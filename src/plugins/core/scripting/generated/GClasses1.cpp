#include "classes.h"

#include "../../../../sdk/entity/CBaseEntity.h"
#include "../../../../sdk/entity/CBaseModelEntity.h"

GCGlowProperty::GCGlowProperty(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCGlowProperty::GCGlowProperty(void *ptr) {
    m_ptr = ptr;
}
Vector GCGlowProperty::GetGlowColor() const {
    return GetSchemaValue<Vector>(m_ptr, "CGlowProperty", "m_fGlowColor");
}
void GCGlowProperty::SetGlowColor(Vector value) {
    SetSchemaValue(m_ptr, "CGlowProperty", "m_fGlowColor", false, value);
}
int32_t GCGlowProperty::GetGlowType() const {
    return GetSchemaValue<int32_t>(m_ptr, "CGlowProperty", "m_iGlowType");
}
void GCGlowProperty::SetGlowType(int32_t value) {
    SetSchemaValue(m_ptr, "CGlowProperty", "m_iGlowType", false, value);
}
int32_t GCGlowProperty::GetGlowTeam() const {
    return GetSchemaValue<int32_t>(m_ptr, "CGlowProperty", "m_iGlowTeam");
}
void GCGlowProperty::SetGlowTeam(int32_t value) {
    SetSchemaValue(m_ptr, "CGlowProperty", "m_iGlowTeam", false, value);
}
int32_t GCGlowProperty::GetGlowRange() const {
    return GetSchemaValue<int32_t>(m_ptr, "CGlowProperty", "m_nGlowRange");
}
void GCGlowProperty::SetGlowRange(int32_t value) {
    SetSchemaValue(m_ptr, "CGlowProperty", "m_nGlowRange", false, value);
}
int32_t GCGlowProperty::GetGlowRangeMin() const {
    return GetSchemaValue<int32_t>(m_ptr, "CGlowProperty", "m_nGlowRangeMin");
}
void GCGlowProperty::SetGlowRangeMin(int32_t value) {
    SetSchemaValue(m_ptr, "CGlowProperty", "m_nGlowRangeMin", false, value);
}
Color GCGlowProperty::GetGlowColorOverride() const {
    return GetSchemaValue<Color>(m_ptr, "CGlowProperty", "m_glowColorOverride");
}
void GCGlowProperty::SetGlowColorOverride(Color value) {
    SetSchemaValue(m_ptr, "CGlowProperty", "m_glowColorOverride", false, value);
}
bool GCGlowProperty::GetFlashing() const {
    return GetSchemaValue<bool>(m_ptr, "CGlowProperty", "m_bFlashing");
}
void GCGlowProperty::SetFlashing(bool value) {
    SetSchemaValue(m_ptr, "CGlowProperty", "m_bFlashing", false, value);
}
float GCGlowProperty::GetGlowTime() const {
    return GetSchemaValue<float>(m_ptr, "CGlowProperty", "m_flGlowTime");
}
void GCGlowProperty::SetGlowTime(float value) {
    SetSchemaValue(m_ptr, "CGlowProperty", "m_flGlowTime", false, value);
}
float GCGlowProperty::GetGlowStartTime() const {
    return GetSchemaValue<float>(m_ptr, "CGlowProperty", "m_flGlowStartTime");
}
void GCGlowProperty::SetGlowStartTime(float value) {
    SetSchemaValue(m_ptr, "CGlowProperty", "m_flGlowStartTime", false, value);
}
bool GCGlowProperty::GetEligibleForScreenHighlight() const {
    return GetSchemaValue<bool>(m_ptr, "CGlowProperty", "m_bEligibleForScreenHighlight");
}
void GCGlowProperty::SetEligibleForScreenHighlight(bool value) {
    SetSchemaValue(m_ptr, "CGlowProperty", "m_bEligibleForScreenHighlight", false, value);
}
bool GCGlowProperty::GetGlowing() const {
    return GetSchemaValue<bool>(m_ptr, "CGlowProperty", "m_bGlowing");
}
void GCGlowProperty::SetGlowing(bool value) {
    SetSchemaValue(m_ptr, "CGlowProperty", "m_bGlowing", false, value);
}
std::string GCGlowProperty::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCGlowProperty::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCGlowProperty(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCGlowProperty>("CGlowProperty")
        .addConstructor<void (*)(std::string)>()
        .addProperty("GlowColor", &GCGlowProperty::GetGlowColor, &GCGlowProperty::SetGlowColor)
        .addProperty("GlowType", &GCGlowProperty::GetGlowType, &GCGlowProperty::SetGlowType)
        .addProperty("GlowTeam", &GCGlowProperty::GetGlowTeam, &GCGlowProperty::SetGlowTeam)
        .addProperty("GlowRange", &GCGlowProperty::GetGlowRange, &GCGlowProperty::SetGlowRange)
        .addProperty("GlowRangeMin", &GCGlowProperty::GetGlowRangeMin, &GCGlowProperty::SetGlowRangeMin)
        .addProperty("GlowColorOverride", &GCGlowProperty::GetGlowColorOverride, &GCGlowProperty::SetGlowColorOverride)
        .addProperty("Flashing", &GCGlowProperty::GetFlashing, &GCGlowProperty::SetFlashing)
        .addProperty("GlowTime", &GCGlowProperty::GetGlowTime, &GCGlowProperty::SetGlowTime)
        .addProperty("GlowStartTime", &GCGlowProperty::GetGlowStartTime, &GCGlowProperty::SetGlowStartTime)
        .addProperty("EligibleForScreenHighlight", &GCGlowProperty::GetEligibleForScreenHighlight, &GCGlowProperty::SetEligibleForScreenHighlight)
        .addProperty("Glowing", &GCGlowProperty::GetGlowing, &GCGlowProperty::SetGlowing)
        .addFunction("ToPtr", &GCGlowProperty::ToPtr)
        .addFunction("IsValid", &GCGlowProperty::IsValid)
        .endClass();
}
GCEntityComponent::GCEntityComponent(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCEntityComponent::GCEntityComponent(void *ptr) {
    m_ptr = ptr;
}
std::string GCEntityComponent::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCEntityComponent::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCEntityComponent(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCEntityComponent>("CEntityComponent")
        .addConstructor<void (*)(std::string)>()
        .addFunction("ToPtr", &GCEntityComponent::ToPtr)
        .addFunction("IsValid", &GCEntityComponent::IsValid)
        .endClass();
}
GCPlayerPawnComponent::GCPlayerPawnComponent(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCPlayerPawnComponent::GCPlayerPawnComponent(void *ptr) {
    m_ptr = ptr;
}
GCNetworkVarChainer GCPlayerPawnComponent::Get__pChainEntity() const {
    GCNetworkVarChainer value(GetSchemaPtr(m_ptr, "CPlayerPawnComponent", "__m_pChainEntity"));
    return value;
}
void GCPlayerPawnComponent::Set__pChainEntity(GCNetworkVarChainer value) {
    SetSchemaValue(m_ptr, "CPlayerPawnComponent", "__m_pChainEntity", false, value);
}
std::string GCPlayerPawnComponent::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCPlayerPawnComponent::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCPlayerPawnComponent(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCPlayerPawnComponent>("CPlayerPawnComponent")
        .addConstructor<void (*)(std::string)>()
        .addProperty("__pChainEntity", &GCPlayerPawnComponent::Get__pChainEntity, &GCPlayerPawnComponent::Set__pChainEntity)
        .addFunction("ToPtr", &GCPlayerPawnComponent::ToPtr)
        .addFunction("IsValid", &GCPlayerPawnComponent::IsValid)
        .endClass();
}
Gfogparams_t::Gfogparams_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
Gfogparams_t::Gfogparams_t(void *ptr) {
    m_ptr = ptr;
}
Vector Gfogparams_t::GetDirPrimary() const {
    return GetSchemaValue<Vector>(m_ptr, "fogparams_t", "dirPrimary");
}
void Gfogparams_t::SetDirPrimary(Vector value) {
    SetSchemaValue(m_ptr, "fogparams_t", "dirPrimary", true, value);
}
Color Gfogparams_t::GetColorPrimary() const {
    return GetSchemaValue<Color>(m_ptr, "fogparams_t", "colorPrimary");
}
void Gfogparams_t::SetColorPrimary(Color value) {
    SetSchemaValue(m_ptr, "fogparams_t", "colorPrimary", true, value);
}
Color Gfogparams_t::GetColorSecondary() const {
    return GetSchemaValue<Color>(m_ptr, "fogparams_t", "colorSecondary");
}
void Gfogparams_t::SetColorSecondary(Color value) {
    SetSchemaValue(m_ptr, "fogparams_t", "colorSecondary", true, value);
}
Color Gfogparams_t::GetColorPrimaryLerpTo() const {
    return GetSchemaValue<Color>(m_ptr, "fogparams_t", "colorPrimaryLerpTo");
}
void Gfogparams_t::SetColorPrimaryLerpTo(Color value) {
    SetSchemaValue(m_ptr, "fogparams_t", "colorPrimaryLerpTo", true, value);
}
Color Gfogparams_t::GetColorSecondaryLerpTo() const {
    return GetSchemaValue<Color>(m_ptr, "fogparams_t", "colorSecondaryLerpTo");
}
void Gfogparams_t::SetColorSecondaryLerpTo(Color value) {
    SetSchemaValue(m_ptr, "fogparams_t", "colorSecondaryLerpTo", true, value);
}
float Gfogparams_t::GetStart() const {
    return GetSchemaValue<float>(m_ptr, "fogparams_t", "start");
}
void Gfogparams_t::SetStart(float value) {
    SetSchemaValue(m_ptr, "fogparams_t", "start", true, value);
}
float Gfogparams_t::GetEnd() const {
    return GetSchemaValue<float>(m_ptr, "fogparams_t", "end");
}
void Gfogparams_t::SetEnd(float value) {
    SetSchemaValue(m_ptr, "fogparams_t", "end", true, value);
}
float Gfogparams_t::GetFarz() const {
    return GetSchemaValue<float>(m_ptr, "fogparams_t", "farz");
}
void Gfogparams_t::SetFarz(float value) {
    SetSchemaValue(m_ptr, "fogparams_t", "farz", true, value);
}
float Gfogparams_t::GetMaxdensity() const {
    return GetSchemaValue<float>(m_ptr, "fogparams_t", "maxdensity");
}
void Gfogparams_t::SetMaxdensity(float value) {
    SetSchemaValue(m_ptr, "fogparams_t", "maxdensity", true, value);
}
float Gfogparams_t::GetExponent() const {
    return GetSchemaValue<float>(m_ptr, "fogparams_t", "exponent");
}
void Gfogparams_t::SetExponent(float value) {
    SetSchemaValue(m_ptr, "fogparams_t", "exponent", true, value);
}
float Gfogparams_t::GetHDRColorScale() const {
    return GetSchemaValue<float>(m_ptr, "fogparams_t", "HDRColorScale");
}
void Gfogparams_t::SetHDRColorScale(float value) {
    SetSchemaValue(m_ptr, "fogparams_t", "HDRColorScale", true, value);
}
float Gfogparams_t::GetSkyboxFogFactor() const {
    return GetSchemaValue<float>(m_ptr, "fogparams_t", "skyboxFogFactor");
}
void Gfogparams_t::SetSkyboxFogFactor(float value) {
    SetSchemaValue(m_ptr, "fogparams_t", "skyboxFogFactor", true, value);
}
float Gfogparams_t::GetSkyboxFogFactorLerpTo() const {
    return GetSchemaValue<float>(m_ptr, "fogparams_t", "skyboxFogFactorLerpTo");
}
void Gfogparams_t::SetSkyboxFogFactorLerpTo(float value) {
    SetSchemaValue(m_ptr, "fogparams_t", "skyboxFogFactorLerpTo", true, value);
}
float Gfogparams_t::GetStartLerpTo() const {
    return GetSchemaValue<float>(m_ptr, "fogparams_t", "startLerpTo");
}
void Gfogparams_t::SetStartLerpTo(float value) {
    SetSchemaValue(m_ptr, "fogparams_t", "startLerpTo", true, value);
}
float Gfogparams_t::GetEndLerpTo() const {
    return GetSchemaValue<float>(m_ptr, "fogparams_t", "endLerpTo");
}
void Gfogparams_t::SetEndLerpTo(float value) {
    SetSchemaValue(m_ptr, "fogparams_t", "endLerpTo", true, value);
}
float Gfogparams_t::GetMaxdensityLerpTo() const {
    return GetSchemaValue<float>(m_ptr, "fogparams_t", "maxdensityLerpTo");
}
void Gfogparams_t::SetMaxdensityLerpTo(float value) {
    SetSchemaValue(m_ptr, "fogparams_t", "maxdensityLerpTo", true, value);
}
float Gfogparams_t::GetLerptime() const {
    return GetSchemaValue<float>(m_ptr, "fogparams_t", "lerptime");
}
void Gfogparams_t::SetLerptime(float value) {
    SetSchemaValue(m_ptr, "fogparams_t", "lerptime", true, value);
}
float Gfogparams_t::GetDuration() const {
    return GetSchemaValue<float>(m_ptr, "fogparams_t", "duration");
}
void Gfogparams_t::SetDuration(float value) {
    SetSchemaValue(m_ptr, "fogparams_t", "duration", true, value);
}
float Gfogparams_t::GetBlendtobackground() const {
    return GetSchemaValue<float>(m_ptr, "fogparams_t", "blendtobackground");
}
void Gfogparams_t::SetBlendtobackground(float value) {
    SetSchemaValue(m_ptr, "fogparams_t", "blendtobackground", true, value);
}
float Gfogparams_t::GetScattering() const {
    return GetSchemaValue<float>(m_ptr, "fogparams_t", "scattering");
}
void Gfogparams_t::SetScattering(float value) {
    SetSchemaValue(m_ptr, "fogparams_t", "scattering", true, value);
}
float Gfogparams_t::GetLocallightscale() const {
    return GetSchemaValue<float>(m_ptr, "fogparams_t", "locallightscale");
}
void Gfogparams_t::SetLocallightscale(float value) {
    SetSchemaValue(m_ptr, "fogparams_t", "locallightscale", true, value);
}
bool Gfogparams_t::GetEnable() const {
    return GetSchemaValue<bool>(m_ptr, "fogparams_t", "enable");
}
void Gfogparams_t::SetEnable(bool value) {
    SetSchemaValue(m_ptr, "fogparams_t", "enable", true, value);
}
bool Gfogparams_t::GetBlend() const {
    return GetSchemaValue<bool>(m_ptr, "fogparams_t", "blend");
}
void Gfogparams_t::SetBlend(bool value) {
    SetSchemaValue(m_ptr, "fogparams_t", "blend", true, value);
}
bool Gfogparams_t::GetNoReflectionFog() const {
    return GetSchemaValue<bool>(m_ptr, "fogparams_t", "m_bNoReflectionFog");
}
void Gfogparams_t::SetNoReflectionFog(bool value) {
    SetSchemaValue(m_ptr, "fogparams_t", "m_bNoReflectionFog", true, value);
}
bool Gfogparams_t::GetPadding() const {
    return GetSchemaValue<bool>(m_ptr, "fogparams_t", "m_bPadding");
}
void Gfogparams_t::SetPadding(bool value) {
    SetSchemaValue(m_ptr, "fogparams_t", "m_bPadding", true, value);
}
std::string Gfogparams_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool Gfogparams_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassfogparams_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<Gfogparams_t>("fogparams_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("DirPrimary", &Gfogparams_t::GetDirPrimary, &Gfogparams_t::SetDirPrimary)
        .addProperty("ColorPrimary", &Gfogparams_t::GetColorPrimary, &Gfogparams_t::SetColorPrimary)
        .addProperty("ColorSecondary", &Gfogparams_t::GetColorSecondary, &Gfogparams_t::SetColorSecondary)
        .addProperty("ColorPrimaryLerpTo", &Gfogparams_t::GetColorPrimaryLerpTo, &Gfogparams_t::SetColorPrimaryLerpTo)
        .addProperty("ColorSecondaryLerpTo", &Gfogparams_t::GetColorSecondaryLerpTo, &Gfogparams_t::SetColorSecondaryLerpTo)
        .addProperty("Start", &Gfogparams_t::GetStart, &Gfogparams_t::SetStart)
        .addProperty("End", &Gfogparams_t::GetEnd, &Gfogparams_t::SetEnd)
        .addProperty("Farz", &Gfogparams_t::GetFarz, &Gfogparams_t::SetFarz)
        .addProperty("Maxdensity", &Gfogparams_t::GetMaxdensity, &Gfogparams_t::SetMaxdensity)
        .addProperty("Exponent", &Gfogparams_t::GetExponent, &Gfogparams_t::SetExponent)
        .addProperty("HDRColorScale", &Gfogparams_t::GetHDRColorScale, &Gfogparams_t::SetHDRColorScale)
        .addProperty("SkyboxFogFactor", &Gfogparams_t::GetSkyboxFogFactor, &Gfogparams_t::SetSkyboxFogFactor)
        .addProperty("SkyboxFogFactorLerpTo", &Gfogparams_t::GetSkyboxFogFactorLerpTo, &Gfogparams_t::SetSkyboxFogFactorLerpTo)
        .addProperty("StartLerpTo", &Gfogparams_t::GetStartLerpTo, &Gfogparams_t::SetStartLerpTo)
        .addProperty("EndLerpTo", &Gfogparams_t::GetEndLerpTo, &Gfogparams_t::SetEndLerpTo)
        .addProperty("MaxdensityLerpTo", &Gfogparams_t::GetMaxdensityLerpTo, &Gfogparams_t::SetMaxdensityLerpTo)
        .addProperty("Lerptime", &Gfogparams_t::GetLerptime, &Gfogparams_t::SetLerptime)
        .addProperty("Duration", &Gfogparams_t::GetDuration, &Gfogparams_t::SetDuration)
        .addProperty("Blendtobackground", &Gfogparams_t::GetBlendtobackground, &Gfogparams_t::SetBlendtobackground)
        .addProperty("Scattering", &Gfogparams_t::GetScattering, &Gfogparams_t::SetScattering)
        .addProperty("Locallightscale", &Gfogparams_t::GetLocallightscale, &Gfogparams_t::SetLocallightscale)
        .addProperty("Enable", &Gfogparams_t::GetEnable, &Gfogparams_t::SetEnable)
        .addProperty("Blend", &Gfogparams_t::GetBlend, &Gfogparams_t::SetBlend)
        .addProperty("NoReflectionFog", &Gfogparams_t::GetNoReflectionFog, &Gfogparams_t::SetNoReflectionFog)
        .addProperty("Padding", &Gfogparams_t::GetPadding, &Gfogparams_t::SetPadding)
        .addFunction("ToPtr", &Gfogparams_t::ToPtr)
        .addFunction("IsValid", &Gfogparams_t::IsValid)
        .endClass();
}
GCNetworkTransmitComponent::GCNetworkTransmitComponent(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCNetworkTransmitComponent::GCNetworkTransmitComponent(void *ptr) {
    m_ptr = ptr;
}
uint8_t GCNetworkTransmitComponent::GetTransmitStateOwnedCounter() const {
    return GetSchemaValue<uint8_t>(m_ptr, "CNetworkTransmitComponent", "m_nTransmitStateOwnedCounter");
}
void GCNetworkTransmitComponent::SetTransmitStateOwnedCounter(uint8_t value) {
    SetSchemaValue(m_ptr, "CNetworkTransmitComponent", "m_nTransmitStateOwnedCounter", false, value);
}
std::string GCNetworkTransmitComponent::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCNetworkTransmitComponent::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCNetworkTransmitComponent(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCNetworkTransmitComponent>("CNetworkTransmitComponent")
        .addConstructor<void (*)(std::string)>()
        .addProperty("TransmitStateOwnedCounter", &GCNetworkTransmitComponent::GetTransmitStateOwnedCounter, &GCNetworkTransmitComponent::SetTransmitStateOwnedCounter)
        .addFunction("ToPtr", &GCNetworkTransmitComponent::ToPtr)
        .addFunction("IsValid", &GCNetworkTransmitComponent::IsValid)
        .endClass();
}
GCNetworkViewOffsetVector::GCNetworkViewOffsetVector(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCNetworkViewOffsetVector::GCNetworkViewOffsetVector(void *ptr) {
    m_ptr = ptr;
}
float GCNetworkViewOffsetVector::GetX() const {
    return GetSchemaValue<float>(m_ptr, "CNetworkViewOffsetVector", "m_vecX");
}
void GCNetworkViewOffsetVector::SetX(float value) {
    SetSchemaValue(m_ptr, "CNetworkViewOffsetVector", "m_vecX", false, value);
}
float GCNetworkViewOffsetVector::GetY() const {
    return GetSchemaValue<float>(m_ptr, "CNetworkViewOffsetVector", "m_vecY");
}
void GCNetworkViewOffsetVector::SetY(float value) {
    SetSchemaValue(m_ptr, "CNetworkViewOffsetVector", "m_vecY", false, value);
}
float GCNetworkViewOffsetVector::GetZ() const {
    return GetSchemaValue<float>(m_ptr, "CNetworkViewOffsetVector", "m_vecZ");
}
void GCNetworkViewOffsetVector::SetZ(float value) {
    SetSchemaValue(m_ptr, "CNetworkViewOffsetVector", "m_vecZ", false, value);
}
std::string GCNetworkViewOffsetVector::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCNetworkViewOffsetVector::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCNetworkViewOffsetVector(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCNetworkViewOffsetVector>("CNetworkViewOffsetVector")
        .addConstructor<void (*)(std::string)>()
        .addProperty("X", &GCNetworkViewOffsetVector::GetX, &GCNetworkViewOffsetVector::SetX)
        .addProperty("Y", &GCNetworkViewOffsetVector::GetY, &GCNetworkViewOffsetVector::SetY)
        .addProperty("Z", &GCNetworkViewOffsetVector::GetZ, &GCNetworkViewOffsetVector::SetZ)
        .addFunction("ToPtr", &GCNetworkViewOffsetVector::ToPtr)
        .addFunction("IsValid", &GCNetworkViewOffsetVector::IsValid)
        .endClass();
}
GCNetworkVelocityVector::GCNetworkVelocityVector(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCNetworkVelocityVector::GCNetworkVelocityVector(void *ptr) {
    m_ptr = ptr;
}
float GCNetworkVelocityVector::GetX() const {
    return GetSchemaValue<float>(m_ptr, "CNetworkVelocityVector", "m_vecX");
}
void GCNetworkVelocityVector::SetX(float value) {
    SetSchemaValue(m_ptr, "CNetworkVelocityVector", "m_vecX", false, value);
}
float GCNetworkVelocityVector::GetY() const {
    return GetSchemaValue<float>(m_ptr, "CNetworkVelocityVector", "m_vecY");
}
void GCNetworkVelocityVector::SetY(float value) {
    SetSchemaValue(m_ptr, "CNetworkVelocityVector", "m_vecY", false, value);
}
float GCNetworkVelocityVector::GetZ() const {
    return GetSchemaValue<float>(m_ptr, "CNetworkVelocityVector", "m_vecZ");
}
void GCNetworkVelocityVector::SetZ(float value) {
    SetSchemaValue(m_ptr, "CNetworkVelocityVector", "m_vecZ", false, value);
}
std::string GCNetworkVelocityVector::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCNetworkVelocityVector::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCNetworkVelocityVector(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCNetworkVelocityVector>("CNetworkVelocityVector")
        .addConstructor<void (*)(std::string)>()
        .addProperty("X", &GCNetworkVelocityVector::GetX, &GCNetworkVelocityVector::SetX)
        .addProperty("Y", &GCNetworkVelocityVector::GetY, &GCNetworkVelocityVector::SetY)
        .addProperty("Z", &GCNetworkVelocityVector::GetZ, &GCNetworkVelocityVector::SetZ)
        .addFunction("ToPtr", &GCNetworkVelocityVector::ToPtr)
        .addFunction("IsValid", &GCNetworkVelocityVector::IsValid)
        .endClass();
}
GCEntityInstance::GCEntityInstance(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCEntityInstance::GCEntityInstance(void *ptr) {
    m_ptr = ptr;
}
std::string GCEntityInstance::GetPrivateVScripts() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CEntityInstance", "m_iszPrivateVScripts").String();
}
void GCEntityInstance::SetPrivateVScripts(std::string value) {
    SetSchemaValue(m_ptr, "CEntityInstance", "m_iszPrivateVScripts", false, CUtlSymbolLarge(value.c_str()));
}
GCEntityIdentity GCEntityInstance::GetEntity() const {
    GCEntityIdentity value(*GetSchemaValuePtr<void*>(m_ptr, "CEntityInstance", "m_pEntity"));
    return value;
}
void GCEntityInstance::SetEntity(GCEntityIdentity* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Entity' is not possible.\n");
}
GCScriptComponent GCEntityInstance::GetCScriptComponent() const {
    GCScriptComponent value(*GetSchemaValuePtr<void*>(m_ptr, "CEntityInstance", "m_CScriptComponent"));
    return value;
}
void GCEntityInstance::SetCScriptComponent(GCScriptComponent* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'CScriptComponent' is not possible.\n");
}
bool GCEntityInstance::GetVisibleinPVS() const {
    return GetSchemaValue<bool>(m_ptr, "CEntityInstance", "m_bVisibleinPVS");
}
void GCEntityInstance::SetVisibleinPVS(bool value) {
    SetSchemaValue(m_ptr, "CEntityInstance", "m_bVisibleinPVS", false, value);
}
std::string GCEntityInstance::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCEntityInstance::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCEntityInstance(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCEntityInstance>("CEntityInstance")
        .addConstructor<void (*)(std::string)>()
        .addProperty("PrivateVScripts", &GCEntityInstance::GetPrivateVScripts, &GCEntityInstance::SetPrivateVScripts)
        .addProperty("Entity", &GCEntityInstance::GetEntity, &GCEntityInstance::SetEntity)
        .addProperty("CScriptComponent", &GCEntityInstance::GetCScriptComponent, &GCEntityInstance::SetCScriptComponent)
        .addProperty("VisibleinPVS", &GCEntityInstance::GetVisibleinPVS, &GCEntityInstance::SetVisibleinPVS)
        .addFunction("ToPtr", &GCEntityInstance::ToPtr)
        .addFunction("IsValid", &GCEntityInstance::IsValid)
        .endClass();
}
GCBaseEntity::GCBaseEntity(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCBaseEntity::GCBaseEntity(void *ptr) {
    m_ptr = ptr;
}
void GCBaseEntity::Spawn() {
    ((Z_CBaseEntity*)m_ptr)->Spawn();
}
void GCBaseEntity::Despawn() {
    ((Z_CBaseEntity*)m_ptr)->Despawn();
}
void GCBaseEntity::AcceptInput(std::string input, GCEntityInstance activator, GCEntityInstance caller, std::string value, int outputID) {
    ((Z_CBaseEntity*)m_ptr)->AcceptInput(input.c_str(), (CEntityInstance*)(strtoul(activator.ToPtr().c_str(), nullptr, 16)), (CEntityInstance*)(strtoul(caller.ToPtr().c_str(), nullptr, 16)), value.c_str(), outputID);
}
std::string GCBaseEntity::GetClassname() {
    return ((Z_CBaseEntity*)m_ptr)->GetClassname();
}
GCEntitySubclassVDataBase GCBaseEntity::GetVData() {
    return GCEntitySubclassVDataBase(((Z_CBaseEntity*)m_ptr)->GetVData());
}
void GCBaseEntity::Teleport(Vector value) {
    ((Z_CBaseEntity*)m_ptr)->Teleport(&value, nullptr, nullptr);
}
GCBodyComponent GCBaseEntity::GetCBodyComponent() const {
    GCBodyComponent value(*GetSchemaValuePtr<void*>(m_ptr, "CBaseEntity", "m_CBodyComponent"));
    return value;
}
void GCBaseEntity::SetCBodyComponent(GCBodyComponent* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'CBodyComponent' is not possible.\n");
}
GCNetworkTransmitComponent GCBaseEntity::GetNetworkTransmitComponent() const {
    GCNetworkTransmitComponent value(GetSchemaPtr(m_ptr, "CBaseEntity", "m_NetworkTransmitComponent"));
    return value;
}
void GCBaseEntity::SetNetworkTransmitComponent(GCNetworkTransmitComponent value) {
    SetSchemaValue(m_ptr, "CBaseEntity", "m_NetworkTransmitComponent", false, value);
}
std::vector<Gthinkfunc_t> GCBaseEntity::GetThinkFunctions() const {
    CUtlVector<Gthinkfunc_t>* vec = GetSchemaValue<CUtlVector<Gthinkfunc_t>*>(m_ptr, "CBaseEntity", "m_aThinkFunctions"); std::vector<Gthinkfunc_t> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCBaseEntity::SetThinkFunctions(std::vector<Gthinkfunc_t> value) {
    SetSchemaValueCUtlVector<Gthinkfunc_t>(m_ptr, "CBaseEntity", "m_aThinkFunctions", false, value);
}
int32_t GCBaseEntity::GetCurrentThinkContext() const {
    return GetSchemaValue<int32_t>(m_ptr, "CBaseEntity", "m_iCurrentThinkContext");
}
void GCBaseEntity::SetCurrentThinkContext(int32_t value) {
    SetSchemaValue(m_ptr, "CBaseEntity", "m_iCurrentThinkContext", false, value);
}
int32 GCBaseEntity::GetLastThinkTick() const {
    return GetSchemaValue<int32>(m_ptr, "CBaseEntity", "m_nLastThinkTick");
}
void GCBaseEntity::SetLastThinkTick(int32 value) {
    SetSchemaValue(m_ptr, "CBaseEntity", "m_nLastThinkTick", false, value);
}
bool GCBaseEntity::GetDisabledContextThinks() const {
    return GetSchemaValue<bool>(m_ptr, "CBaseEntity", "m_bDisabledContextThinks");
}
void GCBaseEntity::SetDisabledContextThinks(bool value) {
    SetSchemaValue(m_ptr, "CBaseEntity", "m_bDisabledContextThinks", false, value);
}
float GCBaseEntity::GetLastNetworkChange() const {
    return GetSchemaValue<float>(m_ptr, "CBaseEntity", "m_lastNetworkChange");
}
void GCBaseEntity::SetLastNetworkChange(float value) {
    SetSchemaValue(m_ptr, "CBaseEntity", "m_lastNetworkChange", false, value);
}
std::vector<GResponseContext_t> GCBaseEntity::GetResponseContexts() const {
    CUtlVector<GResponseContext_t>* vec = GetSchemaValue<CUtlVector<GResponseContext_t>*>(m_ptr, "CBaseEntity", "m_ResponseContexts"); std::vector<GResponseContext_t> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCBaseEntity::SetResponseContexts(std::vector<GResponseContext_t> value) {
    SetSchemaValueCUtlVector<GResponseContext_t>(m_ptr, "CBaseEntity", "m_ResponseContexts", false, value);
}
std::string GCBaseEntity::GetResponseContext() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CBaseEntity", "m_iszResponseContext").String();
}
void GCBaseEntity::SetResponseContext(std::string value) {
    SetSchemaValue(m_ptr, "CBaseEntity", "m_iszResponseContext", false, CUtlSymbolLarge(value.c_str()));
}
int32_t GCBaseEntity::GetHealth() const {
    return GetSchemaValue<int32_t>(m_ptr, "CBaseEntity", "m_iHealth");
}
void GCBaseEntity::SetHealth(int32_t value) {
    SetSchemaValue(m_ptr, "CBaseEntity", "m_iHealth", false, value);
}
int32_t GCBaseEntity::GetMaxHealth() const {
    return GetSchemaValue<int32_t>(m_ptr, "CBaseEntity", "m_iMaxHealth");
}
void GCBaseEntity::SetMaxHealth(int32_t value) {
    SetSchemaValue(m_ptr, "CBaseEntity", "m_iMaxHealth", false, value);
}
uint8_t GCBaseEntity::GetLifeState() const {
    return GetSchemaValue<uint8_t>(m_ptr, "CBaseEntity", "m_lifeState");
}
void GCBaseEntity::SetLifeState(uint8_t value) {
    SetSchemaValue(m_ptr, "CBaseEntity", "m_lifeState", false, value);
}
float GCBaseEntity::GetDamageAccumulator() const {
    return GetSchemaValue<float>(m_ptr, "CBaseEntity", "m_flDamageAccumulator");
}
void GCBaseEntity::SetDamageAccumulator(float value) {
    SetSchemaValue(m_ptr, "CBaseEntity", "m_flDamageAccumulator", false, value);
}
bool GCBaseEntity::GetTakesDamage() const {
    return GetSchemaValue<bool>(m_ptr, "CBaseEntity", "m_bTakesDamage");
}
void GCBaseEntity::SetTakesDamage(bool value) {
    SetSchemaValue(m_ptr, "CBaseEntity", "m_bTakesDamage", false, value);
}
uint64_t GCBaseEntity::GetTakeDamageFlags() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CBaseEntity", "m_nTakeDamageFlags");
}
void GCBaseEntity::SetTakeDamageFlags(uint64_t value) {
    SetSchemaValue(m_ptr, "CBaseEntity", "m_nTakeDamageFlags", false, value);
}
bool GCBaseEntity::GetIsPlatform() const {
    return GetSchemaValue<bool>(m_ptr, "CBaseEntity", "m_bIsPlatform");
}
void GCBaseEntity::SetIsPlatform(bool value) {
    SetSchemaValue(m_ptr, "CBaseEntity", "m_bIsPlatform", false, value);
}
uint64_t GCBaseEntity::GetMoveCollide() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CBaseEntity", "m_MoveCollide");
}
void GCBaseEntity::SetMoveCollide(uint64_t value) {
    SetSchemaValue(m_ptr, "CBaseEntity", "m_MoveCollide", false, value);
}
uint64_t GCBaseEntity::GetMoveType() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CBaseEntity", "m_MoveType");
}
void GCBaseEntity::SetMoveType(uint64_t value) {
    SetSchemaValue(m_ptr, "CBaseEntity", "m_MoveType", false, value);
}
uint64_t GCBaseEntity::GetActualMoveType() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CBaseEntity", "m_nActualMoveType");
}
void GCBaseEntity::SetActualMoveType(uint64_t value) {
    SetSchemaValue(m_ptr, "CBaseEntity", "m_nActualMoveType", false, value);
}
uint8_t GCBaseEntity::GetWaterTouch() const {
    return GetSchemaValue<uint8_t>(m_ptr, "CBaseEntity", "m_nWaterTouch");
}
void GCBaseEntity::SetWaterTouch(uint8_t value) {
    SetSchemaValue(m_ptr, "CBaseEntity", "m_nWaterTouch", false, value);
}
uint8_t GCBaseEntity::GetSlimeTouch() const {
    return GetSchemaValue<uint8_t>(m_ptr, "CBaseEntity", "m_nSlimeTouch");
}
void GCBaseEntity::SetSlimeTouch(uint8_t value) {
    SetSchemaValue(m_ptr, "CBaseEntity", "m_nSlimeTouch", false, value);
}
bool GCBaseEntity::GetRestoreInHierarchy() const {
    return GetSchemaValue<bool>(m_ptr, "CBaseEntity", "m_bRestoreInHierarchy");
}
void GCBaseEntity::SetRestoreInHierarchy(bool value) {
    SetSchemaValue(m_ptr, "CBaseEntity", "m_bRestoreInHierarchy", false, value);
}
std::string GCBaseEntity::GetTarget() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CBaseEntity", "m_target").String();
}
void GCBaseEntity::SetTarget(std::string value) {
    SetSchemaValue(m_ptr, "CBaseEntity", "m_target", false, CUtlSymbolLarge(value.c_str()));
}
GCBaseFilter GCBaseEntity::GetDamageFilter() const {
    GCBaseFilter value(*GetSchemaValuePtr<void*>(m_ptr, "CBaseEntity", "m_hDamageFilter"));
    return value;
}
void GCBaseEntity::SetDamageFilter(GCBaseFilter* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'DamageFilter' is not possible.\n");
}
std::string GCBaseEntity::GetDamageFilterName() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CBaseEntity", "m_iszDamageFilterName").String();
}
void GCBaseEntity::SetDamageFilterName(std::string value) {
    SetSchemaValue(m_ptr, "CBaseEntity", "m_iszDamageFilterName", false, CUtlSymbolLarge(value.c_str()));
}
float GCBaseEntity::GetMoveDoneTime() const {
    return GetSchemaValue<float>(m_ptr, "CBaseEntity", "m_flMoveDoneTime");
}
void GCBaseEntity::SetMoveDoneTime(float value) {
    SetSchemaValue(m_ptr, "CBaseEntity", "m_flMoveDoneTime", false, value);
}
CUtlStringToken GCBaseEntity::GetSubclassID() const {
    return GetSchemaValue<CUtlStringToken>(m_ptr, "CBaseEntity", "m_nSubclassID");
}
void GCBaseEntity::SetSubclassID(CUtlStringToken value) {
    SetSchemaValue(m_ptr, "CBaseEntity", "m_nSubclassID", false, value);
}
float GCBaseEntity::GetAnimTime() const {
    return GetSchemaValue<float>(m_ptr, "CBaseEntity", "m_flAnimTime");
}
void GCBaseEntity::SetAnimTime(float value) {
    SetSchemaValue(m_ptr, "CBaseEntity", "m_flAnimTime", false, value);
}
float GCBaseEntity::GetSimulationTime() const {
    return GetSchemaValue<float>(m_ptr, "CBaseEntity", "m_flSimulationTime");
}
void GCBaseEntity::SetSimulationTime(float value) {
    SetSchemaValue(m_ptr, "CBaseEntity", "m_flSimulationTime", false, value);
}
float GCBaseEntity::GetCreateTime() const {
    return GetSchemaValue<float>(m_ptr, "CBaseEntity", "m_flCreateTime");
}
void GCBaseEntity::SetCreateTime(float value) {
    SetSchemaValue(m_ptr, "CBaseEntity", "m_flCreateTime", false, value);
}
bool GCBaseEntity::GetClientSideRagdoll() const {
    return GetSchemaValue<bool>(m_ptr, "CBaseEntity", "m_bClientSideRagdoll");
}
void GCBaseEntity::SetClientSideRagdoll(bool value) {
    SetSchemaValue(m_ptr, "CBaseEntity", "m_bClientSideRagdoll", false, value);
}
uint8_t GCBaseEntity::GetInterpolationFrame() const {
    return GetSchemaValue<uint8_t>(m_ptr, "CBaseEntity", "m_ubInterpolationFrame");
}
void GCBaseEntity::SetInterpolationFrame(uint8_t value) {
    SetSchemaValue(m_ptr, "CBaseEntity", "m_ubInterpolationFrame", false, value);
}
Vector GCBaseEntity::GetPrevVPhysicsUpdatePos() const {
    return GetSchemaValue<Vector>(m_ptr, "CBaseEntity", "m_vPrevVPhysicsUpdatePos");
}
void GCBaseEntity::SetPrevVPhysicsUpdatePos(Vector value) {
    SetSchemaValue(m_ptr, "CBaseEntity", "m_vPrevVPhysicsUpdatePos", false, value);
}
uint8_t GCBaseEntity::GetTeamNum() const {
    return GetSchemaValue<uint8_t>(m_ptr, "CBaseEntity", "m_iTeamNum");
}
void GCBaseEntity::SetTeamNum(uint8_t value) {
    SetSchemaValue(m_ptr, "CBaseEntity", "m_iTeamNum", false, value);
}
std::string GCBaseEntity::GetGlobalname() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CBaseEntity", "m_iGlobalname").String();
}
void GCBaseEntity::SetGlobalname(std::string value) {
    SetSchemaValue(m_ptr, "CBaseEntity", "m_iGlobalname", false, CUtlSymbolLarge(value.c_str()));
}
int32_t GCBaseEntity::GetSentToClients() const {
    return GetSchemaValue<int32_t>(m_ptr, "CBaseEntity", "m_iSentToClients");
}
void GCBaseEntity::SetSentToClients(int32_t value) {
    SetSchemaValue(m_ptr, "CBaseEntity", "m_iSentToClients", false, value);
}
float GCBaseEntity::GetSpeed() const {
    return GetSchemaValue<float>(m_ptr, "CBaseEntity", "m_flSpeed");
}
void GCBaseEntity::SetSpeed(float value) {
    SetSchemaValue(m_ptr, "CBaseEntity", "m_flSpeed", false, value);
}
std::string GCBaseEntity::GetUniqueHammerID() const {
    return GetSchemaValue<CUtlString>(m_ptr, "CBaseEntity", "m_sUniqueHammerID").Get();
}
void GCBaseEntity::SetUniqueHammerID(std::string value) {
    SetSchemaValue(m_ptr, "CBaseEntity", "m_sUniqueHammerID", false, CUtlString(value.c_str()));
}
uint32_t GCBaseEntity::GetSpawnflags() const {
    return GetSchemaValue<uint32_t>(m_ptr, "CBaseEntity", "m_spawnflags");
}
void GCBaseEntity::SetSpawnflags(uint32_t value) {
    SetSchemaValue(m_ptr, "CBaseEntity", "m_spawnflags", false, value);
}
int32 GCBaseEntity::GetNextThinkTick() const {
    return GetSchemaValue<int32>(m_ptr, "CBaseEntity", "m_nNextThinkTick");
}
void GCBaseEntity::SetNextThinkTick(int32 value) {
    SetSchemaValue(m_ptr, "CBaseEntity", "m_nNextThinkTick", false, value);
}
int32_t GCBaseEntity::GetSimulationTick() const {
    return GetSchemaValue<int32_t>(m_ptr, "CBaseEntity", "m_nSimulationTick");
}
void GCBaseEntity::SetSimulationTick(int32_t value) {
    SetSchemaValue(m_ptr, "CBaseEntity", "m_nSimulationTick", false, value);
}
GCEntityIOOutput GCBaseEntity::GetOnKilled() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CBaseEntity", "m_OnKilled"));
    return value;
}
void GCBaseEntity::SetOnKilled(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CBaseEntity", "m_OnKilled", false, value);
}
uint32_t GCBaseEntity::GetFlags() const {
    return GetSchemaValue<uint32_t>(m_ptr, "CBaseEntity", "m_fFlags");
}
void GCBaseEntity::SetFlags(uint32_t value) {
    SetSchemaValue(m_ptr, "CBaseEntity", "m_fFlags", false, value);
}
Vector GCBaseEntity::GetAbsVelocity() const {
    return GetSchemaValue<Vector>(m_ptr, "CBaseEntity", "m_vecAbsVelocity");
}
void GCBaseEntity::SetAbsVelocity(Vector value) {
    SetSchemaValue(m_ptr, "CBaseEntity", "m_vecAbsVelocity", false, value);
}
GCNetworkVelocityVector GCBaseEntity::GetVelocity() const {
    GCNetworkVelocityVector value(GetSchemaPtr(m_ptr, "CBaseEntity", "m_vecVelocity"));
    return value;
}
void GCBaseEntity::SetVelocity(GCNetworkVelocityVector value) {
    SetSchemaValue(m_ptr, "CBaseEntity", "m_vecVelocity", false, value);
}
Vector GCBaseEntity::GetBaseVelocity() const {
    return GetSchemaValue<Vector>(m_ptr, "CBaseEntity", "m_vecBaseVelocity");
}
void GCBaseEntity::SetBaseVelocity(Vector value) {
    SetSchemaValue(m_ptr, "CBaseEntity", "m_vecBaseVelocity", false, value);
}
int32_t GCBaseEntity::GetPushEnumCount() const {
    return GetSchemaValue<int32_t>(m_ptr, "CBaseEntity", "m_nPushEnumCount");
}
void GCBaseEntity::SetPushEnumCount(int32_t value) {
    SetSchemaValue(m_ptr, "CBaseEntity", "m_nPushEnumCount", false, value);
}
GCCollisionProperty GCBaseEntity::GetCollision() const {
    GCCollisionProperty value(*GetSchemaValuePtr<void*>(m_ptr, "CBaseEntity", "m_pCollision"));
    return value;
}
void GCBaseEntity::SetCollision(GCCollisionProperty* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Collision' is not possible.\n");
}
GCBaseEntity GCBaseEntity::GetEffectEntity() const {
    GCBaseEntity value(*GetSchemaValuePtr<void*>(m_ptr, "CBaseEntity", "m_hEffectEntity"));
    return value;
}
void GCBaseEntity::SetEffectEntity(GCBaseEntity* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'EffectEntity' is not possible.\n");
}
GCBaseEntity GCBaseEntity::GetOwnerEntity() const {
    GCBaseEntity value(*GetSchemaValuePtr<void*>(m_ptr, "CBaseEntity", "m_hOwnerEntity"));
    return value;
}
void GCBaseEntity::SetOwnerEntity(GCBaseEntity* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'OwnerEntity' is not possible.\n");
}
uint32_t GCBaseEntity::GetEffects() const {
    return GetSchemaValue<uint32_t>(m_ptr, "CBaseEntity", "m_fEffects");
}
void GCBaseEntity::SetEffects(uint32_t value) {
    SetSchemaValue(m_ptr, "CBaseEntity", "m_fEffects", false, value);
}
GCBaseEntity GCBaseEntity::GetGroundEntity() const {
    GCBaseEntity value(*GetSchemaValuePtr<void*>(m_ptr, "CBaseEntity", "m_hGroundEntity"));
    return value;
}
void GCBaseEntity::SetGroundEntity(GCBaseEntity* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'GroundEntity' is not possible.\n");
}
int32_t GCBaseEntity::GetGroundBodyIndex() const {
    return GetSchemaValue<int32_t>(m_ptr, "CBaseEntity", "m_nGroundBodyIndex");
}
void GCBaseEntity::SetGroundBodyIndex(int32_t value) {
    SetSchemaValue(m_ptr, "CBaseEntity", "m_nGroundBodyIndex", false, value);
}
float GCBaseEntity::GetFriction() const {
    return GetSchemaValue<float>(m_ptr, "CBaseEntity", "m_flFriction");
}
void GCBaseEntity::SetFriction(float value) {
    SetSchemaValue(m_ptr, "CBaseEntity", "m_flFriction", false, value);
}
float GCBaseEntity::GetElasticity() const {
    return GetSchemaValue<float>(m_ptr, "CBaseEntity", "m_flElasticity");
}
void GCBaseEntity::SetElasticity(float value) {
    SetSchemaValue(m_ptr, "CBaseEntity", "m_flElasticity", false, value);
}
float GCBaseEntity::GetGravityScale() const {
    return GetSchemaValue<float>(m_ptr, "CBaseEntity", "m_flGravityScale");
}
void GCBaseEntity::SetGravityScale(float value) {
    SetSchemaValue(m_ptr, "CBaseEntity", "m_flGravityScale", false, value);
}
float GCBaseEntity::GetTimeScale() const {
    return GetSchemaValue<float>(m_ptr, "CBaseEntity", "m_flTimeScale");
}
void GCBaseEntity::SetTimeScale(float value) {
    SetSchemaValue(m_ptr, "CBaseEntity", "m_flTimeScale", false, value);
}
float GCBaseEntity::GetWaterLevel() const {
    return GetSchemaValue<float>(m_ptr, "CBaseEntity", "m_flWaterLevel");
}
void GCBaseEntity::SetWaterLevel(float value) {
    SetSchemaValue(m_ptr, "CBaseEntity", "m_flWaterLevel", false, value);
}
bool GCBaseEntity::GetAnimatedEveryTick() const {
    return GetSchemaValue<bool>(m_ptr, "CBaseEntity", "m_bAnimatedEveryTick");
}
void GCBaseEntity::SetAnimatedEveryTick(bool value) {
    SetSchemaValue(m_ptr, "CBaseEntity", "m_bAnimatedEveryTick", false, value);
}
bool GCBaseEntity::GetDisableLowViolence() const {
    return GetSchemaValue<bool>(m_ptr, "CBaseEntity", "m_bDisableLowViolence");
}
void GCBaseEntity::SetDisableLowViolence(bool value) {
    SetSchemaValue(m_ptr, "CBaseEntity", "m_bDisableLowViolence", false, value);
}
uint8_t GCBaseEntity::GetWaterType() const {
    return GetSchemaValue<uint8_t>(m_ptr, "CBaseEntity", "m_nWaterType");
}
void GCBaseEntity::SetWaterType(uint8_t value) {
    SetSchemaValue(m_ptr, "CBaseEntity", "m_nWaterType", false, value);
}
int32_t GCBaseEntity::GetEFlags() const {
    return GetSchemaValue<int32_t>(m_ptr, "CBaseEntity", "m_iEFlags");
}
void GCBaseEntity::SetEFlags(int32_t value) {
    SetSchemaValue(m_ptr, "CBaseEntity", "m_iEFlags", false, value);
}
GCEntityIOOutput GCBaseEntity::GetOnUser1() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CBaseEntity", "m_OnUser1"));
    return value;
}
void GCBaseEntity::SetOnUser1(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CBaseEntity", "m_OnUser1", false, value);
}
GCEntityIOOutput GCBaseEntity::GetOnUser2() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CBaseEntity", "m_OnUser2"));
    return value;
}
void GCBaseEntity::SetOnUser2(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CBaseEntity", "m_OnUser2", false, value);
}
GCEntityIOOutput GCBaseEntity::GetOnUser3() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CBaseEntity", "m_OnUser3"));
    return value;
}
void GCBaseEntity::SetOnUser3(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CBaseEntity", "m_OnUser3", false, value);
}
GCEntityIOOutput GCBaseEntity::GetOnUser4() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CBaseEntity", "m_OnUser4"));
    return value;
}
void GCBaseEntity::SetOnUser4(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CBaseEntity", "m_OnUser4", false, value);
}
int32_t GCBaseEntity::GetInitialTeamNum() const {
    return GetSchemaValue<int32_t>(m_ptr, "CBaseEntity", "m_iInitialTeamNum");
}
void GCBaseEntity::SetInitialTeamNum(int32_t value) {
    SetSchemaValue(m_ptr, "CBaseEntity", "m_iInitialTeamNum", false, value);
}
float GCBaseEntity::GetNavIgnoreUntilTime() const {
    return GetSchemaValue<float>(m_ptr, "CBaseEntity", "m_flNavIgnoreUntilTime");
}
void GCBaseEntity::SetNavIgnoreUntilTime(float value) {
    SetSchemaValue(m_ptr, "CBaseEntity", "m_flNavIgnoreUntilTime", false, value);
}
QAngle GCBaseEntity::GetAngVelocity() const {
    return GetSchemaValue<QAngle>(m_ptr, "CBaseEntity", "m_vecAngVelocity");
}
void GCBaseEntity::SetAngVelocity(QAngle value) {
    SetSchemaValue(m_ptr, "CBaseEntity", "m_vecAngVelocity", false, value);
}
bool GCBaseEntity::GetNetworkQuantizeOriginAndAngles() const {
    return GetSchemaValue<bool>(m_ptr, "CBaseEntity", "m_bNetworkQuantizeOriginAndAngles");
}
void GCBaseEntity::SetNetworkQuantizeOriginAndAngles(bool value) {
    SetSchemaValue(m_ptr, "CBaseEntity", "m_bNetworkQuantizeOriginAndAngles", false, value);
}
bool GCBaseEntity::GetLagCompensate() const {
    return GetSchemaValue<bool>(m_ptr, "CBaseEntity", "m_bLagCompensate");
}
void GCBaseEntity::SetLagCompensate(bool value) {
    SetSchemaValue(m_ptr, "CBaseEntity", "m_bLagCompensate", false, value);
}
float GCBaseEntity::GetOverriddenFriction() const {
    return GetSchemaValue<float>(m_ptr, "CBaseEntity", "m_flOverriddenFriction");
}
void GCBaseEntity::SetOverriddenFriction(float value) {
    SetSchemaValue(m_ptr, "CBaseEntity", "m_flOverriddenFriction", false, value);
}
GCBaseEntity GCBaseEntity::GetBlocker() const {
    GCBaseEntity value(*GetSchemaValuePtr<void*>(m_ptr, "CBaseEntity", "m_pBlocker"));
    return value;
}
void GCBaseEntity::SetBlocker(GCBaseEntity* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Blocker' is not possible.\n");
}
float GCBaseEntity::GetLocalTime() const {
    return GetSchemaValue<float>(m_ptr, "CBaseEntity", "m_flLocalTime");
}
void GCBaseEntity::SetLocalTime(float value) {
    SetSchemaValue(m_ptr, "CBaseEntity", "m_flLocalTime", false, value);
}
float GCBaseEntity::GetVPhysicsUpdateLocalTime() const {
    return GetSchemaValue<float>(m_ptr, "CBaseEntity", "m_flVPhysicsUpdateLocalTime");
}
void GCBaseEntity::SetVPhysicsUpdateLocalTime(float value) {
    SetSchemaValue(m_ptr, "CBaseEntity", "m_flVPhysicsUpdateLocalTime", false, value);
}
uint64_t GCBaseEntity::GetBloodType() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CBaseEntity", "m_nBloodType");
}
void GCBaseEntity::SetBloodType(uint64_t value) {
    SetSchemaValue(m_ptr, "CBaseEntity", "m_nBloodType", false, value);
}
std::string GCBaseEntity::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCBaseEntity::IsValid() {
    return (m_ptr != nullptr);
}
GCEntityInstance GCBaseEntity::GetParent() const {
    GCEntityInstance value(m_ptr);
    return value;
}
void GCBaseEntity::SetParent(GCEntityInstance value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCBaseEntity(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCBaseEntity>("CBaseEntity")
        .addConstructor<void (*)(std::string)>()
        .addProperty("CBodyComponent", &GCBaseEntity::GetCBodyComponent, &GCBaseEntity::SetCBodyComponent)
        .addProperty("NetworkTransmitComponent", &GCBaseEntity::GetNetworkTransmitComponent, &GCBaseEntity::SetNetworkTransmitComponent)
        .addProperty("ThinkFunctions", &GCBaseEntity::GetThinkFunctions, &GCBaseEntity::SetThinkFunctions)
        .addProperty("CurrentThinkContext", &GCBaseEntity::GetCurrentThinkContext, &GCBaseEntity::SetCurrentThinkContext)
        .addProperty("LastThinkTick", &GCBaseEntity::GetLastThinkTick, &GCBaseEntity::SetLastThinkTick)
        .addProperty("DisabledContextThinks", &GCBaseEntity::GetDisabledContextThinks, &GCBaseEntity::SetDisabledContextThinks)
        .addProperty("LastNetworkChange", &GCBaseEntity::GetLastNetworkChange, &GCBaseEntity::SetLastNetworkChange)
        .addProperty("ResponseContexts", &GCBaseEntity::GetResponseContexts, &GCBaseEntity::SetResponseContexts)
        .addProperty("ResponseContext", &GCBaseEntity::GetResponseContext, &GCBaseEntity::SetResponseContext)
        .addProperty("Health", &GCBaseEntity::GetHealth, &GCBaseEntity::SetHealth)
        .addProperty("MaxHealth", &GCBaseEntity::GetMaxHealth, &GCBaseEntity::SetMaxHealth)
        .addProperty("LifeState", &GCBaseEntity::GetLifeState, &GCBaseEntity::SetLifeState)
        .addProperty("DamageAccumulator", &GCBaseEntity::GetDamageAccumulator, &GCBaseEntity::SetDamageAccumulator)
        .addProperty("TakesDamage", &GCBaseEntity::GetTakesDamage, &GCBaseEntity::SetTakesDamage)
        .addProperty("TakeDamageFlags", &GCBaseEntity::GetTakeDamageFlags, &GCBaseEntity::SetTakeDamageFlags)
        .addProperty("IsPlatform", &GCBaseEntity::GetIsPlatform, &GCBaseEntity::SetIsPlatform)
        .addProperty("MoveCollide", &GCBaseEntity::GetMoveCollide, &GCBaseEntity::SetMoveCollide)
        .addProperty("MoveType", &GCBaseEntity::GetMoveType, &GCBaseEntity::SetMoveType)
        .addProperty("ActualMoveType", &GCBaseEntity::GetActualMoveType, &GCBaseEntity::SetActualMoveType)
        .addProperty("WaterTouch", &GCBaseEntity::GetWaterTouch, &GCBaseEntity::SetWaterTouch)
        .addProperty("SlimeTouch", &GCBaseEntity::GetSlimeTouch, &GCBaseEntity::SetSlimeTouch)
        .addProperty("RestoreInHierarchy", &GCBaseEntity::GetRestoreInHierarchy, &GCBaseEntity::SetRestoreInHierarchy)
        .addProperty("Target", &GCBaseEntity::GetTarget, &GCBaseEntity::SetTarget)
        .addProperty("DamageFilter", &GCBaseEntity::GetDamageFilter, &GCBaseEntity::SetDamageFilter)
        .addProperty("DamageFilterName", &GCBaseEntity::GetDamageFilterName, &GCBaseEntity::SetDamageFilterName)
        .addProperty("MoveDoneTime", &GCBaseEntity::GetMoveDoneTime, &GCBaseEntity::SetMoveDoneTime)
        .addProperty("SubclassID", &GCBaseEntity::GetSubclassID, &GCBaseEntity::SetSubclassID)
        .addProperty("AnimTime", &GCBaseEntity::GetAnimTime, &GCBaseEntity::SetAnimTime)
        .addProperty("SimulationTime", &GCBaseEntity::GetSimulationTime, &GCBaseEntity::SetSimulationTime)
        .addProperty("CreateTime", &GCBaseEntity::GetCreateTime, &GCBaseEntity::SetCreateTime)
        .addProperty("ClientSideRagdoll", &GCBaseEntity::GetClientSideRagdoll, &GCBaseEntity::SetClientSideRagdoll)
        .addProperty("InterpolationFrame", &GCBaseEntity::GetInterpolationFrame, &GCBaseEntity::SetInterpolationFrame)
        .addProperty("PrevVPhysicsUpdatePos", &GCBaseEntity::GetPrevVPhysicsUpdatePos, &GCBaseEntity::SetPrevVPhysicsUpdatePos)
        .addProperty("TeamNum", &GCBaseEntity::GetTeamNum, &GCBaseEntity::SetTeamNum)
        .addProperty("Globalname", &GCBaseEntity::GetGlobalname, &GCBaseEntity::SetGlobalname)
        .addProperty("SentToClients", &GCBaseEntity::GetSentToClients, &GCBaseEntity::SetSentToClients)
        .addProperty("Speed", &GCBaseEntity::GetSpeed, &GCBaseEntity::SetSpeed)
        .addProperty("UniqueHammerID", &GCBaseEntity::GetUniqueHammerID, &GCBaseEntity::SetUniqueHammerID)
        .addProperty("Spawnflags", &GCBaseEntity::GetSpawnflags, &GCBaseEntity::SetSpawnflags)
        .addProperty("NextThinkTick", &GCBaseEntity::GetNextThinkTick, &GCBaseEntity::SetNextThinkTick)
        .addProperty("SimulationTick", &GCBaseEntity::GetSimulationTick, &GCBaseEntity::SetSimulationTick)
        .addProperty("OnKilled", &GCBaseEntity::GetOnKilled, &GCBaseEntity::SetOnKilled)
        .addProperty("Flags", &GCBaseEntity::GetFlags, &GCBaseEntity::SetFlags)
        .addProperty("AbsVelocity", &GCBaseEntity::GetAbsVelocity, &GCBaseEntity::SetAbsVelocity)
        .addProperty("Velocity", &GCBaseEntity::GetVelocity, &GCBaseEntity::SetVelocity)
        .addProperty("BaseVelocity", &GCBaseEntity::GetBaseVelocity, &GCBaseEntity::SetBaseVelocity)
        .addProperty("PushEnumCount", &GCBaseEntity::GetPushEnumCount, &GCBaseEntity::SetPushEnumCount)
        .addProperty("Collision", &GCBaseEntity::GetCollision, &GCBaseEntity::SetCollision)
        .addProperty("EffectEntity", &GCBaseEntity::GetEffectEntity, &GCBaseEntity::SetEffectEntity)
        .addProperty("OwnerEntity", &GCBaseEntity::GetOwnerEntity, &GCBaseEntity::SetOwnerEntity)
        .addProperty("Effects", &GCBaseEntity::GetEffects, &GCBaseEntity::SetEffects)
        .addProperty("GroundEntity", &GCBaseEntity::GetGroundEntity, &GCBaseEntity::SetGroundEntity)
        .addProperty("GroundBodyIndex", &GCBaseEntity::GetGroundBodyIndex, &GCBaseEntity::SetGroundBodyIndex)
        .addProperty("Friction", &GCBaseEntity::GetFriction, &GCBaseEntity::SetFriction)
        .addProperty("Elasticity", &GCBaseEntity::GetElasticity, &GCBaseEntity::SetElasticity)
        .addProperty("GravityScale", &GCBaseEntity::GetGravityScale, &GCBaseEntity::SetGravityScale)
        .addProperty("TimeScale", &GCBaseEntity::GetTimeScale, &GCBaseEntity::SetTimeScale)
        .addProperty("WaterLevel", &GCBaseEntity::GetWaterLevel, &GCBaseEntity::SetWaterLevel)
        .addProperty("AnimatedEveryTick", &GCBaseEntity::GetAnimatedEveryTick, &GCBaseEntity::SetAnimatedEveryTick)
        .addProperty("DisableLowViolence", &GCBaseEntity::GetDisableLowViolence, &GCBaseEntity::SetDisableLowViolence)
        .addProperty("WaterType", &GCBaseEntity::GetWaterType, &GCBaseEntity::SetWaterType)
        .addProperty("EFlags", &GCBaseEntity::GetEFlags, &GCBaseEntity::SetEFlags)
        .addProperty("OnUser1", &GCBaseEntity::GetOnUser1, &GCBaseEntity::SetOnUser1)
        .addProperty("OnUser2", &GCBaseEntity::GetOnUser2, &GCBaseEntity::SetOnUser2)
        .addProperty("OnUser3", &GCBaseEntity::GetOnUser3, &GCBaseEntity::SetOnUser3)
        .addProperty("OnUser4", &GCBaseEntity::GetOnUser4, &GCBaseEntity::SetOnUser4)
        .addProperty("InitialTeamNum", &GCBaseEntity::GetInitialTeamNum, &GCBaseEntity::SetInitialTeamNum)
        .addProperty("NavIgnoreUntilTime", &GCBaseEntity::GetNavIgnoreUntilTime, &GCBaseEntity::SetNavIgnoreUntilTime)
        .addProperty("AngVelocity", &GCBaseEntity::GetAngVelocity, &GCBaseEntity::SetAngVelocity)
        .addProperty("NetworkQuantizeOriginAndAngles", &GCBaseEntity::GetNetworkQuantizeOriginAndAngles, &GCBaseEntity::SetNetworkQuantizeOriginAndAngles)
        .addProperty("LagCompensate", &GCBaseEntity::GetLagCompensate, &GCBaseEntity::SetLagCompensate)
        .addProperty("OverriddenFriction", &GCBaseEntity::GetOverriddenFriction, &GCBaseEntity::SetOverriddenFriction)
        .addProperty("Blocker", &GCBaseEntity::GetBlocker, &GCBaseEntity::SetBlocker)
        .addProperty("LocalTime", &GCBaseEntity::GetLocalTime, &GCBaseEntity::SetLocalTime)
        .addProperty("VPhysicsUpdateLocalTime", &GCBaseEntity::GetVPhysicsUpdateLocalTime, &GCBaseEntity::SetVPhysicsUpdateLocalTime)
        .addProperty("BloodType", &GCBaseEntity::GetBloodType, &GCBaseEntity::SetBloodType)
        .addProperty("Parent", &GCBaseEntity::GetParent, &GCBaseEntity::SetParent)
        .addFunction("Spawn", &GCBaseEntity::Spawn)
        .addFunction("Despawn", &GCBaseEntity::Despawn)
        .addFunction("AcceptInput", &GCBaseEntity::AcceptInput)
        .addFunction("GetClassname", &GCBaseEntity::GetClassname)
        .addFunction("GetVData", &GCBaseEntity::GetVData)
        .addFunction("Teleport", &GCBaseEntity::Teleport)
        .addFunction("ToPtr", &GCBaseEntity::ToPtr)
        .addFunction("IsValid", &GCBaseEntity::IsValid)
        .endClass();
}
GCPropDataComponent::GCPropDataComponent(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCPropDataComponent::GCPropDataComponent(void *ptr) {
    m_ptr = ptr;
}
float GCPropDataComponent::GetDmgModBullet() const {
    return GetSchemaValue<float>(m_ptr, "CPropDataComponent", "m_flDmgModBullet");
}
void GCPropDataComponent::SetDmgModBullet(float value) {
    SetSchemaValue(m_ptr, "CPropDataComponent", "m_flDmgModBullet", false, value);
}
float GCPropDataComponent::GetDmgModClub() const {
    return GetSchemaValue<float>(m_ptr, "CPropDataComponent", "m_flDmgModClub");
}
void GCPropDataComponent::SetDmgModClub(float value) {
    SetSchemaValue(m_ptr, "CPropDataComponent", "m_flDmgModClub", false, value);
}
float GCPropDataComponent::GetDmgModExplosive() const {
    return GetSchemaValue<float>(m_ptr, "CPropDataComponent", "m_flDmgModExplosive");
}
void GCPropDataComponent::SetDmgModExplosive(float value) {
    SetSchemaValue(m_ptr, "CPropDataComponent", "m_flDmgModExplosive", false, value);
}
float GCPropDataComponent::GetDmgModFire() const {
    return GetSchemaValue<float>(m_ptr, "CPropDataComponent", "m_flDmgModFire");
}
void GCPropDataComponent::SetDmgModFire(float value) {
    SetSchemaValue(m_ptr, "CPropDataComponent", "m_flDmgModFire", false, value);
}
std::string GCPropDataComponent::GetPhysicsDamageTableName() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CPropDataComponent", "m_iszPhysicsDamageTableName").String();
}
void GCPropDataComponent::SetPhysicsDamageTableName(std::string value) {
    SetSchemaValue(m_ptr, "CPropDataComponent", "m_iszPhysicsDamageTableName", false, CUtlSymbolLarge(value.c_str()));
}
std::string GCPropDataComponent::GetBasePropData() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CPropDataComponent", "m_iszBasePropData").String();
}
void GCPropDataComponent::SetBasePropData(std::string value) {
    SetSchemaValue(m_ptr, "CPropDataComponent", "m_iszBasePropData", false, CUtlSymbolLarge(value.c_str()));
}
int32_t GCPropDataComponent::GetInteractions() const {
    return GetSchemaValue<int32_t>(m_ptr, "CPropDataComponent", "m_nInteractions");
}
void GCPropDataComponent::SetInteractions(int32_t value) {
    SetSchemaValue(m_ptr, "CPropDataComponent", "m_nInteractions", false, value);
}
bool GCPropDataComponent::GetSpawnMotionDisabled() const {
    return GetSchemaValue<bool>(m_ptr, "CPropDataComponent", "m_bSpawnMotionDisabled");
}
void GCPropDataComponent::SetSpawnMotionDisabled(bool value) {
    SetSchemaValue(m_ptr, "CPropDataComponent", "m_bSpawnMotionDisabled", false, value);
}
int32_t GCPropDataComponent::GetDisableTakePhysicsDamageSpawnFlag() const {
    return GetSchemaValue<int32_t>(m_ptr, "CPropDataComponent", "m_nDisableTakePhysicsDamageSpawnFlag");
}
void GCPropDataComponent::SetDisableTakePhysicsDamageSpawnFlag(int32_t value) {
    SetSchemaValue(m_ptr, "CPropDataComponent", "m_nDisableTakePhysicsDamageSpawnFlag", false, value);
}
int32_t GCPropDataComponent::GetMotionDisabledSpawnFlag() const {
    return GetSchemaValue<int32_t>(m_ptr, "CPropDataComponent", "m_nMotionDisabledSpawnFlag");
}
void GCPropDataComponent::SetMotionDisabledSpawnFlag(int32_t value) {
    SetSchemaValue(m_ptr, "CPropDataComponent", "m_nMotionDisabledSpawnFlag", false, value);
}
std::string GCPropDataComponent::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCPropDataComponent::IsValid() {
    return (m_ptr != nullptr);
}
GCEntityComponent GCPropDataComponent::GetParent() const {
    GCEntityComponent value(m_ptr);
    return value;
}
void GCPropDataComponent::SetParent(GCEntityComponent value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCPropDataComponent(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCPropDataComponent>("CPropDataComponent")
        .addConstructor<void (*)(std::string)>()
        .addProperty("DmgModBullet", &GCPropDataComponent::GetDmgModBullet, &GCPropDataComponent::SetDmgModBullet)
        .addProperty("DmgModClub", &GCPropDataComponent::GetDmgModClub, &GCPropDataComponent::SetDmgModClub)
        .addProperty("DmgModExplosive", &GCPropDataComponent::GetDmgModExplosive, &GCPropDataComponent::SetDmgModExplosive)
        .addProperty("DmgModFire", &GCPropDataComponent::GetDmgModFire, &GCPropDataComponent::SetDmgModFire)
        .addProperty("PhysicsDamageTableName", &GCPropDataComponent::GetPhysicsDamageTableName, &GCPropDataComponent::SetPhysicsDamageTableName)
        .addProperty("BasePropData", &GCPropDataComponent::GetBasePropData, &GCPropDataComponent::SetBasePropData)
        .addProperty("Interactions", &GCPropDataComponent::GetInteractions, &GCPropDataComponent::SetInteractions)
        .addProperty("SpawnMotionDisabled", &GCPropDataComponent::GetSpawnMotionDisabled, &GCPropDataComponent::SetSpawnMotionDisabled)
        .addProperty("DisableTakePhysicsDamageSpawnFlag", &GCPropDataComponent::GetDisableTakePhysicsDamageSpawnFlag, &GCPropDataComponent::SetDisableTakePhysicsDamageSpawnFlag)
        .addProperty("MotionDisabledSpawnFlag", &GCPropDataComponent::GetMotionDisabledSpawnFlag, &GCPropDataComponent::SetMotionDisabledSpawnFlag)
        .addProperty("Parent", &GCPropDataComponent::GetParent, &GCPropDataComponent::SetParent)
        .addFunction("ToPtr", &GCPropDataComponent::ToPtr)
        .addFunction("IsValid", &GCPropDataComponent::IsValid)
        .endClass();
}
GCHitboxComponent::GCHitboxComponent(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCHitboxComponent::GCHitboxComponent(void *ptr) {
    m_ptr = ptr;
}
std::vector<uint32_t> GCHitboxComponent::GetDisabledHitGroups() const {
    uint32_t* outValue = GetSchemaValue<uint32_t*>(m_ptr, "CHitboxComponent", "m_bvDisabledHitGroups"); std::vector<uint32_t> ret; for(int i = 0; i < 1; i++) { ret.push_back(outValue[i]); } return ret;
}
void GCHitboxComponent::SetDisabledHitGroups(std::vector<uint32_t> value) {
    uint32_t* outValue = GetSchemaValue<uint32_t*>(m_ptr, "CHitboxComponent", "m_bvDisabledHitGroups"); for(int i = 0; i < 1; i++) { outValue[i] = value[i]; } SetSchemaValue(m_ptr, "CHitboxComponent", "m_bvDisabledHitGroups", false, outValue);
}
std::string GCHitboxComponent::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCHitboxComponent::IsValid() {
    return (m_ptr != nullptr);
}
GCEntityComponent GCHitboxComponent::GetParent() const {
    GCEntityComponent value(m_ptr);
    return value;
}
void GCHitboxComponent::SetParent(GCEntityComponent value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCHitboxComponent(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCHitboxComponent>("CHitboxComponent")
        .addConstructor<void (*)(std::string)>()
        .addProperty("DisabledHitGroups", &GCHitboxComponent::GetDisabledHitGroups, &GCHitboxComponent::SetDisabledHitGroups)
        .addProperty("Parent", &GCHitboxComponent::GetParent, &GCHitboxComponent::SetParent)
        .addFunction("ToPtr", &GCHitboxComponent::ToPtr)
        .addFunction("IsValid", &GCHitboxComponent::IsValid)
        .endClass();
}
GVPhysicsCollisionAttribute_t::GVPhysicsCollisionAttribute_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GVPhysicsCollisionAttribute_t::GVPhysicsCollisionAttribute_t(void *ptr) {
    m_ptr = ptr;
}
uint64_t GVPhysicsCollisionAttribute_t::GetInteractsAs() const {
    return GetSchemaValue<uint64_t>(m_ptr, "VPhysicsCollisionAttribute_t", "m_nInteractsAs");
}
void GVPhysicsCollisionAttribute_t::SetInteractsAs(uint64_t value) {
    SetSchemaValue(m_ptr, "VPhysicsCollisionAttribute_t", "m_nInteractsAs", true, value);
}
uint64_t GVPhysicsCollisionAttribute_t::GetInteractsWith() const {
    return GetSchemaValue<uint64_t>(m_ptr, "VPhysicsCollisionAttribute_t", "m_nInteractsWith");
}
void GVPhysicsCollisionAttribute_t::SetInteractsWith(uint64_t value) {
    SetSchemaValue(m_ptr, "VPhysicsCollisionAttribute_t", "m_nInteractsWith", true, value);
}
uint64_t GVPhysicsCollisionAttribute_t::GetInteractsExclude() const {
    return GetSchemaValue<uint64_t>(m_ptr, "VPhysicsCollisionAttribute_t", "m_nInteractsExclude");
}
void GVPhysicsCollisionAttribute_t::SetInteractsExclude(uint64_t value) {
    SetSchemaValue(m_ptr, "VPhysicsCollisionAttribute_t", "m_nInteractsExclude", true, value);
}
uint32_t GVPhysicsCollisionAttribute_t::GetEntityId() const {
    return GetSchemaValue<uint32_t>(m_ptr, "VPhysicsCollisionAttribute_t", "m_nEntityId");
}
void GVPhysicsCollisionAttribute_t::SetEntityId(uint32_t value) {
    SetSchemaValue(m_ptr, "VPhysicsCollisionAttribute_t", "m_nEntityId", true, value);
}
uint32_t GVPhysicsCollisionAttribute_t::GetOwnerId() const {
    return GetSchemaValue<uint32_t>(m_ptr, "VPhysicsCollisionAttribute_t", "m_nOwnerId");
}
void GVPhysicsCollisionAttribute_t::SetOwnerId(uint32_t value) {
    SetSchemaValue(m_ptr, "VPhysicsCollisionAttribute_t", "m_nOwnerId", true, value);
}
uint16_t GVPhysicsCollisionAttribute_t::GetHierarchyId() const {
    return GetSchemaValue<uint16_t>(m_ptr, "VPhysicsCollisionAttribute_t", "m_nHierarchyId");
}
void GVPhysicsCollisionAttribute_t::SetHierarchyId(uint16_t value) {
    SetSchemaValue(m_ptr, "VPhysicsCollisionAttribute_t", "m_nHierarchyId", true, value);
}
uint8_t GVPhysicsCollisionAttribute_t::GetCollisionGroup() const {
    return GetSchemaValue<uint8_t>(m_ptr, "VPhysicsCollisionAttribute_t", "m_nCollisionGroup");
}
void GVPhysicsCollisionAttribute_t::SetCollisionGroup(uint8_t value) {
    SetSchemaValue(m_ptr, "VPhysicsCollisionAttribute_t", "m_nCollisionGroup", true, value);
}
uint8_t GVPhysicsCollisionAttribute_t::GetCollisionFunctionMask() const {
    return GetSchemaValue<uint8_t>(m_ptr, "VPhysicsCollisionAttribute_t", "m_nCollisionFunctionMask");
}
void GVPhysicsCollisionAttribute_t::SetCollisionFunctionMask(uint8_t value) {
    SetSchemaValue(m_ptr, "VPhysicsCollisionAttribute_t", "m_nCollisionFunctionMask", true, value);
}
std::string GVPhysicsCollisionAttribute_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GVPhysicsCollisionAttribute_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassVPhysicsCollisionAttribute_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GVPhysicsCollisionAttribute_t>("VPhysicsCollisionAttribute_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("InteractsAs", &GVPhysicsCollisionAttribute_t::GetInteractsAs, &GVPhysicsCollisionAttribute_t::SetInteractsAs)
        .addProperty("InteractsWith", &GVPhysicsCollisionAttribute_t::GetInteractsWith, &GVPhysicsCollisionAttribute_t::SetInteractsWith)
        .addProperty("InteractsExclude", &GVPhysicsCollisionAttribute_t::GetInteractsExclude, &GVPhysicsCollisionAttribute_t::SetInteractsExclude)
        .addProperty("EntityId", &GVPhysicsCollisionAttribute_t::GetEntityId, &GVPhysicsCollisionAttribute_t::SetEntityId)
        .addProperty("OwnerId", &GVPhysicsCollisionAttribute_t::GetOwnerId, &GVPhysicsCollisionAttribute_t::SetOwnerId)
        .addProperty("HierarchyId", &GVPhysicsCollisionAttribute_t::GetHierarchyId, &GVPhysicsCollisionAttribute_t::SetHierarchyId)
        .addProperty("CollisionGroup", &GVPhysicsCollisionAttribute_t::GetCollisionGroup, &GVPhysicsCollisionAttribute_t::SetCollisionGroup)
        .addProperty("CollisionFunctionMask", &GVPhysicsCollisionAttribute_t::GetCollisionFunctionMask, &GVPhysicsCollisionAttribute_t::SetCollisionFunctionMask)
        .addFunction("ToPtr", &GVPhysicsCollisionAttribute_t::ToPtr)
        .addFunction("IsValid", &GVPhysicsCollisionAttribute_t::IsValid)
        .endClass();
}
GCCollisionProperty::GCCollisionProperty(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCCollisionProperty::GCCollisionProperty(void *ptr) {
    m_ptr = ptr;
}
GVPhysicsCollisionAttribute_t GCCollisionProperty::GetCollisionAttribute() const {
    GVPhysicsCollisionAttribute_t value(GetSchemaPtr(m_ptr, "CCollisionProperty", "m_collisionAttribute"));
    return value;
}
void GCCollisionProperty::SetCollisionAttribute(GVPhysicsCollisionAttribute_t value) {
    SetSchemaValue(m_ptr, "CCollisionProperty", "m_collisionAttribute", false, value);
}
Vector GCCollisionProperty::GetMins() const {
    return GetSchemaValue<Vector>(m_ptr, "CCollisionProperty", "m_vecMins");
}
void GCCollisionProperty::SetMins(Vector value) {
    SetSchemaValue(m_ptr, "CCollisionProperty", "m_vecMins", false, value);
}
Vector GCCollisionProperty::GetMaxs() const {
    return GetSchemaValue<Vector>(m_ptr, "CCollisionProperty", "m_vecMaxs");
}
void GCCollisionProperty::SetMaxs(Vector value) {
    SetSchemaValue(m_ptr, "CCollisionProperty", "m_vecMaxs", false, value);
}
uint8_t GCCollisionProperty::GetSolidFlags() const {
    return GetSchemaValue<uint8_t>(m_ptr, "CCollisionProperty", "m_usSolidFlags");
}
void GCCollisionProperty::SetSolidFlags(uint8_t value) {
    SetSchemaValue(m_ptr, "CCollisionProperty", "m_usSolidFlags", false, value);
}
uint64_t GCCollisionProperty::GetSolidType() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CCollisionProperty", "m_nSolidType");
}
void GCCollisionProperty::SetSolidType(uint64_t value) {
    SetSchemaValue(m_ptr, "CCollisionProperty", "m_nSolidType", false, value);
}
uint8_t GCCollisionProperty::GetTriggerBloat() const {
    return GetSchemaValue<uint8_t>(m_ptr, "CCollisionProperty", "m_triggerBloat");
}
void GCCollisionProperty::SetTriggerBloat(uint8_t value) {
    SetSchemaValue(m_ptr, "CCollisionProperty", "m_triggerBloat", false, value);
}
uint64_t GCCollisionProperty::GetSurroundType() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CCollisionProperty", "m_nSurroundType");
}
void GCCollisionProperty::SetSurroundType(uint64_t value) {
    SetSchemaValue(m_ptr, "CCollisionProperty", "m_nSurroundType", false, value);
}
uint8_t GCCollisionProperty::GetCollisionGroup() const {
    return GetSchemaValue<uint8_t>(m_ptr, "CCollisionProperty", "m_CollisionGroup");
}
void GCCollisionProperty::SetCollisionGroup(uint8_t value) {
    SetSchemaValue(m_ptr, "CCollisionProperty", "m_CollisionGroup", false, value);
}
uint8_t GCCollisionProperty::GetEnablePhysics() const {
    return GetSchemaValue<uint8_t>(m_ptr, "CCollisionProperty", "m_nEnablePhysics");
}
void GCCollisionProperty::SetEnablePhysics(uint8_t value) {
    SetSchemaValue(m_ptr, "CCollisionProperty", "m_nEnablePhysics", false, value);
}
float GCCollisionProperty::GetBoundingRadius() const {
    return GetSchemaValue<float>(m_ptr, "CCollisionProperty", "m_flBoundingRadius");
}
void GCCollisionProperty::SetBoundingRadius(float value) {
    SetSchemaValue(m_ptr, "CCollisionProperty", "m_flBoundingRadius", false, value);
}
Vector GCCollisionProperty::GetSpecifiedSurroundingMins() const {
    return GetSchemaValue<Vector>(m_ptr, "CCollisionProperty", "m_vecSpecifiedSurroundingMins");
}
void GCCollisionProperty::SetSpecifiedSurroundingMins(Vector value) {
    SetSchemaValue(m_ptr, "CCollisionProperty", "m_vecSpecifiedSurroundingMins", false, value);
}
Vector GCCollisionProperty::GetSpecifiedSurroundingMaxs() const {
    return GetSchemaValue<Vector>(m_ptr, "CCollisionProperty", "m_vecSpecifiedSurroundingMaxs");
}
void GCCollisionProperty::SetSpecifiedSurroundingMaxs(Vector value) {
    SetSchemaValue(m_ptr, "CCollisionProperty", "m_vecSpecifiedSurroundingMaxs", false, value);
}
Vector GCCollisionProperty::GetSurroundingMaxs() const {
    return GetSchemaValue<Vector>(m_ptr, "CCollisionProperty", "m_vecSurroundingMaxs");
}
void GCCollisionProperty::SetSurroundingMaxs(Vector value) {
    SetSchemaValue(m_ptr, "CCollisionProperty", "m_vecSurroundingMaxs", false, value);
}
Vector GCCollisionProperty::GetSurroundingMins() const {
    return GetSchemaValue<Vector>(m_ptr, "CCollisionProperty", "m_vecSurroundingMins");
}
void GCCollisionProperty::SetSurroundingMins(Vector value) {
    SetSchemaValue(m_ptr, "CCollisionProperty", "m_vecSurroundingMins", false, value);
}
Vector GCCollisionProperty::GetCapsuleCenter1() const {
    return GetSchemaValue<Vector>(m_ptr, "CCollisionProperty", "m_vCapsuleCenter1");
}
void GCCollisionProperty::SetCapsuleCenter1(Vector value) {
    SetSchemaValue(m_ptr, "CCollisionProperty", "m_vCapsuleCenter1", false, value);
}
Vector GCCollisionProperty::GetCapsuleCenter2() const {
    return GetSchemaValue<Vector>(m_ptr, "CCollisionProperty", "m_vCapsuleCenter2");
}
void GCCollisionProperty::SetCapsuleCenter2(Vector value) {
    SetSchemaValue(m_ptr, "CCollisionProperty", "m_vCapsuleCenter2", false, value);
}
float GCCollisionProperty::GetCapsuleRadius() const {
    return GetSchemaValue<float>(m_ptr, "CCollisionProperty", "m_flCapsuleRadius");
}
void GCCollisionProperty::SetCapsuleRadius(float value) {
    SetSchemaValue(m_ptr, "CCollisionProperty", "m_flCapsuleRadius", false, value);
}
std::string GCCollisionProperty::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCCollisionProperty::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCCollisionProperty(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCCollisionProperty>("CCollisionProperty")
        .addConstructor<void (*)(std::string)>()
        .addProperty("CollisionAttribute", &GCCollisionProperty::GetCollisionAttribute, &GCCollisionProperty::SetCollisionAttribute)
        .addProperty("Mins", &GCCollisionProperty::GetMins, &GCCollisionProperty::SetMins)
        .addProperty("Maxs", &GCCollisionProperty::GetMaxs, &GCCollisionProperty::SetMaxs)
        .addProperty("SolidFlags", &GCCollisionProperty::GetSolidFlags, &GCCollisionProperty::SetSolidFlags)
        .addProperty("SolidType", &GCCollisionProperty::GetSolidType, &GCCollisionProperty::SetSolidType)
        .addProperty("TriggerBloat", &GCCollisionProperty::GetTriggerBloat, &GCCollisionProperty::SetTriggerBloat)
        .addProperty("SurroundType", &GCCollisionProperty::GetSurroundType, &GCCollisionProperty::SetSurroundType)
        .addProperty("CollisionGroup", &GCCollisionProperty::GetCollisionGroup, &GCCollisionProperty::SetCollisionGroup)
        .addProperty("EnablePhysics", &GCCollisionProperty::GetEnablePhysics, &GCCollisionProperty::SetEnablePhysics)
        .addProperty("BoundingRadius", &GCCollisionProperty::GetBoundingRadius, &GCCollisionProperty::SetBoundingRadius)
        .addProperty("SpecifiedSurroundingMins", &GCCollisionProperty::GetSpecifiedSurroundingMins, &GCCollisionProperty::SetSpecifiedSurroundingMins)
        .addProperty("SpecifiedSurroundingMaxs", &GCCollisionProperty::GetSpecifiedSurroundingMaxs, &GCCollisionProperty::SetSpecifiedSurroundingMaxs)
        .addProperty("SurroundingMaxs", &GCCollisionProperty::GetSurroundingMaxs, &GCCollisionProperty::SetSurroundingMaxs)
        .addProperty("SurroundingMins", &GCCollisionProperty::GetSurroundingMins, &GCCollisionProperty::SetSurroundingMins)
        .addProperty("CapsuleCenter1", &GCCollisionProperty::GetCapsuleCenter1, &GCCollisionProperty::SetCapsuleCenter1)
        .addProperty("CapsuleCenter2", &GCCollisionProperty::GetCapsuleCenter2, &GCCollisionProperty::SetCapsuleCenter2)
        .addProperty("CapsuleRadius", &GCCollisionProperty::GetCapsuleRadius, &GCCollisionProperty::SetCapsuleRadius)
        .addFunction("ToPtr", &GCCollisionProperty::ToPtr)
        .addFunction("IsValid", &GCCollisionProperty::IsValid)
        .endClass();
}
GCBaseModelEntity::GCBaseModelEntity(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCBaseModelEntity::GCBaseModelEntity(void *ptr) {
    m_ptr = ptr;
}
void GCBaseModelEntity::SetModel(std::string model) {
    ((CBaseModelEntity*)m_ptr)->SetModel(model.c_str());
}
GCRenderComponent GCBaseModelEntity::GetCRenderComponent() const {
    GCRenderComponent value(*GetSchemaValuePtr<void*>(m_ptr, "CBaseModelEntity", "m_CRenderComponent"));
    return value;
}
void GCBaseModelEntity::SetCRenderComponent(GCRenderComponent* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'CRenderComponent' is not possible.\n");
}
GCHitboxComponent GCBaseModelEntity::GetCHitboxComponent() const {
    GCHitboxComponent value(GetSchemaPtr(m_ptr, "CBaseModelEntity", "m_CHitboxComponent"));
    return value;
}
void GCBaseModelEntity::SetCHitboxComponent(GCHitboxComponent value) {
    SetSchemaValue(m_ptr, "CBaseModelEntity", "m_CHitboxComponent", false, value);
}
float GCBaseModelEntity::GetDissolveStartTime() const {
    return GetSchemaValue<float>(m_ptr, "CBaseModelEntity", "m_flDissolveStartTime");
}
void GCBaseModelEntity::SetDissolveStartTime(float value) {
    SetSchemaValue(m_ptr, "CBaseModelEntity", "m_flDissolveStartTime", false, value);
}
GCEntityIOOutput GCBaseModelEntity::GetOnIgnite() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CBaseModelEntity", "m_OnIgnite"));
    return value;
}
void GCBaseModelEntity::SetOnIgnite(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CBaseModelEntity", "m_OnIgnite", false, value);
}
uint64_t GCBaseModelEntity::GetRenderMode() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CBaseModelEntity", "m_nRenderMode");
}
void GCBaseModelEntity::SetRenderMode(uint64_t value) {
    SetSchemaValue(m_ptr, "CBaseModelEntity", "m_nRenderMode", false, value);
}
uint64_t GCBaseModelEntity::GetRenderFX() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CBaseModelEntity", "m_nRenderFX");
}
void GCBaseModelEntity::SetRenderFX(uint64_t value) {
    SetSchemaValue(m_ptr, "CBaseModelEntity", "m_nRenderFX", false, value);
}
bool GCBaseModelEntity::GetAllowFadeInView() const {
    return GetSchemaValue<bool>(m_ptr, "CBaseModelEntity", "m_bAllowFadeInView");
}
void GCBaseModelEntity::SetAllowFadeInView(bool value) {
    SetSchemaValue(m_ptr, "CBaseModelEntity", "m_bAllowFadeInView", false, value);
}
Color GCBaseModelEntity::GetRender() const {
    return GetSchemaValue<Color>(m_ptr, "CBaseModelEntity", "m_clrRender");
}
void GCBaseModelEntity::SetRender(Color value) {
    SetSchemaValue(m_ptr, "CBaseModelEntity", "m_clrRender", false, value);
}
std::vector<GEntityRenderAttribute_t> GCBaseModelEntity::GetRenderAttributes() const {
    CUtlVector<GEntityRenderAttribute_t>* vec = GetSchemaValue<CUtlVector<GEntityRenderAttribute_t>*>(m_ptr, "CBaseModelEntity", "m_vecRenderAttributes"); std::vector<GEntityRenderAttribute_t> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCBaseModelEntity::SetRenderAttributes(std::vector<GEntityRenderAttribute_t> value) {
    SetSchemaValueCUtlVector<GEntityRenderAttribute_t>(m_ptr, "CBaseModelEntity", "m_vecRenderAttributes", false, value);
}
bool GCBaseModelEntity::GetRenderToCubemaps() const {
    return GetSchemaValue<bool>(m_ptr, "CBaseModelEntity", "m_bRenderToCubemaps");
}
void GCBaseModelEntity::SetRenderToCubemaps(bool value) {
    SetSchemaValue(m_ptr, "CBaseModelEntity", "m_bRenderToCubemaps", false, value);
}
GCCollisionProperty GCBaseModelEntity::GetCollision() const {
    GCCollisionProperty value(GetSchemaPtr(m_ptr, "CBaseModelEntity", "m_Collision"));
    return value;
}
void GCBaseModelEntity::SetCollision(GCCollisionProperty value) {
    SetSchemaValue(m_ptr, "CBaseModelEntity", "m_Collision", false, value);
}
GCGlowProperty GCBaseModelEntity::GetGlow() const {
    GCGlowProperty value(GetSchemaPtr(m_ptr, "CBaseModelEntity", "m_Glow"));
    return value;
}
void GCBaseModelEntity::SetGlow(GCGlowProperty value) {
    SetSchemaValue(m_ptr, "CBaseModelEntity", "m_Glow", false, value);
}
float GCBaseModelEntity::GetGlowBackfaceMult() const {
    return GetSchemaValue<float>(m_ptr, "CBaseModelEntity", "m_flGlowBackfaceMult");
}
void GCBaseModelEntity::SetGlowBackfaceMult(float value) {
    SetSchemaValue(m_ptr, "CBaseModelEntity", "m_flGlowBackfaceMult", false, value);
}
float GCBaseModelEntity::GetFadeMinDist() const {
    return GetSchemaValue<float>(m_ptr, "CBaseModelEntity", "m_fadeMinDist");
}
void GCBaseModelEntity::SetFadeMinDist(float value) {
    SetSchemaValue(m_ptr, "CBaseModelEntity", "m_fadeMinDist", false, value);
}
float GCBaseModelEntity::GetFadeMaxDist() const {
    return GetSchemaValue<float>(m_ptr, "CBaseModelEntity", "m_fadeMaxDist");
}
void GCBaseModelEntity::SetFadeMaxDist(float value) {
    SetSchemaValue(m_ptr, "CBaseModelEntity", "m_fadeMaxDist", false, value);
}
float GCBaseModelEntity::GetFadeScale() const {
    return GetSchemaValue<float>(m_ptr, "CBaseModelEntity", "m_flFadeScale");
}
void GCBaseModelEntity::SetFadeScale(float value) {
    SetSchemaValue(m_ptr, "CBaseModelEntity", "m_flFadeScale", false, value);
}
float GCBaseModelEntity::GetShadowStrength() const {
    return GetSchemaValue<float>(m_ptr, "CBaseModelEntity", "m_flShadowStrength");
}
void GCBaseModelEntity::SetShadowStrength(float value) {
    SetSchemaValue(m_ptr, "CBaseModelEntity", "m_flShadowStrength", false, value);
}
uint8_t GCBaseModelEntity::GetObjectCulling() const {
    return GetSchemaValue<uint8_t>(m_ptr, "CBaseModelEntity", "m_nObjectCulling");
}
void GCBaseModelEntity::SetObjectCulling(uint8_t value) {
    SetSchemaValue(m_ptr, "CBaseModelEntity", "m_nObjectCulling", false, value);
}
int32_t GCBaseModelEntity::GetAddDecal() const {
    return GetSchemaValue<int32_t>(m_ptr, "CBaseModelEntity", "m_nAddDecal");
}
void GCBaseModelEntity::SetAddDecal(int32_t value) {
    SetSchemaValue(m_ptr, "CBaseModelEntity", "m_nAddDecal", false, value);
}
Vector GCBaseModelEntity::GetDecalPosition() const {
    return GetSchemaValue<Vector>(m_ptr, "CBaseModelEntity", "m_vDecalPosition");
}
void GCBaseModelEntity::SetDecalPosition(Vector value) {
    SetSchemaValue(m_ptr, "CBaseModelEntity", "m_vDecalPosition", false, value);
}
Vector GCBaseModelEntity::GetDecalForwardAxis() const {
    return GetSchemaValue<Vector>(m_ptr, "CBaseModelEntity", "m_vDecalForwardAxis");
}
void GCBaseModelEntity::SetDecalForwardAxis(Vector value) {
    SetSchemaValue(m_ptr, "CBaseModelEntity", "m_vDecalForwardAxis", false, value);
}
float GCBaseModelEntity::GetDecalHealBloodRate() const {
    return GetSchemaValue<float>(m_ptr, "CBaseModelEntity", "m_flDecalHealBloodRate");
}
void GCBaseModelEntity::SetDecalHealBloodRate(float value) {
    SetSchemaValue(m_ptr, "CBaseModelEntity", "m_flDecalHealBloodRate", false, value);
}
float GCBaseModelEntity::GetDecalHealHeightRate() const {
    return GetSchemaValue<float>(m_ptr, "CBaseModelEntity", "m_flDecalHealHeightRate");
}
void GCBaseModelEntity::SetDecalHealHeightRate(float value) {
    SetSchemaValue(m_ptr, "CBaseModelEntity", "m_flDecalHealHeightRate", false, value);
}
std::vector<GCBaseModelEntity*> GCBaseModelEntity::GetConfigEntitiesToPropagateMaterialDecalsTo() const {
    CUtlVector<GCBaseModelEntity*>* vec = GetSchemaValue<CUtlVector<GCBaseModelEntity*>*>(m_ptr, "CBaseModelEntity", "m_ConfigEntitiesToPropagateMaterialDecalsTo"); std::vector<GCBaseModelEntity*> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCBaseModelEntity::SetConfigEntitiesToPropagateMaterialDecalsTo(std::vector<GCBaseModelEntity*> value) {
    SetSchemaValueCUtlVector<GCBaseModelEntity*>(m_ptr, "CBaseModelEntity", "m_ConfigEntitiesToPropagateMaterialDecalsTo", false, value);
}
GCNetworkViewOffsetVector GCBaseModelEntity::GetViewOffset() const {
    GCNetworkViewOffsetVector value(GetSchemaPtr(m_ptr, "CBaseModelEntity", "m_vecViewOffset"));
    return value;
}
void GCBaseModelEntity::SetViewOffset(GCNetworkViewOffsetVector value) {
    SetSchemaValue(m_ptr, "CBaseModelEntity", "m_vecViewOffset", false, value);
}
std::string GCBaseModelEntity::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCBaseModelEntity::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseEntity GCBaseModelEntity::GetParent() const {
    GCBaseEntity value(m_ptr);
    return value;
}
void GCBaseModelEntity::SetParent(GCBaseEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCBaseModelEntity(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCBaseModelEntity>("CBaseModelEntity")
        .addConstructor<void (*)(std::string)>()
        .addProperty("CRenderComponent", &GCBaseModelEntity::GetCRenderComponent, &GCBaseModelEntity::SetCRenderComponent)
        .addProperty("CHitboxComponent", &GCBaseModelEntity::GetCHitboxComponent, &GCBaseModelEntity::SetCHitboxComponent)
        .addProperty("DissolveStartTime", &GCBaseModelEntity::GetDissolveStartTime, &GCBaseModelEntity::SetDissolveStartTime)
        .addProperty("OnIgnite", &GCBaseModelEntity::GetOnIgnite, &GCBaseModelEntity::SetOnIgnite)
        .addProperty("RenderMode", &GCBaseModelEntity::GetRenderMode, &GCBaseModelEntity::SetRenderMode)
        .addProperty("RenderFX", &GCBaseModelEntity::GetRenderFX, &GCBaseModelEntity::SetRenderFX)
        .addProperty("AllowFadeInView", &GCBaseModelEntity::GetAllowFadeInView, &GCBaseModelEntity::SetAllowFadeInView)
        .addProperty("Render", &GCBaseModelEntity::GetRender, &GCBaseModelEntity::SetRender)
        .addProperty("RenderAttributes", &GCBaseModelEntity::GetRenderAttributes, &GCBaseModelEntity::SetRenderAttributes)
        .addProperty("RenderToCubemaps", &GCBaseModelEntity::GetRenderToCubemaps, &GCBaseModelEntity::SetRenderToCubemaps)
        .addProperty("Collision", &GCBaseModelEntity::GetCollision, &GCBaseModelEntity::SetCollision)
        .addProperty("Glow", &GCBaseModelEntity::GetGlow, &GCBaseModelEntity::SetGlow)
        .addProperty("GlowBackfaceMult", &GCBaseModelEntity::GetGlowBackfaceMult, &GCBaseModelEntity::SetGlowBackfaceMult)
        .addProperty("FadeMinDist", &GCBaseModelEntity::GetFadeMinDist, &GCBaseModelEntity::SetFadeMinDist)
        .addProperty("FadeMaxDist", &GCBaseModelEntity::GetFadeMaxDist, &GCBaseModelEntity::SetFadeMaxDist)
        .addProperty("FadeScale", &GCBaseModelEntity::GetFadeScale, &GCBaseModelEntity::SetFadeScale)
        .addProperty("ShadowStrength", &GCBaseModelEntity::GetShadowStrength, &GCBaseModelEntity::SetShadowStrength)
        .addProperty("ObjectCulling", &GCBaseModelEntity::GetObjectCulling, &GCBaseModelEntity::SetObjectCulling)
        .addProperty("AddDecal", &GCBaseModelEntity::GetAddDecal, &GCBaseModelEntity::SetAddDecal)
        .addProperty("DecalPosition", &GCBaseModelEntity::GetDecalPosition, &GCBaseModelEntity::SetDecalPosition)
        .addProperty("DecalForwardAxis", &GCBaseModelEntity::GetDecalForwardAxis, &GCBaseModelEntity::SetDecalForwardAxis)
        .addProperty("DecalHealBloodRate", &GCBaseModelEntity::GetDecalHealBloodRate, &GCBaseModelEntity::SetDecalHealBloodRate)
        .addProperty("DecalHealHeightRate", &GCBaseModelEntity::GetDecalHealHeightRate, &GCBaseModelEntity::SetDecalHealHeightRate)
        .addProperty("ConfigEntitiesToPropagateMaterialDecalsTo", &GCBaseModelEntity::GetConfigEntitiesToPropagateMaterialDecalsTo, &GCBaseModelEntity::SetConfigEntitiesToPropagateMaterialDecalsTo)
        .addProperty("ViewOffset", &GCBaseModelEntity::GetViewOffset, &GCBaseModelEntity::SetViewOffset)
        .addProperty("Parent", &GCBaseModelEntity::GetParent, &GCBaseModelEntity::SetParent)
        .addFunction("SetModel", &GCBaseModelEntity::SetModel)
        .addFunction("ToPtr", &GCBaseModelEntity::ToPtr)
        .addFunction("IsValid", &GCBaseModelEntity::IsValid)
        .endClass();
}
GCServerOnlyEntity::GCServerOnlyEntity(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCServerOnlyEntity::GCServerOnlyEntity(void *ptr) {
    m_ptr = ptr;
}
std::string GCServerOnlyEntity::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCServerOnlyEntity::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseEntity GCServerOnlyEntity::GetParent() const {
    GCBaseEntity value(m_ptr);
    return value;
}
void GCServerOnlyEntity::SetParent(GCBaseEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCServerOnlyEntity(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCServerOnlyEntity>("CServerOnlyEntity")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCServerOnlyEntity::GetParent, &GCServerOnlyEntity::SetParent)
        .addFunction("ToPtr", &GCServerOnlyEntity::ToPtr)
        .addFunction("IsValid", &GCServerOnlyEntity::IsValid)
        .endClass();
}
GCBaseToggle::GCBaseToggle(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCBaseToggle::GCBaseToggle(void *ptr) {
    m_ptr = ptr;
}
uint64_t GCBaseToggle::GetToggle_state() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CBaseToggle", "m_toggle_state");
}
void GCBaseToggle::SetToggle_state(uint64_t value) {
    SetSchemaValue(m_ptr, "CBaseToggle", "m_toggle_state", false, value);
}
float GCBaseToggle::GetMoveDistance() const {
    return GetSchemaValue<float>(m_ptr, "CBaseToggle", "m_flMoveDistance");
}
void GCBaseToggle::SetMoveDistance(float value) {
    SetSchemaValue(m_ptr, "CBaseToggle", "m_flMoveDistance", false, value);
}
float GCBaseToggle::GetWait() const {
    return GetSchemaValue<float>(m_ptr, "CBaseToggle", "m_flWait");
}
void GCBaseToggle::SetWait(float value) {
    SetSchemaValue(m_ptr, "CBaseToggle", "m_flWait", false, value);
}
float GCBaseToggle::GetLip() const {
    return GetSchemaValue<float>(m_ptr, "CBaseToggle", "m_flLip");
}
void GCBaseToggle::SetLip(float value) {
    SetSchemaValue(m_ptr, "CBaseToggle", "m_flLip", false, value);
}
bool GCBaseToggle::GetAlwaysFireBlockedOutputs() const {
    return GetSchemaValue<bool>(m_ptr, "CBaseToggle", "m_bAlwaysFireBlockedOutputs");
}
void GCBaseToggle::SetAlwaysFireBlockedOutputs(bool value) {
    SetSchemaValue(m_ptr, "CBaseToggle", "m_bAlwaysFireBlockedOutputs", false, value);
}
Vector GCBaseToggle::GetPosition1() const {
    return GetSchemaValue<Vector>(m_ptr, "CBaseToggle", "m_vecPosition1");
}
void GCBaseToggle::SetPosition1(Vector value) {
    SetSchemaValue(m_ptr, "CBaseToggle", "m_vecPosition1", false, value);
}
Vector GCBaseToggle::GetPosition2() const {
    return GetSchemaValue<Vector>(m_ptr, "CBaseToggle", "m_vecPosition2");
}
void GCBaseToggle::SetPosition2(Vector value) {
    SetSchemaValue(m_ptr, "CBaseToggle", "m_vecPosition2", false, value);
}
QAngle GCBaseToggle::GetMoveAng() const {
    return GetSchemaValue<QAngle>(m_ptr, "CBaseToggle", "m_vecMoveAng");
}
void GCBaseToggle::SetMoveAng(QAngle value) {
    SetSchemaValue(m_ptr, "CBaseToggle", "m_vecMoveAng", false, value);
}
QAngle GCBaseToggle::GetAngle1() const {
    return GetSchemaValue<QAngle>(m_ptr, "CBaseToggle", "m_vecAngle1");
}
void GCBaseToggle::SetAngle1(QAngle value) {
    SetSchemaValue(m_ptr, "CBaseToggle", "m_vecAngle1", false, value);
}
QAngle GCBaseToggle::GetAngle2() const {
    return GetSchemaValue<QAngle>(m_ptr, "CBaseToggle", "m_vecAngle2");
}
void GCBaseToggle::SetAngle2(QAngle value) {
    SetSchemaValue(m_ptr, "CBaseToggle", "m_vecAngle2", false, value);
}
float GCBaseToggle::GetHeight() const {
    return GetSchemaValue<float>(m_ptr, "CBaseToggle", "m_flHeight");
}
void GCBaseToggle::SetHeight(float value) {
    SetSchemaValue(m_ptr, "CBaseToggle", "m_flHeight", false, value);
}
GCBaseEntity GCBaseToggle::GetActivator() const {
    GCBaseEntity value(*GetSchemaValuePtr<void*>(m_ptr, "CBaseToggle", "m_hActivator"));
    return value;
}
void GCBaseToggle::SetActivator(GCBaseEntity* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Activator' is not possible.\n");
}
Vector GCBaseToggle::GetFinalDest() const {
    return GetSchemaValue<Vector>(m_ptr, "CBaseToggle", "m_vecFinalDest");
}
void GCBaseToggle::SetFinalDest(Vector value) {
    SetSchemaValue(m_ptr, "CBaseToggle", "m_vecFinalDest", false, value);
}
QAngle GCBaseToggle::GetFinalAngle() const {
    return GetSchemaValue<QAngle>(m_ptr, "CBaseToggle", "m_vecFinalAngle");
}
void GCBaseToggle::SetFinalAngle(QAngle value) {
    SetSchemaValue(m_ptr, "CBaseToggle", "m_vecFinalAngle", false, value);
}
int32_t GCBaseToggle::GetMovementType() const {
    return GetSchemaValue<int32_t>(m_ptr, "CBaseToggle", "m_movementType");
}
void GCBaseToggle::SetMovementType(int32_t value) {
    SetSchemaValue(m_ptr, "CBaseToggle", "m_movementType", false, value);
}
std::string GCBaseToggle::GetMaster() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CBaseToggle", "m_sMaster").String();
}
void GCBaseToggle::SetMaster(std::string value) {
    SetSchemaValue(m_ptr, "CBaseToggle", "m_sMaster", false, CUtlSymbolLarge(value.c_str()));
}
std::string GCBaseToggle::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCBaseToggle::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseModelEntity GCBaseToggle::GetParent() const {
    GCBaseModelEntity value(m_ptr);
    return value;
}
void GCBaseToggle::SetParent(GCBaseModelEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCBaseToggle(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCBaseToggle>("CBaseToggle")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Toggle_state", &GCBaseToggle::GetToggle_state, &GCBaseToggle::SetToggle_state)
        .addProperty("MoveDistance", &GCBaseToggle::GetMoveDistance, &GCBaseToggle::SetMoveDistance)
        .addProperty("Wait", &GCBaseToggle::GetWait, &GCBaseToggle::SetWait)
        .addProperty("Lip", &GCBaseToggle::GetLip, &GCBaseToggle::SetLip)
        .addProperty("AlwaysFireBlockedOutputs", &GCBaseToggle::GetAlwaysFireBlockedOutputs, &GCBaseToggle::SetAlwaysFireBlockedOutputs)
        .addProperty("Position1", &GCBaseToggle::GetPosition1, &GCBaseToggle::SetPosition1)
        .addProperty("Position2", &GCBaseToggle::GetPosition2, &GCBaseToggle::SetPosition2)
        .addProperty("MoveAng", &GCBaseToggle::GetMoveAng, &GCBaseToggle::SetMoveAng)
        .addProperty("Angle1", &GCBaseToggle::GetAngle1, &GCBaseToggle::SetAngle1)
        .addProperty("Angle2", &GCBaseToggle::GetAngle2, &GCBaseToggle::SetAngle2)
        .addProperty("Height", &GCBaseToggle::GetHeight, &GCBaseToggle::SetHeight)
        .addProperty("Activator", &GCBaseToggle::GetActivator, &GCBaseToggle::SetActivator)
        .addProperty("FinalDest", &GCBaseToggle::GetFinalDest, &GCBaseToggle::SetFinalDest)
        .addProperty("FinalAngle", &GCBaseToggle::GetFinalAngle, &GCBaseToggle::SetFinalAngle)
        .addProperty("MovementType", &GCBaseToggle::GetMovementType, &GCBaseToggle::SetMovementType)
        .addProperty("Master", &GCBaseToggle::GetMaster, &GCBaseToggle::SetMaster)
        .addProperty("Parent", &GCBaseToggle::GetParent, &GCBaseToggle::SetParent)
        .addFunction("ToPtr", &GCBaseToggle::ToPtr)
        .addFunction("IsValid", &GCBaseToggle::IsValid)
        .endClass();
}
GCBaseTrigger::GCBaseTrigger(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCBaseTrigger::GCBaseTrigger(void *ptr) {
    m_ptr = ptr;
}
bool GCBaseTrigger::GetDisabled() const {
    return GetSchemaValue<bool>(m_ptr, "CBaseTrigger", "m_bDisabled");
}
void GCBaseTrigger::SetDisabled(bool value) {
    SetSchemaValue(m_ptr, "CBaseTrigger", "m_bDisabled", false, value);
}
std::string GCBaseTrigger::GetFilterName() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CBaseTrigger", "m_iFilterName").String();
}
void GCBaseTrigger::SetFilterName(std::string value) {
    SetSchemaValue(m_ptr, "CBaseTrigger", "m_iFilterName", false, CUtlSymbolLarge(value.c_str()));
}
GCBaseFilter GCBaseTrigger::GetFilter() const {
    GCBaseFilter value(*GetSchemaValuePtr<void*>(m_ptr, "CBaseTrigger", "m_hFilter"));
    return value;
}
void GCBaseTrigger::SetFilter(GCBaseFilter* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Filter' is not possible.\n");
}
GCEntityIOOutput GCBaseTrigger::GetOnStartTouch() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CBaseTrigger", "m_OnStartTouch"));
    return value;
}
void GCBaseTrigger::SetOnStartTouch(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CBaseTrigger", "m_OnStartTouch", false, value);
}
GCEntityIOOutput GCBaseTrigger::GetOnStartTouchAll() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CBaseTrigger", "m_OnStartTouchAll"));
    return value;
}
void GCBaseTrigger::SetOnStartTouchAll(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CBaseTrigger", "m_OnStartTouchAll", false, value);
}
GCEntityIOOutput GCBaseTrigger::GetOnEndTouch() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CBaseTrigger", "m_OnEndTouch"));
    return value;
}
void GCBaseTrigger::SetOnEndTouch(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CBaseTrigger", "m_OnEndTouch", false, value);
}
GCEntityIOOutput GCBaseTrigger::GetOnEndTouchAll() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CBaseTrigger", "m_OnEndTouchAll"));
    return value;
}
void GCBaseTrigger::SetOnEndTouchAll(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CBaseTrigger", "m_OnEndTouchAll", false, value);
}
GCEntityIOOutput GCBaseTrigger::GetOnTouching() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CBaseTrigger", "m_OnTouching"));
    return value;
}
void GCBaseTrigger::SetOnTouching(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CBaseTrigger", "m_OnTouching", false, value);
}
GCEntityIOOutput GCBaseTrigger::GetOnTouchingEachEntity() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CBaseTrigger", "m_OnTouchingEachEntity"));
    return value;
}
void GCBaseTrigger::SetOnTouchingEachEntity(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CBaseTrigger", "m_OnTouchingEachEntity", false, value);
}
GCEntityIOOutput GCBaseTrigger::GetOnNotTouching() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CBaseTrigger", "m_OnNotTouching"));
    return value;
}
void GCBaseTrigger::SetOnNotTouching(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CBaseTrigger", "m_OnNotTouching", false, value);
}
bool GCBaseTrigger::GetClientSidePredicted() const {
    return GetSchemaValue<bool>(m_ptr, "CBaseTrigger", "m_bClientSidePredicted");
}
void GCBaseTrigger::SetClientSidePredicted(bool value) {
    SetSchemaValue(m_ptr, "CBaseTrigger", "m_bClientSidePredicted", false, value);
}
std::string GCBaseTrigger::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCBaseTrigger::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseToggle GCBaseTrigger::GetParent() const {
    GCBaseToggle value(m_ptr);
    return value;
}
void GCBaseTrigger::SetParent(GCBaseToggle value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCBaseTrigger(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCBaseTrigger>("CBaseTrigger")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Disabled", &GCBaseTrigger::GetDisabled, &GCBaseTrigger::SetDisabled)
        .addProperty("FilterName", &GCBaseTrigger::GetFilterName, &GCBaseTrigger::SetFilterName)
        .addProperty("Filter", &GCBaseTrigger::GetFilter, &GCBaseTrigger::SetFilter)
        .addProperty("OnStartTouch", &GCBaseTrigger::GetOnStartTouch, &GCBaseTrigger::SetOnStartTouch)
        .addProperty("OnStartTouchAll", &GCBaseTrigger::GetOnStartTouchAll, &GCBaseTrigger::SetOnStartTouchAll)
        .addProperty("OnEndTouch", &GCBaseTrigger::GetOnEndTouch, &GCBaseTrigger::SetOnEndTouch)
        .addProperty("OnEndTouchAll", &GCBaseTrigger::GetOnEndTouchAll, &GCBaseTrigger::SetOnEndTouchAll)
        .addProperty("OnTouching", &GCBaseTrigger::GetOnTouching, &GCBaseTrigger::SetOnTouching)
        .addProperty("OnTouchingEachEntity", &GCBaseTrigger::GetOnTouchingEachEntity, &GCBaseTrigger::SetOnTouchingEachEntity)
        .addProperty("OnNotTouching", &GCBaseTrigger::GetOnNotTouching, &GCBaseTrigger::SetOnNotTouching)
        .addProperty("ClientSidePredicted", &GCBaseTrigger::GetClientSidePredicted, &GCBaseTrigger::SetClientSidePredicted)
        .addProperty("Parent", &GCBaseTrigger::GetParent, &GCBaseTrigger::SetParent)
        .addFunction("ToPtr", &GCBaseTrigger::ToPtr)
        .addFunction("IsValid", &GCBaseTrigger::IsValid)
        .endClass();
}
GCTriggerProximity::GCTriggerProximity(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCTriggerProximity::GCTriggerProximity(void *ptr) {
    m_ptr = ptr;
}
GCBaseEntity GCTriggerProximity::GetMeasureTarget() const {
    GCBaseEntity value(*GetSchemaValuePtr<void*>(m_ptr, "CTriggerProximity", "m_hMeasureTarget"));
    return value;
}
void GCTriggerProximity::SetMeasureTarget(GCBaseEntity* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'MeasureTarget' is not possible.\n");
}
std::string GCTriggerProximity::GetMeasureTarget1() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CTriggerProximity", "m_iszMeasureTarget").String();
}
void GCTriggerProximity::SetMeasureTarget1(std::string value) {
    SetSchemaValue(m_ptr, "CTriggerProximity", "m_iszMeasureTarget", false, CUtlSymbolLarge(value.c_str()));
}
float GCTriggerProximity::GetRadius() const {
    return GetSchemaValue<float>(m_ptr, "CTriggerProximity", "m_fRadius");
}
void GCTriggerProximity::SetRadius(float value) {
    SetSchemaValue(m_ptr, "CTriggerProximity", "m_fRadius", false, value);
}
int32_t GCTriggerProximity::GetTouchers() const {
    return GetSchemaValue<int32_t>(m_ptr, "CTriggerProximity", "m_nTouchers");
}
void GCTriggerProximity::SetTouchers(int32_t value) {
    SetSchemaValue(m_ptr, "CTriggerProximity", "m_nTouchers", false, value);
}
std::string GCTriggerProximity::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCTriggerProximity::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseTrigger GCTriggerProximity::GetParent() const {
    GCBaseTrigger value(m_ptr);
    return value;
}
void GCTriggerProximity::SetParent(GCBaseTrigger value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCTriggerProximity(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCTriggerProximity>("CTriggerProximity")
        .addConstructor<void (*)(std::string)>()
        .addProperty("MeasureTarget", &GCTriggerProximity::GetMeasureTarget, &GCTriggerProximity::SetMeasureTarget)
        .addProperty("MeasureTarget1", &GCTriggerProximity::GetMeasureTarget1, &GCTriggerProximity::SetMeasureTarget1)
        .addProperty("Radius", &GCTriggerProximity::GetRadius, &GCTriggerProximity::SetRadius)
        .addProperty("Touchers", &GCTriggerProximity::GetTouchers, &GCTriggerProximity::SetTouchers)
        .addProperty("Parent", &GCTriggerProximity::GetParent, &GCTriggerProximity::SetParent)
        .addFunction("ToPtr", &GCTriggerProximity::ToPtr)
        .addFunction("IsValid", &GCTriggerProximity::IsValid)
        .endClass();
}
GCLogicalEntity::GCLogicalEntity(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCLogicalEntity::GCLogicalEntity(void *ptr) {
    m_ptr = ptr;
}
std::string GCLogicalEntity::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCLogicalEntity::IsValid() {
    return (m_ptr != nullptr);
}
GCServerOnlyEntity GCLogicalEntity::GetParent() const {
    GCServerOnlyEntity value(m_ptr);
    return value;
}
void GCLogicalEntity::SetParent(GCServerOnlyEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCLogicalEntity(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCLogicalEntity>("CLogicalEntity")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCLogicalEntity::GetParent, &GCLogicalEntity::SetParent)
        .addFunction("ToPtr", &GCLogicalEntity::ToPtr)
        .addFunction("IsValid", &GCLogicalEntity::IsValid)
        .endClass();
}
GCTriggerPush::GCTriggerPush(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCTriggerPush::GCTriggerPush(void *ptr) {
    m_ptr = ptr;
}
QAngle GCTriggerPush::GetPushEntitySpace() const {
    return GetSchemaValue<QAngle>(m_ptr, "CTriggerPush", "m_angPushEntitySpace");
}
void GCTriggerPush::SetPushEntitySpace(QAngle value) {
    SetSchemaValue(m_ptr, "CTriggerPush", "m_angPushEntitySpace", false, value);
}
Vector GCTriggerPush::GetPushDirEntitySpace() const {
    return GetSchemaValue<Vector>(m_ptr, "CTriggerPush", "m_vecPushDirEntitySpace");
}
void GCTriggerPush::SetPushDirEntitySpace(Vector value) {
    SetSchemaValue(m_ptr, "CTriggerPush", "m_vecPushDirEntitySpace", false, value);
}
bool GCTriggerPush::GetTriggerOnStartTouch() const {
    return GetSchemaValue<bool>(m_ptr, "CTriggerPush", "m_bTriggerOnStartTouch");
}
void GCTriggerPush::SetTriggerOnStartTouch(bool value) {
    SetSchemaValue(m_ptr, "CTriggerPush", "m_bTriggerOnStartTouch", false, value);
}
bool GCTriggerPush::GetUsePathSimple() const {
    return GetSchemaValue<bool>(m_ptr, "CTriggerPush", "m_bUsePathSimple");
}
void GCTriggerPush::SetUsePathSimple(bool value) {
    SetSchemaValue(m_ptr, "CTriggerPush", "m_bUsePathSimple", false, value);
}
std::string GCTriggerPush::GetPathSimpleName() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CTriggerPush", "m_iszPathSimpleName").String();
}
void GCTriggerPush::SetPathSimpleName(std::string value) {
    SetSchemaValue(m_ptr, "CTriggerPush", "m_iszPathSimpleName", false, CUtlSymbolLarge(value.c_str()));
}
GCPathSimple GCTriggerPush::GetPathSimple() const {
    GCPathSimple value(*GetSchemaValuePtr<void*>(m_ptr, "CTriggerPush", "m_PathSimple"));
    return value;
}
void GCTriggerPush::SetPathSimple(GCPathSimple* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'PathSimple' is not possible.\n");
}
uint32_t GCTriggerPush::GetSplinePushType() const {
    return GetSchemaValue<uint32_t>(m_ptr, "CTriggerPush", "m_splinePushType");
}
void GCTriggerPush::SetSplinePushType(uint32_t value) {
    SetSchemaValue(m_ptr, "CTriggerPush", "m_splinePushType", false, value);
}
std::string GCTriggerPush::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCTriggerPush::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseTrigger GCTriggerPush::GetParent() const {
    GCBaseTrigger value(m_ptr);
    return value;
}
void GCTriggerPush::SetParent(GCBaseTrigger value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCTriggerPush(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCTriggerPush>("CTriggerPush")
        .addConstructor<void (*)(std::string)>()
        .addProperty("PushEntitySpace", &GCTriggerPush::GetPushEntitySpace, &GCTriggerPush::SetPushEntitySpace)
        .addProperty("PushDirEntitySpace", &GCTriggerPush::GetPushDirEntitySpace, &GCTriggerPush::SetPushDirEntitySpace)
        .addProperty("TriggerOnStartTouch", &GCTriggerPush::GetTriggerOnStartTouch, &GCTriggerPush::SetTriggerOnStartTouch)
        .addProperty("UsePathSimple", &GCTriggerPush::GetUsePathSimple, &GCTriggerPush::SetUsePathSimple)
        .addProperty("PathSimpleName", &GCTriggerPush::GetPathSimpleName, &GCTriggerPush::SetPathSimpleName)
        .addProperty("PathSimple", &GCTriggerPush::GetPathSimple, &GCTriggerPush::SetPathSimple)
        .addProperty("SplinePushType", &GCTriggerPush::GetSplinePushType, &GCTriggerPush::SetSplinePushType)
        .addProperty("Parent", &GCTriggerPush::GetParent, &GCTriggerPush::SetParent)
        .addFunction("ToPtr", &GCTriggerPush::ToPtr)
        .addFunction("IsValid", &GCTriggerPush::IsValid)
        .endClass();
}
GCTriggerMultiple::GCTriggerMultiple(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCTriggerMultiple::GCTriggerMultiple(void *ptr) {
    m_ptr = ptr;
}
GCEntityIOOutput GCTriggerMultiple::GetOnTrigger() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CTriggerMultiple", "m_OnTrigger"));
    return value;
}
void GCTriggerMultiple::SetOnTrigger(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CTriggerMultiple", "m_OnTrigger", false, value);
}
std::string GCTriggerMultiple::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCTriggerMultiple::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseTrigger GCTriggerMultiple::GetParent() const {
    GCBaseTrigger value(m_ptr);
    return value;
}
void GCTriggerMultiple::SetParent(GCBaseTrigger value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCTriggerMultiple(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCTriggerMultiple>("CTriggerMultiple")
        .addConstructor<void (*)(std::string)>()
        .addProperty("OnTrigger", &GCTriggerMultiple::GetOnTrigger, &GCTriggerMultiple::SetOnTrigger)
        .addProperty("Parent", &GCTriggerMultiple::GetParent, &GCTriggerMultiple::SetParent)
        .addFunction("ToPtr", &GCTriggerMultiple::ToPtr)
        .addFunction("IsValid", &GCTriggerMultiple::IsValid)
        .endClass();
}
GCBasePlatTrain::GCBasePlatTrain(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCBasePlatTrain::GCBasePlatTrain(void *ptr) {
    m_ptr = ptr;
}
std::string GCBasePlatTrain::GetNoiseMoving() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CBasePlatTrain", "m_NoiseMoving").String();
}
void GCBasePlatTrain::SetNoiseMoving(std::string value) {
    SetSchemaValue(m_ptr, "CBasePlatTrain", "m_NoiseMoving", false, CUtlSymbolLarge(value.c_str()));
}
std::string GCBasePlatTrain::GetNoiseArrived() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CBasePlatTrain", "m_NoiseArrived").String();
}
void GCBasePlatTrain::SetNoiseArrived(std::string value) {
    SetSchemaValue(m_ptr, "CBasePlatTrain", "m_NoiseArrived", false, CUtlSymbolLarge(value.c_str()));
}
float GCBasePlatTrain::GetVolume() const {
    return GetSchemaValue<float>(m_ptr, "CBasePlatTrain", "m_volume");
}
void GCBasePlatTrain::SetVolume(float value) {
    SetSchemaValue(m_ptr, "CBasePlatTrain", "m_volume", false, value);
}
float GCBasePlatTrain::GetTWidth() const {
    return GetSchemaValue<float>(m_ptr, "CBasePlatTrain", "m_flTWidth");
}
void GCBasePlatTrain::SetTWidth(float value) {
    SetSchemaValue(m_ptr, "CBasePlatTrain", "m_flTWidth", false, value);
}
float GCBasePlatTrain::GetTLength() const {
    return GetSchemaValue<float>(m_ptr, "CBasePlatTrain", "m_flTLength");
}
void GCBasePlatTrain::SetTLength(float value) {
    SetSchemaValue(m_ptr, "CBasePlatTrain", "m_flTLength", false, value);
}
std::string GCBasePlatTrain::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCBasePlatTrain::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseToggle GCBasePlatTrain::GetParent() const {
    GCBaseToggle value(m_ptr);
    return value;
}
void GCBasePlatTrain::SetParent(GCBaseToggle value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCBasePlatTrain(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCBasePlatTrain>("CBasePlatTrain")
        .addConstructor<void (*)(std::string)>()
        .addProperty("NoiseMoving", &GCBasePlatTrain::GetNoiseMoving, &GCBasePlatTrain::SetNoiseMoving)
        .addProperty("NoiseArrived", &GCBasePlatTrain::GetNoiseArrived, &GCBasePlatTrain::SetNoiseArrived)
        .addProperty("Volume", &GCBasePlatTrain::GetVolume, &GCBasePlatTrain::SetVolume)
        .addProperty("TWidth", &GCBasePlatTrain::GetTWidth, &GCBasePlatTrain::SetTWidth)
        .addProperty("TLength", &GCBasePlatTrain::GetTLength, &GCBasePlatTrain::SetTLength)
        .addProperty("Parent", &GCBasePlatTrain::GetParent, &GCBasePlatTrain::SetParent)
        .addFunction("ToPtr", &GCBasePlatTrain::ToPtr)
        .addFunction("IsValid", &GCBasePlatTrain::IsValid)
        .endClass();
}
GCTonemapTrigger::GCTonemapTrigger(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCTonemapTrigger::GCTonemapTrigger(void *ptr) {
    m_ptr = ptr;
}
std::string GCTonemapTrigger::GetTonemapControllerName() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CTonemapTrigger", "m_tonemapControllerName").String();
}
void GCTonemapTrigger::SetTonemapControllerName(std::string value) {
    SetSchemaValue(m_ptr, "CTonemapTrigger", "m_tonemapControllerName", false, CUtlSymbolLarge(value.c_str()));
}
GCEntityInstance GCTonemapTrigger::GetTonemapController() const {
    GCEntityInstance value(*GetSchemaValuePtr<void*>(m_ptr, "CTonemapTrigger", "m_hTonemapController"));
    return value;
}
void GCTonemapTrigger::SetTonemapController(GCEntityInstance* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'TonemapController' is not possible.\n");
}
std::string GCTonemapTrigger::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCTonemapTrigger::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseTrigger GCTonemapTrigger::GetParent() const {
    GCBaseTrigger value(m_ptr);
    return value;
}
void GCTonemapTrigger::SetParent(GCBaseTrigger value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCTonemapTrigger(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCTonemapTrigger>("CTonemapTrigger")
        .addConstructor<void (*)(std::string)>()
        .addProperty("TonemapControllerName", &GCTonemapTrigger::GetTonemapControllerName, &GCTonemapTrigger::SetTonemapControllerName)
        .addProperty("TonemapController", &GCTonemapTrigger::GetTonemapController, &GCTonemapTrigger::SetTonemapController)
        .addProperty("Parent", &GCTonemapTrigger::GetParent, &GCTonemapTrigger::SetParent)
        .addFunction("ToPtr", &GCTonemapTrigger::ToPtr)
        .addFunction("IsValid", &GCTonemapTrigger::IsValid)
        .endClass();
}
GCEconItemAttribute::GCEconItemAttribute(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCEconItemAttribute::GCEconItemAttribute(void *ptr) {
    m_ptr = ptr;
}
uint16_t GCEconItemAttribute::GetAttributeDefinitionIndex() const {
    return GetSchemaValue<uint16_t>(m_ptr, "CEconItemAttribute", "m_iAttributeDefinitionIndex");
}
void GCEconItemAttribute::SetAttributeDefinitionIndex(uint16_t value) {
    SetSchemaValue(m_ptr, "CEconItemAttribute", "m_iAttributeDefinitionIndex", false, value);
}
float GCEconItemAttribute::GetValue() const {
    return GetSchemaValue<float>(m_ptr, "CEconItemAttribute", "m_flValue");
}
void GCEconItemAttribute::SetValue(float value) {
    SetSchemaValue(m_ptr, "CEconItemAttribute", "m_flValue", false, value);
}
float GCEconItemAttribute::GetInitialValue() const {
    return GetSchemaValue<float>(m_ptr, "CEconItemAttribute", "m_flInitialValue");
}
void GCEconItemAttribute::SetInitialValue(float value) {
    SetSchemaValue(m_ptr, "CEconItemAttribute", "m_flInitialValue", false, value);
}
int32_t GCEconItemAttribute::GetRefundableCurrency() const {
    return GetSchemaValue<int32_t>(m_ptr, "CEconItemAttribute", "m_nRefundableCurrency");
}
void GCEconItemAttribute::SetRefundableCurrency(int32_t value) {
    SetSchemaValue(m_ptr, "CEconItemAttribute", "m_nRefundableCurrency", false, value);
}
bool GCEconItemAttribute::GetSetBonus() const {
    return GetSchemaValue<bool>(m_ptr, "CEconItemAttribute", "m_bSetBonus");
}
void GCEconItemAttribute::SetSetBonus(bool value) {
    SetSchemaValue(m_ptr, "CEconItemAttribute", "m_bSetBonus", false, value);
}
std::string GCEconItemAttribute::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCEconItemAttribute::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCEconItemAttribute(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCEconItemAttribute>("CEconItemAttribute")
        .addConstructor<void (*)(std::string)>()
        .addProperty("AttributeDefinitionIndex", &GCEconItemAttribute::GetAttributeDefinitionIndex, &GCEconItemAttribute::SetAttributeDefinitionIndex)
        .addProperty("Value", &GCEconItemAttribute::GetValue, &GCEconItemAttribute::SetValue)
        .addProperty("InitialValue", &GCEconItemAttribute::GetInitialValue, &GCEconItemAttribute::SetInitialValue)
        .addProperty("RefundableCurrency", &GCEconItemAttribute::GetRefundableCurrency, &GCEconItemAttribute::SetRefundableCurrency)
        .addProperty("SetBonus", &GCEconItemAttribute::GetSetBonus, &GCEconItemAttribute::SetSetBonus)
        .addFunction("ToPtr", &GCEconItemAttribute::ToPtr)
        .addFunction("IsValid", &GCEconItemAttribute::IsValid)
        .endClass();
}
GCIronSightController::GCIronSightController(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCIronSightController::GCIronSightController(void *ptr) {
    m_ptr = ptr;
}
bool GCIronSightController::GetIronSightAvailable() const {
    return GetSchemaValue<bool>(m_ptr, "CIronSightController", "m_bIronSightAvailable");
}
void GCIronSightController::SetIronSightAvailable(bool value) {
    SetSchemaValue(m_ptr, "CIronSightController", "m_bIronSightAvailable", false, value);
}
float GCIronSightController::GetIronSightAmount() const {
    return GetSchemaValue<float>(m_ptr, "CIronSightController", "m_flIronSightAmount");
}
void GCIronSightController::SetIronSightAmount(float value) {
    SetSchemaValue(m_ptr, "CIronSightController", "m_flIronSightAmount", false, value);
}
float GCIronSightController::GetIronSightAmountGained() const {
    return GetSchemaValue<float>(m_ptr, "CIronSightController", "m_flIronSightAmountGained");
}
void GCIronSightController::SetIronSightAmountGained(float value) {
    SetSchemaValue(m_ptr, "CIronSightController", "m_flIronSightAmountGained", false, value);
}
float GCIronSightController::GetIronSightAmountBiased() const {
    return GetSchemaValue<float>(m_ptr, "CIronSightController", "m_flIronSightAmountBiased");
}
void GCIronSightController::SetIronSightAmountBiased(float value) {
    SetSchemaValue(m_ptr, "CIronSightController", "m_flIronSightAmountBiased", false, value);
}
std::string GCIronSightController::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCIronSightController::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCIronSightController(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCIronSightController>("CIronSightController")
        .addConstructor<void (*)(std::string)>()
        .addProperty("IronSightAvailable", &GCIronSightController::GetIronSightAvailable, &GCIronSightController::SetIronSightAvailable)
        .addProperty("IronSightAmount", &GCIronSightController::GetIronSightAmount, &GCIronSightController::SetIronSightAmount)
        .addProperty("IronSightAmountGained", &GCIronSightController::GetIronSightAmountGained, &GCIronSightController::SetIronSightAmountGained)
        .addProperty("IronSightAmountBiased", &GCIronSightController::GetIronSightAmountBiased, &GCIronSightController::SetIronSightAmountBiased)
        .addFunction("ToPtr", &GCIronSightController::ToPtr)
        .addFunction("IsValid", &GCIronSightController::IsValid)
        .endClass();
}
GCFogTrigger::GCFogTrigger(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCFogTrigger::GCFogTrigger(void *ptr) {
    m_ptr = ptr;
}
Gfogparams_t GCFogTrigger::GetFog() const {
    Gfogparams_t value(GetSchemaPtr(m_ptr, "CFogTrigger", "m_fog"));
    return value;
}
void GCFogTrigger::SetFog(Gfogparams_t value) {
    SetSchemaValue(m_ptr, "CFogTrigger", "m_fog", false, value);
}
std::string GCFogTrigger::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCFogTrigger::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseTrigger GCFogTrigger::GetParent() const {
    GCBaseTrigger value(m_ptr);
    return value;
}
void GCFogTrigger::SetParent(GCBaseTrigger value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCFogTrigger(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCFogTrigger>("CFogTrigger")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Fog", &GCFogTrigger::GetFog, &GCFogTrigger::SetFog)
        .addProperty("Parent", &GCFogTrigger::GetParent, &GCFogTrigger::SetParent)
        .addFunction("ToPtr", &GCFogTrigger::ToPtr)
        .addFunction("IsValid", &GCFogTrigger::IsValid)
        .endClass();
}
GCBaseFilter::GCBaseFilter(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCBaseFilter::GCBaseFilter(void *ptr) {
    m_ptr = ptr;
}
bool GCBaseFilter::GetNegated() const {
    return GetSchemaValue<bool>(m_ptr, "CBaseFilter", "m_bNegated");
}
void GCBaseFilter::SetNegated(bool value) {
    SetSchemaValue(m_ptr, "CBaseFilter", "m_bNegated", false, value);
}
GCEntityIOOutput GCBaseFilter::GetOnPass() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CBaseFilter", "m_OnPass"));
    return value;
}
void GCBaseFilter::SetOnPass(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CBaseFilter", "m_OnPass", false, value);
}
GCEntityIOOutput GCBaseFilter::GetOnFail() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CBaseFilter", "m_OnFail"));
    return value;
}
void GCBaseFilter::SetOnFail(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CBaseFilter", "m_OnFail", false, value);
}
std::string GCBaseFilter::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCBaseFilter::IsValid() {
    return (m_ptr != nullptr);
}
GCLogicalEntity GCBaseFilter::GetParent() const {
    GCLogicalEntity value(m_ptr);
    return value;
}
void GCBaseFilter::SetParent(GCLogicalEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCBaseFilter(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCBaseFilter>("CBaseFilter")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Negated", &GCBaseFilter::GetNegated, &GCBaseFilter::SetNegated)
        .addProperty("OnPass", &GCBaseFilter::GetOnPass, &GCBaseFilter::SetOnPass)
        .addProperty("OnFail", &GCBaseFilter::GetOnFail, &GCBaseFilter::SetOnFail)
        .addProperty("Parent", &GCBaseFilter::GetParent, &GCBaseFilter::SetParent)
        .addFunction("ToPtr", &GCBaseFilter::ToPtr)
        .addFunction("IsValid", &GCBaseFilter::IsValid)
        .endClass();
}
GCCSPointScriptExtensions_weapon_cs_base::GCCSPointScriptExtensions_weapon_cs_base(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCCSPointScriptExtensions_weapon_cs_base::GCCSPointScriptExtensions_weapon_cs_base(void *ptr) {
    m_ptr = ptr;
}
std::string GCCSPointScriptExtensions_weapon_cs_base::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCCSPointScriptExtensions_weapon_cs_base::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCCSPointScriptExtensions_weapon_cs_base(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCCSPointScriptExtensions_weapon_cs_base>("CCSPointScriptExtensions_weapon_cs_base")
        .addConstructor<void (*)(std::string)>()
        .addFunction("ToPtr", &GCCSPointScriptExtensions_weapon_cs_base::ToPtr)
        .addFunction("IsValid", &GCCSPointScriptExtensions_weapon_cs_base::IsValid)
        .endClass();
}
GCTriggerHostageReset::GCTriggerHostageReset(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCTriggerHostageReset::GCTriggerHostageReset(void *ptr) {
    m_ptr = ptr;
}
std::string GCTriggerHostageReset::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCTriggerHostageReset::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseTrigger GCTriggerHostageReset::GetParent() const {
    GCBaseTrigger value(m_ptr);
    return value;
}
void GCTriggerHostageReset::SetParent(GCBaseTrigger value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCTriggerHostageReset(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCTriggerHostageReset>("CTriggerHostageReset")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCTriggerHostageReset::GetParent, &GCTriggerHostageReset::SetParent)
        .addFunction("ToPtr", &GCTriggerHostageReset::ToPtr)
        .addFunction("IsValid", &GCTriggerHostageReset::IsValid)
        .endClass();
}
GCServerOnlyPointEntity::GCServerOnlyPointEntity(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCServerOnlyPointEntity::GCServerOnlyPointEntity(void *ptr) {
    m_ptr = ptr;
}
std::string GCServerOnlyPointEntity::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCServerOnlyPointEntity::IsValid() {
    return (m_ptr != nullptr);
}
GCServerOnlyEntity GCServerOnlyPointEntity::GetParent() const {
    GCServerOnlyEntity value(m_ptr);
    return value;
}
void GCServerOnlyPointEntity::SetParent(GCServerOnlyEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCServerOnlyPointEntity(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCServerOnlyPointEntity>("CServerOnlyPointEntity")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCServerOnlyPointEntity::GetParent, &GCServerOnlyPointEntity::SetParent)
        .addFunction("ToPtr", &GCServerOnlyPointEntity::ToPtr)
        .addFunction("IsValid", &GCServerOnlyPointEntity::IsValid)
        .endClass();
}
GCPointEntity::GCPointEntity(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCPointEntity::GCPointEntity(void *ptr) {
    m_ptr = ptr;
}
std::string GCPointEntity::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCPointEntity::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseEntity GCPointEntity::GetParent() const {
    GCBaseEntity value(m_ptr);
    return value;
}
void GCPointEntity::SetParent(GCBaseEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCPointEntity(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCPointEntity>("CPointEntity")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCPointEntity::GetParent, &GCPointEntity::SetParent)
        .addFunction("ToPtr", &GCPointEntity::ToPtr)
        .addFunction("IsValid", &GCPointEntity::IsValid)
        .endClass();
}
GCountdownTimer::GCountdownTimer(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCountdownTimer::GCountdownTimer(void *ptr) {
    m_ptr = ptr;
}
float GCountdownTimer::GetDuration() const {
    return GetSchemaValue<float>(m_ptr, "CountdownTimer", "m_duration");
}
void GCountdownTimer::SetDuration(float value) {
    SetSchemaValue(m_ptr, "CountdownTimer", "m_duration", false, value);
}
float GCountdownTimer::GetTimestamp() const {
    return GetSchemaValue<float>(m_ptr, "CountdownTimer", "m_timestamp");
}
void GCountdownTimer::SetTimestamp(float value) {
    SetSchemaValue(m_ptr, "CountdownTimer", "m_timestamp", false, value);
}
float GCountdownTimer::GetTimescale() const {
    return GetSchemaValue<float>(m_ptr, "CountdownTimer", "m_timescale");
}
void GCountdownTimer::SetTimescale(float value) {
    SetSchemaValue(m_ptr, "CountdownTimer", "m_timescale", false, value);
}
WorldGroupId_t GCountdownTimer::GetWorldGroupId() const {
    return GetSchemaValue<WorldGroupId_t>(m_ptr, "CountdownTimer", "m_nWorldGroupId");
}
void GCountdownTimer::SetWorldGroupId(WorldGroupId_t value) {
    SetSchemaValue(m_ptr, "CountdownTimer", "m_nWorldGroupId", false, value);
}
std::string GCountdownTimer::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCountdownTimer::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCountdownTimer(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCountdownTimer>("CountdownTimer")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Duration", &GCountdownTimer::GetDuration, &GCountdownTimer::SetDuration)
        .addProperty("Timestamp", &GCountdownTimer::GetTimestamp, &GCountdownTimer::SetTimestamp)
        .addProperty("Timescale", &GCountdownTimer::GetTimescale, &GCountdownTimer::SetTimescale)
        .addProperty("WorldGroupId", &GCountdownTimer::GetWorldGroupId, &GCountdownTimer::SetWorldGroupId)
        .addFunction("ToPtr", &GCountdownTimer::ToPtr)
        .addFunction("IsValid", &GCountdownTimer::IsValid)
        .endClass();
}
GSceneEventId_t::GSceneEventId_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GSceneEventId_t::GSceneEventId_t(void *ptr) {
    m_ptr = ptr;
}
uint32_t GSceneEventId_t::GetValue() const {
    return GetSchemaValue<uint32_t>(m_ptr, "SceneEventId_t", "m_Value");
}
void GSceneEventId_t::SetValue(uint32_t value) {
    SetSchemaValue(m_ptr, "SceneEventId_t", "m_Value", true, value);
}
std::string GSceneEventId_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GSceneEventId_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassSceneEventId_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GSceneEventId_t>("SceneEventId_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Value", &GSceneEventId_t::GetValue, &GSceneEventId_t::SetValue)
        .addFunction("ToPtr", &GSceneEventId_t::ToPtr)
        .addFunction("IsValid", &GSceneEventId_t::IsValid)
        .endClass();
}
GCBuoyancyHelper::GCBuoyancyHelper(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCBuoyancyHelper::GCBuoyancyHelper(void *ptr) {
    m_ptr = ptr;
}
float GCBuoyancyHelper::GetFluidDensity() const {
    return GetSchemaValue<float>(m_ptr, "CBuoyancyHelper", "m_flFluidDensity");
}
void GCBuoyancyHelper::SetFluidDensity(float value) {
    SetSchemaValue(m_ptr, "CBuoyancyHelper", "m_flFluidDensity", false, value);
}
std::string GCBuoyancyHelper::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCBuoyancyHelper::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCBuoyancyHelper(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCBuoyancyHelper>("CBuoyancyHelper")
        .addConstructor<void (*)(std::string)>()
        .addProperty("FluidDensity", &GCBuoyancyHelper::GetFluidDensity, &GCBuoyancyHelper::SetFluidDensity)
        .addFunction("ToPtr", &GCBuoyancyHelper::ToPtr)
        .addFunction("IsValid", &GCBuoyancyHelper::IsValid)
        .endClass();
}
GCMoverPathNode::GCMoverPathNode(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCMoverPathNode::GCMoverPathNode(void *ptr) {
    m_ptr = ptr;
}
Vector GCMoverPathNode::GetInTangentLocal() const {
    return GetSchemaValue<Vector>(m_ptr, "CMoverPathNode", "m_vInTangentLocal");
}
void GCMoverPathNode::SetInTangentLocal(Vector value) {
    SetSchemaValue(m_ptr, "CMoverPathNode", "m_vInTangentLocal", false, value);
}
Vector GCMoverPathNode::GetOutTangentLocal() const {
    return GetSchemaValue<Vector>(m_ptr, "CMoverPathNode", "m_vOutTangentLocal");
}
void GCMoverPathNode::SetOutTangentLocal(Vector value) {
    SetSchemaValue(m_ptr, "CMoverPathNode", "m_vOutTangentLocal", false, value);
}
std::string GCMoverPathNode::GetParentPathUniqueID() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CMoverPathNode", "m_szParentPathUniqueID").String();
}
void GCMoverPathNode::SetParentPathUniqueID(std::string value) {
    SetSchemaValue(m_ptr, "CMoverPathNode", "m_szParentPathUniqueID", false, CUtlSymbolLarge(value.c_str()));
}
GCEntityIOOutput GCMoverPathNode::GetOnPassThrough() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CMoverPathNode", "m_OnPassThrough"));
    return value;
}
void GCMoverPathNode::SetOnPassThrough(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CMoverPathNode", "m_OnPassThrough", false, value);
}
GCPathMover GCMoverPathNode::GetMover() const {
    GCPathMover value(*GetSchemaValuePtr<void*>(m_ptr, "CMoverPathNode", "m_hMover"));
    return value;
}
void GCMoverPathNode::SetMover(GCPathMover* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Mover' is not possible.\n");
}
std::string GCMoverPathNode::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCMoverPathNode::IsValid() {
    return (m_ptr != nullptr);
}
GCPointEntity GCMoverPathNode::GetParent() const {
    GCPointEntity value(m_ptr);
    return value;
}
void GCMoverPathNode::SetParent(GCPointEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCMoverPathNode(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCMoverPathNode>("CMoverPathNode")
        .addConstructor<void (*)(std::string)>()
        .addProperty("InTangentLocal", &GCMoverPathNode::GetInTangentLocal, &GCMoverPathNode::SetInTangentLocal)
        .addProperty("OutTangentLocal", &GCMoverPathNode::GetOutTangentLocal, &GCMoverPathNode::SetOutTangentLocal)
        .addProperty("ParentPathUniqueID", &GCMoverPathNode::GetParentPathUniqueID, &GCMoverPathNode::SetParentPathUniqueID)
        .addProperty("OnPassThrough", &GCMoverPathNode::GetOnPassThrough, &GCMoverPathNode::SetOnPassThrough)
        .addProperty("Mover", &GCMoverPathNode::GetMover, &GCMoverPathNode::SetMover)
        .addProperty("Parent", &GCMoverPathNode::GetParent, &GCMoverPathNode::SetParent)
        .addFunction("ToPtr", &GCMoverPathNode::ToPtr)
        .addFunction("IsValid", &GCMoverPathNode::IsValid)
        .endClass();
}
GCBtNode::GCBtNode(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCBtNode::GCBtNode(void *ptr) {
    m_ptr = ptr;
}
std::string GCBtNode::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCBtNode::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCBtNode(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCBtNode>("CBtNode")
        .addConstructor<void (*)(std::string)>()
        .addFunction("ToPtr", &GCBtNode::ToPtr)
        .addFunction("IsValid", &GCBtNode::IsValid)
        .endClass();
}
GCPlayer_ViewModelServices::GCPlayer_ViewModelServices(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCPlayer_ViewModelServices::GCPlayer_ViewModelServices(void *ptr) {
    m_ptr = ptr;
}
std::string GCPlayer_ViewModelServices::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCPlayer_ViewModelServices::IsValid() {
    return (m_ptr != nullptr);
}
GCPlayerPawnComponent GCPlayer_ViewModelServices::GetParent() const {
    GCPlayerPawnComponent value(m_ptr);
    return value;
}
void GCPlayer_ViewModelServices::SetParent(GCPlayerPawnComponent value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCPlayer_ViewModelServices(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCPlayer_ViewModelServices>("CPlayer_ViewModelServices")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCPlayer_ViewModelServices::GetParent, &GCPlayer_ViewModelServices::SetParent)
        .addFunction("ToPtr", &GCPlayer_ViewModelServices::ToPtr)
        .addFunction("IsValid", &GCPlayer_ViewModelServices::IsValid)
        .endClass();
}
GIEconItemInterface::GIEconItemInterface(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GIEconItemInterface::GIEconItemInterface(void *ptr) {
    m_ptr = ptr;
}
std::string GIEconItemInterface::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GIEconItemInterface::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassIEconItemInterface(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GIEconItemInterface>("IEconItemInterface")
        .addConstructor<void (*)(std::string)>()
        .addFunction("ToPtr", &GIEconItemInterface::ToPtr)
        .addFunction("IsValid", &GIEconItemInterface::IsValid)
        .endClass();
}
GCEnvSoundscape::GCEnvSoundscape(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCEnvSoundscape::GCEnvSoundscape(void *ptr) {
    m_ptr = ptr;
}
GCEntityIOOutput GCEnvSoundscape::GetOnPlay() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CEnvSoundscape", "m_OnPlay"));
    return value;
}
void GCEnvSoundscape::SetOnPlay(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CEnvSoundscape", "m_OnPlay", false, value);
}
float GCEnvSoundscape::GetRadius() const {
    return GetSchemaValue<float>(m_ptr, "CEnvSoundscape", "m_flRadius");
}
void GCEnvSoundscape::SetRadius(float value) {
    SetSchemaValue(m_ptr, "CEnvSoundscape", "m_flRadius", false, value);
}
std::string GCEnvSoundscape::GetSoundscapeName() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CEnvSoundscape", "m_soundscapeName").String();
}
void GCEnvSoundscape::SetSoundscapeName(std::string value) {
    SetSchemaValue(m_ptr, "CEnvSoundscape", "m_soundscapeName", false, CUtlSymbolLarge(value.c_str()));
}
std::string GCEnvSoundscape::GetSoundEventName() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CEnvSoundscape", "m_soundEventName").String();
}
void GCEnvSoundscape::SetSoundEventName(std::string value) {
    SetSchemaValue(m_ptr, "CEnvSoundscape", "m_soundEventName", false, CUtlSymbolLarge(value.c_str()));
}
bool GCEnvSoundscape::GetOverrideWithEvent() const {
    return GetSchemaValue<bool>(m_ptr, "CEnvSoundscape", "m_bOverrideWithEvent");
}
void GCEnvSoundscape::SetOverrideWithEvent(bool value) {
    SetSchemaValue(m_ptr, "CEnvSoundscape", "m_bOverrideWithEvent", false, value);
}
int32_t GCEnvSoundscape::GetSoundscapeIndex() const {
    return GetSchemaValue<int32_t>(m_ptr, "CEnvSoundscape", "m_soundscapeIndex");
}
void GCEnvSoundscape::SetSoundscapeIndex(int32_t value) {
    SetSchemaValue(m_ptr, "CEnvSoundscape", "m_soundscapeIndex", false, value);
}
int32_t GCEnvSoundscape::GetSoundscapeEntityListId() const {
    return GetSchemaValue<int32_t>(m_ptr, "CEnvSoundscape", "m_soundscapeEntityListId");
}
void GCEnvSoundscape::SetSoundscapeEntityListId(int32_t value) {
    SetSchemaValue(m_ptr, "CEnvSoundscape", "m_soundscapeEntityListId", false, value);
}
uint32_t GCEnvSoundscape::GetSoundEventHash() const {
    return GetSchemaValue<uint32_t>(m_ptr, "CEnvSoundscape", "m_soundEventHash");
}
void GCEnvSoundscape::SetSoundEventHash(uint32_t value) {
    SetSchemaValue(m_ptr, "CEnvSoundscape", "m_soundEventHash", false, value);
}
std::vector<CUtlSymbolLarge> GCEnvSoundscape::GetPositionNames() const {
    CUtlSymbolLarge* outValue = GetSchemaValue<CUtlSymbolLarge*>(m_ptr, "CEnvSoundscape", "m_positionNames"); std::vector<CUtlSymbolLarge> ret; for(int i = 0; i < 8; i++) { ret.push_back(outValue[i]); } return ret;
}
void GCEnvSoundscape::SetPositionNames(std::vector<CUtlSymbolLarge> value) {
    CUtlSymbolLarge* outValue = GetSchemaValue<CUtlSymbolLarge*>(m_ptr, "CEnvSoundscape", "m_positionNames"); for(int i = 0; i < 8; i++) { outValue[i] = value[i]; } SetSchemaValue(m_ptr, "CEnvSoundscape", "m_positionNames", false, outValue);
}
GCEnvSoundscape GCEnvSoundscape::GetProxySoundscape() const {
    GCEnvSoundscape value(*GetSchemaValuePtr<void*>(m_ptr, "CEnvSoundscape", "m_hProxySoundscape"));
    return value;
}
void GCEnvSoundscape::SetProxySoundscape(GCEnvSoundscape* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'ProxySoundscape' is not possible.\n");
}
bool GCEnvSoundscape::GetDisabled() const {
    return GetSchemaValue<bool>(m_ptr, "CEnvSoundscape", "m_bDisabled");
}
void GCEnvSoundscape::SetDisabled(bool value) {
    SetSchemaValue(m_ptr, "CEnvSoundscape", "m_bDisabled", false, value);
}
std::string GCEnvSoundscape::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCEnvSoundscape::IsValid() {
    return (m_ptr != nullptr);
}
GCServerOnlyEntity GCEnvSoundscape::GetParent() const {
    GCServerOnlyEntity value(m_ptr);
    return value;
}
void GCEnvSoundscape::SetParent(GCServerOnlyEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCEnvSoundscape(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCEnvSoundscape>("CEnvSoundscape")
        .addConstructor<void (*)(std::string)>()
        .addProperty("OnPlay", &GCEnvSoundscape::GetOnPlay, &GCEnvSoundscape::SetOnPlay)
        .addProperty("Radius", &GCEnvSoundscape::GetRadius, &GCEnvSoundscape::SetRadius)
        .addProperty("SoundscapeName", &GCEnvSoundscape::GetSoundscapeName, &GCEnvSoundscape::SetSoundscapeName)
        .addProperty("SoundEventName", &GCEnvSoundscape::GetSoundEventName, &GCEnvSoundscape::SetSoundEventName)
        .addProperty("OverrideWithEvent", &GCEnvSoundscape::GetOverrideWithEvent, &GCEnvSoundscape::SetOverrideWithEvent)
        .addProperty("SoundscapeIndex", &GCEnvSoundscape::GetSoundscapeIndex, &GCEnvSoundscape::SetSoundscapeIndex)
        .addProperty("SoundscapeEntityListId", &GCEnvSoundscape::GetSoundscapeEntityListId, &GCEnvSoundscape::SetSoundscapeEntityListId)
        .addProperty("SoundEventHash", &GCEnvSoundscape::GetSoundEventHash, &GCEnvSoundscape::SetSoundEventHash)
        .addProperty("PositionNames", &GCEnvSoundscape::GetPositionNames, &GCEnvSoundscape::SetPositionNames)
        .addProperty("ProxySoundscape", &GCEnvSoundscape::GetProxySoundscape, &GCEnvSoundscape::SetProxySoundscape)
        .addProperty("Disabled", &GCEnvSoundscape::GetDisabled, &GCEnvSoundscape::SetDisabled)
        .addProperty("Parent", &GCEnvSoundscape::GetParent, &GCEnvSoundscape::SetParent)
        .addFunction("ToPtr", &GCEnvSoundscape::ToPtr)
        .addFunction("IsValid", &GCEnvSoundscape::IsValid)
        .endClass();
}
Gfogplayerparams_t::Gfogplayerparams_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
Gfogplayerparams_t::Gfogplayerparams_t(void *ptr) {
    m_ptr = ptr;
}
GCFogController Gfogplayerparams_t::GetCtrl() const {
    GCFogController value(*GetSchemaValuePtr<void*>(m_ptr, "fogplayerparams_t", "m_hCtrl"));
    return value;
}
void Gfogplayerparams_t::SetCtrl(GCFogController* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Ctrl' is not possible.\n");
}
float Gfogplayerparams_t::GetTransitionTime() const {
    return GetSchemaValue<float>(m_ptr, "fogplayerparams_t", "m_flTransitionTime");
}
void Gfogplayerparams_t::SetTransitionTime(float value) {
    SetSchemaValue(m_ptr, "fogplayerparams_t", "m_flTransitionTime", true, value);
}
Color Gfogplayerparams_t::GetOldColor() const {
    return GetSchemaValue<Color>(m_ptr, "fogplayerparams_t", "m_OldColor");
}
void Gfogplayerparams_t::SetOldColor(Color value) {
    SetSchemaValue(m_ptr, "fogplayerparams_t", "m_OldColor", true, value);
}
float Gfogplayerparams_t::GetOldStart() const {
    return GetSchemaValue<float>(m_ptr, "fogplayerparams_t", "m_flOldStart");
}
void Gfogplayerparams_t::SetOldStart(float value) {
    SetSchemaValue(m_ptr, "fogplayerparams_t", "m_flOldStart", true, value);
}
float Gfogplayerparams_t::GetOldEnd() const {
    return GetSchemaValue<float>(m_ptr, "fogplayerparams_t", "m_flOldEnd");
}
void Gfogplayerparams_t::SetOldEnd(float value) {
    SetSchemaValue(m_ptr, "fogplayerparams_t", "m_flOldEnd", true, value);
}
float Gfogplayerparams_t::GetOldMaxDensity() const {
    return GetSchemaValue<float>(m_ptr, "fogplayerparams_t", "m_flOldMaxDensity");
}
void Gfogplayerparams_t::SetOldMaxDensity(float value) {
    SetSchemaValue(m_ptr, "fogplayerparams_t", "m_flOldMaxDensity", true, value);
}
float Gfogplayerparams_t::GetOldHDRColorScale() const {
    return GetSchemaValue<float>(m_ptr, "fogplayerparams_t", "m_flOldHDRColorScale");
}
void Gfogplayerparams_t::SetOldHDRColorScale(float value) {
    SetSchemaValue(m_ptr, "fogplayerparams_t", "m_flOldHDRColorScale", true, value);
}
float Gfogplayerparams_t::GetOldFarZ() const {
    return GetSchemaValue<float>(m_ptr, "fogplayerparams_t", "m_flOldFarZ");
}
void Gfogplayerparams_t::SetOldFarZ(float value) {
    SetSchemaValue(m_ptr, "fogplayerparams_t", "m_flOldFarZ", true, value);
}
Color Gfogplayerparams_t::GetNewColor() const {
    return GetSchemaValue<Color>(m_ptr, "fogplayerparams_t", "m_NewColor");
}
void Gfogplayerparams_t::SetNewColor(Color value) {
    SetSchemaValue(m_ptr, "fogplayerparams_t", "m_NewColor", true, value);
}
float Gfogplayerparams_t::GetNewStart() const {
    return GetSchemaValue<float>(m_ptr, "fogplayerparams_t", "m_flNewStart");
}
void Gfogplayerparams_t::SetNewStart(float value) {
    SetSchemaValue(m_ptr, "fogplayerparams_t", "m_flNewStart", true, value);
}
float Gfogplayerparams_t::GetNewEnd() const {
    return GetSchemaValue<float>(m_ptr, "fogplayerparams_t", "m_flNewEnd");
}
void Gfogplayerparams_t::SetNewEnd(float value) {
    SetSchemaValue(m_ptr, "fogplayerparams_t", "m_flNewEnd", true, value);
}
float Gfogplayerparams_t::GetNewMaxDensity() const {
    return GetSchemaValue<float>(m_ptr, "fogplayerparams_t", "m_flNewMaxDensity");
}
void Gfogplayerparams_t::SetNewMaxDensity(float value) {
    SetSchemaValue(m_ptr, "fogplayerparams_t", "m_flNewMaxDensity", true, value);
}
float Gfogplayerparams_t::GetNewHDRColorScale() const {
    return GetSchemaValue<float>(m_ptr, "fogplayerparams_t", "m_flNewHDRColorScale");
}
void Gfogplayerparams_t::SetNewHDRColorScale(float value) {
    SetSchemaValue(m_ptr, "fogplayerparams_t", "m_flNewHDRColorScale", true, value);
}
float Gfogplayerparams_t::GetNewFarZ() const {
    return GetSchemaValue<float>(m_ptr, "fogplayerparams_t", "m_flNewFarZ");
}
void Gfogplayerparams_t::SetNewFarZ(float value) {
    SetSchemaValue(m_ptr, "fogplayerparams_t", "m_flNewFarZ", true, value);
}
std::string Gfogplayerparams_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool Gfogplayerparams_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassfogplayerparams_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<Gfogplayerparams_t>("fogplayerparams_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Ctrl", &Gfogplayerparams_t::GetCtrl, &Gfogplayerparams_t::SetCtrl)
        .addProperty("TransitionTime", &Gfogplayerparams_t::GetTransitionTime, &Gfogplayerparams_t::SetTransitionTime)
        .addProperty("OldColor", &Gfogplayerparams_t::GetOldColor, &Gfogplayerparams_t::SetOldColor)
        .addProperty("OldStart", &Gfogplayerparams_t::GetOldStart, &Gfogplayerparams_t::SetOldStart)
        .addProperty("OldEnd", &Gfogplayerparams_t::GetOldEnd, &Gfogplayerparams_t::SetOldEnd)
        .addProperty("OldMaxDensity", &Gfogplayerparams_t::GetOldMaxDensity, &Gfogplayerparams_t::SetOldMaxDensity)
        .addProperty("OldHDRColorScale", &Gfogplayerparams_t::GetOldHDRColorScale, &Gfogplayerparams_t::SetOldHDRColorScale)
        .addProperty("OldFarZ", &Gfogplayerparams_t::GetOldFarZ, &Gfogplayerparams_t::SetOldFarZ)
        .addProperty("NewColor", &Gfogplayerparams_t::GetNewColor, &Gfogplayerparams_t::SetNewColor)
        .addProperty("NewStart", &Gfogplayerparams_t::GetNewStart, &Gfogplayerparams_t::SetNewStart)
        .addProperty("NewEnd", &Gfogplayerparams_t::GetNewEnd, &Gfogplayerparams_t::SetNewEnd)
        .addProperty("NewMaxDensity", &Gfogplayerparams_t::GetNewMaxDensity, &Gfogplayerparams_t::SetNewMaxDensity)
        .addProperty("NewHDRColorScale", &Gfogplayerparams_t::GetNewHDRColorScale, &Gfogplayerparams_t::SetNewHDRColorScale)
        .addProperty("NewFarZ", &Gfogplayerparams_t::GetNewFarZ, &Gfogplayerparams_t::SetNewFarZ)
        .addFunction("ToPtr", &Gfogplayerparams_t::ToPtr)
        .addFunction("IsValid", &Gfogplayerparams_t::IsValid)
        .endClass();
}
GCFogController::GCFogController(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCFogController::GCFogController(void *ptr) {
    m_ptr = ptr;
}
Gfogparams_t GCFogController::GetFog() const {
    Gfogparams_t value(GetSchemaPtr(m_ptr, "CFogController", "m_fog"));
    return value;
}
void GCFogController::SetFog(Gfogparams_t value) {
    SetSchemaValue(m_ptr, "CFogController", "m_fog", false, value);
}
bool GCFogController::GetUseAngles() const {
    return GetSchemaValue<bool>(m_ptr, "CFogController", "m_bUseAngles");
}
void GCFogController::SetUseAngles(bool value) {
    SetSchemaValue(m_ptr, "CFogController", "m_bUseAngles", false, value);
}
int32_t GCFogController::GetChangedVariables() const {
    return GetSchemaValue<int32_t>(m_ptr, "CFogController", "m_iChangedVariables");
}
void GCFogController::SetChangedVariables(int32_t value) {
    SetSchemaValue(m_ptr, "CFogController", "m_iChangedVariables", false, value);
}
std::string GCFogController::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCFogController::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseEntity GCFogController::GetParent() const {
    GCBaseEntity value(m_ptr);
    return value;
}
void GCFogController::SetParent(GCBaseEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCFogController(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCFogController>("CFogController")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Fog", &GCFogController::GetFog, &GCFogController::SetFog)
        .addProperty("UseAngles", &GCFogController::GetUseAngles, &GCFogController::SetUseAngles)
        .addProperty("ChangedVariables", &GCFogController::GetChangedVariables, &GCFogController::SetChangedVariables)
        .addProperty("Parent", &GCFogController::GetParent, &GCFogController::SetParent)
        .addFunction("ToPtr", &GCFogController::ToPtr)
        .addFunction("IsValid", &GCFogController::IsValid)
        .endClass();
}
GCAttributeList::GCAttributeList(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCAttributeList::GCAttributeList(void *ptr) {
    m_ptr = ptr;
}
std::vector<GCEconItemAttribute> GCAttributeList::GetAttributes() const {
    CUtlVector<GCEconItemAttribute>* vec = GetSchemaValue<CUtlVector<GCEconItemAttribute>*>(m_ptr, "CAttributeList", "m_Attributes"); std::vector<GCEconItemAttribute> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCAttributeList::SetAttributes(std::vector<GCEconItemAttribute> value) {
    SetSchemaValueCUtlVector<GCEconItemAttribute>(m_ptr, "CAttributeList", "m_Attributes", false, value);
}
GCAttributeManager GCAttributeList::GetManager() const {
    GCAttributeManager value(*GetSchemaValuePtr<void*>(m_ptr, "CAttributeList", "m_pManager"));
    return value;
}
void GCAttributeList::SetManager(GCAttributeManager* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Manager' is not possible.\n");
}
std::string GCAttributeList::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCAttributeList::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCAttributeList(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCAttributeList>("CAttributeList")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Attributes", &GCAttributeList::GetAttributes, &GCAttributeList::SetAttributes)
        .addProperty("Manager", &GCAttributeList::GetManager, &GCAttributeList::SetManager)
        .addFunction("ToPtr", &GCAttributeList::ToPtr)
        .addFunction("IsValid", &GCAttributeList::IsValid)
        .endClass();
}
GCModelState::GCModelState(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCModelState::GCModelState(void *ptr) {
    m_ptr = ptr;
}
std::string GCModelState::GetModelName() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CModelState", "m_ModelName").String();
}
void GCModelState::SetModelName(std::string value) {
    SetSchemaValue(m_ptr, "CModelState", "m_ModelName", false, CUtlSymbolLarge(value.c_str()));
}
bool GCModelState::GetClientClothCreationSuppressed() const {
    return GetSchemaValue<bool>(m_ptr, "CModelState", "m_bClientClothCreationSuppressed");
}
void GCModelState::SetClientClothCreationSuppressed(bool value) {
    SetSchemaValue(m_ptr, "CModelState", "m_bClientClothCreationSuppressed", false, value);
}
uint64_t GCModelState::GetMeshGroupMask() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CModelState", "m_MeshGroupMask");
}
void GCModelState::SetMeshGroupMask(uint64_t value) {
    SetSchemaValue(m_ptr, "CModelState", "m_MeshGroupMask", false, value);
}
int8_t GCModelState::GetIdealMotionType() const {
    return GetSchemaValue<int8_t>(m_ptr, "CModelState", "m_nIdealMotionType");
}
void GCModelState::SetIdealMotionType(int8_t value) {
    SetSchemaValue(m_ptr, "CModelState", "m_nIdealMotionType", false, value);
}
int8_t GCModelState::GetForceLOD() const {
    return GetSchemaValue<int8_t>(m_ptr, "CModelState", "m_nForceLOD");
}
void GCModelState::SetForceLOD(int8_t value) {
    SetSchemaValue(m_ptr, "CModelState", "m_nForceLOD", false, value);
}
int8_t GCModelState::GetClothUpdateFlags() const {
    return GetSchemaValue<int8_t>(m_ptr, "CModelState", "m_nClothUpdateFlags");
}
void GCModelState::SetClothUpdateFlags(int8_t value) {
    SetSchemaValue(m_ptr, "CModelState", "m_nClothUpdateFlags", false, value);
}
std::string GCModelState::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCModelState::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCModelState(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCModelState>("CModelState")
        .addConstructor<void (*)(std::string)>()
        .addProperty("ModelName", &GCModelState::GetModelName, &GCModelState::SetModelName)
        .addProperty("ClientClothCreationSuppressed", &GCModelState::GetClientClothCreationSuppressed, &GCModelState::SetClientClothCreationSuppressed)
        .addProperty("MeshGroupMask", &GCModelState::GetMeshGroupMask, &GCModelState::SetMeshGroupMask)
        .addProperty("IdealMotionType", &GCModelState::GetIdealMotionType, &GCModelState::SetIdealMotionType)
        .addProperty("ForceLOD", &GCModelState::GetForceLOD, &GCModelState::SetForceLOD)
        .addProperty("ClothUpdateFlags", &GCModelState::GetClothUpdateFlags, &GCModelState::SetClothUpdateFlags)
        .addFunction("ToPtr", &GCModelState::ToPtr)
        .addFunction("IsValid", &GCModelState::IsValid)
        .endClass();
}
GCBaseAnimGraph::GCBaseAnimGraph(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCBaseAnimGraph::GCBaseAnimGraph(void *ptr) {
    m_ptr = ptr;
}
bool GCBaseAnimGraph::GetInitiallyPopulateInterpHistory() const {
    return GetSchemaValue<bool>(m_ptr, "CBaseAnimGraph", "m_bInitiallyPopulateInterpHistory");
}
void GCBaseAnimGraph::SetInitiallyPopulateInterpHistory(bool value) {
    SetSchemaValue(m_ptr, "CBaseAnimGraph", "m_bInitiallyPopulateInterpHistory", false, value);
}
GIChoreoServices GCBaseAnimGraph::GetChoreoServices() const {
    GIChoreoServices value(*GetSchemaValuePtr<void*>(m_ptr, "CBaseAnimGraph", "m_pChoreoServices"));
    return value;
}
void GCBaseAnimGraph::SetChoreoServices(GIChoreoServices* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'ChoreoServices' is not possible.\n");
}
bool GCBaseAnimGraph::GetAnimGraphUpdateEnabled() const {
    return GetSchemaValue<bool>(m_ptr, "CBaseAnimGraph", "m_bAnimGraphUpdateEnabled");
}
void GCBaseAnimGraph::SetAnimGraphUpdateEnabled(bool value) {
    SetSchemaValue(m_ptr, "CBaseAnimGraph", "m_bAnimGraphUpdateEnabled", false, value);
}
float GCBaseAnimGraph::GetMaxSlopeDistance() const {
    return GetSchemaValue<float>(m_ptr, "CBaseAnimGraph", "m_flMaxSlopeDistance");
}
void GCBaseAnimGraph::SetMaxSlopeDistance(float value) {
    SetSchemaValue(m_ptr, "CBaseAnimGraph", "m_flMaxSlopeDistance", false, value);
}
Vector GCBaseAnimGraph::GetLastSlopeCheckPos() const {
    return GetSchemaValue<Vector>(m_ptr, "CBaseAnimGraph", "m_vLastSlopeCheckPos");
}
void GCBaseAnimGraph::SetLastSlopeCheckPos(Vector value) {
    SetSchemaValue(m_ptr, "CBaseAnimGraph", "m_vLastSlopeCheckPos", false, value);
}
bool GCBaseAnimGraph::GetAnimationUpdateScheduled() const {
    return GetSchemaValue<bool>(m_ptr, "CBaseAnimGraph", "m_bAnimationUpdateScheduled");
}
void GCBaseAnimGraph::SetAnimationUpdateScheduled(bool value) {
    SetSchemaValue(m_ptr, "CBaseAnimGraph", "m_bAnimationUpdateScheduled", false, value);
}
Vector GCBaseAnimGraph::GetForce() const {
    return GetSchemaValue<Vector>(m_ptr, "CBaseAnimGraph", "m_vecForce");
}
void GCBaseAnimGraph::SetForce(Vector value) {
    SetSchemaValue(m_ptr, "CBaseAnimGraph", "m_vecForce", false, value);
}
int32_t GCBaseAnimGraph::GetForceBone() const {
    return GetSchemaValue<int32_t>(m_ptr, "CBaseAnimGraph", "m_nForceBone");
}
void GCBaseAnimGraph::SetForceBone(int32_t value) {
    SetSchemaValue(m_ptr, "CBaseAnimGraph", "m_nForceBone", false, value);
}
GPhysicsRagdollPose_t GCBaseAnimGraph::GetRagdollPose() const {
    GPhysicsRagdollPose_t value(*GetSchemaValuePtr<void*>(m_ptr, "CBaseAnimGraph", "m_pRagdollPose"));
    return value;
}
void GCBaseAnimGraph::SetRagdollPose(GPhysicsRagdollPose_t* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'RagdollPose' is not possible.\n");
}
bool GCBaseAnimGraph::GetRagdollClientSide() const {
    return GetSchemaValue<bool>(m_ptr, "CBaseAnimGraph", "m_bRagdollClientSide");
}
void GCBaseAnimGraph::SetRagdollClientSide(bool value) {
    SetSchemaValue(m_ptr, "CBaseAnimGraph", "m_bRagdollClientSide", false, value);
}
std::string GCBaseAnimGraph::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCBaseAnimGraph::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseModelEntity GCBaseAnimGraph::GetParent() const {
    GCBaseModelEntity value(m_ptr);
    return value;
}
void GCBaseAnimGraph::SetParent(GCBaseModelEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCBaseAnimGraph(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCBaseAnimGraph>("CBaseAnimGraph")
        .addConstructor<void (*)(std::string)>()
        .addProperty("InitiallyPopulateInterpHistory", &GCBaseAnimGraph::GetInitiallyPopulateInterpHistory, &GCBaseAnimGraph::SetInitiallyPopulateInterpHistory)
        .addProperty("ChoreoServices", &GCBaseAnimGraph::GetChoreoServices, &GCBaseAnimGraph::SetChoreoServices)
        .addProperty("AnimGraphUpdateEnabled", &GCBaseAnimGraph::GetAnimGraphUpdateEnabled, &GCBaseAnimGraph::SetAnimGraphUpdateEnabled)
        .addProperty("MaxSlopeDistance", &GCBaseAnimGraph::GetMaxSlopeDistance, &GCBaseAnimGraph::SetMaxSlopeDistance)
        .addProperty("LastSlopeCheckPos", &GCBaseAnimGraph::GetLastSlopeCheckPos, &GCBaseAnimGraph::SetLastSlopeCheckPos)
        .addProperty("AnimationUpdateScheduled", &GCBaseAnimGraph::GetAnimationUpdateScheduled, &GCBaseAnimGraph::SetAnimationUpdateScheduled)
        .addProperty("Force", &GCBaseAnimGraph::GetForce, &GCBaseAnimGraph::SetForce)
        .addProperty("ForceBone", &GCBaseAnimGraph::GetForceBone, &GCBaseAnimGraph::SetForceBone)
        .addProperty("RagdollPose", &GCBaseAnimGraph::GetRagdollPose, &GCBaseAnimGraph::SetRagdollPose)
        .addProperty("RagdollClientSide", &GCBaseAnimGraph::GetRagdollClientSide, &GCBaseAnimGraph::SetRagdollClientSide)
        .addProperty("Parent", &GCBaseAnimGraph::GetParent, &GCBaseAnimGraph::SetParent)
        .addFunction("ToPtr", &GCBaseAnimGraph::ToPtr)
        .addFunction("IsValid", &GCBaseAnimGraph::IsValid)
        .endClass();
}
GCEnableMotionFixup::GCEnableMotionFixup(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCEnableMotionFixup::GCEnableMotionFixup(void *ptr) {
    m_ptr = ptr;
}
std::string GCEnableMotionFixup::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCEnableMotionFixup::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseEntity GCEnableMotionFixup::GetParent() const {
    GCBaseEntity value(m_ptr);
    return value;
}
void GCEnableMotionFixup::SetParent(GCBaseEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCEnableMotionFixup(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCEnableMotionFixup>("CEnableMotionFixup")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCEnableMotionFixup::GetParent, &GCEnableMotionFixup::SetParent)
        .addFunction("ToPtr", &GCEnableMotionFixup::ToPtr)
        .addFunction("IsValid", &GCEnableMotionFixup::IsValid)
        .endClass();
}
GCInButtonState::GCInButtonState(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCInButtonState::GCInButtonState(void *ptr) {
    m_ptr = ptr;
}
std::vector<uint64_t> GCInButtonState::GetButtonStates() const {
    uint64_t* outValue = GetSchemaValue<uint64_t*>(m_ptr, "CInButtonState", "m_pButtonStates"); std::vector<uint64_t> ret; for(int i = 0; i < 3; i++) { ret.push_back(outValue[i]); } return ret;
}
void GCInButtonState::SetButtonStates(std::vector<uint64_t> value) {
    uint64_t* outValue = GetSchemaValue<uint64_t*>(m_ptr, "CInButtonState", "m_pButtonStates"); for(int i = 0; i < 3; i++) { outValue[i] = value[i]; } SetSchemaValue(m_ptr, "CInButtonState", "m_pButtonStates", false, outValue);
}
std::string GCInButtonState::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCInButtonState::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCInButtonState(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCInButtonState>("CInButtonState")
        .addConstructor<void (*)(std::string)>()
        .addProperty("ButtonStates", &GCInButtonState::GetButtonStates, &GCInButtonState::SetButtonStates)
        .addFunction("ToPtr", &GCInButtonState::ToPtr)
        .addFunction("IsValid", &GCInButtonState::IsValid)
        .endClass();
}
GCBtNodeDecorator::GCBtNodeDecorator(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCBtNodeDecorator::GCBtNodeDecorator(void *ptr) {
    m_ptr = ptr;
}
std::string GCBtNodeDecorator::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCBtNodeDecorator::IsValid() {
    return (m_ptr != nullptr);
}
GCBtNode GCBtNodeDecorator::GetParent() const {
    GCBtNode value(m_ptr);
    return value;
}
void GCBtNodeDecorator::SetParent(GCBtNode value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCBtNodeDecorator(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCBtNodeDecorator>("CBtNodeDecorator")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCBtNodeDecorator::GetParent, &GCBtNodeDecorator::SetParent)
        .addFunction("ToPtr", &GCBtNodeDecorator::ToPtr)
        .addFunction("IsValid", &GCBtNodeDecorator::IsValid)
        .endClass();
}
GCAttributeManager::GCAttributeManager(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCAttributeManager::GCAttributeManager(void *ptr) {
    m_ptr = ptr;
}
int32_t GCAttributeManager::GetReapplyProvisionParity() const {
    return GetSchemaValue<int32_t>(m_ptr, "CAttributeManager", "m_iReapplyProvisionParity");
}
void GCAttributeManager::SetReapplyProvisionParity(int32_t value) {
    SetSchemaValue(m_ptr, "CAttributeManager", "m_iReapplyProvisionParity", false, value);
}
GCBaseEntity GCAttributeManager::GetOuter() const {
    GCBaseEntity value(*GetSchemaValuePtr<void*>(m_ptr, "CAttributeManager", "m_hOuter"));
    return value;
}
void GCAttributeManager::SetOuter(GCBaseEntity* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Outer' is not possible.\n");
}
bool GCAttributeManager::GetPreventLoopback() const {
    return GetSchemaValue<bool>(m_ptr, "CAttributeManager", "m_bPreventLoopback");
}
void GCAttributeManager::SetPreventLoopback(bool value) {
    SetSchemaValue(m_ptr, "CAttributeManager", "m_bPreventLoopback", false, value);
}
uint64_t GCAttributeManager::GetProviderType() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CAttributeManager", "m_ProviderType");
}
void GCAttributeManager::SetProviderType(uint64_t value) {
    SetSchemaValue(m_ptr, "CAttributeManager", "m_ProviderType", false, value);
}
std::vector<GCAttributeManager> GCAttributeManager::GetCachedResults() const {
    CUtlVector<GCAttributeManager>* vec = GetSchemaValue<CUtlVector<GCAttributeManager>*>(m_ptr, "CAttributeManager", "m_CachedResults"); std::vector<GCAttributeManager> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCAttributeManager::SetCachedResults(std::vector<GCAttributeManager> value) {
    SetSchemaValueCUtlVector<GCAttributeManager>(m_ptr, "CAttributeManager", "m_CachedResults", false, value);
}
std::string GCAttributeManager::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCAttributeManager::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCAttributeManager(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCAttributeManager>("CAttributeManager")
        .addConstructor<void (*)(std::string)>()
        .addProperty("ReapplyProvisionParity", &GCAttributeManager::GetReapplyProvisionParity, &GCAttributeManager::SetReapplyProvisionParity)
        .addProperty("Outer", &GCAttributeManager::GetOuter, &GCAttributeManager::SetOuter)
        .addProperty("PreventLoopback", &GCAttributeManager::GetPreventLoopback, &GCAttributeManager::SetPreventLoopback)
        .addProperty("ProviderType", &GCAttributeManager::GetProviderType, &GCAttributeManager::SetProviderType)
        .addProperty("CachedResults", &GCAttributeManager::GetCachedResults, &GCAttributeManager::SetCachedResults)
        .addFunction("ToPtr", &GCAttributeManager::ToPtr)
        .addFunction("IsValid", &GCAttributeManager::IsValid)
        .endClass();
}
GFilterHealth::GFilterHealth(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GFilterHealth::GFilterHealth(void *ptr) {
    m_ptr = ptr;
}
bool GFilterHealth::GetAdrenalineActive() const {
    return GetSchemaValue<bool>(m_ptr, "FilterHealth", "m_bAdrenalineActive");
}
void GFilterHealth::SetAdrenalineActive(bool value) {
    SetSchemaValue(m_ptr, "FilterHealth", "m_bAdrenalineActive", false, value);
}
int32_t GFilterHealth::GetHealthMin() const {
    return GetSchemaValue<int32_t>(m_ptr, "FilterHealth", "m_iHealthMin");
}
void GFilterHealth::SetHealthMin(int32_t value) {
    SetSchemaValue(m_ptr, "FilterHealth", "m_iHealthMin", false, value);
}
int32_t GFilterHealth::GetHealthMax() const {
    return GetSchemaValue<int32_t>(m_ptr, "FilterHealth", "m_iHealthMax");
}
void GFilterHealth::SetHealthMax(int32_t value) {
    SetSchemaValue(m_ptr, "FilterHealth", "m_iHealthMax", false, value);
}
std::string GFilterHealth::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GFilterHealth::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseFilter GFilterHealth::GetParent() const {
    GCBaseFilter value(m_ptr);
    return value;
}
void GFilterHealth::SetParent(GCBaseFilter value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassFilterHealth(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GFilterHealth>("FilterHealth")
        .addConstructor<void (*)(std::string)>()
        .addProperty("AdrenalineActive", &GFilterHealth::GetAdrenalineActive, &GFilterHealth::SetAdrenalineActive)
        .addProperty("HealthMin", &GFilterHealth::GetHealthMin, &GFilterHealth::SetHealthMin)
        .addProperty("HealthMax", &GFilterHealth::GetHealthMax, &GFilterHealth::SetHealthMax)
        .addProperty("Parent", &GFilterHealth::GetParent, &GFilterHealth::SetParent)
        .addFunction("ToPtr", &GFilterHealth::ToPtr)
        .addFunction("IsValid", &GFilterHealth::IsValid)
        .endClass();
}
GCPlayerPing::GCPlayerPing(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCPlayerPing::GCPlayerPing(void *ptr) {
    m_ptr = ptr;
}
GCCSPlayerPawn GCPlayerPing::GetPlayer() const {
    GCCSPlayerPawn value(*GetSchemaValuePtr<void*>(m_ptr, "CPlayerPing", "m_hPlayer"));
    return value;
}
void GCPlayerPing::SetPlayer(GCCSPlayerPawn* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Player' is not possible.\n");
}
GCBaseEntity GCPlayerPing::GetPingedEntity() const {
    GCBaseEntity value(*GetSchemaValuePtr<void*>(m_ptr, "CPlayerPing", "m_hPingedEntity"));
    return value;
}
void GCPlayerPing::SetPingedEntity(GCBaseEntity* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'PingedEntity' is not possible.\n");
}
int32_t GCPlayerPing::GetType() const {
    return GetSchemaValue<int32_t>(m_ptr, "CPlayerPing", "m_iType");
}
void GCPlayerPing::SetType(int32_t value) {
    SetSchemaValue(m_ptr, "CPlayerPing", "m_iType", false, value);
}
bool GCPlayerPing::GetUrgent() const {
    return GetSchemaValue<bool>(m_ptr, "CPlayerPing", "m_bUrgent");
}
void GCPlayerPing::SetUrgent(bool value) {
    SetSchemaValue(m_ptr, "CPlayerPing", "m_bUrgent", false, value);
}
std::string GCPlayerPing::GetPlaceName() const {
    return GetSchemaValuePtr<char>(m_ptr, "CPlayerPing", "m_szPlaceName");
}
void GCPlayerPing::SetPlaceName(std::string value) {
    WriteSchemaPtrValue(m_ptr, "CPlayerPing", "m_szPlaceName", false, reinterpret_cast<byte*>(const_cast<char*>(value.c_str())), 18);
}
std::string GCPlayerPing::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCPlayerPing::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseEntity GCPlayerPing::GetParent() const {
    GCBaseEntity value(m_ptr);
    return value;
}
void GCPlayerPing::SetParent(GCBaseEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCPlayerPing(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCPlayerPing>("CPlayerPing")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Player", &GCPlayerPing::GetPlayer, &GCPlayerPing::SetPlayer)
        .addProperty("PingedEntity", &GCPlayerPing::GetPingedEntity, &GCPlayerPing::SetPingedEntity)
        .addProperty("Type", &GCPlayerPing::GetType, &GCPlayerPing::SetType)
        .addProperty("Urgent", &GCPlayerPing::GetUrgent, &GCPlayerPing::SetUrgent)
        .addProperty("PlaceName", &GCPlayerPing::GetPlaceName, &GCPlayerPing::SetPlaceName)
        .addProperty("Parent", &GCPlayerPing::GetParent, &GCPlayerPing::SetParent)
        .addFunction("ToPtr", &GCPlayerPing::ToPtr)
        .addFunction("IsValid", &GCPlayerPing::IsValid)
        .endClass();
}
GCCSPointScriptEntity::GCCSPointScriptEntity(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCCSPointScriptEntity::GCCSPointScriptEntity(void *ptr) {
    m_ptr = ptr;
}
std::string GCCSPointScriptEntity::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCCSPointScriptEntity::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseEntity GCCSPointScriptEntity::GetParent() const {
    GCBaseEntity value(m_ptr);
    return value;
}
void GCCSPointScriptEntity::SetParent(GCBaseEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCCSPointScriptEntity(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCCSPointScriptEntity>("CCSPointScriptEntity")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCCSPointScriptEntity::GetParent, &GCCSPointScriptEntity::SetParent)
        .addFunction("ToPtr", &GCCSPointScriptEntity::ToPtr)
        .addFunction("IsValid", &GCCSPointScriptEntity::IsValid)
        .endClass();
}
GCNetworkOriginCellCoordQuantizedVector::GCNetworkOriginCellCoordQuantizedVector(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCNetworkOriginCellCoordQuantizedVector::GCNetworkOriginCellCoordQuantizedVector(void *ptr) {
    m_ptr = ptr;
}
uint16_t GCNetworkOriginCellCoordQuantizedVector::GetCellX() const {
    return GetSchemaValue<uint16_t>(m_ptr, "CNetworkOriginCellCoordQuantizedVector", "m_cellX");
}
void GCNetworkOriginCellCoordQuantizedVector::SetCellX(uint16_t value) {
    SetSchemaValue(m_ptr, "CNetworkOriginCellCoordQuantizedVector", "m_cellX", false, value);
}
uint16_t GCNetworkOriginCellCoordQuantizedVector::GetCellY() const {
    return GetSchemaValue<uint16_t>(m_ptr, "CNetworkOriginCellCoordQuantizedVector", "m_cellY");
}
void GCNetworkOriginCellCoordQuantizedVector::SetCellY(uint16_t value) {
    SetSchemaValue(m_ptr, "CNetworkOriginCellCoordQuantizedVector", "m_cellY", false, value);
}
uint16_t GCNetworkOriginCellCoordQuantizedVector::GetCellZ() const {
    return GetSchemaValue<uint16_t>(m_ptr, "CNetworkOriginCellCoordQuantizedVector", "m_cellZ");
}
void GCNetworkOriginCellCoordQuantizedVector::SetCellZ(uint16_t value) {
    SetSchemaValue(m_ptr, "CNetworkOriginCellCoordQuantizedVector", "m_cellZ", false, value);
}
uint16_t GCNetworkOriginCellCoordQuantizedVector::GetOutsideWorld() const {
    return GetSchemaValue<uint16_t>(m_ptr, "CNetworkOriginCellCoordQuantizedVector", "m_nOutsideWorld");
}
void GCNetworkOriginCellCoordQuantizedVector::SetOutsideWorld(uint16_t value) {
    SetSchemaValue(m_ptr, "CNetworkOriginCellCoordQuantizedVector", "m_nOutsideWorld", false, value);
}
float GCNetworkOriginCellCoordQuantizedVector::GetX() const {
    return GetSchemaValue<float>(m_ptr, "CNetworkOriginCellCoordQuantizedVector", "m_vecX");
}
void GCNetworkOriginCellCoordQuantizedVector::SetX(float value) {
    SetSchemaValue(m_ptr, "CNetworkOriginCellCoordQuantizedVector", "m_vecX", false, value);
}
float GCNetworkOriginCellCoordQuantizedVector::GetY() const {
    return GetSchemaValue<float>(m_ptr, "CNetworkOriginCellCoordQuantizedVector", "m_vecY");
}
void GCNetworkOriginCellCoordQuantizedVector::SetY(float value) {
    SetSchemaValue(m_ptr, "CNetworkOriginCellCoordQuantizedVector", "m_vecY", false, value);
}
float GCNetworkOriginCellCoordQuantizedVector::GetZ() const {
    return GetSchemaValue<float>(m_ptr, "CNetworkOriginCellCoordQuantizedVector", "m_vecZ");
}
void GCNetworkOriginCellCoordQuantizedVector::SetZ(float value) {
    SetSchemaValue(m_ptr, "CNetworkOriginCellCoordQuantizedVector", "m_vecZ", false, value);
}
std::string GCNetworkOriginCellCoordQuantizedVector::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCNetworkOriginCellCoordQuantizedVector::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCNetworkOriginCellCoordQuantizedVector(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCNetworkOriginCellCoordQuantizedVector>("CNetworkOriginCellCoordQuantizedVector")
        .addConstructor<void (*)(std::string)>()
        .addProperty("CellX", &GCNetworkOriginCellCoordQuantizedVector::GetCellX, &GCNetworkOriginCellCoordQuantizedVector::SetCellX)
        .addProperty("CellY", &GCNetworkOriginCellCoordQuantizedVector::GetCellY, &GCNetworkOriginCellCoordQuantizedVector::SetCellY)
        .addProperty("CellZ", &GCNetworkOriginCellCoordQuantizedVector::GetCellZ, &GCNetworkOriginCellCoordQuantizedVector::SetCellZ)
        .addProperty("OutsideWorld", &GCNetworkOriginCellCoordQuantizedVector::GetOutsideWorld, &GCNetworkOriginCellCoordQuantizedVector::SetOutsideWorld)
        .addProperty("X", &GCNetworkOriginCellCoordQuantizedVector::GetX, &GCNetworkOriginCellCoordQuantizedVector::SetX)
        .addProperty("Y", &GCNetworkOriginCellCoordQuantizedVector::GetY, &GCNetworkOriginCellCoordQuantizedVector::SetY)
        .addProperty("Z", &GCNetworkOriginCellCoordQuantizedVector::GetZ, &GCNetworkOriginCellCoordQuantizedVector::SetZ)
        .addFunction("ToPtr", &GCNetworkOriginCellCoordQuantizedVector::ToPtr)
        .addFunction("IsValid", &GCNetworkOriginCellCoordQuantizedVector::IsValid)
        .endClass();
}
GCInfoLandmark::GCInfoLandmark(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCInfoLandmark::GCInfoLandmark(void *ptr) {
    m_ptr = ptr;
}
std::string GCInfoLandmark::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCInfoLandmark::IsValid() {
    return (m_ptr != nullptr);
}
GCPointEntity GCInfoLandmark::GetParent() const {
    GCPointEntity value(m_ptr);
    return value;
}
void GCInfoLandmark::SetParent(GCPointEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCInfoLandmark(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCInfoLandmark>("CInfoLandmark")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCInfoLandmark::GetParent, &GCInfoLandmark::SetParent)
        .addFunction("ToPtr", &GCInfoLandmark::ToPtr)
        .addFunction("IsValid", &GCInfoLandmark::IsValid)
        .endClass();
}
GCBaseFlex::GCBaseFlex(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCBaseFlex::GCBaseFlex(void *ptr) {
    m_ptr = ptr;
}
std::vector<float32> GCBaseFlex::GetFlexWeight() const {
    CUtlVector<float32>* vec = GetSchemaValue<CUtlVector<float32>*>(m_ptr, "CBaseFlex", "m_flexWeight"); std::vector<float32> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCBaseFlex::SetFlexWeight(std::vector<float32> value) {
    SetSchemaValueCUtlVector<float32>(m_ptr, "CBaseFlex", "m_flexWeight", false, value);
}
Vector GCBaseFlex::GetLookTargetPosition() const {
    return GetSchemaValue<Vector>(m_ptr, "CBaseFlex", "m_vLookTargetPosition");
}
void GCBaseFlex::SetLookTargetPosition(Vector value) {
    SetSchemaValue(m_ptr, "CBaseFlex", "m_vLookTargetPosition", false, value);
}
bool GCBaseFlex::GetBlinktoggle() const {
    return GetSchemaValue<bool>(m_ptr, "CBaseFlex", "m_blinktoggle");
}
void GCBaseFlex::SetBlinktoggle(bool value) {
    SetSchemaValue(m_ptr, "CBaseFlex", "m_blinktoggle", false, value);
}
float GCBaseFlex::GetAllowResponsesEndTime() const {
    return GetSchemaValue<float>(m_ptr, "CBaseFlex", "m_flAllowResponsesEndTime");
}
void GCBaseFlex::SetAllowResponsesEndTime(float value) {
    SetSchemaValue(m_ptr, "CBaseFlex", "m_flAllowResponsesEndTime", false, value);
}
float GCBaseFlex::GetLastFlexAnimationTime() const {
    return GetSchemaValue<float>(m_ptr, "CBaseFlex", "m_flLastFlexAnimationTime");
}
void GCBaseFlex::SetLastFlexAnimationTime(float value) {
    SetSchemaValue(m_ptr, "CBaseFlex", "m_flLastFlexAnimationTime", false, value);
}
GSceneEventId_t GCBaseFlex::GetNextSceneEventId() const {
    GSceneEventId_t value(GetSchemaPtr(m_ptr, "CBaseFlex", "m_nNextSceneEventId"));
    return value;
}
void GCBaseFlex::SetNextSceneEventId(GSceneEventId_t value) {
    SetSchemaValue(m_ptr, "CBaseFlex", "m_nNextSceneEventId", false, value);
}
bool GCBaseFlex::GetUpdateLayerPriorities() const {
    return GetSchemaValue<bool>(m_ptr, "CBaseFlex", "m_bUpdateLayerPriorities");
}
void GCBaseFlex::SetUpdateLayerPriorities(bool value) {
    SetSchemaValue(m_ptr, "CBaseFlex", "m_bUpdateLayerPriorities", false, value);
}
std::string GCBaseFlex::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCBaseFlex::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseAnimGraph GCBaseFlex::GetParent() const {
    GCBaseAnimGraph value(m_ptr);
    return value;
}
void GCBaseFlex::SetParent(GCBaseAnimGraph value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCBaseFlex(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCBaseFlex>("CBaseFlex")
        .addConstructor<void (*)(std::string)>()
        .addProperty("FlexWeight", &GCBaseFlex::GetFlexWeight, &GCBaseFlex::SetFlexWeight)
        .addProperty("LookTargetPosition", &GCBaseFlex::GetLookTargetPosition, &GCBaseFlex::SetLookTargetPosition)
        .addProperty("Blinktoggle", &GCBaseFlex::GetBlinktoggle, &GCBaseFlex::SetBlinktoggle)
        .addProperty("AllowResponsesEndTime", &GCBaseFlex::GetAllowResponsesEndTime, &GCBaseFlex::SetAllowResponsesEndTime)
        .addProperty("LastFlexAnimationTime", &GCBaseFlex::GetLastFlexAnimationTime, &GCBaseFlex::SetLastFlexAnimationTime)
        .addProperty("NextSceneEventId", &GCBaseFlex::GetNextSceneEventId, &GCBaseFlex::SetNextSceneEventId)
        .addProperty("UpdateLayerPriorities", &GCBaseFlex::GetUpdateLayerPriorities, &GCBaseFlex::SetUpdateLayerPriorities)
        .addProperty("Parent", &GCBaseFlex::GetParent, &GCBaseFlex::SetParent)
        .addFunction("ToPtr", &GCBaseFlex::ToPtr)
        .addFunction("IsValid", &GCBaseFlex::IsValid)
        .endClass();
}
GCEconItemView::GCEconItemView(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCEconItemView::GCEconItemView(void *ptr) {
    m_ptr = ptr;
}
uint16_t GCEconItemView::GetItemDefinitionIndex() const {
    return GetSchemaValue<uint16_t>(m_ptr, "CEconItemView", "m_iItemDefinitionIndex");
}
void GCEconItemView::SetItemDefinitionIndex(uint16_t value) {
    SetSchemaValue(m_ptr, "CEconItemView", "m_iItemDefinitionIndex", false, value);
}
int32_t GCEconItemView::GetEntityQuality() const {
    return GetSchemaValue<int32_t>(m_ptr, "CEconItemView", "m_iEntityQuality");
}
void GCEconItemView::SetEntityQuality(int32_t value) {
    SetSchemaValue(m_ptr, "CEconItemView", "m_iEntityQuality", false, value);
}
uint32_t GCEconItemView::GetEntityLevel() const {
    return GetSchemaValue<uint32_t>(m_ptr, "CEconItemView", "m_iEntityLevel");
}
void GCEconItemView::SetEntityLevel(uint32_t value) {
    SetSchemaValue(m_ptr, "CEconItemView", "m_iEntityLevel", false, value);
}
uint64_t GCEconItemView::GetItemID() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CEconItemView", "m_iItemID");
}
void GCEconItemView::SetItemID(uint64_t value) {
    SetSchemaValue(m_ptr, "CEconItemView", "m_iItemID", false, value);
}
uint32_t GCEconItemView::GetItemIDHigh() const {
    return GetSchemaValue<uint32_t>(m_ptr, "CEconItemView", "m_iItemIDHigh");
}
void GCEconItemView::SetItemIDHigh(uint32_t value) {
    SetSchemaValue(m_ptr, "CEconItemView", "m_iItemIDHigh", false, value);
}
uint32_t GCEconItemView::GetItemIDLow() const {
    return GetSchemaValue<uint32_t>(m_ptr, "CEconItemView", "m_iItemIDLow");
}
void GCEconItemView::SetItemIDLow(uint32_t value) {
    SetSchemaValue(m_ptr, "CEconItemView", "m_iItemIDLow", false, value);
}
uint32_t GCEconItemView::GetAccountID() const {
    return GetSchemaValue<uint32_t>(m_ptr, "CEconItemView", "m_iAccountID");
}
void GCEconItemView::SetAccountID(uint32_t value) {
    SetSchemaValue(m_ptr, "CEconItemView", "m_iAccountID", false, value);
}
uint32_t GCEconItemView::GetInventoryPosition() const {
    return GetSchemaValue<uint32_t>(m_ptr, "CEconItemView", "m_iInventoryPosition");
}
void GCEconItemView::SetInventoryPosition(uint32_t value) {
    SetSchemaValue(m_ptr, "CEconItemView", "m_iInventoryPosition", false, value);
}
bool GCEconItemView::GetInitialized() const {
    return GetSchemaValue<bool>(m_ptr, "CEconItemView", "m_bInitialized");
}
void GCEconItemView::SetInitialized(bool value) {
    SetSchemaValue(m_ptr, "CEconItemView", "m_bInitialized", false, value);
}
GCAttributeList GCEconItemView::GetAttributeList() const {
    GCAttributeList value(GetSchemaPtr(m_ptr, "CEconItemView", "m_AttributeList"));
    return value;
}
void GCEconItemView::SetAttributeList(GCAttributeList value) {
    SetSchemaValue(m_ptr, "CEconItemView", "m_AttributeList", false, value);
}
GCAttributeList GCEconItemView::GetNetworkedDynamicAttributes() const {
    GCAttributeList value(GetSchemaPtr(m_ptr, "CEconItemView", "m_NetworkedDynamicAttributes"));
    return value;
}
void GCEconItemView::SetNetworkedDynamicAttributes(GCAttributeList value) {
    SetSchemaValue(m_ptr, "CEconItemView", "m_NetworkedDynamicAttributes", false, value);
}
std::string GCEconItemView::GetCustomName() const {
    return GetSchemaValuePtr<char>(m_ptr, "CEconItemView", "m_szCustomName");
}
void GCEconItemView::SetCustomName(std::string value) {
    WriteSchemaPtrValue(m_ptr, "CEconItemView", "m_szCustomName", false, reinterpret_cast<byte*>(const_cast<char*>(value.c_str())), 161);
}
std::string GCEconItemView::GetCustomNameOverride() const {
    return GetSchemaValuePtr<char>(m_ptr, "CEconItemView", "m_szCustomNameOverride");
}
void GCEconItemView::SetCustomNameOverride(std::string value) {
    WriteSchemaPtrValue(m_ptr, "CEconItemView", "m_szCustomNameOverride", false, reinterpret_cast<byte*>(const_cast<char*>(value.c_str())), 161);
}
std::string GCEconItemView::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCEconItemView::IsValid() {
    return (m_ptr != nullptr);
}
GIEconItemInterface GCEconItemView::GetParent() const {
    GIEconItemInterface value(m_ptr);
    return value;
}
void GCEconItemView::SetParent(GIEconItemInterface value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCEconItemView(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCEconItemView>("CEconItemView")
        .addConstructor<void (*)(std::string)>()
        .addProperty("ItemDefinitionIndex", &GCEconItemView::GetItemDefinitionIndex, &GCEconItemView::SetItemDefinitionIndex)
        .addProperty("EntityQuality", &GCEconItemView::GetEntityQuality, &GCEconItemView::SetEntityQuality)
        .addProperty("EntityLevel", &GCEconItemView::GetEntityLevel, &GCEconItemView::SetEntityLevel)
        .addProperty("ItemID", &GCEconItemView::GetItemID, &GCEconItemView::SetItemID)
        .addProperty("ItemIDHigh", &GCEconItemView::GetItemIDHigh, &GCEconItemView::SetItemIDHigh)
        .addProperty("ItemIDLow", &GCEconItemView::GetItemIDLow, &GCEconItemView::SetItemIDLow)
        .addProperty("AccountID", &GCEconItemView::GetAccountID, &GCEconItemView::SetAccountID)
        .addProperty("InventoryPosition", &GCEconItemView::GetInventoryPosition, &GCEconItemView::SetInventoryPosition)
        .addProperty("Initialized", &GCEconItemView::GetInitialized, &GCEconItemView::SetInitialized)
        .addProperty("AttributeList", &GCEconItemView::GetAttributeList, &GCEconItemView::SetAttributeList)
        .addProperty("NetworkedDynamicAttributes", &GCEconItemView::GetNetworkedDynamicAttributes, &GCEconItemView::SetNetworkedDynamicAttributes)
        .addProperty("CustomName", &GCEconItemView::GetCustomName, &GCEconItemView::SetCustomName)
        .addProperty("CustomNameOverride", &GCEconItemView::GetCustomNameOverride, &GCEconItemView::SetCustomNameOverride)
        .addProperty("Parent", &GCEconItemView::GetParent, &GCEconItemView::SetParent)
        .addFunction("ToPtr", &GCEconItemView::ToPtr)
        .addFunction("IsValid", &GCEconItemView::IsValid)
        .endClass();
}
GCAnimGraphNetworkedVariables::GCAnimGraphNetworkedVariables(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCAnimGraphNetworkedVariables::GCAnimGraphNetworkedVariables(void *ptr) {
    m_ptr = ptr;
}
std::vector<uint32> GCAnimGraphNetworkedVariables::GetPredNetBoolVariables() const {
    CUtlVector<uint32>* vec = GetSchemaValue<CUtlVector<uint32>*>(m_ptr, "CAnimGraphNetworkedVariables", "m_PredNetBoolVariables"); std::vector<uint32> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCAnimGraphNetworkedVariables::SetPredNetBoolVariables(std::vector<uint32> value) {
    SetSchemaValueCUtlVector<uint32>(m_ptr, "CAnimGraphNetworkedVariables", "m_PredNetBoolVariables", false, value);
}
std::vector<uint8> GCAnimGraphNetworkedVariables::GetPredNetByteVariables() const {
    CUtlVector<uint8>* vec = GetSchemaValue<CUtlVector<uint8>*>(m_ptr, "CAnimGraphNetworkedVariables", "m_PredNetByteVariables"); std::vector<uint8> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCAnimGraphNetworkedVariables::SetPredNetByteVariables(std::vector<uint8> value) {
    SetSchemaValueCUtlVector<uint8>(m_ptr, "CAnimGraphNetworkedVariables", "m_PredNetByteVariables", false, value);
}
std::vector<uint16> GCAnimGraphNetworkedVariables::GetPredNetUInt16Variables() const {
    CUtlVector<uint16>* vec = GetSchemaValue<CUtlVector<uint16>*>(m_ptr, "CAnimGraphNetworkedVariables", "m_PredNetUInt16Variables"); std::vector<uint16> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCAnimGraphNetworkedVariables::SetPredNetUInt16Variables(std::vector<uint16> value) {
    SetSchemaValueCUtlVector<uint16>(m_ptr, "CAnimGraphNetworkedVariables", "m_PredNetUInt16Variables", false, value);
}
std::vector<int32> GCAnimGraphNetworkedVariables::GetPredNetIntVariables() const {
    CUtlVector<int32>* vec = GetSchemaValue<CUtlVector<int32>*>(m_ptr, "CAnimGraphNetworkedVariables", "m_PredNetIntVariables"); std::vector<int32> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCAnimGraphNetworkedVariables::SetPredNetIntVariables(std::vector<int32> value) {
    SetSchemaValueCUtlVector<int32>(m_ptr, "CAnimGraphNetworkedVariables", "m_PredNetIntVariables", false, value);
}
std::vector<uint32> GCAnimGraphNetworkedVariables::GetPredNetUInt32Variables() const {
    CUtlVector<uint32>* vec = GetSchemaValue<CUtlVector<uint32>*>(m_ptr, "CAnimGraphNetworkedVariables", "m_PredNetUInt32Variables"); std::vector<uint32> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCAnimGraphNetworkedVariables::SetPredNetUInt32Variables(std::vector<uint32> value) {
    SetSchemaValueCUtlVector<uint32>(m_ptr, "CAnimGraphNetworkedVariables", "m_PredNetUInt32Variables", false, value);
}
std::vector<uint64> GCAnimGraphNetworkedVariables::GetPredNetUInt64Variables() const {
    CUtlVector<uint64>* vec = GetSchemaValue<CUtlVector<uint64>*>(m_ptr, "CAnimGraphNetworkedVariables", "m_PredNetUInt64Variables"); std::vector<uint64> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCAnimGraphNetworkedVariables::SetPredNetUInt64Variables(std::vector<uint64> value) {
    SetSchemaValueCUtlVector<uint64>(m_ptr, "CAnimGraphNetworkedVariables", "m_PredNetUInt64Variables", false, value);
}
std::vector<float32> GCAnimGraphNetworkedVariables::GetPredNetFloatVariables() const {
    CUtlVector<float32>* vec = GetSchemaValue<CUtlVector<float32>*>(m_ptr, "CAnimGraphNetworkedVariables", "m_PredNetFloatVariables"); std::vector<float32> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCAnimGraphNetworkedVariables::SetPredNetFloatVariables(std::vector<float32> value) {
    SetSchemaValueCUtlVector<float32>(m_ptr, "CAnimGraphNetworkedVariables", "m_PredNetFloatVariables", false, value);
}
std::vector<Vector> GCAnimGraphNetworkedVariables::GetPredNetVectorVariables() const {
    CUtlVector<Vector>* vec = GetSchemaValue<CUtlVector<Vector>*>(m_ptr, "CAnimGraphNetworkedVariables", "m_PredNetVectorVariables"); std::vector<Vector> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCAnimGraphNetworkedVariables::SetPredNetVectorVariables(std::vector<Vector> value) {
    SetSchemaValueCUtlVector<Vector>(m_ptr, "CAnimGraphNetworkedVariables", "m_PredNetVectorVariables", false, value);
}
std::vector<Quaternion> GCAnimGraphNetworkedVariables::GetPredNetQuaternionVariables() const {
    CUtlVector<Quaternion>* vec = GetSchemaValue<CUtlVector<Quaternion>*>(m_ptr, "CAnimGraphNetworkedVariables", "m_PredNetQuaternionVariables"); std::vector<Quaternion> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCAnimGraphNetworkedVariables::SetPredNetQuaternionVariables(std::vector<Quaternion> value) {
    SetSchemaValueCUtlVector<Quaternion>(m_ptr, "CAnimGraphNetworkedVariables", "m_PredNetQuaternionVariables", false, value);
}
std::vector<uint32> GCAnimGraphNetworkedVariables::GetOwnerOnlyPredNetBoolVariables() const {
    CUtlVector<uint32>* vec = GetSchemaValue<CUtlVector<uint32>*>(m_ptr, "CAnimGraphNetworkedVariables", "m_OwnerOnlyPredNetBoolVariables"); std::vector<uint32> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCAnimGraphNetworkedVariables::SetOwnerOnlyPredNetBoolVariables(std::vector<uint32> value) {
    SetSchemaValueCUtlVector<uint32>(m_ptr, "CAnimGraphNetworkedVariables", "m_OwnerOnlyPredNetBoolVariables", false, value);
}
std::vector<uint8> GCAnimGraphNetworkedVariables::GetOwnerOnlyPredNetByteVariables() const {
    CUtlVector<uint8>* vec = GetSchemaValue<CUtlVector<uint8>*>(m_ptr, "CAnimGraphNetworkedVariables", "m_OwnerOnlyPredNetByteVariables"); std::vector<uint8> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCAnimGraphNetworkedVariables::SetOwnerOnlyPredNetByteVariables(std::vector<uint8> value) {
    SetSchemaValueCUtlVector<uint8>(m_ptr, "CAnimGraphNetworkedVariables", "m_OwnerOnlyPredNetByteVariables", false, value);
}
std::vector<uint16> GCAnimGraphNetworkedVariables::GetOwnerOnlyPredNetUInt16Variables() const {
    CUtlVector<uint16>* vec = GetSchemaValue<CUtlVector<uint16>*>(m_ptr, "CAnimGraphNetworkedVariables", "m_OwnerOnlyPredNetUInt16Variables"); std::vector<uint16> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCAnimGraphNetworkedVariables::SetOwnerOnlyPredNetUInt16Variables(std::vector<uint16> value) {
    SetSchemaValueCUtlVector<uint16>(m_ptr, "CAnimGraphNetworkedVariables", "m_OwnerOnlyPredNetUInt16Variables", false, value);
}
std::vector<int32> GCAnimGraphNetworkedVariables::GetOwnerOnlyPredNetIntVariables() const {
    CUtlVector<int32>* vec = GetSchemaValue<CUtlVector<int32>*>(m_ptr, "CAnimGraphNetworkedVariables", "m_OwnerOnlyPredNetIntVariables"); std::vector<int32> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCAnimGraphNetworkedVariables::SetOwnerOnlyPredNetIntVariables(std::vector<int32> value) {
    SetSchemaValueCUtlVector<int32>(m_ptr, "CAnimGraphNetworkedVariables", "m_OwnerOnlyPredNetIntVariables", false, value);
}
std::vector<uint32> GCAnimGraphNetworkedVariables::GetOwnerOnlyPredNetUInt32Variables() const {
    CUtlVector<uint32>* vec = GetSchemaValue<CUtlVector<uint32>*>(m_ptr, "CAnimGraphNetworkedVariables", "m_OwnerOnlyPredNetUInt32Variables"); std::vector<uint32> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCAnimGraphNetworkedVariables::SetOwnerOnlyPredNetUInt32Variables(std::vector<uint32> value) {
    SetSchemaValueCUtlVector<uint32>(m_ptr, "CAnimGraphNetworkedVariables", "m_OwnerOnlyPredNetUInt32Variables", false, value);
}
std::vector<uint64> GCAnimGraphNetworkedVariables::GetOwnerOnlyPredNetUInt64Variables() const {
    CUtlVector<uint64>* vec = GetSchemaValue<CUtlVector<uint64>*>(m_ptr, "CAnimGraphNetworkedVariables", "m_OwnerOnlyPredNetUInt64Variables"); std::vector<uint64> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCAnimGraphNetworkedVariables::SetOwnerOnlyPredNetUInt64Variables(std::vector<uint64> value) {
    SetSchemaValueCUtlVector<uint64>(m_ptr, "CAnimGraphNetworkedVariables", "m_OwnerOnlyPredNetUInt64Variables", false, value);
}
std::vector<float32> GCAnimGraphNetworkedVariables::GetOwnerOnlyPredNetFloatVariables() const {
    CUtlVector<float32>* vec = GetSchemaValue<CUtlVector<float32>*>(m_ptr, "CAnimGraphNetworkedVariables", "m_OwnerOnlyPredNetFloatVariables"); std::vector<float32> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCAnimGraphNetworkedVariables::SetOwnerOnlyPredNetFloatVariables(std::vector<float32> value) {
    SetSchemaValueCUtlVector<float32>(m_ptr, "CAnimGraphNetworkedVariables", "m_OwnerOnlyPredNetFloatVariables", false, value);
}
std::vector<Vector> GCAnimGraphNetworkedVariables::GetOwnerOnlyPredNetVectorVariables() const {
    CUtlVector<Vector>* vec = GetSchemaValue<CUtlVector<Vector>*>(m_ptr, "CAnimGraphNetworkedVariables", "m_OwnerOnlyPredNetVectorVariables"); std::vector<Vector> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCAnimGraphNetworkedVariables::SetOwnerOnlyPredNetVectorVariables(std::vector<Vector> value) {
    SetSchemaValueCUtlVector<Vector>(m_ptr, "CAnimGraphNetworkedVariables", "m_OwnerOnlyPredNetVectorVariables", false, value);
}
std::vector<Quaternion> GCAnimGraphNetworkedVariables::GetOwnerOnlyPredNetQuaternionVariables() const {
    CUtlVector<Quaternion>* vec = GetSchemaValue<CUtlVector<Quaternion>*>(m_ptr, "CAnimGraphNetworkedVariables", "m_OwnerOnlyPredNetQuaternionVariables"); std::vector<Quaternion> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCAnimGraphNetworkedVariables::SetOwnerOnlyPredNetQuaternionVariables(std::vector<Quaternion> value) {
    SetSchemaValueCUtlVector<Quaternion>(m_ptr, "CAnimGraphNetworkedVariables", "m_OwnerOnlyPredNetQuaternionVariables", false, value);
}
int32_t GCAnimGraphNetworkedVariables::GetBoolVariablesCount() const {
    return GetSchemaValue<int32_t>(m_ptr, "CAnimGraphNetworkedVariables", "m_nBoolVariablesCount");
}
void GCAnimGraphNetworkedVariables::SetBoolVariablesCount(int32_t value) {
    SetSchemaValue(m_ptr, "CAnimGraphNetworkedVariables", "m_nBoolVariablesCount", false, value);
}
int32_t GCAnimGraphNetworkedVariables::GetOwnerOnlyBoolVariablesCount() const {
    return GetSchemaValue<int32_t>(m_ptr, "CAnimGraphNetworkedVariables", "m_nOwnerOnlyBoolVariablesCount");
}
void GCAnimGraphNetworkedVariables::SetOwnerOnlyBoolVariablesCount(int32_t value) {
    SetSchemaValue(m_ptr, "CAnimGraphNetworkedVariables", "m_nOwnerOnlyBoolVariablesCount", false, value);
}
int32_t GCAnimGraphNetworkedVariables::GetRandomSeedOffset() const {
    return GetSchemaValue<int32_t>(m_ptr, "CAnimGraphNetworkedVariables", "m_nRandomSeedOffset");
}
void GCAnimGraphNetworkedVariables::SetRandomSeedOffset(int32_t value) {
    SetSchemaValue(m_ptr, "CAnimGraphNetworkedVariables", "m_nRandomSeedOffset", false, value);
}
float GCAnimGraphNetworkedVariables::GetLastTeleportTime() const {
    return GetSchemaValue<float>(m_ptr, "CAnimGraphNetworkedVariables", "m_flLastTeleportTime");
}
void GCAnimGraphNetworkedVariables::SetLastTeleportTime(float value) {
    SetSchemaValue(m_ptr, "CAnimGraphNetworkedVariables", "m_flLastTeleportTime", false, value);
}
std::string GCAnimGraphNetworkedVariables::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCAnimGraphNetworkedVariables::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCAnimGraphNetworkedVariables(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCAnimGraphNetworkedVariables>("CAnimGraphNetworkedVariables")
        .addConstructor<void (*)(std::string)>()
        .addProperty("PredNetBoolVariables", &GCAnimGraphNetworkedVariables::GetPredNetBoolVariables, &GCAnimGraphNetworkedVariables::SetPredNetBoolVariables)
        .addProperty("PredNetByteVariables", &GCAnimGraphNetworkedVariables::GetPredNetByteVariables, &GCAnimGraphNetworkedVariables::SetPredNetByteVariables)
        .addProperty("PredNetUInt16Variables", &GCAnimGraphNetworkedVariables::GetPredNetUInt16Variables, &GCAnimGraphNetworkedVariables::SetPredNetUInt16Variables)
        .addProperty("PredNetIntVariables", &GCAnimGraphNetworkedVariables::GetPredNetIntVariables, &GCAnimGraphNetworkedVariables::SetPredNetIntVariables)
        .addProperty("PredNetUInt32Variables", &GCAnimGraphNetworkedVariables::GetPredNetUInt32Variables, &GCAnimGraphNetworkedVariables::SetPredNetUInt32Variables)
        .addProperty("PredNetUInt64Variables", &GCAnimGraphNetworkedVariables::GetPredNetUInt64Variables, &GCAnimGraphNetworkedVariables::SetPredNetUInt64Variables)
        .addProperty("PredNetFloatVariables", &GCAnimGraphNetworkedVariables::GetPredNetFloatVariables, &GCAnimGraphNetworkedVariables::SetPredNetFloatVariables)
        .addProperty("PredNetVectorVariables", &GCAnimGraphNetworkedVariables::GetPredNetVectorVariables, &GCAnimGraphNetworkedVariables::SetPredNetVectorVariables)
        .addProperty("PredNetQuaternionVariables", &GCAnimGraphNetworkedVariables::GetPredNetQuaternionVariables, &GCAnimGraphNetworkedVariables::SetPredNetQuaternionVariables)
        .addProperty("OwnerOnlyPredNetBoolVariables", &GCAnimGraphNetworkedVariables::GetOwnerOnlyPredNetBoolVariables, &GCAnimGraphNetworkedVariables::SetOwnerOnlyPredNetBoolVariables)
        .addProperty("OwnerOnlyPredNetByteVariables", &GCAnimGraphNetworkedVariables::GetOwnerOnlyPredNetByteVariables, &GCAnimGraphNetworkedVariables::SetOwnerOnlyPredNetByteVariables)
        .addProperty("OwnerOnlyPredNetUInt16Variables", &GCAnimGraphNetworkedVariables::GetOwnerOnlyPredNetUInt16Variables, &GCAnimGraphNetworkedVariables::SetOwnerOnlyPredNetUInt16Variables)
        .addProperty("OwnerOnlyPredNetIntVariables", &GCAnimGraphNetworkedVariables::GetOwnerOnlyPredNetIntVariables, &GCAnimGraphNetworkedVariables::SetOwnerOnlyPredNetIntVariables)
        .addProperty("OwnerOnlyPredNetUInt32Variables", &GCAnimGraphNetworkedVariables::GetOwnerOnlyPredNetUInt32Variables, &GCAnimGraphNetworkedVariables::SetOwnerOnlyPredNetUInt32Variables)
        .addProperty("OwnerOnlyPredNetUInt64Variables", &GCAnimGraphNetworkedVariables::GetOwnerOnlyPredNetUInt64Variables, &GCAnimGraphNetworkedVariables::SetOwnerOnlyPredNetUInt64Variables)
        .addProperty("OwnerOnlyPredNetFloatVariables", &GCAnimGraphNetworkedVariables::GetOwnerOnlyPredNetFloatVariables, &GCAnimGraphNetworkedVariables::SetOwnerOnlyPredNetFloatVariables)
        .addProperty("OwnerOnlyPredNetVectorVariables", &GCAnimGraphNetworkedVariables::GetOwnerOnlyPredNetVectorVariables, &GCAnimGraphNetworkedVariables::SetOwnerOnlyPredNetVectorVariables)
        .addProperty("OwnerOnlyPredNetQuaternionVariables", &GCAnimGraphNetworkedVariables::GetOwnerOnlyPredNetQuaternionVariables, &GCAnimGraphNetworkedVariables::SetOwnerOnlyPredNetQuaternionVariables)
        .addProperty("BoolVariablesCount", &GCAnimGraphNetworkedVariables::GetBoolVariablesCount, &GCAnimGraphNetworkedVariables::SetBoolVariablesCount)
        .addProperty("OwnerOnlyBoolVariablesCount", &GCAnimGraphNetworkedVariables::GetOwnerOnlyBoolVariablesCount, &GCAnimGraphNetworkedVariables::SetOwnerOnlyBoolVariablesCount)
        .addProperty("RandomSeedOffset", &GCAnimGraphNetworkedVariables::GetRandomSeedOffset, &GCAnimGraphNetworkedVariables::SetRandomSeedOffset)
        .addProperty("LastTeleportTime", &GCAnimGraphNetworkedVariables::GetLastTeleportTime, &GCAnimGraphNetworkedVariables::SetLastTeleportTime)
        .addFunction("ToPtr", &GCAnimGraphNetworkedVariables::ToPtr)
        .addFunction("IsValid", &GCAnimGraphNetworkedVariables::IsValid)
        .endClass();
}
GCBodyComponent::GCBodyComponent(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCBodyComponent::GCBodyComponent(void *ptr) {
    m_ptr = ptr;
}
GCGameSceneNode GCBodyComponent::GetSceneNode() const {
    GCGameSceneNode value(*GetSchemaValuePtr<void*>(m_ptr, "CBodyComponent", "m_pSceneNode"));
    return value;
}
void GCBodyComponent::SetSceneNode(GCGameSceneNode* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'SceneNode' is not possible.\n");
}
GCNetworkVarChainer GCBodyComponent::Get__pChainEntity() const {
    GCNetworkVarChainer value(GetSchemaPtr(m_ptr, "CBodyComponent", "__m_pChainEntity"));
    return value;
}
void GCBodyComponent::Set__pChainEntity(GCNetworkVarChainer value) {
    SetSchemaValue(m_ptr, "CBodyComponent", "__m_pChainEntity", false, value);
}
std::string GCBodyComponent::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCBodyComponent::IsValid() {
    return (m_ptr != nullptr);
}
GCEntityComponent GCBodyComponent::GetParent() const {
    GCEntityComponent value(m_ptr);
    return value;
}
void GCBodyComponent::SetParent(GCEntityComponent value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCBodyComponent(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCBodyComponent>("CBodyComponent")
        .addConstructor<void (*)(std::string)>()
        .addProperty("SceneNode", &GCBodyComponent::GetSceneNode, &GCBodyComponent::SetSceneNode)
        .addProperty("__pChainEntity", &GCBodyComponent::Get__pChainEntity, &GCBodyComponent::Set__pChainEntity)
        .addProperty("Parent", &GCBodyComponent::GetParent, &GCBodyComponent::SetParent)
        .addFunction("ToPtr", &GCBodyComponent::ToPtr)
        .addFunction("IsValid", &GCBodyComponent::IsValid)
        .endClass();
}
GCEnvFireSensor::GCEnvFireSensor(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCEnvFireSensor::GCEnvFireSensor(void *ptr) {
    m_ptr = ptr;
}
bool GCEnvFireSensor::GetEnabled() const {
    return GetSchemaValue<bool>(m_ptr, "CEnvFireSensor", "m_bEnabled");
}
void GCEnvFireSensor::SetEnabled(bool value) {
    SetSchemaValue(m_ptr, "CEnvFireSensor", "m_bEnabled", false, value);
}
bool GCEnvFireSensor::GetHeatAtLevel() const {
    return GetSchemaValue<bool>(m_ptr, "CEnvFireSensor", "m_bHeatAtLevel");
}
void GCEnvFireSensor::SetHeatAtLevel(bool value) {
    SetSchemaValue(m_ptr, "CEnvFireSensor", "m_bHeatAtLevel", false, value);
}
float GCEnvFireSensor::GetRadius() const {
    return GetSchemaValue<float>(m_ptr, "CEnvFireSensor", "m_radius");
}
void GCEnvFireSensor::SetRadius(float value) {
    SetSchemaValue(m_ptr, "CEnvFireSensor", "m_radius", false, value);
}
float GCEnvFireSensor::GetTargetLevel() const {
    return GetSchemaValue<float>(m_ptr, "CEnvFireSensor", "m_targetLevel");
}
void GCEnvFireSensor::SetTargetLevel(float value) {
    SetSchemaValue(m_ptr, "CEnvFireSensor", "m_targetLevel", false, value);
}
float GCEnvFireSensor::GetTargetTime() const {
    return GetSchemaValue<float>(m_ptr, "CEnvFireSensor", "m_targetTime");
}
void GCEnvFireSensor::SetTargetTime(float value) {
    SetSchemaValue(m_ptr, "CEnvFireSensor", "m_targetTime", false, value);
}
float GCEnvFireSensor::GetLevelTime() const {
    return GetSchemaValue<float>(m_ptr, "CEnvFireSensor", "m_levelTime");
}
void GCEnvFireSensor::SetLevelTime(float value) {
    SetSchemaValue(m_ptr, "CEnvFireSensor", "m_levelTime", false, value);
}
GCEntityIOOutput GCEnvFireSensor::GetOnHeatLevelStart() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CEnvFireSensor", "m_OnHeatLevelStart"));
    return value;
}
void GCEnvFireSensor::SetOnHeatLevelStart(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CEnvFireSensor", "m_OnHeatLevelStart", false, value);
}
GCEntityIOOutput GCEnvFireSensor::GetOnHeatLevelEnd() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CEnvFireSensor", "m_OnHeatLevelEnd"));
    return value;
}
void GCEnvFireSensor::SetOnHeatLevelEnd(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CEnvFireSensor", "m_OnHeatLevelEnd", false, value);
}
std::string GCEnvFireSensor::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCEnvFireSensor::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseEntity GCEnvFireSensor::GetParent() const {
    GCBaseEntity value(m_ptr);
    return value;
}
void GCEnvFireSensor::SetParent(GCBaseEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCEnvFireSensor(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCEnvFireSensor>("CEnvFireSensor")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Enabled", &GCEnvFireSensor::GetEnabled, &GCEnvFireSensor::SetEnabled)
        .addProperty("HeatAtLevel", &GCEnvFireSensor::GetHeatAtLevel, &GCEnvFireSensor::SetHeatAtLevel)
        .addProperty("Radius", &GCEnvFireSensor::GetRadius, &GCEnvFireSensor::SetRadius)
        .addProperty("TargetLevel", &GCEnvFireSensor::GetTargetLevel, &GCEnvFireSensor::SetTargetLevel)
        .addProperty("TargetTime", &GCEnvFireSensor::GetTargetTime, &GCEnvFireSensor::SetTargetTime)
        .addProperty("LevelTime", &GCEnvFireSensor::GetLevelTime, &GCEnvFireSensor::SetLevelTime)
        .addProperty("OnHeatLevelStart", &GCEnvFireSensor::GetOnHeatLevelStart, &GCEnvFireSensor::SetOnHeatLevelStart)
        .addProperty("OnHeatLevelEnd", &GCEnvFireSensor::GetOnHeatLevelEnd, &GCEnvFireSensor::SetOnHeatLevelEnd)
        .addProperty("Parent", &GCEnvFireSensor::GetParent, &GCEnvFireSensor::SetParent)
        .addFunction("ToPtr", &GCEnvFireSensor::ToPtr)
        .addFunction("IsValid", &GCEnvFireSensor::IsValid)
        .endClass();
}
GCCSGO_TeamPreviewCharacterPosition::GCCSGO_TeamPreviewCharacterPosition(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCCSGO_TeamPreviewCharacterPosition::GCCSGO_TeamPreviewCharacterPosition(void *ptr) {
    m_ptr = ptr;
}
int32_t GCCSGO_TeamPreviewCharacterPosition::GetVariant() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSGO_TeamPreviewCharacterPosition", "m_nVariant");
}
void GCCSGO_TeamPreviewCharacterPosition::SetVariant(int32_t value) {
    SetSchemaValue(m_ptr, "CCSGO_TeamPreviewCharacterPosition", "m_nVariant", false, value);
}
int32_t GCCSGO_TeamPreviewCharacterPosition::GetRandom() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSGO_TeamPreviewCharacterPosition", "m_nRandom");
}
void GCCSGO_TeamPreviewCharacterPosition::SetRandom(int32_t value) {
    SetSchemaValue(m_ptr, "CCSGO_TeamPreviewCharacterPosition", "m_nRandom", false, value);
}
int32_t GCCSGO_TeamPreviewCharacterPosition::GetOrdinal() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSGO_TeamPreviewCharacterPosition", "m_nOrdinal");
}
void GCCSGO_TeamPreviewCharacterPosition::SetOrdinal(int32_t value) {
    SetSchemaValue(m_ptr, "CCSGO_TeamPreviewCharacterPosition", "m_nOrdinal", false, value);
}
std::string GCCSGO_TeamPreviewCharacterPosition::GetWeaponName() const {
    return GetSchemaValue<CUtlString>(m_ptr, "CCSGO_TeamPreviewCharacterPosition", "m_sWeaponName").Get();
}
void GCCSGO_TeamPreviewCharacterPosition::SetWeaponName(std::string value) {
    SetSchemaValue(m_ptr, "CCSGO_TeamPreviewCharacterPosition", "m_sWeaponName", false, CUtlString(value.c_str()));
}
uint64_t GCCSGO_TeamPreviewCharacterPosition::GetXuid() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CCSGO_TeamPreviewCharacterPosition", "m_xuid");
}
void GCCSGO_TeamPreviewCharacterPosition::SetXuid(uint64_t value) {
    SetSchemaValue(m_ptr, "CCSGO_TeamPreviewCharacterPosition", "m_xuid", false, value);
}
GCEconItemView GCCSGO_TeamPreviewCharacterPosition::GetAgentItem() const {
    GCEconItemView value(GetSchemaPtr(m_ptr, "CCSGO_TeamPreviewCharacterPosition", "m_agentItem"));
    return value;
}
void GCCSGO_TeamPreviewCharacterPosition::SetAgentItem(GCEconItemView value) {
    SetSchemaValue(m_ptr, "CCSGO_TeamPreviewCharacterPosition", "m_agentItem", false, value);
}
GCEconItemView GCCSGO_TeamPreviewCharacterPosition::GetGlovesItem() const {
    GCEconItemView value(GetSchemaPtr(m_ptr, "CCSGO_TeamPreviewCharacterPosition", "m_glovesItem"));
    return value;
}
void GCCSGO_TeamPreviewCharacterPosition::SetGlovesItem(GCEconItemView value) {
    SetSchemaValue(m_ptr, "CCSGO_TeamPreviewCharacterPosition", "m_glovesItem", false, value);
}
GCEconItemView GCCSGO_TeamPreviewCharacterPosition::GetWeaponItem() const {
    GCEconItemView value(GetSchemaPtr(m_ptr, "CCSGO_TeamPreviewCharacterPosition", "m_weaponItem"));
    return value;
}
void GCCSGO_TeamPreviewCharacterPosition::SetWeaponItem(GCEconItemView value) {
    SetSchemaValue(m_ptr, "CCSGO_TeamPreviewCharacterPosition", "m_weaponItem", false, value);
}
std::string GCCSGO_TeamPreviewCharacterPosition::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCCSGO_TeamPreviewCharacterPosition::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseEntity GCCSGO_TeamPreviewCharacterPosition::GetParent() const {
    GCBaseEntity value(m_ptr);
    return value;
}
void GCCSGO_TeamPreviewCharacterPosition::SetParent(GCBaseEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCCSGO_TeamPreviewCharacterPosition(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCCSGO_TeamPreviewCharacterPosition>("CCSGO_TeamPreviewCharacterPosition")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Variant", &GCCSGO_TeamPreviewCharacterPosition::GetVariant, &GCCSGO_TeamPreviewCharacterPosition::SetVariant)
        .addProperty("Random", &GCCSGO_TeamPreviewCharacterPosition::GetRandom, &GCCSGO_TeamPreviewCharacterPosition::SetRandom)
        .addProperty("Ordinal", &GCCSGO_TeamPreviewCharacterPosition::GetOrdinal, &GCCSGO_TeamPreviewCharacterPosition::SetOrdinal)
        .addProperty("WeaponName", &GCCSGO_TeamPreviewCharacterPosition::GetWeaponName, &GCCSGO_TeamPreviewCharacterPosition::SetWeaponName)
        .addProperty("Xuid", &GCCSGO_TeamPreviewCharacterPosition::GetXuid, &GCCSGO_TeamPreviewCharacterPosition::SetXuid)
        .addProperty("AgentItem", &GCCSGO_TeamPreviewCharacterPosition::GetAgentItem, &GCCSGO_TeamPreviewCharacterPosition::SetAgentItem)
        .addProperty("GlovesItem", &GCCSGO_TeamPreviewCharacterPosition::GetGlovesItem, &GCCSGO_TeamPreviewCharacterPosition::SetGlovesItem)
        .addProperty("WeaponItem", &GCCSGO_TeamPreviewCharacterPosition::GetWeaponItem, &GCCSGO_TeamPreviewCharacterPosition::SetWeaponItem)
        .addProperty("Parent", &GCCSGO_TeamPreviewCharacterPosition::GetParent, &GCCSGO_TeamPreviewCharacterPosition::SetParent)
        .addFunction("ToPtr", &GCCSGO_TeamPreviewCharacterPosition::ToPtr)
        .addFunction("IsValid", &GCCSGO_TeamPreviewCharacterPosition::IsValid)
        .endClass();
}
GCEnvWindShared__WindAveEvent_t::GCEnvWindShared__WindAveEvent_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCEnvWindShared__WindAveEvent_t::GCEnvWindShared__WindAveEvent_t(void *ptr) {
    m_ptr = ptr;
}
float GCEnvWindShared__WindAveEvent_t::GetStartWindSpeed() const {
    return GetSchemaValue<float>(m_ptr, "CEnvWindShared__WindAveEvent_t", "m_flStartWindSpeed");
}
void GCEnvWindShared__WindAveEvent_t::SetStartWindSpeed(float value) {
    SetSchemaValue(m_ptr, "CEnvWindShared__WindAveEvent_t", "m_flStartWindSpeed", true, value);
}
float GCEnvWindShared__WindAveEvent_t::GetAveWindSpeed() const {
    return GetSchemaValue<float>(m_ptr, "CEnvWindShared__WindAveEvent_t", "m_flAveWindSpeed");
}
void GCEnvWindShared__WindAveEvent_t::SetAveWindSpeed(float value) {
    SetSchemaValue(m_ptr, "CEnvWindShared__WindAveEvent_t", "m_flAveWindSpeed", true, value);
}
std::string GCEnvWindShared__WindAveEvent_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCEnvWindShared__WindAveEvent_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCEnvWindShared__WindAveEvent_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCEnvWindShared__WindAveEvent_t>("CEnvWindShared__WindAveEvent_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("StartWindSpeed", &GCEnvWindShared__WindAveEvent_t::GetStartWindSpeed, &GCEnvWindShared__WindAveEvent_t::SetStartWindSpeed)
        .addProperty("AveWindSpeed", &GCEnvWindShared__WindAveEvent_t::GetAveWindSpeed, &GCEnvWindShared__WindAveEvent_t::SetAveWindSpeed)
        .addFunction("ToPtr", &GCEnvWindShared__WindAveEvent_t::ToPtr)
        .addFunction("IsValid", &GCEnvWindShared__WindAveEvent_t::IsValid)
        .endClass();
}
GCBaseProp::GCBaseProp(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCBaseProp::GCBaseProp(void *ptr) {
    m_ptr = ptr;
}
bool GCBaseProp::GetModelOverrodeBlockLOS() const {
    return GetSchemaValue<bool>(m_ptr, "CBaseProp", "m_bModelOverrodeBlockLOS");
}
void GCBaseProp::SetModelOverrodeBlockLOS(bool value) {
    SetSchemaValue(m_ptr, "CBaseProp", "m_bModelOverrodeBlockLOS", false, value);
}
int32_t GCBaseProp::GetShapeType() const {
    return GetSchemaValue<int32_t>(m_ptr, "CBaseProp", "m_iShapeType");
}
void GCBaseProp::SetShapeType(int32_t value) {
    SetSchemaValue(m_ptr, "CBaseProp", "m_iShapeType", false, value);
}
bool GCBaseProp::GetConformToCollisionBounds() const {
    return GetSchemaValue<bool>(m_ptr, "CBaseProp", "m_bConformToCollisionBounds");
}
void GCBaseProp::SetConformToCollisionBounds(bool value) {
    SetSchemaValue(m_ptr, "CBaseProp", "m_bConformToCollisionBounds", false, value);
}
matrix3x4_t GCBaseProp::GetMPreferredCatchTransform() const {
    return GetSchemaValue<matrix3x4_t>(m_ptr, "CBaseProp", "m_mPreferredCatchTransform");
}
void GCBaseProp::SetMPreferredCatchTransform(matrix3x4_t value) {
    SetSchemaValue(m_ptr, "CBaseProp", "m_mPreferredCatchTransform", false, value);
}
std::string GCBaseProp::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCBaseProp::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseAnimGraph GCBaseProp::GetParent() const {
    GCBaseAnimGraph value(m_ptr);
    return value;
}
void GCBaseProp::SetParent(GCBaseAnimGraph value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCBaseProp(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCBaseProp>("CBaseProp")
        .addConstructor<void (*)(std::string)>()
        .addProperty("ModelOverrodeBlockLOS", &GCBaseProp::GetModelOverrodeBlockLOS, &GCBaseProp::SetModelOverrodeBlockLOS)
        .addProperty("ShapeType", &GCBaseProp::GetShapeType, &GCBaseProp::SetShapeType)
        .addProperty("ConformToCollisionBounds", &GCBaseProp::GetConformToCollisionBounds, &GCBaseProp::SetConformToCollisionBounds)
        .addProperty("MPreferredCatchTransform", &GCBaseProp::GetMPreferredCatchTransform, &GCBaseProp::SetMPreferredCatchTransform)
        .addProperty("Parent", &GCBaseProp::GetParent, &GCBaseProp::SetParent)
        .addFunction("ToPtr", &GCBaseProp::ToPtr)
        .addFunction("IsValid", &GCBaseProp::IsValid)
        .endClass();
}
GCPointGamestatsCounter::GCPointGamestatsCounter(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCPointGamestatsCounter::GCPointGamestatsCounter(void *ptr) {
    m_ptr = ptr;
}
std::string GCPointGamestatsCounter::GetStrStatisticName() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CPointGamestatsCounter", "m_strStatisticName").String();
}
void GCPointGamestatsCounter::SetStrStatisticName(std::string value) {
    SetSchemaValue(m_ptr, "CPointGamestatsCounter", "m_strStatisticName", false, CUtlSymbolLarge(value.c_str()));
}
bool GCPointGamestatsCounter::GetDisabled() const {
    return GetSchemaValue<bool>(m_ptr, "CPointGamestatsCounter", "m_bDisabled");
}
void GCPointGamestatsCounter::SetDisabled(bool value) {
    SetSchemaValue(m_ptr, "CPointGamestatsCounter", "m_bDisabled", false, value);
}
std::string GCPointGamestatsCounter::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCPointGamestatsCounter::IsValid() {
    return (m_ptr != nullptr);
}
GCPointEntity GCPointGamestatsCounter::GetParent() const {
    GCPointEntity value(m_ptr);
    return value;
}
void GCPointGamestatsCounter::SetParent(GCPointEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCPointGamestatsCounter(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCPointGamestatsCounter>("CPointGamestatsCounter")
        .addConstructor<void (*)(std::string)>()
        .addProperty("StrStatisticName", &GCPointGamestatsCounter::GetStrStatisticName, &GCPointGamestatsCounter::SetStrStatisticName)
        .addProperty("Disabled", &GCPointGamestatsCounter::GetDisabled, &GCPointGamestatsCounter::SetDisabled)
        .addProperty("Parent", &GCPointGamestatsCounter::GetParent, &GCPointGamestatsCounter::SetParent)
        .addFunction("ToPtr", &GCPointGamestatsCounter::ToPtr)
        .addFunction("IsValid", &GCPointGamestatsCounter::IsValid)
        .endClass();
}
GCPhysicsShake::GCPhysicsShake(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCPhysicsShake::GCPhysicsShake(void *ptr) {
    m_ptr = ptr;
}
Vector GCPhysicsShake::GetForce() const {
    return GetSchemaValue<Vector>(m_ptr, "CPhysicsShake", "m_force");
}
void GCPhysicsShake::SetForce(Vector value) {
    SetSchemaValue(m_ptr, "CPhysicsShake", "m_force", false, value);
}
std::string GCPhysicsShake::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCPhysicsShake::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCPhysicsShake(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCPhysicsShake>("CPhysicsShake")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Force", &GCPhysicsShake::GetForce, &GCPhysicsShake::SetForce)
        .addFunction("ToPtr", &GCPhysicsShake::ToPtr)
        .addFunction("IsValid", &GCPhysicsShake::IsValid)
        .endClass();
}
GCBreakable::GCBreakable(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCBreakable::GCBreakable(void *ptr) {
    m_ptr = ptr;
}
GCPropDataComponent GCBreakable::GetCPropDataComponent() const {
    GCPropDataComponent value(GetSchemaPtr(m_ptr, "CBreakable", "m_CPropDataComponent"));
    return value;
}
void GCBreakable::SetCPropDataComponent(GCPropDataComponent value) {
    SetSchemaValue(m_ptr, "CBreakable", "m_CPropDataComponent", false, value);
}
uint64_t GCBreakable::GetMaterial() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CBreakable", "m_Material");
}
void GCBreakable::SetMaterial(uint64_t value) {
    SetSchemaValue(m_ptr, "CBreakable", "m_Material", false, value);
}
GCBaseEntity GCBreakable::GetBreaker() const {
    GCBaseEntity value(*GetSchemaValuePtr<void*>(m_ptr, "CBreakable", "m_hBreaker"));
    return value;
}
void GCBreakable::SetBreaker(GCBaseEntity* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Breaker' is not possible.\n");
}
uint64_t GCBreakable::GetExplosion() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CBreakable", "m_Explosion");
}
void GCBreakable::SetExplosion(uint64_t value) {
    SetSchemaValue(m_ptr, "CBreakable", "m_Explosion", false, value);
}
std::string GCBreakable::GetSpawnObject() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CBreakable", "m_iszSpawnObject").String();
}
void GCBreakable::SetSpawnObject(std::string value) {
    SetSchemaValue(m_ptr, "CBreakable", "m_iszSpawnObject", false, CUtlSymbolLarge(value.c_str()));
}
float GCBreakable::GetPressureDelay() const {
    return GetSchemaValue<float>(m_ptr, "CBreakable", "m_flPressureDelay");
}
void GCBreakable::SetPressureDelay(float value) {
    SetSchemaValue(m_ptr, "CBreakable", "m_flPressureDelay", false, value);
}
int32_t GCBreakable::GetMinHealthDmg() const {
    return GetSchemaValue<int32_t>(m_ptr, "CBreakable", "m_iMinHealthDmg");
}
void GCBreakable::SetMinHealthDmg(int32_t value) {
    SetSchemaValue(m_ptr, "CBreakable", "m_iMinHealthDmg", false, value);
}
std::string GCBreakable::GetPropData() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CBreakable", "m_iszPropData").String();
}
void GCBreakable::SetPropData(std::string value) {
    SetSchemaValue(m_ptr, "CBreakable", "m_iszPropData", false, CUtlSymbolLarge(value.c_str()));
}
float GCBreakable::GetImpactEnergyScale() const {
    return GetSchemaValue<float>(m_ptr, "CBreakable", "m_impactEnergyScale");
}
void GCBreakable::SetImpactEnergyScale(float value) {
    SetSchemaValue(m_ptr, "CBreakable", "m_impactEnergyScale", false, value);
}
uint64_t GCBreakable::GetOverrideBlockLOS() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CBreakable", "m_nOverrideBlockLOS");
}
void GCBreakable::SetOverrideBlockLOS(uint64_t value) {
    SetSchemaValue(m_ptr, "CBreakable", "m_nOverrideBlockLOS", false, value);
}
GCEntityIOOutput GCBreakable::GetOnBreak() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CBreakable", "m_OnBreak"));
    return value;
}
void GCBreakable::SetOnBreak(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CBreakable", "m_OnBreak", false, value);
}
uint64_t GCBreakable::GetPerformanceMode() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CBreakable", "m_PerformanceMode");
}
void GCBreakable::SetPerformanceMode(uint64_t value) {
    SetSchemaValue(m_ptr, "CBreakable", "m_PerformanceMode", false, value);
}
GCBasePlayerPawn GCBreakable::GetPhysicsAttacker() const {
    GCBasePlayerPawn value(*GetSchemaValuePtr<void*>(m_ptr, "CBreakable", "m_hPhysicsAttacker"));
    return value;
}
void GCBreakable::SetPhysicsAttacker(GCBasePlayerPawn* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'PhysicsAttacker' is not possible.\n");
}
float GCBreakable::GetLastPhysicsInfluenceTime() const {
    return GetSchemaValue<float>(m_ptr, "CBreakable", "m_flLastPhysicsInfluenceTime");
}
void GCBreakable::SetLastPhysicsInfluenceTime(float value) {
    SetSchemaValue(m_ptr, "CBreakable", "m_flLastPhysicsInfluenceTime", false, value);
}
std::string GCBreakable::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCBreakable::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseModelEntity GCBreakable::GetParent() const {
    GCBaseModelEntity value(m_ptr);
    return value;
}
void GCBreakable::SetParent(GCBaseModelEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCBreakable(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCBreakable>("CBreakable")
        .addConstructor<void (*)(std::string)>()
        .addProperty("CPropDataComponent", &GCBreakable::GetCPropDataComponent, &GCBreakable::SetCPropDataComponent)
        .addProperty("Material", &GCBreakable::GetMaterial, &GCBreakable::SetMaterial)
        .addProperty("Breaker", &GCBreakable::GetBreaker, &GCBreakable::SetBreaker)
        .addProperty("Explosion", &GCBreakable::GetExplosion, &GCBreakable::SetExplosion)
        .addProperty("SpawnObject", &GCBreakable::GetSpawnObject, &GCBreakable::SetSpawnObject)
        .addProperty("PressureDelay", &GCBreakable::GetPressureDelay, &GCBreakable::SetPressureDelay)
        .addProperty("MinHealthDmg", &GCBreakable::GetMinHealthDmg, &GCBreakable::SetMinHealthDmg)
        .addProperty("PropData", &GCBreakable::GetPropData, &GCBreakable::SetPropData)
        .addProperty("ImpactEnergyScale", &GCBreakable::GetImpactEnergyScale, &GCBreakable::SetImpactEnergyScale)
        .addProperty("OverrideBlockLOS", &GCBreakable::GetOverrideBlockLOS, &GCBreakable::SetOverrideBlockLOS)
        .addProperty("OnBreak", &GCBreakable::GetOnBreak, &GCBreakable::SetOnBreak)
        .addProperty("PerformanceMode", &GCBreakable::GetPerformanceMode, &GCBreakable::SetPerformanceMode)
        .addProperty("PhysicsAttacker", &GCBreakable::GetPhysicsAttacker, &GCBreakable::SetPhysicsAttacker)
        .addProperty("LastPhysicsInfluenceTime", &GCBreakable::GetLastPhysicsInfluenceTime, &GCBreakable::SetLastPhysicsInfluenceTime)
        .addProperty("Parent", &GCBreakable::GetParent, &GCBreakable::SetParent)
        .addFunction("ToPtr", &GCBreakable::ToPtr)
        .addFunction("IsValid", &GCBreakable::IsValid)
        .endClass();
}
GCPathKeyFrame::GCPathKeyFrame(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCPathKeyFrame::GCPathKeyFrame(void *ptr) {
    m_ptr = ptr;
}
Vector GCPathKeyFrame::GetOrigin() const {
    return GetSchemaValue<Vector>(m_ptr, "CPathKeyFrame", "m_Origin");
}
void GCPathKeyFrame::SetOrigin(Vector value) {
    SetSchemaValue(m_ptr, "CPathKeyFrame", "m_Origin", false, value);
}
QAngle GCPathKeyFrame::GetAngles() const {
    return GetSchemaValue<QAngle>(m_ptr, "CPathKeyFrame", "m_Angles");
}
void GCPathKeyFrame::SetAngles(QAngle value) {
    SetSchemaValue(m_ptr, "CPathKeyFrame", "m_Angles", false, value);
}
Quaternion GCPathKeyFrame::GetAngle() const {
    return GetSchemaValue<Quaternion>(m_ptr, "CPathKeyFrame", "m_qAngle");
}
void GCPathKeyFrame::SetAngle(Quaternion value) {
    SetSchemaValue(m_ptr, "CPathKeyFrame", "m_qAngle", false, value);
}
std::string GCPathKeyFrame::GetNextKey() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CPathKeyFrame", "m_iNextKey").String();
}
void GCPathKeyFrame::SetNextKey(std::string value) {
    SetSchemaValue(m_ptr, "CPathKeyFrame", "m_iNextKey", false, CUtlSymbolLarge(value.c_str()));
}
float GCPathKeyFrame::GetNextTime() const {
    return GetSchemaValue<float>(m_ptr, "CPathKeyFrame", "m_flNextTime");
}
void GCPathKeyFrame::SetNextTime(float value) {
    SetSchemaValue(m_ptr, "CPathKeyFrame", "m_flNextTime", false, value);
}
GCPathKeyFrame GCPathKeyFrame::GetNextKey1() const {
    GCPathKeyFrame value(*GetSchemaValuePtr<void*>(m_ptr, "CPathKeyFrame", "m_pNextKey"));
    return value;
}
void GCPathKeyFrame::SetNextKey1(GCPathKeyFrame* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'NextKey1' is not possible.\n");
}
GCPathKeyFrame GCPathKeyFrame::GetPrevKey() const {
    GCPathKeyFrame value(*GetSchemaValuePtr<void*>(m_ptr, "CPathKeyFrame", "m_pPrevKey"));
    return value;
}
void GCPathKeyFrame::SetPrevKey(GCPathKeyFrame* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'PrevKey' is not possible.\n");
}
float GCPathKeyFrame::GetMoveSpeed() const {
    return GetSchemaValue<float>(m_ptr, "CPathKeyFrame", "m_flMoveSpeed");
}
void GCPathKeyFrame::SetMoveSpeed(float value) {
    SetSchemaValue(m_ptr, "CPathKeyFrame", "m_flMoveSpeed", false, value);
}
std::string GCPathKeyFrame::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCPathKeyFrame::IsValid() {
    return (m_ptr != nullptr);
}
GCLogicalEntity GCPathKeyFrame::GetParent() const {
    GCLogicalEntity value(m_ptr);
    return value;
}
void GCPathKeyFrame::SetParent(GCLogicalEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCPathKeyFrame(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCPathKeyFrame>("CPathKeyFrame")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Origin", &GCPathKeyFrame::GetOrigin, &GCPathKeyFrame::SetOrigin)
        .addProperty("Angles", &GCPathKeyFrame::GetAngles, &GCPathKeyFrame::SetAngles)
        .addProperty("Angle", &GCPathKeyFrame::GetAngle, &GCPathKeyFrame::SetAngle)
        .addProperty("NextKey", &GCPathKeyFrame::GetNextKey, &GCPathKeyFrame::SetNextKey)
        .addProperty("NextTime", &GCPathKeyFrame::GetNextTime, &GCPathKeyFrame::SetNextTime)
        .addProperty("NextKey1", &GCPathKeyFrame::GetNextKey1, &GCPathKeyFrame::SetNextKey1)
        .addProperty("PrevKey", &GCPathKeyFrame::GetPrevKey, &GCPathKeyFrame::SetPrevKey)
        .addProperty("MoveSpeed", &GCPathKeyFrame::GetMoveSpeed, &GCPathKeyFrame::SetMoveSpeed)
        .addProperty("Parent", &GCPathKeyFrame::GetParent, &GCPathKeyFrame::SetParent)
        .addFunction("ToPtr", &GCPathKeyFrame::ToPtr)
        .addFunction("IsValid", &GCPathKeyFrame::IsValid)
        .endClass();
}
GCTriggerTripWire::GCTriggerTripWire(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCTriggerTripWire::GCTriggerTripWire(void *ptr) {
    m_ptr = ptr;
}
std::string GCTriggerTripWire::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCTriggerTripWire::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseTrigger GCTriggerTripWire::GetParent() const {
    GCBaseTrigger value(m_ptr);
    return value;
}
void GCTriggerTripWire::SetParent(GCBaseTrigger value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCTriggerTripWire(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCTriggerTripWire>("CTriggerTripWire")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCTriggerTripWire::GetParent, &GCTriggerTripWire::SetParent)
        .addFunction("ToPtr", &GCTriggerTripWire::ToPtr)
        .addFunction("IsValid", &GCTriggerTripWire::IsValid)
        .endClass();
}
GCEnvTilt::GCEnvTilt(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCEnvTilt::GCEnvTilt(void *ptr) {
    m_ptr = ptr;
}
float GCEnvTilt::GetDuration() const {
    return GetSchemaValue<float>(m_ptr, "CEnvTilt", "m_Duration");
}
void GCEnvTilt::SetDuration(float value) {
    SetSchemaValue(m_ptr, "CEnvTilt", "m_Duration", false, value);
}
float GCEnvTilt::GetRadius() const {
    return GetSchemaValue<float>(m_ptr, "CEnvTilt", "m_Radius");
}
void GCEnvTilt::SetRadius(float value) {
    SetSchemaValue(m_ptr, "CEnvTilt", "m_Radius", false, value);
}
float GCEnvTilt::GetTiltTime() const {
    return GetSchemaValue<float>(m_ptr, "CEnvTilt", "m_TiltTime");
}
void GCEnvTilt::SetTiltTime(float value) {
    SetSchemaValue(m_ptr, "CEnvTilt", "m_TiltTime", false, value);
}
float GCEnvTilt::GetStopTime() const {
    return GetSchemaValue<float>(m_ptr, "CEnvTilt", "m_stopTime");
}
void GCEnvTilt::SetStopTime(float value) {
    SetSchemaValue(m_ptr, "CEnvTilt", "m_stopTime", false, value);
}
std::string GCEnvTilt::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCEnvTilt::IsValid() {
    return (m_ptr != nullptr);
}
GCPointEntity GCEnvTilt::GetParent() const {
    GCPointEntity value(m_ptr);
    return value;
}
void GCEnvTilt::SetParent(GCPointEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCEnvTilt(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCEnvTilt>("CEnvTilt")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Duration", &GCEnvTilt::GetDuration, &GCEnvTilt::SetDuration)
        .addProperty("Radius", &GCEnvTilt::GetRadius, &GCEnvTilt::SetRadius)
        .addProperty("TiltTime", &GCEnvTilt::GetTiltTime, &GCEnvTilt::SetTiltTime)
        .addProperty("StopTime", &GCEnvTilt::GetStopTime, &GCEnvTilt::SetStopTime)
        .addProperty("Parent", &GCEnvTilt::GetParent, &GCEnvTilt::SetParent)
        .addFunction("ToPtr", &GCEnvTilt::ToPtr)
        .addFunction("IsValid", &GCEnvTilt::IsValid)
        .endClass();
}
GCAttributeContainer::GCAttributeContainer(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCAttributeContainer::GCAttributeContainer(void *ptr) {
    m_ptr = ptr;
}
GCEconItemView GCAttributeContainer::GetItem() const {
    GCEconItemView value(GetSchemaPtr(m_ptr, "CAttributeContainer", "m_Item"));
    return value;
}
void GCAttributeContainer::SetItem(GCEconItemView value) {
    SetSchemaValue(m_ptr, "CAttributeContainer", "m_Item", false, value);
}
std::string GCAttributeContainer::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCAttributeContainer::IsValid() {
    return (m_ptr != nullptr);
}
GCAttributeManager GCAttributeContainer::GetParent() const {
    GCAttributeManager value(m_ptr);
    return value;
}
void GCAttributeContainer::SetParent(GCAttributeManager value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCAttributeContainer(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCAttributeContainer>("CAttributeContainer")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Item", &GCAttributeContainer::GetItem, &GCAttributeContainer::SetItem)
        .addProperty("Parent", &GCAttributeContainer::GetParent, &GCAttributeContainer::SetParent)
        .addFunction("ToPtr", &GCAttributeContainer::ToPtr)
        .addFunction("IsValid", &GCAttributeContainer::IsValid)
        .endClass();
}
GCItemGenericTriggerHelper::GCItemGenericTriggerHelper(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCItemGenericTriggerHelper::GCItemGenericTriggerHelper(void *ptr) {
    m_ptr = ptr;
}
std::string GCItemGenericTriggerHelper::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCItemGenericTriggerHelper::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseModelEntity GCItemGenericTriggerHelper::GetParent() const {
    GCBaseModelEntity value(m_ptr);
    return value;
}
void GCItemGenericTriggerHelper::SetParent(GCBaseModelEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCItemGenericTriggerHelper(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCItemGenericTriggerHelper>("CItemGenericTriggerHelper")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCItemGenericTriggerHelper::GetParent, &GCItemGenericTriggerHelper::SetParent)
        .addFunction("ToPtr", &GCItemGenericTriggerHelper::ToPtr)
        .addFunction("IsValid", &GCItemGenericTriggerHelper::IsValid)
        .endClass();
}
GCLogicBranchList::GCLogicBranchList(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCLogicBranchList::GCLogicBranchList(void *ptr) {
    m_ptr = ptr;
}
std::vector<CUtlSymbolLarge> GCLogicBranchList::GetLogicBranchNames() const {
    CUtlSymbolLarge* outValue = GetSchemaValue<CUtlSymbolLarge*>(m_ptr, "CLogicBranchList", "m_nLogicBranchNames"); std::vector<CUtlSymbolLarge> ret; for(int i = 0; i < 16; i++) { ret.push_back(outValue[i]); } return ret;
}
void GCLogicBranchList::SetLogicBranchNames(std::vector<CUtlSymbolLarge> value) {
    CUtlSymbolLarge* outValue = GetSchemaValue<CUtlSymbolLarge*>(m_ptr, "CLogicBranchList", "m_nLogicBranchNames"); for(int i = 0; i < 16; i++) { outValue[i] = value[i]; } SetSchemaValue(m_ptr, "CLogicBranchList", "m_nLogicBranchNames", false, outValue);
}
GCLogicBranchList GCLogicBranchList::GetLastState() const {
    GCLogicBranchList value(GetSchemaPtr(m_ptr, "CLogicBranchList", "m_eLastState"));
    return value;
}
void GCLogicBranchList::SetLastState(GCLogicBranchList value) {
    SetSchemaValue(m_ptr, "CLogicBranchList", "m_eLastState", false, value);
}
GCEntityIOOutput GCLogicBranchList::GetOnAllTrue() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CLogicBranchList", "m_OnAllTrue"));
    return value;
}
void GCLogicBranchList::SetOnAllTrue(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CLogicBranchList", "m_OnAllTrue", false, value);
}
GCEntityIOOutput GCLogicBranchList::GetOnAllFalse() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CLogicBranchList", "m_OnAllFalse"));
    return value;
}
void GCLogicBranchList::SetOnAllFalse(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CLogicBranchList", "m_OnAllFalse", false, value);
}
GCEntityIOOutput GCLogicBranchList::GetOnMixed() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CLogicBranchList", "m_OnMixed"));
    return value;
}
void GCLogicBranchList::SetOnMixed(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CLogicBranchList", "m_OnMixed", false, value);
}
std::string GCLogicBranchList::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCLogicBranchList::IsValid() {
    return (m_ptr != nullptr);
}
GCLogicalEntity GCLogicBranchList::GetParent() const {
    GCLogicalEntity value(m_ptr);
    return value;
}
void GCLogicBranchList::SetParent(GCLogicalEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCLogicBranchList(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCLogicBranchList>("CLogicBranchList")
        .addConstructor<void (*)(std::string)>()
        .addProperty("LogicBranchNames", &GCLogicBranchList::GetLogicBranchNames, &GCLogicBranchList::SetLogicBranchNames)
        .addProperty("LastState", &GCLogicBranchList::GetLastState, &GCLogicBranchList::SetLastState)
        .addProperty("OnAllTrue", &GCLogicBranchList::GetOnAllTrue, &GCLogicBranchList::SetOnAllTrue)
        .addProperty("OnAllFalse", &GCLogicBranchList::GetOnAllFalse, &GCLogicBranchList::SetOnAllFalse)
        .addProperty("OnMixed", &GCLogicBranchList::GetOnMixed, &GCLogicBranchList::SetOnMixed)
        .addProperty("Parent", &GCLogicBranchList::GetParent, &GCLogicBranchList::SetParent)
        .addFunction("ToPtr", &GCLogicBranchList::ToPtr)
        .addFunction("IsValid", &GCLogicBranchList::IsValid)
        .endClass();
}
Gaudioparams_t::Gaudioparams_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
Gaudioparams_t::Gaudioparams_t(void *ptr) {
    m_ptr = ptr;
}
std::vector<Vector> Gaudioparams_t::GetLocalSound() const {
    Vector* outValue = GetSchemaValue<Vector*>(m_ptr, "audioparams_t", "localSound"); std::vector<Vector> ret; for(int i = 0; i < 8; i++) { ret.push_back(outValue[i]); } return ret;
}
void Gaudioparams_t::SetLocalSound(std::vector<Vector> value) {
    Vector* outValue = GetSchemaValue<Vector*>(m_ptr, "audioparams_t", "localSound"); for(int i = 0; i < 8; i++) { outValue[i] = value[i]; } SetSchemaValue(m_ptr, "audioparams_t", "localSound", true, outValue);
}
int32_t Gaudioparams_t::GetSoundscapeIndex() const {
    return GetSchemaValue<int32_t>(m_ptr, "audioparams_t", "soundscapeIndex");
}
void Gaudioparams_t::SetSoundscapeIndex(int32_t value) {
    SetSchemaValue(m_ptr, "audioparams_t", "soundscapeIndex", true, value);
}
uint8_t Gaudioparams_t::GetLocalBits() const {
    return GetSchemaValue<uint8_t>(m_ptr, "audioparams_t", "localBits");
}
void Gaudioparams_t::SetLocalBits(uint8_t value) {
    SetSchemaValue(m_ptr, "audioparams_t", "localBits", true, value);
}
int32_t Gaudioparams_t::GetSoundscapeEntityListIndex() const {
    return GetSchemaValue<int32_t>(m_ptr, "audioparams_t", "soundscapeEntityListIndex");
}
void Gaudioparams_t::SetSoundscapeEntityListIndex(int32_t value) {
    SetSchemaValue(m_ptr, "audioparams_t", "soundscapeEntityListIndex", true, value);
}
uint32_t Gaudioparams_t::GetSoundEventHash() const {
    return GetSchemaValue<uint32_t>(m_ptr, "audioparams_t", "soundEventHash");
}
void Gaudioparams_t::SetSoundEventHash(uint32_t value) {
    SetSchemaValue(m_ptr, "audioparams_t", "soundEventHash", true, value);
}
std::string Gaudioparams_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool Gaudioparams_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassaudioparams_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<Gaudioparams_t>("audioparams_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("LocalSound", &Gaudioparams_t::GetLocalSound, &Gaudioparams_t::SetLocalSound)
        .addProperty("SoundscapeIndex", &Gaudioparams_t::GetSoundscapeIndex, &Gaudioparams_t::SetSoundscapeIndex)
        .addProperty("LocalBits", &Gaudioparams_t::GetLocalBits, &Gaudioparams_t::SetLocalBits)
        .addProperty("SoundscapeEntityListIndex", &Gaudioparams_t::GetSoundscapeEntityListIndex, &Gaudioparams_t::SetSoundscapeEntityListIndex)
        .addProperty("SoundEventHash", &Gaudioparams_t::GetSoundEventHash, &Gaudioparams_t::SetSoundEventHash)
        .addFunction("ToPtr", &Gaudioparams_t::ToPtr)
        .addFunction("IsValid", &Gaudioparams_t::IsValid)
        .endClass();
}
GCEconEntity::GCEconEntity(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCEconEntity::GCEconEntity(void *ptr) {
    m_ptr = ptr;
}
GCAttributeContainer GCEconEntity::GetAttributeManager() const {
    GCAttributeContainer value(GetSchemaPtr(m_ptr, "CEconEntity", "m_AttributeManager"));
    return value;
}
void GCEconEntity::SetAttributeManager(GCAttributeContainer value) {
    SetSchemaValue(m_ptr, "CEconEntity", "m_AttributeManager", false, value);
}
uint32_t GCEconEntity::GetOriginalOwnerXuidLow() const {
    return GetSchemaValue<uint32_t>(m_ptr, "CEconEntity", "m_OriginalOwnerXuidLow");
}
void GCEconEntity::SetOriginalOwnerXuidLow(uint32_t value) {
    SetSchemaValue(m_ptr, "CEconEntity", "m_OriginalOwnerXuidLow", false, value);
}
uint32_t GCEconEntity::GetOriginalOwnerXuidHigh() const {
    return GetSchemaValue<uint32_t>(m_ptr, "CEconEntity", "m_OriginalOwnerXuidHigh");
}
void GCEconEntity::SetOriginalOwnerXuidHigh(uint32_t value) {
    SetSchemaValue(m_ptr, "CEconEntity", "m_OriginalOwnerXuidHigh", false, value);
}
int32_t GCEconEntity::GetFallbackPaintKit() const {
    return GetSchemaValue<int32_t>(m_ptr, "CEconEntity", "m_nFallbackPaintKit");
}
void GCEconEntity::SetFallbackPaintKit(int32_t value) {
    SetSchemaValue(m_ptr, "CEconEntity", "m_nFallbackPaintKit", false, value);
}
int32_t GCEconEntity::GetFallbackSeed() const {
    return GetSchemaValue<int32_t>(m_ptr, "CEconEntity", "m_nFallbackSeed");
}
void GCEconEntity::SetFallbackSeed(int32_t value) {
    SetSchemaValue(m_ptr, "CEconEntity", "m_nFallbackSeed", false, value);
}
float GCEconEntity::GetFallbackWear() const {
    return GetSchemaValue<float>(m_ptr, "CEconEntity", "m_flFallbackWear");
}
void GCEconEntity::SetFallbackWear(float value) {
    SetSchemaValue(m_ptr, "CEconEntity", "m_flFallbackWear", false, value);
}
int32_t GCEconEntity::GetFallbackStatTrak() const {
    return GetSchemaValue<int32_t>(m_ptr, "CEconEntity", "m_nFallbackStatTrak");
}
void GCEconEntity::SetFallbackStatTrak(int32_t value) {
    SetSchemaValue(m_ptr, "CEconEntity", "m_nFallbackStatTrak", false, value);
}
GCBaseEntity GCEconEntity::GetOldProvidee() const {
    GCBaseEntity value(*GetSchemaValuePtr<void*>(m_ptr, "CEconEntity", "m_hOldProvidee"));
    return value;
}
void GCEconEntity::SetOldProvidee(GCBaseEntity* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'OldProvidee' is not possible.\n");
}
int32_t GCEconEntity::GetOldOwnerClass() const {
    return GetSchemaValue<int32_t>(m_ptr, "CEconEntity", "m_iOldOwnerClass");
}
void GCEconEntity::SetOldOwnerClass(int32_t value) {
    SetSchemaValue(m_ptr, "CEconEntity", "m_iOldOwnerClass", false, value);
}
std::string GCEconEntity::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCEconEntity::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseFlex GCEconEntity::GetParent() const {
    GCBaseFlex value(m_ptr);
    return value;
}
void GCEconEntity::SetParent(GCBaseFlex value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCEconEntity(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCEconEntity>("CEconEntity")
        .addConstructor<void (*)(std::string)>()
        .addProperty("AttributeManager", &GCEconEntity::GetAttributeManager, &GCEconEntity::SetAttributeManager)
        .addProperty("OriginalOwnerXuidLow", &GCEconEntity::GetOriginalOwnerXuidLow, &GCEconEntity::SetOriginalOwnerXuidLow)
        .addProperty("OriginalOwnerXuidHigh", &GCEconEntity::GetOriginalOwnerXuidHigh, &GCEconEntity::SetOriginalOwnerXuidHigh)
        .addProperty("FallbackPaintKit", &GCEconEntity::GetFallbackPaintKit, &GCEconEntity::SetFallbackPaintKit)
        .addProperty("FallbackSeed", &GCEconEntity::GetFallbackSeed, &GCEconEntity::SetFallbackSeed)
        .addProperty("FallbackWear", &GCEconEntity::GetFallbackWear, &GCEconEntity::SetFallbackWear)
        .addProperty("FallbackStatTrak", &GCEconEntity::GetFallbackStatTrak, &GCEconEntity::SetFallbackStatTrak)
        .addProperty("OldProvidee", &GCEconEntity::GetOldProvidee, &GCEconEntity::SetOldProvidee)
        .addProperty("OldOwnerClass", &GCEconEntity::GetOldOwnerClass, &GCEconEntity::SetOldOwnerClass)
        .addProperty("Parent", &GCEconEntity::GetParent, &GCEconEntity::SetParent)
        .addFunction("ToPtr", &GCEconEntity::ToPtr)
        .addFunction("IsValid", &GCEconEntity::IsValid)
        .endClass();
}
GCModelPointEntity::GCModelPointEntity(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCModelPointEntity::GCModelPointEntity(void *ptr) {
    m_ptr = ptr;
}
std::string GCModelPointEntity::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCModelPointEntity::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseModelEntity GCModelPointEntity::GetParent() const {
    GCBaseModelEntity value(m_ptr);
    return value;
}
void GCModelPointEntity::SetParent(GCBaseModelEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCModelPointEntity(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCModelPointEntity>("CModelPointEntity")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCModelPointEntity::GetParent, &GCModelPointEntity::SetParent)
        .addFunction("ToPtr", &GCModelPointEntity::ToPtr)
        .addFunction("IsValid", &GCModelPointEntity::IsValid)
        .endClass();
}
GCMultiLightProxy::GCMultiLightProxy(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCMultiLightProxy::GCMultiLightProxy(void *ptr) {
    m_ptr = ptr;
}
std::string GCMultiLightProxy::GetLightNameFilter() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CMultiLightProxy", "m_iszLightNameFilter").String();
}
void GCMultiLightProxy::SetLightNameFilter(std::string value) {
    SetSchemaValue(m_ptr, "CMultiLightProxy", "m_iszLightNameFilter", false, CUtlSymbolLarge(value.c_str()));
}
std::string GCMultiLightProxy::GetLightClassFilter() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CMultiLightProxy", "m_iszLightClassFilter").String();
}
void GCMultiLightProxy::SetLightClassFilter(std::string value) {
    SetSchemaValue(m_ptr, "CMultiLightProxy", "m_iszLightClassFilter", false, CUtlSymbolLarge(value.c_str()));
}
float GCMultiLightProxy::GetLightRadiusFilter() const {
    return GetSchemaValue<float>(m_ptr, "CMultiLightProxy", "m_flLightRadiusFilter");
}
void GCMultiLightProxy::SetLightRadiusFilter(float value) {
    SetSchemaValue(m_ptr, "CMultiLightProxy", "m_flLightRadiusFilter", false, value);
}
float GCMultiLightProxy::GetBrightnessDelta() const {
    return GetSchemaValue<float>(m_ptr, "CMultiLightProxy", "m_flBrightnessDelta");
}
void GCMultiLightProxy::SetBrightnessDelta(float value) {
    SetSchemaValue(m_ptr, "CMultiLightProxy", "m_flBrightnessDelta", false, value);
}
bool GCMultiLightProxy::GetPerformScreenFade() const {
    return GetSchemaValue<bool>(m_ptr, "CMultiLightProxy", "m_bPerformScreenFade");
}
void GCMultiLightProxy::SetPerformScreenFade(bool value) {
    SetSchemaValue(m_ptr, "CMultiLightProxy", "m_bPerformScreenFade", false, value);
}
float GCMultiLightProxy::GetTargetBrightnessMultiplier() const {
    return GetSchemaValue<float>(m_ptr, "CMultiLightProxy", "m_flTargetBrightnessMultiplier");
}
void GCMultiLightProxy::SetTargetBrightnessMultiplier(float value) {
    SetSchemaValue(m_ptr, "CMultiLightProxy", "m_flTargetBrightnessMultiplier", false, value);
}
float GCMultiLightProxy::GetCurrentBrightnessMultiplier() const {
    return GetSchemaValue<float>(m_ptr, "CMultiLightProxy", "m_flCurrentBrightnessMultiplier");
}
void GCMultiLightProxy::SetCurrentBrightnessMultiplier(float value) {
    SetSchemaValue(m_ptr, "CMultiLightProxy", "m_flCurrentBrightnessMultiplier", false, value);
}
std::string GCMultiLightProxy::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCMultiLightProxy::IsValid() {
    return (m_ptr != nullptr);
}
GCLogicalEntity GCMultiLightProxy::GetParent() const {
    GCLogicalEntity value(m_ptr);
    return value;
}
void GCMultiLightProxy::SetParent(GCLogicalEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCMultiLightProxy(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCMultiLightProxy>("CMultiLightProxy")
        .addConstructor<void (*)(std::string)>()
        .addProperty("LightNameFilter", &GCMultiLightProxy::GetLightNameFilter, &GCMultiLightProxy::SetLightNameFilter)
        .addProperty("LightClassFilter", &GCMultiLightProxy::GetLightClassFilter, &GCMultiLightProxy::SetLightClassFilter)
        .addProperty("LightRadiusFilter", &GCMultiLightProxy::GetLightRadiusFilter, &GCMultiLightProxy::SetLightRadiusFilter)
        .addProperty("BrightnessDelta", &GCMultiLightProxy::GetBrightnessDelta, &GCMultiLightProxy::SetBrightnessDelta)
        .addProperty("PerformScreenFade", &GCMultiLightProxy::GetPerformScreenFade, &GCMultiLightProxy::SetPerformScreenFade)
        .addProperty("TargetBrightnessMultiplier", &GCMultiLightProxy::GetTargetBrightnessMultiplier, &GCMultiLightProxy::SetTargetBrightnessMultiplier)
        .addProperty("CurrentBrightnessMultiplier", &GCMultiLightProxy::GetCurrentBrightnessMultiplier, &GCMultiLightProxy::SetCurrentBrightnessMultiplier)
        .addProperty("Parent", &GCMultiLightProxy::GetParent, &GCMultiLightProxy::SetParent)
        .addFunction("ToPtr", &GCMultiLightProxy::ToPtr)
        .addFunction("IsValid", &GCMultiLightProxy::IsValid)
        .endClass();
}
GCEffectData::GCEffectData(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCEffectData::GCEffectData(void *ptr) {
    m_ptr = ptr;
}
Vector GCEffectData::GetOrigin() const {
    return GetSchemaValue<Vector>(m_ptr, "CEffectData", "m_vOrigin");
}
void GCEffectData::SetOrigin(Vector value) {
    SetSchemaValue(m_ptr, "CEffectData", "m_vOrigin", false, value);
}
Vector GCEffectData::GetStart() const {
    return GetSchemaValue<Vector>(m_ptr, "CEffectData", "m_vStart");
}
void GCEffectData::SetStart(Vector value) {
    SetSchemaValue(m_ptr, "CEffectData", "m_vStart", false, value);
}
Vector GCEffectData::GetNormal() const {
    return GetSchemaValue<Vector>(m_ptr, "CEffectData", "m_vNormal");
}
void GCEffectData::SetNormal(Vector value) {
    SetSchemaValue(m_ptr, "CEffectData", "m_vNormal", false, value);
}
QAngle GCEffectData::GetAngles() const {
    return GetSchemaValue<QAngle>(m_ptr, "CEffectData", "m_vAngles");
}
void GCEffectData::SetAngles(QAngle value) {
    SetSchemaValue(m_ptr, "CEffectData", "m_vAngles", false, value);
}
GCEntityInstance GCEffectData::GetEntity() const {
    GCEntityInstance value(*GetSchemaValuePtr<void*>(m_ptr, "CEffectData", "m_hEntity"));
    return value;
}
void GCEffectData::SetEntity(GCEntityInstance* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Entity' is not possible.\n");
}
GCEntityInstance GCEffectData::GetOtherEntity() const {
    GCEntityInstance value(*GetSchemaValuePtr<void*>(m_ptr, "CEffectData", "m_hOtherEntity"));
    return value;
}
void GCEffectData::SetOtherEntity(GCEntityInstance* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'OtherEntity' is not possible.\n");
}
float GCEffectData::GetScale() const {
    return GetSchemaValue<float>(m_ptr, "CEffectData", "m_flScale");
}
void GCEffectData::SetScale(float value) {
    SetSchemaValue(m_ptr, "CEffectData", "m_flScale", false, value);
}
float GCEffectData::GetMagnitude() const {
    return GetSchemaValue<float>(m_ptr, "CEffectData", "m_flMagnitude");
}
void GCEffectData::SetMagnitude(float value) {
    SetSchemaValue(m_ptr, "CEffectData", "m_flMagnitude", false, value);
}
float GCEffectData::GetRadius() const {
    return GetSchemaValue<float>(m_ptr, "CEffectData", "m_flRadius");
}
void GCEffectData::SetRadius(float value) {
    SetSchemaValue(m_ptr, "CEffectData", "m_flRadius", false, value);
}
CUtlStringToken GCEffectData::GetSurfaceProp() const {
    return GetSchemaValue<CUtlStringToken>(m_ptr, "CEffectData", "m_nSurfaceProp");
}
void GCEffectData::SetSurfaceProp(CUtlStringToken value) {
    SetSchemaValue(m_ptr, "CEffectData", "m_nSurfaceProp", false, value);
}
uint32_t GCEffectData::GetDamageType() const {
    return GetSchemaValue<uint32_t>(m_ptr, "CEffectData", "m_nDamageType");
}
void GCEffectData::SetDamageType(uint32_t value) {
    SetSchemaValue(m_ptr, "CEffectData", "m_nDamageType", false, value);
}
uint8_t GCEffectData::GetPenetrate() const {
    return GetSchemaValue<uint8_t>(m_ptr, "CEffectData", "m_nPenetrate");
}
void GCEffectData::SetPenetrate(uint8_t value) {
    SetSchemaValue(m_ptr, "CEffectData", "m_nPenetrate", false, value);
}
uint16_t GCEffectData::GetMaterial() const {
    return GetSchemaValue<uint16_t>(m_ptr, "CEffectData", "m_nMaterial");
}
void GCEffectData::SetMaterial(uint16_t value) {
    SetSchemaValue(m_ptr, "CEffectData", "m_nMaterial", false, value);
}
uint16_t GCEffectData::GetHitBox() const {
    return GetSchemaValue<uint16_t>(m_ptr, "CEffectData", "m_nHitBox");
}
void GCEffectData::SetHitBox(uint16_t value) {
    SetSchemaValue(m_ptr, "CEffectData", "m_nHitBox", false, value);
}
uint8_t GCEffectData::GetColor() const {
    return GetSchemaValue<uint8_t>(m_ptr, "CEffectData", "m_nColor");
}
void GCEffectData::SetColor(uint8_t value) {
    SetSchemaValue(m_ptr, "CEffectData", "m_nColor", false, value);
}
uint8_t GCEffectData::GetFlags() const {
    return GetSchemaValue<uint8_t>(m_ptr, "CEffectData", "m_fFlags");
}
void GCEffectData::SetFlags(uint8_t value) {
    SetSchemaValue(m_ptr, "CEffectData", "m_fFlags", false, value);
}
CUtlStringToken GCEffectData::GetAttachmentName() const {
    return GetSchemaValue<CUtlStringToken>(m_ptr, "CEffectData", "m_nAttachmentName");
}
void GCEffectData::SetAttachmentName(CUtlStringToken value) {
    SetSchemaValue(m_ptr, "CEffectData", "m_nAttachmentName", false, value);
}
uint16_t GCEffectData::GetEffectName() const {
    return GetSchemaValue<uint16_t>(m_ptr, "CEffectData", "m_iEffectName");
}
void GCEffectData::SetEffectName(uint16_t value) {
    SetSchemaValue(m_ptr, "CEffectData", "m_iEffectName", false, value);
}
uint8_t GCEffectData::GetExplosionType() const {
    return GetSchemaValue<uint8_t>(m_ptr, "CEffectData", "m_nExplosionType");
}
void GCEffectData::SetExplosionType(uint8_t value) {
    SetSchemaValue(m_ptr, "CEffectData", "m_nExplosionType", false, value);
}
std::string GCEffectData::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCEffectData::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCEffectData(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCEffectData>("CEffectData")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Origin", &GCEffectData::GetOrigin, &GCEffectData::SetOrigin)
        .addProperty("Start", &GCEffectData::GetStart, &GCEffectData::SetStart)
        .addProperty("Normal", &GCEffectData::GetNormal, &GCEffectData::SetNormal)
        .addProperty("Angles", &GCEffectData::GetAngles, &GCEffectData::SetAngles)
        .addProperty("Entity", &GCEffectData::GetEntity, &GCEffectData::SetEntity)
        .addProperty("OtherEntity", &GCEffectData::GetOtherEntity, &GCEffectData::SetOtherEntity)
        .addProperty("Scale", &GCEffectData::GetScale, &GCEffectData::SetScale)
        .addProperty("Magnitude", &GCEffectData::GetMagnitude, &GCEffectData::SetMagnitude)
        .addProperty("Radius", &GCEffectData::GetRadius, &GCEffectData::SetRadius)
        .addProperty("SurfaceProp", &GCEffectData::GetSurfaceProp, &GCEffectData::SetSurfaceProp)
        .addProperty("DamageType", &GCEffectData::GetDamageType, &GCEffectData::SetDamageType)
        .addProperty("Penetrate", &GCEffectData::GetPenetrate, &GCEffectData::SetPenetrate)
        .addProperty("Material", &GCEffectData::GetMaterial, &GCEffectData::SetMaterial)
        .addProperty("HitBox", &GCEffectData::GetHitBox, &GCEffectData::SetHitBox)
        .addProperty("Color", &GCEffectData::GetColor, &GCEffectData::SetColor)
        .addProperty("Flags", &GCEffectData::GetFlags, &GCEffectData::SetFlags)
        .addProperty("AttachmentName", &GCEffectData::GetAttachmentName, &GCEffectData::SetAttachmentName)
        .addProperty("EffectName", &GCEffectData::GetEffectName, &GCEffectData::SetEffectName)
        .addProperty("ExplosionType", &GCEffectData::GetExplosionType, &GCEffectData::SetExplosionType)
        .addFunction("ToPtr", &GCEffectData::ToPtr)
        .addFunction("IsValid", &GCEffectData::IsValid)
        .endClass();
}
GCEntityBlocker::GCEntityBlocker(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCEntityBlocker::GCEntityBlocker(void *ptr) {
    m_ptr = ptr;
}
std::string GCEntityBlocker::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCEntityBlocker::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseModelEntity GCEntityBlocker::GetParent() const {
    GCBaseModelEntity value(m_ptr);
    return value;
}
void GCEntityBlocker::SetParent(GCBaseModelEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCEntityBlocker(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCEntityBlocker>("CEntityBlocker")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCEntityBlocker::GetParent, &GCEntityBlocker::SetParent)
        .addFunction("ToPtr", &GCEntityBlocker::ToPtr)
        .addFunction("IsValid", &GCEntityBlocker::IsValid)
        .endClass();
}
GCLogicCase::GCLogicCase(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCLogicCase::GCLogicCase(void *ptr) {
    m_ptr = ptr;
}
std::vector<CUtlSymbolLarge> GCLogicCase::GetCase() const {
    CUtlSymbolLarge* outValue = GetSchemaValue<CUtlSymbolLarge*>(m_ptr, "CLogicCase", "m_nCase"); std::vector<CUtlSymbolLarge> ret; for(int i = 0; i < 32; i++) { ret.push_back(outValue[i]); } return ret;
}
void GCLogicCase::SetCase(std::vector<CUtlSymbolLarge> value) {
    CUtlSymbolLarge* outValue = GetSchemaValue<CUtlSymbolLarge*>(m_ptr, "CLogicCase", "m_nCase"); for(int i = 0; i < 32; i++) { outValue[i] = value[i]; } SetSchemaValue(m_ptr, "CLogicCase", "m_nCase", false, outValue);
}
int32_t GCLogicCase::GetShuffleCases() const {
    return GetSchemaValue<int32_t>(m_ptr, "CLogicCase", "m_nShuffleCases");
}
void GCLogicCase::SetShuffleCases(int32_t value) {
    SetSchemaValue(m_ptr, "CLogicCase", "m_nShuffleCases", false, value);
}
int32_t GCLogicCase::GetLastShuffleCase() const {
    return GetSchemaValue<int32_t>(m_ptr, "CLogicCase", "m_nLastShuffleCase");
}
void GCLogicCase::SetLastShuffleCase(int32_t value) {
    SetSchemaValue(m_ptr, "CLogicCase", "m_nLastShuffleCase", false, value);
}
std::vector<uint8_t> GCLogicCase::GetUchShuffleCaseMap() const {
    uint8_t* outValue = GetSchemaValue<uint8_t*>(m_ptr, "CLogicCase", "m_uchShuffleCaseMap"); std::vector<uint8_t> ret; for(int i = 0; i < 32; i++) { ret.push_back(outValue[i]); } return ret;
}
void GCLogicCase::SetUchShuffleCaseMap(std::vector<uint8_t> value) {
    uint8_t* outValue = GetSchemaValue<uint8_t*>(m_ptr, "CLogicCase", "m_uchShuffleCaseMap"); for(int i = 0; i < 32; i++) { outValue[i] = value[i]; } SetSchemaValue(m_ptr, "CLogicCase", "m_uchShuffleCaseMap", false, outValue);
}
std::vector<GCEntityIOOutput> GCLogicCase::GetOnCase() const {
    GCEntityIOOutput* outValue = GetSchemaValue<GCEntityIOOutput*>(m_ptr, "CLogicCase", "m_OnCase"); std::vector<GCEntityIOOutput> ret; for(int i = 0; i < 32; i++) { ret.push_back(outValue[i]); } return ret;
}
void GCLogicCase::SetOnCase(std::vector<GCEntityIOOutput> value) {
    GCEntityIOOutput* outValue = GetSchemaValue<GCEntityIOOutput*>(m_ptr, "CLogicCase", "m_OnCase"); for(int i = 0; i < 32; i++) { outValue[i] = value[i]; } SetSchemaValue(m_ptr, "CLogicCase", "m_OnCase", false, outValue);
}
std::string GCLogicCase::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCLogicCase::IsValid() {
    return (m_ptr != nullptr);
}
GCLogicalEntity GCLogicCase::GetParent() const {
    GCLogicalEntity value(m_ptr);
    return value;
}
void GCLogicCase::SetParent(GCLogicalEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCLogicCase(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCLogicCase>("CLogicCase")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Case", &GCLogicCase::GetCase, &GCLogicCase::SetCase)
        .addProperty("ShuffleCases", &GCLogicCase::GetShuffleCases, &GCLogicCase::SetShuffleCases)
        .addProperty("LastShuffleCase", &GCLogicCase::GetLastShuffleCase, &GCLogicCase::SetLastShuffleCase)
        .addProperty("UchShuffleCaseMap", &GCLogicCase::GetUchShuffleCaseMap, &GCLogicCase::SetUchShuffleCaseMap)
        .addProperty("OnCase", &GCLogicCase::GetOnCase, &GCLogicCase::SetOnCase)
        .addProperty("Parent", &GCLogicCase::GetParent, &GCLogicCase::SetParent)
        .addFunction("ToPtr", &GCLogicCase::ToPtr)
        .addFunction("IsValid", &GCLogicCase::IsValid)
        .endClass();
}
GCItem::GCItem(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCItem::GCItem(void *ptr) {
    m_ptr = ptr;
}
GCEntityIOOutput GCItem::GetOnPlayerTouch() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CItem", "m_OnPlayerTouch"));
    return value;
}
void GCItem::SetOnPlayerTouch(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CItem", "m_OnPlayerTouch", false, value);
}
GCEntityIOOutput GCItem::GetOnPlayerPickup() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CItem", "m_OnPlayerPickup"));
    return value;
}
void GCItem::SetOnPlayerPickup(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CItem", "m_OnPlayerPickup", false, value);
}
bool GCItem::GetActivateWhenAtRest() const {
    return GetSchemaValue<bool>(m_ptr, "CItem", "m_bActivateWhenAtRest");
}
void GCItem::SetActivateWhenAtRest(bool value) {
    SetSchemaValue(m_ptr, "CItem", "m_bActivateWhenAtRest", false, value);
}
GCEntityIOOutput GCItem::GetOnCacheInteraction() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CItem", "m_OnCacheInteraction"));
    return value;
}
void GCItem::SetOnCacheInteraction(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CItem", "m_OnCacheInteraction", false, value);
}
GCEntityIOOutput GCItem::GetOnGlovePulled() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CItem", "m_OnGlovePulled"));
    return value;
}
void GCItem::SetOnGlovePulled(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CItem", "m_OnGlovePulled", false, value);
}
Vector GCItem::GetOriginalSpawnOrigin() const {
    return GetSchemaValue<Vector>(m_ptr, "CItem", "m_vOriginalSpawnOrigin");
}
void GCItem::SetOriginalSpawnOrigin(Vector value) {
    SetSchemaValue(m_ptr, "CItem", "m_vOriginalSpawnOrigin", false, value);
}
QAngle GCItem::GetOriginalSpawnAngles() const {
    return GetSchemaValue<QAngle>(m_ptr, "CItem", "m_vOriginalSpawnAngles");
}
void GCItem::SetOriginalSpawnAngles(QAngle value) {
    SetSchemaValue(m_ptr, "CItem", "m_vOriginalSpawnAngles", false, value);
}
bool GCItem::GetPhysStartAsleep() const {
    return GetSchemaValue<bool>(m_ptr, "CItem", "m_bPhysStartAsleep");
}
void GCItem::SetPhysStartAsleep(bool value) {
    SetSchemaValue(m_ptr, "CItem", "m_bPhysStartAsleep", false, value);
}
std::string GCItem::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCItem::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseAnimGraph GCItem::GetParent() const {
    GCBaseAnimGraph value(m_ptr);
    return value;
}
void GCItem::SetParent(GCBaseAnimGraph value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCItem(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCItem>("CItem")
        .addConstructor<void (*)(std::string)>()
        .addProperty("OnPlayerTouch", &GCItem::GetOnPlayerTouch, &GCItem::SetOnPlayerTouch)
        .addProperty("OnPlayerPickup", &GCItem::GetOnPlayerPickup, &GCItem::SetOnPlayerPickup)
        .addProperty("ActivateWhenAtRest", &GCItem::GetActivateWhenAtRest, &GCItem::SetActivateWhenAtRest)
        .addProperty("OnCacheInteraction", &GCItem::GetOnCacheInteraction, &GCItem::SetOnCacheInteraction)
        .addProperty("OnGlovePulled", &GCItem::GetOnGlovePulled, &GCItem::SetOnGlovePulled)
        .addProperty("OriginalSpawnOrigin", &GCItem::GetOriginalSpawnOrigin, &GCItem::SetOriginalSpawnOrigin)
        .addProperty("OriginalSpawnAngles", &GCItem::GetOriginalSpawnAngles, &GCItem::SetOriginalSpawnAngles)
        .addProperty("PhysStartAsleep", &GCItem::GetPhysStartAsleep, &GCItem::SetPhysStartAsleep)
        .addProperty("Parent", &GCItem::GetParent, &GCItem::SetParent)
        .addFunction("ToPtr", &GCItem::ToPtr)
        .addFunction("IsValid", &GCItem::IsValid)
        .endClass();
}
GCRuleEntity::GCRuleEntity(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCRuleEntity::GCRuleEntity(void *ptr) {
    m_ptr = ptr;
}
std::string GCRuleEntity::GetMaster() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CRuleEntity", "m_iszMaster").String();
}
void GCRuleEntity::SetMaster(std::string value) {
    SetSchemaValue(m_ptr, "CRuleEntity", "m_iszMaster", false, CUtlSymbolLarge(value.c_str()));
}
std::string GCRuleEntity::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCRuleEntity::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseModelEntity GCRuleEntity::GetParent() const {
    GCBaseModelEntity value(m_ptr);
    return value;
}
void GCRuleEntity::SetParent(GCBaseModelEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCRuleEntity(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCRuleEntity>("CRuleEntity")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Master", &GCRuleEntity::GetMaster, &GCRuleEntity::SetMaster)
        .addProperty("Parent", &GCRuleEntity::GetParent, &GCRuleEntity::SetParent)
        .addFunction("ToPtr", &GCRuleEntity::ToPtr)
        .addFunction("IsValid", &GCRuleEntity::IsValid)
        .endClass();
}
GExtent::GExtent(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GExtent::GExtent(void *ptr) {
    m_ptr = ptr;
}
Vector GExtent::GetLo() const {
    return GetSchemaValue<Vector>(m_ptr, "Extent", "lo");
}
void GExtent::SetLo(Vector value) {
    SetSchemaValue(m_ptr, "Extent", "lo", false, value);
}
Vector GExtent::GetHi() const {
    return GetSchemaValue<Vector>(m_ptr, "Extent", "hi");
}
void GExtent::SetHi(Vector value) {
    SetSchemaValue(m_ptr, "Extent", "hi", false, value);
}
std::string GExtent::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GExtent::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassExtent(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GExtent>("Extent")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Lo", &GExtent::GetLo, &GExtent::SetLo)
        .addProperty("Hi", &GExtent::GetHi, &GExtent::SetHi)
        .addFunction("ToPtr", &GExtent::ToPtr)
        .addFunction("IsValid", &GExtent::IsValid)
        .endClass();
}
GCSoundEventEntity::GCSoundEventEntity(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCSoundEventEntity::GCSoundEventEntity(void *ptr) {
    m_ptr = ptr;
}
bool GCSoundEventEntity::GetStartOnSpawn() const {
    return GetSchemaValue<bool>(m_ptr, "CSoundEventEntity", "m_bStartOnSpawn");
}
void GCSoundEventEntity::SetStartOnSpawn(bool value) {
    SetSchemaValue(m_ptr, "CSoundEventEntity", "m_bStartOnSpawn", false, value);
}
bool GCSoundEventEntity::GetToLocalPlayer() const {
    return GetSchemaValue<bool>(m_ptr, "CSoundEventEntity", "m_bToLocalPlayer");
}
void GCSoundEventEntity::SetToLocalPlayer(bool value) {
    SetSchemaValue(m_ptr, "CSoundEventEntity", "m_bToLocalPlayer", false, value);
}
bool GCSoundEventEntity::GetStopOnNew() const {
    return GetSchemaValue<bool>(m_ptr, "CSoundEventEntity", "m_bStopOnNew");
}
void GCSoundEventEntity::SetStopOnNew(bool value) {
    SetSchemaValue(m_ptr, "CSoundEventEntity", "m_bStopOnNew", false, value);
}
bool GCSoundEventEntity::GetSaveRestore() const {
    return GetSchemaValue<bool>(m_ptr, "CSoundEventEntity", "m_bSaveRestore");
}
void GCSoundEventEntity::SetSaveRestore(bool value) {
    SetSchemaValue(m_ptr, "CSoundEventEntity", "m_bSaveRestore", false, value);
}
bool GCSoundEventEntity::GetSavedIsPlaying() const {
    return GetSchemaValue<bool>(m_ptr, "CSoundEventEntity", "m_bSavedIsPlaying");
}
void GCSoundEventEntity::SetSavedIsPlaying(bool value) {
    SetSchemaValue(m_ptr, "CSoundEventEntity", "m_bSavedIsPlaying", false, value);
}
float GCSoundEventEntity::GetSavedElapsedTime() const {
    return GetSchemaValue<float>(m_ptr, "CSoundEventEntity", "m_flSavedElapsedTime");
}
void GCSoundEventEntity::SetSavedElapsedTime(float value) {
    SetSchemaValue(m_ptr, "CSoundEventEntity", "m_flSavedElapsedTime", false, value);
}
std::string GCSoundEventEntity::GetSourceEntityName() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CSoundEventEntity", "m_iszSourceEntityName").String();
}
void GCSoundEventEntity::SetSourceEntityName(std::string value) {
    SetSchemaValue(m_ptr, "CSoundEventEntity", "m_iszSourceEntityName", false, CUtlSymbolLarge(value.c_str()));
}
std::string GCSoundEventEntity::GetAttachmentName() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CSoundEventEntity", "m_iszAttachmentName").String();
}
void GCSoundEventEntity::SetAttachmentName(std::string value) {
    SetSchemaValue(m_ptr, "CSoundEventEntity", "m_iszAttachmentName", false, CUtlSymbolLarge(value.c_str()));
}
GCEntityIOOutput GCSoundEventEntity::GetOnSoundFinished() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CSoundEventEntity", "m_onSoundFinished"));
    return value;
}
void GCSoundEventEntity::SetOnSoundFinished(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CSoundEventEntity", "m_onSoundFinished", false, value);
}
std::string GCSoundEventEntity::GetSoundName() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CSoundEventEntity", "m_iszSoundName").String();
}
void GCSoundEventEntity::SetSoundName(std::string value) {
    SetSchemaValue(m_ptr, "CSoundEventEntity", "m_iszSoundName", false, CUtlSymbolLarge(value.c_str()));
}
GCEntityInstance GCSoundEventEntity::GetSource() const {
    GCEntityInstance value(*GetSchemaValuePtr<void*>(m_ptr, "CSoundEventEntity", "m_hSource"));
    return value;
}
void GCSoundEventEntity::SetSource(GCEntityInstance* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Source' is not possible.\n");
}
int32_t GCSoundEventEntity::GetEntityIndexSelection() const {
    return GetSchemaValue<int32_t>(m_ptr, "CSoundEventEntity", "m_nEntityIndexSelection");
}
void GCSoundEventEntity::SetEntityIndexSelection(int32_t value) {
    SetSchemaValue(m_ptr, "CSoundEventEntity", "m_nEntityIndexSelection", false, value);
}
std::string GCSoundEventEntity::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCSoundEventEntity::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseEntity GCSoundEventEntity::GetParent() const {
    GCBaseEntity value(m_ptr);
    return value;
}
void GCSoundEventEntity::SetParent(GCBaseEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCSoundEventEntity(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCSoundEventEntity>("CSoundEventEntity")
        .addConstructor<void (*)(std::string)>()
        .addProperty("StartOnSpawn", &GCSoundEventEntity::GetStartOnSpawn, &GCSoundEventEntity::SetStartOnSpawn)
        .addProperty("ToLocalPlayer", &GCSoundEventEntity::GetToLocalPlayer, &GCSoundEventEntity::SetToLocalPlayer)
        .addProperty("StopOnNew", &GCSoundEventEntity::GetStopOnNew, &GCSoundEventEntity::SetStopOnNew)
        .addProperty("SaveRestore", &GCSoundEventEntity::GetSaveRestore, &GCSoundEventEntity::SetSaveRestore)
        .addProperty("SavedIsPlaying", &GCSoundEventEntity::GetSavedIsPlaying, &GCSoundEventEntity::SetSavedIsPlaying)
        .addProperty("SavedElapsedTime", &GCSoundEventEntity::GetSavedElapsedTime, &GCSoundEventEntity::SetSavedElapsedTime)
        .addProperty("SourceEntityName", &GCSoundEventEntity::GetSourceEntityName, &GCSoundEventEntity::SetSourceEntityName)
        .addProperty("AttachmentName", &GCSoundEventEntity::GetAttachmentName, &GCSoundEventEntity::SetAttachmentName)
        .addProperty("OnSoundFinished", &GCSoundEventEntity::GetOnSoundFinished, &GCSoundEventEntity::SetOnSoundFinished)
        .addProperty("SoundName", &GCSoundEventEntity::GetSoundName, &GCSoundEventEntity::SetSoundName)
        .addProperty("Source", &GCSoundEventEntity::GetSource, &GCSoundEventEntity::SetSource)
        .addProperty("EntityIndexSelection", &GCSoundEventEntity::GetEntityIndexSelection, &GCSoundEventEntity::SetEntityIndexSelection)
        .addProperty("Parent", &GCSoundEventEntity::GetParent, &GCSoundEventEntity::SetParent)
        .addFunction("ToPtr", &GCSoundEventEntity::ToPtr)
        .addFunction("IsValid", &GCSoundEventEntity::IsValid)
        .endClass();
}
GCCSPlayer_ViewModelServices::GCCSPlayer_ViewModelServices(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCCSPlayer_ViewModelServices::GCCSPlayer_ViewModelServices(void *ptr) {
    m_ptr = ptr;
}
std::vector<GCBaseViewModel*> GCCSPlayer_ViewModelServices::GetViewModel() const {
    GCBaseViewModel** outValue = GetSchemaValue<GCBaseViewModel**>(m_ptr, "CCSPlayer_ViewModelServices", "m_hViewModel"); std::vector<GCBaseViewModel*> ret; for(int i = 0; i < 3; i++) { ret.push_back(outValue[i]); } return ret;
}
void GCCSPlayer_ViewModelServices::SetViewModel(std::vector<GCBaseViewModel*> value) {
    GCBaseViewModel** outValue = GetSchemaValue<GCBaseViewModel**>(m_ptr, "CCSPlayer_ViewModelServices", "m_hViewModel"); for(int i = 0; i < 3; i++) { outValue[i] = value[i]; } SetSchemaValue(m_ptr, "CCSPlayer_ViewModelServices", "m_hViewModel", false, outValue);
}
std::string GCCSPlayer_ViewModelServices::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCCSPlayer_ViewModelServices::IsValid() {
    return (m_ptr != nullptr);
}
GCPlayer_ViewModelServices GCCSPlayer_ViewModelServices::GetParent() const {
    GCPlayer_ViewModelServices value(m_ptr);
    return value;
}
void GCCSPlayer_ViewModelServices::SetParent(GCPlayer_ViewModelServices value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCCSPlayer_ViewModelServices(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCCSPlayer_ViewModelServices>("CCSPlayer_ViewModelServices")
        .addConstructor<void (*)(std::string)>()
        .addProperty("ViewModel", &GCCSPlayer_ViewModelServices::GetViewModel, &GCCSPlayer_ViewModelServices::SetViewModel)
        .addProperty("Parent", &GCCSPlayer_ViewModelServices::GetParent, &GCCSPlayer_ViewModelServices::SetParent)
        .addFunction("ToPtr", &GCCSPlayer_ViewModelServices::ToPtr)
        .addFunction("IsValid", &GCCSPlayer_ViewModelServices::IsValid)
        .endClass();
}
GCBasePlayerWeapon::GCBasePlayerWeapon(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCBasePlayerWeapon::GCBasePlayerWeapon(void *ptr) {
    m_ptr = ptr;
}
int32 GCBasePlayerWeapon::GetNextPrimaryAttackTick() const {
    return GetSchemaValue<int32>(m_ptr, "CBasePlayerWeapon", "m_nNextPrimaryAttackTick");
}
void GCBasePlayerWeapon::SetNextPrimaryAttackTick(int32 value) {
    SetSchemaValue(m_ptr, "CBasePlayerWeapon", "m_nNextPrimaryAttackTick", false, value);
}
float GCBasePlayerWeapon::GetNextPrimaryAttackTickRatio() const {
    return GetSchemaValue<float>(m_ptr, "CBasePlayerWeapon", "m_flNextPrimaryAttackTickRatio");
}
void GCBasePlayerWeapon::SetNextPrimaryAttackTickRatio(float value) {
    SetSchemaValue(m_ptr, "CBasePlayerWeapon", "m_flNextPrimaryAttackTickRatio", false, value);
}
int32 GCBasePlayerWeapon::GetNextSecondaryAttackTick() const {
    return GetSchemaValue<int32>(m_ptr, "CBasePlayerWeapon", "m_nNextSecondaryAttackTick");
}
void GCBasePlayerWeapon::SetNextSecondaryAttackTick(int32 value) {
    SetSchemaValue(m_ptr, "CBasePlayerWeapon", "m_nNextSecondaryAttackTick", false, value);
}
float GCBasePlayerWeapon::GetNextSecondaryAttackTickRatio() const {
    return GetSchemaValue<float>(m_ptr, "CBasePlayerWeapon", "m_flNextSecondaryAttackTickRatio");
}
void GCBasePlayerWeapon::SetNextSecondaryAttackTickRatio(float value) {
    SetSchemaValue(m_ptr, "CBasePlayerWeapon", "m_flNextSecondaryAttackTickRatio", false, value);
}
int32_t GCBasePlayerWeapon::GetClip1() const {
    return GetSchemaValue<int32_t>(m_ptr, "CBasePlayerWeapon", "m_iClip1");
}
void GCBasePlayerWeapon::SetClip1(int32_t value) {
    SetSchemaValue(m_ptr, "CBasePlayerWeapon", "m_iClip1", false, value);
}
int32_t GCBasePlayerWeapon::GetClip2() const {
    return GetSchemaValue<int32_t>(m_ptr, "CBasePlayerWeapon", "m_iClip2");
}
void GCBasePlayerWeapon::SetClip2(int32_t value) {
    SetSchemaValue(m_ptr, "CBasePlayerWeapon", "m_iClip2", false, value);
}
std::vector<int32_t> GCBasePlayerWeapon::GetReserveAmmo() const {
    int32_t* outValue = GetSchemaValue<int32_t*>(m_ptr, "CBasePlayerWeapon", "m_pReserveAmmo"); std::vector<int32_t> ret; for(int i = 0; i < 2; i++) { ret.push_back(outValue[i]); } return ret;
}
void GCBasePlayerWeapon::SetReserveAmmo(std::vector<int32_t> value) {
    int32_t* outValue = GetSchemaValue<int32_t*>(m_ptr, "CBasePlayerWeapon", "m_pReserveAmmo"); for(int i = 0; i < 2; i++) { outValue[i] = value[i]; } SetSchemaValue(m_ptr, "CBasePlayerWeapon", "m_pReserveAmmo", false, outValue);
}
GCEntityIOOutput GCBasePlayerWeapon::GetOnPlayerUse() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CBasePlayerWeapon", "m_OnPlayerUse"));
    return value;
}
void GCBasePlayerWeapon::SetOnPlayerUse(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CBasePlayerWeapon", "m_OnPlayerUse", false, value);
}
std::string GCBasePlayerWeapon::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCBasePlayerWeapon::IsValid() {
    return (m_ptr != nullptr);
}
GCEconEntity GCBasePlayerWeapon::GetParent() const {
    GCEconEntity value(m_ptr);
    return value;
}
void GCBasePlayerWeapon::SetParent(GCEconEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCBasePlayerWeapon(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCBasePlayerWeapon>("CBasePlayerWeapon")
        .addConstructor<void (*)(std::string)>()
        .addProperty("NextPrimaryAttackTick", &GCBasePlayerWeapon::GetNextPrimaryAttackTick, &GCBasePlayerWeapon::SetNextPrimaryAttackTick)
        .addProperty("NextPrimaryAttackTickRatio", &GCBasePlayerWeapon::GetNextPrimaryAttackTickRatio, &GCBasePlayerWeapon::SetNextPrimaryAttackTickRatio)
        .addProperty("NextSecondaryAttackTick", &GCBasePlayerWeapon::GetNextSecondaryAttackTick, &GCBasePlayerWeapon::SetNextSecondaryAttackTick)
        .addProperty("NextSecondaryAttackTickRatio", &GCBasePlayerWeapon::GetNextSecondaryAttackTickRatio, &GCBasePlayerWeapon::SetNextSecondaryAttackTickRatio)
        .addProperty("Clip1", &GCBasePlayerWeapon::GetClip1, &GCBasePlayerWeapon::SetClip1)
        .addProperty("Clip2", &GCBasePlayerWeapon::GetClip2, &GCBasePlayerWeapon::SetClip2)
        .addProperty("ReserveAmmo", &GCBasePlayerWeapon::GetReserveAmmo, &GCBasePlayerWeapon::SetReserveAmmo)
        .addProperty("OnPlayerUse", &GCBasePlayerWeapon::GetOnPlayerUse, &GCBasePlayerWeapon::SetOnPlayerUse)
        .addProperty("Parent", &GCBasePlayerWeapon::GetParent, &GCBasePlayerWeapon::SetParent)
        .addFunction("ToPtr", &GCBasePlayerWeapon::ToPtr)
        .addFunction("IsValid", &GCBasePlayerWeapon::IsValid)
        .endClass();
}
GCInfoParticleTarget::GCInfoParticleTarget(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCInfoParticleTarget::GCInfoParticleTarget(void *ptr) {
    m_ptr = ptr;
}
std::string GCInfoParticleTarget::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCInfoParticleTarget::IsValid() {
    return (m_ptr != nullptr);
}
GCPointEntity GCInfoParticleTarget::GetParent() const {
    GCPointEntity value(m_ptr);
    return value;
}
void GCInfoParticleTarget::SetParent(GCPointEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCInfoParticleTarget(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCInfoParticleTarget>("CInfoParticleTarget")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCInfoParticleTarget::GetParent, &GCInfoParticleTarget::SetParent)
        .addFunction("ToPtr", &GCInfoParticleTarget::ToPtr)
        .addFunction("IsValid", &GCInfoParticleTarget::IsValid)
        .endClass();
}
GCEnvVolumetricFogController::GCEnvVolumetricFogController(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCEnvVolumetricFogController::GCEnvVolumetricFogController(void *ptr) {
    m_ptr = ptr;
}
float GCEnvVolumetricFogController::GetScattering() const {
    return GetSchemaValue<float>(m_ptr, "CEnvVolumetricFogController", "m_flScattering");
}
void GCEnvVolumetricFogController::SetScattering(float value) {
    SetSchemaValue(m_ptr, "CEnvVolumetricFogController", "m_flScattering", false, value);
}
float GCEnvVolumetricFogController::GetAnisotropy() const {
    return GetSchemaValue<float>(m_ptr, "CEnvVolumetricFogController", "m_flAnisotropy");
}
void GCEnvVolumetricFogController::SetAnisotropy(float value) {
    SetSchemaValue(m_ptr, "CEnvVolumetricFogController", "m_flAnisotropy", false, value);
}
float GCEnvVolumetricFogController::GetFadeSpeed() const {
    return GetSchemaValue<float>(m_ptr, "CEnvVolumetricFogController", "m_flFadeSpeed");
}
void GCEnvVolumetricFogController::SetFadeSpeed(float value) {
    SetSchemaValue(m_ptr, "CEnvVolumetricFogController", "m_flFadeSpeed", false, value);
}
float GCEnvVolumetricFogController::GetDrawDistance() const {
    return GetSchemaValue<float>(m_ptr, "CEnvVolumetricFogController", "m_flDrawDistance");
}
void GCEnvVolumetricFogController::SetDrawDistance(float value) {
    SetSchemaValue(m_ptr, "CEnvVolumetricFogController", "m_flDrawDistance", false, value);
}
float GCEnvVolumetricFogController::GetFadeInStart() const {
    return GetSchemaValue<float>(m_ptr, "CEnvVolumetricFogController", "m_flFadeInStart");
}
void GCEnvVolumetricFogController::SetFadeInStart(float value) {
    SetSchemaValue(m_ptr, "CEnvVolumetricFogController", "m_flFadeInStart", false, value);
}
float GCEnvVolumetricFogController::GetFadeInEnd() const {
    return GetSchemaValue<float>(m_ptr, "CEnvVolumetricFogController", "m_flFadeInEnd");
}
void GCEnvVolumetricFogController::SetFadeInEnd(float value) {
    SetSchemaValue(m_ptr, "CEnvVolumetricFogController", "m_flFadeInEnd", false, value);
}
float GCEnvVolumetricFogController::GetIndirectStrength() const {
    return GetSchemaValue<float>(m_ptr, "CEnvVolumetricFogController", "m_flIndirectStrength");
}
void GCEnvVolumetricFogController::SetIndirectStrength(float value) {
    SetSchemaValue(m_ptr, "CEnvVolumetricFogController", "m_flIndirectStrength", false, value);
}
int32_t GCEnvVolumetricFogController::GetIndirectTextureDimX() const {
    return GetSchemaValue<int32_t>(m_ptr, "CEnvVolumetricFogController", "m_nIndirectTextureDimX");
}
void GCEnvVolumetricFogController::SetIndirectTextureDimX(int32_t value) {
    SetSchemaValue(m_ptr, "CEnvVolumetricFogController", "m_nIndirectTextureDimX", false, value);
}
int32_t GCEnvVolumetricFogController::GetIndirectTextureDimY() const {
    return GetSchemaValue<int32_t>(m_ptr, "CEnvVolumetricFogController", "m_nIndirectTextureDimY");
}
void GCEnvVolumetricFogController::SetIndirectTextureDimY(int32_t value) {
    SetSchemaValue(m_ptr, "CEnvVolumetricFogController", "m_nIndirectTextureDimY", false, value);
}
int32_t GCEnvVolumetricFogController::GetIndirectTextureDimZ() const {
    return GetSchemaValue<int32_t>(m_ptr, "CEnvVolumetricFogController", "m_nIndirectTextureDimZ");
}
void GCEnvVolumetricFogController::SetIndirectTextureDimZ(int32_t value) {
    SetSchemaValue(m_ptr, "CEnvVolumetricFogController", "m_nIndirectTextureDimZ", false, value);
}
Vector GCEnvVolumetricFogController::GetBoxMins() const {
    return GetSchemaValue<Vector>(m_ptr, "CEnvVolumetricFogController", "m_vBoxMins");
}
void GCEnvVolumetricFogController::SetBoxMins(Vector value) {
    SetSchemaValue(m_ptr, "CEnvVolumetricFogController", "m_vBoxMins", false, value);
}
Vector GCEnvVolumetricFogController::GetBoxMaxs() const {
    return GetSchemaValue<Vector>(m_ptr, "CEnvVolumetricFogController", "m_vBoxMaxs");
}
void GCEnvVolumetricFogController::SetBoxMaxs(Vector value) {
    SetSchemaValue(m_ptr, "CEnvVolumetricFogController", "m_vBoxMaxs", false, value);
}
bool GCEnvVolumetricFogController::GetActive() const {
    return GetSchemaValue<bool>(m_ptr, "CEnvVolumetricFogController", "m_bActive");
}
void GCEnvVolumetricFogController::SetActive(bool value) {
    SetSchemaValue(m_ptr, "CEnvVolumetricFogController", "m_bActive", false, value);
}
float GCEnvVolumetricFogController::GetStartAnisoTime() const {
    return GetSchemaValue<float>(m_ptr, "CEnvVolumetricFogController", "m_flStartAnisoTime");
}
void GCEnvVolumetricFogController::SetStartAnisoTime(float value) {
    SetSchemaValue(m_ptr, "CEnvVolumetricFogController", "m_flStartAnisoTime", false, value);
}
float GCEnvVolumetricFogController::GetStartScatterTime() const {
    return GetSchemaValue<float>(m_ptr, "CEnvVolumetricFogController", "m_flStartScatterTime");
}
void GCEnvVolumetricFogController::SetStartScatterTime(float value) {
    SetSchemaValue(m_ptr, "CEnvVolumetricFogController", "m_flStartScatterTime", false, value);
}
float GCEnvVolumetricFogController::GetStartDrawDistanceTime() const {
    return GetSchemaValue<float>(m_ptr, "CEnvVolumetricFogController", "m_flStartDrawDistanceTime");
}
void GCEnvVolumetricFogController::SetStartDrawDistanceTime(float value) {
    SetSchemaValue(m_ptr, "CEnvVolumetricFogController", "m_flStartDrawDistanceTime", false, value);
}
float GCEnvVolumetricFogController::GetStartAnisotropy() const {
    return GetSchemaValue<float>(m_ptr, "CEnvVolumetricFogController", "m_flStartAnisotropy");
}
void GCEnvVolumetricFogController::SetStartAnisotropy(float value) {
    SetSchemaValue(m_ptr, "CEnvVolumetricFogController", "m_flStartAnisotropy", false, value);
}
float GCEnvVolumetricFogController::GetStartScattering() const {
    return GetSchemaValue<float>(m_ptr, "CEnvVolumetricFogController", "m_flStartScattering");
}
void GCEnvVolumetricFogController::SetStartScattering(float value) {
    SetSchemaValue(m_ptr, "CEnvVolumetricFogController", "m_flStartScattering", false, value);
}
float GCEnvVolumetricFogController::GetStartDrawDistance() const {
    return GetSchemaValue<float>(m_ptr, "CEnvVolumetricFogController", "m_flStartDrawDistance");
}
void GCEnvVolumetricFogController::SetStartDrawDistance(float value) {
    SetSchemaValue(m_ptr, "CEnvVolumetricFogController", "m_flStartDrawDistance", false, value);
}
float GCEnvVolumetricFogController::GetDefaultAnisotropy() const {
    return GetSchemaValue<float>(m_ptr, "CEnvVolumetricFogController", "m_flDefaultAnisotropy");
}
void GCEnvVolumetricFogController::SetDefaultAnisotropy(float value) {
    SetSchemaValue(m_ptr, "CEnvVolumetricFogController", "m_flDefaultAnisotropy", false, value);
}
float GCEnvVolumetricFogController::GetDefaultScattering() const {
    return GetSchemaValue<float>(m_ptr, "CEnvVolumetricFogController", "m_flDefaultScattering");
}
void GCEnvVolumetricFogController::SetDefaultScattering(float value) {
    SetSchemaValue(m_ptr, "CEnvVolumetricFogController", "m_flDefaultScattering", false, value);
}
float GCEnvVolumetricFogController::GetDefaultDrawDistance() const {
    return GetSchemaValue<float>(m_ptr, "CEnvVolumetricFogController", "m_flDefaultDrawDistance");
}
void GCEnvVolumetricFogController::SetDefaultDrawDistance(float value) {
    SetSchemaValue(m_ptr, "CEnvVolumetricFogController", "m_flDefaultDrawDistance", false, value);
}
bool GCEnvVolumetricFogController::GetStartDisabled() const {
    return GetSchemaValue<bool>(m_ptr, "CEnvVolumetricFogController", "m_bStartDisabled");
}
void GCEnvVolumetricFogController::SetStartDisabled(bool value) {
    SetSchemaValue(m_ptr, "CEnvVolumetricFogController", "m_bStartDisabled", false, value);
}
bool GCEnvVolumetricFogController::GetEnableIndirect() const {
    return GetSchemaValue<bool>(m_ptr, "CEnvVolumetricFogController", "m_bEnableIndirect");
}
void GCEnvVolumetricFogController::SetEnableIndirect(bool value) {
    SetSchemaValue(m_ptr, "CEnvVolumetricFogController", "m_bEnableIndirect", false, value);
}
bool GCEnvVolumetricFogController::GetIndirectUseLPVs() const {
    return GetSchemaValue<bool>(m_ptr, "CEnvVolumetricFogController", "m_bIndirectUseLPVs");
}
void GCEnvVolumetricFogController::SetIndirectUseLPVs(bool value) {
    SetSchemaValue(m_ptr, "CEnvVolumetricFogController", "m_bIndirectUseLPVs", false, value);
}
bool GCEnvVolumetricFogController::GetIsMaster() const {
    return GetSchemaValue<bool>(m_ptr, "CEnvVolumetricFogController", "m_bIsMaster");
}
void GCEnvVolumetricFogController::SetIsMaster(bool value) {
    SetSchemaValue(m_ptr, "CEnvVolumetricFogController", "m_bIsMaster", false, value);
}
int32_t GCEnvVolumetricFogController::GetForceRefreshCount() const {
    return GetSchemaValue<int32_t>(m_ptr, "CEnvVolumetricFogController", "m_nForceRefreshCount");
}
void GCEnvVolumetricFogController::SetForceRefreshCount(int32_t value) {
    SetSchemaValue(m_ptr, "CEnvVolumetricFogController", "m_nForceRefreshCount", false, value);
}
float GCEnvVolumetricFogController::GetNoiseSpeed() const {
    return GetSchemaValue<float>(m_ptr, "CEnvVolumetricFogController", "m_fNoiseSpeed");
}
void GCEnvVolumetricFogController::SetNoiseSpeed(float value) {
    SetSchemaValue(m_ptr, "CEnvVolumetricFogController", "m_fNoiseSpeed", false, value);
}
float GCEnvVolumetricFogController::GetNoiseStrength() const {
    return GetSchemaValue<float>(m_ptr, "CEnvVolumetricFogController", "m_fNoiseStrength");
}
void GCEnvVolumetricFogController::SetNoiseStrength(float value) {
    SetSchemaValue(m_ptr, "CEnvVolumetricFogController", "m_fNoiseStrength", false, value);
}
Vector GCEnvVolumetricFogController::GetNoiseScale() const {
    return GetSchemaValue<Vector>(m_ptr, "CEnvVolumetricFogController", "m_vNoiseScale");
}
void GCEnvVolumetricFogController::SetNoiseScale(Vector value) {
    SetSchemaValue(m_ptr, "CEnvVolumetricFogController", "m_vNoiseScale", false, value);
}
bool GCEnvVolumetricFogController::GetFirstTime() const {
    return GetSchemaValue<bool>(m_ptr, "CEnvVolumetricFogController", "m_bFirstTime");
}
void GCEnvVolumetricFogController::SetFirstTime(bool value) {
    SetSchemaValue(m_ptr, "CEnvVolumetricFogController", "m_bFirstTime", false, value);
}
std::string GCEnvVolumetricFogController::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCEnvVolumetricFogController::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseEntity GCEnvVolumetricFogController::GetParent() const {
    GCBaseEntity value(m_ptr);
    return value;
}
void GCEnvVolumetricFogController::SetParent(GCBaseEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCEnvVolumetricFogController(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCEnvVolumetricFogController>("CEnvVolumetricFogController")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Scattering", &GCEnvVolumetricFogController::GetScattering, &GCEnvVolumetricFogController::SetScattering)
        .addProperty("Anisotropy", &GCEnvVolumetricFogController::GetAnisotropy, &GCEnvVolumetricFogController::SetAnisotropy)
        .addProperty("FadeSpeed", &GCEnvVolumetricFogController::GetFadeSpeed, &GCEnvVolumetricFogController::SetFadeSpeed)
        .addProperty("DrawDistance", &GCEnvVolumetricFogController::GetDrawDistance, &GCEnvVolumetricFogController::SetDrawDistance)
        .addProperty("FadeInStart", &GCEnvVolumetricFogController::GetFadeInStart, &GCEnvVolumetricFogController::SetFadeInStart)
        .addProperty("FadeInEnd", &GCEnvVolumetricFogController::GetFadeInEnd, &GCEnvVolumetricFogController::SetFadeInEnd)
        .addProperty("IndirectStrength", &GCEnvVolumetricFogController::GetIndirectStrength, &GCEnvVolumetricFogController::SetIndirectStrength)
        .addProperty("IndirectTextureDimX", &GCEnvVolumetricFogController::GetIndirectTextureDimX, &GCEnvVolumetricFogController::SetIndirectTextureDimX)
        .addProperty("IndirectTextureDimY", &GCEnvVolumetricFogController::GetIndirectTextureDimY, &GCEnvVolumetricFogController::SetIndirectTextureDimY)
        .addProperty("IndirectTextureDimZ", &GCEnvVolumetricFogController::GetIndirectTextureDimZ, &GCEnvVolumetricFogController::SetIndirectTextureDimZ)
        .addProperty("BoxMins", &GCEnvVolumetricFogController::GetBoxMins, &GCEnvVolumetricFogController::SetBoxMins)
        .addProperty("BoxMaxs", &GCEnvVolumetricFogController::GetBoxMaxs, &GCEnvVolumetricFogController::SetBoxMaxs)
        .addProperty("Active", &GCEnvVolumetricFogController::GetActive, &GCEnvVolumetricFogController::SetActive)
        .addProperty("StartAnisoTime", &GCEnvVolumetricFogController::GetStartAnisoTime, &GCEnvVolumetricFogController::SetStartAnisoTime)
        .addProperty("StartScatterTime", &GCEnvVolumetricFogController::GetStartScatterTime, &GCEnvVolumetricFogController::SetStartScatterTime)
        .addProperty("StartDrawDistanceTime", &GCEnvVolumetricFogController::GetStartDrawDistanceTime, &GCEnvVolumetricFogController::SetStartDrawDistanceTime)
        .addProperty("StartAnisotropy", &GCEnvVolumetricFogController::GetStartAnisotropy, &GCEnvVolumetricFogController::SetStartAnisotropy)
        .addProperty("StartScattering", &GCEnvVolumetricFogController::GetStartScattering, &GCEnvVolumetricFogController::SetStartScattering)
        .addProperty("StartDrawDistance", &GCEnvVolumetricFogController::GetStartDrawDistance, &GCEnvVolumetricFogController::SetStartDrawDistance)
        .addProperty("DefaultAnisotropy", &GCEnvVolumetricFogController::GetDefaultAnisotropy, &GCEnvVolumetricFogController::SetDefaultAnisotropy)
        .addProperty("DefaultScattering", &GCEnvVolumetricFogController::GetDefaultScattering, &GCEnvVolumetricFogController::SetDefaultScattering)
        .addProperty("DefaultDrawDistance", &GCEnvVolumetricFogController::GetDefaultDrawDistance, &GCEnvVolumetricFogController::SetDefaultDrawDistance)
        .addProperty("StartDisabled", &GCEnvVolumetricFogController::GetStartDisabled, &GCEnvVolumetricFogController::SetStartDisabled)
        .addProperty("EnableIndirect", &GCEnvVolumetricFogController::GetEnableIndirect, &GCEnvVolumetricFogController::SetEnableIndirect)
        .addProperty("IndirectUseLPVs", &GCEnvVolumetricFogController::GetIndirectUseLPVs, &GCEnvVolumetricFogController::SetIndirectUseLPVs)
        .addProperty("IsMaster", &GCEnvVolumetricFogController::GetIsMaster, &GCEnvVolumetricFogController::SetIsMaster)
        .addProperty("ForceRefreshCount", &GCEnvVolumetricFogController::GetForceRefreshCount, &GCEnvVolumetricFogController::SetForceRefreshCount)
        .addProperty("NoiseSpeed", &GCEnvVolumetricFogController::GetNoiseSpeed, &GCEnvVolumetricFogController::SetNoiseSpeed)
        .addProperty("NoiseStrength", &GCEnvVolumetricFogController::GetNoiseStrength, &GCEnvVolumetricFogController::SetNoiseStrength)
        .addProperty("NoiseScale", &GCEnvVolumetricFogController::GetNoiseScale, &GCEnvVolumetricFogController::SetNoiseScale)
        .addProperty("FirstTime", &GCEnvVolumetricFogController::GetFirstTime, &GCEnvVolumetricFogController::SetFirstTime)
        .addProperty("Parent", &GCEnvVolumetricFogController::GetParent, &GCEnvVolumetricFogController::SetParent)
        .addFunction("ToPtr", &GCEnvVolumetricFogController::ToPtr)
        .addFunction("IsValid", &GCEnvVolumetricFogController::IsValid)
        .endClass();
}
GCPlayer_MovementServices::GCPlayer_MovementServices(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCPlayer_MovementServices::GCPlayer_MovementServices(void *ptr) {
    m_ptr = ptr;
}
int32_t GCPlayer_MovementServices::GetImpulse() const {
    return GetSchemaValue<int32_t>(m_ptr, "CPlayer_MovementServices", "m_nImpulse");
}
void GCPlayer_MovementServices::SetImpulse(int32_t value) {
    SetSchemaValue(m_ptr, "CPlayer_MovementServices", "m_nImpulse", false, value);
}
GCInButtonState GCPlayer_MovementServices::GetButtons() const {
    GCInButtonState value(GetSchemaPtr(m_ptr, "CPlayer_MovementServices", "m_nButtons"));
    return value;
}
void GCPlayer_MovementServices::SetButtons(GCInButtonState value) {
    SetSchemaValue(m_ptr, "CPlayer_MovementServices", "m_nButtons", false, value);
}
uint64_t GCPlayer_MovementServices::GetQueuedButtonDownMask() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CPlayer_MovementServices", "m_nQueuedButtonDownMask");
}
void GCPlayer_MovementServices::SetQueuedButtonDownMask(uint64_t value) {
    SetSchemaValue(m_ptr, "CPlayer_MovementServices", "m_nQueuedButtonDownMask", false, value);
}
uint64_t GCPlayer_MovementServices::GetQueuedButtonChangeMask() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CPlayer_MovementServices", "m_nQueuedButtonChangeMask");
}
void GCPlayer_MovementServices::SetQueuedButtonChangeMask(uint64_t value) {
    SetSchemaValue(m_ptr, "CPlayer_MovementServices", "m_nQueuedButtonChangeMask", false, value);
}
uint64_t GCPlayer_MovementServices::GetButtonDoublePressed() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CPlayer_MovementServices", "m_nButtonDoublePressed");
}
void GCPlayer_MovementServices::SetButtonDoublePressed(uint64_t value) {
    SetSchemaValue(m_ptr, "CPlayer_MovementServices", "m_nButtonDoublePressed", false, value);
}
std::vector<uint32_t> GCPlayer_MovementServices::GetButtonPressedCmdNumber() const {
    uint32_t* outValue = GetSchemaValue<uint32_t*>(m_ptr, "CPlayer_MovementServices", "m_pButtonPressedCmdNumber"); std::vector<uint32_t> ret; for(int i = 0; i < 64; i++) { ret.push_back(outValue[i]); } return ret;
}
void GCPlayer_MovementServices::SetButtonPressedCmdNumber(std::vector<uint32_t> value) {
    uint32_t* outValue = GetSchemaValue<uint32_t*>(m_ptr, "CPlayer_MovementServices", "m_pButtonPressedCmdNumber"); for(int i = 0; i < 64; i++) { outValue[i] = value[i]; } SetSchemaValue(m_ptr, "CPlayer_MovementServices", "m_pButtonPressedCmdNumber", false, outValue);
}
uint32_t GCPlayer_MovementServices::GetLastCommandNumberProcessed() const {
    return GetSchemaValue<uint32_t>(m_ptr, "CPlayer_MovementServices", "m_nLastCommandNumberProcessed");
}
void GCPlayer_MovementServices::SetLastCommandNumberProcessed(uint32_t value) {
    SetSchemaValue(m_ptr, "CPlayer_MovementServices", "m_nLastCommandNumberProcessed", false, value);
}
uint64_t GCPlayer_MovementServices::GetToggleButtonDownMask() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CPlayer_MovementServices", "m_nToggleButtonDownMask");
}
void GCPlayer_MovementServices::SetToggleButtonDownMask(uint64_t value) {
    SetSchemaValue(m_ptr, "CPlayer_MovementServices", "m_nToggleButtonDownMask", false, value);
}
float GCPlayer_MovementServices::GetMaxspeed() const {
    return GetSchemaValue<float>(m_ptr, "CPlayer_MovementServices", "m_flMaxspeed");
}
void GCPlayer_MovementServices::SetMaxspeed(float value) {
    SetSchemaValue(m_ptr, "CPlayer_MovementServices", "m_flMaxspeed", false, value);
}
std::vector<float> GCPlayer_MovementServices::GetForceSubtickMoveWhen() const {
    float* outValue = GetSchemaValue<float*>(m_ptr, "CPlayer_MovementServices", "m_arrForceSubtickMoveWhen"); std::vector<float> ret; for(int i = 0; i < 4; i++) { ret.push_back(outValue[i]); } return ret;
}
void GCPlayer_MovementServices::SetForceSubtickMoveWhen(std::vector<float> value) {
    float* outValue = GetSchemaValue<float*>(m_ptr, "CPlayer_MovementServices", "m_arrForceSubtickMoveWhen"); for(int i = 0; i < 4; i++) { outValue[i] = value[i]; } SetSchemaValue(m_ptr, "CPlayer_MovementServices", "m_arrForceSubtickMoveWhen", false, outValue);
}
float GCPlayer_MovementServices::GetForwardMove() const {
    return GetSchemaValue<float>(m_ptr, "CPlayer_MovementServices", "m_flForwardMove");
}
void GCPlayer_MovementServices::SetForwardMove(float value) {
    SetSchemaValue(m_ptr, "CPlayer_MovementServices", "m_flForwardMove", false, value);
}
float GCPlayer_MovementServices::GetLeftMove() const {
    return GetSchemaValue<float>(m_ptr, "CPlayer_MovementServices", "m_flLeftMove");
}
void GCPlayer_MovementServices::SetLeftMove(float value) {
    SetSchemaValue(m_ptr, "CPlayer_MovementServices", "m_flLeftMove", false, value);
}
float GCPlayer_MovementServices::GetUpMove() const {
    return GetSchemaValue<float>(m_ptr, "CPlayer_MovementServices", "m_flUpMove");
}
void GCPlayer_MovementServices::SetUpMove(float value) {
    SetSchemaValue(m_ptr, "CPlayer_MovementServices", "m_flUpMove", false, value);
}
Vector GCPlayer_MovementServices::GetLastMovementImpulses() const {
    return GetSchemaValue<Vector>(m_ptr, "CPlayer_MovementServices", "m_vecLastMovementImpulses");
}
void GCPlayer_MovementServices::SetLastMovementImpulses(Vector value) {
    SetSchemaValue(m_ptr, "CPlayer_MovementServices", "m_vecLastMovementImpulses", false, value);
}
QAngle GCPlayer_MovementServices::GetOldViewAngles() const {
    return GetSchemaValue<QAngle>(m_ptr, "CPlayer_MovementServices", "m_vecOldViewAngles");
}
void GCPlayer_MovementServices::SetOldViewAngles(QAngle value) {
    SetSchemaValue(m_ptr, "CPlayer_MovementServices", "m_vecOldViewAngles", false, value);
}
std::string GCPlayer_MovementServices::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCPlayer_MovementServices::IsValid() {
    return (m_ptr != nullptr);
}
GCPlayerPawnComponent GCPlayer_MovementServices::GetParent() const {
    GCPlayerPawnComponent value(m_ptr);
    return value;
}
void GCPlayer_MovementServices::SetParent(GCPlayerPawnComponent value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCPlayer_MovementServices(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCPlayer_MovementServices>("CPlayer_MovementServices")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Impulse", &GCPlayer_MovementServices::GetImpulse, &GCPlayer_MovementServices::SetImpulse)
        .addProperty("Buttons", &GCPlayer_MovementServices::GetButtons, &GCPlayer_MovementServices::SetButtons)
        .addProperty("QueuedButtonDownMask", &GCPlayer_MovementServices::GetQueuedButtonDownMask, &GCPlayer_MovementServices::SetQueuedButtonDownMask)
        .addProperty("QueuedButtonChangeMask", &GCPlayer_MovementServices::GetQueuedButtonChangeMask, &GCPlayer_MovementServices::SetQueuedButtonChangeMask)
        .addProperty("ButtonDoublePressed", &GCPlayer_MovementServices::GetButtonDoublePressed, &GCPlayer_MovementServices::SetButtonDoublePressed)
        .addProperty("ButtonPressedCmdNumber", &GCPlayer_MovementServices::GetButtonPressedCmdNumber, &GCPlayer_MovementServices::SetButtonPressedCmdNumber)
        .addProperty("LastCommandNumberProcessed", &GCPlayer_MovementServices::GetLastCommandNumberProcessed, &GCPlayer_MovementServices::SetLastCommandNumberProcessed)
        .addProperty("ToggleButtonDownMask", &GCPlayer_MovementServices::GetToggleButtonDownMask, &GCPlayer_MovementServices::SetToggleButtonDownMask)
        .addProperty("Maxspeed", &GCPlayer_MovementServices::GetMaxspeed, &GCPlayer_MovementServices::SetMaxspeed)
        .addProperty("ForceSubtickMoveWhen", &GCPlayer_MovementServices::GetForceSubtickMoveWhen, &GCPlayer_MovementServices::SetForceSubtickMoveWhen)
        .addProperty("ForwardMove", &GCPlayer_MovementServices::GetForwardMove, &GCPlayer_MovementServices::SetForwardMove)
        .addProperty("LeftMove", &GCPlayer_MovementServices::GetLeftMove, &GCPlayer_MovementServices::SetLeftMove)
        .addProperty("UpMove", &GCPlayer_MovementServices::GetUpMove, &GCPlayer_MovementServices::SetUpMove)
        .addProperty("LastMovementImpulses", &GCPlayer_MovementServices::GetLastMovementImpulses, &GCPlayer_MovementServices::SetLastMovementImpulses)
        .addProperty("OldViewAngles", &GCPlayer_MovementServices::GetOldViewAngles, &GCPlayer_MovementServices::SetOldViewAngles)
        .addProperty("Parent", &GCPlayer_MovementServices::GetParent, &GCPlayer_MovementServices::SetParent)
        .addFunction("ToPtr", &GCPlayer_MovementServices::ToPtr)
        .addFunction("IsValid", &GCPlayer_MovementServices::IsValid)
        .endClass();
}
GCBreakableProp::GCBreakableProp(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCBreakableProp::GCBreakableProp(void *ptr) {
    m_ptr = ptr;
}
GCPropDataComponent GCBreakableProp::GetCPropDataComponent() const {
    GCPropDataComponent value(GetSchemaPtr(m_ptr, "CBreakableProp", "m_CPropDataComponent"));
    return value;
}
void GCBreakableProp::SetCPropDataComponent(GCPropDataComponent value) {
    SetSchemaValue(m_ptr, "CBreakableProp", "m_CPropDataComponent", false, value);
}
GCEntityIOOutput GCBreakableProp::GetOnBreak() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CBreakableProp", "m_OnBreak"));
    return value;
}
void GCBreakableProp::SetOnBreak(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CBreakableProp", "m_OnBreak", false, value);
}
GCEntityIOOutput GCBreakableProp::GetOnTakeDamage() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CBreakableProp", "m_OnTakeDamage"));
    return value;
}
void GCBreakableProp::SetOnTakeDamage(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CBreakableProp", "m_OnTakeDamage", false, value);
}
float GCBreakableProp::GetImpactEnergyScale() const {
    return GetSchemaValue<float>(m_ptr, "CBreakableProp", "m_impactEnergyScale");
}
void GCBreakableProp::SetImpactEnergyScale(float value) {
    SetSchemaValue(m_ptr, "CBreakableProp", "m_impactEnergyScale", false, value);
}
int32_t GCBreakableProp::GetMinHealthDmg() const {
    return GetSchemaValue<int32_t>(m_ptr, "CBreakableProp", "m_iMinHealthDmg");
}
void GCBreakableProp::SetMinHealthDmg(int32_t value) {
    SetSchemaValue(m_ptr, "CBreakableProp", "m_iMinHealthDmg", false, value);
}
QAngle GCBreakableProp::GetPreferredCarryAngles() const {
    return GetSchemaValue<QAngle>(m_ptr, "CBreakableProp", "m_preferredCarryAngles");
}
void GCBreakableProp::SetPreferredCarryAngles(QAngle value) {
    SetSchemaValue(m_ptr, "CBreakableProp", "m_preferredCarryAngles", false, value);
}
float GCBreakableProp::GetPressureDelay() const {
    return GetSchemaValue<float>(m_ptr, "CBreakableProp", "m_flPressureDelay");
}
void GCBreakableProp::SetPressureDelay(float value) {
    SetSchemaValue(m_ptr, "CBreakableProp", "m_flPressureDelay", false, value);
}
float GCBreakableProp::GetDefBurstScale() const {
    return GetSchemaValue<float>(m_ptr, "CBreakableProp", "m_flDefBurstScale");
}
void GCBreakableProp::SetDefBurstScale(float value) {
    SetSchemaValue(m_ptr, "CBreakableProp", "m_flDefBurstScale", false, value);
}
Vector GCBreakableProp::GetDefBurstOffset() const {
    return GetSchemaValue<Vector>(m_ptr, "CBreakableProp", "m_vDefBurstOffset");
}
void GCBreakableProp::SetDefBurstOffset(Vector value) {
    SetSchemaValue(m_ptr, "CBreakableProp", "m_vDefBurstOffset", false, value);
}
GCBaseEntity GCBreakableProp::GetBreaker() const {
    GCBaseEntity value(*GetSchemaValuePtr<void*>(m_ptr, "CBreakableProp", "m_hBreaker"));
    return value;
}
void GCBreakableProp::SetBreaker(GCBaseEntity* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Breaker' is not possible.\n");
}
uint64_t GCBreakableProp::GetPerformanceMode() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CBreakableProp", "m_PerformanceMode");
}
void GCBreakableProp::SetPerformanceMode(uint64_t value) {
    SetSchemaValue(m_ptr, "CBreakableProp", "m_PerformanceMode", false, value);
}
float GCBreakableProp::GetPreventDamageBeforeTime() const {
    return GetSchemaValue<float>(m_ptr, "CBreakableProp", "m_flPreventDamageBeforeTime");
}
void GCBreakableProp::SetPreventDamageBeforeTime(float value) {
    SetSchemaValue(m_ptr, "CBreakableProp", "m_flPreventDamageBeforeTime", false, value);
}
bool GCBreakableProp::GetHasBreakPiecesOrCommands() const {
    return GetSchemaValue<bool>(m_ptr, "CBreakableProp", "m_bHasBreakPiecesOrCommands");
}
void GCBreakableProp::SetHasBreakPiecesOrCommands(bool value) {
    SetSchemaValue(m_ptr, "CBreakableProp", "m_bHasBreakPiecesOrCommands", false, value);
}
float GCBreakableProp::GetExplodeDamage() const {
    return GetSchemaValue<float>(m_ptr, "CBreakableProp", "m_explodeDamage");
}
void GCBreakableProp::SetExplodeDamage(float value) {
    SetSchemaValue(m_ptr, "CBreakableProp", "m_explodeDamage", false, value);
}
float GCBreakableProp::GetExplodeRadius() const {
    return GetSchemaValue<float>(m_ptr, "CBreakableProp", "m_explodeRadius");
}
void GCBreakableProp::SetExplodeRadius(float value) {
    SetSchemaValue(m_ptr, "CBreakableProp", "m_explodeRadius", false, value);
}
float GCBreakableProp::GetExplosionDelay() const {
    return GetSchemaValue<float>(m_ptr, "CBreakableProp", "m_explosionDelay");
}
void GCBreakableProp::SetExplosionDelay(float value) {
    SetSchemaValue(m_ptr, "CBreakableProp", "m_explosionDelay", false, value);
}
std::string GCBreakableProp::GetExplosionBuildupSound() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CBreakableProp", "m_explosionBuildupSound").String();
}
void GCBreakableProp::SetExplosionBuildupSound(std::string value) {
    SetSchemaValue(m_ptr, "CBreakableProp", "m_explosionBuildupSound", false, CUtlSymbolLarge(value.c_str()));
}
std::string GCBreakableProp::GetExplosionCustomEffect() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CBreakableProp", "m_explosionCustomEffect").String();
}
void GCBreakableProp::SetExplosionCustomEffect(std::string value) {
    SetSchemaValue(m_ptr, "CBreakableProp", "m_explosionCustomEffect", false, CUtlSymbolLarge(value.c_str()));
}
std::string GCBreakableProp::GetExplosionCustomSound() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CBreakableProp", "m_explosionCustomSound").String();
}
void GCBreakableProp::SetExplosionCustomSound(std::string value) {
    SetSchemaValue(m_ptr, "CBreakableProp", "m_explosionCustomSound", false, CUtlSymbolLarge(value.c_str()));
}
std::string GCBreakableProp::GetExplosionModifier() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CBreakableProp", "m_explosionModifier").String();
}
void GCBreakableProp::SetExplosionModifier(std::string value) {
    SetSchemaValue(m_ptr, "CBreakableProp", "m_explosionModifier", false, CUtlSymbolLarge(value.c_str()));
}
GCBasePlayerPawn GCBreakableProp::GetPhysicsAttacker() const {
    GCBasePlayerPawn value(*GetSchemaValuePtr<void*>(m_ptr, "CBreakableProp", "m_hPhysicsAttacker"));
    return value;
}
void GCBreakableProp::SetPhysicsAttacker(GCBasePlayerPawn* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'PhysicsAttacker' is not possible.\n");
}
float GCBreakableProp::GetLastPhysicsInfluenceTime() const {
    return GetSchemaValue<float>(m_ptr, "CBreakableProp", "m_flLastPhysicsInfluenceTime");
}
void GCBreakableProp::SetLastPhysicsInfluenceTime(float value) {
    SetSchemaValue(m_ptr, "CBreakableProp", "m_flLastPhysicsInfluenceTime", false, value);
}
bool GCBreakableProp::GetOriginalBlockLOS() const {
    return GetSchemaValue<bool>(m_ptr, "CBreakableProp", "m_bOriginalBlockLOS");
}
void GCBreakableProp::SetOriginalBlockLOS(bool value) {
    SetSchemaValue(m_ptr, "CBreakableProp", "m_bOriginalBlockLOS", false, value);
}
float GCBreakableProp::GetDefaultFadeScale() const {
    return GetSchemaValue<float>(m_ptr, "CBreakableProp", "m_flDefaultFadeScale");
}
void GCBreakableProp::SetDefaultFadeScale(float value) {
    SetSchemaValue(m_ptr, "CBreakableProp", "m_flDefaultFadeScale", false, value);
}
GCBaseEntity GCBreakableProp::GetLastAttacker() const {
    GCBaseEntity value(*GetSchemaValuePtr<void*>(m_ptr, "CBreakableProp", "m_hLastAttacker"));
    return value;
}
void GCBreakableProp::SetLastAttacker(GCBaseEntity* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'LastAttacker' is not possible.\n");
}
GCBaseEntity GCBreakableProp::GetFlareEnt() const {
    GCBaseEntity value(*GetSchemaValuePtr<void*>(m_ptr, "CBreakableProp", "m_hFlareEnt"));
    return value;
}
void GCBreakableProp::SetFlareEnt(GCBaseEntity* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'FlareEnt' is not possible.\n");
}
bool GCBreakableProp::GetUsePuntSound() const {
    return GetSchemaValue<bool>(m_ptr, "CBreakableProp", "m_bUsePuntSound");
}
void GCBreakableProp::SetUsePuntSound(bool value) {
    SetSchemaValue(m_ptr, "CBreakableProp", "m_bUsePuntSound", false, value);
}
std::string GCBreakableProp::GetPuntSound() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CBreakableProp", "m_iszPuntSound").String();
}
void GCBreakableProp::SetPuntSound(std::string value) {
    SetSchemaValue(m_ptr, "CBreakableProp", "m_iszPuntSound", false, CUtlSymbolLarge(value.c_str()));
}
bool GCBreakableProp::GetNoGhostCollision() const {
    return GetSchemaValue<bool>(m_ptr, "CBreakableProp", "m_noGhostCollision");
}
void GCBreakableProp::SetNoGhostCollision(bool value) {
    SetSchemaValue(m_ptr, "CBreakableProp", "m_noGhostCollision", false, value);
}
std::string GCBreakableProp::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCBreakableProp::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseProp GCBreakableProp::GetParent() const {
    GCBaseProp value(m_ptr);
    return value;
}
void GCBreakableProp::SetParent(GCBaseProp value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCBreakableProp(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCBreakableProp>("CBreakableProp")
        .addConstructor<void (*)(std::string)>()
        .addProperty("CPropDataComponent", &GCBreakableProp::GetCPropDataComponent, &GCBreakableProp::SetCPropDataComponent)
        .addProperty("OnBreak", &GCBreakableProp::GetOnBreak, &GCBreakableProp::SetOnBreak)
        .addProperty("OnTakeDamage", &GCBreakableProp::GetOnTakeDamage, &GCBreakableProp::SetOnTakeDamage)
        .addProperty("ImpactEnergyScale", &GCBreakableProp::GetImpactEnergyScale, &GCBreakableProp::SetImpactEnergyScale)
        .addProperty("MinHealthDmg", &GCBreakableProp::GetMinHealthDmg, &GCBreakableProp::SetMinHealthDmg)
        .addProperty("PreferredCarryAngles", &GCBreakableProp::GetPreferredCarryAngles, &GCBreakableProp::SetPreferredCarryAngles)
        .addProperty("PressureDelay", &GCBreakableProp::GetPressureDelay, &GCBreakableProp::SetPressureDelay)
        .addProperty("DefBurstScale", &GCBreakableProp::GetDefBurstScale, &GCBreakableProp::SetDefBurstScale)
        .addProperty("DefBurstOffset", &GCBreakableProp::GetDefBurstOffset, &GCBreakableProp::SetDefBurstOffset)
        .addProperty("Breaker", &GCBreakableProp::GetBreaker, &GCBreakableProp::SetBreaker)
        .addProperty("PerformanceMode", &GCBreakableProp::GetPerformanceMode, &GCBreakableProp::SetPerformanceMode)
        .addProperty("PreventDamageBeforeTime", &GCBreakableProp::GetPreventDamageBeforeTime, &GCBreakableProp::SetPreventDamageBeforeTime)
        .addProperty("HasBreakPiecesOrCommands", &GCBreakableProp::GetHasBreakPiecesOrCommands, &GCBreakableProp::SetHasBreakPiecesOrCommands)
        .addProperty("ExplodeDamage", &GCBreakableProp::GetExplodeDamage, &GCBreakableProp::SetExplodeDamage)
        .addProperty("ExplodeRadius", &GCBreakableProp::GetExplodeRadius, &GCBreakableProp::SetExplodeRadius)
        .addProperty("ExplosionDelay", &GCBreakableProp::GetExplosionDelay, &GCBreakableProp::SetExplosionDelay)
        .addProperty("ExplosionBuildupSound", &GCBreakableProp::GetExplosionBuildupSound, &GCBreakableProp::SetExplosionBuildupSound)
        .addProperty("ExplosionCustomEffect", &GCBreakableProp::GetExplosionCustomEffect, &GCBreakableProp::SetExplosionCustomEffect)
        .addProperty("ExplosionCustomSound", &GCBreakableProp::GetExplosionCustomSound, &GCBreakableProp::SetExplosionCustomSound)
        .addProperty("ExplosionModifier", &GCBreakableProp::GetExplosionModifier, &GCBreakableProp::SetExplosionModifier)
        .addProperty("PhysicsAttacker", &GCBreakableProp::GetPhysicsAttacker, &GCBreakableProp::SetPhysicsAttacker)
        .addProperty("LastPhysicsInfluenceTime", &GCBreakableProp::GetLastPhysicsInfluenceTime, &GCBreakableProp::SetLastPhysicsInfluenceTime)
        .addProperty("OriginalBlockLOS", &GCBreakableProp::GetOriginalBlockLOS, &GCBreakableProp::SetOriginalBlockLOS)
        .addProperty("DefaultFadeScale", &GCBreakableProp::GetDefaultFadeScale, &GCBreakableProp::SetDefaultFadeScale)
        .addProperty("LastAttacker", &GCBreakableProp::GetLastAttacker, &GCBreakableProp::SetLastAttacker)
        .addProperty("FlareEnt", &GCBreakableProp::GetFlareEnt, &GCBreakableProp::SetFlareEnt)
        .addProperty("UsePuntSound", &GCBreakableProp::GetUsePuntSound, &GCBreakableProp::SetUsePuntSound)
        .addProperty("PuntSound", &GCBreakableProp::GetPuntSound, &GCBreakableProp::SetPuntSound)
        .addProperty("NoGhostCollision", &GCBreakableProp::GetNoGhostCollision, &GCBreakableProp::SetNoGhostCollision)
        .addProperty("Parent", &GCBreakableProp::GetParent, &GCBreakableProp::SetParent)
        .addFunction("ToPtr", &GCBreakableProp::ToPtr)
        .addFunction("IsValid", &GCBreakableProp::IsValid)
        .endClass();
}
GCEnvSoundscapeProxy::GCEnvSoundscapeProxy(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCEnvSoundscapeProxy::GCEnvSoundscapeProxy(void *ptr) {
    m_ptr = ptr;
}
std::string GCEnvSoundscapeProxy::GetMainSoundscapeName() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CEnvSoundscapeProxy", "m_MainSoundscapeName").String();
}
void GCEnvSoundscapeProxy::SetMainSoundscapeName(std::string value) {
    SetSchemaValue(m_ptr, "CEnvSoundscapeProxy", "m_MainSoundscapeName", false, CUtlSymbolLarge(value.c_str()));
}
std::string GCEnvSoundscapeProxy::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCEnvSoundscapeProxy::IsValid() {
    return (m_ptr != nullptr);
}
GCEnvSoundscape GCEnvSoundscapeProxy::GetParent() const {
    GCEnvSoundscape value(m_ptr);
    return value;
}
void GCEnvSoundscapeProxy::SetParent(GCEnvSoundscape value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCEnvSoundscapeProxy(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCEnvSoundscapeProxy>("CEnvSoundscapeProxy")
        .addConstructor<void (*)(std::string)>()
        .addProperty("MainSoundscapeName", &GCEnvSoundscapeProxy::GetMainSoundscapeName, &GCEnvSoundscapeProxy::SetMainSoundscapeName)
        .addProperty("Parent", &GCEnvSoundscapeProxy::GetParent, &GCEnvSoundscapeProxy::SetParent)
        .addFunction("ToPtr", &GCEnvSoundscapeProxy::ToPtr)
        .addFunction("IsValid", &GCEnvSoundscapeProxy::IsValid)
        .endClass();
}
GCPhysConstraint::GCPhysConstraint(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCPhysConstraint::GCPhysConstraint(void *ptr) {
    m_ptr = ptr;
}
std::string GCPhysConstraint::GetNameAttach1() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CPhysConstraint", "m_nameAttach1").String();
}
void GCPhysConstraint::SetNameAttach1(std::string value) {
    SetSchemaValue(m_ptr, "CPhysConstraint", "m_nameAttach1", false, CUtlSymbolLarge(value.c_str()));
}
std::string GCPhysConstraint::GetNameAttach2() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CPhysConstraint", "m_nameAttach2").String();
}
void GCPhysConstraint::SetNameAttach2(std::string value) {
    SetSchemaValue(m_ptr, "CPhysConstraint", "m_nameAttach2", false, CUtlSymbolLarge(value.c_str()));
}
GCBaseEntity GCPhysConstraint::GetAttach1() const {
    GCBaseEntity value(*GetSchemaValuePtr<void*>(m_ptr, "CPhysConstraint", "m_hAttach1"));
    return value;
}
void GCPhysConstraint::SetAttach1(GCBaseEntity* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Attach1' is not possible.\n");
}
GCBaseEntity GCPhysConstraint::GetAttach2() const {
    GCBaseEntity value(*GetSchemaValuePtr<void*>(m_ptr, "CPhysConstraint", "m_hAttach2"));
    return value;
}
void GCPhysConstraint::SetAttach2(GCBaseEntity* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Attach2' is not possible.\n");
}
std::string GCPhysConstraint::GetNameAttachment1() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CPhysConstraint", "m_nameAttachment1").String();
}
void GCPhysConstraint::SetNameAttachment1(std::string value) {
    SetSchemaValue(m_ptr, "CPhysConstraint", "m_nameAttachment1", false, CUtlSymbolLarge(value.c_str()));
}
std::string GCPhysConstraint::GetNameAttachment2() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CPhysConstraint", "m_nameAttachment2").String();
}
void GCPhysConstraint::SetNameAttachment2(std::string value) {
    SetSchemaValue(m_ptr, "CPhysConstraint", "m_nameAttachment2", false, CUtlSymbolLarge(value.c_str()));
}
std::string GCPhysConstraint::GetBreakSound() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CPhysConstraint", "m_breakSound").String();
}
void GCPhysConstraint::SetBreakSound(std::string value) {
    SetSchemaValue(m_ptr, "CPhysConstraint", "m_breakSound", false, CUtlSymbolLarge(value.c_str()));
}
float GCPhysConstraint::GetForceLimit() const {
    return GetSchemaValue<float>(m_ptr, "CPhysConstraint", "m_forceLimit");
}
void GCPhysConstraint::SetForceLimit(float value) {
    SetSchemaValue(m_ptr, "CPhysConstraint", "m_forceLimit", false, value);
}
float GCPhysConstraint::GetTorqueLimit() const {
    return GetSchemaValue<float>(m_ptr, "CPhysConstraint", "m_torqueLimit");
}
void GCPhysConstraint::SetTorqueLimit(float value) {
    SetSchemaValue(m_ptr, "CPhysConstraint", "m_torqueLimit", false, value);
}
uint32_t GCPhysConstraint::GetTeleportTick() const {
    return GetSchemaValue<uint32_t>(m_ptr, "CPhysConstraint", "m_teleportTick");
}
void GCPhysConstraint::SetTeleportTick(uint32_t value) {
    SetSchemaValue(m_ptr, "CPhysConstraint", "m_teleportTick", false, value);
}
float GCPhysConstraint::GetMinTeleportDistance() const {
    return GetSchemaValue<float>(m_ptr, "CPhysConstraint", "m_minTeleportDistance");
}
void GCPhysConstraint::SetMinTeleportDistance(float value) {
    SetSchemaValue(m_ptr, "CPhysConstraint", "m_minTeleportDistance", false, value);
}
bool GCPhysConstraint::GetSnapObjectPositions() const {
    return GetSchemaValue<bool>(m_ptr, "CPhysConstraint", "m_bSnapObjectPositions");
}
void GCPhysConstraint::SetSnapObjectPositions(bool value) {
    SetSchemaValue(m_ptr, "CPhysConstraint", "m_bSnapObjectPositions", false, value);
}
GCEntityIOOutput GCPhysConstraint::GetOnBreak() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CPhysConstraint", "m_OnBreak"));
    return value;
}
void GCPhysConstraint::SetOnBreak(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CPhysConstraint", "m_OnBreak", false, value);
}
std::string GCPhysConstraint::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCPhysConstraint::IsValid() {
    return (m_ptr != nullptr);
}
GCLogicalEntity GCPhysConstraint::GetParent() const {
    GCLogicalEntity value(m_ptr);
    return value;
}
void GCPhysConstraint::SetParent(GCLogicalEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCPhysConstraint(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCPhysConstraint>("CPhysConstraint")
        .addConstructor<void (*)(std::string)>()
        .addProperty("NameAttach1", &GCPhysConstraint::GetNameAttach1, &GCPhysConstraint::SetNameAttach1)
        .addProperty("NameAttach2", &GCPhysConstraint::GetNameAttach2, &GCPhysConstraint::SetNameAttach2)
        .addProperty("Attach1", &GCPhysConstraint::GetAttach1, &GCPhysConstraint::SetAttach1)
        .addProperty("Attach2", &GCPhysConstraint::GetAttach2, &GCPhysConstraint::SetAttach2)
        .addProperty("NameAttachment1", &GCPhysConstraint::GetNameAttachment1, &GCPhysConstraint::SetNameAttachment1)
        .addProperty("NameAttachment2", &GCPhysConstraint::GetNameAttachment2, &GCPhysConstraint::SetNameAttachment2)
        .addProperty("BreakSound", &GCPhysConstraint::GetBreakSound, &GCPhysConstraint::SetBreakSound)
        .addProperty("ForceLimit", &GCPhysConstraint::GetForceLimit, &GCPhysConstraint::SetForceLimit)
        .addProperty("TorqueLimit", &GCPhysConstraint::GetTorqueLimit, &GCPhysConstraint::SetTorqueLimit)
        .addProperty("TeleportTick", &GCPhysConstraint::GetTeleportTick, &GCPhysConstraint::SetTeleportTick)
        .addProperty("MinTeleportDistance", &GCPhysConstraint::GetMinTeleportDistance, &GCPhysConstraint::SetMinTeleportDistance)
        .addProperty("SnapObjectPositions", &GCPhysConstraint::GetSnapObjectPositions, &GCPhysConstraint::SetSnapObjectPositions)
        .addProperty("OnBreak", &GCPhysConstraint::GetOnBreak, &GCPhysConstraint::SetOnBreak)
        .addProperty("Parent", &GCPhysConstraint::GetParent, &GCPhysConstraint::SetParent)
        .addFunction("ToPtr", &GCPhysConstraint::ToPtr)
        .addFunction("IsValid", &GCPhysConstraint::IsValid)
        .endClass();
}
GCCSGameModeRules::GCCSGameModeRules(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCCSGameModeRules::GCCSGameModeRules(void *ptr) {
    m_ptr = ptr;
}
GCNetworkVarChainer GCCSGameModeRules::Get__pChainEntity() const {
    GCNetworkVarChainer value(GetSchemaPtr(m_ptr, "CCSGameModeRules", "__m_pChainEntity"));
    return value;
}
void GCCSGameModeRules::Set__pChainEntity(GCNetworkVarChainer value) {
    SetSchemaValue(m_ptr, "CCSGameModeRules", "__m_pChainEntity", false, value);
}
std::string GCCSGameModeRules::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCCSGameModeRules::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCCSGameModeRules(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCCSGameModeRules>("CCSGameModeRules")
        .addConstructor<void (*)(std::string)>()
        .addProperty("__pChainEntity", &GCCSGameModeRules::Get__pChainEntity, &GCCSGameModeRules::Set__pChainEntity)
        .addFunction("ToPtr", &GCCSGameModeRules::ToPtr)
        .addFunction("IsValid", &GCCSGameModeRules::IsValid)
        .endClass();
}
GCItemAssaultSuit::GCItemAssaultSuit(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCItemAssaultSuit::GCItemAssaultSuit(void *ptr) {
    m_ptr = ptr;
}
std::string GCItemAssaultSuit::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCItemAssaultSuit::IsValid() {
    return (m_ptr != nullptr);
}
GCItem GCItemAssaultSuit::GetParent() const {
    GCItem value(m_ptr);
    return value;
}
void GCItemAssaultSuit::SetParent(GCItem value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCItemAssaultSuit(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCItemAssaultSuit>("CItemAssaultSuit")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCItemAssaultSuit::GetParent, &GCItemAssaultSuit::SetParent)
        .addFunction("ToPtr", &GCItemAssaultSuit::ToPtr)
        .addFunction("IsValid", &GCItemAssaultSuit::IsValid)
        .endClass();
}
GCInfoPlayerStart::GCInfoPlayerStart(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCInfoPlayerStart::GCInfoPlayerStart(void *ptr) {
    m_ptr = ptr;
}
bool GCInfoPlayerStart::GetDisabled() const {
    return GetSchemaValue<bool>(m_ptr, "CInfoPlayerStart", "m_bDisabled");
}
void GCInfoPlayerStart::SetDisabled(bool value) {
    SetSchemaValue(m_ptr, "CInfoPlayerStart", "m_bDisabled", false, value);
}
std::string GCInfoPlayerStart::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCInfoPlayerStart::IsValid() {
    return (m_ptr != nullptr);
}
GCPointEntity GCInfoPlayerStart::GetParent() const {
    GCPointEntity value(m_ptr);
    return value;
}
void GCInfoPlayerStart::SetParent(GCPointEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCInfoPlayerStart(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCInfoPlayerStart>("CInfoPlayerStart")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Disabled", &GCInfoPlayerStart::GetDisabled, &GCInfoPlayerStart::SetDisabled)
        .addProperty("Parent", &GCInfoPlayerStart::GetParent, &GCInfoPlayerStart::SetParent)
        .addFunction("ToPtr", &GCInfoPlayerStart::ToPtr)
        .addFunction("IsValid", &GCInfoPlayerStart::IsValid)
        .endClass();
}
GCSoundOpvarSetPointBase::GCSoundOpvarSetPointBase(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCSoundOpvarSetPointBase::GCSoundOpvarSetPointBase(void *ptr) {
    m_ptr = ptr;
}
bool GCSoundOpvarSetPointBase::GetDisabled() const {
    return GetSchemaValue<bool>(m_ptr, "CSoundOpvarSetPointBase", "m_bDisabled");
}
void GCSoundOpvarSetPointBase::SetDisabled(bool value) {
    SetSchemaValue(m_ptr, "CSoundOpvarSetPointBase", "m_bDisabled", false, value);
}
GCEntityInstance GCSoundOpvarSetPointBase::GetSource() const {
    GCEntityInstance value(*GetSchemaValuePtr<void*>(m_ptr, "CSoundOpvarSetPointBase", "m_hSource"));
    return value;
}
void GCSoundOpvarSetPointBase::SetSource(GCEntityInstance* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Source' is not possible.\n");
}
std::string GCSoundOpvarSetPointBase::GetSourceEntityName() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CSoundOpvarSetPointBase", "m_iszSourceEntityName").String();
}
void GCSoundOpvarSetPointBase::SetSourceEntityName(std::string value) {
    SetSchemaValue(m_ptr, "CSoundOpvarSetPointBase", "m_iszSourceEntityName", false, CUtlSymbolLarge(value.c_str()));
}
Vector GCSoundOpvarSetPointBase::GetLastPosition() const {
    return GetSchemaValue<Vector>(m_ptr, "CSoundOpvarSetPointBase", "m_vLastPosition");
}
void GCSoundOpvarSetPointBase::SetLastPosition(Vector value) {
    SetSchemaValue(m_ptr, "CSoundOpvarSetPointBase", "m_vLastPosition", false, value);
}
std::string GCSoundOpvarSetPointBase::GetStackName() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CSoundOpvarSetPointBase", "m_iszStackName").String();
}
void GCSoundOpvarSetPointBase::SetStackName(std::string value) {
    SetSchemaValue(m_ptr, "CSoundOpvarSetPointBase", "m_iszStackName", false, CUtlSymbolLarge(value.c_str()));
}
std::string GCSoundOpvarSetPointBase::GetOperatorName() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CSoundOpvarSetPointBase", "m_iszOperatorName").String();
}
void GCSoundOpvarSetPointBase::SetOperatorName(std::string value) {
    SetSchemaValue(m_ptr, "CSoundOpvarSetPointBase", "m_iszOperatorName", false, CUtlSymbolLarge(value.c_str()));
}
std::string GCSoundOpvarSetPointBase::GetOpvarName() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CSoundOpvarSetPointBase", "m_iszOpvarName").String();
}
void GCSoundOpvarSetPointBase::SetOpvarName(std::string value) {
    SetSchemaValue(m_ptr, "CSoundOpvarSetPointBase", "m_iszOpvarName", false, CUtlSymbolLarge(value.c_str()));
}
int32_t GCSoundOpvarSetPointBase::GetOpvarIndex() const {
    return GetSchemaValue<int32_t>(m_ptr, "CSoundOpvarSetPointBase", "m_iOpvarIndex");
}
void GCSoundOpvarSetPointBase::SetOpvarIndex(int32_t value) {
    SetSchemaValue(m_ptr, "CSoundOpvarSetPointBase", "m_iOpvarIndex", false, value);
}
bool GCSoundOpvarSetPointBase::GetUseAutoCompare() const {
    return GetSchemaValue<bool>(m_ptr, "CSoundOpvarSetPointBase", "m_bUseAutoCompare");
}
void GCSoundOpvarSetPointBase::SetUseAutoCompare(bool value) {
    SetSchemaValue(m_ptr, "CSoundOpvarSetPointBase", "m_bUseAutoCompare", false, value);
}
std::string GCSoundOpvarSetPointBase::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCSoundOpvarSetPointBase::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseEntity GCSoundOpvarSetPointBase::GetParent() const {
    GCBaseEntity value(m_ptr);
    return value;
}
void GCSoundOpvarSetPointBase::SetParent(GCBaseEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCSoundOpvarSetPointBase(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCSoundOpvarSetPointBase>("CSoundOpvarSetPointBase")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Disabled", &GCSoundOpvarSetPointBase::GetDisabled, &GCSoundOpvarSetPointBase::SetDisabled)
        .addProperty("Source", &GCSoundOpvarSetPointBase::GetSource, &GCSoundOpvarSetPointBase::SetSource)
        .addProperty("SourceEntityName", &GCSoundOpvarSetPointBase::GetSourceEntityName, &GCSoundOpvarSetPointBase::SetSourceEntityName)
        .addProperty("LastPosition", &GCSoundOpvarSetPointBase::GetLastPosition, &GCSoundOpvarSetPointBase::SetLastPosition)
        .addProperty("StackName", &GCSoundOpvarSetPointBase::GetStackName, &GCSoundOpvarSetPointBase::SetStackName)
        .addProperty("OperatorName", &GCSoundOpvarSetPointBase::GetOperatorName, &GCSoundOpvarSetPointBase::SetOperatorName)
        .addProperty("OpvarName", &GCSoundOpvarSetPointBase::GetOpvarName, &GCSoundOpvarSetPointBase::SetOpvarName)
        .addProperty("OpvarIndex", &GCSoundOpvarSetPointBase::GetOpvarIndex, &GCSoundOpvarSetPointBase::SetOpvarIndex)
        .addProperty("UseAutoCompare", &GCSoundOpvarSetPointBase::GetUseAutoCompare, &GCSoundOpvarSetPointBase::SetUseAutoCompare)
        .addProperty("Parent", &GCSoundOpvarSetPointBase::GetParent, &GCSoundOpvarSetPointBase::SetParent)
        .addFunction("ToPtr", &GCSoundOpvarSetPointBase::ToPtr)
        .addFunction("IsValid", &GCSoundOpvarSetPointBase::IsValid)
        .endClass();
}
Gragdoll_t::Gragdoll_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
Gragdoll_t::Gragdoll_t(void *ptr) {
    m_ptr = ptr;
}
std::vector<Gragdollelement_t> Gragdoll_t::GetList() const {
    CUtlVector<Gragdollelement_t>* vec = GetSchemaValue<CUtlVector<Gragdollelement_t>*>(m_ptr, "ragdoll_t", "list"); std::vector<Gragdollelement_t> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void Gragdoll_t::SetList(std::vector<Gragdollelement_t> value) {
    SetSchemaValueCUtlVector<Gragdollelement_t>(m_ptr, "ragdoll_t", "list", true, value);
}
std::vector<int32> Gragdoll_t::GetBoneIndex() const {
    CUtlVector<int32>* vec = GetSchemaValue<CUtlVector<int32>*>(m_ptr, "ragdoll_t", "boneIndex"); std::vector<int32> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void Gragdoll_t::SetBoneIndex(std::vector<int32> value) {
    SetSchemaValueCUtlVector<int32>(m_ptr, "ragdoll_t", "boneIndex", true, value);
}
bool Gragdoll_t::GetAllowStretch() const {
    return GetSchemaValue<bool>(m_ptr, "ragdoll_t", "allowStretch");
}
void Gragdoll_t::SetAllowStretch(bool value) {
    SetSchemaValue(m_ptr, "ragdoll_t", "allowStretch", true, value);
}
bool Gragdoll_t::GetUnused() const {
    return GetSchemaValue<bool>(m_ptr, "ragdoll_t", "unused");
}
void Gragdoll_t::SetUnused(bool value) {
    SetSchemaValue(m_ptr, "ragdoll_t", "unused", true, value);
}
std::string Gragdoll_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool Gragdoll_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassragdoll_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<Gragdoll_t>("ragdoll_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("List", &Gragdoll_t::GetList, &Gragdoll_t::SetList)
        .addProperty("BoneIndex", &Gragdoll_t::GetBoneIndex, &Gragdoll_t::SetBoneIndex)
        .addProperty("AllowStretch", &Gragdoll_t::GetAllowStretch, &Gragdoll_t::SetAllowStretch)
        .addProperty("Unused", &Gragdoll_t::GetUnused, &Gragdoll_t::SetUnused)
        .addFunction("ToPtr", &Gragdoll_t::ToPtr)
        .addFunction("IsValid", &Gragdoll_t::IsValid)
        .endClass();
}
GCItemDogtags::GCItemDogtags(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCItemDogtags::GCItemDogtags(void *ptr) {
    m_ptr = ptr;
}
GCCSPlayerPawn GCItemDogtags::GetOwningPlayer() const {
    GCCSPlayerPawn value(*GetSchemaValuePtr<void*>(m_ptr, "CItemDogtags", "m_OwningPlayer"));
    return value;
}
void GCItemDogtags::SetOwningPlayer(GCCSPlayerPawn* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'OwningPlayer' is not possible.\n");
}
GCCSPlayerPawn GCItemDogtags::GetKillingPlayer() const {
    GCCSPlayerPawn value(*GetSchemaValuePtr<void*>(m_ptr, "CItemDogtags", "m_KillingPlayer"));
    return value;
}
void GCItemDogtags::SetKillingPlayer(GCCSPlayerPawn* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'KillingPlayer' is not possible.\n");
}
std::string GCItemDogtags::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCItemDogtags::IsValid() {
    return (m_ptr != nullptr);
}
GCItem GCItemDogtags::GetParent() const {
    GCItem value(m_ptr);
    return value;
}
void GCItemDogtags::SetParent(GCItem value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCItemDogtags(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCItemDogtags>("CItemDogtags")
        .addConstructor<void (*)(std::string)>()
        .addProperty("OwningPlayer", &GCItemDogtags::GetOwningPlayer, &GCItemDogtags::SetOwningPlayer)
        .addProperty("KillingPlayer", &GCItemDogtags::GetKillingPlayer, &GCItemDogtags::SetKillingPlayer)
        .addProperty("Parent", &GCItemDogtags::GetParent, &GCItemDogtags::SetParent)
        .addFunction("ToPtr", &GCItemDogtags::ToPtr)
        .addFunction("IsValid", &GCItemDogtags::IsValid)
        .endClass();
}
GCLightEntity::GCLightEntity(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCLightEntity::GCLightEntity(void *ptr) {
    m_ptr = ptr;
}
GCLightComponent GCLightEntity::GetCLightComponent() const {
    GCLightComponent value(*GetSchemaValuePtr<void*>(m_ptr, "CLightEntity", "m_CLightComponent"));
    return value;
}
void GCLightEntity::SetCLightComponent(GCLightComponent* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'CLightComponent' is not possible.\n");
}
std::string GCLightEntity::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCLightEntity::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseModelEntity GCLightEntity::GetParent() const {
    GCBaseModelEntity value(m_ptr);
    return value;
}
void GCLightEntity::SetParent(GCBaseModelEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCLightEntity(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCLightEntity>("CLightEntity")
        .addConstructor<void (*)(std::string)>()
        .addProperty("CLightComponent", &GCLightEntity::GetCLightComponent, &GCLightEntity::SetCLightComponent)
        .addProperty("Parent", &GCLightEntity::GetParent, &GCLightEntity::SetParent)
        .addFunction("ToPtr", &GCLightEntity::ToPtr)
        .addFunction("IsValid", &GCLightEntity::IsValid)
        .endClass();
}
GCPlayer_WaterServices::GCPlayer_WaterServices(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCPlayer_WaterServices::GCPlayer_WaterServices(void *ptr) {
    m_ptr = ptr;
}
std::string GCPlayer_WaterServices::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCPlayer_WaterServices::IsValid() {
    return (m_ptr != nullptr);
}
GCPlayerPawnComponent GCPlayer_WaterServices::GetParent() const {
    GCPlayerPawnComponent value(m_ptr);
    return value;
}
void GCPlayer_WaterServices::SetParent(GCPlayerPawnComponent value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCPlayer_WaterServices(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCPlayer_WaterServices>("CPlayer_WaterServices")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCPlayer_WaterServices::GetParent, &GCPlayer_WaterServices::SetParent)
        .addFunction("ToPtr", &GCPlayer_WaterServices::ToPtr)
        .addFunction("IsValid", &GCPlayer_WaterServices::IsValid)
        .endClass();
}
GCSkyboxReference::GCSkyboxReference(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCSkyboxReference::GCSkyboxReference(void *ptr) {
    m_ptr = ptr;
}
WorldGroupId_t GCSkyboxReference::GetWorldGroupId() const {
    return GetSchemaValue<WorldGroupId_t>(m_ptr, "CSkyboxReference", "m_worldGroupId");
}
void GCSkyboxReference::SetWorldGroupId(WorldGroupId_t value) {
    SetSchemaValue(m_ptr, "CSkyboxReference", "m_worldGroupId", false, value);
}
GCSkyCamera GCSkyboxReference::GetSkyCamera() const {
    GCSkyCamera value(*GetSchemaValuePtr<void*>(m_ptr, "CSkyboxReference", "m_hSkyCamera"));
    return value;
}
void GCSkyboxReference::SetSkyCamera(GCSkyCamera* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'SkyCamera' is not possible.\n");
}
std::string GCSkyboxReference::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCSkyboxReference::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseEntity GCSkyboxReference::GetParent() const {
    GCBaseEntity value(m_ptr);
    return value;
}
void GCSkyboxReference::SetParent(GCBaseEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCSkyboxReference(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCSkyboxReference>("CSkyboxReference")
        .addConstructor<void (*)(std::string)>()
        .addProperty("WorldGroupId", &GCSkyboxReference::GetWorldGroupId, &GCSkyboxReference::SetWorldGroupId)
        .addProperty("SkyCamera", &GCSkyboxReference::GetSkyCamera, &GCSkyboxReference::SetSkyCamera)
        .addProperty("Parent", &GCSkyboxReference::GetParent, &GCSkyboxReference::SetParent)
        .addFunction("ToPtr", &GCSkyboxReference::ToPtr)
        .addFunction("IsValid", &GCSkyboxReference::IsValid)
        .endClass();
}
GCDynamicProp::GCDynamicProp(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCDynamicProp::GCDynamicProp(void *ptr) {
    m_ptr = ptr;
}
bool GCDynamicProp::GetCreateNavObstacle() const {
    return GetSchemaValue<bool>(m_ptr, "CDynamicProp", "m_bCreateNavObstacle");
}
void GCDynamicProp::SetCreateNavObstacle(bool value) {
    SetSchemaValue(m_ptr, "CDynamicProp", "m_bCreateNavObstacle", false, value);
}
bool GCDynamicProp::GetUseHitboxesForRenderBox() const {
    return GetSchemaValue<bool>(m_ptr, "CDynamicProp", "m_bUseHitboxesForRenderBox");
}
void GCDynamicProp::SetUseHitboxesForRenderBox(bool value) {
    SetSchemaValue(m_ptr, "CDynamicProp", "m_bUseHitboxesForRenderBox", false, value);
}
bool GCDynamicProp::GetUseAnimGraph() const {
    return GetSchemaValue<bool>(m_ptr, "CDynamicProp", "m_bUseAnimGraph");
}
void GCDynamicProp::SetUseAnimGraph(bool value) {
    SetSchemaValue(m_ptr, "CDynamicProp", "m_bUseAnimGraph", false, value);
}
GCEntityIOOutput GCDynamicProp::GetOutputAnimBegun() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CDynamicProp", "m_pOutputAnimBegun"));
    return value;
}
void GCDynamicProp::SetOutputAnimBegun(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CDynamicProp", "m_pOutputAnimBegun", false, value);
}
GCEntityIOOutput GCDynamicProp::GetOutputAnimOver() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CDynamicProp", "m_pOutputAnimOver"));
    return value;
}
void GCDynamicProp::SetOutputAnimOver(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CDynamicProp", "m_pOutputAnimOver", false, value);
}
GCEntityIOOutput GCDynamicProp::GetOutputAnimLoopCycleOver() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CDynamicProp", "m_pOutputAnimLoopCycleOver"));
    return value;
}
void GCDynamicProp::SetOutputAnimLoopCycleOver(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CDynamicProp", "m_pOutputAnimLoopCycleOver", false, value);
}
GCEntityIOOutput GCDynamicProp::GetOnAnimReachedStart() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CDynamicProp", "m_OnAnimReachedStart"));
    return value;
}
void GCDynamicProp::SetOnAnimReachedStart(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CDynamicProp", "m_OnAnimReachedStart", false, value);
}
GCEntityIOOutput GCDynamicProp::GetOnAnimReachedEnd() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CDynamicProp", "m_OnAnimReachedEnd"));
    return value;
}
void GCDynamicProp::SetOnAnimReachedEnd(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CDynamicProp", "m_OnAnimReachedEnd", false, value);
}
std::string GCDynamicProp::GetIdleAnim() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CDynamicProp", "m_iszIdleAnim").String();
}
void GCDynamicProp::SetIdleAnim(std::string value) {
    SetSchemaValue(m_ptr, "CDynamicProp", "m_iszIdleAnim", false, CUtlSymbolLarge(value.c_str()));
}
uint64_t GCDynamicProp::GetIdleAnimLoopMode() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CDynamicProp", "m_nIdleAnimLoopMode");
}
void GCDynamicProp::SetIdleAnimLoopMode(uint64_t value) {
    SetSchemaValue(m_ptr, "CDynamicProp", "m_nIdleAnimLoopMode", false, value);
}
bool GCDynamicProp::GetRandomizeCycle() const {
    return GetSchemaValue<bool>(m_ptr, "CDynamicProp", "m_bRandomizeCycle");
}
void GCDynamicProp::SetRandomizeCycle(bool value) {
    SetSchemaValue(m_ptr, "CDynamicProp", "m_bRandomizeCycle", false, value);
}
bool GCDynamicProp::GetStartDisabled() const {
    return GetSchemaValue<bool>(m_ptr, "CDynamicProp", "m_bStartDisabled");
}
void GCDynamicProp::SetStartDisabled(bool value) {
    SetSchemaValue(m_ptr, "CDynamicProp", "m_bStartDisabled", false, value);
}
bool GCDynamicProp::GetFiredStartEndOutput() const {
    return GetSchemaValue<bool>(m_ptr, "CDynamicProp", "m_bFiredStartEndOutput");
}
void GCDynamicProp::SetFiredStartEndOutput(bool value) {
    SetSchemaValue(m_ptr, "CDynamicProp", "m_bFiredStartEndOutput", false, value);
}
bool GCDynamicProp::GetForceNpcExclude() const {
    return GetSchemaValue<bool>(m_ptr, "CDynamicProp", "m_bForceNpcExclude");
}
void GCDynamicProp::SetForceNpcExclude(bool value) {
    SetSchemaValue(m_ptr, "CDynamicProp", "m_bForceNpcExclude", false, value);
}
bool GCDynamicProp::GetCreateNonSolid() const {
    return GetSchemaValue<bool>(m_ptr, "CDynamicProp", "m_bCreateNonSolid");
}
void GCDynamicProp::SetCreateNonSolid(bool value) {
    SetSchemaValue(m_ptr, "CDynamicProp", "m_bCreateNonSolid", false, value);
}
bool GCDynamicProp::GetIsOverrideProp() const {
    return GetSchemaValue<bool>(m_ptr, "CDynamicProp", "m_bIsOverrideProp");
}
void GCDynamicProp::SetIsOverrideProp(bool value) {
    SetSchemaValue(m_ptr, "CDynamicProp", "m_bIsOverrideProp", false, value);
}
int32_t GCDynamicProp::GetInitialGlowState() const {
    return GetSchemaValue<int32_t>(m_ptr, "CDynamicProp", "m_iInitialGlowState");
}
void GCDynamicProp::SetInitialGlowState(int32_t value) {
    SetSchemaValue(m_ptr, "CDynamicProp", "m_iInitialGlowState", false, value);
}
int32_t GCDynamicProp::GetGlowRange() const {
    return GetSchemaValue<int32_t>(m_ptr, "CDynamicProp", "m_nGlowRange");
}
void GCDynamicProp::SetGlowRange(int32_t value) {
    SetSchemaValue(m_ptr, "CDynamicProp", "m_nGlowRange", false, value);
}
int32_t GCDynamicProp::GetGlowRangeMin() const {
    return GetSchemaValue<int32_t>(m_ptr, "CDynamicProp", "m_nGlowRangeMin");
}
void GCDynamicProp::SetGlowRangeMin(int32_t value) {
    SetSchemaValue(m_ptr, "CDynamicProp", "m_nGlowRangeMin", false, value);
}
Color GCDynamicProp::GetGlowColor() const {
    return GetSchemaValue<Color>(m_ptr, "CDynamicProp", "m_glowColor");
}
void GCDynamicProp::SetGlowColor(Color value) {
    SetSchemaValue(m_ptr, "CDynamicProp", "m_glowColor", false, value);
}
int32_t GCDynamicProp::GetGlowTeam() const {
    return GetSchemaValue<int32_t>(m_ptr, "CDynamicProp", "m_nGlowTeam");
}
void GCDynamicProp::SetGlowTeam(int32_t value) {
    SetSchemaValue(m_ptr, "CDynamicProp", "m_nGlowTeam", false, value);
}
std::string GCDynamicProp::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCDynamicProp::IsValid() {
    return (m_ptr != nullptr);
}
GCBreakableProp GCDynamicProp::GetParent() const {
    GCBreakableProp value(m_ptr);
    return value;
}
void GCDynamicProp::SetParent(GCBreakableProp value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCDynamicProp(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCDynamicProp>("CDynamicProp")
        .addConstructor<void (*)(std::string)>()
        .addProperty("CreateNavObstacle", &GCDynamicProp::GetCreateNavObstacle, &GCDynamicProp::SetCreateNavObstacle)
        .addProperty("UseHitboxesForRenderBox", &GCDynamicProp::GetUseHitboxesForRenderBox, &GCDynamicProp::SetUseHitboxesForRenderBox)
        .addProperty("UseAnimGraph", &GCDynamicProp::GetUseAnimGraph, &GCDynamicProp::SetUseAnimGraph)
        .addProperty("OutputAnimBegun", &GCDynamicProp::GetOutputAnimBegun, &GCDynamicProp::SetOutputAnimBegun)
        .addProperty("OutputAnimOver", &GCDynamicProp::GetOutputAnimOver, &GCDynamicProp::SetOutputAnimOver)
        .addProperty("OutputAnimLoopCycleOver", &GCDynamicProp::GetOutputAnimLoopCycleOver, &GCDynamicProp::SetOutputAnimLoopCycleOver)
        .addProperty("OnAnimReachedStart", &GCDynamicProp::GetOnAnimReachedStart, &GCDynamicProp::SetOnAnimReachedStart)
        .addProperty("OnAnimReachedEnd", &GCDynamicProp::GetOnAnimReachedEnd, &GCDynamicProp::SetOnAnimReachedEnd)
        .addProperty("IdleAnim", &GCDynamicProp::GetIdleAnim, &GCDynamicProp::SetIdleAnim)
        .addProperty("IdleAnimLoopMode", &GCDynamicProp::GetIdleAnimLoopMode, &GCDynamicProp::SetIdleAnimLoopMode)
        .addProperty("RandomizeCycle", &GCDynamicProp::GetRandomizeCycle, &GCDynamicProp::SetRandomizeCycle)
        .addProperty("StartDisabled", &GCDynamicProp::GetStartDisabled, &GCDynamicProp::SetStartDisabled)
        .addProperty("FiredStartEndOutput", &GCDynamicProp::GetFiredStartEndOutput, &GCDynamicProp::SetFiredStartEndOutput)
        .addProperty("ForceNpcExclude", &GCDynamicProp::GetForceNpcExclude, &GCDynamicProp::SetForceNpcExclude)
        .addProperty("CreateNonSolid", &GCDynamicProp::GetCreateNonSolid, &GCDynamicProp::SetCreateNonSolid)
        .addProperty("IsOverrideProp", &GCDynamicProp::GetIsOverrideProp, &GCDynamicProp::SetIsOverrideProp)
        .addProperty("InitialGlowState", &GCDynamicProp::GetInitialGlowState, &GCDynamicProp::SetInitialGlowState)
        .addProperty("GlowRange", &GCDynamicProp::GetGlowRange, &GCDynamicProp::SetGlowRange)
        .addProperty("GlowRangeMin", &GCDynamicProp::GetGlowRangeMin, &GCDynamicProp::SetGlowRangeMin)
        .addProperty("GlowColor", &GCDynamicProp::GetGlowColor, &GCDynamicProp::SetGlowColor)
        .addProperty("GlowTeam", &GCDynamicProp::GetGlowTeam, &GCDynamicProp::SetGlowTeam)
        .addProperty("Parent", &GCDynamicProp::GetParent, &GCDynamicProp::SetParent)
        .addFunction("ToPtr", &GCDynamicProp::ToPtr)
        .addFunction("IsValid", &GCDynamicProp::IsValid)
        .endClass();
}
GCRopeKeyframe::GCRopeKeyframe(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCRopeKeyframe::GCRopeKeyframe(void *ptr) {
    m_ptr = ptr;
}
uint16_t GCRopeKeyframe::GetRopeFlags() const {
    return GetSchemaValue<uint16_t>(m_ptr, "CRopeKeyframe", "m_RopeFlags");
}
void GCRopeKeyframe::SetRopeFlags(uint16_t value) {
    SetSchemaValue(m_ptr, "CRopeKeyframe", "m_RopeFlags", false, value);
}
std::string GCRopeKeyframe::GetNextLinkName() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CRopeKeyframe", "m_iNextLinkName").String();
}
void GCRopeKeyframe::SetNextLinkName(std::string value) {
    SetSchemaValue(m_ptr, "CRopeKeyframe", "m_iNextLinkName", false, CUtlSymbolLarge(value.c_str()));
}
int16_t GCRopeKeyframe::GetSlack() const {
    return GetSchemaValue<int16_t>(m_ptr, "CRopeKeyframe", "m_Slack");
}
void GCRopeKeyframe::SetSlack(int16_t value) {
    SetSchemaValue(m_ptr, "CRopeKeyframe", "m_Slack", false, value);
}
float GCRopeKeyframe::GetWidth() const {
    return GetSchemaValue<float>(m_ptr, "CRopeKeyframe", "m_Width");
}
void GCRopeKeyframe::SetWidth(float value) {
    SetSchemaValue(m_ptr, "CRopeKeyframe", "m_Width", false, value);
}
float GCRopeKeyframe::GetTextureScale() const {
    return GetSchemaValue<float>(m_ptr, "CRopeKeyframe", "m_TextureScale");
}
void GCRopeKeyframe::SetTextureScale(float value) {
    SetSchemaValue(m_ptr, "CRopeKeyframe", "m_TextureScale", false, value);
}
uint8_t GCRopeKeyframe::GetSegments() const {
    return GetSchemaValue<uint8_t>(m_ptr, "CRopeKeyframe", "m_nSegments");
}
void GCRopeKeyframe::SetSegments(uint8_t value) {
    SetSchemaValue(m_ptr, "CRopeKeyframe", "m_nSegments", false, value);
}
bool GCRopeKeyframe::GetConstrainBetweenEndpoints() const {
    return GetSchemaValue<bool>(m_ptr, "CRopeKeyframe", "m_bConstrainBetweenEndpoints");
}
void GCRopeKeyframe::SetConstrainBetweenEndpoints(bool value) {
    SetSchemaValue(m_ptr, "CRopeKeyframe", "m_bConstrainBetweenEndpoints", false, value);
}
std::string GCRopeKeyframe::GetStrRopeMaterialModel() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CRopeKeyframe", "m_strRopeMaterialModel").String();
}
void GCRopeKeyframe::SetStrRopeMaterialModel(std::string value) {
    SetSchemaValue(m_ptr, "CRopeKeyframe", "m_strRopeMaterialModel", false, CUtlSymbolLarge(value.c_str()));
}
uint8_t GCRopeKeyframe::GetSubdiv() const {
    return GetSchemaValue<uint8_t>(m_ptr, "CRopeKeyframe", "m_Subdiv");
}
void GCRopeKeyframe::SetSubdiv(uint8_t value) {
    SetSchemaValue(m_ptr, "CRopeKeyframe", "m_Subdiv", false, value);
}
uint8_t GCRopeKeyframe::GetChangeCount() const {
    return GetSchemaValue<uint8_t>(m_ptr, "CRopeKeyframe", "m_nChangeCount");
}
void GCRopeKeyframe::SetChangeCount(uint8_t value) {
    SetSchemaValue(m_ptr, "CRopeKeyframe", "m_nChangeCount", false, value);
}
int16_t GCRopeKeyframe::GetRopeLength() const {
    return GetSchemaValue<int16_t>(m_ptr, "CRopeKeyframe", "m_RopeLength");
}
void GCRopeKeyframe::SetRopeLength(int16_t value) {
    SetSchemaValue(m_ptr, "CRopeKeyframe", "m_RopeLength", false, value);
}
uint8_t GCRopeKeyframe::GetLockedPoints() const {
    return GetSchemaValue<uint8_t>(m_ptr, "CRopeKeyframe", "m_fLockedPoints");
}
void GCRopeKeyframe::SetLockedPoints(uint8_t value) {
    SetSchemaValue(m_ptr, "CRopeKeyframe", "m_fLockedPoints", false, value);
}
bool GCRopeKeyframe::GetCreatedFromMapFile() const {
    return GetSchemaValue<bool>(m_ptr, "CRopeKeyframe", "m_bCreatedFromMapFile");
}
void GCRopeKeyframe::SetCreatedFromMapFile(bool value) {
    SetSchemaValue(m_ptr, "CRopeKeyframe", "m_bCreatedFromMapFile", false, value);
}
float GCRopeKeyframe::GetScrollSpeed() const {
    return GetSchemaValue<float>(m_ptr, "CRopeKeyframe", "m_flScrollSpeed");
}
void GCRopeKeyframe::SetScrollSpeed(float value) {
    SetSchemaValue(m_ptr, "CRopeKeyframe", "m_flScrollSpeed", false, value);
}
bool GCRopeKeyframe::GetStartPointValid() const {
    return GetSchemaValue<bool>(m_ptr, "CRopeKeyframe", "m_bStartPointValid");
}
void GCRopeKeyframe::SetStartPointValid(bool value) {
    SetSchemaValue(m_ptr, "CRopeKeyframe", "m_bStartPointValid", false, value);
}
bool GCRopeKeyframe::GetEndPointValid() const {
    return GetSchemaValue<bool>(m_ptr, "CRopeKeyframe", "m_bEndPointValid");
}
void GCRopeKeyframe::SetEndPointValid(bool value) {
    SetSchemaValue(m_ptr, "CRopeKeyframe", "m_bEndPointValid", false, value);
}
GCBaseEntity GCRopeKeyframe::GetStartPoint() const {
    GCBaseEntity value(*GetSchemaValuePtr<void*>(m_ptr, "CRopeKeyframe", "m_hStartPoint"));
    return value;
}
void GCRopeKeyframe::SetStartPoint(GCBaseEntity* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'StartPoint' is not possible.\n");
}
GCBaseEntity GCRopeKeyframe::GetEndPoint() const {
    GCBaseEntity value(*GetSchemaValuePtr<void*>(m_ptr, "CRopeKeyframe", "m_hEndPoint"));
    return value;
}
void GCRopeKeyframe::SetEndPoint(GCBaseEntity* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'EndPoint' is not possible.\n");
}
std::string GCRopeKeyframe::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCRopeKeyframe::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseModelEntity GCRopeKeyframe::GetParent() const {
    GCBaseModelEntity value(m_ptr);
    return value;
}
void GCRopeKeyframe::SetParent(GCBaseModelEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCRopeKeyframe(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCRopeKeyframe>("CRopeKeyframe")
        .addConstructor<void (*)(std::string)>()
        .addProperty("RopeFlags", &GCRopeKeyframe::GetRopeFlags, &GCRopeKeyframe::SetRopeFlags)
        .addProperty("NextLinkName", &GCRopeKeyframe::GetNextLinkName, &GCRopeKeyframe::SetNextLinkName)
        .addProperty("Slack", &GCRopeKeyframe::GetSlack, &GCRopeKeyframe::SetSlack)
        .addProperty("Width", &GCRopeKeyframe::GetWidth, &GCRopeKeyframe::SetWidth)
        .addProperty("TextureScale", &GCRopeKeyframe::GetTextureScale, &GCRopeKeyframe::SetTextureScale)
        .addProperty("Segments", &GCRopeKeyframe::GetSegments, &GCRopeKeyframe::SetSegments)
        .addProperty("ConstrainBetweenEndpoints", &GCRopeKeyframe::GetConstrainBetweenEndpoints, &GCRopeKeyframe::SetConstrainBetweenEndpoints)
        .addProperty("StrRopeMaterialModel", &GCRopeKeyframe::GetStrRopeMaterialModel, &GCRopeKeyframe::SetStrRopeMaterialModel)
        .addProperty("Subdiv", &GCRopeKeyframe::GetSubdiv, &GCRopeKeyframe::SetSubdiv)
        .addProperty("ChangeCount", &GCRopeKeyframe::GetChangeCount, &GCRopeKeyframe::SetChangeCount)
        .addProperty("RopeLength", &GCRopeKeyframe::GetRopeLength, &GCRopeKeyframe::SetRopeLength)
        .addProperty("LockedPoints", &GCRopeKeyframe::GetLockedPoints, &GCRopeKeyframe::SetLockedPoints)
        .addProperty("CreatedFromMapFile", &GCRopeKeyframe::GetCreatedFromMapFile, &GCRopeKeyframe::SetCreatedFromMapFile)
        .addProperty("ScrollSpeed", &GCRopeKeyframe::GetScrollSpeed, &GCRopeKeyframe::SetScrollSpeed)
        .addProperty("StartPointValid", &GCRopeKeyframe::GetStartPointValid, &GCRopeKeyframe::SetStartPointValid)
        .addProperty("EndPointValid", &GCRopeKeyframe::GetEndPointValid, &GCRopeKeyframe::SetEndPointValid)
        .addProperty("StartPoint", &GCRopeKeyframe::GetStartPoint, &GCRopeKeyframe::SetStartPoint)
        .addProperty("EndPoint", &GCRopeKeyframe::GetEndPoint, &GCRopeKeyframe::SetEndPoint)
        .addProperty("Parent", &GCRopeKeyframe::GetParent, &GCRopeKeyframe::SetParent)
        .addFunction("ToPtr", &GCRopeKeyframe::ToPtr)
        .addFunction("IsValid", &GCRopeKeyframe::IsValid)
        .endClass();
}
GCBarnLight::GCBarnLight(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCBarnLight::GCBarnLight(void *ptr) {
    m_ptr = ptr;
}
bool GCBarnLight::GetEnabled() const {
    return GetSchemaValue<bool>(m_ptr, "CBarnLight", "m_bEnabled");
}
void GCBarnLight::SetEnabled(bool value) {
    SetSchemaValue(m_ptr, "CBarnLight", "m_bEnabled", false, value);
}
int32_t GCBarnLight::GetColorMode() const {
    return GetSchemaValue<int32_t>(m_ptr, "CBarnLight", "m_nColorMode");
}
void GCBarnLight::SetColorMode(int32_t value) {
    SetSchemaValue(m_ptr, "CBarnLight", "m_nColorMode", false, value);
}
Color GCBarnLight::GetColor() const {
    return GetSchemaValue<Color>(m_ptr, "CBarnLight", "m_Color");
}
void GCBarnLight::SetColor(Color value) {
    SetSchemaValue(m_ptr, "CBarnLight", "m_Color", false, value);
}
float GCBarnLight::GetColorTemperature() const {
    return GetSchemaValue<float>(m_ptr, "CBarnLight", "m_flColorTemperature");
}
void GCBarnLight::SetColorTemperature(float value) {
    SetSchemaValue(m_ptr, "CBarnLight", "m_flColorTemperature", false, value);
}
float GCBarnLight::GetBrightness() const {
    return GetSchemaValue<float>(m_ptr, "CBarnLight", "m_flBrightness");
}
void GCBarnLight::SetBrightness(float value) {
    SetSchemaValue(m_ptr, "CBarnLight", "m_flBrightness", false, value);
}
float GCBarnLight::GetBrightnessScale() const {
    return GetSchemaValue<float>(m_ptr, "CBarnLight", "m_flBrightnessScale");
}
void GCBarnLight::SetBrightnessScale(float value) {
    SetSchemaValue(m_ptr, "CBarnLight", "m_flBrightnessScale", false, value);
}
int32_t GCBarnLight::GetDirectLight() const {
    return GetSchemaValue<int32_t>(m_ptr, "CBarnLight", "m_nDirectLight");
}
void GCBarnLight::SetDirectLight(int32_t value) {
    SetSchemaValue(m_ptr, "CBarnLight", "m_nDirectLight", false, value);
}
int32_t GCBarnLight::GetBakedShadowIndex() const {
    return GetSchemaValue<int32_t>(m_ptr, "CBarnLight", "m_nBakedShadowIndex");
}
void GCBarnLight::SetBakedShadowIndex(int32_t value) {
    SetSchemaValue(m_ptr, "CBarnLight", "m_nBakedShadowIndex", false, value);
}
int32_t GCBarnLight::GetLuminaireShape() const {
    return GetSchemaValue<int32_t>(m_ptr, "CBarnLight", "m_nLuminaireShape");
}
void GCBarnLight::SetLuminaireShape(int32_t value) {
    SetSchemaValue(m_ptr, "CBarnLight", "m_nLuminaireShape", false, value);
}
float GCBarnLight::GetLuminaireSize() const {
    return GetSchemaValue<float>(m_ptr, "CBarnLight", "m_flLuminaireSize");
}
void GCBarnLight::SetLuminaireSize(float value) {
    SetSchemaValue(m_ptr, "CBarnLight", "m_flLuminaireSize", false, value);
}
float GCBarnLight::GetLuminaireAnisotropy() const {
    return GetSchemaValue<float>(m_ptr, "CBarnLight", "m_flLuminaireAnisotropy");
}
void GCBarnLight::SetLuminaireAnisotropy(float value) {
    SetSchemaValue(m_ptr, "CBarnLight", "m_flLuminaireAnisotropy", false, value);
}
std::string GCBarnLight::GetLightStyleString() const {
    return GetSchemaValue<CUtlString>(m_ptr, "CBarnLight", "m_LightStyleString").Get();
}
void GCBarnLight::SetLightStyleString(std::string value) {
    SetSchemaValue(m_ptr, "CBarnLight", "m_LightStyleString", false, CUtlString(value.c_str()));
}
float GCBarnLight::GetLightStyleStartTime() const {
    return GetSchemaValue<float>(m_ptr, "CBarnLight", "m_flLightStyleStartTime");
}
void GCBarnLight::SetLightStyleStartTime(float value) {
    SetSchemaValue(m_ptr, "CBarnLight", "m_flLightStyleStartTime", false, value);
}
std::vector<CUtlString> GCBarnLight::GetQueuedLightStyleStrings() const {
    CUtlVector<CUtlString>* vec = GetSchemaValue<CUtlVector<CUtlString>*>(m_ptr, "CBarnLight", "m_QueuedLightStyleStrings"); std::vector<CUtlString> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCBarnLight::SetQueuedLightStyleStrings(std::vector<CUtlString> value) {
    SetSchemaValueCUtlVector<CUtlString>(m_ptr, "CBarnLight", "m_QueuedLightStyleStrings", false, value);
}
std::vector<CUtlString> GCBarnLight::GetLightStyleEvents() const {
    CUtlVector<CUtlString>* vec = GetSchemaValue<CUtlVector<CUtlString>*>(m_ptr, "CBarnLight", "m_LightStyleEvents"); std::vector<CUtlString> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCBarnLight::SetLightStyleEvents(std::vector<CUtlString> value) {
    SetSchemaValueCUtlVector<CUtlString>(m_ptr, "CBarnLight", "m_LightStyleEvents", false, value);
}
std::vector<GCBaseModelEntity*> GCBarnLight::GetLightStyleTargets() const {
    CUtlVector<GCBaseModelEntity*>* vec = GetSchemaValue<CUtlVector<GCBaseModelEntity*>*>(m_ptr, "CBarnLight", "m_LightStyleTargets"); std::vector<GCBaseModelEntity*> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCBarnLight::SetLightStyleTargets(std::vector<GCBaseModelEntity*> value) {
    SetSchemaValueCUtlVector<GCBaseModelEntity*>(m_ptr, "CBarnLight", "m_LightStyleTargets", false, value);
}
std::vector<GCEntityIOOutput> GCBarnLight::GetStyleEvent() const {
    GCEntityIOOutput* outValue = GetSchemaValue<GCEntityIOOutput*>(m_ptr, "CBarnLight", "m_StyleEvent"); std::vector<GCEntityIOOutput> ret; for(int i = 0; i < 4; i++) { ret.push_back(outValue[i]); } return ret;
}
void GCBarnLight::SetStyleEvent(std::vector<GCEntityIOOutput> value) {
    GCEntityIOOutput* outValue = GetSchemaValue<GCEntityIOOutput*>(m_ptr, "CBarnLight", "m_StyleEvent"); for(int i = 0; i < 4; i++) { outValue[i] = value[i]; } SetSchemaValue(m_ptr, "CBarnLight", "m_StyleEvent", false, outValue);
}
float GCBarnLight::GetShape() const {
    return GetSchemaValue<float>(m_ptr, "CBarnLight", "m_flShape");
}
void GCBarnLight::SetShape(float value) {
    SetSchemaValue(m_ptr, "CBarnLight", "m_flShape", false, value);
}
float GCBarnLight::GetSoftX() const {
    return GetSchemaValue<float>(m_ptr, "CBarnLight", "m_flSoftX");
}
void GCBarnLight::SetSoftX(float value) {
    SetSchemaValue(m_ptr, "CBarnLight", "m_flSoftX", false, value);
}
float GCBarnLight::GetSoftY() const {
    return GetSchemaValue<float>(m_ptr, "CBarnLight", "m_flSoftY");
}
void GCBarnLight::SetSoftY(float value) {
    SetSchemaValue(m_ptr, "CBarnLight", "m_flSoftY", false, value);
}
float GCBarnLight::GetSkirt() const {
    return GetSchemaValue<float>(m_ptr, "CBarnLight", "m_flSkirt");
}
void GCBarnLight::SetSkirt(float value) {
    SetSchemaValue(m_ptr, "CBarnLight", "m_flSkirt", false, value);
}
float GCBarnLight::GetSkirtNear() const {
    return GetSchemaValue<float>(m_ptr, "CBarnLight", "m_flSkirtNear");
}
void GCBarnLight::SetSkirtNear(float value) {
    SetSchemaValue(m_ptr, "CBarnLight", "m_flSkirtNear", false, value);
}
Vector GCBarnLight::GetSizeParams() const {
    return GetSchemaValue<Vector>(m_ptr, "CBarnLight", "m_vSizeParams");
}
void GCBarnLight::SetSizeParams(Vector value) {
    SetSchemaValue(m_ptr, "CBarnLight", "m_vSizeParams", false, value);
}
float GCBarnLight::GetRange() const {
    return GetSchemaValue<float>(m_ptr, "CBarnLight", "m_flRange");
}
void GCBarnLight::SetRange(float value) {
    SetSchemaValue(m_ptr, "CBarnLight", "m_flRange", false, value);
}
Vector GCBarnLight::GetShear() const {
    return GetSchemaValue<Vector>(m_ptr, "CBarnLight", "m_vShear");
}
void GCBarnLight::SetShear(Vector value) {
    SetSchemaValue(m_ptr, "CBarnLight", "m_vShear", false, value);
}
int32_t GCBarnLight::GetBakeSpecularToCubemaps() const {
    return GetSchemaValue<int32_t>(m_ptr, "CBarnLight", "m_nBakeSpecularToCubemaps");
}
void GCBarnLight::SetBakeSpecularToCubemaps(int32_t value) {
    SetSchemaValue(m_ptr, "CBarnLight", "m_nBakeSpecularToCubemaps", false, value);
}
Vector GCBarnLight::GetBakeSpecularToCubemapsSize() const {
    return GetSchemaValue<Vector>(m_ptr, "CBarnLight", "m_vBakeSpecularToCubemapsSize");
}
void GCBarnLight::SetBakeSpecularToCubemapsSize(Vector value) {
    SetSchemaValue(m_ptr, "CBarnLight", "m_vBakeSpecularToCubemapsSize", false, value);
}
int32_t GCBarnLight::GetCastShadows() const {
    return GetSchemaValue<int32_t>(m_ptr, "CBarnLight", "m_nCastShadows");
}
void GCBarnLight::SetCastShadows(int32_t value) {
    SetSchemaValue(m_ptr, "CBarnLight", "m_nCastShadows", false, value);
}
int32_t GCBarnLight::GetShadowMapSize() const {
    return GetSchemaValue<int32_t>(m_ptr, "CBarnLight", "m_nShadowMapSize");
}
void GCBarnLight::SetShadowMapSize(int32_t value) {
    SetSchemaValue(m_ptr, "CBarnLight", "m_nShadowMapSize", false, value);
}
int32_t GCBarnLight::GetShadowPriority() const {
    return GetSchemaValue<int32_t>(m_ptr, "CBarnLight", "m_nShadowPriority");
}
void GCBarnLight::SetShadowPriority(int32_t value) {
    SetSchemaValue(m_ptr, "CBarnLight", "m_nShadowPriority", false, value);
}
bool GCBarnLight::GetContactShadow() const {
    return GetSchemaValue<bool>(m_ptr, "CBarnLight", "m_bContactShadow");
}
void GCBarnLight::SetContactShadow(bool value) {
    SetSchemaValue(m_ptr, "CBarnLight", "m_bContactShadow", false, value);
}
int32_t GCBarnLight::GetBounceLight() const {
    return GetSchemaValue<int32_t>(m_ptr, "CBarnLight", "m_nBounceLight");
}
void GCBarnLight::SetBounceLight(int32_t value) {
    SetSchemaValue(m_ptr, "CBarnLight", "m_nBounceLight", false, value);
}
float GCBarnLight::GetBounceScale() const {
    return GetSchemaValue<float>(m_ptr, "CBarnLight", "m_flBounceScale");
}
void GCBarnLight::SetBounceScale(float value) {
    SetSchemaValue(m_ptr, "CBarnLight", "m_flBounceScale", false, value);
}
float GCBarnLight::GetMinRoughness() const {
    return GetSchemaValue<float>(m_ptr, "CBarnLight", "m_flMinRoughness");
}
void GCBarnLight::SetMinRoughness(float value) {
    SetSchemaValue(m_ptr, "CBarnLight", "m_flMinRoughness", false, value);
}
Vector GCBarnLight::GetAlternateColor() const {
    return GetSchemaValue<Vector>(m_ptr, "CBarnLight", "m_vAlternateColor");
}
void GCBarnLight::SetAlternateColor(Vector value) {
    SetSchemaValue(m_ptr, "CBarnLight", "m_vAlternateColor", false, value);
}
float GCBarnLight::GetAlternateColorBrightness() const {
    return GetSchemaValue<float>(m_ptr, "CBarnLight", "m_fAlternateColorBrightness");
}
void GCBarnLight::SetAlternateColorBrightness(float value) {
    SetSchemaValue(m_ptr, "CBarnLight", "m_fAlternateColorBrightness", false, value);
}
int32_t GCBarnLight::GetFog() const {
    return GetSchemaValue<int32_t>(m_ptr, "CBarnLight", "m_nFog");
}
void GCBarnLight::SetFog(int32_t value) {
    SetSchemaValue(m_ptr, "CBarnLight", "m_nFog", false, value);
}
float GCBarnLight::GetFogStrength() const {
    return GetSchemaValue<float>(m_ptr, "CBarnLight", "m_flFogStrength");
}
void GCBarnLight::SetFogStrength(float value) {
    SetSchemaValue(m_ptr, "CBarnLight", "m_flFogStrength", false, value);
}
int32_t GCBarnLight::GetFogShadows() const {
    return GetSchemaValue<int32_t>(m_ptr, "CBarnLight", "m_nFogShadows");
}
void GCBarnLight::SetFogShadows(int32_t value) {
    SetSchemaValue(m_ptr, "CBarnLight", "m_nFogShadows", false, value);
}
float GCBarnLight::GetFogScale() const {
    return GetSchemaValue<float>(m_ptr, "CBarnLight", "m_flFogScale");
}
void GCBarnLight::SetFogScale(float value) {
    SetSchemaValue(m_ptr, "CBarnLight", "m_flFogScale", false, value);
}
float GCBarnLight::GetFadeSizeStart() const {
    return GetSchemaValue<float>(m_ptr, "CBarnLight", "m_flFadeSizeStart");
}
void GCBarnLight::SetFadeSizeStart(float value) {
    SetSchemaValue(m_ptr, "CBarnLight", "m_flFadeSizeStart", false, value);
}
float GCBarnLight::GetFadeSizeEnd() const {
    return GetSchemaValue<float>(m_ptr, "CBarnLight", "m_flFadeSizeEnd");
}
void GCBarnLight::SetFadeSizeEnd(float value) {
    SetSchemaValue(m_ptr, "CBarnLight", "m_flFadeSizeEnd", false, value);
}
float GCBarnLight::GetShadowFadeSizeStart() const {
    return GetSchemaValue<float>(m_ptr, "CBarnLight", "m_flShadowFadeSizeStart");
}
void GCBarnLight::SetShadowFadeSizeStart(float value) {
    SetSchemaValue(m_ptr, "CBarnLight", "m_flShadowFadeSizeStart", false, value);
}
float GCBarnLight::GetShadowFadeSizeEnd() const {
    return GetSchemaValue<float>(m_ptr, "CBarnLight", "m_flShadowFadeSizeEnd");
}
void GCBarnLight::SetShadowFadeSizeEnd(float value) {
    SetSchemaValue(m_ptr, "CBarnLight", "m_flShadowFadeSizeEnd", false, value);
}
bool GCBarnLight::GetPrecomputedFieldsValid() const {
    return GetSchemaValue<bool>(m_ptr, "CBarnLight", "m_bPrecomputedFieldsValid");
}
void GCBarnLight::SetPrecomputedFieldsValid(bool value) {
    SetSchemaValue(m_ptr, "CBarnLight", "m_bPrecomputedFieldsValid", false, value);
}
Vector GCBarnLight::GetPrecomputedBoundsMins() const {
    return GetSchemaValue<Vector>(m_ptr, "CBarnLight", "m_vPrecomputedBoundsMins");
}
void GCBarnLight::SetPrecomputedBoundsMins(Vector value) {
    SetSchemaValue(m_ptr, "CBarnLight", "m_vPrecomputedBoundsMins", false, value);
}
Vector GCBarnLight::GetPrecomputedBoundsMaxs() const {
    return GetSchemaValue<Vector>(m_ptr, "CBarnLight", "m_vPrecomputedBoundsMaxs");
}
void GCBarnLight::SetPrecomputedBoundsMaxs(Vector value) {
    SetSchemaValue(m_ptr, "CBarnLight", "m_vPrecomputedBoundsMaxs", false, value);
}
Vector GCBarnLight::GetPrecomputedOBBOrigin() const {
    return GetSchemaValue<Vector>(m_ptr, "CBarnLight", "m_vPrecomputedOBBOrigin");
}
void GCBarnLight::SetPrecomputedOBBOrigin(Vector value) {
    SetSchemaValue(m_ptr, "CBarnLight", "m_vPrecomputedOBBOrigin", false, value);
}
QAngle GCBarnLight::GetPrecomputedOBBAngles() const {
    return GetSchemaValue<QAngle>(m_ptr, "CBarnLight", "m_vPrecomputedOBBAngles");
}
void GCBarnLight::SetPrecomputedOBBAngles(QAngle value) {
    SetSchemaValue(m_ptr, "CBarnLight", "m_vPrecomputedOBBAngles", false, value);
}
Vector GCBarnLight::GetPrecomputedOBBExtent() const {
    return GetSchemaValue<Vector>(m_ptr, "CBarnLight", "m_vPrecomputedOBBExtent");
}
void GCBarnLight::SetPrecomputedOBBExtent(Vector value) {
    SetSchemaValue(m_ptr, "CBarnLight", "m_vPrecomputedOBBExtent", false, value);
}
bool GCBarnLight::GetPvsModifyEntity() const {
    return GetSchemaValue<bool>(m_ptr, "CBarnLight", "m_bPvsModifyEntity");
}
void GCBarnLight::SetPvsModifyEntity(bool value) {
    SetSchemaValue(m_ptr, "CBarnLight", "m_bPvsModifyEntity", false, value);
}
std::string GCBarnLight::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCBarnLight::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseModelEntity GCBarnLight::GetParent() const {
    GCBaseModelEntity value(m_ptr);
    return value;
}
void GCBarnLight::SetParent(GCBaseModelEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCBarnLight(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCBarnLight>("CBarnLight")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Enabled", &GCBarnLight::GetEnabled, &GCBarnLight::SetEnabled)
        .addProperty("ColorMode", &GCBarnLight::GetColorMode, &GCBarnLight::SetColorMode)
        .addProperty("Color", &GCBarnLight::GetColor, &GCBarnLight::SetColor)
        .addProperty("ColorTemperature", &GCBarnLight::GetColorTemperature, &GCBarnLight::SetColorTemperature)
        .addProperty("Brightness", &GCBarnLight::GetBrightness, &GCBarnLight::SetBrightness)
        .addProperty("BrightnessScale", &GCBarnLight::GetBrightnessScale, &GCBarnLight::SetBrightnessScale)
        .addProperty("DirectLight", &GCBarnLight::GetDirectLight, &GCBarnLight::SetDirectLight)
        .addProperty("BakedShadowIndex", &GCBarnLight::GetBakedShadowIndex, &GCBarnLight::SetBakedShadowIndex)
        .addProperty("LuminaireShape", &GCBarnLight::GetLuminaireShape, &GCBarnLight::SetLuminaireShape)
        .addProperty("LuminaireSize", &GCBarnLight::GetLuminaireSize, &GCBarnLight::SetLuminaireSize)
        .addProperty("LuminaireAnisotropy", &GCBarnLight::GetLuminaireAnisotropy, &GCBarnLight::SetLuminaireAnisotropy)
        .addProperty("LightStyleString", &GCBarnLight::GetLightStyleString, &GCBarnLight::SetLightStyleString)
        .addProperty("LightStyleStartTime", &GCBarnLight::GetLightStyleStartTime, &GCBarnLight::SetLightStyleStartTime)
        .addProperty("QueuedLightStyleStrings", &GCBarnLight::GetQueuedLightStyleStrings, &GCBarnLight::SetQueuedLightStyleStrings)
        .addProperty("LightStyleEvents", &GCBarnLight::GetLightStyleEvents, &GCBarnLight::SetLightStyleEvents)
        .addProperty("LightStyleTargets", &GCBarnLight::GetLightStyleTargets, &GCBarnLight::SetLightStyleTargets)
        .addProperty("StyleEvent", &GCBarnLight::GetStyleEvent, &GCBarnLight::SetStyleEvent)
        .addProperty("Shape", &GCBarnLight::GetShape, &GCBarnLight::SetShape)
        .addProperty("SoftX", &GCBarnLight::GetSoftX, &GCBarnLight::SetSoftX)
        .addProperty("SoftY", &GCBarnLight::GetSoftY, &GCBarnLight::SetSoftY)
        .addProperty("Skirt", &GCBarnLight::GetSkirt, &GCBarnLight::SetSkirt)
        .addProperty("SkirtNear", &GCBarnLight::GetSkirtNear, &GCBarnLight::SetSkirtNear)
        .addProperty("SizeParams", &GCBarnLight::GetSizeParams, &GCBarnLight::SetSizeParams)
        .addProperty("Range", &GCBarnLight::GetRange, &GCBarnLight::SetRange)
        .addProperty("Shear", &GCBarnLight::GetShear, &GCBarnLight::SetShear)
        .addProperty("BakeSpecularToCubemaps", &GCBarnLight::GetBakeSpecularToCubemaps, &GCBarnLight::SetBakeSpecularToCubemaps)
        .addProperty("BakeSpecularToCubemapsSize", &GCBarnLight::GetBakeSpecularToCubemapsSize, &GCBarnLight::SetBakeSpecularToCubemapsSize)
        .addProperty("CastShadows", &GCBarnLight::GetCastShadows, &GCBarnLight::SetCastShadows)
        .addProperty("ShadowMapSize", &GCBarnLight::GetShadowMapSize, &GCBarnLight::SetShadowMapSize)
        .addProperty("ShadowPriority", &GCBarnLight::GetShadowPriority, &GCBarnLight::SetShadowPriority)
        .addProperty("ContactShadow", &GCBarnLight::GetContactShadow, &GCBarnLight::SetContactShadow)
        .addProperty("BounceLight", &GCBarnLight::GetBounceLight, &GCBarnLight::SetBounceLight)
        .addProperty("BounceScale", &GCBarnLight::GetBounceScale, &GCBarnLight::SetBounceScale)
        .addProperty("MinRoughness", &GCBarnLight::GetMinRoughness, &GCBarnLight::SetMinRoughness)
        .addProperty("AlternateColor", &GCBarnLight::GetAlternateColor, &GCBarnLight::SetAlternateColor)
        .addProperty("AlternateColorBrightness", &GCBarnLight::GetAlternateColorBrightness, &GCBarnLight::SetAlternateColorBrightness)
        .addProperty("Fog", &GCBarnLight::GetFog, &GCBarnLight::SetFog)
        .addProperty("FogStrength", &GCBarnLight::GetFogStrength, &GCBarnLight::SetFogStrength)
        .addProperty("FogShadows", &GCBarnLight::GetFogShadows, &GCBarnLight::SetFogShadows)
        .addProperty("FogScale", &GCBarnLight::GetFogScale, &GCBarnLight::SetFogScale)
        .addProperty("FadeSizeStart", &GCBarnLight::GetFadeSizeStart, &GCBarnLight::SetFadeSizeStart)
        .addProperty("FadeSizeEnd", &GCBarnLight::GetFadeSizeEnd, &GCBarnLight::SetFadeSizeEnd)
        .addProperty("ShadowFadeSizeStart", &GCBarnLight::GetShadowFadeSizeStart, &GCBarnLight::SetShadowFadeSizeStart)
        .addProperty("ShadowFadeSizeEnd", &GCBarnLight::GetShadowFadeSizeEnd, &GCBarnLight::SetShadowFadeSizeEnd)
        .addProperty("PrecomputedFieldsValid", &GCBarnLight::GetPrecomputedFieldsValid, &GCBarnLight::SetPrecomputedFieldsValid)
        .addProperty("PrecomputedBoundsMins", &GCBarnLight::GetPrecomputedBoundsMins, &GCBarnLight::SetPrecomputedBoundsMins)
        .addProperty("PrecomputedBoundsMaxs", &GCBarnLight::GetPrecomputedBoundsMaxs, &GCBarnLight::SetPrecomputedBoundsMaxs)
        .addProperty("PrecomputedOBBOrigin", &GCBarnLight::GetPrecomputedOBBOrigin, &GCBarnLight::SetPrecomputedOBBOrigin)
        .addProperty("PrecomputedOBBAngles", &GCBarnLight::GetPrecomputedOBBAngles, &GCBarnLight::SetPrecomputedOBBAngles)
        .addProperty("PrecomputedOBBExtent", &GCBarnLight::GetPrecomputedOBBExtent, &GCBarnLight::SetPrecomputedOBBExtent)
        .addProperty("PvsModifyEntity", &GCBarnLight::GetPvsModifyEntity, &GCBarnLight::SetPvsModifyEntity)
        .addProperty("Parent", &GCBarnLight::GetParent, &GCBarnLight::SetParent)
        .addFunction("ToPtr", &GCBarnLight::ToPtr)
        .addFunction("IsValid", &GCBarnLight::IsValid)
        .endClass();
}
GSpawnPoint::GSpawnPoint(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GSpawnPoint::GSpawnPoint(void *ptr) {
    m_ptr = ptr;
}
int32_t GSpawnPoint::GetPriority() const {
    return GetSchemaValue<int32_t>(m_ptr, "SpawnPoint", "m_iPriority");
}
void GSpawnPoint::SetPriority(int32_t value) {
    SetSchemaValue(m_ptr, "SpawnPoint", "m_iPriority", false, value);
}
bool GSpawnPoint::GetEnabled() const {
    return GetSchemaValue<bool>(m_ptr, "SpawnPoint", "m_bEnabled");
}
void GSpawnPoint::SetEnabled(bool value) {
    SetSchemaValue(m_ptr, "SpawnPoint", "m_bEnabled", false, value);
}
int32_t GSpawnPoint::GetType() const {
    return GetSchemaValue<int32_t>(m_ptr, "SpawnPoint", "m_nType");
}
void GSpawnPoint::SetType(int32_t value) {
    SetSchemaValue(m_ptr, "SpawnPoint", "m_nType", false, value);
}
std::string GSpawnPoint::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GSpawnPoint::IsValid() {
    return (m_ptr != nullptr);
}
GCServerOnlyPointEntity GSpawnPoint::GetParent() const {
    GCServerOnlyPointEntity value(m_ptr);
    return value;
}
void GSpawnPoint::SetParent(GCServerOnlyPointEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassSpawnPoint(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GSpawnPoint>("SpawnPoint")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Priority", &GSpawnPoint::GetPriority, &GSpawnPoint::SetPriority)
        .addProperty("Enabled", &GSpawnPoint::GetEnabled, &GSpawnPoint::SetEnabled)
        .addProperty("Type", &GSpawnPoint::GetType, &GSpawnPoint::SetType)
        .addProperty("Parent", &GSpawnPoint::GetParent, &GSpawnPoint::SetParent)
        .addFunction("ToPtr", &GSpawnPoint::ToPtr)
        .addFunction("IsValid", &GSpawnPoint::IsValid)
        .endClass();
}
GCEnvViewPunch::GCEnvViewPunch(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCEnvViewPunch::GCEnvViewPunch(void *ptr) {
    m_ptr = ptr;
}
float GCEnvViewPunch::GetRadius() const {
    return GetSchemaValue<float>(m_ptr, "CEnvViewPunch", "m_flRadius");
}
void GCEnvViewPunch::SetRadius(float value) {
    SetSchemaValue(m_ptr, "CEnvViewPunch", "m_flRadius", false, value);
}
QAngle GCEnvViewPunch::GetViewPunch() const {
    return GetSchemaValue<QAngle>(m_ptr, "CEnvViewPunch", "m_angViewPunch");
}
void GCEnvViewPunch::SetViewPunch(QAngle value) {
    SetSchemaValue(m_ptr, "CEnvViewPunch", "m_angViewPunch", false, value);
}
std::string GCEnvViewPunch::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCEnvViewPunch::IsValid() {
    return (m_ptr != nullptr);
}
GCPointEntity GCEnvViewPunch::GetParent() const {
    GCPointEntity value(m_ptr);
    return value;
}
void GCEnvViewPunch::SetParent(GCPointEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCEnvViewPunch(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCEnvViewPunch>("CEnvViewPunch")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Radius", &GCEnvViewPunch::GetRadius, &GCEnvViewPunch::SetRadius)
        .addProperty("ViewPunch", &GCEnvViewPunch::GetViewPunch, &GCEnvViewPunch::SetViewPunch)
        .addProperty("Parent", &GCEnvViewPunch::GetParent, &GCEnvViewPunch::SetParent)
        .addFunction("ToPtr", &GCEnvViewPunch::ToPtr)
        .addFunction("IsValid", &GCEnvViewPunch::IsValid)
        .endClass();
}
GCCSWeaponBase::GCCSWeaponBase(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCCSWeaponBase::GCCSWeaponBase(void *ptr) {
    m_ptr = ptr;
}
bool GCCSWeaponBase::GetRemoveable() const {
    return GetSchemaValue<bool>(m_ptr, "CCSWeaponBase", "m_bRemoveable");
}
void GCCSWeaponBase::SetRemoveable(bool value) {
    SetSchemaValue(m_ptr, "CCSWeaponBase", "m_bRemoveable", false, value);
}
float GCCSWeaponBase::GetFireSequenceStartTime() const {
    return GetSchemaValue<float>(m_ptr, "CCSWeaponBase", "m_flFireSequenceStartTime");
}
void GCCSWeaponBase::SetFireSequenceStartTime(float value) {
    SetSchemaValue(m_ptr, "CCSWeaponBase", "m_flFireSequenceStartTime", false, value);
}
int32_t GCCSWeaponBase::GetFireSequenceStartTimeChange() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSWeaponBase", "m_nFireSequenceStartTimeChange");
}
void GCCSWeaponBase::SetFireSequenceStartTimeChange(int32_t value) {
    SetSchemaValue(m_ptr, "CCSWeaponBase", "m_nFireSequenceStartTimeChange", false, value);
}
int32_t GCCSWeaponBase::GetFireSequenceStartTimeAck() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSWeaponBase", "m_nFireSequenceStartTimeAck");
}
void GCCSWeaponBase::SetFireSequenceStartTimeAck(int32_t value) {
    SetSchemaValue(m_ptr, "CCSWeaponBase", "m_nFireSequenceStartTimeAck", false, value);
}
uint64_t GCCSWeaponBase::GetPlayerFireEvent() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CCSWeaponBase", "m_ePlayerFireEvent");
}
void GCCSWeaponBase::SetPlayerFireEvent(uint64_t value) {
    SetSchemaValue(m_ptr, "CCSWeaponBase", "m_ePlayerFireEvent", false, value);
}
uint64_t GCCSWeaponBase::GetPlayerFireEventAttackType() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CCSWeaponBase", "m_ePlayerFireEventAttackType");
}
void GCCSWeaponBase::SetPlayerFireEventAttackType(uint64_t value) {
    SetSchemaValue(m_ptr, "CCSWeaponBase", "m_ePlayerFireEventAttackType", false, value);
}
int32_t GCCSWeaponBase::GetSilencerBoneIndex() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSWeaponBase", "m_nSilencerBoneIndex");
}
void GCCSWeaponBase::SetSilencerBoneIndex(int32_t value) {
    SetSchemaValue(m_ptr, "CCSWeaponBase", "m_nSilencerBoneIndex", false, value);
}
bool GCCSWeaponBase::GetPlayerAmmoStockOnPickup() const {
    return GetSchemaValue<bool>(m_ptr, "CCSWeaponBase", "m_bPlayerAmmoStockOnPickup");
}
void GCCSWeaponBase::SetPlayerAmmoStockOnPickup(bool value) {
    SetSchemaValue(m_ptr, "CCSWeaponBase", "m_bPlayerAmmoStockOnPickup", false, value);
}
bool GCCSWeaponBase::GetRequireUseToTouch() const {
    return GetSchemaValue<bool>(m_ptr, "CCSWeaponBase", "m_bRequireUseToTouch");
}
void GCCSWeaponBase::SetRequireUseToTouch(bool value) {
    SetSchemaValue(m_ptr, "CCSWeaponBase", "m_bRequireUseToTouch", false, value);
}
uint64_t GCCSWeaponBase::GetState() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CCSWeaponBase", "m_iState");
}
void GCCSWeaponBase::SetState(uint64_t value) {
    SetSchemaValue(m_ptr, "CCSWeaponBase", "m_iState", false, value);
}
float GCCSWeaponBase::GetLastTimeInAir() const {
    return GetSchemaValue<float>(m_ptr, "CCSWeaponBase", "m_flLastTimeInAir");
}
void GCCSWeaponBase::SetLastTimeInAir(float value) {
    SetSchemaValue(m_ptr, "CCSWeaponBase", "m_flLastTimeInAir", false, value);
}
float GCCSWeaponBase::GetLastDeployTime() const {
    return GetSchemaValue<float>(m_ptr, "CCSWeaponBase", "m_flLastDeployTime");
}
void GCCSWeaponBase::SetLastDeployTime(float value) {
    SetSchemaValue(m_ptr, "CCSWeaponBase", "m_flLastDeployTime", false, value);
}
int32_t GCCSWeaponBase::GetLastEmptySoundCmdNum() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSWeaponBase", "m_nLastEmptySoundCmdNum");
}
void GCCSWeaponBase::SetLastEmptySoundCmdNum(int32_t value) {
    SetSchemaValue(m_ptr, "CCSWeaponBase", "m_nLastEmptySoundCmdNum", false, value);
}
uint32_t GCCSWeaponBase::GetViewModelIndex() const {
    return GetSchemaValue<uint32_t>(m_ptr, "CCSWeaponBase", "m_nViewModelIndex");
}
void GCCSWeaponBase::SetViewModelIndex(uint32_t value) {
    SetSchemaValue(m_ptr, "CCSWeaponBase", "m_nViewModelIndex", false, value);
}
bool GCCSWeaponBase::GetReloadsWithClips() const {
    return GetSchemaValue<bool>(m_ptr, "CCSWeaponBase", "m_bReloadsWithClips");
}
void GCCSWeaponBase::SetReloadsWithClips(bool value) {
    SetSchemaValue(m_ptr, "CCSWeaponBase", "m_bReloadsWithClips", false, value);
}
float GCCSWeaponBase::GetTimeWeaponIdle() const {
    return GetSchemaValue<float>(m_ptr, "CCSWeaponBase", "m_flTimeWeaponIdle");
}
void GCCSWeaponBase::SetTimeWeaponIdle(float value) {
    SetSchemaValue(m_ptr, "CCSWeaponBase", "m_flTimeWeaponIdle", false, value);
}
bool GCCSWeaponBase::GetFireOnEmpty() const {
    return GetSchemaValue<bool>(m_ptr, "CCSWeaponBase", "m_bFireOnEmpty");
}
void GCCSWeaponBase::SetFireOnEmpty(bool value) {
    SetSchemaValue(m_ptr, "CCSWeaponBase", "m_bFireOnEmpty", false, value);
}
GCEntityIOOutput GCCSWeaponBase::GetOnPlayerPickup() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CCSWeaponBase", "m_OnPlayerPickup"));
    return value;
}
void GCCSWeaponBase::SetOnPlayerPickup(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CCSWeaponBase", "m_OnPlayerPickup", false, value);
}
uint64_t GCCSWeaponBase::GetWeaponMode() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CCSWeaponBase", "m_weaponMode");
}
void GCCSWeaponBase::SetWeaponMode(uint64_t value) {
    SetSchemaValue(m_ptr, "CCSWeaponBase", "m_weaponMode", false, value);
}
float GCCSWeaponBase::GetTurningInaccuracyDelta() const {
    return GetSchemaValue<float>(m_ptr, "CCSWeaponBase", "m_flTurningInaccuracyDelta");
}
void GCCSWeaponBase::SetTurningInaccuracyDelta(float value) {
    SetSchemaValue(m_ptr, "CCSWeaponBase", "m_flTurningInaccuracyDelta", false, value);
}
Vector GCCSWeaponBase::GetTurningInaccuracyEyeDirLast() const {
    return GetSchemaValue<Vector>(m_ptr, "CCSWeaponBase", "m_vecTurningInaccuracyEyeDirLast");
}
void GCCSWeaponBase::SetTurningInaccuracyEyeDirLast(Vector value) {
    SetSchemaValue(m_ptr, "CCSWeaponBase", "m_vecTurningInaccuracyEyeDirLast", false, value);
}
float GCCSWeaponBase::GetTurningInaccuracy() const {
    return GetSchemaValue<float>(m_ptr, "CCSWeaponBase", "m_flTurningInaccuracy");
}
void GCCSWeaponBase::SetTurningInaccuracy(float value) {
    SetSchemaValue(m_ptr, "CCSWeaponBase", "m_flTurningInaccuracy", false, value);
}
float GCCSWeaponBase::GetAccuracyPenalty() const {
    return GetSchemaValue<float>(m_ptr, "CCSWeaponBase", "m_fAccuracyPenalty");
}
void GCCSWeaponBase::SetAccuracyPenalty(float value) {
    SetSchemaValue(m_ptr, "CCSWeaponBase", "m_fAccuracyPenalty", false, value);
}
float GCCSWeaponBase::GetLastAccuracyUpdateTime() const {
    return GetSchemaValue<float>(m_ptr, "CCSWeaponBase", "m_flLastAccuracyUpdateTime");
}
void GCCSWeaponBase::SetLastAccuracyUpdateTime(float value) {
    SetSchemaValue(m_ptr, "CCSWeaponBase", "m_flLastAccuracyUpdateTime", false, value);
}
float GCCSWeaponBase::GetAccuracySmoothedForZoom() const {
    return GetSchemaValue<float>(m_ptr, "CCSWeaponBase", "m_fAccuracySmoothedForZoom");
}
void GCCSWeaponBase::SetAccuracySmoothedForZoom(float value) {
    SetSchemaValue(m_ptr, "CCSWeaponBase", "m_fAccuracySmoothedForZoom", false, value);
}
float GCCSWeaponBase::GetScopeZoomEndTime() const {
    return GetSchemaValue<float>(m_ptr, "CCSWeaponBase", "m_fScopeZoomEndTime");
}
void GCCSWeaponBase::SetScopeZoomEndTime(float value) {
    SetSchemaValue(m_ptr, "CCSWeaponBase", "m_fScopeZoomEndTime", false, value);
}
int32_t GCCSWeaponBase::GetRecoilIndex() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSWeaponBase", "m_iRecoilIndex");
}
void GCCSWeaponBase::SetRecoilIndex(int32_t value) {
    SetSchemaValue(m_ptr, "CCSWeaponBase", "m_iRecoilIndex", false, value);
}
float GCCSWeaponBase::GetRecoilIndex1() const {
    return GetSchemaValue<float>(m_ptr, "CCSWeaponBase", "m_flRecoilIndex");
}
void GCCSWeaponBase::SetRecoilIndex1(float value) {
    SetSchemaValue(m_ptr, "CCSWeaponBase", "m_flRecoilIndex", false, value);
}
bool GCCSWeaponBase::GetBurstMode() const {
    return GetSchemaValue<bool>(m_ptr, "CCSWeaponBase", "m_bBurstMode");
}
void GCCSWeaponBase::SetBurstMode(bool value) {
    SetSchemaValue(m_ptr, "CCSWeaponBase", "m_bBurstMode", false, value);
}
int32 GCCSWeaponBase::GetPostponeFireReadyTicks() const {
    return GetSchemaValue<int32>(m_ptr, "CCSWeaponBase", "m_nPostponeFireReadyTicks");
}
void GCCSWeaponBase::SetPostponeFireReadyTicks(int32 value) {
    SetSchemaValue(m_ptr, "CCSWeaponBase", "m_nPostponeFireReadyTicks", false, value);
}
float GCCSWeaponBase::GetPostponeFireReadyFrac() const {
    return GetSchemaValue<float>(m_ptr, "CCSWeaponBase", "m_flPostponeFireReadyFrac");
}
void GCCSWeaponBase::SetPostponeFireReadyFrac(float value) {
    SetSchemaValue(m_ptr, "CCSWeaponBase", "m_flPostponeFireReadyFrac", false, value);
}
bool GCCSWeaponBase::GetInReload() const {
    return GetSchemaValue<bool>(m_ptr, "CCSWeaponBase", "m_bInReload");
}
void GCCSWeaponBase::SetInReload(bool value) {
    SetSchemaValue(m_ptr, "CCSWeaponBase", "m_bInReload", false, value);
}
bool GCCSWeaponBase::GetReloadVisuallyComplete() const {
    return GetSchemaValue<bool>(m_ptr, "CCSWeaponBase", "m_bReloadVisuallyComplete");
}
void GCCSWeaponBase::SetReloadVisuallyComplete(bool value) {
    SetSchemaValue(m_ptr, "CCSWeaponBase", "m_bReloadVisuallyComplete", false, value);
}
float GCCSWeaponBase::GetDroppedAtTime() const {
    return GetSchemaValue<float>(m_ptr, "CCSWeaponBase", "m_flDroppedAtTime");
}
void GCCSWeaponBase::SetDroppedAtTime(float value) {
    SetSchemaValue(m_ptr, "CCSWeaponBase", "m_flDroppedAtTime", false, value);
}
bool GCCSWeaponBase::GetIsHauledBack() const {
    return GetSchemaValue<bool>(m_ptr, "CCSWeaponBase", "m_bIsHauledBack");
}
void GCCSWeaponBase::SetIsHauledBack(bool value) {
    SetSchemaValue(m_ptr, "CCSWeaponBase", "m_bIsHauledBack", false, value);
}
bool GCCSWeaponBase::GetSilencerOn() const {
    return GetSchemaValue<bool>(m_ptr, "CCSWeaponBase", "m_bSilencerOn");
}
void GCCSWeaponBase::SetSilencerOn(bool value) {
    SetSchemaValue(m_ptr, "CCSWeaponBase", "m_bSilencerOn", false, value);
}
float GCCSWeaponBase::GetTimeSilencerSwitchComplete() const {
    return GetSchemaValue<float>(m_ptr, "CCSWeaponBase", "m_flTimeSilencerSwitchComplete");
}
void GCCSWeaponBase::SetTimeSilencerSwitchComplete(float value) {
    SetSchemaValue(m_ptr, "CCSWeaponBase", "m_flTimeSilencerSwitchComplete", false, value);
}
int32_t GCCSWeaponBase::GetOriginalTeamNumber() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSWeaponBase", "m_iOriginalTeamNumber");
}
void GCCSWeaponBase::SetOriginalTeamNumber(int32_t value) {
    SetSchemaValue(m_ptr, "CCSWeaponBase", "m_iOriginalTeamNumber", false, value);
}
int32_t GCCSWeaponBase::GetMostRecentTeamNumber() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSWeaponBase", "m_iMostRecentTeamNumber");
}
void GCCSWeaponBase::SetMostRecentTeamNumber(int32_t value) {
    SetSchemaValue(m_ptr, "CCSWeaponBase", "m_iMostRecentTeamNumber", false, value);
}
bool GCCSWeaponBase::GetDroppedNearBuyZone() const {
    return GetSchemaValue<bool>(m_ptr, "CCSWeaponBase", "m_bDroppedNearBuyZone");
}
void GCCSWeaponBase::SetDroppedNearBuyZone(bool value) {
    SetSchemaValue(m_ptr, "CCSWeaponBase", "m_bDroppedNearBuyZone", false, value);
}
float GCCSWeaponBase::GetNextAttackRenderTimeOffset() const {
    return GetSchemaValue<float>(m_ptr, "CCSWeaponBase", "m_flNextAttackRenderTimeOffset");
}
void GCCSWeaponBase::SetNextAttackRenderTimeOffset(float value) {
    SetSchemaValue(m_ptr, "CCSWeaponBase", "m_flNextAttackRenderTimeOffset", false, value);
}
bool GCCSWeaponBase::GetCanBePickedUp() const {
    return GetSchemaValue<bool>(m_ptr, "CCSWeaponBase", "m_bCanBePickedUp");
}
void GCCSWeaponBase::SetCanBePickedUp(bool value) {
    SetSchemaValue(m_ptr, "CCSWeaponBase", "m_bCanBePickedUp", false, value);
}
bool GCCSWeaponBase::GetUseCanOverrideNextOwnerTouchTime() const {
    return GetSchemaValue<bool>(m_ptr, "CCSWeaponBase", "m_bUseCanOverrideNextOwnerTouchTime");
}
void GCCSWeaponBase::SetUseCanOverrideNextOwnerTouchTime(bool value) {
    SetSchemaValue(m_ptr, "CCSWeaponBase", "m_bUseCanOverrideNextOwnerTouchTime", false, value);
}
float GCCSWeaponBase::GetNextOwnerTouchTime() const {
    return GetSchemaValue<float>(m_ptr, "CCSWeaponBase", "m_nextOwnerTouchTime");
}
void GCCSWeaponBase::SetNextOwnerTouchTime(float value) {
    SetSchemaValue(m_ptr, "CCSWeaponBase", "m_nextOwnerTouchTime", false, value);
}
float GCCSWeaponBase::GetNextPrevOwnerTouchTime() const {
    return GetSchemaValue<float>(m_ptr, "CCSWeaponBase", "m_nextPrevOwnerTouchTime");
}
void GCCSWeaponBase::SetNextPrevOwnerTouchTime(float value) {
    SetSchemaValue(m_ptr, "CCSWeaponBase", "m_nextPrevOwnerTouchTime", false, value);
}
GCCSPlayerPawn GCCSWeaponBase::GetPrevOwner() const {
    GCCSPlayerPawn value(*GetSchemaValuePtr<void*>(m_ptr, "CCSWeaponBase", "m_hPrevOwner"));
    return value;
}
void GCCSWeaponBase::SetPrevOwner(GCCSPlayerPawn* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'PrevOwner' is not possible.\n");
}
int32 GCCSWeaponBase::GetDropTick() const {
    return GetSchemaValue<int32>(m_ptr, "CCSWeaponBase", "m_nDropTick");
}
void GCCSWeaponBase::SetDropTick(int32 value) {
    SetSchemaValue(m_ptr, "CCSWeaponBase", "m_nDropTick", false, value);
}
bool GCCSWeaponBase::GetDonated() const {
    return GetSchemaValue<bool>(m_ptr, "CCSWeaponBase", "m_donated");
}
void GCCSWeaponBase::SetDonated(bool value) {
    SetSchemaValue(m_ptr, "CCSWeaponBase", "m_donated", false, value);
}
float GCCSWeaponBase::GetLastShotTime() const {
    return GetSchemaValue<float>(m_ptr, "CCSWeaponBase", "m_fLastShotTime");
}
void GCCSWeaponBase::SetLastShotTime(float value) {
    SetSchemaValue(m_ptr, "CCSWeaponBase", "m_fLastShotTime", false, value);
}
bool GCCSWeaponBase::GetWasOwnedByCT() const {
    return GetSchemaValue<bool>(m_ptr, "CCSWeaponBase", "m_bWasOwnedByCT");
}
void GCCSWeaponBase::SetWasOwnedByCT(bool value) {
    SetSchemaValue(m_ptr, "CCSWeaponBase", "m_bWasOwnedByCT", false, value);
}
bool GCCSWeaponBase::GetWasOwnedByTerrorist() const {
    return GetSchemaValue<bool>(m_ptr, "CCSWeaponBase", "m_bWasOwnedByTerrorist");
}
void GCCSWeaponBase::SetWasOwnedByTerrorist(bool value) {
    SetSchemaValue(m_ptr, "CCSWeaponBase", "m_bWasOwnedByTerrorist", false, value);
}
bool GCCSWeaponBase::GetFiredOutOfAmmoEvent() const {
    return GetSchemaValue<bool>(m_ptr, "CCSWeaponBase", "m_bFiredOutOfAmmoEvent");
}
void GCCSWeaponBase::SetFiredOutOfAmmoEvent(bool value) {
    SetSchemaValue(m_ptr, "CCSWeaponBase", "m_bFiredOutOfAmmoEvent", false, value);
}
int32_t GCCSWeaponBase::GetNumRemoveUnownedWeaponThink() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSWeaponBase", "m_numRemoveUnownedWeaponThink");
}
void GCCSWeaponBase::SetNumRemoveUnownedWeaponThink(int32_t value) {
    SetSchemaValue(m_ptr, "CCSWeaponBase", "m_numRemoveUnownedWeaponThink", false, value);
}
GCIronSightController GCCSWeaponBase::GetIronSightController() const {
    GCIronSightController value(GetSchemaPtr(m_ptr, "CCSWeaponBase", "m_IronSightController"));
    return value;
}
void GCCSWeaponBase::SetIronSightController(GCIronSightController value) {
    SetSchemaValue(m_ptr, "CCSWeaponBase", "m_IronSightController", false, value);
}
int32_t GCCSWeaponBase::GetIronSightMode() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSWeaponBase", "m_iIronSightMode");
}
void GCCSWeaponBase::SetIronSightMode(int32_t value) {
    SetSchemaValue(m_ptr, "CCSWeaponBase", "m_iIronSightMode", false, value);
}
float GCCSWeaponBase::GetLastLOSTraceFailureTime() const {
    return GetSchemaValue<float>(m_ptr, "CCSWeaponBase", "m_flLastLOSTraceFailureTime");
}
void GCCSWeaponBase::SetLastLOSTraceFailureTime(float value) {
    SetSchemaValue(m_ptr, "CCSWeaponBase", "m_flLastLOSTraceFailureTime", false, value);
}
int32_t GCCSWeaponBase::GetNumEmptyAttacks() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSWeaponBase", "m_iNumEmptyAttacks");
}
void GCCSWeaponBase::SetNumEmptyAttacks(int32_t value) {
    SetSchemaValue(m_ptr, "CCSWeaponBase", "m_iNumEmptyAttacks", false, value);
}
float GCCSWeaponBase::GetWatTickOffset() const {
    return GetSchemaValue<float>(m_ptr, "CCSWeaponBase", "m_flWatTickOffset");
}
void GCCSWeaponBase::SetWatTickOffset(float value) {
    SetSchemaValue(m_ptr, "CCSWeaponBase", "m_flWatTickOffset", false, value);
}
std::string GCCSWeaponBase::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCCSWeaponBase::IsValid() {
    return (m_ptr != nullptr);
}
GCBasePlayerWeapon GCCSWeaponBase::GetParent() const {
    GCBasePlayerWeapon value(m_ptr);
    return value;
}
void GCCSWeaponBase::SetParent(GCBasePlayerWeapon value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCCSWeaponBase(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCCSWeaponBase>("CCSWeaponBase")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Removeable", &GCCSWeaponBase::GetRemoveable, &GCCSWeaponBase::SetRemoveable)
        .addProperty("FireSequenceStartTime", &GCCSWeaponBase::GetFireSequenceStartTime, &GCCSWeaponBase::SetFireSequenceStartTime)
        .addProperty("FireSequenceStartTimeChange", &GCCSWeaponBase::GetFireSequenceStartTimeChange, &GCCSWeaponBase::SetFireSequenceStartTimeChange)
        .addProperty("FireSequenceStartTimeAck", &GCCSWeaponBase::GetFireSequenceStartTimeAck, &GCCSWeaponBase::SetFireSequenceStartTimeAck)
        .addProperty("PlayerFireEvent", &GCCSWeaponBase::GetPlayerFireEvent, &GCCSWeaponBase::SetPlayerFireEvent)
        .addProperty("PlayerFireEventAttackType", &GCCSWeaponBase::GetPlayerFireEventAttackType, &GCCSWeaponBase::SetPlayerFireEventAttackType)
        .addProperty("SilencerBoneIndex", &GCCSWeaponBase::GetSilencerBoneIndex, &GCCSWeaponBase::SetSilencerBoneIndex)
        .addProperty("PlayerAmmoStockOnPickup", &GCCSWeaponBase::GetPlayerAmmoStockOnPickup, &GCCSWeaponBase::SetPlayerAmmoStockOnPickup)
        .addProperty("RequireUseToTouch", &GCCSWeaponBase::GetRequireUseToTouch, &GCCSWeaponBase::SetRequireUseToTouch)
        .addProperty("State", &GCCSWeaponBase::GetState, &GCCSWeaponBase::SetState)
        .addProperty("LastTimeInAir", &GCCSWeaponBase::GetLastTimeInAir, &GCCSWeaponBase::SetLastTimeInAir)
        .addProperty("LastDeployTime", &GCCSWeaponBase::GetLastDeployTime, &GCCSWeaponBase::SetLastDeployTime)
        .addProperty("LastEmptySoundCmdNum", &GCCSWeaponBase::GetLastEmptySoundCmdNum, &GCCSWeaponBase::SetLastEmptySoundCmdNum)
        .addProperty("ViewModelIndex", &GCCSWeaponBase::GetViewModelIndex, &GCCSWeaponBase::SetViewModelIndex)
        .addProperty("ReloadsWithClips", &GCCSWeaponBase::GetReloadsWithClips, &GCCSWeaponBase::SetReloadsWithClips)
        .addProperty("TimeWeaponIdle", &GCCSWeaponBase::GetTimeWeaponIdle, &GCCSWeaponBase::SetTimeWeaponIdle)
        .addProperty("FireOnEmpty", &GCCSWeaponBase::GetFireOnEmpty, &GCCSWeaponBase::SetFireOnEmpty)
        .addProperty("OnPlayerPickup", &GCCSWeaponBase::GetOnPlayerPickup, &GCCSWeaponBase::SetOnPlayerPickup)
        .addProperty("WeaponMode", &GCCSWeaponBase::GetWeaponMode, &GCCSWeaponBase::SetWeaponMode)
        .addProperty("TurningInaccuracyDelta", &GCCSWeaponBase::GetTurningInaccuracyDelta, &GCCSWeaponBase::SetTurningInaccuracyDelta)
        .addProperty("TurningInaccuracyEyeDirLast", &GCCSWeaponBase::GetTurningInaccuracyEyeDirLast, &GCCSWeaponBase::SetTurningInaccuracyEyeDirLast)
        .addProperty("TurningInaccuracy", &GCCSWeaponBase::GetTurningInaccuracy, &GCCSWeaponBase::SetTurningInaccuracy)
        .addProperty("AccuracyPenalty", &GCCSWeaponBase::GetAccuracyPenalty, &GCCSWeaponBase::SetAccuracyPenalty)
        .addProperty("LastAccuracyUpdateTime", &GCCSWeaponBase::GetLastAccuracyUpdateTime, &GCCSWeaponBase::SetLastAccuracyUpdateTime)
        .addProperty("AccuracySmoothedForZoom", &GCCSWeaponBase::GetAccuracySmoothedForZoom, &GCCSWeaponBase::SetAccuracySmoothedForZoom)
        .addProperty("ScopeZoomEndTime", &GCCSWeaponBase::GetScopeZoomEndTime, &GCCSWeaponBase::SetScopeZoomEndTime)
        .addProperty("RecoilIndex", &GCCSWeaponBase::GetRecoilIndex, &GCCSWeaponBase::SetRecoilIndex)
        .addProperty("RecoilIndex1", &GCCSWeaponBase::GetRecoilIndex1, &GCCSWeaponBase::SetRecoilIndex1)
        .addProperty("BurstMode", &GCCSWeaponBase::GetBurstMode, &GCCSWeaponBase::SetBurstMode)
        .addProperty("PostponeFireReadyTicks", &GCCSWeaponBase::GetPostponeFireReadyTicks, &GCCSWeaponBase::SetPostponeFireReadyTicks)
        .addProperty("PostponeFireReadyFrac", &GCCSWeaponBase::GetPostponeFireReadyFrac, &GCCSWeaponBase::SetPostponeFireReadyFrac)
        .addProperty("InReload", &GCCSWeaponBase::GetInReload, &GCCSWeaponBase::SetInReload)
        .addProperty("ReloadVisuallyComplete", &GCCSWeaponBase::GetReloadVisuallyComplete, &GCCSWeaponBase::SetReloadVisuallyComplete)
        .addProperty("DroppedAtTime", &GCCSWeaponBase::GetDroppedAtTime, &GCCSWeaponBase::SetDroppedAtTime)
        .addProperty("IsHauledBack", &GCCSWeaponBase::GetIsHauledBack, &GCCSWeaponBase::SetIsHauledBack)
        .addProperty("SilencerOn", &GCCSWeaponBase::GetSilencerOn, &GCCSWeaponBase::SetSilencerOn)
        .addProperty("TimeSilencerSwitchComplete", &GCCSWeaponBase::GetTimeSilencerSwitchComplete, &GCCSWeaponBase::SetTimeSilencerSwitchComplete)
        .addProperty("OriginalTeamNumber", &GCCSWeaponBase::GetOriginalTeamNumber, &GCCSWeaponBase::SetOriginalTeamNumber)
        .addProperty("MostRecentTeamNumber", &GCCSWeaponBase::GetMostRecentTeamNumber, &GCCSWeaponBase::SetMostRecentTeamNumber)
        .addProperty("DroppedNearBuyZone", &GCCSWeaponBase::GetDroppedNearBuyZone, &GCCSWeaponBase::SetDroppedNearBuyZone)
        .addProperty("NextAttackRenderTimeOffset", &GCCSWeaponBase::GetNextAttackRenderTimeOffset, &GCCSWeaponBase::SetNextAttackRenderTimeOffset)
        .addProperty("CanBePickedUp", &GCCSWeaponBase::GetCanBePickedUp, &GCCSWeaponBase::SetCanBePickedUp)
        .addProperty("UseCanOverrideNextOwnerTouchTime", &GCCSWeaponBase::GetUseCanOverrideNextOwnerTouchTime, &GCCSWeaponBase::SetUseCanOverrideNextOwnerTouchTime)
        .addProperty("NextOwnerTouchTime", &GCCSWeaponBase::GetNextOwnerTouchTime, &GCCSWeaponBase::SetNextOwnerTouchTime)
        .addProperty("NextPrevOwnerTouchTime", &GCCSWeaponBase::GetNextPrevOwnerTouchTime, &GCCSWeaponBase::SetNextPrevOwnerTouchTime)
        .addProperty("PrevOwner", &GCCSWeaponBase::GetPrevOwner, &GCCSWeaponBase::SetPrevOwner)
        .addProperty("DropTick", &GCCSWeaponBase::GetDropTick, &GCCSWeaponBase::SetDropTick)
        .addProperty("Donated", &GCCSWeaponBase::GetDonated, &GCCSWeaponBase::SetDonated)
        .addProperty("LastShotTime", &GCCSWeaponBase::GetLastShotTime, &GCCSWeaponBase::SetLastShotTime)
        .addProperty("WasOwnedByCT", &GCCSWeaponBase::GetWasOwnedByCT, &GCCSWeaponBase::SetWasOwnedByCT)
        .addProperty("WasOwnedByTerrorist", &GCCSWeaponBase::GetWasOwnedByTerrorist, &GCCSWeaponBase::SetWasOwnedByTerrorist)
        .addProperty("FiredOutOfAmmoEvent", &GCCSWeaponBase::GetFiredOutOfAmmoEvent, &GCCSWeaponBase::SetFiredOutOfAmmoEvent)
        .addProperty("NumRemoveUnownedWeaponThink", &GCCSWeaponBase::GetNumRemoveUnownedWeaponThink, &GCCSWeaponBase::SetNumRemoveUnownedWeaponThink)
        .addProperty("IronSightController", &GCCSWeaponBase::GetIronSightController, &GCCSWeaponBase::SetIronSightController)
        .addProperty("IronSightMode", &GCCSWeaponBase::GetIronSightMode, &GCCSWeaponBase::SetIronSightMode)
        .addProperty("LastLOSTraceFailureTime", &GCCSWeaponBase::GetLastLOSTraceFailureTime, &GCCSWeaponBase::SetLastLOSTraceFailureTime)
        .addProperty("NumEmptyAttacks", &GCCSWeaponBase::GetNumEmptyAttacks, &GCCSWeaponBase::SetNumEmptyAttacks)
        .addProperty("WatTickOffset", &GCCSWeaponBase::GetWatTickOffset, &GCCSWeaponBase::SetWatTickOffset)
        .addProperty("Parent", &GCCSWeaponBase::GetParent, &GCCSWeaponBase::SetParent)
        .addFunction("ToPtr", &GCCSWeaponBase::ToPtr)
        .addFunction("IsValid", &GCCSWeaponBase::IsValid)
        .endClass();
}
GCPathCorner::GCPathCorner(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCPathCorner::GCPathCorner(void *ptr) {
    m_ptr = ptr;
}
float GCPathCorner::GetWait() const {
    return GetSchemaValue<float>(m_ptr, "CPathCorner", "m_flWait");
}
void GCPathCorner::SetWait(float value) {
    SetSchemaValue(m_ptr, "CPathCorner", "m_flWait", false, value);
}
float GCPathCorner::GetRadius() const {
    return GetSchemaValue<float>(m_ptr, "CPathCorner", "m_flRadius");
}
void GCPathCorner::SetRadius(float value) {
    SetSchemaValue(m_ptr, "CPathCorner", "m_flRadius", false, value);
}
GCEntityIOOutput GCPathCorner::GetOnPass() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CPathCorner", "m_OnPass"));
    return value;
}
void GCPathCorner::SetOnPass(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CPathCorner", "m_OnPass", false, value);
}
std::string GCPathCorner::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCPathCorner::IsValid() {
    return (m_ptr != nullptr);
}
GCPointEntity GCPathCorner::GetParent() const {
    GCPointEntity value(m_ptr);
    return value;
}
void GCPathCorner::SetParent(GCPointEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCPathCorner(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCPathCorner>("CPathCorner")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Wait", &GCPathCorner::GetWait, &GCPathCorner::SetWait)
        .addProperty("Radius", &GCPathCorner::GetRadius, &GCPathCorner::SetRadius)
        .addProperty("OnPass", &GCPathCorner::GetOnPass, &GCPathCorner::SetOnPass)
        .addProperty("Parent", &GCPathCorner::GetParent, &GCPathCorner::SetParent)
        .addFunction("ToPtr", &GCPathCorner::ToPtr)
        .addFunction("IsValid", &GCPathCorner::IsValid)
        .endClass();
}
GCPlayerControllerComponent::GCPlayerControllerComponent(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCPlayerControllerComponent::GCPlayerControllerComponent(void *ptr) {
    m_ptr = ptr;
}
GCNetworkVarChainer GCPlayerControllerComponent::Get__pChainEntity() const {
    GCNetworkVarChainer value(GetSchemaPtr(m_ptr, "CPlayerControllerComponent", "__m_pChainEntity"));
    return value;
}
void GCPlayerControllerComponent::Set__pChainEntity(GCNetworkVarChainer value) {
    SetSchemaValue(m_ptr, "CPlayerControllerComponent", "__m_pChainEntity", false, value);
}
std::string GCPlayerControllerComponent::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCPlayerControllerComponent::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCPlayerControllerComponent(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCPlayerControllerComponent>("CPlayerControllerComponent")
        .addConstructor<void (*)(std::string)>()
        .addProperty("__pChainEntity", &GCPlayerControllerComponent::Get__pChainEntity, &GCPlayerControllerComponent::Set__pChainEntity)
        .addFunction("ToPtr", &GCPlayerControllerComponent::ToPtr)
        .addFunction("IsValid", &GCPlayerControllerComponent::IsValid)
        .endClass();
}
GCWeaponBaseItem::GCWeaponBaseItem(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCWeaponBaseItem::GCWeaponBaseItem(void *ptr) {
    m_ptr = ptr;
}
GCountdownTimer GCWeaponBaseItem::GetSequenceCompleteTimer() const {
    GCountdownTimer value(GetSchemaPtr(m_ptr, "CWeaponBaseItem", "m_SequenceCompleteTimer"));
    return value;
}
void GCWeaponBaseItem::SetSequenceCompleteTimer(GCountdownTimer value) {
    SetSchemaValue(m_ptr, "CWeaponBaseItem", "m_SequenceCompleteTimer", false, value);
}
bool GCWeaponBaseItem::GetRedraw() const {
    return GetSchemaValue<bool>(m_ptr, "CWeaponBaseItem", "m_bRedraw");
}
void GCWeaponBaseItem::SetRedraw(bool value) {
    SetSchemaValue(m_ptr, "CWeaponBaseItem", "m_bRedraw", false, value);
}
std::string GCWeaponBaseItem::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCWeaponBaseItem::IsValid() {
    return (m_ptr != nullptr);
}
GCCSWeaponBase GCWeaponBaseItem::GetParent() const {
    GCCSWeaponBase value(m_ptr);
    return value;
}
void GCWeaponBaseItem::SetParent(GCCSWeaponBase value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCWeaponBaseItem(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCWeaponBaseItem>("CWeaponBaseItem")
        .addConstructor<void (*)(std::string)>()
        .addProperty("SequenceCompleteTimer", &GCWeaponBaseItem::GetSequenceCompleteTimer, &GCWeaponBaseItem::SetSequenceCompleteTimer)
        .addProperty("Redraw", &GCWeaponBaseItem::GetRedraw, &GCWeaponBaseItem::SetRedraw)
        .addProperty("Parent", &GCWeaponBaseItem::GetParent, &GCWeaponBaseItem::SetParent)
        .addFunction("ToPtr", &GCWeaponBaseItem::ToPtr)
        .addFunction("IsValid", &GCWeaponBaseItem::IsValid)
        .endClass();
}
GCBaseCombatCharacter::GCBaseCombatCharacter(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCBaseCombatCharacter::GCBaseCombatCharacter(void *ptr) {
    m_ptr = ptr;
}
bool GCBaseCombatCharacter::GetForceServerRagdoll() const {
    return GetSchemaValue<bool>(m_ptr, "CBaseCombatCharacter", "m_bForceServerRagdoll");
}
void GCBaseCombatCharacter::SetForceServerRagdoll(bool value) {
    SetSchemaValue(m_ptr, "CBaseCombatCharacter", "m_bForceServerRagdoll", false, value);
}
std::vector<GCEconWearable*> GCBaseCombatCharacter::GetMyWearables() const {
    CUtlVector<GCEconWearable*>* vec = GetSchemaValue<CUtlVector<GCEconWearable*>*>(m_ptr, "CBaseCombatCharacter", "m_hMyWearables"); std::vector<GCEconWearable*> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCBaseCombatCharacter::SetMyWearables(std::vector<GCEconWearable*> value) {
    SetSchemaValueCUtlVector<GCEconWearable*>(m_ptr, "CBaseCombatCharacter", "m_hMyWearables", false, value);
}
float GCBaseCombatCharacter::GetFieldOfView() const {
    return GetSchemaValue<float>(m_ptr, "CBaseCombatCharacter", "m_flFieldOfView");
}
void GCBaseCombatCharacter::SetFieldOfView(float value) {
    SetSchemaValue(m_ptr, "CBaseCombatCharacter", "m_flFieldOfView", false, value);
}
float GCBaseCombatCharacter::GetImpactEnergyScale() const {
    return GetSchemaValue<float>(m_ptr, "CBaseCombatCharacter", "m_impactEnergyScale");
}
void GCBaseCombatCharacter::SetImpactEnergyScale(float value) {
    SetSchemaValue(m_ptr, "CBaseCombatCharacter", "m_impactEnergyScale", false, value);
}
uint64_t GCBaseCombatCharacter::GetLastHitGroup() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CBaseCombatCharacter", "m_LastHitGroup");
}
void GCBaseCombatCharacter::SetLastHitGroup(uint64_t value) {
    SetSchemaValue(m_ptr, "CBaseCombatCharacter", "m_LastHitGroup", false, value);
}
bool GCBaseCombatCharacter::GetApplyStressDamage() const {
    return GetSchemaValue<bool>(m_ptr, "CBaseCombatCharacter", "m_bApplyStressDamage");
}
void GCBaseCombatCharacter::SetApplyStressDamage(bool value) {
    SetSchemaValue(m_ptr, "CBaseCombatCharacter", "m_bApplyStressDamage", false, value);
}
int32_t GCBaseCombatCharacter::GetDamageCount() const {
    return GetSchemaValue<int32_t>(m_ptr, "CBaseCombatCharacter", "m_iDamageCount");
}
void GCBaseCombatCharacter::SetDamageCount(int32_t value) {
    SetSchemaValue(m_ptr, "CBaseCombatCharacter", "m_iDamageCount", false, value);
}
std::string GCBaseCombatCharacter::GetStrRelationships() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CBaseCombatCharacter", "m_strRelationships").String();
}
void GCBaseCombatCharacter::SetStrRelationships(std::string value) {
    SetSchemaValue(m_ptr, "CBaseCombatCharacter", "m_strRelationships", false, CUtlSymbolLarge(value.c_str()));
}
uint64_t GCBaseCombatCharacter::GetHull() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CBaseCombatCharacter", "m_eHull");
}
void GCBaseCombatCharacter::SetHull(uint64_t value) {
    SetSchemaValue(m_ptr, "CBaseCombatCharacter", "m_eHull", false, value);
}
uint32_t GCBaseCombatCharacter::GetNavHullIdx() const {
    return GetSchemaValue<uint32_t>(m_ptr, "CBaseCombatCharacter", "m_nNavHullIdx");
}
void GCBaseCombatCharacter::SetNavHullIdx(uint32_t value) {
    SetSchemaValue(m_ptr, "CBaseCombatCharacter", "m_nNavHullIdx", false, value);
}
std::string GCBaseCombatCharacter::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCBaseCombatCharacter::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseFlex GCBaseCombatCharacter::GetParent() const {
    GCBaseFlex value(m_ptr);
    return value;
}
void GCBaseCombatCharacter::SetParent(GCBaseFlex value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCBaseCombatCharacter(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCBaseCombatCharacter>("CBaseCombatCharacter")
        .addConstructor<void (*)(std::string)>()
        .addProperty("ForceServerRagdoll", &GCBaseCombatCharacter::GetForceServerRagdoll, &GCBaseCombatCharacter::SetForceServerRagdoll)
        .addProperty("MyWearables", &GCBaseCombatCharacter::GetMyWearables, &GCBaseCombatCharacter::SetMyWearables)
        .addProperty("FieldOfView", &GCBaseCombatCharacter::GetFieldOfView, &GCBaseCombatCharacter::SetFieldOfView)
        .addProperty("ImpactEnergyScale", &GCBaseCombatCharacter::GetImpactEnergyScale, &GCBaseCombatCharacter::SetImpactEnergyScale)
        .addProperty("LastHitGroup", &GCBaseCombatCharacter::GetLastHitGroup, &GCBaseCombatCharacter::SetLastHitGroup)
        .addProperty("ApplyStressDamage", &GCBaseCombatCharacter::GetApplyStressDamage, &GCBaseCombatCharacter::SetApplyStressDamage)
        .addProperty("DamageCount", &GCBaseCombatCharacter::GetDamageCount, &GCBaseCombatCharacter::SetDamageCount)
        .addProperty("StrRelationships", &GCBaseCombatCharacter::GetStrRelationships, &GCBaseCombatCharacter::SetStrRelationships)
        .addProperty("Hull", &GCBaseCombatCharacter::GetHull, &GCBaseCombatCharacter::SetHull)
        .addProperty("NavHullIdx", &GCBaseCombatCharacter::GetNavHullIdx, &GCBaseCombatCharacter::SetNavHullIdx)
        .addProperty("Parent", &GCBaseCombatCharacter::GetParent, &GCBaseCombatCharacter::SetParent)
        .addFunction("ToPtr", &GCBaseCombatCharacter::ToPtr)
        .addFunction("IsValid", &GCBaseCombatCharacter::IsValid)
        .endClass();
}
GCMultiSource::GCMultiSource(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCMultiSource::GCMultiSource(void *ptr) {
    m_ptr = ptr;
}
std::vector<GCBaseEntity*> GCMultiSource::GetRgEntities() const {
    GCBaseEntity** outValue = GetSchemaValue<GCBaseEntity**>(m_ptr, "CMultiSource", "m_rgEntities"); std::vector<GCBaseEntity*> ret; for(int i = 0; i < 32; i++) { ret.push_back(outValue[i]); } return ret;
}
void GCMultiSource::SetRgEntities(std::vector<GCBaseEntity*> value) {
    GCBaseEntity** outValue = GetSchemaValue<GCBaseEntity**>(m_ptr, "CMultiSource", "m_rgEntities"); for(int i = 0; i < 32; i++) { outValue[i] = value[i]; } SetSchemaValue(m_ptr, "CMultiSource", "m_rgEntities", false, outValue);
}
std::vector<int32_t> GCMultiSource::GetRgTriggered() const {
    int32_t* outValue = GetSchemaValue<int32_t*>(m_ptr, "CMultiSource", "m_rgTriggered"); std::vector<int32_t> ret; for(int i = 0; i < 32; i++) { ret.push_back(outValue[i]); } return ret;
}
void GCMultiSource::SetRgTriggered(std::vector<int32_t> value) {
    int32_t* outValue = GetSchemaValue<int32_t*>(m_ptr, "CMultiSource", "m_rgTriggered"); for(int i = 0; i < 32; i++) { outValue[i] = value[i]; } SetSchemaValue(m_ptr, "CMultiSource", "m_rgTriggered", false, outValue);
}
GCEntityIOOutput GCMultiSource::GetOnTrigger() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CMultiSource", "m_OnTrigger"));
    return value;
}
void GCMultiSource::SetOnTrigger(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CMultiSource", "m_OnTrigger", false, value);
}
int32_t GCMultiSource::GetTotal() const {
    return GetSchemaValue<int32_t>(m_ptr, "CMultiSource", "m_iTotal");
}
void GCMultiSource::SetTotal(int32_t value) {
    SetSchemaValue(m_ptr, "CMultiSource", "m_iTotal", false, value);
}
std::string GCMultiSource::GetGlobalstate() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CMultiSource", "m_globalstate").String();
}
void GCMultiSource::SetGlobalstate(std::string value) {
    SetSchemaValue(m_ptr, "CMultiSource", "m_globalstate", false, CUtlSymbolLarge(value.c_str()));
}
std::string GCMultiSource::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCMultiSource::IsValid() {
    return (m_ptr != nullptr);
}
GCLogicalEntity GCMultiSource::GetParent() const {
    GCLogicalEntity value(m_ptr);
    return value;
}
void GCMultiSource::SetParent(GCLogicalEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCMultiSource(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCMultiSource>("CMultiSource")
        .addConstructor<void (*)(std::string)>()
        .addProperty("RgEntities", &GCMultiSource::GetRgEntities, &GCMultiSource::SetRgEntities)
        .addProperty("RgTriggered", &GCMultiSource::GetRgTriggered, &GCMultiSource::SetRgTriggered)
        .addProperty("OnTrigger", &GCMultiSource::GetOnTrigger, &GCMultiSource::SetOnTrigger)
        .addProperty("Total", &GCMultiSource::GetTotal, &GCMultiSource::SetTotal)
        .addProperty("Globalstate", &GCMultiSource::GetGlobalstate, &GCMultiSource::SetGlobalstate)
        .addProperty("Parent", &GCMultiSource::GetParent, &GCMultiSource::SetParent)
        .addFunction("ToPtr", &GCMultiSource::ToPtr)
        .addFunction("IsValid", &GCMultiSource::IsValid)
        .endClass();
}
GCLogicNavigation::GCLogicNavigation(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCLogicNavigation::GCLogicNavigation(void *ptr) {
    m_ptr = ptr;
}
bool GCLogicNavigation::GetIsOn() const {
    return GetSchemaValue<bool>(m_ptr, "CLogicNavigation", "m_isOn");
}
void GCLogicNavigation::SetIsOn(bool value) {
    SetSchemaValue(m_ptr, "CLogicNavigation", "m_isOn", false, value);
}
uint64_t GCLogicNavigation::GetNavProperty() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CLogicNavigation", "m_navProperty");
}
void GCLogicNavigation::SetNavProperty(uint64_t value) {
    SetSchemaValue(m_ptr, "CLogicNavigation", "m_navProperty", false, value);
}
std::string GCLogicNavigation::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCLogicNavigation::IsValid() {
    return (m_ptr != nullptr);
}
GCLogicalEntity GCLogicNavigation::GetParent() const {
    GCLogicalEntity value(m_ptr);
    return value;
}
void GCLogicNavigation::SetParent(GCLogicalEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCLogicNavigation(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCLogicNavigation>("CLogicNavigation")
        .addConstructor<void (*)(std::string)>()
        .addProperty("IsOn", &GCLogicNavigation::GetIsOn, &GCLogicNavigation::SetIsOn)
        .addProperty("NavProperty", &GCLogicNavigation::GetNavProperty, &GCLogicNavigation::SetNavProperty)
        .addProperty("Parent", &GCLogicNavigation::GetParent, &GCLogicNavigation::SetParent)
        .addFunction("ToPtr", &GCLogicNavigation::ToPtr)
        .addFunction("IsValid", &GCLogicNavigation::IsValid)
        .endClass();
}
GCEnvEntityMaker::GCEnvEntityMaker(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCEnvEntityMaker::GCEnvEntityMaker(void *ptr) {
    m_ptr = ptr;
}
Vector GCEnvEntityMaker::GetEntityMins() const {
    return GetSchemaValue<Vector>(m_ptr, "CEnvEntityMaker", "m_vecEntityMins");
}
void GCEnvEntityMaker::SetEntityMins(Vector value) {
    SetSchemaValue(m_ptr, "CEnvEntityMaker", "m_vecEntityMins", false, value);
}
Vector GCEnvEntityMaker::GetEntityMaxs() const {
    return GetSchemaValue<Vector>(m_ptr, "CEnvEntityMaker", "m_vecEntityMaxs");
}
void GCEnvEntityMaker::SetEntityMaxs(Vector value) {
    SetSchemaValue(m_ptr, "CEnvEntityMaker", "m_vecEntityMaxs", false, value);
}
GCBaseEntity GCEnvEntityMaker::GetCurrentInstance() const {
    GCBaseEntity value(*GetSchemaValuePtr<void*>(m_ptr, "CEnvEntityMaker", "m_hCurrentInstance"));
    return value;
}
void GCEnvEntityMaker::SetCurrentInstance(GCBaseEntity* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'CurrentInstance' is not possible.\n");
}
GCBaseEntity GCEnvEntityMaker::GetCurrentBlocker() const {
    GCBaseEntity value(*GetSchemaValuePtr<void*>(m_ptr, "CEnvEntityMaker", "m_hCurrentBlocker"));
    return value;
}
void GCEnvEntityMaker::SetCurrentBlocker(GCBaseEntity* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'CurrentBlocker' is not possible.\n");
}
Vector GCEnvEntityMaker::GetBlockerOrigin() const {
    return GetSchemaValue<Vector>(m_ptr, "CEnvEntityMaker", "m_vecBlockerOrigin");
}
void GCEnvEntityMaker::SetBlockerOrigin(Vector value) {
    SetSchemaValue(m_ptr, "CEnvEntityMaker", "m_vecBlockerOrigin", false, value);
}
QAngle GCEnvEntityMaker::GetPostSpawnDirection() const {
    return GetSchemaValue<QAngle>(m_ptr, "CEnvEntityMaker", "m_angPostSpawnDirection");
}
void GCEnvEntityMaker::SetPostSpawnDirection(QAngle value) {
    SetSchemaValue(m_ptr, "CEnvEntityMaker", "m_angPostSpawnDirection", false, value);
}
float GCEnvEntityMaker::GetPostSpawnDirectionVariance() const {
    return GetSchemaValue<float>(m_ptr, "CEnvEntityMaker", "m_flPostSpawnDirectionVariance");
}
void GCEnvEntityMaker::SetPostSpawnDirectionVariance(float value) {
    SetSchemaValue(m_ptr, "CEnvEntityMaker", "m_flPostSpawnDirectionVariance", false, value);
}
float GCEnvEntityMaker::GetPostSpawnSpeed() const {
    return GetSchemaValue<float>(m_ptr, "CEnvEntityMaker", "m_flPostSpawnSpeed");
}
void GCEnvEntityMaker::SetPostSpawnSpeed(float value) {
    SetSchemaValue(m_ptr, "CEnvEntityMaker", "m_flPostSpawnSpeed", false, value);
}
bool GCEnvEntityMaker::GetPostSpawnUseAngles() const {
    return GetSchemaValue<bool>(m_ptr, "CEnvEntityMaker", "m_bPostSpawnUseAngles");
}
void GCEnvEntityMaker::SetPostSpawnUseAngles(bool value) {
    SetSchemaValue(m_ptr, "CEnvEntityMaker", "m_bPostSpawnUseAngles", false, value);
}
std::string GCEnvEntityMaker::GetTemplate() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CEnvEntityMaker", "m_iszTemplate").String();
}
void GCEnvEntityMaker::SetTemplate(std::string value) {
    SetSchemaValue(m_ptr, "CEnvEntityMaker", "m_iszTemplate", false, CUtlSymbolLarge(value.c_str()));
}
GCEntityIOOutput GCEnvEntityMaker::GetOutputOnSpawned() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CEnvEntityMaker", "m_pOutputOnSpawned"));
    return value;
}
void GCEnvEntityMaker::SetOutputOnSpawned(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CEnvEntityMaker", "m_pOutputOnSpawned", false, value);
}
GCEntityIOOutput GCEnvEntityMaker::GetOutputOnFailedSpawn() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CEnvEntityMaker", "m_pOutputOnFailedSpawn"));
    return value;
}
void GCEnvEntityMaker::SetOutputOnFailedSpawn(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CEnvEntityMaker", "m_pOutputOnFailedSpawn", false, value);
}
std::string GCEnvEntityMaker::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCEnvEntityMaker::IsValid() {
    return (m_ptr != nullptr);
}
GCPointEntity GCEnvEntityMaker::GetParent() const {
    GCPointEntity value(m_ptr);
    return value;
}
void GCEnvEntityMaker::SetParent(GCPointEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCEnvEntityMaker(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCEnvEntityMaker>("CEnvEntityMaker")
        .addConstructor<void (*)(std::string)>()
        .addProperty("EntityMins", &GCEnvEntityMaker::GetEntityMins, &GCEnvEntityMaker::SetEntityMins)
        .addProperty("EntityMaxs", &GCEnvEntityMaker::GetEntityMaxs, &GCEnvEntityMaker::SetEntityMaxs)
        .addProperty("CurrentInstance", &GCEnvEntityMaker::GetCurrentInstance, &GCEnvEntityMaker::SetCurrentInstance)
        .addProperty("CurrentBlocker", &GCEnvEntityMaker::GetCurrentBlocker, &GCEnvEntityMaker::SetCurrentBlocker)
        .addProperty("BlockerOrigin", &GCEnvEntityMaker::GetBlockerOrigin, &GCEnvEntityMaker::SetBlockerOrigin)
        .addProperty("PostSpawnDirection", &GCEnvEntityMaker::GetPostSpawnDirection, &GCEnvEntityMaker::SetPostSpawnDirection)
        .addProperty("PostSpawnDirectionVariance", &GCEnvEntityMaker::GetPostSpawnDirectionVariance, &GCEnvEntityMaker::SetPostSpawnDirectionVariance)
        .addProperty("PostSpawnSpeed", &GCEnvEntityMaker::GetPostSpawnSpeed, &GCEnvEntityMaker::SetPostSpawnSpeed)
        .addProperty("PostSpawnUseAngles", &GCEnvEntityMaker::GetPostSpawnUseAngles, &GCEnvEntityMaker::SetPostSpawnUseAngles)
        .addProperty("Template", &GCEnvEntityMaker::GetTemplate, &GCEnvEntityMaker::SetTemplate)
        .addProperty("OutputOnSpawned", &GCEnvEntityMaker::GetOutputOnSpawned, &GCEnvEntityMaker::SetOutputOnSpawned)
        .addProperty("OutputOnFailedSpawn", &GCEnvEntityMaker::GetOutputOnFailedSpawn, &GCEnvEntityMaker::SetOutputOnFailedSpawn)
        .addProperty("Parent", &GCEnvEntityMaker::GetParent, &GCEnvEntityMaker::SetParent)
        .addFunction("ToPtr", &GCEnvEntityMaker::ToPtr)
        .addFunction("IsValid", &GCEnvEntityMaker::IsValid)
        .endClass();
}
GCProjectedDecal::GCProjectedDecal(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCProjectedDecal::GCProjectedDecal(void *ptr) {
    m_ptr = ptr;
}
int32_t GCProjectedDecal::GetTexture() const {
    return GetSchemaValue<int32_t>(m_ptr, "CProjectedDecal", "m_nTexture");
}
void GCProjectedDecal::SetTexture(int32_t value) {
    SetSchemaValue(m_ptr, "CProjectedDecal", "m_nTexture", false, value);
}
float GCProjectedDecal::GetDistance() const {
    return GetSchemaValue<float>(m_ptr, "CProjectedDecal", "m_flDistance");
}
void GCProjectedDecal::SetDistance(float value) {
    SetSchemaValue(m_ptr, "CProjectedDecal", "m_flDistance", false, value);
}
std::string GCProjectedDecal::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCProjectedDecal::IsValid() {
    return (m_ptr != nullptr);
}
GCPointEntity GCProjectedDecal::GetParent() const {
    GCPointEntity value(m_ptr);
    return value;
}
void GCProjectedDecal::SetParent(GCPointEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCProjectedDecal(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCProjectedDecal>("CProjectedDecal")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Texture", &GCProjectedDecal::GetTexture, &GCProjectedDecal::SetTexture)
        .addProperty("Distance", &GCProjectedDecal::GetDistance, &GCProjectedDecal::SetDistance)
        .addProperty("Parent", &GCProjectedDecal::GetParent, &GCProjectedDecal::SetParent)
        .addFunction("ToPtr", &GCProjectedDecal::ToPtr)
        .addFunction("IsValid", &GCProjectedDecal::IsValid)
        .endClass();
}
GCLogicEventListener::GCLogicEventListener(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCLogicEventListener::GCLogicEventListener(void *ptr) {
    m_ptr = ptr;
}
std::string GCLogicEventListener::GetStrEventName() const {
    return GetSchemaValue<CUtlString>(m_ptr, "CLogicEventListener", "m_strEventName").Get();
}
void GCLogicEventListener::SetStrEventName(std::string value) {
    SetSchemaValue(m_ptr, "CLogicEventListener", "m_strEventName", false, CUtlString(value.c_str()));
}
bool GCLogicEventListener::GetIsEnabled() const {
    return GetSchemaValue<bool>(m_ptr, "CLogicEventListener", "m_bIsEnabled");
}
void GCLogicEventListener::SetIsEnabled(bool value) {
    SetSchemaValue(m_ptr, "CLogicEventListener", "m_bIsEnabled", false, value);
}
int32_t GCLogicEventListener::GetTeam() const {
    return GetSchemaValue<int32_t>(m_ptr, "CLogicEventListener", "m_nTeam");
}
void GCLogicEventListener::SetTeam(int32_t value) {
    SetSchemaValue(m_ptr, "CLogicEventListener", "m_nTeam", false, value);
}
GCEntityIOOutput GCLogicEventListener::GetOnEventFired() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CLogicEventListener", "m_OnEventFired"));
    return value;
}
void GCLogicEventListener::SetOnEventFired(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CLogicEventListener", "m_OnEventFired", false, value);
}
std::string GCLogicEventListener::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCLogicEventListener::IsValid() {
    return (m_ptr != nullptr);
}
GCLogicalEntity GCLogicEventListener::GetParent() const {
    GCLogicalEntity value(m_ptr);
    return value;
}
void GCLogicEventListener::SetParent(GCLogicalEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCLogicEventListener(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCLogicEventListener>("CLogicEventListener")
        .addConstructor<void (*)(std::string)>()
        .addProperty("StrEventName", &GCLogicEventListener::GetStrEventName, &GCLogicEventListener::SetStrEventName)
        .addProperty("IsEnabled", &GCLogicEventListener::GetIsEnabled, &GCLogicEventListener::SetIsEnabled)
        .addProperty("Team", &GCLogicEventListener::GetTeam, &GCLogicEventListener::SetTeam)
        .addProperty("OnEventFired", &GCLogicEventListener::GetOnEventFired, &GCLogicEventListener::SetOnEventFired)
        .addProperty("Parent", &GCLogicEventListener::GetParent, &GCLogicEventListener::SetParent)
        .addFunction("ToPtr", &GCLogicEventListener::ToPtr)
        .addFunction("IsValid", &GCLogicEventListener::IsValid)
        .endClass();
}
GCFilterMultiple::GCFilterMultiple(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCFilterMultiple::GCFilterMultiple(void *ptr) {
    m_ptr = ptr;
}
uint64_t GCFilterMultiple::GetFilterType() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CFilterMultiple", "m_nFilterType");
}
void GCFilterMultiple::SetFilterType(uint64_t value) {
    SetSchemaValue(m_ptr, "CFilterMultiple", "m_nFilterType", false, value);
}
std::vector<CUtlSymbolLarge> GCFilterMultiple::GetFilterName() const {
    CUtlSymbolLarge* outValue = GetSchemaValue<CUtlSymbolLarge*>(m_ptr, "CFilterMultiple", "m_iFilterName"); std::vector<CUtlSymbolLarge> ret; for(int i = 0; i < 10; i++) { ret.push_back(outValue[i]); } return ret;
}
void GCFilterMultiple::SetFilterName(std::vector<CUtlSymbolLarge> value) {
    CUtlSymbolLarge* outValue = GetSchemaValue<CUtlSymbolLarge*>(m_ptr, "CFilterMultiple", "m_iFilterName"); for(int i = 0; i < 10; i++) { outValue[i] = value[i]; } SetSchemaValue(m_ptr, "CFilterMultiple", "m_iFilterName", false, outValue);
}
std::vector<GCBaseEntity*> GCFilterMultiple::GetFilter() const {
    GCBaseEntity** outValue = GetSchemaValue<GCBaseEntity**>(m_ptr, "CFilterMultiple", "m_hFilter"); std::vector<GCBaseEntity*> ret; for(int i = 0; i < 10; i++) { ret.push_back(outValue[i]); } return ret;
}
void GCFilterMultiple::SetFilter(std::vector<GCBaseEntity*> value) {
    GCBaseEntity** outValue = GetSchemaValue<GCBaseEntity**>(m_ptr, "CFilterMultiple", "m_hFilter"); for(int i = 0; i < 10; i++) { outValue[i] = value[i]; } SetSchemaValue(m_ptr, "CFilterMultiple", "m_hFilter", false, outValue);
}
int32_t GCFilterMultiple::GetFilterCount() const {
    return GetSchemaValue<int32_t>(m_ptr, "CFilterMultiple", "m_nFilterCount");
}
void GCFilterMultiple::SetFilterCount(int32_t value) {
    SetSchemaValue(m_ptr, "CFilterMultiple", "m_nFilterCount", false, value);
}
std::string GCFilterMultiple::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCFilterMultiple::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseFilter GCFilterMultiple::GetParent() const {
    GCBaseFilter value(m_ptr);
    return value;
}
void GCFilterMultiple::SetParent(GCBaseFilter value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCFilterMultiple(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCFilterMultiple>("CFilterMultiple")
        .addConstructor<void (*)(std::string)>()
        .addProperty("FilterType", &GCFilterMultiple::GetFilterType, &GCFilterMultiple::SetFilterType)
        .addProperty("FilterName", &GCFilterMultiple::GetFilterName, &GCFilterMultiple::SetFilterName)
        .addProperty("Filter", &GCFilterMultiple::GetFilter, &GCFilterMultiple::SetFilter)
        .addProperty("FilterCount", &GCFilterMultiple::GetFilterCount, &GCFilterMultiple::SetFilterCount)
        .addProperty("Parent", &GCFilterMultiple::GetParent, &GCFilterMultiple::SetParent)
        .addFunction("ToPtr", &GCFilterMultiple::ToPtr)
        .addFunction("IsValid", &GCFilterMultiple::IsValid)
        .endClass();
}
GCPlayer_UseServices::GCPlayer_UseServices(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCPlayer_UseServices::GCPlayer_UseServices(void *ptr) {
    m_ptr = ptr;
}
std::string GCPlayer_UseServices::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCPlayer_UseServices::IsValid() {
    return (m_ptr != nullptr);
}
GCPlayerPawnComponent GCPlayer_UseServices::GetParent() const {
    GCPlayerPawnComponent value(m_ptr);
    return value;
}
void GCPlayer_UseServices::SetParent(GCPlayerPawnComponent value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCPlayer_UseServices(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCPlayer_UseServices>("CPlayer_UseServices")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCPlayer_UseServices::GetParent, &GCPlayer_UseServices::SetParent)
        .addFunction("ToPtr", &GCPlayer_UseServices::ToPtr)
        .addFunction("IsValid", &GCPlayer_UseServices::IsValid)
        .endClass();
}
GCScriptComponent::GCScriptComponent(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCScriptComponent::GCScriptComponent(void *ptr) {
    m_ptr = ptr;
}
std::string GCScriptComponent::GetScriptClassName() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CScriptComponent", "m_scriptClassName").String();
}
void GCScriptComponent::SetScriptClassName(std::string value) {
    SetSchemaValue(m_ptr, "CScriptComponent", "m_scriptClassName", false, CUtlSymbolLarge(value.c_str()));
}
std::string GCScriptComponent::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCScriptComponent::IsValid() {
    return (m_ptr != nullptr);
}
GCEntityComponent GCScriptComponent::GetParent() const {
    GCEntityComponent value(m_ptr);
    return value;
}
void GCScriptComponent::SetParent(GCEntityComponent value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCScriptComponent(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCScriptComponent>("CScriptComponent")
        .addConstructor<void (*)(std::string)>()
        .addProperty("ScriptClassName", &GCScriptComponent::GetScriptClassName, &GCScriptComponent::SetScriptClassName)
        .addProperty("Parent", &GCScriptComponent::GetParent, &GCScriptComponent::SetParent)
        .addFunction("ToPtr", &GCScriptComponent::ToPtr)
        .addFunction("IsValid", &GCScriptComponent::IsValid)
        .endClass();
}
GCPhysicsWire::GCPhysicsWire(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCPhysicsWire::GCPhysicsWire(void *ptr) {
    m_ptr = ptr;
}
int32_t GCPhysicsWire::GetDensity() const {
    return GetSchemaValue<int32_t>(m_ptr, "CPhysicsWire", "m_nDensity");
}
void GCPhysicsWire::SetDensity(int32_t value) {
    SetSchemaValue(m_ptr, "CPhysicsWire", "m_nDensity", false, value);
}
std::string GCPhysicsWire::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCPhysicsWire::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseEntity GCPhysicsWire::GetParent() const {
    GCBaseEntity value(m_ptr);
    return value;
}
void GCPhysicsWire::SetParent(GCBaseEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCPhysicsWire(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCPhysicsWire>("CPhysicsWire")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Density", &GCPhysicsWire::GetDensity, &GCPhysicsWire::SetDensity)
        .addProperty("Parent", &GCPhysicsWire::GetParent, &GCPhysicsWire::SetParent)
        .addFunction("ToPtr", &GCPhysicsWire::ToPtr)
        .addFunction("IsValid", &GCPhysicsWire::IsValid)
        .endClass();
}
Glocksound_t::Glocksound_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
Glocksound_t::Glocksound_t(void *ptr) {
    m_ptr = ptr;
}
std::string Glocksound_t::GetLockedSound() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "locksound_t", "sLockedSound").String();
}
void Glocksound_t::SetLockedSound(std::string value) {
    SetSchemaValue(m_ptr, "locksound_t", "sLockedSound", true, CUtlSymbolLarge(value.c_str()));
}
std::string Glocksound_t::GetUnlockedSound() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "locksound_t", "sUnlockedSound").String();
}
void Glocksound_t::SetUnlockedSound(std::string value) {
    SetSchemaValue(m_ptr, "locksound_t", "sUnlockedSound", true, CUtlSymbolLarge(value.c_str()));
}
float Glocksound_t::GetFlwaitSound() const {
    return GetSchemaValue<float>(m_ptr, "locksound_t", "flwaitSound");
}
void Glocksound_t::SetFlwaitSound(float value) {
    SetSchemaValue(m_ptr, "locksound_t", "flwaitSound", true, value);
}
std::string Glocksound_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool Glocksound_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClasslocksound_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<Glocksound_t>("locksound_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("LockedSound", &Glocksound_t::GetLockedSound, &Glocksound_t::SetLockedSound)
        .addProperty("UnlockedSound", &Glocksound_t::GetUnlockedSound, &Glocksound_t::SetUnlockedSound)
        .addProperty("FlwaitSound", &Glocksound_t::GetFlwaitSound, &Glocksound_t::SetFlwaitSound)
        .addFunction("ToPtr", &Glocksound_t::ToPtr)
        .addFunction("IsValid", &Glocksound_t::IsValid)
        .endClass();
}
GCCSPointScriptExtensions_player_controller::GCCSPointScriptExtensions_player_controller(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCCSPointScriptExtensions_player_controller::GCCSPointScriptExtensions_player_controller(void *ptr) {
    m_ptr = ptr;
}
std::string GCCSPointScriptExtensions_player_controller::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCCSPointScriptExtensions_player_controller::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCCSPointScriptExtensions_player_controller(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCCSPointScriptExtensions_player_controller>("CCSPointScriptExtensions_player_controller")
        .addConstructor<void (*)(std::string)>()
        .addFunction("ToPtr", &GCCSPointScriptExtensions_player_controller::ToPtr)
        .addFunction("IsValid", &GCCSPointScriptExtensions_player_controller::IsValid)
        .endClass();
}
GCBaseFire::GCBaseFire(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCBaseFire::GCBaseFire(void *ptr) {
    m_ptr = ptr;
}
float GCBaseFire::GetScale() const {
    return GetSchemaValue<float>(m_ptr, "CBaseFire", "m_flScale");
}
void GCBaseFire::SetScale(float value) {
    SetSchemaValue(m_ptr, "CBaseFire", "m_flScale", false, value);
}
float GCBaseFire::GetStartScale() const {
    return GetSchemaValue<float>(m_ptr, "CBaseFire", "m_flStartScale");
}
void GCBaseFire::SetStartScale(float value) {
    SetSchemaValue(m_ptr, "CBaseFire", "m_flStartScale", false, value);
}
float GCBaseFire::GetScaleTime() const {
    return GetSchemaValue<float>(m_ptr, "CBaseFire", "m_flScaleTime");
}
void GCBaseFire::SetScaleTime(float value) {
    SetSchemaValue(m_ptr, "CBaseFire", "m_flScaleTime", false, value);
}
uint32_t GCBaseFire::GetFlags() const {
    return GetSchemaValue<uint32_t>(m_ptr, "CBaseFire", "m_nFlags");
}
void GCBaseFire::SetFlags(uint32_t value) {
    SetSchemaValue(m_ptr, "CBaseFire", "m_nFlags", false, value);
}
std::string GCBaseFire::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCBaseFire::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseEntity GCBaseFire::GetParent() const {
    GCBaseEntity value(m_ptr);
    return value;
}
void GCBaseFire::SetParent(GCBaseEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCBaseFire(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCBaseFire>("CBaseFire")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Scale", &GCBaseFire::GetScale, &GCBaseFire::SetScale)
        .addProperty("StartScale", &GCBaseFire::GetStartScale, &GCBaseFire::SetStartScale)
        .addProperty("ScaleTime", &GCBaseFire::GetScaleTime, &GCBaseFire::SetScaleTime)
        .addProperty("Flags", &GCBaseFire::GetFlags, &GCBaseFire::SetFlags)
        .addProperty("Parent", &GCBaseFire::GetParent, &GCBaseFire::SetParent)
        .addFunction("ToPtr", &GCBaseFire::ToPtr)
        .addFunction("IsValid", &GCBaseFire::IsValid)
        .endClass();
}
GCBumpMine::GCBumpMine(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCBumpMine::GCBumpMine(void *ptr) {
    m_ptr = ptr;
}
std::string GCBumpMine::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCBumpMine::IsValid() {
    return (m_ptr != nullptr);
}
GCCSWeaponBase GCBumpMine::GetParent() const {
    GCCSWeaponBase value(m_ptr);
    return value;
}
void GCBumpMine::SetParent(GCCSWeaponBase value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCBumpMine(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCBumpMine>("CBumpMine")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCBumpMine::GetParent, &GCBumpMine::SetParent)
        .addFunction("ToPtr", &GCBumpMine::ToPtr)
        .addFunction("IsValid", &GCBumpMine::IsValid)
        .endClass();
}
GCLightGlow::GCLightGlow(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCLightGlow::GCLightGlow(void *ptr) {
    m_ptr = ptr;
}
uint32_t GCLightGlow::GetHorizontalSize() const {
    return GetSchemaValue<uint32_t>(m_ptr, "CLightGlow", "m_nHorizontalSize");
}
void GCLightGlow::SetHorizontalSize(uint32_t value) {
    SetSchemaValue(m_ptr, "CLightGlow", "m_nHorizontalSize", false, value);
}
uint32_t GCLightGlow::GetVerticalSize() const {
    return GetSchemaValue<uint32_t>(m_ptr, "CLightGlow", "m_nVerticalSize");
}
void GCLightGlow::SetVerticalSize(uint32_t value) {
    SetSchemaValue(m_ptr, "CLightGlow", "m_nVerticalSize", false, value);
}
uint32_t GCLightGlow::GetMinDist() const {
    return GetSchemaValue<uint32_t>(m_ptr, "CLightGlow", "m_nMinDist");
}
void GCLightGlow::SetMinDist(uint32_t value) {
    SetSchemaValue(m_ptr, "CLightGlow", "m_nMinDist", false, value);
}
uint32_t GCLightGlow::GetMaxDist() const {
    return GetSchemaValue<uint32_t>(m_ptr, "CLightGlow", "m_nMaxDist");
}
void GCLightGlow::SetMaxDist(uint32_t value) {
    SetSchemaValue(m_ptr, "CLightGlow", "m_nMaxDist", false, value);
}
uint32_t GCLightGlow::GetOuterMaxDist() const {
    return GetSchemaValue<uint32_t>(m_ptr, "CLightGlow", "m_nOuterMaxDist");
}
void GCLightGlow::SetOuterMaxDist(uint32_t value) {
    SetSchemaValue(m_ptr, "CLightGlow", "m_nOuterMaxDist", false, value);
}
float GCLightGlow::GetGlowProxySize() const {
    return GetSchemaValue<float>(m_ptr, "CLightGlow", "m_flGlowProxySize");
}
void GCLightGlow::SetGlowProxySize(float value) {
    SetSchemaValue(m_ptr, "CLightGlow", "m_flGlowProxySize", false, value);
}
float GCLightGlow::GetHDRColorScale() const {
    return GetSchemaValue<float>(m_ptr, "CLightGlow", "m_flHDRColorScale");
}
void GCLightGlow::SetHDRColorScale(float value) {
    SetSchemaValue(m_ptr, "CLightGlow", "m_flHDRColorScale", false, value);
}
std::string GCLightGlow::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCLightGlow::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseModelEntity GCLightGlow::GetParent() const {
    GCBaseModelEntity value(m_ptr);
    return value;
}
void GCLightGlow::SetParent(GCBaseModelEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCLightGlow(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCLightGlow>("CLightGlow")
        .addConstructor<void (*)(std::string)>()
        .addProperty("HorizontalSize", &GCLightGlow::GetHorizontalSize, &GCLightGlow::SetHorizontalSize)
        .addProperty("VerticalSize", &GCLightGlow::GetVerticalSize, &GCLightGlow::SetVerticalSize)
        .addProperty("MinDist", &GCLightGlow::GetMinDist, &GCLightGlow::SetMinDist)
        .addProperty("MaxDist", &GCLightGlow::GetMaxDist, &GCLightGlow::SetMaxDist)
        .addProperty("OuterMaxDist", &GCLightGlow::GetOuterMaxDist, &GCLightGlow::SetOuterMaxDist)
        .addProperty("GlowProxySize", &GCLightGlow::GetGlowProxySize, &GCLightGlow::SetGlowProxySize)
        .addProperty("HDRColorScale", &GCLightGlow::GetHDRColorScale, &GCLightGlow::SetHDRColorScale)
        .addProperty("Parent", &GCLightGlow::GetParent, &GCLightGlow::SetParent)
        .addFunction("ToPtr", &GCLightGlow::ToPtr)
        .addFunction("IsValid", &GCLightGlow::IsValid)
        .endClass();
}
GCSPerRoundStats_t::GCSPerRoundStats_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCSPerRoundStats_t::GCSPerRoundStats_t(void *ptr) {
    m_ptr = ptr;
}
int32_t GCSPerRoundStats_t::GetKills() const {
    return GetSchemaValue<int32_t>(m_ptr, "CSPerRoundStats_t", "m_iKills");
}
void GCSPerRoundStats_t::SetKills(int32_t value) {
    SetSchemaValue(m_ptr, "CSPerRoundStats_t", "m_iKills", true, value);
}
int32_t GCSPerRoundStats_t::GetDeaths() const {
    return GetSchemaValue<int32_t>(m_ptr, "CSPerRoundStats_t", "m_iDeaths");
}
void GCSPerRoundStats_t::SetDeaths(int32_t value) {
    SetSchemaValue(m_ptr, "CSPerRoundStats_t", "m_iDeaths", true, value);
}
int32_t GCSPerRoundStats_t::GetAssists() const {
    return GetSchemaValue<int32_t>(m_ptr, "CSPerRoundStats_t", "m_iAssists");
}
void GCSPerRoundStats_t::SetAssists(int32_t value) {
    SetSchemaValue(m_ptr, "CSPerRoundStats_t", "m_iAssists", true, value);
}
int32_t GCSPerRoundStats_t::GetDamage() const {
    return GetSchemaValue<int32_t>(m_ptr, "CSPerRoundStats_t", "m_iDamage");
}
void GCSPerRoundStats_t::SetDamage(int32_t value) {
    SetSchemaValue(m_ptr, "CSPerRoundStats_t", "m_iDamage", true, value);
}
int32_t GCSPerRoundStats_t::GetEquipmentValue() const {
    return GetSchemaValue<int32_t>(m_ptr, "CSPerRoundStats_t", "m_iEquipmentValue");
}
void GCSPerRoundStats_t::SetEquipmentValue(int32_t value) {
    SetSchemaValue(m_ptr, "CSPerRoundStats_t", "m_iEquipmentValue", true, value);
}
int32_t GCSPerRoundStats_t::GetMoneySaved() const {
    return GetSchemaValue<int32_t>(m_ptr, "CSPerRoundStats_t", "m_iMoneySaved");
}
void GCSPerRoundStats_t::SetMoneySaved(int32_t value) {
    SetSchemaValue(m_ptr, "CSPerRoundStats_t", "m_iMoneySaved", true, value);
}
int32_t GCSPerRoundStats_t::GetKillReward() const {
    return GetSchemaValue<int32_t>(m_ptr, "CSPerRoundStats_t", "m_iKillReward");
}
void GCSPerRoundStats_t::SetKillReward(int32_t value) {
    SetSchemaValue(m_ptr, "CSPerRoundStats_t", "m_iKillReward", true, value);
}
int32_t GCSPerRoundStats_t::GetLiveTime() const {
    return GetSchemaValue<int32_t>(m_ptr, "CSPerRoundStats_t", "m_iLiveTime");
}
void GCSPerRoundStats_t::SetLiveTime(int32_t value) {
    SetSchemaValue(m_ptr, "CSPerRoundStats_t", "m_iLiveTime", true, value);
}
int32_t GCSPerRoundStats_t::GetHeadShotKills() const {
    return GetSchemaValue<int32_t>(m_ptr, "CSPerRoundStats_t", "m_iHeadShotKills");
}
void GCSPerRoundStats_t::SetHeadShotKills(int32_t value) {
    SetSchemaValue(m_ptr, "CSPerRoundStats_t", "m_iHeadShotKills", true, value);
}
int32_t GCSPerRoundStats_t::GetObjective() const {
    return GetSchemaValue<int32_t>(m_ptr, "CSPerRoundStats_t", "m_iObjective");
}
void GCSPerRoundStats_t::SetObjective(int32_t value) {
    SetSchemaValue(m_ptr, "CSPerRoundStats_t", "m_iObjective", true, value);
}
int32_t GCSPerRoundStats_t::GetCashEarned() const {
    return GetSchemaValue<int32_t>(m_ptr, "CSPerRoundStats_t", "m_iCashEarned");
}
void GCSPerRoundStats_t::SetCashEarned(int32_t value) {
    SetSchemaValue(m_ptr, "CSPerRoundStats_t", "m_iCashEarned", true, value);
}
int32_t GCSPerRoundStats_t::GetUtilityDamage() const {
    return GetSchemaValue<int32_t>(m_ptr, "CSPerRoundStats_t", "m_iUtilityDamage");
}
void GCSPerRoundStats_t::SetUtilityDamage(int32_t value) {
    SetSchemaValue(m_ptr, "CSPerRoundStats_t", "m_iUtilityDamage", true, value);
}
int32_t GCSPerRoundStats_t::GetEnemiesFlashed() const {
    return GetSchemaValue<int32_t>(m_ptr, "CSPerRoundStats_t", "m_iEnemiesFlashed");
}
void GCSPerRoundStats_t::SetEnemiesFlashed(int32_t value) {
    SetSchemaValue(m_ptr, "CSPerRoundStats_t", "m_iEnemiesFlashed", true, value);
}
std::string GCSPerRoundStats_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCSPerRoundStats_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCSPerRoundStats_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCSPerRoundStats_t>("CSPerRoundStats_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Kills", &GCSPerRoundStats_t::GetKills, &GCSPerRoundStats_t::SetKills)
        .addProperty("Deaths", &GCSPerRoundStats_t::GetDeaths, &GCSPerRoundStats_t::SetDeaths)
        .addProperty("Assists", &GCSPerRoundStats_t::GetAssists, &GCSPerRoundStats_t::SetAssists)
        .addProperty("Damage", &GCSPerRoundStats_t::GetDamage, &GCSPerRoundStats_t::SetDamage)
        .addProperty("EquipmentValue", &GCSPerRoundStats_t::GetEquipmentValue, &GCSPerRoundStats_t::SetEquipmentValue)
        .addProperty("MoneySaved", &GCSPerRoundStats_t::GetMoneySaved, &GCSPerRoundStats_t::SetMoneySaved)
        .addProperty("KillReward", &GCSPerRoundStats_t::GetKillReward, &GCSPerRoundStats_t::SetKillReward)
        .addProperty("LiveTime", &GCSPerRoundStats_t::GetLiveTime, &GCSPerRoundStats_t::SetLiveTime)
        .addProperty("HeadShotKills", &GCSPerRoundStats_t::GetHeadShotKills, &GCSPerRoundStats_t::SetHeadShotKills)
        .addProperty("Objective", &GCSPerRoundStats_t::GetObjective, &GCSPerRoundStats_t::SetObjective)
        .addProperty("CashEarned", &GCSPerRoundStats_t::GetCashEarned, &GCSPerRoundStats_t::SetCashEarned)
        .addProperty("UtilityDamage", &GCSPerRoundStats_t::GetUtilityDamage, &GCSPerRoundStats_t::SetUtilityDamage)
        .addProperty("EnemiesFlashed", &GCSPerRoundStats_t::GetEnemiesFlashed, &GCSPerRoundStats_t::SetEnemiesFlashed)
        .addFunction("ToPtr", &GCSPerRoundStats_t::ToPtr)
        .addFunction("IsValid", &GCSPerRoundStats_t::IsValid)
        .endClass();
}
GCBasePropDoor::GCBasePropDoor(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCBasePropDoor::GCBasePropDoor(void *ptr) {
    m_ptr = ptr;
}
float GCBasePropDoor::GetAutoReturnDelay() const {
    return GetSchemaValue<float>(m_ptr, "CBasePropDoor", "m_flAutoReturnDelay");
}
void GCBasePropDoor::SetAutoReturnDelay(float value) {
    SetSchemaValue(m_ptr, "CBasePropDoor", "m_flAutoReturnDelay", false, value);
}
int32_t GCBasePropDoor::GetHardwareType() const {
    return GetSchemaValue<int32_t>(m_ptr, "CBasePropDoor", "m_nHardwareType");
}
void GCBasePropDoor::SetHardwareType(int32_t value) {
    SetSchemaValue(m_ptr, "CBasePropDoor", "m_nHardwareType", false, value);
}
bool GCBasePropDoor::GetNeedsHardware() const {
    return GetSchemaValue<bool>(m_ptr, "CBasePropDoor", "m_bNeedsHardware");
}
void GCBasePropDoor::SetNeedsHardware(bool value) {
    SetSchemaValue(m_ptr, "CBasePropDoor", "m_bNeedsHardware", false, value);
}
uint64_t GCBasePropDoor::GetDoorState() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CBasePropDoor", "m_eDoorState");
}
void GCBasePropDoor::SetDoorState(uint64_t value) {
    SetSchemaValue(m_ptr, "CBasePropDoor", "m_eDoorState", false, value);
}
bool GCBasePropDoor::GetLocked() const {
    return GetSchemaValue<bool>(m_ptr, "CBasePropDoor", "m_bLocked");
}
void GCBasePropDoor::SetLocked(bool value) {
    SetSchemaValue(m_ptr, "CBasePropDoor", "m_bLocked", false, value);
}
Vector GCBasePropDoor::GetClosedPosition() const {
    return GetSchemaValue<Vector>(m_ptr, "CBasePropDoor", "m_closedPosition");
}
void GCBasePropDoor::SetClosedPosition(Vector value) {
    SetSchemaValue(m_ptr, "CBasePropDoor", "m_closedPosition", false, value);
}
QAngle GCBasePropDoor::GetClosedAngles() const {
    return GetSchemaValue<QAngle>(m_ptr, "CBasePropDoor", "m_closedAngles");
}
void GCBasePropDoor::SetClosedAngles(QAngle value) {
    SetSchemaValue(m_ptr, "CBasePropDoor", "m_closedAngles", false, value);
}
GCBaseEntity GCBasePropDoor::GetBlocker() const {
    GCBaseEntity value(*GetSchemaValuePtr<void*>(m_ptr, "CBasePropDoor", "m_hBlocker"));
    return value;
}
void GCBasePropDoor::SetBlocker(GCBaseEntity* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Blocker' is not possible.\n");
}
bool GCBasePropDoor::GetFirstBlocked() const {
    return GetSchemaValue<bool>(m_ptr, "CBasePropDoor", "m_bFirstBlocked");
}
void GCBasePropDoor::SetFirstBlocked(bool value) {
    SetSchemaValue(m_ptr, "CBasePropDoor", "m_bFirstBlocked", false, value);
}
Glocksound_t GCBasePropDoor::GetLs() const {
    Glocksound_t value(GetSchemaPtr(m_ptr, "CBasePropDoor", "m_ls"));
    return value;
}
void GCBasePropDoor::SetLs(Glocksound_t value) {
    SetSchemaValue(m_ptr, "CBasePropDoor", "m_ls", false, value);
}
bool GCBasePropDoor::GetForceClosed() const {
    return GetSchemaValue<bool>(m_ptr, "CBasePropDoor", "m_bForceClosed");
}
void GCBasePropDoor::SetForceClosed(bool value) {
    SetSchemaValue(m_ptr, "CBasePropDoor", "m_bForceClosed", false, value);
}
Vector GCBasePropDoor::GetLatchWorldPosition() const {
    return GetSchemaValue<Vector>(m_ptr, "CBasePropDoor", "m_vecLatchWorldPosition");
}
void GCBasePropDoor::SetLatchWorldPosition(Vector value) {
    SetSchemaValue(m_ptr, "CBasePropDoor", "m_vecLatchWorldPosition", false, value);
}
GCBaseEntity GCBasePropDoor::GetActivator() const {
    GCBaseEntity value(*GetSchemaValuePtr<void*>(m_ptr, "CBasePropDoor", "m_hActivator"));
    return value;
}
void GCBasePropDoor::SetActivator(GCBaseEntity* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Activator' is not possible.\n");
}
std::string GCBasePropDoor::GetSoundMoving() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CBasePropDoor", "m_SoundMoving").String();
}
void GCBasePropDoor::SetSoundMoving(std::string value) {
    SetSchemaValue(m_ptr, "CBasePropDoor", "m_SoundMoving", false, CUtlSymbolLarge(value.c_str()));
}
std::string GCBasePropDoor::GetSoundOpen() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CBasePropDoor", "m_SoundOpen").String();
}
void GCBasePropDoor::SetSoundOpen(std::string value) {
    SetSchemaValue(m_ptr, "CBasePropDoor", "m_SoundOpen", false, CUtlSymbolLarge(value.c_str()));
}
std::string GCBasePropDoor::GetSoundClose() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CBasePropDoor", "m_SoundClose").String();
}
void GCBasePropDoor::SetSoundClose(std::string value) {
    SetSchemaValue(m_ptr, "CBasePropDoor", "m_SoundClose", false, CUtlSymbolLarge(value.c_str()));
}
std::string GCBasePropDoor::GetSoundLock() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CBasePropDoor", "m_SoundLock").String();
}
void GCBasePropDoor::SetSoundLock(std::string value) {
    SetSchemaValue(m_ptr, "CBasePropDoor", "m_SoundLock", false, CUtlSymbolLarge(value.c_str()));
}
std::string GCBasePropDoor::GetSoundUnlock() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CBasePropDoor", "m_SoundUnlock").String();
}
void GCBasePropDoor::SetSoundUnlock(std::string value) {
    SetSchemaValue(m_ptr, "CBasePropDoor", "m_SoundUnlock", false, CUtlSymbolLarge(value.c_str()));
}
std::string GCBasePropDoor::GetSoundLatch() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CBasePropDoor", "m_SoundLatch").String();
}
void GCBasePropDoor::SetSoundLatch(std::string value) {
    SetSchemaValue(m_ptr, "CBasePropDoor", "m_SoundLatch", false, CUtlSymbolLarge(value.c_str()));
}
std::string GCBasePropDoor::GetSoundPound() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CBasePropDoor", "m_SoundPound").String();
}
void GCBasePropDoor::SetSoundPound(std::string value) {
    SetSchemaValue(m_ptr, "CBasePropDoor", "m_SoundPound", false, CUtlSymbolLarge(value.c_str()));
}
std::string GCBasePropDoor::GetSoundJiggle() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CBasePropDoor", "m_SoundJiggle").String();
}
void GCBasePropDoor::SetSoundJiggle(std::string value) {
    SetSchemaValue(m_ptr, "CBasePropDoor", "m_SoundJiggle", false, CUtlSymbolLarge(value.c_str()));
}
std::string GCBasePropDoor::GetSoundLockedAnim() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CBasePropDoor", "m_SoundLockedAnim").String();
}
void GCBasePropDoor::SetSoundLockedAnim(std::string value) {
    SetSchemaValue(m_ptr, "CBasePropDoor", "m_SoundLockedAnim", false, CUtlSymbolLarge(value.c_str()));
}
int32_t GCBasePropDoor::GetNumCloseAttempts() const {
    return GetSchemaValue<int32_t>(m_ptr, "CBasePropDoor", "m_numCloseAttempts");
}
void GCBasePropDoor::SetNumCloseAttempts(int32_t value) {
    SetSchemaValue(m_ptr, "CBasePropDoor", "m_numCloseAttempts", false, value);
}
CUtlStringToken GCBasePropDoor::GetPhysicsMaterial() const {
    return GetSchemaValue<CUtlStringToken>(m_ptr, "CBasePropDoor", "m_nPhysicsMaterial");
}
void GCBasePropDoor::SetPhysicsMaterial(CUtlStringToken value) {
    SetSchemaValue(m_ptr, "CBasePropDoor", "m_nPhysicsMaterial", false, value);
}
std::string GCBasePropDoor::GetSlaveName() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CBasePropDoor", "m_SlaveName").String();
}
void GCBasePropDoor::SetSlaveName(std::string value) {
    SetSchemaValue(m_ptr, "CBasePropDoor", "m_SlaveName", false, CUtlSymbolLarge(value.c_str()));
}
GCBasePropDoor GCBasePropDoor::GetMaster() const {
    GCBasePropDoor value(*GetSchemaValuePtr<void*>(m_ptr, "CBasePropDoor", "m_hMaster"));
    return value;
}
void GCBasePropDoor::SetMaster(GCBasePropDoor* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Master' is not possible.\n");
}
GCEntityIOOutput GCBasePropDoor::GetOnBlockedClosing() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CBasePropDoor", "m_OnBlockedClosing"));
    return value;
}
void GCBasePropDoor::SetOnBlockedClosing(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CBasePropDoor", "m_OnBlockedClosing", false, value);
}
GCEntityIOOutput GCBasePropDoor::GetOnBlockedOpening() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CBasePropDoor", "m_OnBlockedOpening"));
    return value;
}
void GCBasePropDoor::SetOnBlockedOpening(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CBasePropDoor", "m_OnBlockedOpening", false, value);
}
GCEntityIOOutput GCBasePropDoor::GetOnUnblockedClosing() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CBasePropDoor", "m_OnUnblockedClosing"));
    return value;
}
void GCBasePropDoor::SetOnUnblockedClosing(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CBasePropDoor", "m_OnUnblockedClosing", false, value);
}
GCEntityIOOutput GCBasePropDoor::GetOnUnblockedOpening() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CBasePropDoor", "m_OnUnblockedOpening"));
    return value;
}
void GCBasePropDoor::SetOnUnblockedOpening(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CBasePropDoor", "m_OnUnblockedOpening", false, value);
}
GCEntityIOOutput GCBasePropDoor::GetOnFullyClosed() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CBasePropDoor", "m_OnFullyClosed"));
    return value;
}
void GCBasePropDoor::SetOnFullyClosed(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CBasePropDoor", "m_OnFullyClosed", false, value);
}
GCEntityIOOutput GCBasePropDoor::GetOnFullyOpen() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CBasePropDoor", "m_OnFullyOpen"));
    return value;
}
void GCBasePropDoor::SetOnFullyOpen(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CBasePropDoor", "m_OnFullyOpen", false, value);
}
GCEntityIOOutput GCBasePropDoor::GetOnClose() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CBasePropDoor", "m_OnClose"));
    return value;
}
void GCBasePropDoor::SetOnClose(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CBasePropDoor", "m_OnClose", false, value);
}
GCEntityIOOutput GCBasePropDoor::GetOnOpen() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CBasePropDoor", "m_OnOpen"));
    return value;
}
void GCBasePropDoor::SetOnOpen(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CBasePropDoor", "m_OnOpen", false, value);
}
GCEntityIOOutput GCBasePropDoor::GetOnLockedUse() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CBasePropDoor", "m_OnLockedUse"));
    return value;
}
void GCBasePropDoor::SetOnLockedUse(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CBasePropDoor", "m_OnLockedUse", false, value);
}
GCEntityIOOutput GCBasePropDoor::GetOnAjarOpen() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CBasePropDoor", "m_OnAjarOpen"));
    return value;
}
void GCBasePropDoor::SetOnAjarOpen(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CBasePropDoor", "m_OnAjarOpen", false, value);
}
std::string GCBasePropDoor::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCBasePropDoor::IsValid() {
    return (m_ptr != nullptr);
}
GCDynamicProp GCBasePropDoor::GetParent() const {
    GCDynamicProp value(m_ptr);
    return value;
}
void GCBasePropDoor::SetParent(GCDynamicProp value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCBasePropDoor(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCBasePropDoor>("CBasePropDoor")
        .addConstructor<void (*)(std::string)>()
        .addProperty("AutoReturnDelay", &GCBasePropDoor::GetAutoReturnDelay, &GCBasePropDoor::SetAutoReturnDelay)
        .addProperty("HardwareType", &GCBasePropDoor::GetHardwareType, &GCBasePropDoor::SetHardwareType)
        .addProperty("NeedsHardware", &GCBasePropDoor::GetNeedsHardware, &GCBasePropDoor::SetNeedsHardware)
        .addProperty("DoorState", &GCBasePropDoor::GetDoorState, &GCBasePropDoor::SetDoorState)
        .addProperty("Locked", &GCBasePropDoor::GetLocked, &GCBasePropDoor::SetLocked)
        .addProperty("ClosedPosition", &GCBasePropDoor::GetClosedPosition, &GCBasePropDoor::SetClosedPosition)
        .addProperty("ClosedAngles", &GCBasePropDoor::GetClosedAngles, &GCBasePropDoor::SetClosedAngles)
        .addProperty("Blocker", &GCBasePropDoor::GetBlocker, &GCBasePropDoor::SetBlocker)
        .addProperty("FirstBlocked", &GCBasePropDoor::GetFirstBlocked, &GCBasePropDoor::SetFirstBlocked)
        .addProperty("Ls", &GCBasePropDoor::GetLs, &GCBasePropDoor::SetLs)
        .addProperty("ForceClosed", &GCBasePropDoor::GetForceClosed, &GCBasePropDoor::SetForceClosed)
        .addProperty("LatchWorldPosition", &GCBasePropDoor::GetLatchWorldPosition, &GCBasePropDoor::SetLatchWorldPosition)
        .addProperty("Activator", &GCBasePropDoor::GetActivator, &GCBasePropDoor::SetActivator)
        .addProperty("SoundMoving", &GCBasePropDoor::GetSoundMoving, &GCBasePropDoor::SetSoundMoving)
        .addProperty("SoundOpen", &GCBasePropDoor::GetSoundOpen, &GCBasePropDoor::SetSoundOpen)
        .addProperty("SoundClose", &GCBasePropDoor::GetSoundClose, &GCBasePropDoor::SetSoundClose)
        .addProperty("SoundLock", &GCBasePropDoor::GetSoundLock, &GCBasePropDoor::SetSoundLock)
        .addProperty("SoundUnlock", &GCBasePropDoor::GetSoundUnlock, &GCBasePropDoor::SetSoundUnlock)
        .addProperty("SoundLatch", &GCBasePropDoor::GetSoundLatch, &GCBasePropDoor::SetSoundLatch)
        .addProperty("SoundPound", &GCBasePropDoor::GetSoundPound, &GCBasePropDoor::SetSoundPound)
        .addProperty("SoundJiggle", &GCBasePropDoor::GetSoundJiggle, &GCBasePropDoor::SetSoundJiggle)
        .addProperty("SoundLockedAnim", &GCBasePropDoor::GetSoundLockedAnim, &GCBasePropDoor::SetSoundLockedAnim)
        .addProperty("NumCloseAttempts", &GCBasePropDoor::GetNumCloseAttempts, &GCBasePropDoor::SetNumCloseAttempts)
        .addProperty("PhysicsMaterial", &GCBasePropDoor::GetPhysicsMaterial, &GCBasePropDoor::SetPhysicsMaterial)
        .addProperty("SlaveName", &GCBasePropDoor::GetSlaveName, &GCBasePropDoor::SetSlaveName)
        .addProperty("Master", &GCBasePropDoor::GetMaster, &GCBasePropDoor::SetMaster)
        .addProperty("OnBlockedClosing", &GCBasePropDoor::GetOnBlockedClosing, &GCBasePropDoor::SetOnBlockedClosing)
        .addProperty("OnBlockedOpening", &GCBasePropDoor::GetOnBlockedOpening, &GCBasePropDoor::SetOnBlockedOpening)
        .addProperty("OnUnblockedClosing", &GCBasePropDoor::GetOnUnblockedClosing, &GCBasePropDoor::SetOnUnblockedClosing)
        .addProperty("OnUnblockedOpening", &GCBasePropDoor::GetOnUnblockedOpening, &GCBasePropDoor::SetOnUnblockedOpening)
        .addProperty("OnFullyClosed", &GCBasePropDoor::GetOnFullyClosed, &GCBasePropDoor::SetOnFullyClosed)
        .addProperty("OnFullyOpen", &GCBasePropDoor::GetOnFullyOpen, &GCBasePropDoor::SetOnFullyOpen)
        .addProperty("OnClose", &GCBasePropDoor::GetOnClose, &GCBasePropDoor::SetOnClose)
        .addProperty("OnOpen", &GCBasePropDoor::GetOnOpen, &GCBasePropDoor::SetOnOpen)
        .addProperty("OnLockedUse", &GCBasePropDoor::GetOnLockedUse, &GCBasePropDoor::SetOnLockedUse)
        .addProperty("OnAjarOpen", &GCBasePropDoor::GetOnAjarOpen, &GCBasePropDoor::SetOnAjarOpen)
        .addProperty("Parent", &GCBasePropDoor::GetParent, &GCBasePropDoor::SetParent)
        .addFunction("ToPtr", &GCBasePropDoor::ToPtr)
        .addFunction("IsValid", &GCBasePropDoor::IsValid)
        .endClass();
}
GCRagdollManager::GCRagdollManager(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCRagdollManager::GCRagdollManager(void *ptr) {
    m_ptr = ptr;
}
int8_t GCRagdollManager::GetCurrentMaxRagdollCount() const {
    return GetSchemaValue<int8_t>(m_ptr, "CRagdollManager", "m_iCurrentMaxRagdollCount");
}
void GCRagdollManager::SetCurrentMaxRagdollCount(int8_t value) {
    SetSchemaValue(m_ptr, "CRagdollManager", "m_iCurrentMaxRagdollCount", false, value);
}
int32_t GCRagdollManager::GetMaxRagdollCount() const {
    return GetSchemaValue<int32_t>(m_ptr, "CRagdollManager", "m_iMaxRagdollCount");
}
void GCRagdollManager::SetMaxRagdollCount(int32_t value) {
    SetSchemaValue(m_ptr, "CRagdollManager", "m_iMaxRagdollCount", false, value);
}
bool GCRagdollManager::GetSaveImportant() const {
    return GetSchemaValue<bool>(m_ptr, "CRagdollManager", "m_bSaveImportant");
}
void GCRagdollManager::SetSaveImportant(bool value) {
    SetSchemaValue(m_ptr, "CRagdollManager", "m_bSaveImportant", false, value);
}
std::string GCRagdollManager::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCRagdollManager::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseEntity GCRagdollManager::GetParent() const {
    GCBaseEntity value(m_ptr);
    return value;
}
void GCRagdollManager::SetParent(GCBaseEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCRagdollManager(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCRagdollManager>("CRagdollManager")
        .addConstructor<void (*)(std::string)>()
        .addProperty("CurrentMaxRagdollCount", &GCRagdollManager::GetCurrentMaxRagdollCount, &GCRagdollManager::SetCurrentMaxRagdollCount)
        .addProperty("MaxRagdollCount", &GCRagdollManager::GetMaxRagdollCount, &GCRagdollManager::SetMaxRagdollCount)
        .addProperty("SaveImportant", &GCRagdollManager::GetSaveImportant, &GCRagdollManager::SetSaveImportant)
        .addProperty("Parent", &GCRagdollManager::GetParent, &GCRagdollManager::SetParent)
        .addFunction("ToPtr", &GCRagdollManager::ToPtr)
        .addFunction("IsValid", &GCRagdollManager::IsValid)
        .endClass();
}
GCTriggerFan::GCTriggerFan(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCTriggerFan::GCTriggerFan(void *ptr) {
    m_ptr = ptr;
}
Vector GCTriggerFan::GetFanOrigin() const {
    return GetSchemaValue<Vector>(m_ptr, "CTriggerFan", "m_vFanOrigin");
}
void GCTriggerFan::SetFanOrigin(Vector value) {
    SetSchemaValue(m_ptr, "CTriggerFan", "m_vFanOrigin", false, value);
}
Vector GCTriggerFan::GetFanEnd() const {
    return GetSchemaValue<Vector>(m_ptr, "CTriggerFan", "m_vFanEnd");
}
void GCTriggerFan::SetFanEnd(Vector value) {
    SetSchemaValue(m_ptr, "CTriggerFan", "m_vFanEnd", false, value);
}
Vector GCTriggerFan::GetNoise() const {
    return GetSchemaValue<Vector>(m_ptr, "CTriggerFan", "m_vNoise");
}
void GCTriggerFan::SetNoise(Vector value) {
    SetSchemaValue(m_ptr, "CTriggerFan", "m_vNoise", false, value);
}
float GCTriggerFan::GetForce() const {
    return GetSchemaValue<float>(m_ptr, "CTriggerFan", "m_flForce");
}
void GCTriggerFan::SetForce(float value) {
    SetSchemaValue(m_ptr, "CTriggerFan", "m_flForce", false, value);
}
float GCTriggerFan::GetRopeForceScale() const {
    return GetSchemaValue<float>(m_ptr, "CTriggerFan", "m_flRopeForceScale");
}
void GCTriggerFan::SetRopeForceScale(float value) {
    SetSchemaValue(m_ptr, "CTriggerFan", "m_flRopeForceScale", false, value);
}
float GCTriggerFan::GetPlayerForce() const {
    return GetSchemaValue<float>(m_ptr, "CTriggerFan", "m_flPlayerForce");
}
void GCTriggerFan::SetPlayerForce(float value) {
    SetSchemaValue(m_ptr, "CTriggerFan", "m_flPlayerForce", false, value);
}
float GCTriggerFan::GetRampTime() const {
    return GetSchemaValue<float>(m_ptr, "CTriggerFan", "m_flRampTime");
}
void GCTriggerFan::SetRampTime(float value) {
    SetSchemaValue(m_ptr, "CTriggerFan", "m_flRampTime", false, value);
}
bool GCTriggerFan::GetFalloff() const {
    return GetSchemaValue<bool>(m_ptr, "CTriggerFan", "m_bFalloff");
}
void GCTriggerFan::SetFalloff(bool value) {
    SetSchemaValue(m_ptr, "CTriggerFan", "m_bFalloff", false, value);
}
bool GCTriggerFan::GetPushPlayer() const {
    return GetSchemaValue<bool>(m_ptr, "CTriggerFan", "m_bPushPlayer");
}
void GCTriggerFan::SetPushPlayer(bool value) {
    SetSchemaValue(m_ptr, "CTriggerFan", "m_bPushPlayer", false, value);
}
bool GCTriggerFan::GetRampDown() const {
    return GetSchemaValue<bool>(m_ptr, "CTriggerFan", "m_bRampDown");
}
void GCTriggerFan::SetRampDown(bool value) {
    SetSchemaValue(m_ptr, "CTriggerFan", "m_bRampDown", false, value);
}
bool GCTriggerFan::GetAddNoise() const {
    return GetSchemaValue<bool>(m_ptr, "CTriggerFan", "m_bAddNoise");
}
void GCTriggerFan::SetAddNoise(bool value) {
    SetSchemaValue(m_ptr, "CTriggerFan", "m_bAddNoise", false, value);
}
GCountdownTimer GCTriggerFan::GetRampTimer() const {
    GCountdownTimer value(GetSchemaPtr(m_ptr, "CTriggerFan", "m_RampTimer"));
    return value;
}
void GCTriggerFan::SetRampTimer(GCountdownTimer value) {
    SetSchemaValue(m_ptr, "CTriggerFan", "m_RampTimer", false, value);
}
std::string GCTriggerFan::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCTriggerFan::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseTrigger GCTriggerFan::GetParent() const {
    GCBaseTrigger value(m_ptr);
    return value;
}
void GCTriggerFan::SetParent(GCBaseTrigger value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCTriggerFan(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCTriggerFan>("CTriggerFan")
        .addConstructor<void (*)(std::string)>()
        .addProperty("FanOrigin", &GCTriggerFan::GetFanOrigin, &GCTriggerFan::SetFanOrigin)
        .addProperty("FanEnd", &GCTriggerFan::GetFanEnd, &GCTriggerFan::SetFanEnd)
        .addProperty("Noise", &GCTriggerFan::GetNoise, &GCTriggerFan::SetNoise)
        .addProperty("Force", &GCTriggerFan::GetForce, &GCTriggerFan::SetForce)
        .addProperty("RopeForceScale", &GCTriggerFan::GetRopeForceScale, &GCTriggerFan::SetRopeForceScale)
        .addProperty("PlayerForce", &GCTriggerFan::GetPlayerForce, &GCTriggerFan::SetPlayerForce)
        .addProperty("RampTime", &GCTriggerFan::GetRampTime, &GCTriggerFan::SetRampTime)
        .addProperty("Falloff", &GCTriggerFan::GetFalloff, &GCTriggerFan::SetFalloff)
        .addProperty("PushPlayer", &GCTriggerFan::GetPushPlayer, &GCTriggerFan::SetPushPlayer)
        .addProperty("RampDown", &GCTriggerFan::GetRampDown, &GCTriggerFan::SetRampDown)
        .addProperty("AddNoise", &GCTriggerFan::GetAddNoise, &GCTriggerFan::SetAddNoise)
        .addProperty("RampTimer", &GCTriggerFan::GetRampTimer, &GCTriggerFan::SetRampTimer)
        .addProperty("Parent", &GCTriggerFan::GetParent, &GCTriggerFan::SetParent)
        .addFunction("ToPtr", &GCTriggerFan::ToPtr)
        .addFunction("IsValid", &GCTriggerFan::IsValid)
        .endClass();
}
GCBaseCSGrenade::GCBaseCSGrenade(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCBaseCSGrenade::GCBaseCSGrenade(void *ptr) {
    m_ptr = ptr;
}
bool GCBaseCSGrenade::GetRedraw() const {
    return GetSchemaValue<bool>(m_ptr, "CBaseCSGrenade", "m_bRedraw");
}
void GCBaseCSGrenade::SetRedraw(bool value) {
    SetSchemaValue(m_ptr, "CBaseCSGrenade", "m_bRedraw", false, value);
}
bool GCBaseCSGrenade::GetIsHeldByPlayer() const {
    return GetSchemaValue<bool>(m_ptr, "CBaseCSGrenade", "m_bIsHeldByPlayer");
}
void GCBaseCSGrenade::SetIsHeldByPlayer(bool value) {
    SetSchemaValue(m_ptr, "CBaseCSGrenade", "m_bIsHeldByPlayer", false, value);
}
bool GCBaseCSGrenade::GetPinPulled() const {
    return GetSchemaValue<bool>(m_ptr, "CBaseCSGrenade", "m_bPinPulled");
}
void GCBaseCSGrenade::SetPinPulled(bool value) {
    SetSchemaValue(m_ptr, "CBaseCSGrenade", "m_bPinPulled", false, value);
}
bool GCBaseCSGrenade::GetJumpThrow() const {
    return GetSchemaValue<bool>(m_ptr, "CBaseCSGrenade", "m_bJumpThrow");
}
void GCBaseCSGrenade::SetJumpThrow(bool value) {
    SetSchemaValue(m_ptr, "CBaseCSGrenade", "m_bJumpThrow", false, value);
}
bool GCBaseCSGrenade::GetThrowAnimating() const {
    return GetSchemaValue<bool>(m_ptr, "CBaseCSGrenade", "m_bThrowAnimating");
}
void GCBaseCSGrenade::SetThrowAnimating(bool value) {
    SetSchemaValue(m_ptr, "CBaseCSGrenade", "m_bThrowAnimating", false, value);
}
float GCBaseCSGrenade::GetThrowTime() const {
    return GetSchemaValue<float>(m_ptr, "CBaseCSGrenade", "m_fThrowTime");
}
void GCBaseCSGrenade::SetThrowTime(float value) {
    SetSchemaValue(m_ptr, "CBaseCSGrenade", "m_fThrowTime", false, value);
}
float GCBaseCSGrenade::GetThrowStrength() const {
    return GetSchemaValue<float>(m_ptr, "CBaseCSGrenade", "m_flThrowStrength");
}
void GCBaseCSGrenade::SetThrowStrength(float value) {
    SetSchemaValue(m_ptr, "CBaseCSGrenade", "m_flThrowStrength", false, value);
}
float GCBaseCSGrenade::GetThrowStrengthApproach() const {
    return GetSchemaValue<float>(m_ptr, "CBaseCSGrenade", "m_flThrowStrengthApproach");
}
void GCBaseCSGrenade::SetThrowStrengthApproach(float value) {
    SetSchemaValue(m_ptr, "CBaseCSGrenade", "m_flThrowStrengthApproach", false, value);
}
float GCBaseCSGrenade::GetDropTime() const {
    return GetSchemaValue<float>(m_ptr, "CBaseCSGrenade", "m_fDropTime");
}
void GCBaseCSGrenade::SetDropTime(float value) {
    SetSchemaValue(m_ptr, "CBaseCSGrenade", "m_fDropTime", false, value);
}
float GCBaseCSGrenade::GetPinPullTime() const {
    return GetSchemaValue<float>(m_ptr, "CBaseCSGrenade", "m_fPinPullTime");
}
void GCBaseCSGrenade::SetPinPullTime(float value) {
    SetSchemaValue(m_ptr, "CBaseCSGrenade", "m_fPinPullTime", false, value);
}
bool GCBaseCSGrenade::GetJustPulledPin() const {
    return GetSchemaValue<bool>(m_ptr, "CBaseCSGrenade", "m_bJustPulledPin");
}
void GCBaseCSGrenade::SetJustPulledPin(bool value) {
    SetSchemaValue(m_ptr, "CBaseCSGrenade", "m_bJustPulledPin", false, value);
}
int32 GCBaseCSGrenade::GetNextHoldTick() const {
    return GetSchemaValue<int32>(m_ptr, "CBaseCSGrenade", "m_nNextHoldTick");
}
void GCBaseCSGrenade::SetNextHoldTick(int32 value) {
    SetSchemaValue(m_ptr, "CBaseCSGrenade", "m_nNextHoldTick", false, value);
}
float GCBaseCSGrenade::GetNextHoldFrac() const {
    return GetSchemaValue<float>(m_ptr, "CBaseCSGrenade", "m_flNextHoldFrac");
}
void GCBaseCSGrenade::SetNextHoldFrac(float value) {
    SetSchemaValue(m_ptr, "CBaseCSGrenade", "m_flNextHoldFrac", false, value);
}
GCCSWeaponBase GCBaseCSGrenade::GetSwitchToWeaponAfterThrow() const {
    GCCSWeaponBase value(*GetSchemaValuePtr<void*>(m_ptr, "CBaseCSGrenade", "m_hSwitchToWeaponAfterThrow"));
    return value;
}
void GCBaseCSGrenade::SetSwitchToWeaponAfterThrow(GCCSWeaponBase* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'SwitchToWeaponAfterThrow' is not possible.\n");
}
std::string GCBaseCSGrenade::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCBaseCSGrenade::IsValid() {
    return (m_ptr != nullptr);
}
GCCSWeaponBase GCBaseCSGrenade::GetParent() const {
    GCCSWeaponBase value(m_ptr);
    return value;
}
void GCBaseCSGrenade::SetParent(GCCSWeaponBase value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCBaseCSGrenade(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCBaseCSGrenade>("CBaseCSGrenade")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Redraw", &GCBaseCSGrenade::GetRedraw, &GCBaseCSGrenade::SetRedraw)
        .addProperty("IsHeldByPlayer", &GCBaseCSGrenade::GetIsHeldByPlayer, &GCBaseCSGrenade::SetIsHeldByPlayer)
        .addProperty("PinPulled", &GCBaseCSGrenade::GetPinPulled, &GCBaseCSGrenade::SetPinPulled)
        .addProperty("JumpThrow", &GCBaseCSGrenade::GetJumpThrow, &GCBaseCSGrenade::SetJumpThrow)
        .addProperty("ThrowAnimating", &GCBaseCSGrenade::GetThrowAnimating, &GCBaseCSGrenade::SetThrowAnimating)
        .addProperty("ThrowTime", &GCBaseCSGrenade::GetThrowTime, &GCBaseCSGrenade::SetThrowTime)
        .addProperty("ThrowStrength", &GCBaseCSGrenade::GetThrowStrength, &GCBaseCSGrenade::SetThrowStrength)
        .addProperty("ThrowStrengthApproach", &GCBaseCSGrenade::GetThrowStrengthApproach, &GCBaseCSGrenade::SetThrowStrengthApproach)
        .addProperty("DropTime", &GCBaseCSGrenade::GetDropTime, &GCBaseCSGrenade::SetDropTime)
        .addProperty("PinPullTime", &GCBaseCSGrenade::GetPinPullTime, &GCBaseCSGrenade::SetPinPullTime)
        .addProperty("JustPulledPin", &GCBaseCSGrenade::GetJustPulledPin, &GCBaseCSGrenade::SetJustPulledPin)
        .addProperty("NextHoldTick", &GCBaseCSGrenade::GetNextHoldTick, &GCBaseCSGrenade::SetNextHoldTick)
        .addProperty("NextHoldFrac", &GCBaseCSGrenade::GetNextHoldFrac, &GCBaseCSGrenade::SetNextHoldFrac)
        .addProperty("SwitchToWeaponAfterThrow", &GCBaseCSGrenade::GetSwitchToWeaponAfterThrow, &GCBaseCSGrenade::SetSwitchToWeaponAfterThrow)
        .addProperty("Parent", &GCBaseCSGrenade::GetParent, &GCBaseCSGrenade::SetParent)
        .addFunction("ToPtr", &GCBaseCSGrenade::ToPtr)
        .addFunction("IsValid", &GCBaseCSGrenade::IsValid)
        .endClass();
}
GCPathCornerCrash::GCPathCornerCrash(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCPathCornerCrash::GCPathCornerCrash(void *ptr) {
    m_ptr = ptr;
}
std::string GCPathCornerCrash::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCPathCornerCrash::IsValid() {
    return (m_ptr != nullptr);
}
GCPathCorner GCPathCornerCrash::GetParent() const {
    GCPathCorner value(m_ptr);
    return value;
}
void GCPathCornerCrash::SetParent(GCPathCorner value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCPathCornerCrash(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCPathCornerCrash>("CPathCornerCrash")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCPathCornerCrash::GetParent, &GCPathCornerCrash::SetParent)
        .addFunction("ToPtr", &GCPathCornerCrash::ToPtr)
        .addFunction("IsValid", &GCPathCornerCrash::IsValid)
        .endClass();
}
GCHandleTest::GCHandleTest(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCHandleTest::GCHandleTest(void *ptr) {
    m_ptr = ptr;
}
GCBaseEntity GCHandleTest::GetHandle() const {
    GCBaseEntity value(*GetSchemaValuePtr<void*>(m_ptr, "CHandleTest", "m_Handle"));
    return value;
}
void GCHandleTest::SetHandle(GCBaseEntity* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Handle' is not possible.\n");
}
bool GCHandleTest::GetSendHandle() const {
    return GetSchemaValue<bool>(m_ptr, "CHandleTest", "m_bSendHandle");
}
void GCHandleTest::SetSendHandle(bool value) {
    SetSchemaValue(m_ptr, "CHandleTest", "m_bSendHandle", false, value);
}
std::string GCHandleTest::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCHandleTest::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseEntity GCHandleTest::GetParent() const {
    GCBaseEntity value(m_ptr);
    return value;
}
void GCHandleTest::SetParent(GCBaseEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCHandleTest(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCHandleTest>("CHandleTest")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Handle", &GCHandleTest::GetHandle, &GCHandleTest::SetHandle)
        .addProperty("SendHandle", &GCHandleTest::GetSendHandle, &GCHandleTest::SetSendHandle)
        .addProperty("Parent", &GCHandleTest::GetParent, &GCHandleTest::SetParent)
        .addFunction("ToPtr", &GCHandleTest::ToPtr)
        .addFunction("IsValid", &GCHandleTest::IsValid)
        .endClass();
}
GCSoundOpvarSetEntity::GCSoundOpvarSetEntity(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCSoundOpvarSetEntity::GCSoundOpvarSetEntity(void *ptr) {
    m_ptr = ptr;
}
std::string GCSoundOpvarSetEntity::GetStackName() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CSoundOpvarSetEntity", "m_iszStackName").String();
}
void GCSoundOpvarSetEntity::SetStackName(std::string value) {
    SetSchemaValue(m_ptr, "CSoundOpvarSetEntity", "m_iszStackName", false, CUtlSymbolLarge(value.c_str()));
}
std::string GCSoundOpvarSetEntity::GetOperatorName() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CSoundOpvarSetEntity", "m_iszOperatorName").String();
}
void GCSoundOpvarSetEntity::SetOperatorName(std::string value) {
    SetSchemaValue(m_ptr, "CSoundOpvarSetEntity", "m_iszOperatorName", false, CUtlSymbolLarge(value.c_str()));
}
std::string GCSoundOpvarSetEntity::GetOpvarName() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CSoundOpvarSetEntity", "m_iszOpvarName").String();
}
void GCSoundOpvarSetEntity::SetOpvarName(std::string value) {
    SetSchemaValue(m_ptr, "CSoundOpvarSetEntity", "m_iszOpvarName", false, CUtlSymbolLarge(value.c_str()));
}
int32_t GCSoundOpvarSetEntity::GetOpvarType() const {
    return GetSchemaValue<int32_t>(m_ptr, "CSoundOpvarSetEntity", "m_nOpvarType");
}
void GCSoundOpvarSetEntity::SetOpvarType(int32_t value) {
    SetSchemaValue(m_ptr, "CSoundOpvarSetEntity", "m_nOpvarType", false, value);
}
int32_t GCSoundOpvarSetEntity::GetOpvarIndex() const {
    return GetSchemaValue<int32_t>(m_ptr, "CSoundOpvarSetEntity", "m_nOpvarIndex");
}
void GCSoundOpvarSetEntity::SetOpvarIndex(int32_t value) {
    SetSchemaValue(m_ptr, "CSoundOpvarSetEntity", "m_nOpvarIndex", false, value);
}
float GCSoundOpvarSetEntity::GetOpvarValue() const {
    return GetSchemaValue<float>(m_ptr, "CSoundOpvarSetEntity", "m_flOpvarValue");
}
void GCSoundOpvarSetEntity::SetOpvarValue(float value) {
    SetSchemaValue(m_ptr, "CSoundOpvarSetEntity", "m_flOpvarValue", false, value);
}
std::string GCSoundOpvarSetEntity::GetOpvarValueString() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CSoundOpvarSetEntity", "m_OpvarValueString").String();
}
void GCSoundOpvarSetEntity::SetOpvarValueString(std::string value) {
    SetSchemaValue(m_ptr, "CSoundOpvarSetEntity", "m_OpvarValueString", false, CUtlSymbolLarge(value.c_str()));
}
bool GCSoundOpvarSetEntity::GetSetOnSpawn() const {
    return GetSchemaValue<bool>(m_ptr, "CSoundOpvarSetEntity", "m_bSetOnSpawn");
}
void GCSoundOpvarSetEntity::SetSetOnSpawn(bool value) {
    SetSchemaValue(m_ptr, "CSoundOpvarSetEntity", "m_bSetOnSpawn", false, value);
}
std::string GCSoundOpvarSetEntity::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCSoundOpvarSetEntity::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseEntity GCSoundOpvarSetEntity::GetParent() const {
    GCBaseEntity value(m_ptr);
    return value;
}
void GCSoundOpvarSetEntity::SetParent(GCBaseEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCSoundOpvarSetEntity(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCSoundOpvarSetEntity>("CSoundOpvarSetEntity")
        .addConstructor<void (*)(std::string)>()
        .addProperty("StackName", &GCSoundOpvarSetEntity::GetStackName, &GCSoundOpvarSetEntity::SetStackName)
        .addProperty("OperatorName", &GCSoundOpvarSetEntity::GetOperatorName, &GCSoundOpvarSetEntity::SetOperatorName)
        .addProperty("OpvarName", &GCSoundOpvarSetEntity::GetOpvarName, &GCSoundOpvarSetEntity::SetOpvarName)
        .addProperty("OpvarType", &GCSoundOpvarSetEntity::GetOpvarType, &GCSoundOpvarSetEntity::SetOpvarType)
        .addProperty("OpvarIndex", &GCSoundOpvarSetEntity::GetOpvarIndex, &GCSoundOpvarSetEntity::SetOpvarIndex)
        .addProperty("OpvarValue", &GCSoundOpvarSetEntity::GetOpvarValue, &GCSoundOpvarSetEntity::SetOpvarValue)
        .addProperty("OpvarValueString", &GCSoundOpvarSetEntity::GetOpvarValueString, &GCSoundOpvarSetEntity::SetOpvarValueString)
        .addProperty("SetOnSpawn", &GCSoundOpvarSetEntity::GetSetOnSpawn, &GCSoundOpvarSetEntity::SetSetOnSpawn)
        .addProperty("Parent", &GCSoundOpvarSetEntity::GetParent, &GCSoundOpvarSetEntity::SetParent)
        .addFunction("ToPtr", &GCSoundOpvarSetEntity::ToPtr)
        .addFunction("IsValid", &GCSoundOpvarSetEntity::IsValid)
        .endClass();
}
GWeaponPurchaseCount_t::GWeaponPurchaseCount_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GWeaponPurchaseCount_t::GWeaponPurchaseCount_t(void *ptr) {
    m_ptr = ptr;
}
uint16_t GWeaponPurchaseCount_t::GetItemDefIndex() const {
    return GetSchemaValue<uint16_t>(m_ptr, "WeaponPurchaseCount_t", "m_nItemDefIndex");
}
void GWeaponPurchaseCount_t::SetItemDefIndex(uint16_t value) {
    SetSchemaValue(m_ptr, "WeaponPurchaseCount_t", "m_nItemDefIndex", true, value);
}
uint16_t GWeaponPurchaseCount_t::GetCount() const {
    return GetSchemaValue<uint16_t>(m_ptr, "WeaponPurchaseCount_t", "m_nCount");
}
void GWeaponPurchaseCount_t::SetCount(uint16_t value) {
    SetSchemaValue(m_ptr, "WeaponPurchaseCount_t", "m_nCount", true, value);
}
std::string GWeaponPurchaseCount_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GWeaponPurchaseCount_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassWeaponPurchaseCount_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GWeaponPurchaseCount_t>("WeaponPurchaseCount_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("ItemDefIndex", &GWeaponPurchaseCount_t::GetItemDefIndex, &GWeaponPurchaseCount_t::SetItemDefIndex)
        .addProperty("Count", &GWeaponPurchaseCount_t::GetCount, &GWeaponPurchaseCount_t::SetCount)
        .addFunction("ToPtr", &GWeaponPurchaseCount_t::ToPtr)
        .addFunction("IsValid", &GWeaponPurchaseCount_t::IsValid)
        .endClass();
}
GCNavSpaceInfo::GCNavSpaceInfo(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCNavSpaceInfo::GCNavSpaceInfo(void *ptr) {
    m_ptr = ptr;
}
bool GCNavSpaceInfo::GetCreateFlightSpace() const {
    return GetSchemaValue<bool>(m_ptr, "CNavSpaceInfo", "m_bCreateFlightSpace");
}
void GCNavSpaceInfo::SetCreateFlightSpace(bool value) {
    SetSchemaValue(m_ptr, "CNavSpaceInfo", "m_bCreateFlightSpace", false, value);
}
std::string GCNavSpaceInfo::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCNavSpaceInfo::IsValid() {
    return (m_ptr != nullptr);
}
GCPointEntity GCNavSpaceInfo::GetParent() const {
    GCPointEntity value(m_ptr);
    return value;
}
void GCNavSpaceInfo::SetParent(GCPointEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCNavSpaceInfo(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCNavSpaceInfo>("CNavSpaceInfo")
        .addConstructor<void (*)(std::string)>()
        .addProperty("CreateFlightSpace", &GCNavSpaceInfo::GetCreateFlightSpace, &GCNavSpaceInfo::SetCreateFlightSpace)
        .addProperty("Parent", &GCNavSpaceInfo::GetParent, &GCNavSpaceInfo::SetParent)
        .addFunction("ToPtr", &GCNavSpaceInfo::ToPtr)
        .addFunction("IsValid", &GCNavSpaceInfo::IsValid)
        .endClass();
}
GCLogicAchievement::GCLogicAchievement(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCLogicAchievement::GCLogicAchievement(void *ptr) {
    m_ptr = ptr;
}
bool GCLogicAchievement::GetDisabled() const {
    return GetSchemaValue<bool>(m_ptr, "CLogicAchievement", "m_bDisabled");
}
void GCLogicAchievement::SetDisabled(bool value) {
    SetSchemaValue(m_ptr, "CLogicAchievement", "m_bDisabled", false, value);
}
std::string GCLogicAchievement::GetAchievementEventID() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CLogicAchievement", "m_iszAchievementEventID").String();
}
void GCLogicAchievement::SetAchievementEventID(std::string value) {
    SetSchemaValue(m_ptr, "CLogicAchievement", "m_iszAchievementEventID", false, CUtlSymbolLarge(value.c_str()));
}
GCEntityIOOutput GCLogicAchievement::GetOnFired() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CLogicAchievement", "m_OnFired"));
    return value;
}
void GCLogicAchievement::SetOnFired(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CLogicAchievement", "m_OnFired", false, value);
}
std::string GCLogicAchievement::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCLogicAchievement::IsValid() {
    return (m_ptr != nullptr);
}
GCLogicalEntity GCLogicAchievement::GetParent() const {
    GCLogicalEntity value(m_ptr);
    return value;
}
void GCLogicAchievement::SetParent(GCLogicalEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCLogicAchievement(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCLogicAchievement>("CLogicAchievement")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Disabled", &GCLogicAchievement::GetDisabled, &GCLogicAchievement::SetDisabled)
        .addProperty("AchievementEventID", &GCLogicAchievement::GetAchievementEventID, &GCLogicAchievement::SetAchievementEventID)
        .addProperty("OnFired", &GCLogicAchievement::GetOnFired, &GCLogicAchievement::SetOnFired)
        .addProperty("Parent", &GCLogicAchievement::GetParent, &GCLogicAchievement::SetParent)
        .addFunction("ToPtr", &GCLogicAchievement::ToPtr)
        .addFunction("IsValid", &GCLogicAchievement::IsValid)
        .endClass();
}
GCPathSimple::GCPathSimple(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCPathSimple::GCPathSimple(void *ptr) {
    m_ptr = ptr;
}
std::string GCPathSimple::GetPathString() const {
    return GetSchemaValue<CUtlString>(m_ptr, "CPathSimple", "m_pathString").Get();
}
void GCPathSimple::SetPathString(std::string value) {
    SetSchemaValue(m_ptr, "CPathSimple", "m_pathString", false, CUtlString(value.c_str()));
}
std::string GCPathSimple::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCPathSimple::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseEntity GCPathSimple::GetParent() const {
    GCBaseEntity value(m_ptr);
    return value;
}
void GCPathSimple::SetParent(GCBaseEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCPathSimple(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCPathSimple>("CPathSimple")
        .addConstructor<void (*)(std::string)>()
        .addProperty("PathString", &GCPathSimple::GetPathString, &GCPathSimple::SetPathString)
        .addProperty("Parent", &GCPathSimple::GetParent, &GCPathSimple::SetParent)
        .addFunction("ToPtr", &GCPathSimple::ToPtr)
        .addFunction("IsValid", &GCPathSimple::IsValid)
        .endClass();
}
GCBtActionParachutePositioning::GCBtActionParachutePositioning(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCBtActionParachutePositioning::GCBtActionParachutePositioning(void *ptr) {
    m_ptr = ptr;
}
GCountdownTimer GCBtActionParachutePositioning::GetActionTimer() const {
    GCountdownTimer value(GetSchemaPtr(m_ptr, "CBtActionParachutePositioning", "m_ActionTimer"));
    return value;
}
void GCBtActionParachutePositioning::SetActionTimer(GCountdownTimer value) {
    SetSchemaValue(m_ptr, "CBtActionParachutePositioning", "m_ActionTimer", false, value);
}
std::string GCBtActionParachutePositioning::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCBtActionParachutePositioning::IsValid() {
    return (m_ptr != nullptr);
}
GCBtNode GCBtActionParachutePositioning::GetParent() const {
    GCBtNode value(m_ptr);
    return value;
}
void GCBtActionParachutePositioning::SetParent(GCBtNode value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCBtActionParachutePositioning(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCBtActionParachutePositioning>("CBtActionParachutePositioning")
        .addConstructor<void (*)(std::string)>()
        .addProperty("ActionTimer", &GCBtActionParachutePositioning::GetActionTimer, &GCBtActionParachutePositioning::SetActionTimer)
        .addProperty("Parent", &GCBtActionParachutePositioning::GetParent, &GCBtActionParachutePositioning::SetParent)
        .addFunction("ToPtr", &GCBtActionParachutePositioning::ToPtr)
        .addFunction("IsValid", &GCBtActionParachutePositioning::IsValid)
        .endClass();
}
GCPlayer_CameraServices::GCPlayer_CameraServices(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCPlayer_CameraServices::GCPlayer_CameraServices(void *ptr) {
    m_ptr = ptr;
}
QAngle GCPlayer_CameraServices::GetCsViewPunchAngle() const {
    return GetSchemaValue<QAngle>(m_ptr, "CPlayer_CameraServices", "m_vecCsViewPunchAngle");
}
void GCPlayer_CameraServices::SetCsViewPunchAngle(QAngle value) {
    SetSchemaValue(m_ptr, "CPlayer_CameraServices", "m_vecCsViewPunchAngle", false, value);
}
int32 GCPlayer_CameraServices::GetCsViewPunchAngleTick() const {
    return GetSchemaValue<int32>(m_ptr, "CPlayer_CameraServices", "m_nCsViewPunchAngleTick");
}
void GCPlayer_CameraServices::SetCsViewPunchAngleTick(int32 value) {
    SetSchemaValue(m_ptr, "CPlayer_CameraServices", "m_nCsViewPunchAngleTick", false, value);
}
float GCPlayer_CameraServices::GetCsViewPunchAngleTickRatio() const {
    return GetSchemaValue<float>(m_ptr, "CPlayer_CameraServices", "m_flCsViewPunchAngleTickRatio");
}
void GCPlayer_CameraServices::SetCsViewPunchAngleTickRatio(float value) {
    SetSchemaValue(m_ptr, "CPlayer_CameraServices", "m_flCsViewPunchAngleTickRatio", false, value);
}
Gfogplayerparams_t GCPlayer_CameraServices::GetPlayerFog() const {
    Gfogplayerparams_t value(GetSchemaPtr(m_ptr, "CPlayer_CameraServices", "m_PlayerFog"));
    return value;
}
void GCPlayer_CameraServices::SetPlayerFog(Gfogplayerparams_t value) {
    SetSchemaValue(m_ptr, "CPlayer_CameraServices", "m_PlayerFog", false, value);
}
GCColorCorrection GCPlayer_CameraServices::GetColorCorrectionCtrl() const {
    GCColorCorrection value(*GetSchemaValuePtr<void*>(m_ptr, "CPlayer_CameraServices", "m_hColorCorrectionCtrl"));
    return value;
}
void GCPlayer_CameraServices::SetColorCorrectionCtrl(GCColorCorrection* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'ColorCorrectionCtrl' is not possible.\n");
}
GCBaseEntity GCPlayer_CameraServices::GetViewEntity() const {
    GCBaseEntity value(*GetSchemaValuePtr<void*>(m_ptr, "CPlayer_CameraServices", "m_hViewEntity"));
    return value;
}
void GCPlayer_CameraServices::SetViewEntity(GCBaseEntity* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'ViewEntity' is not possible.\n");
}
GCTonemapController2 GCPlayer_CameraServices::GetTonemapController() const {
    GCTonemapController2 value(*GetSchemaValuePtr<void*>(m_ptr, "CPlayer_CameraServices", "m_hTonemapController"));
    return value;
}
void GCPlayer_CameraServices::SetTonemapController(GCTonemapController2* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'TonemapController' is not possible.\n");
}
Gaudioparams_t GCPlayer_CameraServices::GetAudio() const {
    Gaudioparams_t value(GetSchemaPtr(m_ptr, "CPlayer_CameraServices", "m_audio"));
    return value;
}
void GCPlayer_CameraServices::SetAudio(Gaudioparams_t value) {
    SetSchemaValue(m_ptr, "CPlayer_CameraServices", "m_audio", false, value);
}
std::vector<GCPostProcessingVolume*> GCPlayer_CameraServices::GetPostProcessingVolumes() const {
    CUtlVector<GCPostProcessingVolume*>* vec = GetSchemaValue<CUtlVector<GCPostProcessingVolume*>*>(m_ptr, "CPlayer_CameraServices", "m_PostProcessingVolumes"); std::vector<GCPostProcessingVolume*> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCPlayer_CameraServices::SetPostProcessingVolumes(std::vector<GCPostProcessingVolume*> value) {
    SetSchemaValueCUtlVector<GCPostProcessingVolume*>(m_ptr, "CPlayer_CameraServices", "m_PostProcessingVolumes", false, value);
}
float GCPlayer_CameraServices::GetOldPlayerZ() const {
    return GetSchemaValue<float>(m_ptr, "CPlayer_CameraServices", "m_flOldPlayerZ");
}
void GCPlayer_CameraServices::SetOldPlayerZ(float value) {
    SetSchemaValue(m_ptr, "CPlayer_CameraServices", "m_flOldPlayerZ", false, value);
}
float GCPlayer_CameraServices::GetOldPlayerViewOffsetZ() const {
    return GetSchemaValue<float>(m_ptr, "CPlayer_CameraServices", "m_flOldPlayerViewOffsetZ");
}
void GCPlayer_CameraServices::SetOldPlayerViewOffsetZ(float value) {
    SetSchemaValue(m_ptr, "CPlayer_CameraServices", "m_flOldPlayerViewOffsetZ", false, value);
}
std::string GCPlayer_CameraServices::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCPlayer_CameraServices::IsValid() {
    return (m_ptr != nullptr);
}
GCPlayerPawnComponent GCPlayer_CameraServices::GetParent() const {
    GCPlayerPawnComponent value(m_ptr);
    return value;
}
void GCPlayer_CameraServices::SetParent(GCPlayerPawnComponent value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCPlayer_CameraServices(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCPlayer_CameraServices>("CPlayer_CameraServices")
        .addConstructor<void (*)(std::string)>()
        .addProperty("CsViewPunchAngle", &GCPlayer_CameraServices::GetCsViewPunchAngle, &GCPlayer_CameraServices::SetCsViewPunchAngle)
        .addProperty("CsViewPunchAngleTick", &GCPlayer_CameraServices::GetCsViewPunchAngleTick, &GCPlayer_CameraServices::SetCsViewPunchAngleTick)
        .addProperty("CsViewPunchAngleTickRatio", &GCPlayer_CameraServices::GetCsViewPunchAngleTickRatio, &GCPlayer_CameraServices::SetCsViewPunchAngleTickRatio)
        .addProperty("PlayerFog", &GCPlayer_CameraServices::GetPlayerFog, &GCPlayer_CameraServices::SetPlayerFog)
        .addProperty("ColorCorrectionCtrl", &GCPlayer_CameraServices::GetColorCorrectionCtrl, &GCPlayer_CameraServices::SetColorCorrectionCtrl)
        .addProperty("ViewEntity", &GCPlayer_CameraServices::GetViewEntity, &GCPlayer_CameraServices::SetViewEntity)
        .addProperty("TonemapController", &GCPlayer_CameraServices::GetTonemapController, &GCPlayer_CameraServices::SetTonemapController)
        .addProperty("Audio", &GCPlayer_CameraServices::GetAudio, &GCPlayer_CameraServices::SetAudio)
        .addProperty("PostProcessingVolumes", &GCPlayer_CameraServices::GetPostProcessingVolumes, &GCPlayer_CameraServices::SetPostProcessingVolumes)
        .addProperty("OldPlayerZ", &GCPlayer_CameraServices::GetOldPlayerZ, &GCPlayer_CameraServices::SetOldPlayerZ)
        .addProperty("OldPlayerViewOffsetZ", &GCPlayer_CameraServices::GetOldPlayerViewOffsetZ, &GCPlayer_CameraServices::SetOldPlayerViewOffsetZ)
        .addProperty("Parent", &GCPlayer_CameraServices::GetParent, &GCPlayer_CameraServices::SetParent)
        .addFunction("ToPtr", &GCPlayer_CameraServices::ToPtr)
        .addFunction("IsValid", &GCPlayer_CameraServices::IsValid)
        .endClass();
}
GCTouchExpansionComponent::GCTouchExpansionComponent(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCTouchExpansionComponent::GCTouchExpansionComponent(void *ptr) {
    m_ptr = ptr;
}
std::string GCTouchExpansionComponent::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCTouchExpansionComponent::IsValid() {
    return (m_ptr != nullptr);
}
GCEntityComponent GCTouchExpansionComponent::GetParent() const {
    GCEntityComponent value(m_ptr);
    return value;
}
void GCTouchExpansionComponent::SetParent(GCEntityComponent value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCTouchExpansionComponent(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCTouchExpansionComponent>("CTouchExpansionComponent")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCTouchExpansionComponent::GetParent, &GCTouchExpansionComponent::SetParent)
        .addFunction("ToPtr", &GCTouchExpansionComponent::ToPtr)
        .addFunction("IsValid", &GCTouchExpansionComponent::IsValid)
        .endClass();
}
GEntitySpottedState_t::GEntitySpottedState_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GEntitySpottedState_t::GEntitySpottedState_t(void *ptr) {
    m_ptr = ptr;
}
bool GEntitySpottedState_t::GetSpotted() const {
    return GetSchemaValue<bool>(m_ptr, "EntitySpottedState_t", "m_bSpotted");
}
void GEntitySpottedState_t::SetSpotted(bool value) {
    SetSchemaValue(m_ptr, "EntitySpottedState_t", "m_bSpotted", true, value);
}
std::vector<uint32_t> GEntitySpottedState_t::GetSpottedByMask() const {
    uint32_t* outValue = GetSchemaValue<uint32_t*>(m_ptr, "EntitySpottedState_t", "m_bSpottedByMask"); std::vector<uint32_t> ret; for(int i = 0; i < 2; i++) { ret.push_back(outValue[i]); } return ret;
}
void GEntitySpottedState_t::SetSpottedByMask(std::vector<uint32_t> value) {
    uint32_t* outValue = GetSchemaValue<uint32_t*>(m_ptr, "EntitySpottedState_t", "m_bSpottedByMask"); for(int i = 0; i < 2; i++) { outValue[i] = value[i]; } SetSchemaValue(m_ptr, "EntitySpottedState_t", "m_bSpottedByMask", true, outValue);
}
std::string GEntitySpottedState_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GEntitySpottedState_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassEntitySpottedState_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GEntitySpottedState_t>("EntitySpottedState_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Spotted", &GEntitySpottedState_t::GetSpotted, &GEntitySpottedState_t::SetSpotted)
        .addProperty("SpottedByMask", &GEntitySpottedState_t::GetSpottedByMask, &GEntitySpottedState_t::SetSpottedByMask)
        .addFunction("ToPtr", &GEntitySpottedState_t::ToPtr)
        .addFunction("IsValid", &GEntitySpottedState_t::IsValid)
        .endClass();
}
GCBaseClientUIEntity::GCBaseClientUIEntity(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCBaseClientUIEntity::GCBaseClientUIEntity(void *ptr) {
    m_ptr = ptr;
}
bool GCBaseClientUIEntity::GetEnabled() const {
    return GetSchemaValue<bool>(m_ptr, "CBaseClientUIEntity", "m_bEnabled");
}
void GCBaseClientUIEntity::SetEnabled(bool value) {
    SetSchemaValue(m_ptr, "CBaseClientUIEntity", "m_bEnabled", false, value);
}
std::string GCBaseClientUIEntity::GetDialogXMLName() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CBaseClientUIEntity", "m_DialogXMLName").String();
}
void GCBaseClientUIEntity::SetDialogXMLName(std::string value) {
    SetSchemaValue(m_ptr, "CBaseClientUIEntity", "m_DialogXMLName", false, CUtlSymbolLarge(value.c_str()));
}
std::string GCBaseClientUIEntity::GetPanelClassName() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CBaseClientUIEntity", "m_PanelClassName").String();
}
void GCBaseClientUIEntity::SetPanelClassName(std::string value) {
    SetSchemaValue(m_ptr, "CBaseClientUIEntity", "m_PanelClassName", false, CUtlSymbolLarge(value.c_str()));
}
std::string GCBaseClientUIEntity::GetPanelID() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CBaseClientUIEntity", "m_PanelID").String();
}
void GCBaseClientUIEntity::SetPanelID(std::string value) {
    SetSchemaValue(m_ptr, "CBaseClientUIEntity", "m_PanelID", false, CUtlSymbolLarge(value.c_str()));
}
GCEntityIOOutput GCBaseClientUIEntity::GetCustomOutput0() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CBaseClientUIEntity", "m_CustomOutput0"));
    return value;
}
void GCBaseClientUIEntity::SetCustomOutput0(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CBaseClientUIEntity", "m_CustomOutput0", false, value);
}
GCEntityIOOutput GCBaseClientUIEntity::GetCustomOutput1() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CBaseClientUIEntity", "m_CustomOutput1"));
    return value;
}
void GCBaseClientUIEntity::SetCustomOutput1(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CBaseClientUIEntity", "m_CustomOutput1", false, value);
}
GCEntityIOOutput GCBaseClientUIEntity::GetCustomOutput2() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CBaseClientUIEntity", "m_CustomOutput2"));
    return value;
}
void GCBaseClientUIEntity::SetCustomOutput2(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CBaseClientUIEntity", "m_CustomOutput2", false, value);
}
GCEntityIOOutput GCBaseClientUIEntity::GetCustomOutput3() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CBaseClientUIEntity", "m_CustomOutput3"));
    return value;
}
void GCBaseClientUIEntity::SetCustomOutput3(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CBaseClientUIEntity", "m_CustomOutput3", false, value);
}
GCEntityIOOutput GCBaseClientUIEntity::GetCustomOutput4() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CBaseClientUIEntity", "m_CustomOutput4"));
    return value;
}
void GCBaseClientUIEntity::SetCustomOutput4(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CBaseClientUIEntity", "m_CustomOutput4", false, value);
}
GCEntityIOOutput GCBaseClientUIEntity::GetCustomOutput5() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CBaseClientUIEntity", "m_CustomOutput5"));
    return value;
}
void GCBaseClientUIEntity::SetCustomOutput5(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CBaseClientUIEntity", "m_CustomOutput5", false, value);
}
GCEntityIOOutput GCBaseClientUIEntity::GetCustomOutput6() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CBaseClientUIEntity", "m_CustomOutput6"));
    return value;
}
void GCBaseClientUIEntity::SetCustomOutput6(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CBaseClientUIEntity", "m_CustomOutput6", false, value);
}
GCEntityIOOutput GCBaseClientUIEntity::GetCustomOutput7() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CBaseClientUIEntity", "m_CustomOutput7"));
    return value;
}
void GCBaseClientUIEntity::SetCustomOutput7(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CBaseClientUIEntity", "m_CustomOutput7", false, value);
}
GCEntityIOOutput GCBaseClientUIEntity::GetCustomOutput8() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CBaseClientUIEntity", "m_CustomOutput8"));
    return value;
}
void GCBaseClientUIEntity::SetCustomOutput8(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CBaseClientUIEntity", "m_CustomOutput8", false, value);
}
GCEntityIOOutput GCBaseClientUIEntity::GetCustomOutput9() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CBaseClientUIEntity", "m_CustomOutput9"));
    return value;
}
void GCBaseClientUIEntity::SetCustomOutput9(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CBaseClientUIEntity", "m_CustomOutput9", false, value);
}
std::string GCBaseClientUIEntity::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCBaseClientUIEntity::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseModelEntity GCBaseClientUIEntity::GetParent() const {
    GCBaseModelEntity value(m_ptr);
    return value;
}
void GCBaseClientUIEntity::SetParent(GCBaseModelEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCBaseClientUIEntity(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCBaseClientUIEntity>("CBaseClientUIEntity")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Enabled", &GCBaseClientUIEntity::GetEnabled, &GCBaseClientUIEntity::SetEnabled)
        .addProperty("DialogXMLName", &GCBaseClientUIEntity::GetDialogXMLName, &GCBaseClientUIEntity::SetDialogXMLName)
        .addProperty("PanelClassName", &GCBaseClientUIEntity::GetPanelClassName, &GCBaseClientUIEntity::SetPanelClassName)
        .addProperty("PanelID", &GCBaseClientUIEntity::GetPanelID, &GCBaseClientUIEntity::SetPanelID)
        .addProperty("CustomOutput0", &GCBaseClientUIEntity::GetCustomOutput0, &GCBaseClientUIEntity::SetCustomOutput0)
        .addProperty("CustomOutput1", &GCBaseClientUIEntity::GetCustomOutput1, &GCBaseClientUIEntity::SetCustomOutput1)
        .addProperty("CustomOutput2", &GCBaseClientUIEntity::GetCustomOutput2, &GCBaseClientUIEntity::SetCustomOutput2)
        .addProperty("CustomOutput3", &GCBaseClientUIEntity::GetCustomOutput3, &GCBaseClientUIEntity::SetCustomOutput3)
        .addProperty("CustomOutput4", &GCBaseClientUIEntity::GetCustomOutput4, &GCBaseClientUIEntity::SetCustomOutput4)
        .addProperty("CustomOutput5", &GCBaseClientUIEntity::GetCustomOutput5, &GCBaseClientUIEntity::SetCustomOutput5)
        .addProperty("CustomOutput6", &GCBaseClientUIEntity::GetCustomOutput6, &GCBaseClientUIEntity::SetCustomOutput6)
        .addProperty("CustomOutput7", &GCBaseClientUIEntity::GetCustomOutput7, &GCBaseClientUIEntity::SetCustomOutput7)
        .addProperty("CustomOutput8", &GCBaseClientUIEntity::GetCustomOutput8, &GCBaseClientUIEntity::SetCustomOutput8)
        .addProperty("CustomOutput9", &GCBaseClientUIEntity::GetCustomOutput9, &GCBaseClientUIEntity::SetCustomOutput9)
        .addProperty("Parent", &GCBaseClientUIEntity::GetParent, &GCBaseClientUIEntity::SetParent)
        .addFunction("ToPtr", &GCBaseClientUIEntity::ToPtr)
        .addFunction("IsValid", &GCBaseClientUIEntity::IsValid)
        .endClass();
}
GCEnvDecal::GCEnvDecal(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCEnvDecal::GCEnvDecal(void *ptr) {
    m_ptr = ptr;
}
float GCEnvDecal::GetWidth() const {
    return GetSchemaValue<float>(m_ptr, "CEnvDecal", "m_flWidth");
}
void GCEnvDecal::SetWidth(float value) {
    SetSchemaValue(m_ptr, "CEnvDecal", "m_flWidth", false, value);
}
float GCEnvDecal::GetHeight() const {
    return GetSchemaValue<float>(m_ptr, "CEnvDecal", "m_flHeight");
}
void GCEnvDecal::SetHeight(float value) {
    SetSchemaValue(m_ptr, "CEnvDecal", "m_flHeight", false, value);
}
float GCEnvDecal::GetDepth() const {
    return GetSchemaValue<float>(m_ptr, "CEnvDecal", "m_flDepth");
}
void GCEnvDecal::SetDepth(float value) {
    SetSchemaValue(m_ptr, "CEnvDecal", "m_flDepth", false, value);
}
uint32_t GCEnvDecal::GetRenderOrder() const {
    return GetSchemaValue<uint32_t>(m_ptr, "CEnvDecal", "m_nRenderOrder");
}
void GCEnvDecal::SetRenderOrder(uint32_t value) {
    SetSchemaValue(m_ptr, "CEnvDecal", "m_nRenderOrder", false, value);
}
bool GCEnvDecal::GetProjectOnWorld() const {
    return GetSchemaValue<bool>(m_ptr, "CEnvDecal", "m_bProjectOnWorld");
}
void GCEnvDecal::SetProjectOnWorld(bool value) {
    SetSchemaValue(m_ptr, "CEnvDecal", "m_bProjectOnWorld", false, value);
}
bool GCEnvDecal::GetProjectOnCharacters() const {
    return GetSchemaValue<bool>(m_ptr, "CEnvDecal", "m_bProjectOnCharacters");
}
void GCEnvDecal::SetProjectOnCharacters(bool value) {
    SetSchemaValue(m_ptr, "CEnvDecal", "m_bProjectOnCharacters", false, value);
}
bool GCEnvDecal::GetProjectOnWater() const {
    return GetSchemaValue<bool>(m_ptr, "CEnvDecal", "m_bProjectOnWater");
}
void GCEnvDecal::SetProjectOnWater(bool value) {
    SetSchemaValue(m_ptr, "CEnvDecal", "m_bProjectOnWater", false, value);
}
float GCEnvDecal::GetDepthSortBias() const {
    return GetSchemaValue<float>(m_ptr, "CEnvDecal", "m_flDepthSortBias");
}
void GCEnvDecal::SetDepthSortBias(float value) {
    SetSchemaValue(m_ptr, "CEnvDecal", "m_flDepthSortBias", false, value);
}
std::string GCEnvDecal::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCEnvDecal::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseModelEntity GCEnvDecal::GetParent() const {
    GCBaseModelEntity value(m_ptr);
    return value;
}
void GCEnvDecal::SetParent(GCBaseModelEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCEnvDecal(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCEnvDecal>("CEnvDecal")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Width", &GCEnvDecal::GetWidth, &GCEnvDecal::SetWidth)
        .addProperty("Height", &GCEnvDecal::GetHeight, &GCEnvDecal::SetHeight)
        .addProperty("Depth", &GCEnvDecal::GetDepth, &GCEnvDecal::SetDepth)
        .addProperty("RenderOrder", &GCEnvDecal::GetRenderOrder, &GCEnvDecal::SetRenderOrder)
        .addProperty("ProjectOnWorld", &GCEnvDecal::GetProjectOnWorld, &GCEnvDecal::SetProjectOnWorld)
        .addProperty("ProjectOnCharacters", &GCEnvDecal::GetProjectOnCharacters, &GCEnvDecal::SetProjectOnCharacters)
        .addProperty("ProjectOnWater", &GCEnvDecal::GetProjectOnWater, &GCEnvDecal::SetProjectOnWater)
        .addProperty("DepthSortBias", &GCEnvDecal::GetDepthSortBias, &GCEnvDecal::SetDepthSortBias)
        .addProperty("Parent", &GCEnvDecal::GetParent, &GCEnvDecal::SetParent)
        .addFunction("ToPtr", &GCEnvDecal::ToPtr)
        .addFunction("IsValid", &GCEnvDecal::IsValid)
        .endClass();
}
GCCSPointScriptExtensions_entity::GCCSPointScriptExtensions_entity(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCCSPointScriptExtensions_entity::GCCSPointScriptExtensions_entity(void *ptr) {
    m_ptr = ptr;
}
std::string GCCSPointScriptExtensions_entity::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCCSPointScriptExtensions_entity::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCCSPointScriptExtensions_entity(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCCSPointScriptExtensions_entity>("CCSPointScriptExtensions_entity")
        .addConstructor<void (*)(std::string)>()
        .addFunction("ToPtr", &GCCSPointScriptExtensions_entity::ToPtr)
        .addFunction("IsValid", &GCCSPointScriptExtensions_entity::IsValid)
        .endClass();
}
GCGameSceneNode::GCGameSceneNode(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCGameSceneNode::GCGameSceneNode(void *ptr) {
    m_ptr = ptr;
}
GCEntityInstance GCGameSceneNode::GetOwner() const {
    GCEntityInstance value(*GetSchemaValuePtr<void*>(m_ptr, "CGameSceneNode", "m_pOwner"));
    return value;
}
void GCGameSceneNode::SetOwner(GCEntityInstance* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Owner' is not possible.\n");
}
GCGameSceneNode GCGameSceneNode::GetParent() const {
    GCGameSceneNode value(*GetSchemaValuePtr<void*>(m_ptr, "CGameSceneNode", "m_pParent"));
    return value;
}
void GCGameSceneNode::SetParent(GCGameSceneNode* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
GCGameSceneNode GCGameSceneNode::GetChild() const {
    GCGameSceneNode value(*GetSchemaValuePtr<void*>(m_ptr, "CGameSceneNode", "m_pChild"));
    return value;
}
void GCGameSceneNode::SetChild(GCGameSceneNode* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Child' is not possible.\n");
}
GCGameSceneNode GCGameSceneNode::GetNextSibling() const {
    GCGameSceneNode value(*GetSchemaValuePtr<void*>(m_ptr, "CGameSceneNode", "m_pNextSibling"));
    return value;
}
void GCGameSceneNode::SetNextSibling(GCGameSceneNode* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'NextSibling' is not possible.\n");
}
GCNetworkOriginCellCoordQuantizedVector GCGameSceneNode::GetOrigin() const {
    GCNetworkOriginCellCoordQuantizedVector value(GetSchemaPtr(m_ptr, "CGameSceneNode", "m_vecOrigin"));
    return value;
}
void GCGameSceneNode::SetOrigin(GCNetworkOriginCellCoordQuantizedVector value) {
    SetSchemaValue(m_ptr, "CGameSceneNode", "m_vecOrigin", false, value);
}
QAngle GCGameSceneNode::GetRotation() const {
    return GetSchemaValue<QAngle>(m_ptr, "CGameSceneNode", "m_angRotation");
}
void GCGameSceneNode::SetRotation(QAngle value) {
    SetSchemaValue(m_ptr, "CGameSceneNode", "m_angRotation", false, value);
}
float GCGameSceneNode::GetScale() const {
    return GetSchemaValue<float>(m_ptr, "CGameSceneNode", "m_flScale");
}
void GCGameSceneNode::SetScale(float value) {
    SetSchemaValue(m_ptr, "CGameSceneNode", "m_flScale", false, value);
}
Vector GCGameSceneNode::GetAbsOrigin() const {
    return GetSchemaValue<Vector>(m_ptr, "CGameSceneNode", "m_vecAbsOrigin");
}
void GCGameSceneNode::SetAbsOrigin(Vector value) {
    SetSchemaValue(m_ptr, "CGameSceneNode", "m_vecAbsOrigin", false, value);
}
QAngle GCGameSceneNode::GetAbsRotation() const {
    return GetSchemaValue<QAngle>(m_ptr, "CGameSceneNode", "m_angAbsRotation");
}
void GCGameSceneNode::SetAbsRotation(QAngle value) {
    SetSchemaValue(m_ptr, "CGameSceneNode", "m_angAbsRotation", false, value);
}
float GCGameSceneNode::GetAbsScale() const {
    return GetSchemaValue<float>(m_ptr, "CGameSceneNode", "m_flAbsScale");
}
void GCGameSceneNode::SetAbsScale(float value) {
    SetSchemaValue(m_ptr, "CGameSceneNode", "m_flAbsScale", false, value);
}
int16_t GCGameSceneNode::GetParentAttachmentOrBone() const {
    return GetSchemaValue<int16_t>(m_ptr, "CGameSceneNode", "m_nParentAttachmentOrBone");
}
void GCGameSceneNode::SetParentAttachmentOrBone(int16_t value) {
    SetSchemaValue(m_ptr, "CGameSceneNode", "m_nParentAttachmentOrBone", false, value);
}
bool GCGameSceneNode::GetDebugAbsOriginChanges() const {
    return GetSchemaValue<bool>(m_ptr, "CGameSceneNode", "m_bDebugAbsOriginChanges");
}
void GCGameSceneNode::SetDebugAbsOriginChanges(bool value) {
    SetSchemaValue(m_ptr, "CGameSceneNode", "m_bDebugAbsOriginChanges", false, value);
}
bool GCGameSceneNode::GetDormant() const {
    return GetSchemaValue<bool>(m_ptr, "CGameSceneNode", "m_bDormant");
}
void GCGameSceneNode::SetDormant(bool value) {
    SetSchemaValue(m_ptr, "CGameSceneNode", "m_bDormant", false, value);
}
bool GCGameSceneNode::GetForceParentToBeNetworked() const {
    return GetSchemaValue<bool>(m_ptr, "CGameSceneNode", "m_bForceParentToBeNetworked");
}
void GCGameSceneNode::SetForceParentToBeNetworked(bool value) {
    SetSchemaValue(m_ptr, "CGameSceneNode", "m_bForceParentToBeNetworked", false, value);
}
uint8_t GCGameSceneNode::GetHierarchicalDepth() const {
    return GetSchemaValue<uint8_t>(m_ptr, "CGameSceneNode", "m_nHierarchicalDepth");
}
void GCGameSceneNode::SetHierarchicalDepth(uint8_t value) {
    SetSchemaValue(m_ptr, "CGameSceneNode", "m_nHierarchicalDepth", false, value);
}
uint8_t GCGameSceneNode::GetHierarchyType() const {
    return GetSchemaValue<uint8_t>(m_ptr, "CGameSceneNode", "m_nHierarchyType");
}
void GCGameSceneNode::SetHierarchyType(uint8_t value) {
    SetSchemaValue(m_ptr, "CGameSceneNode", "m_nHierarchyType", false, value);
}
uint8_t GCGameSceneNode::GetDoNotSetAnimTimeInInvalidatePhysicsCount() const {
    return GetSchemaValue<uint8_t>(m_ptr, "CGameSceneNode", "m_nDoNotSetAnimTimeInInvalidatePhysicsCount");
}
void GCGameSceneNode::SetDoNotSetAnimTimeInInvalidatePhysicsCount(uint8_t value) {
    SetSchemaValue(m_ptr, "CGameSceneNode", "m_nDoNotSetAnimTimeInInvalidatePhysicsCount", false, value);
}
CUtlStringToken GCGameSceneNode::GetName() const {
    return GetSchemaValue<CUtlStringToken>(m_ptr, "CGameSceneNode", "m_name");
}
void GCGameSceneNode::SetName(CUtlStringToken value) {
    SetSchemaValue(m_ptr, "CGameSceneNode", "m_name", false, value);
}
CUtlStringToken GCGameSceneNode::GetHierarchyAttachName() const {
    return GetSchemaValue<CUtlStringToken>(m_ptr, "CGameSceneNode", "m_hierarchyAttachName");
}
void GCGameSceneNode::SetHierarchyAttachName(CUtlStringToken value) {
    SetSchemaValue(m_ptr, "CGameSceneNode", "m_hierarchyAttachName", false, value);
}
float GCGameSceneNode::GetZOffset() const {
    return GetSchemaValue<float>(m_ptr, "CGameSceneNode", "m_flZOffset");
}
void GCGameSceneNode::SetZOffset(float value) {
    SetSchemaValue(m_ptr, "CGameSceneNode", "m_flZOffset", false, value);
}
float GCGameSceneNode::GetClientLocalScale() const {
    return GetSchemaValue<float>(m_ptr, "CGameSceneNode", "m_flClientLocalScale");
}
void GCGameSceneNode::SetClientLocalScale(float value) {
    SetSchemaValue(m_ptr, "CGameSceneNode", "m_flClientLocalScale", false, value);
}
Vector GCGameSceneNode::GetRenderOrigin() const {
    return GetSchemaValue<Vector>(m_ptr, "CGameSceneNode", "m_vRenderOrigin");
}
void GCGameSceneNode::SetRenderOrigin(Vector value) {
    SetSchemaValue(m_ptr, "CGameSceneNode", "m_vRenderOrigin", false, value);
}
std::string GCGameSceneNode::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCGameSceneNode::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCGameSceneNode(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCGameSceneNode>("CGameSceneNode")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Owner", &GCGameSceneNode::GetOwner, &GCGameSceneNode::SetOwner)
        .addProperty("Parent", &GCGameSceneNode::GetParent, &GCGameSceneNode::SetParent)
        .addProperty("Child", &GCGameSceneNode::GetChild, &GCGameSceneNode::SetChild)
        .addProperty("NextSibling", &GCGameSceneNode::GetNextSibling, &GCGameSceneNode::SetNextSibling)
        .addProperty("Origin", &GCGameSceneNode::GetOrigin, &GCGameSceneNode::SetOrigin)
        .addProperty("Rotation", &GCGameSceneNode::GetRotation, &GCGameSceneNode::SetRotation)
        .addProperty("Scale", &GCGameSceneNode::GetScale, &GCGameSceneNode::SetScale)
        .addProperty("AbsOrigin", &GCGameSceneNode::GetAbsOrigin, &GCGameSceneNode::SetAbsOrigin)
        .addProperty("AbsRotation", &GCGameSceneNode::GetAbsRotation, &GCGameSceneNode::SetAbsRotation)
        .addProperty("AbsScale", &GCGameSceneNode::GetAbsScale, &GCGameSceneNode::SetAbsScale)
        .addProperty("ParentAttachmentOrBone", &GCGameSceneNode::GetParentAttachmentOrBone, &GCGameSceneNode::SetParentAttachmentOrBone)
        .addProperty("DebugAbsOriginChanges", &GCGameSceneNode::GetDebugAbsOriginChanges, &GCGameSceneNode::SetDebugAbsOriginChanges)
        .addProperty("Dormant", &GCGameSceneNode::GetDormant, &GCGameSceneNode::SetDormant)
        .addProperty("ForceParentToBeNetworked", &GCGameSceneNode::GetForceParentToBeNetworked, &GCGameSceneNode::SetForceParentToBeNetworked)
        .addProperty("HierarchicalDepth", &GCGameSceneNode::GetHierarchicalDepth, &GCGameSceneNode::SetHierarchicalDepth)
        .addProperty("HierarchyType", &GCGameSceneNode::GetHierarchyType, &GCGameSceneNode::SetHierarchyType)
        .addProperty("DoNotSetAnimTimeInInvalidatePhysicsCount", &GCGameSceneNode::GetDoNotSetAnimTimeInInvalidatePhysicsCount, &GCGameSceneNode::SetDoNotSetAnimTimeInInvalidatePhysicsCount)
        .addProperty("Name", &GCGameSceneNode::GetName, &GCGameSceneNode::SetName)
        .addProperty("HierarchyAttachName", &GCGameSceneNode::GetHierarchyAttachName, &GCGameSceneNode::SetHierarchyAttachName)
        .addProperty("ZOffset", &GCGameSceneNode::GetZOffset, &GCGameSceneNode::SetZOffset)
        .addProperty("ClientLocalScale", &GCGameSceneNode::GetClientLocalScale, &GCGameSceneNode::SetClientLocalScale)
        .addProperty("RenderOrigin", &GCGameSceneNode::GetRenderOrigin, &GCGameSceneNode::SetRenderOrigin)
        .addFunction("ToPtr", &GCGameSceneNode::ToPtr)
        .addFunction("IsValid", &GCGameSceneNode::IsValid)
        .endClass();
}
GCLogicAuto::GCLogicAuto(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCLogicAuto::GCLogicAuto(void *ptr) {
    m_ptr = ptr;
}
GCEntityIOOutput GCLogicAuto::GetOnMapSpawn() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CLogicAuto", "m_OnMapSpawn"));
    return value;
}
void GCLogicAuto::SetOnMapSpawn(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CLogicAuto", "m_OnMapSpawn", false, value);
}
GCEntityIOOutput GCLogicAuto::GetOnDemoMapSpawn() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CLogicAuto", "m_OnDemoMapSpawn"));
    return value;
}
void GCLogicAuto::SetOnDemoMapSpawn(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CLogicAuto", "m_OnDemoMapSpawn", false, value);
}
GCEntityIOOutput GCLogicAuto::GetOnNewGame() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CLogicAuto", "m_OnNewGame"));
    return value;
}
void GCLogicAuto::SetOnNewGame(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CLogicAuto", "m_OnNewGame", false, value);
}
GCEntityIOOutput GCLogicAuto::GetOnLoadGame() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CLogicAuto", "m_OnLoadGame"));
    return value;
}
void GCLogicAuto::SetOnLoadGame(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CLogicAuto", "m_OnLoadGame", false, value);
}
GCEntityIOOutput GCLogicAuto::GetOnMapTransition() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CLogicAuto", "m_OnMapTransition"));
    return value;
}
void GCLogicAuto::SetOnMapTransition(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CLogicAuto", "m_OnMapTransition", false, value);
}
GCEntityIOOutput GCLogicAuto::GetOnBackgroundMap() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CLogicAuto", "m_OnBackgroundMap"));
    return value;
}
void GCLogicAuto::SetOnBackgroundMap(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CLogicAuto", "m_OnBackgroundMap", false, value);
}
GCEntityIOOutput GCLogicAuto::GetOnMultiNewMap() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CLogicAuto", "m_OnMultiNewMap"));
    return value;
}
void GCLogicAuto::SetOnMultiNewMap(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CLogicAuto", "m_OnMultiNewMap", false, value);
}
GCEntityIOOutput GCLogicAuto::GetOnMultiNewRound() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CLogicAuto", "m_OnMultiNewRound"));
    return value;
}
void GCLogicAuto::SetOnMultiNewRound(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CLogicAuto", "m_OnMultiNewRound", false, value);
}
GCEntityIOOutput GCLogicAuto::GetOnVREnabled() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CLogicAuto", "m_OnVREnabled"));
    return value;
}
void GCLogicAuto::SetOnVREnabled(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CLogicAuto", "m_OnVREnabled", false, value);
}
GCEntityIOOutput GCLogicAuto::GetOnVRNotEnabled() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CLogicAuto", "m_OnVRNotEnabled"));
    return value;
}
void GCLogicAuto::SetOnVRNotEnabled(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CLogicAuto", "m_OnVRNotEnabled", false, value);
}
std::string GCLogicAuto::GetGlobalstate() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CLogicAuto", "m_globalstate").String();
}
void GCLogicAuto::SetGlobalstate(std::string value) {
    SetSchemaValue(m_ptr, "CLogicAuto", "m_globalstate", false, CUtlSymbolLarge(value.c_str()));
}
std::string GCLogicAuto::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCLogicAuto::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseEntity GCLogicAuto::GetParent() const {
    GCBaseEntity value(m_ptr);
    return value;
}
void GCLogicAuto::SetParent(GCBaseEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCLogicAuto(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCLogicAuto>("CLogicAuto")
        .addConstructor<void (*)(std::string)>()
        .addProperty("OnMapSpawn", &GCLogicAuto::GetOnMapSpawn, &GCLogicAuto::SetOnMapSpawn)
        .addProperty("OnDemoMapSpawn", &GCLogicAuto::GetOnDemoMapSpawn, &GCLogicAuto::SetOnDemoMapSpawn)
        .addProperty("OnNewGame", &GCLogicAuto::GetOnNewGame, &GCLogicAuto::SetOnNewGame)
        .addProperty("OnLoadGame", &GCLogicAuto::GetOnLoadGame, &GCLogicAuto::SetOnLoadGame)
        .addProperty("OnMapTransition", &GCLogicAuto::GetOnMapTransition, &GCLogicAuto::SetOnMapTransition)
        .addProperty("OnBackgroundMap", &GCLogicAuto::GetOnBackgroundMap, &GCLogicAuto::SetOnBackgroundMap)
        .addProperty("OnMultiNewMap", &GCLogicAuto::GetOnMultiNewMap, &GCLogicAuto::SetOnMultiNewMap)
        .addProperty("OnMultiNewRound", &GCLogicAuto::GetOnMultiNewRound, &GCLogicAuto::SetOnMultiNewRound)
        .addProperty("OnVREnabled", &GCLogicAuto::GetOnVREnabled, &GCLogicAuto::SetOnVREnabled)
        .addProperty("OnVRNotEnabled", &GCLogicAuto::GetOnVRNotEnabled, &GCLogicAuto::SetOnVRNotEnabled)
        .addProperty("Globalstate", &GCLogicAuto::GetGlobalstate, &GCLogicAuto::SetGlobalstate)
        .addProperty("Parent", &GCLogicAuto::GetParent, &GCLogicAuto::SetParent)
        .addFunction("ToPtr", &GCLogicAuto::ToPtr)
        .addFunction("IsValid", &GCLogicAuto::IsValid)
        .endClass();
}
GCSoundOpvarSetOBBWindEntity::GCSoundOpvarSetOBBWindEntity(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCSoundOpvarSetOBBWindEntity::GCSoundOpvarSetOBBWindEntity(void *ptr) {
    m_ptr = ptr;
}
Vector GCSoundOpvarSetOBBWindEntity::GetMins() const {
    return GetSchemaValue<Vector>(m_ptr, "CSoundOpvarSetOBBWindEntity", "m_vMins");
}
void GCSoundOpvarSetOBBWindEntity::SetMins(Vector value) {
    SetSchemaValue(m_ptr, "CSoundOpvarSetOBBWindEntity", "m_vMins", false, value);
}
Vector GCSoundOpvarSetOBBWindEntity::GetMaxs() const {
    return GetSchemaValue<Vector>(m_ptr, "CSoundOpvarSetOBBWindEntity", "m_vMaxs");
}
void GCSoundOpvarSetOBBWindEntity::SetMaxs(Vector value) {
    SetSchemaValue(m_ptr, "CSoundOpvarSetOBBWindEntity", "m_vMaxs", false, value);
}
Vector GCSoundOpvarSetOBBWindEntity::GetDistanceMins() const {
    return GetSchemaValue<Vector>(m_ptr, "CSoundOpvarSetOBBWindEntity", "m_vDistanceMins");
}
void GCSoundOpvarSetOBBWindEntity::SetDistanceMins(Vector value) {
    SetSchemaValue(m_ptr, "CSoundOpvarSetOBBWindEntity", "m_vDistanceMins", false, value);
}
Vector GCSoundOpvarSetOBBWindEntity::GetDistanceMaxs() const {
    return GetSchemaValue<Vector>(m_ptr, "CSoundOpvarSetOBBWindEntity", "m_vDistanceMaxs");
}
void GCSoundOpvarSetOBBWindEntity::SetDistanceMaxs(Vector value) {
    SetSchemaValue(m_ptr, "CSoundOpvarSetOBBWindEntity", "m_vDistanceMaxs", false, value);
}
float GCSoundOpvarSetOBBWindEntity::GetWindMin() const {
    return GetSchemaValue<float>(m_ptr, "CSoundOpvarSetOBBWindEntity", "m_flWindMin");
}
void GCSoundOpvarSetOBBWindEntity::SetWindMin(float value) {
    SetSchemaValue(m_ptr, "CSoundOpvarSetOBBWindEntity", "m_flWindMin", false, value);
}
float GCSoundOpvarSetOBBWindEntity::GetWindMax() const {
    return GetSchemaValue<float>(m_ptr, "CSoundOpvarSetOBBWindEntity", "m_flWindMax");
}
void GCSoundOpvarSetOBBWindEntity::SetWindMax(float value) {
    SetSchemaValue(m_ptr, "CSoundOpvarSetOBBWindEntity", "m_flWindMax", false, value);
}
float GCSoundOpvarSetOBBWindEntity::GetWindMapMin() const {
    return GetSchemaValue<float>(m_ptr, "CSoundOpvarSetOBBWindEntity", "m_flWindMapMin");
}
void GCSoundOpvarSetOBBWindEntity::SetWindMapMin(float value) {
    SetSchemaValue(m_ptr, "CSoundOpvarSetOBBWindEntity", "m_flWindMapMin", false, value);
}
float GCSoundOpvarSetOBBWindEntity::GetWindMapMax() const {
    return GetSchemaValue<float>(m_ptr, "CSoundOpvarSetOBBWindEntity", "m_flWindMapMax");
}
void GCSoundOpvarSetOBBWindEntity::SetWindMapMax(float value) {
    SetSchemaValue(m_ptr, "CSoundOpvarSetOBBWindEntity", "m_flWindMapMax", false, value);
}
std::string GCSoundOpvarSetOBBWindEntity::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCSoundOpvarSetOBBWindEntity::IsValid() {
    return (m_ptr != nullptr);
}
GCSoundOpvarSetPointBase GCSoundOpvarSetOBBWindEntity::GetParent() const {
    GCSoundOpvarSetPointBase value(m_ptr);
    return value;
}
void GCSoundOpvarSetOBBWindEntity::SetParent(GCSoundOpvarSetPointBase value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCSoundOpvarSetOBBWindEntity(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCSoundOpvarSetOBBWindEntity>("CSoundOpvarSetOBBWindEntity")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Mins", &GCSoundOpvarSetOBBWindEntity::GetMins, &GCSoundOpvarSetOBBWindEntity::SetMins)
        .addProperty("Maxs", &GCSoundOpvarSetOBBWindEntity::GetMaxs, &GCSoundOpvarSetOBBWindEntity::SetMaxs)
        .addProperty("DistanceMins", &GCSoundOpvarSetOBBWindEntity::GetDistanceMins, &GCSoundOpvarSetOBBWindEntity::SetDistanceMins)
        .addProperty("DistanceMaxs", &GCSoundOpvarSetOBBWindEntity::GetDistanceMaxs, &GCSoundOpvarSetOBBWindEntity::SetDistanceMaxs)
        .addProperty("WindMin", &GCSoundOpvarSetOBBWindEntity::GetWindMin, &GCSoundOpvarSetOBBWindEntity::SetWindMin)
        .addProperty("WindMax", &GCSoundOpvarSetOBBWindEntity::GetWindMax, &GCSoundOpvarSetOBBWindEntity::SetWindMax)
        .addProperty("WindMapMin", &GCSoundOpvarSetOBBWindEntity::GetWindMapMin, &GCSoundOpvarSetOBBWindEntity::SetWindMapMin)
        .addProperty("WindMapMax", &GCSoundOpvarSetOBBWindEntity::GetWindMapMax, &GCSoundOpvarSetOBBWindEntity::SetWindMapMax)
        .addProperty("Parent", &GCSoundOpvarSetOBBWindEntity::GetParent, &GCSoundOpvarSetOBBWindEntity::SetParent)
        .addFunction("ToPtr", &GCSoundOpvarSetOBBWindEntity::ToPtr)
        .addFunction("IsValid", &GCSoundOpvarSetOBBWindEntity::IsValid)
        .endClass();
}
GCLightDirectionalEntity::GCLightDirectionalEntity(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCLightDirectionalEntity::GCLightDirectionalEntity(void *ptr) {
    m_ptr = ptr;
}
std::string GCLightDirectionalEntity::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCLightDirectionalEntity::IsValid() {
    return (m_ptr != nullptr);
}
GCLightEntity GCLightDirectionalEntity::GetParent() const {
    GCLightEntity value(m_ptr);
    return value;
}
void GCLightDirectionalEntity::SetParent(GCLightEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCLightDirectionalEntity(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCLightDirectionalEntity>("CLightDirectionalEntity")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCLightDirectionalEntity::GetParent, &GCLightDirectionalEntity::SetParent)
        .addFunction("ToPtr", &GCLightDirectionalEntity::ToPtr)
        .addFunction("IsValid", &GCLightDirectionalEntity::IsValid)
        .endClass();
}
GCLogicNPCCounter::GCLogicNPCCounter(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCLogicNPCCounter::GCLogicNPCCounter(void *ptr) {
    m_ptr = ptr;
}
GCEntityIOOutput GCLogicNPCCounter::GetOnMinCountAll() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CLogicNPCCounter", "m_OnMinCountAll"));
    return value;
}
void GCLogicNPCCounter::SetOnMinCountAll(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CLogicNPCCounter", "m_OnMinCountAll", false, value);
}
GCEntityIOOutput GCLogicNPCCounter::GetOnMaxCountAll() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CLogicNPCCounter", "m_OnMaxCountAll"));
    return value;
}
void GCLogicNPCCounter::SetOnMaxCountAll(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CLogicNPCCounter", "m_OnMaxCountAll", false, value);
}
GCEntityIOOutput GCLogicNPCCounter::GetOnMinCount_1() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CLogicNPCCounter", "m_OnMinCount_1"));
    return value;
}
void GCLogicNPCCounter::SetOnMinCount_1(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CLogicNPCCounter", "m_OnMinCount_1", false, value);
}
GCEntityIOOutput GCLogicNPCCounter::GetOnMaxCount_1() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CLogicNPCCounter", "m_OnMaxCount_1"));
    return value;
}
void GCLogicNPCCounter::SetOnMaxCount_1(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CLogicNPCCounter", "m_OnMaxCount_1", false, value);
}
GCEntityIOOutput GCLogicNPCCounter::GetOnMinCount_2() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CLogicNPCCounter", "m_OnMinCount_2"));
    return value;
}
void GCLogicNPCCounter::SetOnMinCount_2(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CLogicNPCCounter", "m_OnMinCount_2", false, value);
}
GCEntityIOOutput GCLogicNPCCounter::GetOnMaxCount_2() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CLogicNPCCounter", "m_OnMaxCount_2"));
    return value;
}
void GCLogicNPCCounter::SetOnMaxCount_2(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CLogicNPCCounter", "m_OnMaxCount_2", false, value);
}
GCEntityIOOutput GCLogicNPCCounter::GetOnMinCount_3() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CLogicNPCCounter", "m_OnMinCount_3"));
    return value;
}
void GCLogicNPCCounter::SetOnMinCount_3(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CLogicNPCCounter", "m_OnMinCount_3", false, value);
}
GCEntityIOOutput GCLogicNPCCounter::GetOnMaxCount_3() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CLogicNPCCounter", "m_OnMaxCount_3"));
    return value;
}
void GCLogicNPCCounter::SetOnMaxCount_3(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CLogicNPCCounter", "m_OnMaxCount_3", false, value);
}
GCEntityInstance GCLogicNPCCounter::GetSource() const {
    GCEntityInstance value(*GetSchemaValuePtr<void*>(m_ptr, "CLogicNPCCounter", "m_hSource"));
    return value;
}
void GCLogicNPCCounter::SetSource(GCEntityInstance* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Source' is not possible.\n");
}
std::string GCLogicNPCCounter::GetSourceEntityName() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CLogicNPCCounter", "m_iszSourceEntityName").String();
}
void GCLogicNPCCounter::SetSourceEntityName(std::string value) {
    SetSchemaValue(m_ptr, "CLogicNPCCounter", "m_iszSourceEntityName", false, CUtlSymbolLarge(value.c_str()));
}
float GCLogicNPCCounter::GetDistanceMax() const {
    return GetSchemaValue<float>(m_ptr, "CLogicNPCCounter", "m_flDistanceMax");
}
void GCLogicNPCCounter::SetDistanceMax(float value) {
    SetSchemaValue(m_ptr, "CLogicNPCCounter", "m_flDistanceMax", false, value);
}
bool GCLogicNPCCounter::GetDisabled() const {
    return GetSchemaValue<bool>(m_ptr, "CLogicNPCCounter", "m_bDisabled");
}
void GCLogicNPCCounter::SetDisabled(bool value) {
    SetSchemaValue(m_ptr, "CLogicNPCCounter", "m_bDisabled", false, value);
}
int32_t GCLogicNPCCounter::GetMinCountAll() const {
    return GetSchemaValue<int32_t>(m_ptr, "CLogicNPCCounter", "m_nMinCountAll");
}
void GCLogicNPCCounter::SetMinCountAll(int32_t value) {
    SetSchemaValue(m_ptr, "CLogicNPCCounter", "m_nMinCountAll", false, value);
}
int32_t GCLogicNPCCounter::GetMaxCountAll() const {
    return GetSchemaValue<int32_t>(m_ptr, "CLogicNPCCounter", "m_nMaxCountAll");
}
void GCLogicNPCCounter::SetMaxCountAll(int32_t value) {
    SetSchemaValue(m_ptr, "CLogicNPCCounter", "m_nMaxCountAll", false, value);
}
int32_t GCLogicNPCCounter::GetMinFactorAll() const {
    return GetSchemaValue<int32_t>(m_ptr, "CLogicNPCCounter", "m_nMinFactorAll");
}
void GCLogicNPCCounter::SetMinFactorAll(int32_t value) {
    SetSchemaValue(m_ptr, "CLogicNPCCounter", "m_nMinFactorAll", false, value);
}
int32_t GCLogicNPCCounter::GetMaxFactorAll() const {
    return GetSchemaValue<int32_t>(m_ptr, "CLogicNPCCounter", "m_nMaxFactorAll");
}
void GCLogicNPCCounter::SetMaxFactorAll(int32_t value) {
    SetSchemaValue(m_ptr, "CLogicNPCCounter", "m_nMaxFactorAll", false, value);
}
std::string GCLogicNPCCounter::GetNPCClassname_1() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CLogicNPCCounter", "m_iszNPCClassname_1").String();
}
void GCLogicNPCCounter::SetNPCClassname_1(std::string value) {
    SetSchemaValue(m_ptr, "CLogicNPCCounter", "m_iszNPCClassname_1", false, CUtlSymbolLarge(value.c_str()));
}
int32_t GCLogicNPCCounter::GetNPCState_1() const {
    return GetSchemaValue<int32_t>(m_ptr, "CLogicNPCCounter", "m_nNPCState_1");
}
void GCLogicNPCCounter::SetNPCState_1(int32_t value) {
    SetSchemaValue(m_ptr, "CLogicNPCCounter", "m_nNPCState_1", false, value);
}
bool GCLogicNPCCounter::GetInvertState_1() const {
    return GetSchemaValue<bool>(m_ptr, "CLogicNPCCounter", "m_bInvertState_1");
}
void GCLogicNPCCounter::SetInvertState_1(bool value) {
    SetSchemaValue(m_ptr, "CLogicNPCCounter", "m_bInvertState_1", false, value);
}
int32_t GCLogicNPCCounter::GetMinCount_1() const {
    return GetSchemaValue<int32_t>(m_ptr, "CLogicNPCCounter", "m_nMinCount_1");
}
void GCLogicNPCCounter::SetMinCount_1(int32_t value) {
    SetSchemaValue(m_ptr, "CLogicNPCCounter", "m_nMinCount_1", false, value);
}
int32_t GCLogicNPCCounter::GetMaxCount_1() const {
    return GetSchemaValue<int32_t>(m_ptr, "CLogicNPCCounter", "m_nMaxCount_1");
}
void GCLogicNPCCounter::SetMaxCount_1(int32_t value) {
    SetSchemaValue(m_ptr, "CLogicNPCCounter", "m_nMaxCount_1", false, value);
}
int32_t GCLogicNPCCounter::GetMinFactor_1() const {
    return GetSchemaValue<int32_t>(m_ptr, "CLogicNPCCounter", "m_nMinFactor_1");
}
void GCLogicNPCCounter::SetMinFactor_1(int32_t value) {
    SetSchemaValue(m_ptr, "CLogicNPCCounter", "m_nMinFactor_1", false, value);
}
int32_t GCLogicNPCCounter::GetMaxFactor_1() const {
    return GetSchemaValue<int32_t>(m_ptr, "CLogicNPCCounter", "m_nMaxFactor_1");
}
void GCLogicNPCCounter::SetMaxFactor_1(int32_t value) {
    SetSchemaValue(m_ptr, "CLogicNPCCounter", "m_nMaxFactor_1", false, value);
}
float GCLogicNPCCounter::GetDefaultDist_1() const {
    return GetSchemaValue<float>(m_ptr, "CLogicNPCCounter", "m_flDefaultDist_1");
}
void GCLogicNPCCounter::SetDefaultDist_1(float value) {
    SetSchemaValue(m_ptr, "CLogicNPCCounter", "m_flDefaultDist_1", false, value);
}
std::string GCLogicNPCCounter::GetNPCClassname_2() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CLogicNPCCounter", "m_iszNPCClassname_2").String();
}
void GCLogicNPCCounter::SetNPCClassname_2(std::string value) {
    SetSchemaValue(m_ptr, "CLogicNPCCounter", "m_iszNPCClassname_2", false, CUtlSymbolLarge(value.c_str()));
}
int32_t GCLogicNPCCounter::GetNPCState_2() const {
    return GetSchemaValue<int32_t>(m_ptr, "CLogicNPCCounter", "m_nNPCState_2");
}
void GCLogicNPCCounter::SetNPCState_2(int32_t value) {
    SetSchemaValue(m_ptr, "CLogicNPCCounter", "m_nNPCState_2", false, value);
}
bool GCLogicNPCCounter::GetInvertState_2() const {
    return GetSchemaValue<bool>(m_ptr, "CLogicNPCCounter", "m_bInvertState_2");
}
void GCLogicNPCCounter::SetInvertState_2(bool value) {
    SetSchemaValue(m_ptr, "CLogicNPCCounter", "m_bInvertState_2", false, value);
}
int32_t GCLogicNPCCounter::GetMinCount_2() const {
    return GetSchemaValue<int32_t>(m_ptr, "CLogicNPCCounter", "m_nMinCount_2");
}
void GCLogicNPCCounter::SetMinCount_2(int32_t value) {
    SetSchemaValue(m_ptr, "CLogicNPCCounter", "m_nMinCount_2", false, value);
}
int32_t GCLogicNPCCounter::GetMaxCount_2() const {
    return GetSchemaValue<int32_t>(m_ptr, "CLogicNPCCounter", "m_nMaxCount_2");
}
void GCLogicNPCCounter::SetMaxCount_2(int32_t value) {
    SetSchemaValue(m_ptr, "CLogicNPCCounter", "m_nMaxCount_2", false, value);
}
int32_t GCLogicNPCCounter::GetMinFactor_2() const {
    return GetSchemaValue<int32_t>(m_ptr, "CLogicNPCCounter", "m_nMinFactor_2");
}
void GCLogicNPCCounter::SetMinFactor_2(int32_t value) {
    SetSchemaValue(m_ptr, "CLogicNPCCounter", "m_nMinFactor_2", false, value);
}
int32_t GCLogicNPCCounter::GetMaxFactor_2() const {
    return GetSchemaValue<int32_t>(m_ptr, "CLogicNPCCounter", "m_nMaxFactor_2");
}
void GCLogicNPCCounter::SetMaxFactor_2(int32_t value) {
    SetSchemaValue(m_ptr, "CLogicNPCCounter", "m_nMaxFactor_2", false, value);
}
float GCLogicNPCCounter::GetDefaultDist_2() const {
    return GetSchemaValue<float>(m_ptr, "CLogicNPCCounter", "m_flDefaultDist_2");
}
void GCLogicNPCCounter::SetDefaultDist_2(float value) {
    SetSchemaValue(m_ptr, "CLogicNPCCounter", "m_flDefaultDist_2", false, value);
}
std::string GCLogicNPCCounter::GetNPCClassname_3() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CLogicNPCCounter", "m_iszNPCClassname_3").String();
}
void GCLogicNPCCounter::SetNPCClassname_3(std::string value) {
    SetSchemaValue(m_ptr, "CLogicNPCCounter", "m_iszNPCClassname_3", false, CUtlSymbolLarge(value.c_str()));
}
int32_t GCLogicNPCCounter::GetNPCState_3() const {
    return GetSchemaValue<int32_t>(m_ptr, "CLogicNPCCounter", "m_nNPCState_3");
}
void GCLogicNPCCounter::SetNPCState_3(int32_t value) {
    SetSchemaValue(m_ptr, "CLogicNPCCounter", "m_nNPCState_3", false, value);
}
bool GCLogicNPCCounter::GetInvertState_3() const {
    return GetSchemaValue<bool>(m_ptr, "CLogicNPCCounter", "m_bInvertState_3");
}
void GCLogicNPCCounter::SetInvertState_3(bool value) {
    SetSchemaValue(m_ptr, "CLogicNPCCounter", "m_bInvertState_3", false, value);
}
int32_t GCLogicNPCCounter::GetMinCount_3() const {
    return GetSchemaValue<int32_t>(m_ptr, "CLogicNPCCounter", "m_nMinCount_3");
}
void GCLogicNPCCounter::SetMinCount_3(int32_t value) {
    SetSchemaValue(m_ptr, "CLogicNPCCounter", "m_nMinCount_3", false, value);
}
int32_t GCLogicNPCCounter::GetMaxCount_3() const {
    return GetSchemaValue<int32_t>(m_ptr, "CLogicNPCCounter", "m_nMaxCount_3");
}
void GCLogicNPCCounter::SetMaxCount_3(int32_t value) {
    SetSchemaValue(m_ptr, "CLogicNPCCounter", "m_nMaxCount_3", false, value);
}
int32_t GCLogicNPCCounter::GetMinFactor_3() const {
    return GetSchemaValue<int32_t>(m_ptr, "CLogicNPCCounter", "m_nMinFactor_3");
}
void GCLogicNPCCounter::SetMinFactor_3(int32_t value) {
    SetSchemaValue(m_ptr, "CLogicNPCCounter", "m_nMinFactor_3", false, value);
}
int32_t GCLogicNPCCounter::GetMaxFactor_3() const {
    return GetSchemaValue<int32_t>(m_ptr, "CLogicNPCCounter", "m_nMaxFactor_3");
}
void GCLogicNPCCounter::SetMaxFactor_3(int32_t value) {
    SetSchemaValue(m_ptr, "CLogicNPCCounter", "m_nMaxFactor_3", false, value);
}
float GCLogicNPCCounter::GetDefaultDist_3() const {
    return GetSchemaValue<float>(m_ptr, "CLogicNPCCounter", "m_flDefaultDist_3");
}
void GCLogicNPCCounter::SetDefaultDist_3(float value) {
    SetSchemaValue(m_ptr, "CLogicNPCCounter", "m_flDefaultDist_3", false, value);
}
std::string GCLogicNPCCounter::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCLogicNPCCounter::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseEntity GCLogicNPCCounter::GetParent() const {
    GCBaseEntity value(m_ptr);
    return value;
}
void GCLogicNPCCounter::SetParent(GCBaseEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCLogicNPCCounter(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCLogicNPCCounter>("CLogicNPCCounter")
        .addConstructor<void (*)(std::string)>()
        .addProperty("OnMinCountAll", &GCLogicNPCCounter::GetOnMinCountAll, &GCLogicNPCCounter::SetOnMinCountAll)
        .addProperty("OnMaxCountAll", &GCLogicNPCCounter::GetOnMaxCountAll, &GCLogicNPCCounter::SetOnMaxCountAll)
        .addProperty("OnMinCount_1", &GCLogicNPCCounter::GetOnMinCount_1, &GCLogicNPCCounter::SetOnMinCount_1)
        .addProperty("OnMaxCount_1", &GCLogicNPCCounter::GetOnMaxCount_1, &GCLogicNPCCounter::SetOnMaxCount_1)
        .addProperty("OnMinCount_2", &GCLogicNPCCounter::GetOnMinCount_2, &GCLogicNPCCounter::SetOnMinCount_2)
        .addProperty("OnMaxCount_2", &GCLogicNPCCounter::GetOnMaxCount_2, &GCLogicNPCCounter::SetOnMaxCount_2)
        .addProperty("OnMinCount_3", &GCLogicNPCCounter::GetOnMinCount_3, &GCLogicNPCCounter::SetOnMinCount_3)
        .addProperty("OnMaxCount_3", &GCLogicNPCCounter::GetOnMaxCount_3, &GCLogicNPCCounter::SetOnMaxCount_3)
        .addProperty("Source", &GCLogicNPCCounter::GetSource, &GCLogicNPCCounter::SetSource)
        .addProperty("SourceEntityName", &GCLogicNPCCounter::GetSourceEntityName, &GCLogicNPCCounter::SetSourceEntityName)
        .addProperty("DistanceMax", &GCLogicNPCCounter::GetDistanceMax, &GCLogicNPCCounter::SetDistanceMax)
        .addProperty("Disabled", &GCLogicNPCCounter::GetDisabled, &GCLogicNPCCounter::SetDisabled)
        .addProperty("MinCountAll", &GCLogicNPCCounter::GetMinCountAll, &GCLogicNPCCounter::SetMinCountAll)
        .addProperty("MaxCountAll", &GCLogicNPCCounter::GetMaxCountAll, &GCLogicNPCCounter::SetMaxCountAll)
        .addProperty("MinFactorAll", &GCLogicNPCCounter::GetMinFactorAll, &GCLogicNPCCounter::SetMinFactorAll)
        .addProperty("MaxFactorAll", &GCLogicNPCCounter::GetMaxFactorAll, &GCLogicNPCCounter::SetMaxFactorAll)
        .addProperty("NPCClassname_1", &GCLogicNPCCounter::GetNPCClassname_1, &GCLogicNPCCounter::SetNPCClassname_1)
        .addProperty("NPCState_1", &GCLogicNPCCounter::GetNPCState_1, &GCLogicNPCCounter::SetNPCState_1)
        .addProperty("InvertState_1", &GCLogicNPCCounter::GetInvertState_1, &GCLogicNPCCounter::SetInvertState_1)
        .addProperty("MinCount_1", &GCLogicNPCCounter::GetMinCount_1, &GCLogicNPCCounter::SetMinCount_1)
        .addProperty("MaxCount_1", &GCLogicNPCCounter::GetMaxCount_1, &GCLogicNPCCounter::SetMaxCount_1)
        .addProperty("MinFactor_1", &GCLogicNPCCounter::GetMinFactor_1, &GCLogicNPCCounter::SetMinFactor_1)
        .addProperty("MaxFactor_1", &GCLogicNPCCounter::GetMaxFactor_1, &GCLogicNPCCounter::SetMaxFactor_1)
        .addProperty("DefaultDist_1", &GCLogicNPCCounter::GetDefaultDist_1, &GCLogicNPCCounter::SetDefaultDist_1)
        .addProperty("NPCClassname_2", &GCLogicNPCCounter::GetNPCClassname_2, &GCLogicNPCCounter::SetNPCClassname_2)
        .addProperty("NPCState_2", &GCLogicNPCCounter::GetNPCState_2, &GCLogicNPCCounter::SetNPCState_2)
        .addProperty("InvertState_2", &GCLogicNPCCounter::GetInvertState_2, &GCLogicNPCCounter::SetInvertState_2)
        .addProperty("MinCount_2", &GCLogicNPCCounter::GetMinCount_2, &GCLogicNPCCounter::SetMinCount_2)
        .addProperty("MaxCount_2", &GCLogicNPCCounter::GetMaxCount_2, &GCLogicNPCCounter::SetMaxCount_2)
        .addProperty("MinFactor_2", &GCLogicNPCCounter::GetMinFactor_2, &GCLogicNPCCounter::SetMinFactor_2)
        .addProperty("MaxFactor_2", &GCLogicNPCCounter::GetMaxFactor_2, &GCLogicNPCCounter::SetMaxFactor_2)
        .addProperty("DefaultDist_2", &GCLogicNPCCounter::GetDefaultDist_2, &GCLogicNPCCounter::SetDefaultDist_2)
        .addProperty("NPCClassname_3", &GCLogicNPCCounter::GetNPCClassname_3, &GCLogicNPCCounter::SetNPCClassname_3)
        .addProperty("NPCState_3", &GCLogicNPCCounter::GetNPCState_3, &GCLogicNPCCounter::SetNPCState_3)
        .addProperty("InvertState_3", &GCLogicNPCCounter::GetInvertState_3, &GCLogicNPCCounter::SetInvertState_3)
        .addProperty("MinCount_3", &GCLogicNPCCounter::GetMinCount_3, &GCLogicNPCCounter::SetMinCount_3)
        .addProperty("MaxCount_3", &GCLogicNPCCounter::GetMaxCount_3, &GCLogicNPCCounter::SetMaxCount_3)
        .addProperty("MinFactor_3", &GCLogicNPCCounter::GetMinFactor_3, &GCLogicNPCCounter::SetMinFactor_3)
        .addProperty("MaxFactor_3", &GCLogicNPCCounter::GetMaxFactor_3, &GCLogicNPCCounter::SetMaxFactor_3)
        .addProperty("DefaultDist_3", &GCLogicNPCCounter::GetDefaultDist_3, &GCLogicNPCCounter::SetDefaultDist_3)
        .addProperty("Parent", &GCLogicNPCCounter::GetParent, &GCLogicNPCCounter::SetParent)
        .addFunction("ToPtr", &GCLogicNPCCounter::ToPtr)
        .addFunction("IsValid", &GCLogicNPCCounter::IsValid)
        .endClass();
}
GCCSObserver_UseServices::GCCSObserver_UseServices(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCCSObserver_UseServices::GCCSObserver_UseServices(void *ptr) {
    m_ptr = ptr;
}
std::string GCCSObserver_UseServices::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCCSObserver_UseServices::IsValid() {
    return (m_ptr != nullptr);
}
GCPlayer_UseServices GCCSObserver_UseServices::GetParent() const {
    GCPlayer_UseServices value(m_ptr);
    return value;
}
void GCCSObserver_UseServices::SetParent(GCPlayer_UseServices value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCCSObserver_UseServices(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCCSObserver_UseServices>("CCSObserver_UseServices")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCCSObserver_UseServices::GetParent, &GCCSObserver_UseServices::SetParent)
        .addFunction("ToPtr", &GCCSObserver_UseServices::ToPtr)
        .addFunction("IsValid", &GCCSObserver_UseServices::IsValid)
        .endClass();
}
GCFuncPlat::GCFuncPlat(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCFuncPlat::GCFuncPlat(void *ptr) {
    m_ptr = ptr;
}
std::string GCFuncPlat::GetNoise() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CFuncPlat", "m_sNoise").String();
}
void GCFuncPlat::SetNoise(std::string value) {
    SetSchemaValue(m_ptr, "CFuncPlat", "m_sNoise", false, CUtlSymbolLarge(value.c_str()));
}
std::string GCFuncPlat::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCFuncPlat::IsValid() {
    return (m_ptr != nullptr);
}
GCBasePlatTrain GCFuncPlat::GetParent() const {
    GCBasePlatTrain value(m_ptr);
    return value;
}
void GCFuncPlat::SetParent(GCBasePlatTrain value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCFuncPlat(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCFuncPlat>("CFuncPlat")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Noise", &GCFuncPlat::GetNoise, &GCFuncPlat::SetNoise)
        .addProperty("Parent", &GCFuncPlat::GetParent, &GCFuncPlat::SetParent)
        .addFunction("ToPtr", &GCFuncPlat::ToPtr)
        .addFunction("IsValid", &GCFuncPlat::IsValid)
        .endClass();
}
GCRuleBrushEntity::GCRuleBrushEntity(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCRuleBrushEntity::GCRuleBrushEntity(void *ptr) {
    m_ptr = ptr;
}
std::string GCRuleBrushEntity::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCRuleBrushEntity::IsValid() {
    return (m_ptr != nullptr);
}
GCRuleEntity GCRuleBrushEntity::GetParent() const {
    GCRuleEntity value(m_ptr);
    return value;
}
void GCRuleBrushEntity::SetParent(GCRuleEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCRuleBrushEntity(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCRuleBrushEntity>("CRuleBrushEntity")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCRuleBrushEntity::GetParent, &GCRuleBrushEntity::SetParent)
        .addFunction("ToPtr", &GCRuleBrushEntity::ToPtr)
        .addFunction("IsValid", &GCRuleBrushEntity::IsValid)
        .endClass();
}
GCRulePointEntity::GCRulePointEntity(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCRulePointEntity::GCRulePointEntity(void *ptr) {
    m_ptr = ptr;
}
int32_t GCRulePointEntity::GetScore() const {
    return GetSchemaValue<int32_t>(m_ptr, "CRulePointEntity", "m_Score");
}
void GCRulePointEntity::SetScore(int32_t value) {
    SetSchemaValue(m_ptr, "CRulePointEntity", "m_Score", false, value);
}
std::string GCRulePointEntity::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCRulePointEntity::IsValid() {
    return (m_ptr != nullptr);
}
GCRuleEntity GCRulePointEntity::GetParent() const {
    GCRuleEntity value(m_ptr);
    return value;
}
void GCRulePointEntity::SetParent(GCRuleEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCRulePointEntity(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCRulePointEntity>("CRulePointEntity")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Score", &GCRulePointEntity::GetScore, &GCRulePointEntity::SetScore)
        .addProperty("Parent", &GCRulePointEntity::GetParent, &GCRulePointEntity::SetParent)
        .addFunction("ToPtr", &GCRulePointEntity::ToPtr)
        .addFunction("IsValid", &GCRulePointEntity::IsValid)
        .endClass();
}
GCMessageEntity::GCMessageEntity(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCMessageEntity::GCMessageEntity(void *ptr) {
    m_ptr = ptr;
}
int32_t GCMessageEntity::GetRadius() const {
    return GetSchemaValue<int32_t>(m_ptr, "CMessageEntity", "m_radius");
}
void GCMessageEntity::SetRadius(int32_t value) {
    SetSchemaValue(m_ptr, "CMessageEntity", "m_radius", false, value);
}
std::string GCMessageEntity::GetMessageText() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CMessageEntity", "m_messageText").String();
}
void GCMessageEntity::SetMessageText(std::string value) {
    SetSchemaValue(m_ptr, "CMessageEntity", "m_messageText", false, CUtlSymbolLarge(value.c_str()));
}
bool GCMessageEntity::GetDrawText() const {
    return GetSchemaValue<bool>(m_ptr, "CMessageEntity", "m_drawText");
}
void GCMessageEntity::SetDrawText(bool value) {
    SetSchemaValue(m_ptr, "CMessageEntity", "m_drawText", false, value);
}
bool GCMessageEntity::GetDeveloperOnly() const {
    return GetSchemaValue<bool>(m_ptr, "CMessageEntity", "m_bDeveloperOnly");
}
void GCMessageEntity::SetDeveloperOnly(bool value) {
    SetSchemaValue(m_ptr, "CMessageEntity", "m_bDeveloperOnly", false, value);
}
bool GCMessageEntity::GetEnabled() const {
    return GetSchemaValue<bool>(m_ptr, "CMessageEntity", "m_bEnabled");
}
void GCMessageEntity::SetEnabled(bool value) {
    SetSchemaValue(m_ptr, "CMessageEntity", "m_bEnabled", false, value);
}
std::string GCMessageEntity::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCMessageEntity::IsValid() {
    return (m_ptr != nullptr);
}
GCPointEntity GCMessageEntity::GetParent() const {
    GCPointEntity value(m_ptr);
    return value;
}
void GCMessageEntity::SetParent(GCPointEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCMessageEntity(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCMessageEntity>("CMessageEntity")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Radius", &GCMessageEntity::GetRadius, &GCMessageEntity::SetRadius)
        .addProperty("MessageText", &GCMessageEntity::GetMessageText, &GCMessageEntity::SetMessageText)
        .addProperty("DrawText", &GCMessageEntity::GetDrawText, &GCMessageEntity::SetDrawText)
        .addProperty("DeveloperOnly", &GCMessageEntity::GetDeveloperOnly, &GCMessageEntity::SetDeveloperOnly)
        .addProperty("Enabled", &GCMessageEntity::GetEnabled, &GCMessageEntity::SetEnabled)
        .addProperty("Parent", &GCMessageEntity::GetParent, &GCMessageEntity::SetParent)
        .addFunction("ToPtr", &GCMessageEntity::ToPtr)
        .addFunction("IsValid", &GCMessageEntity::IsValid)
        .endClass();
}
GCSmokeGrenade::GCSmokeGrenade(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCSmokeGrenade::GCSmokeGrenade(void *ptr) {
    m_ptr = ptr;
}
std::string GCSmokeGrenade::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCSmokeGrenade::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseCSGrenade GCSmokeGrenade::GetParent() const {
    GCBaseCSGrenade value(m_ptr);
    return value;
}
void GCSmokeGrenade::SetParent(GCBaseCSGrenade value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCSmokeGrenade(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCSmokeGrenade>("CSmokeGrenade")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCSmokeGrenade::GetParent, &GCSmokeGrenade::SetParent)
        .addFunction("ToPtr", &GCSmokeGrenade::ToPtr)
        .addFunction("IsValid", &GCSmokeGrenade::IsValid)
        .endClass();
}
GCBaseViewModel::GCBaseViewModel(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCBaseViewModel::GCBaseViewModel(void *ptr) {
    m_ptr = ptr;
}
Vector GCBaseViewModel::GetLastFacing() const {
    return GetSchemaValue<Vector>(m_ptr, "CBaseViewModel", "m_vecLastFacing");
}
void GCBaseViewModel::SetLastFacing(Vector value) {
    SetSchemaValue(m_ptr, "CBaseViewModel", "m_vecLastFacing", false, value);
}
uint32_t GCBaseViewModel::GetViewModelIndex() const {
    return GetSchemaValue<uint32_t>(m_ptr, "CBaseViewModel", "m_nViewModelIndex");
}
void GCBaseViewModel::SetViewModelIndex(uint32_t value) {
    SetSchemaValue(m_ptr, "CBaseViewModel", "m_nViewModelIndex", false, value);
}
uint32_t GCBaseViewModel::GetAnimationParity() const {
    return GetSchemaValue<uint32_t>(m_ptr, "CBaseViewModel", "m_nAnimationParity");
}
void GCBaseViewModel::SetAnimationParity(uint32_t value) {
    SetSchemaValue(m_ptr, "CBaseViewModel", "m_nAnimationParity", false, value);
}
float GCBaseViewModel::GetAnimationStartTime() const {
    return GetSchemaValue<float>(m_ptr, "CBaseViewModel", "m_flAnimationStartTime");
}
void GCBaseViewModel::SetAnimationStartTime(float value) {
    SetSchemaValue(m_ptr, "CBaseViewModel", "m_flAnimationStartTime", false, value);
}
GCBasePlayerWeapon GCBaseViewModel::GetWeapon() const {
    GCBasePlayerWeapon value(*GetSchemaValuePtr<void*>(m_ptr, "CBaseViewModel", "m_hWeapon"));
    return value;
}
void GCBaseViewModel::SetWeapon(GCBasePlayerWeapon* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Weapon' is not possible.\n");
}
std::string GCBaseViewModel::GetVMName() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CBaseViewModel", "m_sVMName").String();
}
void GCBaseViewModel::SetVMName(std::string value) {
    SetSchemaValue(m_ptr, "CBaseViewModel", "m_sVMName", false, CUtlSymbolLarge(value.c_str()));
}
std::string GCBaseViewModel::GetAnimationPrefix() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CBaseViewModel", "m_sAnimationPrefix").String();
}
void GCBaseViewModel::SetAnimationPrefix(std::string value) {
    SetSchemaValue(m_ptr, "CBaseViewModel", "m_sAnimationPrefix", false, CUtlSymbolLarge(value.c_str()));
}
int32_t GCBaseViewModel::GetOldLayer() const {
    return GetSchemaValue<int32_t>(m_ptr, "CBaseViewModel", "m_oldLayer");
}
void GCBaseViewModel::SetOldLayer(int32_t value) {
    SetSchemaValue(m_ptr, "CBaseViewModel", "m_oldLayer", false, value);
}
float GCBaseViewModel::GetOldLayerStartTime() const {
    return GetSchemaValue<float>(m_ptr, "CBaseViewModel", "m_oldLayerStartTime");
}
void GCBaseViewModel::SetOldLayerStartTime(float value) {
    SetSchemaValue(m_ptr, "CBaseViewModel", "m_oldLayerStartTime", false, value);
}
GCBaseEntity GCBaseViewModel::GetControlPanel() const {
    GCBaseEntity value(*GetSchemaValuePtr<void*>(m_ptr, "CBaseViewModel", "m_hControlPanel"));
    return value;
}
void GCBaseViewModel::SetControlPanel(GCBaseEntity* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'ControlPanel' is not possible.\n");
}
std::string GCBaseViewModel::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCBaseViewModel::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseAnimGraph GCBaseViewModel::GetParent() const {
    GCBaseAnimGraph value(m_ptr);
    return value;
}
void GCBaseViewModel::SetParent(GCBaseAnimGraph value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCBaseViewModel(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCBaseViewModel>("CBaseViewModel")
        .addConstructor<void (*)(std::string)>()
        .addProperty("LastFacing", &GCBaseViewModel::GetLastFacing, &GCBaseViewModel::SetLastFacing)
        .addProperty("ViewModelIndex", &GCBaseViewModel::GetViewModelIndex, &GCBaseViewModel::SetViewModelIndex)
        .addProperty("AnimationParity", &GCBaseViewModel::GetAnimationParity, &GCBaseViewModel::SetAnimationParity)
        .addProperty("AnimationStartTime", &GCBaseViewModel::GetAnimationStartTime, &GCBaseViewModel::SetAnimationStartTime)
        .addProperty("Weapon", &GCBaseViewModel::GetWeapon, &GCBaseViewModel::SetWeapon)
        .addProperty("VMName", &GCBaseViewModel::GetVMName, &GCBaseViewModel::SetVMName)
        .addProperty("AnimationPrefix", &GCBaseViewModel::GetAnimationPrefix, &GCBaseViewModel::SetAnimationPrefix)
        .addProperty("OldLayer", &GCBaseViewModel::GetOldLayer, &GCBaseViewModel::SetOldLayer)
        .addProperty("OldLayerStartTime", &GCBaseViewModel::GetOldLayerStartTime, &GCBaseViewModel::SetOldLayerStartTime)
        .addProperty("ControlPanel", &GCBaseViewModel::GetControlPanel, &GCBaseViewModel::SetControlPanel)
        .addProperty("Parent", &GCBaseViewModel::GetParent, &GCBaseViewModel::SetParent)
        .addFunction("ToPtr", &GCBaseViewModel::ToPtr)
        .addFunction("IsValid", &GCBaseViewModel::IsValid)
        .endClass();
}
GCCSPlayer_PingServices::GCCSPlayer_PingServices(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCCSPlayer_PingServices::GCCSPlayer_PingServices(void *ptr) {
    m_ptr = ptr;
}
std::vector<float> GCCSPlayer_PingServices::GetPlayerPingTokens() const {
    float* outValue = GetSchemaValue<float*>(m_ptr, "CCSPlayer_PingServices", "m_flPlayerPingTokens"); std::vector<float> ret; for(int i = 0; i < 5; i++) { ret.push_back(outValue[i]); } return ret;
}
void GCCSPlayer_PingServices::SetPlayerPingTokens(std::vector<float> value) {
    float* outValue = GetSchemaValue<float*>(m_ptr, "CCSPlayer_PingServices", "m_flPlayerPingTokens"); for(int i = 0; i < 5; i++) { outValue[i] = value[i]; } SetSchemaValue(m_ptr, "CCSPlayer_PingServices", "m_flPlayerPingTokens", false, outValue);
}
GCBaseEntity GCCSPlayer_PingServices::GetPlayerPing() const {
    GCBaseEntity value(*GetSchemaValuePtr<void*>(m_ptr, "CCSPlayer_PingServices", "m_hPlayerPing"));
    return value;
}
void GCCSPlayer_PingServices::SetPlayerPing(GCBaseEntity* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'PlayerPing' is not possible.\n");
}
std::string GCCSPlayer_PingServices::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCCSPlayer_PingServices::IsValid() {
    return (m_ptr != nullptr);
}
GCPlayerPawnComponent GCCSPlayer_PingServices::GetParent() const {
    GCPlayerPawnComponent value(m_ptr);
    return value;
}
void GCCSPlayer_PingServices::SetParent(GCPlayerPawnComponent value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCCSPlayer_PingServices(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCCSPlayer_PingServices>("CCSPlayer_PingServices")
        .addConstructor<void (*)(std::string)>()
        .addProperty("PlayerPingTokens", &GCCSPlayer_PingServices::GetPlayerPingTokens, &GCCSPlayer_PingServices::SetPlayerPingTokens)
        .addProperty("PlayerPing", &GCCSPlayer_PingServices::GetPlayerPing, &GCCSPlayer_PingServices::SetPlayerPing)
        .addProperty("Parent", &GCCSPlayer_PingServices::GetParent, &GCCSPlayer_PingServices::SetParent)
        .addFunction("ToPtr", &GCCSPlayer_PingServices::ToPtr)
        .addFunction("IsValid", &GCCSPlayer_PingServices::IsValid)
        .endClass();
}
GCPlayer_FlashlightServices::GCPlayer_FlashlightServices(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCPlayer_FlashlightServices::GCPlayer_FlashlightServices(void *ptr) {
    m_ptr = ptr;
}
std::string GCPlayer_FlashlightServices::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCPlayer_FlashlightServices::IsValid() {
    return (m_ptr != nullptr);
}
GCPlayerPawnComponent GCPlayer_FlashlightServices::GetParent() const {
    GCPlayerPawnComponent value(m_ptr);
    return value;
}
void GCPlayer_FlashlightServices::SetParent(GCPlayerPawnComponent value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCPlayer_FlashlightServices(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCPlayer_FlashlightServices>("CPlayer_FlashlightServices")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCPlayer_FlashlightServices::GetParent, &GCPlayer_FlashlightServices::SetParent)
        .addFunction("ToPtr", &GCPlayer_FlashlightServices::ToPtr)
        .addFunction("IsValid", &GCPlayer_FlashlightServices::IsValid)
        .endClass();
}
GCServerOnlyModelEntity::GCServerOnlyModelEntity(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCServerOnlyModelEntity::GCServerOnlyModelEntity(void *ptr) {
    m_ptr = ptr;
}
std::string GCServerOnlyModelEntity::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCServerOnlyModelEntity::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseModelEntity GCServerOnlyModelEntity::GetParent() const {
    GCBaseModelEntity value(m_ptr);
    return value;
}
void GCServerOnlyModelEntity::SetParent(GCBaseModelEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCServerOnlyModelEntity(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCServerOnlyModelEntity>("CServerOnlyModelEntity")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCServerOnlyModelEntity::GetParent, &GCServerOnlyModelEntity::SetParent)
        .addFunction("ToPtr", &GCServerOnlyModelEntity::ToPtr)
        .addFunction("IsValid", &GCServerOnlyModelEntity::IsValid)
        .endClass();
}
GCBtActionCombatPositioning::GCBtActionCombatPositioning(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCBtActionCombatPositioning::GCBtActionCombatPositioning(void *ptr) {
    m_ptr = ptr;
}
std::string GCBtActionCombatPositioning::GetSensorInputKey() const {
    return GetSchemaValue<CUtlString>(m_ptr, "CBtActionCombatPositioning", "m_szSensorInputKey").Get();
}
void GCBtActionCombatPositioning::SetSensorInputKey(std::string value) {
    SetSchemaValue(m_ptr, "CBtActionCombatPositioning", "m_szSensorInputKey", false, CUtlString(value.c_str()));
}
std::string GCBtActionCombatPositioning::GetIsAttackingKey() const {
    return GetSchemaValue<CUtlString>(m_ptr, "CBtActionCombatPositioning", "m_szIsAttackingKey").Get();
}
void GCBtActionCombatPositioning::SetIsAttackingKey(std::string value) {
    SetSchemaValue(m_ptr, "CBtActionCombatPositioning", "m_szIsAttackingKey", false, CUtlString(value.c_str()));
}
GCountdownTimer GCBtActionCombatPositioning::GetActionTimer() const {
    GCountdownTimer value(GetSchemaPtr(m_ptr, "CBtActionCombatPositioning", "m_ActionTimer"));
    return value;
}
void GCBtActionCombatPositioning::SetActionTimer(GCountdownTimer value) {
    SetSchemaValue(m_ptr, "CBtActionCombatPositioning", "m_ActionTimer", false, value);
}
bool GCBtActionCombatPositioning::GetCrouching() const {
    return GetSchemaValue<bool>(m_ptr, "CBtActionCombatPositioning", "m_bCrouching");
}
void GCBtActionCombatPositioning::SetCrouching(bool value) {
    SetSchemaValue(m_ptr, "CBtActionCombatPositioning", "m_bCrouching", false, value);
}
std::string GCBtActionCombatPositioning::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCBtActionCombatPositioning::IsValid() {
    return (m_ptr != nullptr);
}
GCBtNode GCBtActionCombatPositioning::GetParent() const {
    GCBtNode value(m_ptr);
    return value;
}
void GCBtActionCombatPositioning::SetParent(GCBtNode value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCBtActionCombatPositioning(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCBtActionCombatPositioning>("CBtActionCombatPositioning")
        .addConstructor<void (*)(std::string)>()
        .addProperty("SensorInputKey", &GCBtActionCombatPositioning::GetSensorInputKey, &GCBtActionCombatPositioning::SetSensorInputKey)
        .addProperty("IsAttackingKey", &GCBtActionCombatPositioning::GetIsAttackingKey, &GCBtActionCombatPositioning::SetIsAttackingKey)
        .addProperty("ActionTimer", &GCBtActionCombatPositioning::GetActionTimer, &GCBtActionCombatPositioning::SetActionTimer)
        .addProperty("Crouching", &GCBtActionCombatPositioning::GetCrouching, &GCBtActionCombatPositioning::SetCrouching)
        .addProperty("Parent", &GCBtActionCombatPositioning::GetParent, &GCBtActionCombatPositioning::SetParent)
        .addFunction("ToPtr", &GCBtActionCombatPositioning::ToPtr)
        .addFunction("IsValid", &GCBtActionCombatPositioning::IsValid)
        .endClass();
}
GCFireSmoke::GCFireSmoke(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCFireSmoke::GCFireSmoke(void *ptr) {
    m_ptr = ptr;
}
int32_t GCFireSmoke::GetFlameModelIndex() const {
    return GetSchemaValue<int32_t>(m_ptr, "CFireSmoke", "m_nFlameModelIndex");
}
void GCFireSmoke::SetFlameModelIndex(int32_t value) {
    SetSchemaValue(m_ptr, "CFireSmoke", "m_nFlameModelIndex", false, value);
}
int32_t GCFireSmoke::GetFlameFromAboveModelIndex() const {
    return GetSchemaValue<int32_t>(m_ptr, "CFireSmoke", "m_nFlameFromAboveModelIndex");
}
void GCFireSmoke::SetFlameFromAboveModelIndex(int32_t value) {
    SetSchemaValue(m_ptr, "CFireSmoke", "m_nFlameFromAboveModelIndex", false, value);
}
std::string GCFireSmoke::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCFireSmoke::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseFire GCFireSmoke::GetParent() const {
    GCBaseFire value(m_ptr);
    return value;
}
void GCFireSmoke::SetParent(GCBaseFire value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCFireSmoke(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCFireSmoke>("CFireSmoke")
        .addConstructor<void (*)(std::string)>()
        .addProperty("FlameModelIndex", &GCFireSmoke::GetFlameModelIndex, &GCFireSmoke::SetFlameModelIndex)
        .addProperty("FlameFromAboveModelIndex", &GCFireSmoke::GetFlameFromAboveModelIndex, &GCFireSmoke::SetFlameFromAboveModelIndex)
        .addProperty("Parent", &GCFireSmoke::GetParent, &GCFireSmoke::SetParent)
        .addFunction("ToPtr", &GCFireSmoke::ToPtr)
        .addFunction("IsValid", &GCFireSmoke::IsValid)
        .endClass();
}
GCCSWeaponBaseGun::GCCSWeaponBaseGun(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCCSWeaponBaseGun::GCCSWeaponBaseGun(void *ptr) {
    m_ptr = ptr;
}
int32_t GCCSWeaponBaseGun::GetZoomLevel() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSWeaponBaseGun", "m_zoomLevel");
}
void GCCSWeaponBaseGun::SetZoomLevel(int32_t value) {
    SetSchemaValue(m_ptr, "CCSWeaponBaseGun", "m_zoomLevel", false, value);
}
int32_t GCCSWeaponBaseGun::GetBurstShotsRemaining() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSWeaponBaseGun", "m_iBurstShotsRemaining");
}
void GCCSWeaponBaseGun::SetBurstShotsRemaining(int32_t value) {
    SetSchemaValue(m_ptr, "CCSWeaponBaseGun", "m_iBurstShotsRemaining", false, value);
}
int32_t GCCSWeaponBaseGun::GetSilencedModelIndex() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSWeaponBaseGun", "m_silencedModelIndex");
}
void GCCSWeaponBaseGun::SetSilencedModelIndex(int32_t value) {
    SetSchemaValue(m_ptr, "CCSWeaponBaseGun", "m_silencedModelIndex", false, value);
}
bool GCCSWeaponBaseGun::GetInPrecache() const {
    return GetSchemaValue<bool>(m_ptr, "CCSWeaponBaseGun", "m_inPrecache");
}
void GCCSWeaponBaseGun::SetInPrecache(bool value) {
    SetSchemaValue(m_ptr, "CCSWeaponBaseGun", "m_inPrecache", false, value);
}
bool GCCSWeaponBaseGun::GetNeedsBoltAction() const {
    return GetSchemaValue<bool>(m_ptr, "CCSWeaponBaseGun", "m_bNeedsBoltAction");
}
void GCCSWeaponBaseGun::SetNeedsBoltAction(bool value) {
    SetSchemaValue(m_ptr, "CCSWeaponBaseGun", "m_bNeedsBoltAction", false, value);
}
bool GCCSWeaponBaseGun::GetSkillReloadAvailable() const {
    return GetSchemaValue<bool>(m_ptr, "CCSWeaponBaseGun", "m_bSkillReloadAvailable");
}
void GCCSWeaponBaseGun::SetSkillReloadAvailable(bool value) {
    SetSchemaValue(m_ptr, "CCSWeaponBaseGun", "m_bSkillReloadAvailable", false, value);
}
bool GCCSWeaponBaseGun::GetSkillReloadLiftedReloadKey() const {
    return GetSchemaValue<bool>(m_ptr, "CCSWeaponBaseGun", "m_bSkillReloadLiftedReloadKey");
}
void GCCSWeaponBaseGun::SetSkillReloadLiftedReloadKey(bool value) {
    SetSchemaValue(m_ptr, "CCSWeaponBaseGun", "m_bSkillReloadLiftedReloadKey", false, value);
}
bool GCCSWeaponBaseGun::GetSkillBoltInterruptAvailable() const {
    return GetSchemaValue<bool>(m_ptr, "CCSWeaponBaseGun", "m_bSkillBoltInterruptAvailable");
}
void GCCSWeaponBaseGun::SetSkillBoltInterruptAvailable(bool value) {
    SetSchemaValue(m_ptr, "CCSWeaponBaseGun", "m_bSkillBoltInterruptAvailable", false, value);
}
bool GCCSWeaponBaseGun::GetSkillBoltLiftedFireKey() const {
    return GetSchemaValue<bool>(m_ptr, "CCSWeaponBaseGun", "m_bSkillBoltLiftedFireKey");
}
void GCCSWeaponBaseGun::SetSkillBoltLiftedFireKey(bool value) {
    SetSchemaValue(m_ptr, "CCSWeaponBaseGun", "m_bSkillBoltLiftedFireKey", false, value);
}
std::string GCCSWeaponBaseGun::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCCSWeaponBaseGun::IsValid() {
    return (m_ptr != nullptr);
}
GCCSWeaponBase GCCSWeaponBaseGun::GetParent() const {
    GCCSWeaponBase value(m_ptr);
    return value;
}
void GCCSWeaponBaseGun::SetParent(GCCSWeaponBase value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCCSWeaponBaseGun(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCCSWeaponBaseGun>("CCSWeaponBaseGun")
        .addConstructor<void (*)(std::string)>()
        .addProperty("ZoomLevel", &GCCSWeaponBaseGun::GetZoomLevel, &GCCSWeaponBaseGun::SetZoomLevel)
        .addProperty("BurstShotsRemaining", &GCCSWeaponBaseGun::GetBurstShotsRemaining, &GCCSWeaponBaseGun::SetBurstShotsRemaining)
        .addProperty("SilencedModelIndex", &GCCSWeaponBaseGun::GetSilencedModelIndex, &GCCSWeaponBaseGun::SetSilencedModelIndex)
        .addProperty("InPrecache", &GCCSWeaponBaseGun::GetInPrecache, &GCCSWeaponBaseGun::SetInPrecache)
        .addProperty("NeedsBoltAction", &GCCSWeaponBaseGun::GetNeedsBoltAction, &GCCSWeaponBaseGun::SetNeedsBoltAction)
        .addProperty("SkillReloadAvailable", &GCCSWeaponBaseGun::GetSkillReloadAvailable, &GCCSWeaponBaseGun::SetSkillReloadAvailable)
        .addProperty("SkillReloadLiftedReloadKey", &GCCSWeaponBaseGun::GetSkillReloadLiftedReloadKey, &GCCSWeaponBaseGun::SetSkillReloadLiftedReloadKey)
        .addProperty("SkillBoltInterruptAvailable", &GCCSWeaponBaseGun::GetSkillBoltInterruptAvailable, &GCCSWeaponBaseGun::SetSkillBoltInterruptAvailable)
        .addProperty("SkillBoltLiftedFireKey", &GCCSWeaponBaseGun::GetSkillBoltLiftedFireKey, &GCCSWeaponBaseGun::SetSkillBoltLiftedFireKey)
        .addProperty("Parent", &GCCSWeaponBaseGun::GetParent, &GCCSWeaponBaseGun::SetParent)
        .addFunction("ToPtr", &GCCSWeaponBaseGun::ToPtr)
        .addFunction("IsValid", &GCCSWeaponBaseGun::IsValid)
        .endClass();
}
GCWeaponGlock::GCWeaponGlock(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCWeaponGlock::GCWeaponGlock(void *ptr) {
    m_ptr = ptr;
}
std::string GCWeaponGlock::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCWeaponGlock::IsValid() {
    return (m_ptr != nullptr);
}
GCCSWeaponBaseGun GCWeaponGlock::GetParent() const {
    GCCSWeaponBaseGun value(m_ptr);
    return value;
}
void GCWeaponGlock::SetParent(GCCSWeaponBaseGun value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCWeaponGlock(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCWeaponGlock>("CWeaponGlock")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCWeaponGlock::GetParent, &GCWeaponGlock::SetParent)
        .addFunction("ToPtr", &GCWeaponGlock::ToPtr)
        .addFunction("IsValid", &GCWeaponGlock::IsValid)
        .endClass();
}
GCPredictedViewModel::GCPredictedViewModel(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCPredictedViewModel::GCPredictedViewModel(void *ptr) {
    m_ptr = ptr;
}
std::string GCPredictedViewModel::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCPredictedViewModel::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseViewModel GCPredictedViewModel::GetParent() const {
    GCBaseViewModel value(m_ptr);
    return value;
}
void GCPredictedViewModel::SetParent(GCBaseViewModel value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCPredictedViewModel(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCPredictedViewModel>("CPredictedViewModel")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCPredictedViewModel::GetParent, &GCPredictedViewModel::SetParent)
        .addFunction("ToPtr", &GCPredictedViewModel::ToPtr)
        .addFunction("IsValid", &GCPredictedViewModel::IsValid)
        .endClass();
}
GCTriggerActiveWeaponDetect::GCTriggerActiveWeaponDetect(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCTriggerActiveWeaponDetect::GCTriggerActiveWeaponDetect(void *ptr) {
    m_ptr = ptr;
}
GCEntityIOOutput GCTriggerActiveWeaponDetect::GetOnTouchedActiveWeapon() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CTriggerActiveWeaponDetect", "m_OnTouchedActiveWeapon"));
    return value;
}
void GCTriggerActiveWeaponDetect::SetOnTouchedActiveWeapon(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CTriggerActiveWeaponDetect", "m_OnTouchedActiveWeapon", false, value);
}
std::string GCTriggerActiveWeaponDetect::GetWeaponClassName() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CTriggerActiveWeaponDetect", "m_iszWeaponClassName").String();
}
void GCTriggerActiveWeaponDetect::SetWeaponClassName(std::string value) {
    SetSchemaValue(m_ptr, "CTriggerActiveWeaponDetect", "m_iszWeaponClassName", false, CUtlSymbolLarge(value.c_str()));
}
std::string GCTriggerActiveWeaponDetect::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCTriggerActiveWeaponDetect::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseTrigger GCTriggerActiveWeaponDetect::GetParent() const {
    GCBaseTrigger value(m_ptr);
    return value;
}
void GCTriggerActiveWeaponDetect::SetParent(GCBaseTrigger value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCTriggerActiveWeaponDetect(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCTriggerActiveWeaponDetect>("CTriggerActiveWeaponDetect")
        .addConstructor<void (*)(std::string)>()
        .addProperty("OnTouchedActiveWeapon", &GCTriggerActiveWeaponDetect::GetOnTouchedActiveWeapon, &GCTriggerActiveWeaponDetect::SetOnTouchedActiveWeapon)
        .addProperty("WeaponClassName", &GCTriggerActiveWeaponDetect::GetWeaponClassName, &GCTriggerActiveWeaponDetect::SetWeaponClassName)
        .addProperty("Parent", &GCTriggerActiveWeaponDetect::GetParent, &GCTriggerActiveWeaponDetect::SetParent)
        .addFunction("ToPtr", &GCTriggerActiveWeaponDetect::ToPtr)
        .addFunction("IsValid", &GCTriggerActiveWeaponDetect::IsValid)
        .endClass();
}
GCEnvMicrophone::GCEnvMicrophone(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCEnvMicrophone::GCEnvMicrophone(void *ptr) {
    m_ptr = ptr;
}
bool GCEnvMicrophone::GetDisabled() const {
    return GetSchemaValue<bool>(m_ptr, "CEnvMicrophone", "m_bDisabled");
}
void GCEnvMicrophone::SetDisabled(bool value) {
    SetSchemaValue(m_ptr, "CEnvMicrophone", "m_bDisabled", false, value);
}
GCBaseEntity GCEnvMicrophone::GetMeasureTarget() const {
    GCBaseEntity value(*GetSchemaValuePtr<void*>(m_ptr, "CEnvMicrophone", "m_hMeasureTarget"));
    return value;
}
void GCEnvMicrophone::SetMeasureTarget(GCBaseEntity* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'MeasureTarget' is not possible.\n");
}
uint64_t GCEnvMicrophone::GetSoundType() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CEnvMicrophone", "m_nSoundType");
}
void GCEnvMicrophone::SetSoundType(uint64_t value) {
    SetSchemaValue(m_ptr, "CEnvMicrophone", "m_nSoundType", false, value);
}
uint64_t GCEnvMicrophone::GetSoundFlags() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CEnvMicrophone", "m_nSoundFlags");
}
void GCEnvMicrophone::SetSoundFlags(uint64_t value) {
    SetSchemaValue(m_ptr, "CEnvMicrophone", "m_nSoundFlags", false, value);
}
float GCEnvMicrophone::GetSensitivity() const {
    return GetSchemaValue<float>(m_ptr, "CEnvMicrophone", "m_flSensitivity");
}
void GCEnvMicrophone::SetSensitivity(float value) {
    SetSchemaValue(m_ptr, "CEnvMicrophone", "m_flSensitivity", false, value);
}
float GCEnvMicrophone::GetSmoothFactor() const {
    return GetSchemaValue<float>(m_ptr, "CEnvMicrophone", "m_flSmoothFactor");
}
void GCEnvMicrophone::SetSmoothFactor(float value) {
    SetSchemaValue(m_ptr, "CEnvMicrophone", "m_flSmoothFactor", false, value);
}
float GCEnvMicrophone::GetMaxRange() const {
    return GetSchemaValue<float>(m_ptr, "CEnvMicrophone", "m_flMaxRange");
}
void GCEnvMicrophone::SetMaxRange(float value) {
    SetSchemaValue(m_ptr, "CEnvMicrophone", "m_flMaxRange", false, value);
}
std::string GCEnvMicrophone::GetSpeakerName() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CEnvMicrophone", "m_iszSpeakerName").String();
}
void GCEnvMicrophone::SetSpeakerName(std::string value) {
    SetSchemaValue(m_ptr, "CEnvMicrophone", "m_iszSpeakerName", false, CUtlSymbolLarge(value.c_str()));
}
GCBaseEntity GCEnvMicrophone::GetSpeaker() const {
    GCBaseEntity value(*GetSchemaValuePtr<void*>(m_ptr, "CEnvMicrophone", "m_hSpeaker"));
    return value;
}
void GCEnvMicrophone::SetSpeaker(GCBaseEntity* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Speaker' is not possible.\n");
}
bool GCEnvMicrophone::GetAvoidFeedback() const {
    return GetSchemaValue<bool>(m_ptr, "CEnvMicrophone", "m_bAvoidFeedback");
}
void GCEnvMicrophone::SetAvoidFeedback(bool value) {
    SetSchemaValue(m_ptr, "CEnvMicrophone", "m_bAvoidFeedback", false, value);
}
int32_t GCEnvMicrophone::GetSpeakerDSPPreset() const {
    return GetSchemaValue<int32_t>(m_ptr, "CEnvMicrophone", "m_iSpeakerDSPPreset");
}
void GCEnvMicrophone::SetSpeakerDSPPreset(int32_t value) {
    SetSchemaValue(m_ptr, "CEnvMicrophone", "m_iSpeakerDSPPreset", false, value);
}
std::string GCEnvMicrophone::GetListenFilter() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CEnvMicrophone", "m_iszListenFilter").String();
}
void GCEnvMicrophone::SetListenFilter(std::string value) {
    SetSchemaValue(m_ptr, "CEnvMicrophone", "m_iszListenFilter", false, CUtlSymbolLarge(value.c_str()));
}
GCBaseFilter GCEnvMicrophone::GetListenFilter1() const {
    GCBaseFilter value(*GetSchemaValuePtr<void*>(m_ptr, "CEnvMicrophone", "m_hListenFilter"));
    return value;
}
void GCEnvMicrophone::SetListenFilter1(GCBaseFilter* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'ListenFilter1' is not possible.\n");
}
GCEntityIOOutput GCEnvMicrophone::GetOnRoutedSound() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CEnvMicrophone", "m_OnRoutedSound"));
    return value;
}
void GCEnvMicrophone::SetOnRoutedSound(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CEnvMicrophone", "m_OnRoutedSound", false, value);
}
GCEntityIOOutput GCEnvMicrophone::GetOnHeardSound() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CEnvMicrophone", "m_OnHeardSound"));
    return value;
}
void GCEnvMicrophone::SetOnHeardSound(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CEnvMicrophone", "m_OnHeardSound", false, value);
}
std::string GCEnvMicrophone::GetLastSound() const {
    return GetSchemaValuePtr<char>(m_ptr, "CEnvMicrophone", "m_szLastSound");
}
void GCEnvMicrophone::SetLastSound(std::string value) {
    WriteSchemaPtrValue(m_ptr, "CEnvMicrophone", "m_szLastSound", false, reinterpret_cast<byte*>(const_cast<char*>(value.c_str())), 256);
}
int32_t GCEnvMicrophone::GetLastRoutedFrame() const {
    return GetSchemaValue<int32_t>(m_ptr, "CEnvMicrophone", "m_iLastRoutedFrame");
}
void GCEnvMicrophone::SetLastRoutedFrame(int32_t value) {
    SetSchemaValue(m_ptr, "CEnvMicrophone", "m_iLastRoutedFrame", false, value);
}
std::string GCEnvMicrophone::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCEnvMicrophone::IsValid() {
    return (m_ptr != nullptr);
}
GCPointEntity GCEnvMicrophone::GetParent() const {
    GCPointEntity value(m_ptr);
    return value;
}
void GCEnvMicrophone::SetParent(GCPointEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCEnvMicrophone(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCEnvMicrophone>("CEnvMicrophone")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Disabled", &GCEnvMicrophone::GetDisabled, &GCEnvMicrophone::SetDisabled)
        .addProperty("MeasureTarget", &GCEnvMicrophone::GetMeasureTarget, &GCEnvMicrophone::SetMeasureTarget)
        .addProperty("SoundType", &GCEnvMicrophone::GetSoundType, &GCEnvMicrophone::SetSoundType)
        .addProperty("SoundFlags", &GCEnvMicrophone::GetSoundFlags, &GCEnvMicrophone::SetSoundFlags)
        .addProperty("Sensitivity", &GCEnvMicrophone::GetSensitivity, &GCEnvMicrophone::SetSensitivity)
        .addProperty("SmoothFactor", &GCEnvMicrophone::GetSmoothFactor, &GCEnvMicrophone::SetSmoothFactor)
        .addProperty("MaxRange", &GCEnvMicrophone::GetMaxRange, &GCEnvMicrophone::SetMaxRange)
        .addProperty("SpeakerName", &GCEnvMicrophone::GetSpeakerName, &GCEnvMicrophone::SetSpeakerName)
        .addProperty("Speaker", &GCEnvMicrophone::GetSpeaker, &GCEnvMicrophone::SetSpeaker)
        .addProperty("AvoidFeedback", &GCEnvMicrophone::GetAvoidFeedback, &GCEnvMicrophone::SetAvoidFeedback)
        .addProperty("SpeakerDSPPreset", &GCEnvMicrophone::GetSpeakerDSPPreset, &GCEnvMicrophone::SetSpeakerDSPPreset)
        .addProperty("ListenFilter", &GCEnvMicrophone::GetListenFilter, &GCEnvMicrophone::SetListenFilter)
        .addProperty("ListenFilter1", &GCEnvMicrophone::GetListenFilter1, &GCEnvMicrophone::SetListenFilter1)
        .addProperty("OnRoutedSound", &GCEnvMicrophone::GetOnRoutedSound, &GCEnvMicrophone::SetOnRoutedSound)
        .addProperty("OnHeardSound", &GCEnvMicrophone::GetOnHeardSound, &GCEnvMicrophone::SetOnHeardSound)
        .addProperty("LastSound", &GCEnvMicrophone::GetLastSound, &GCEnvMicrophone::SetLastSound)
        .addProperty("LastRoutedFrame", &GCEnvMicrophone::GetLastRoutedFrame, &GCEnvMicrophone::SetLastRoutedFrame)
        .addProperty("Parent", &GCEnvMicrophone::GetParent, &GCEnvMicrophone::SetParent)
        .addFunction("ToPtr", &GCEnvMicrophone::ToPtr)
        .addFunction("IsValid", &GCEnvMicrophone::IsValid)
        .endClass();
}
GCInfoSpawnGroupLoadUnload::GCInfoSpawnGroupLoadUnload(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCInfoSpawnGroupLoadUnload::GCInfoSpawnGroupLoadUnload(void *ptr) {
    m_ptr = ptr;
}
GCEntityIOOutput GCInfoSpawnGroupLoadUnload::GetOnSpawnGroupLoadStarted() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CInfoSpawnGroupLoadUnload", "m_OnSpawnGroupLoadStarted"));
    return value;
}
void GCInfoSpawnGroupLoadUnload::SetOnSpawnGroupLoadStarted(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CInfoSpawnGroupLoadUnload", "m_OnSpawnGroupLoadStarted", false, value);
}
GCEntityIOOutput GCInfoSpawnGroupLoadUnload::GetOnSpawnGroupLoadFinished() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CInfoSpawnGroupLoadUnload", "m_OnSpawnGroupLoadFinished"));
    return value;
}
void GCInfoSpawnGroupLoadUnload::SetOnSpawnGroupLoadFinished(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CInfoSpawnGroupLoadUnload", "m_OnSpawnGroupLoadFinished", false, value);
}
GCEntityIOOutput GCInfoSpawnGroupLoadUnload::GetOnSpawnGroupUnloadStarted() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CInfoSpawnGroupLoadUnload", "m_OnSpawnGroupUnloadStarted"));
    return value;
}
void GCInfoSpawnGroupLoadUnload::SetOnSpawnGroupUnloadStarted(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CInfoSpawnGroupLoadUnload", "m_OnSpawnGroupUnloadStarted", false, value);
}
GCEntityIOOutput GCInfoSpawnGroupLoadUnload::GetOnSpawnGroupUnloadFinished() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CInfoSpawnGroupLoadUnload", "m_OnSpawnGroupUnloadFinished"));
    return value;
}
void GCInfoSpawnGroupLoadUnload::SetOnSpawnGroupUnloadFinished(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CInfoSpawnGroupLoadUnload", "m_OnSpawnGroupUnloadFinished", false, value);
}
std::string GCInfoSpawnGroupLoadUnload::GetSpawnGroupName() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CInfoSpawnGroupLoadUnload", "m_iszSpawnGroupName").String();
}
void GCInfoSpawnGroupLoadUnload::SetSpawnGroupName(std::string value) {
    SetSchemaValue(m_ptr, "CInfoSpawnGroupLoadUnload", "m_iszSpawnGroupName", false, CUtlSymbolLarge(value.c_str()));
}
std::string GCInfoSpawnGroupLoadUnload::GetSpawnGroupFilterName() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CInfoSpawnGroupLoadUnload", "m_iszSpawnGroupFilterName").String();
}
void GCInfoSpawnGroupLoadUnload::SetSpawnGroupFilterName(std::string value) {
    SetSchemaValue(m_ptr, "CInfoSpawnGroupLoadUnload", "m_iszSpawnGroupFilterName", false, CUtlSymbolLarge(value.c_str()));
}
std::string GCInfoSpawnGroupLoadUnload::GetLandmarkName() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CInfoSpawnGroupLoadUnload", "m_iszLandmarkName").String();
}
void GCInfoSpawnGroupLoadUnload::SetLandmarkName(std::string value) {
    SetSchemaValue(m_ptr, "CInfoSpawnGroupLoadUnload", "m_iszLandmarkName", false, CUtlSymbolLarge(value.c_str()));
}
std::string GCInfoSpawnGroupLoadUnload::GetFixedSpawnGroupName() const {
    return GetSchemaValue<CUtlString>(m_ptr, "CInfoSpawnGroupLoadUnload", "m_sFixedSpawnGroupName").Get();
}
void GCInfoSpawnGroupLoadUnload::SetFixedSpawnGroupName(std::string value) {
    SetSchemaValue(m_ptr, "CInfoSpawnGroupLoadUnload", "m_sFixedSpawnGroupName", false, CUtlString(value.c_str()));
}
float GCInfoSpawnGroupLoadUnload::GetTimeoutInterval() const {
    return GetSchemaValue<float>(m_ptr, "CInfoSpawnGroupLoadUnload", "m_flTimeoutInterval");
}
void GCInfoSpawnGroupLoadUnload::SetTimeoutInterval(float value) {
    SetSchemaValue(m_ptr, "CInfoSpawnGroupLoadUnload", "m_flTimeoutInterval", false, value);
}
bool GCInfoSpawnGroupLoadUnload::GetStreamingStarted() const {
    return GetSchemaValue<bool>(m_ptr, "CInfoSpawnGroupLoadUnload", "m_bStreamingStarted");
}
void GCInfoSpawnGroupLoadUnload::SetStreamingStarted(bool value) {
    SetSchemaValue(m_ptr, "CInfoSpawnGroupLoadUnload", "m_bStreamingStarted", false, value);
}
bool GCInfoSpawnGroupLoadUnload::GetUnloadingStarted() const {
    return GetSchemaValue<bool>(m_ptr, "CInfoSpawnGroupLoadUnload", "m_bUnloadingStarted");
}
void GCInfoSpawnGroupLoadUnload::SetUnloadingStarted(bool value) {
    SetSchemaValue(m_ptr, "CInfoSpawnGroupLoadUnload", "m_bUnloadingStarted", false, value);
}
std::string GCInfoSpawnGroupLoadUnload::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCInfoSpawnGroupLoadUnload::IsValid() {
    return (m_ptr != nullptr);
}
GCLogicalEntity GCInfoSpawnGroupLoadUnload::GetParent() const {
    GCLogicalEntity value(m_ptr);
    return value;
}
void GCInfoSpawnGroupLoadUnload::SetParent(GCLogicalEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCInfoSpawnGroupLoadUnload(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCInfoSpawnGroupLoadUnload>("CInfoSpawnGroupLoadUnload")
        .addConstructor<void (*)(std::string)>()
        .addProperty("OnSpawnGroupLoadStarted", &GCInfoSpawnGroupLoadUnload::GetOnSpawnGroupLoadStarted, &GCInfoSpawnGroupLoadUnload::SetOnSpawnGroupLoadStarted)
        .addProperty("OnSpawnGroupLoadFinished", &GCInfoSpawnGroupLoadUnload::GetOnSpawnGroupLoadFinished, &GCInfoSpawnGroupLoadUnload::SetOnSpawnGroupLoadFinished)
        .addProperty("OnSpawnGroupUnloadStarted", &GCInfoSpawnGroupLoadUnload::GetOnSpawnGroupUnloadStarted, &GCInfoSpawnGroupLoadUnload::SetOnSpawnGroupUnloadStarted)
        .addProperty("OnSpawnGroupUnloadFinished", &GCInfoSpawnGroupLoadUnload::GetOnSpawnGroupUnloadFinished, &GCInfoSpawnGroupLoadUnload::SetOnSpawnGroupUnloadFinished)
        .addProperty("SpawnGroupName", &GCInfoSpawnGroupLoadUnload::GetSpawnGroupName, &GCInfoSpawnGroupLoadUnload::SetSpawnGroupName)
        .addProperty("SpawnGroupFilterName", &GCInfoSpawnGroupLoadUnload::GetSpawnGroupFilterName, &GCInfoSpawnGroupLoadUnload::SetSpawnGroupFilterName)
        .addProperty("LandmarkName", &GCInfoSpawnGroupLoadUnload::GetLandmarkName, &GCInfoSpawnGroupLoadUnload::SetLandmarkName)
        .addProperty("FixedSpawnGroupName", &GCInfoSpawnGroupLoadUnload::GetFixedSpawnGroupName, &GCInfoSpawnGroupLoadUnload::SetFixedSpawnGroupName)
        .addProperty("TimeoutInterval", &GCInfoSpawnGroupLoadUnload::GetTimeoutInterval, &GCInfoSpawnGroupLoadUnload::SetTimeoutInterval)
        .addProperty("StreamingStarted", &GCInfoSpawnGroupLoadUnload::GetStreamingStarted, &GCInfoSpawnGroupLoadUnload::SetStreamingStarted)
        .addProperty("UnloadingStarted", &GCInfoSpawnGroupLoadUnload::GetUnloadingStarted, &GCInfoSpawnGroupLoadUnload::SetUnloadingStarted)
        .addProperty("Parent", &GCInfoSpawnGroupLoadUnload::GetParent, &GCInfoSpawnGroupLoadUnload::SetParent)
        .addFunction("ToPtr", &GCInfoSpawnGroupLoadUnload::ToPtr)
        .addFunction("IsValid", &GCInfoSpawnGroupLoadUnload::IsValid)
        .endClass();
}
GCBasePlayerController::GCBasePlayerController(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCBasePlayerController::GCBasePlayerController(void *ptr) {
    m_ptr = ptr;
}
uint64_t GCBasePlayerController::GetInButtonsWhichAreToggles() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CBasePlayerController", "m_nInButtonsWhichAreToggles");
}
void GCBasePlayerController::SetInButtonsWhichAreToggles(uint64_t value) {
    SetSchemaValue(m_ptr, "CBasePlayerController", "m_nInButtonsWhichAreToggles", false, value);
}
uint32_t GCBasePlayerController::GetTickBase() const {
    return GetSchemaValue<uint32_t>(m_ptr, "CBasePlayerController", "m_nTickBase");
}
void GCBasePlayerController::SetTickBase(uint32_t value) {
    SetSchemaValue(m_ptr, "CBasePlayerController", "m_nTickBase", false, value);
}
GCBasePlayerPawn GCBasePlayerController::GetPawn() const {
    GCBasePlayerPawn value(*GetSchemaValuePtr<void*>(m_ptr, "CBasePlayerController", "m_hPawn"));
    return value;
}
void GCBasePlayerController::SetPawn(GCBasePlayerPawn* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Pawn' is not possible.\n");
}
bool GCBasePlayerController::GetKnownTeamMismatch() const {
    return GetSchemaValue<bool>(m_ptr, "CBasePlayerController", "m_bKnownTeamMismatch");
}
void GCBasePlayerController::SetKnownTeamMismatch(bool value) {
    SetSchemaValue(m_ptr, "CBasePlayerController", "m_bKnownTeamMismatch", false, value);
}
int32_t GCBasePlayerController::GetSplitScreenSlot() const {
    return GetSchemaValue<int32_t>(m_ptr, "CBasePlayerController", "m_nSplitScreenSlot");
}
void GCBasePlayerController::SetSplitScreenSlot(int32_t value) {
    SetSchemaValue(m_ptr, "CBasePlayerController", "m_nSplitScreenSlot", false, value);
}
GCBasePlayerController GCBasePlayerController::GetSplitOwner() const {
    GCBasePlayerController value(*GetSchemaValuePtr<void*>(m_ptr, "CBasePlayerController", "m_hSplitOwner"));
    return value;
}
void GCBasePlayerController::SetSplitOwner(GCBasePlayerController* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'SplitOwner' is not possible.\n");
}
bool GCBasePlayerController::GetIsHLTV() const {
    return GetSchemaValue<bool>(m_ptr, "CBasePlayerController", "m_bIsHLTV");
}
void GCBasePlayerController::SetIsHLTV(bool value) {
    SetSchemaValue(m_ptr, "CBasePlayerController", "m_bIsHLTV", false, value);
}
uint64_t GCBasePlayerController::GetConnected() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CBasePlayerController", "m_iConnected");
}
void GCBasePlayerController::SetConnected(uint64_t value) {
    SetSchemaValue(m_ptr, "CBasePlayerController", "m_iConnected", false, value);
}
std::string GCBasePlayerController::GetPlayerName() const {
    return GetSchemaValuePtr<char>(m_ptr, "CBasePlayerController", "m_iszPlayerName");
}
void GCBasePlayerController::SetPlayerName(std::string value) {
    WriteSchemaPtrValue(m_ptr, "CBasePlayerController", "m_iszPlayerName", false, reinterpret_cast<byte*>(const_cast<char*>(value.c_str())), 128);
}
std::string GCBasePlayerController::GetNetworkIDString() const {
    return GetSchemaValue<CUtlString>(m_ptr, "CBasePlayerController", "m_szNetworkIDString").Get();
}
void GCBasePlayerController::SetNetworkIDString(std::string value) {
    SetSchemaValue(m_ptr, "CBasePlayerController", "m_szNetworkIDString", false, CUtlString(value.c_str()));
}
float GCBasePlayerController::GetLerpTime() const {
    return GetSchemaValue<float>(m_ptr, "CBasePlayerController", "m_fLerpTime");
}
void GCBasePlayerController::SetLerpTime(float value) {
    SetSchemaValue(m_ptr, "CBasePlayerController", "m_fLerpTime", false, value);
}
bool GCBasePlayerController::GetLagCompensation() const {
    return GetSchemaValue<bool>(m_ptr, "CBasePlayerController", "m_bLagCompensation");
}
void GCBasePlayerController::SetLagCompensation(bool value) {
    SetSchemaValue(m_ptr, "CBasePlayerController", "m_bLagCompensation", false, value);
}
bool GCBasePlayerController::GetPredict() const {
    return GetSchemaValue<bool>(m_ptr, "CBasePlayerController", "m_bPredict");
}
void GCBasePlayerController::SetPredict(bool value) {
    SetSchemaValue(m_ptr, "CBasePlayerController", "m_bPredict", false, value);
}
bool GCBasePlayerController::GetAutoKickDisabled() const {
    return GetSchemaValue<bool>(m_ptr, "CBasePlayerController", "m_bAutoKickDisabled");
}
void GCBasePlayerController::SetAutoKickDisabled(bool value) {
    SetSchemaValue(m_ptr, "CBasePlayerController", "m_bAutoKickDisabled", false, value);
}
bool GCBasePlayerController::GetIsLowViolence() const {
    return GetSchemaValue<bool>(m_ptr, "CBasePlayerController", "m_bIsLowViolence");
}
void GCBasePlayerController::SetIsLowViolence(bool value) {
    SetSchemaValue(m_ptr, "CBasePlayerController", "m_bIsLowViolence", false, value);
}
bool GCBasePlayerController::GetGamePaused() const {
    return GetSchemaValue<bool>(m_ptr, "CBasePlayerController", "m_bGamePaused");
}
void GCBasePlayerController::SetGamePaused(bool value) {
    SetSchemaValue(m_ptr, "CBasePlayerController", "m_bGamePaused", false, value);
}
int32_t GCBasePlayerController::GetLastRealCommandNumberExecuted() const {
    return GetSchemaValue<int32_t>(m_ptr, "CBasePlayerController", "m_nLastRealCommandNumberExecuted");
}
void GCBasePlayerController::SetLastRealCommandNumberExecuted(int32_t value) {
    SetSchemaValue(m_ptr, "CBasePlayerController", "m_nLastRealCommandNumberExecuted", false, value);
}
int32_t GCBasePlayerController::GetLastLateCommandExecuted() const {
    return GetSchemaValue<int32_t>(m_ptr, "CBasePlayerController", "m_nLastLateCommandExecuted");
}
void GCBasePlayerController::SetLastLateCommandExecuted(int32_t value) {
    SetSchemaValue(m_ptr, "CBasePlayerController", "m_nLastLateCommandExecuted", false, value);
}
uint64_t GCBasePlayerController::GetIgnoreGlobalChat() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CBasePlayerController", "m_iIgnoreGlobalChat");
}
void GCBasePlayerController::SetIgnoreGlobalChat(uint64_t value) {
    SetSchemaValue(m_ptr, "CBasePlayerController", "m_iIgnoreGlobalChat", false, value);
}
float GCBasePlayerController::GetLastPlayerTalkTime() const {
    return GetSchemaValue<float>(m_ptr, "CBasePlayerController", "m_flLastPlayerTalkTime");
}
void GCBasePlayerController::SetLastPlayerTalkTime(float value) {
    SetSchemaValue(m_ptr, "CBasePlayerController", "m_flLastPlayerTalkTime", false, value);
}
float GCBasePlayerController::GetLastEntitySteadyState() const {
    return GetSchemaValue<float>(m_ptr, "CBasePlayerController", "m_flLastEntitySteadyState");
}
void GCBasePlayerController::SetLastEntitySteadyState(float value) {
    SetSchemaValue(m_ptr, "CBasePlayerController", "m_flLastEntitySteadyState", false, value);
}
int32_t GCBasePlayerController::GetAvailableEntitySteadyState() const {
    return GetSchemaValue<int32_t>(m_ptr, "CBasePlayerController", "m_nAvailableEntitySteadyState");
}
void GCBasePlayerController::SetAvailableEntitySteadyState(int32_t value) {
    SetSchemaValue(m_ptr, "CBasePlayerController", "m_nAvailableEntitySteadyState", false, value);
}
bool GCBasePlayerController::GetHasAnySteadyStateEnts() const {
    return GetSchemaValue<bool>(m_ptr, "CBasePlayerController", "m_bHasAnySteadyStateEnts");
}
void GCBasePlayerController::SetHasAnySteadyStateEnts(bool value) {
    SetSchemaValue(m_ptr, "CBasePlayerController", "m_bHasAnySteadyStateEnts", false, value);
}
uint64_t GCBasePlayerController::GetSteamID() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CBasePlayerController", "m_steamID");
}
void GCBasePlayerController::SetSteamID(uint64_t value) {
    SetSchemaValue(m_ptr, "CBasePlayerController", "m_steamID", false, value);
}
uint32_t GCBasePlayerController::GetDesiredFOV() const {
    return GetSchemaValue<uint32_t>(m_ptr, "CBasePlayerController", "m_iDesiredFOV");
}
void GCBasePlayerController::SetDesiredFOV(uint32_t value) {
    SetSchemaValue(m_ptr, "CBasePlayerController", "m_iDesiredFOV", false, value);
}
std::string GCBasePlayerController::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCBasePlayerController::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseEntity GCBasePlayerController::GetParent() const {
    GCBaseEntity value(m_ptr);
    return value;
}
void GCBasePlayerController::SetParent(GCBaseEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCBasePlayerController(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCBasePlayerController>("CBasePlayerController")
        .addConstructor<void (*)(std::string)>()
        .addProperty("InButtonsWhichAreToggles", &GCBasePlayerController::GetInButtonsWhichAreToggles, &GCBasePlayerController::SetInButtonsWhichAreToggles)
        .addProperty("TickBase", &GCBasePlayerController::GetTickBase, &GCBasePlayerController::SetTickBase)
        .addProperty("Pawn", &GCBasePlayerController::GetPawn, &GCBasePlayerController::SetPawn)
        .addProperty("KnownTeamMismatch", &GCBasePlayerController::GetKnownTeamMismatch, &GCBasePlayerController::SetKnownTeamMismatch)
        .addProperty("SplitScreenSlot", &GCBasePlayerController::GetSplitScreenSlot, &GCBasePlayerController::SetSplitScreenSlot)
        .addProperty("SplitOwner", &GCBasePlayerController::GetSplitOwner, &GCBasePlayerController::SetSplitOwner)
        .addProperty("IsHLTV", &GCBasePlayerController::GetIsHLTV, &GCBasePlayerController::SetIsHLTV)
        .addProperty("Connected", &GCBasePlayerController::GetConnected, &GCBasePlayerController::SetConnected)
        .addProperty("PlayerName", &GCBasePlayerController::GetPlayerName, &GCBasePlayerController::SetPlayerName)
        .addProperty("NetworkIDString", &GCBasePlayerController::GetNetworkIDString, &GCBasePlayerController::SetNetworkIDString)
        .addProperty("LerpTime", &GCBasePlayerController::GetLerpTime, &GCBasePlayerController::SetLerpTime)
        .addProperty("LagCompensation", &GCBasePlayerController::GetLagCompensation, &GCBasePlayerController::SetLagCompensation)
        .addProperty("Predict", &GCBasePlayerController::GetPredict, &GCBasePlayerController::SetPredict)
        .addProperty("AutoKickDisabled", &GCBasePlayerController::GetAutoKickDisabled, &GCBasePlayerController::SetAutoKickDisabled)
        .addProperty("IsLowViolence", &GCBasePlayerController::GetIsLowViolence, &GCBasePlayerController::SetIsLowViolence)
        .addProperty("GamePaused", &GCBasePlayerController::GetGamePaused, &GCBasePlayerController::SetGamePaused)
        .addProperty("LastRealCommandNumberExecuted", &GCBasePlayerController::GetLastRealCommandNumberExecuted, &GCBasePlayerController::SetLastRealCommandNumberExecuted)
        .addProperty("LastLateCommandExecuted", &GCBasePlayerController::GetLastLateCommandExecuted, &GCBasePlayerController::SetLastLateCommandExecuted)
        .addProperty("IgnoreGlobalChat", &GCBasePlayerController::GetIgnoreGlobalChat, &GCBasePlayerController::SetIgnoreGlobalChat)
        .addProperty("LastPlayerTalkTime", &GCBasePlayerController::GetLastPlayerTalkTime, &GCBasePlayerController::SetLastPlayerTalkTime)
        .addProperty("LastEntitySteadyState", &GCBasePlayerController::GetLastEntitySteadyState, &GCBasePlayerController::SetLastEntitySteadyState)
        .addProperty("AvailableEntitySteadyState", &GCBasePlayerController::GetAvailableEntitySteadyState, &GCBasePlayerController::SetAvailableEntitySteadyState)
        .addProperty("HasAnySteadyStateEnts", &GCBasePlayerController::GetHasAnySteadyStateEnts, &GCBasePlayerController::SetHasAnySteadyStateEnts)
        .addProperty("SteamID", &GCBasePlayerController::GetSteamID, &GCBasePlayerController::SetSteamID)
        .addProperty("DesiredFOV", &GCBasePlayerController::GetDesiredFOV, &GCBasePlayerController::SetDesiredFOV)
        .addProperty("Parent", &GCBasePlayerController::GetParent, &GCBasePlayerController::SetParent)
        .addFunction("ToPtr", &GCBasePlayerController::ToPtr)
        .addFunction("IsValid", &GCBasePlayerController::IsValid)
        .endClass();
}
GCPointTemplateAPI::GCPointTemplateAPI(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCPointTemplateAPI::GCPointTemplateAPI(void *ptr) {
    m_ptr = ptr;
}
std::string GCPointTemplateAPI::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCPointTemplateAPI::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCPointTemplateAPI(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCPointTemplateAPI>("CPointTemplateAPI")
        .addConstructor<void (*)(std::string)>()
        .addFunction("ToPtr", &GCPointTemplateAPI::ToPtr)
        .addFunction("IsValid", &GCPointTemplateAPI::IsValid)
        .endClass();
}
GCKnife::GCKnife(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCKnife::GCKnife(void *ptr) {
    m_ptr = ptr;
}
bool GCKnife::GetFirstAttack() const {
    return GetSchemaValue<bool>(m_ptr, "CKnife", "m_bFirstAttack");
}
void GCKnife::SetFirstAttack(bool value) {
    SetSchemaValue(m_ptr, "CKnife", "m_bFirstAttack", false, value);
}
std::string GCKnife::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCKnife::IsValid() {
    return (m_ptr != nullptr);
}
GCCSWeaponBase GCKnife::GetParent() const {
    GCCSWeaponBase value(m_ptr);
    return value;
}
void GCKnife::SetParent(GCCSWeaponBase value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCKnife(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCKnife>("CKnife")
        .addConstructor<void (*)(std::string)>()
        .addProperty("FirstAttack", &GCKnife::GetFirstAttack, &GCKnife::SetFirstAttack)
        .addProperty("Parent", &GCKnife::GetParent, &GCKnife::SetParent)
        .addFunction("ToPtr", &GCKnife::ToPtr)
        .addFunction("IsValid", &GCKnife::IsValid)
        .endClass();
}
GCFuncTrackTrain::GCFuncTrackTrain(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCFuncTrackTrain::GCFuncTrackTrain(void *ptr) {
    m_ptr = ptr;
}
GCPathTrack GCFuncTrackTrain::GetPpath() const {
    GCPathTrack value(*GetSchemaValuePtr<void*>(m_ptr, "CFuncTrackTrain", "m_ppath"));
    return value;
}
void GCFuncTrackTrain::SetPpath(GCPathTrack* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Ppath' is not possible.\n");
}
float GCFuncTrackTrain::GetLength() const {
    return GetSchemaValue<float>(m_ptr, "CFuncTrackTrain", "m_length");
}
void GCFuncTrackTrain::SetLength(float value) {
    SetSchemaValue(m_ptr, "CFuncTrackTrain", "m_length", false, value);
}
Vector GCFuncTrackTrain::GetPosPrev() const {
    return GetSchemaValue<Vector>(m_ptr, "CFuncTrackTrain", "m_vPosPrev");
}
void GCFuncTrackTrain::SetPosPrev(Vector value) {
    SetSchemaValue(m_ptr, "CFuncTrackTrain", "m_vPosPrev", false, value);
}
QAngle GCFuncTrackTrain::GetPrev() const {
    return GetSchemaValue<QAngle>(m_ptr, "CFuncTrackTrain", "m_angPrev");
}
void GCFuncTrackTrain::SetPrev(QAngle value) {
    SetSchemaValue(m_ptr, "CFuncTrackTrain", "m_angPrev", false, value);
}
Vector GCFuncTrackTrain::GetControlMins() const {
    return GetSchemaValue<Vector>(m_ptr, "CFuncTrackTrain", "m_controlMins");
}
void GCFuncTrackTrain::SetControlMins(Vector value) {
    SetSchemaValue(m_ptr, "CFuncTrackTrain", "m_controlMins", false, value);
}
Vector GCFuncTrackTrain::GetControlMaxs() const {
    return GetSchemaValue<Vector>(m_ptr, "CFuncTrackTrain", "m_controlMaxs");
}
void GCFuncTrackTrain::SetControlMaxs(Vector value) {
    SetSchemaValue(m_ptr, "CFuncTrackTrain", "m_controlMaxs", false, value);
}
Vector GCFuncTrackTrain::GetLastBlockPos() const {
    return GetSchemaValue<Vector>(m_ptr, "CFuncTrackTrain", "m_lastBlockPos");
}
void GCFuncTrackTrain::SetLastBlockPos(Vector value) {
    SetSchemaValue(m_ptr, "CFuncTrackTrain", "m_lastBlockPos", false, value);
}
int32_t GCFuncTrackTrain::GetLastBlockTick() const {
    return GetSchemaValue<int32_t>(m_ptr, "CFuncTrackTrain", "m_lastBlockTick");
}
void GCFuncTrackTrain::SetLastBlockTick(int32_t value) {
    SetSchemaValue(m_ptr, "CFuncTrackTrain", "m_lastBlockTick", false, value);
}
float GCFuncTrackTrain::GetVolume() const {
    return GetSchemaValue<float>(m_ptr, "CFuncTrackTrain", "m_flVolume");
}
void GCFuncTrackTrain::SetVolume(float value) {
    SetSchemaValue(m_ptr, "CFuncTrackTrain", "m_flVolume", false, value);
}
float GCFuncTrackTrain::GetBank() const {
    return GetSchemaValue<float>(m_ptr, "CFuncTrackTrain", "m_flBank");
}
void GCFuncTrackTrain::SetBank(float value) {
    SetSchemaValue(m_ptr, "CFuncTrackTrain", "m_flBank", false, value);
}
float GCFuncTrackTrain::GetOldSpeed() const {
    return GetSchemaValue<float>(m_ptr, "CFuncTrackTrain", "m_oldSpeed");
}
void GCFuncTrackTrain::SetOldSpeed(float value) {
    SetSchemaValue(m_ptr, "CFuncTrackTrain", "m_oldSpeed", false, value);
}
float GCFuncTrackTrain::GetBlockDamage() const {
    return GetSchemaValue<float>(m_ptr, "CFuncTrackTrain", "m_flBlockDamage");
}
void GCFuncTrackTrain::SetBlockDamage(float value) {
    SetSchemaValue(m_ptr, "CFuncTrackTrain", "m_flBlockDamage", false, value);
}
float GCFuncTrackTrain::GetHeight() const {
    return GetSchemaValue<float>(m_ptr, "CFuncTrackTrain", "m_height");
}
void GCFuncTrackTrain::SetHeight(float value) {
    SetSchemaValue(m_ptr, "CFuncTrackTrain", "m_height", false, value);
}
float GCFuncTrackTrain::GetMaxSpeed() const {
    return GetSchemaValue<float>(m_ptr, "CFuncTrackTrain", "m_maxSpeed");
}
void GCFuncTrackTrain::SetMaxSpeed(float value) {
    SetSchemaValue(m_ptr, "CFuncTrackTrain", "m_maxSpeed", false, value);
}
float GCFuncTrackTrain::GetDir() const {
    return GetSchemaValue<float>(m_ptr, "CFuncTrackTrain", "m_dir");
}
void GCFuncTrackTrain::SetDir(float value) {
    SetSchemaValue(m_ptr, "CFuncTrackTrain", "m_dir", false, value);
}
std::string GCFuncTrackTrain::GetSoundMove() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CFuncTrackTrain", "m_iszSoundMove").String();
}
void GCFuncTrackTrain::SetSoundMove(std::string value) {
    SetSchemaValue(m_ptr, "CFuncTrackTrain", "m_iszSoundMove", false, CUtlSymbolLarge(value.c_str()));
}
std::string GCFuncTrackTrain::GetSoundMovePing() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CFuncTrackTrain", "m_iszSoundMovePing").String();
}
void GCFuncTrackTrain::SetSoundMovePing(std::string value) {
    SetSchemaValue(m_ptr, "CFuncTrackTrain", "m_iszSoundMovePing", false, CUtlSymbolLarge(value.c_str()));
}
std::string GCFuncTrackTrain::GetSoundStart() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CFuncTrackTrain", "m_iszSoundStart").String();
}
void GCFuncTrackTrain::SetSoundStart(std::string value) {
    SetSchemaValue(m_ptr, "CFuncTrackTrain", "m_iszSoundStart", false, CUtlSymbolLarge(value.c_str()));
}
std::string GCFuncTrackTrain::GetSoundStop() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CFuncTrackTrain", "m_iszSoundStop").String();
}
void GCFuncTrackTrain::SetSoundStop(std::string value) {
    SetSchemaValue(m_ptr, "CFuncTrackTrain", "m_iszSoundStop", false, CUtlSymbolLarge(value.c_str()));
}
std::string GCFuncTrackTrain::GetStrPathTarget() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CFuncTrackTrain", "m_strPathTarget").String();
}
void GCFuncTrackTrain::SetStrPathTarget(std::string value) {
    SetSchemaValue(m_ptr, "CFuncTrackTrain", "m_strPathTarget", false, CUtlSymbolLarge(value.c_str()));
}
float GCFuncTrackTrain::GetMoveSoundMinDuration() const {
    return GetSchemaValue<float>(m_ptr, "CFuncTrackTrain", "m_flMoveSoundMinDuration");
}
void GCFuncTrackTrain::SetMoveSoundMinDuration(float value) {
    SetSchemaValue(m_ptr, "CFuncTrackTrain", "m_flMoveSoundMinDuration", false, value);
}
float GCFuncTrackTrain::GetMoveSoundMaxDuration() const {
    return GetSchemaValue<float>(m_ptr, "CFuncTrackTrain", "m_flMoveSoundMaxDuration");
}
void GCFuncTrackTrain::SetMoveSoundMaxDuration(float value) {
    SetSchemaValue(m_ptr, "CFuncTrackTrain", "m_flMoveSoundMaxDuration", false, value);
}
float GCFuncTrackTrain::GetNextMoveSoundTime() const {
    return GetSchemaValue<float>(m_ptr, "CFuncTrackTrain", "m_flNextMoveSoundTime");
}
void GCFuncTrackTrain::SetNextMoveSoundTime(float value) {
    SetSchemaValue(m_ptr, "CFuncTrackTrain", "m_flNextMoveSoundTime", false, value);
}
float GCFuncTrackTrain::GetMoveSoundMinPitch() const {
    return GetSchemaValue<float>(m_ptr, "CFuncTrackTrain", "m_flMoveSoundMinPitch");
}
void GCFuncTrackTrain::SetMoveSoundMinPitch(float value) {
    SetSchemaValue(m_ptr, "CFuncTrackTrain", "m_flMoveSoundMinPitch", false, value);
}
float GCFuncTrackTrain::GetMoveSoundMaxPitch() const {
    return GetSchemaValue<float>(m_ptr, "CFuncTrackTrain", "m_flMoveSoundMaxPitch");
}
void GCFuncTrackTrain::SetMoveSoundMaxPitch(float value) {
    SetSchemaValue(m_ptr, "CFuncTrackTrain", "m_flMoveSoundMaxPitch", false, value);
}
uint64_t GCFuncTrackTrain::GetOrientationType() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CFuncTrackTrain", "m_eOrientationType");
}
void GCFuncTrackTrain::SetOrientationType(uint64_t value) {
    SetSchemaValue(m_ptr, "CFuncTrackTrain", "m_eOrientationType", false, value);
}
uint64_t GCFuncTrackTrain::GetVelocityType() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CFuncTrackTrain", "m_eVelocityType");
}
void GCFuncTrackTrain::SetVelocityType(uint64_t value) {
    SetSchemaValue(m_ptr, "CFuncTrackTrain", "m_eVelocityType", false, value);
}
GCEntityIOOutput GCFuncTrackTrain::GetOnStart() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CFuncTrackTrain", "m_OnStart"));
    return value;
}
void GCFuncTrackTrain::SetOnStart(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CFuncTrackTrain", "m_OnStart", false, value);
}
GCEntityIOOutput GCFuncTrackTrain::GetOnNext() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CFuncTrackTrain", "m_OnNext"));
    return value;
}
void GCFuncTrackTrain::SetOnNext(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CFuncTrackTrain", "m_OnNext", false, value);
}
GCEntityIOOutput GCFuncTrackTrain::GetOnArrivedAtDestinationNode() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CFuncTrackTrain", "m_OnArrivedAtDestinationNode"));
    return value;
}
void GCFuncTrackTrain::SetOnArrivedAtDestinationNode(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CFuncTrackTrain", "m_OnArrivedAtDestinationNode", false, value);
}
bool GCFuncTrackTrain::GetManualSpeedChanges() const {
    return GetSchemaValue<bool>(m_ptr, "CFuncTrackTrain", "m_bManualSpeedChanges");
}
void GCFuncTrackTrain::SetManualSpeedChanges(bool value) {
    SetSchemaValue(m_ptr, "CFuncTrackTrain", "m_bManualSpeedChanges", false, value);
}
float GCFuncTrackTrain::GetDesiredSpeed() const {
    return GetSchemaValue<float>(m_ptr, "CFuncTrackTrain", "m_flDesiredSpeed");
}
void GCFuncTrackTrain::SetDesiredSpeed(float value) {
    SetSchemaValue(m_ptr, "CFuncTrackTrain", "m_flDesiredSpeed", false, value);
}
float GCFuncTrackTrain::GetSpeedChangeTime() const {
    return GetSchemaValue<float>(m_ptr, "CFuncTrackTrain", "m_flSpeedChangeTime");
}
void GCFuncTrackTrain::SetSpeedChangeTime(float value) {
    SetSchemaValue(m_ptr, "CFuncTrackTrain", "m_flSpeedChangeTime", false, value);
}
float GCFuncTrackTrain::GetAccelSpeed() const {
    return GetSchemaValue<float>(m_ptr, "CFuncTrackTrain", "m_flAccelSpeed");
}
void GCFuncTrackTrain::SetAccelSpeed(float value) {
    SetSchemaValue(m_ptr, "CFuncTrackTrain", "m_flAccelSpeed", false, value);
}
float GCFuncTrackTrain::GetDecelSpeed() const {
    return GetSchemaValue<float>(m_ptr, "CFuncTrackTrain", "m_flDecelSpeed");
}
void GCFuncTrackTrain::SetDecelSpeed(float value) {
    SetSchemaValue(m_ptr, "CFuncTrackTrain", "m_flDecelSpeed", false, value);
}
bool GCFuncTrackTrain::GetAccelToSpeed() const {
    return GetSchemaValue<bool>(m_ptr, "CFuncTrackTrain", "m_bAccelToSpeed");
}
void GCFuncTrackTrain::SetAccelToSpeed(bool value) {
    SetSchemaValue(m_ptr, "CFuncTrackTrain", "m_bAccelToSpeed", false, value);
}
float GCFuncTrackTrain::GetNextMPSoundTime() const {
    return GetSchemaValue<float>(m_ptr, "CFuncTrackTrain", "m_flNextMPSoundTime");
}
void GCFuncTrackTrain::SetNextMPSoundTime(float value) {
    SetSchemaValue(m_ptr, "CFuncTrackTrain", "m_flNextMPSoundTime", false, value);
}
std::string GCFuncTrackTrain::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCFuncTrackTrain::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseModelEntity GCFuncTrackTrain::GetParent() const {
    GCBaseModelEntity value(m_ptr);
    return value;
}
void GCFuncTrackTrain::SetParent(GCBaseModelEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCFuncTrackTrain(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCFuncTrackTrain>("CFuncTrackTrain")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Ppath", &GCFuncTrackTrain::GetPpath, &GCFuncTrackTrain::SetPpath)
        .addProperty("Length", &GCFuncTrackTrain::GetLength, &GCFuncTrackTrain::SetLength)
        .addProperty("PosPrev", &GCFuncTrackTrain::GetPosPrev, &GCFuncTrackTrain::SetPosPrev)
        .addProperty("Prev", &GCFuncTrackTrain::GetPrev, &GCFuncTrackTrain::SetPrev)
        .addProperty("ControlMins", &GCFuncTrackTrain::GetControlMins, &GCFuncTrackTrain::SetControlMins)
        .addProperty("ControlMaxs", &GCFuncTrackTrain::GetControlMaxs, &GCFuncTrackTrain::SetControlMaxs)
        .addProperty("LastBlockPos", &GCFuncTrackTrain::GetLastBlockPos, &GCFuncTrackTrain::SetLastBlockPos)
        .addProperty("LastBlockTick", &GCFuncTrackTrain::GetLastBlockTick, &GCFuncTrackTrain::SetLastBlockTick)
        .addProperty("Volume", &GCFuncTrackTrain::GetVolume, &GCFuncTrackTrain::SetVolume)
        .addProperty("Bank", &GCFuncTrackTrain::GetBank, &GCFuncTrackTrain::SetBank)
        .addProperty("OldSpeed", &GCFuncTrackTrain::GetOldSpeed, &GCFuncTrackTrain::SetOldSpeed)
        .addProperty("BlockDamage", &GCFuncTrackTrain::GetBlockDamage, &GCFuncTrackTrain::SetBlockDamage)
        .addProperty("Height", &GCFuncTrackTrain::GetHeight, &GCFuncTrackTrain::SetHeight)
        .addProperty("MaxSpeed", &GCFuncTrackTrain::GetMaxSpeed, &GCFuncTrackTrain::SetMaxSpeed)
        .addProperty("Dir", &GCFuncTrackTrain::GetDir, &GCFuncTrackTrain::SetDir)
        .addProperty("SoundMove", &GCFuncTrackTrain::GetSoundMove, &GCFuncTrackTrain::SetSoundMove)
        .addProperty("SoundMovePing", &GCFuncTrackTrain::GetSoundMovePing, &GCFuncTrackTrain::SetSoundMovePing)
        .addProperty("SoundStart", &GCFuncTrackTrain::GetSoundStart, &GCFuncTrackTrain::SetSoundStart)
        .addProperty("SoundStop", &GCFuncTrackTrain::GetSoundStop, &GCFuncTrackTrain::SetSoundStop)
        .addProperty("StrPathTarget", &GCFuncTrackTrain::GetStrPathTarget, &GCFuncTrackTrain::SetStrPathTarget)
        .addProperty("MoveSoundMinDuration", &GCFuncTrackTrain::GetMoveSoundMinDuration, &GCFuncTrackTrain::SetMoveSoundMinDuration)
        .addProperty("MoveSoundMaxDuration", &GCFuncTrackTrain::GetMoveSoundMaxDuration, &GCFuncTrackTrain::SetMoveSoundMaxDuration)
        .addProperty("NextMoveSoundTime", &GCFuncTrackTrain::GetNextMoveSoundTime, &GCFuncTrackTrain::SetNextMoveSoundTime)
        .addProperty("MoveSoundMinPitch", &GCFuncTrackTrain::GetMoveSoundMinPitch, &GCFuncTrackTrain::SetMoveSoundMinPitch)
        .addProperty("MoveSoundMaxPitch", &GCFuncTrackTrain::GetMoveSoundMaxPitch, &GCFuncTrackTrain::SetMoveSoundMaxPitch)
        .addProperty("OrientationType", &GCFuncTrackTrain::GetOrientationType, &GCFuncTrackTrain::SetOrientationType)
        .addProperty("VelocityType", &GCFuncTrackTrain::GetVelocityType, &GCFuncTrackTrain::SetVelocityType)
        .addProperty("OnStart", &GCFuncTrackTrain::GetOnStart, &GCFuncTrackTrain::SetOnStart)
        .addProperty("OnNext", &GCFuncTrackTrain::GetOnNext, &GCFuncTrackTrain::SetOnNext)
        .addProperty("OnArrivedAtDestinationNode", &GCFuncTrackTrain::GetOnArrivedAtDestinationNode, &GCFuncTrackTrain::SetOnArrivedAtDestinationNode)
        .addProperty("ManualSpeedChanges", &GCFuncTrackTrain::GetManualSpeedChanges, &GCFuncTrackTrain::SetManualSpeedChanges)
        .addProperty("DesiredSpeed", &GCFuncTrackTrain::GetDesiredSpeed, &GCFuncTrackTrain::SetDesiredSpeed)
        .addProperty("SpeedChangeTime", &GCFuncTrackTrain::GetSpeedChangeTime, &GCFuncTrackTrain::SetSpeedChangeTime)
        .addProperty("AccelSpeed", &GCFuncTrackTrain::GetAccelSpeed, &GCFuncTrackTrain::SetAccelSpeed)
        .addProperty("DecelSpeed", &GCFuncTrackTrain::GetDecelSpeed, &GCFuncTrackTrain::SetDecelSpeed)
        .addProperty("AccelToSpeed", &GCFuncTrackTrain::GetAccelToSpeed, &GCFuncTrackTrain::SetAccelToSpeed)
        .addProperty("NextMPSoundTime", &GCFuncTrackTrain::GetNextMPSoundTime, &GCFuncTrackTrain::SetNextMPSoundTime)
        .addProperty("Parent", &GCFuncTrackTrain::GetParent, &GCFuncTrackTrain::SetParent)
        .addFunction("ToPtr", &GCFuncTrackTrain::ToPtr)
        .addFunction("IsValid", &GCFuncTrackTrain::IsValid)
        .endClass();
}
GCFogVolume::GCFogVolume(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCFogVolume::GCFogVolume(void *ptr) {
    m_ptr = ptr;
}
std::string GCFogVolume::GetFogName() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CFogVolume", "m_fogName").String();
}
void GCFogVolume::SetFogName(std::string value) {
    SetSchemaValue(m_ptr, "CFogVolume", "m_fogName", false, CUtlSymbolLarge(value.c_str()));
}
std::string GCFogVolume::GetPostProcessName() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CFogVolume", "m_postProcessName").String();
}
void GCFogVolume::SetPostProcessName(std::string value) {
    SetSchemaValue(m_ptr, "CFogVolume", "m_postProcessName", false, CUtlSymbolLarge(value.c_str()));
}
std::string GCFogVolume::GetColorCorrectionName() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CFogVolume", "m_colorCorrectionName").String();
}
void GCFogVolume::SetColorCorrectionName(std::string value) {
    SetSchemaValue(m_ptr, "CFogVolume", "m_colorCorrectionName", false, CUtlSymbolLarge(value.c_str()));
}
bool GCFogVolume::GetDisabled() const {
    return GetSchemaValue<bool>(m_ptr, "CFogVolume", "m_bDisabled");
}
void GCFogVolume::SetDisabled(bool value) {
    SetSchemaValue(m_ptr, "CFogVolume", "m_bDisabled", false, value);
}
bool GCFogVolume::GetInFogVolumesList() const {
    return GetSchemaValue<bool>(m_ptr, "CFogVolume", "m_bInFogVolumesList");
}
void GCFogVolume::SetInFogVolumesList(bool value) {
    SetSchemaValue(m_ptr, "CFogVolume", "m_bInFogVolumesList", false, value);
}
std::string GCFogVolume::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCFogVolume::IsValid() {
    return (m_ptr != nullptr);
}
GCServerOnlyModelEntity GCFogVolume::GetParent() const {
    GCServerOnlyModelEntity value(m_ptr);
    return value;
}
void GCFogVolume::SetParent(GCServerOnlyModelEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCFogVolume(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCFogVolume>("CFogVolume")
        .addConstructor<void (*)(std::string)>()
        .addProperty("FogName", &GCFogVolume::GetFogName, &GCFogVolume::SetFogName)
        .addProperty("PostProcessName", &GCFogVolume::GetPostProcessName, &GCFogVolume::SetPostProcessName)
        .addProperty("ColorCorrectionName", &GCFogVolume::GetColorCorrectionName, &GCFogVolume::SetColorCorrectionName)
        .addProperty("Disabled", &GCFogVolume::GetDisabled, &GCFogVolume::SetDisabled)
        .addProperty("InFogVolumesList", &GCFogVolume::GetInFogVolumesList, &GCFogVolume::SetInFogVolumesList)
        .addProperty("Parent", &GCFogVolume::GetParent, &GCFogVolume::SetParent)
        .addFunction("ToPtr", &GCFogVolume::ToPtr)
        .addFunction("IsValid", &GCFogVolume::IsValid)
        .endClass();
}
GCInfoPlayerCounterterrorist::GCInfoPlayerCounterterrorist(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCInfoPlayerCounterterrorist::GCInfoPlayerCounterterrorist(void *ptr) {
    m_ptr = ptr;
}
std::string GCInfoPlayerCounterterrorist::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCInfoPlayerCounterterrorist::IsValid() {
    return (m_ptr != nullptr);
}
GSpawnPoint GCInfoPlayerCounterterrorist::GetParent() const {
    GSpawnPoint value(m_ptr);
    return value;
}
void GCInfoPlayerCounterterrorist::SetParent(GSpawnPoint value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCInfoPlayerCounterterrorist(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCInfoPlayerCounterterrorist>("CInfoPlayerCounterterrorist")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCInfoPlayerCounterterrorist::GetParent, &GCInfoPlayerCounterterrorist::SetParent)
        .addFunction("ToPtr", &GCInfoPlayerCounterterrorist::ToPtr)
        .addFunction("IsValid", &GCInfoPlayerCounterterrorist::IsValid)
        .endClass();
}
GCFire::GCFire(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCFire::GCFire(void *ptr) {
    m_ptr = ptr;
}
GCBaseFire GCFire::GetEffect() const {
    GCBaseFire value(*GetSchemaValuePtr<void*>(m_ptr, "CFire", "m_hEffect"));
    return value;
}
void GCFire::SetEffect(GCBaseFire* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Effect' is not possible.\n");
}
GCBaseEntity GCFire::GetOwner() const {
    GCBaseEntity value(*GetSchemaValuePtr<void*>(m_ptr, "CFire", "m_hOwner"));
    return value;
}
void GCFire::SetOwner(GCBaseEntity* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Owner' is not possible.\n");
}
int32_t GCFire::GetFireType() const {
    return GetSchemaValue<int32_t>(m_ptr, "CFire", "m_nFireType");
}
void GCFire::SetFireType(int32_t value) {
    SetSchemaValue(m_ptr, "CFire", "m_nFireType", false, value);
}
float GCFire::GetFuel() const {
    return GetSchemaValue<float>(m_ptr, "CFire", "m_flFuel");
}
void GCFire::SetFuel(float value) {
    SetSchemaValue(m_ptr, "CFire", "m_flFuel", false, value);
}
float GCFire::GetDamageTime() const {
    return GetSchemaValue<float>(m_ptr, "CFire", "m_flDamageTime");
}
void GCFire::SetDamageTime(float value) {
    SetSchemaValue(m_ptr, "CFire", "m_flDamageTime", false, value);
}
float GCFire::GetLastDamage() const {
    return GetSchemaValue<float>(m_ptr, "CFire", "m_lastDamage");
}
void GCFire::SetLastDamage(float value) {
    SetSchemaValue(m_ptr, "CFire", "m_lastDamage", false, value);
}
float GCFire::GetFireSize() const {
    return GetSchemaValue<float>(m_ptr, "CFire", "m_flFireSize");
}
void GCFire::SetFireSize(float value) {
    SetSchemaValue(m_ptr, "CFire", "m_flFireSize", false, value);
}
float GCFire::GetLastNavUpdateTime() const {
    return GetSchemaValue<float>(m_ptr, "CFire", "m_flLastNavUpdateTime");
}
void GCFire::SetLastNavUpdateTime(float value) {
    SetSchemaValue(m_ptr, "CFire", "m_flLastNavUpdateTime", false, value);
}
float GCFire::GetHeatLevel() const {
    return GetSchemaValue<float>(m_ptr, "CFire", "m_flHeatLevel");
}
void GCFire::SetHeatLevel(float value) {
    SetSchemaValue(m_ptr, "CFire", "m_flHeatLevel", false, value);
}
float GCFire::GetHeatAbsorb() const {
    return GetSchemaValue<float>(m_ptr, "CFire", "m_flHeatAbsorb");
}
void GCFire::SetHeatAbsorb(float value) {
    SetSchemaValue(m_ptr, "CFire", "m_flHeatAbsorb", false, value);
}
float GCFire::GetDamageScale() const {
    return GetSchemaValue<float>(m_ptr, "CFire", "m_flDamageScale");
}
void GCFire::SetDamageScale(float value) {
    SetSchemaValue(m_ptr, "CFire", "m_flDamageScale", false, value);
}
float GCFire::GetMaxHeat() const {
    return GetSchemaValue<float>(m_ptr, "CFire", "m_flMaxHeat");
}
void GCFire::SetMaxHeat(float value) {
    SetSchemaValue(m_ptr, "CFire", "m_flMaxHeat", false, value);
}
float GCFire::GetLastHeatLevel() const {
    return GetSchemaValue<float>(m_ptr, "CFire", "m_flLastHeatLevel");
}
void GCFire::SetLastHeatLevel(float value) {
    SetSchemaValue(m_ptr, "CFire", "m_flLastHeatLevel", false, value);
}
float GCFire::GetAttackTime() const {
    return GetSchemaValue<float>(m_ptr, "CFire", "m_flAttackTime");
}
void GCFire::SetAttackTime(float value) {
    SetSchemaValue(m_ptr, "CFire", "m_flAttackTime", false, value);
}
bool GCFire::GetEnabled() const {
    return GetSchemaValue<bool>(m_ptr, "CFire", "m_bEnabled");
}
void GCFire::SetEnabled(bool value) {
    SetSchemaValue(m_ptr, "CFire", "m_bEnabled", false, value);
}
bool GCFire::GetStartDisabled() const {
    return GetSchemaValue<bool>(m_ptr, "CFire", "m_bStartDisabled");
}
void GCFire::SetStartDisabled(bool value) {
    SetSchemaValue(m_ptr, "CFire", "m_bStartDisabled", false, value);
}
bool GCFire::GetDidActivate() const {
    return GetSchemaValue<bool>(m_ptr, "CFire", "m_bDidActivate");
}
void GCFire::SetDidActivate(bool value) {
    SetSchemaValue(m_ptr, "CFire", "m_bDidActivate", false, value);
}
GCEntityIOOutput GCFire::GetOnIgnited() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CFire", "m_OnIgnited"));
    return value;
}
void GCFire::SetOnIgnited(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CFire", "m_OnIgnited", false, value);
}
GCEntityIOOutput GCFire::GetOnExtinguished() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CFire", "m_OnExtinguished"));
    return value;
}
void GCFire::SetOnExtinguished(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CFire", "m_OnExtinguished", false, value);
}
std::string GCFire::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCFire::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseModelEntity GCFire::GetParent() const {
    GCBaseModelEntity value(m_ptr);
    return value;
}
void GCFire::SetParent(GCBaseModelEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCFire(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCFire>("CFire")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Effect", &GCFire::GetEffect, &GCFire::SetEffect)
        .addProperty("Owner", &GCFire::GetOwner, &GCFire::SetOwner)
        .addProperty("FireType", &GCFire::GetFireType, &GCFire::SetFireType)
        .addProperty("Fuel", &GCFire::GetFuel, &GCFire::SetFuel)
        .addProperty("DamageTime", &GCFire::GetDamageTime, &GCFire::SetDamageTime)
        .addProperty("LastDamage", &GCFire::GetLastDamage, &GCFire::SetLastDamage)
        .addProperty("FireSize", &GCFire::GetFireSize, &GCFire::SetFireSize)
        .addProperty("LastNavUpdateTime", &GCFire::GetLastNavUpdateTime, &GCFire::SetLastNavUpdateTime)
        .addProperty("HeatLevel", &GCFire::GetHeatLevel, &GCFire::SetHeatLevel)
        .addProperty("HeatAbsorb", &GCFire::GetHeatAbsorb, &GCFire::SetHeatAbsorb)
        .addProperty("DamageScale", &GCFire::GetDamageScale, &GCFire::SetDamageScale)
        .addProperty("MaxHeat", &GCFire::GetMaxHeat, &GCFire::SetMaxHeat)
        .addProperty("LastHeatLevel", &GCFire::GetLastHeatLevel, &GCFire::SetLastHeatLevel)
        .addProperty("AttackTime", &GCFire::GetAttackTime, &GCFire::SetAttackTime)
        .addProperty("Enabled", &GCFire::GetEnabled, &GCFire::SetEnabled)
        .addProperty("StartDisabled", &GCFire::GetStartDisabled, &GCFire::SetStartDisabled)
        .addProperty("DidActivate", &GCFire::GetDidActivate, &GCFire::SetDidActivate)
        .addProperty("OnIgnited", &GCFire::GetOnIgnited, &GCFire::SetOnIgnited)
        .addProperty("OnExtinguished", &GCFire::GetOnExtinguished, &GCFire::SetOnExtinguished)
        .addProperty("Parent", &GCFire::GetParent, &GCFire::SetParent)
        .addFunction("ToPtr", &GCFire::ToPtr)
        .addFunction("IsValid", &GCFire::IsValid)
        .endClass();
}
GISkeletonAnimationController::GISkeletonAnimationController(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GISkeletonAnimationController::GISkeletonAnimationController(void *ptr) {
    m_ptr = ptr;
}
std::string GISkeletonAnimationController::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GISkeletonAnimationController::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassISkeletonAnimationController(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GISkeletonAnimationController>("ISkeletonAnimationController")
        .addConstructor<void (*)(std::string)>()
        .addFunction("ToPtr", &GISkeletonAnimationController::ToPtr)
        .addFunction("IsValid", &GISkeletonAnimationController::IsValid)
        .endClass();
}
GCCSServerPointScriptEntity::GCCSServerPointScriptEntity(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCCSServerPointScriptEntity::GCCSServerPointScriptEntity(void *ptr) {
    m_ptr = ptr;
}
std::string GCCSServerPointScriptEntity::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCCSServerPointScriptEntity::IsValid() {
    return (m_ptr != nullptr);
}
GCCSPointScriptEntity GCCSServerPointScriptEntity::GetParent() const {
    GCCSPointScriptEntity value(m_ptr);
    return value;
}
void GCCSServerPointScriptEntity::SetParent(GCCSPointScriptEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCCSServerPointScriptEntity(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCCSServerPointScriptEntity>("CCSServerPointScriptEntity")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCCSServerPointScriptEntity::GetParent, &GCCSServerPointScriptEntity::SetParent)
        .addFunction("ToPtr", &GCCSServerPointScriptEntity::ToPtr)
        .addFunction("IsValid", &GCCSServerPointScriptEntity::IsValid)
        .endClass();
}
GCWeaponBizon::GCWeaponBizon(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCWeaponBizon::GCWeaponBizon(void *ptr) {
    m_ptr = ptr;
}
std::string GCWeaponBizon::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCWeaponBizon::IsValid() {
    return (m_ptr != nullptr);
}
GCCSWeaponBaseGun GCWeaponBizon::GetParent() const {
    GCCSWeaponBaseGun value(m_ptr);
    return value;
}
void GCWeaponBizon::SetParent(GCCSWeaponBaseGun value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCWeaponBizon(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCWeaponBizon>("CWeaponBizon")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCWeaponBizon::GetParent, &GCWeaponBizon::SetParent)
        .addFunction("ToPtr", &GCWeaponBizon::ToPtr)
        .addFunction("IsValid", &GCWeaponBizon::IsValid)
        .endClass();
}
GCFuncPlatRot::GCFuncPlatRot(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCFuncPlatRot::GCFuncPlatRot(void *ptr) {
    m_ptr = ptr;
}
QAngle GCFuncPlatRot::GetEnd() const {
    return GetSchemaValue<QAngle>(m_ptr, "CFuncPlatRot", "m_end");
}
void GCFuncPlatRot::SetEnd(QAngle value) {
    SetSchemaValue(m_ptr, "CFuncPlatRot", "m_end", false, value);
}
QAngle GCFuncPlatRot::GetStart() const {
    return GetSchemaValue<QAngle>(m_ptr, "CFuncPlatRot", "m_start");
}
void GCFuncPlatRot::SetStart(QAngle value) {
    SetSchemaValue(m_ptr, "CFuncPlatRot", "m_start", false, value);
}
std::string GCFuncPlatRot::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCFuncPlatRot::IsValid() {
    return (m_ptr != nullptr);
}
GCFuncPlat GCFuncPlatRot::GetParent() const {
    GCFuncPlat value(m_ptr);
    return value;
}
void GCFuncPlatRot::SetParent(GCFuncPlat value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCFuncPlatRot(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCFuncPlatRot>("CFuncPlatRot")
        .addConstructor<void (*)(std::string)>()
        .addProperty("End", &GCFuncPlatRot::GetEnd, &GCFuncPlatRot::SetEnd)
        .addProperty("Start", &GCFuncPlatRot::GetStart, &GCFuncPlatRot::SetStart)
        .addProperty("Parent", &GCFuncPlatRot::GetParent, &GCFuncPlatRot::SetParent)
        .addFunction("ToPtr", &GCFuncPlatRot::ToPtr)
        .addFunction("IsValid", &GCFuncPlatRot::IsValid)
        .endClass();
}
GCGenericConstraint::GCGenericConstraint(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCGenericConstraint::GCGenericConstraint(void *ptr) {
    m_ptr = ptr;
}
uint64_t GCGenericConstraint::GetLinearMotionX() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CGenericConstraint", "m_nLinearMotionX");
}
void GCGenericConstraint::SetLinearMotionX(uint64_t value) {
    SetSchemaValue(m_ptr, "CGenericConstraint", "m_nLinearMotionX", false, value);
}
uint64_t GCGenericConstraint::GetLinearMotionY() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CGenericConstraint", "m_nLinearMotionY");
}
void GCGenericConstraint::SetLinearMotionY(uint64_t value) {
    SetSchemaValue(m_ptr, "CGenericConstraint", "m_nLinearMotionY", false, value);
}
uint64_t GCGenericConstraint::GetLinearMotionZ() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CGenericConstraint", "m_nLinearMotionZ");
}
void GCGenericConstraint::SetLinearMotionZ(uint64_t value) {
    SetSchemaValue(m_ptr, "CGenericConstraint", "m_nLinearMotionZ", false, value);
}
float GCGenericConstraint::GetLinearFrequencyX() const {
    return GetSchemaValue<float>(m_ptr, "CGenericConstraint", "m_flLinearFrequencyX");
}
void GCGenericConstraint::SetLinearFrequencyX(float value) {
    SetSchemaValue(m_ptr, "CGenericConstraint", "m_flLinearFrequencyX", false, value);
}
float GCGenericConstraint::GetLinearFrequencyY() const {
    return GetSchemaValue<float>(m_ptr, "CGenericConstraint", "m_flLinearFrequencyY");
}
void GCGenericConstraint::SetLinearFrequencyY(float value) {
    SetSchemaValue(m_ptr, "CGenericConstraint", "m_flLinearFrequencyY", false, value);
}
float GCGenericConstraint::GetLinearFrequencyZ() const {
    return GetSchemaValue<float>(m_ptr, "CGenericConstraint", "m_flLinearFrequencyZ");
}
void GCGenericConstraint::SetLinearFrequencyZ(float value) {
    SetSchemaValue(m_ptr, "CGenericConstraint", "m_flLinearFrequencyZ", false, value);
}
float GCGenericConstraint::GetLinearDampingRatioX() const {
    return GetSchemaValue<float>(m_ptr, "CGenericConstraint", "m_flLinearDampingRatioX");
}
void GCGenericConstraint::SetLinearDampingRatioX(float value) {
    SetSchemaValue(m_ptr, "CGenericConstraint", "m_flLinearDampingRatioX", false, value);
}
float GCGenericConstraint::GetLinearDampingRatioY() const {
    return GetSchemaValue<float>(m_ptr, "CGenericConstraint", "m_flLinearDampingRatioY");
}
void GCGenericConstraint::SetLinearDampingRatioY(float value) {
    SetSchemaValue(m_ptr, "CGenericConstraint", "m_flLinearDampingRatioY", false, value);
}
float GCGenericConstraint::GetLinearDampingRatioZ() const {
    return GetSchemaValue<float>(m_ptr, "CGenericConstraint", "m_flLinearDampingRatioZ");
}
void GCGenericConstraint::SetLinearDampingRatioZ(float value) {
    SetSchemaValue(m_ptr, "CGenericConstraint", "m_flLinearDampingRatioZ", false, value);
}
float GCGenericConstraint::GetMaxLinearImpulseX() const {
    return GetSchemaValue<float>(m_ptr, "CGenericConstraint", "m_flMaxLinearImpulseX");
}
void GCGenericConstraint::SetMaxLinearImpulseX(float value) {
    SetSchemaValue(m_ptr, "CGenericConstraint", "m_flMaxLinearImpulseX", false, value);
}
float GCGenericConstraint::GetMaxLinearImpulseY() const {
    return GetSchemaValue<float>(m_ptr, "CGenericConstraint", "m_flMaxLinearImpulseY");
}
void GCGenericConstraint::SetMaxLinearImpulseY(float value) {
    SetSchemaValue(m_ptr, "CGenericConstraint", "m_flMaxLinearImpulseY", false, value);
}
float GCGenericConstraint::GetMaxLinearImpulseZ() const {
    return GetSchemaValue<float>(m_ptr, "CGenericConstraint", "m_flMaxLinearImpulseZ");
}
void GCGenericConstraint::SetMaxLinearImpulseZ(float value) {
    SetSchemaValue(m_ptr, "CGenericConstraint", "m_flMaxLinearImpulseZ", false, value);
}
float GCGenericConstraint::GetBreakAfterTimeX() const {
    return GetSchemaValue<float>(m_ptr, "CGenericConstraint", "m_flBreakAfterTimeX");
}
void GCGenericConstraint::SetBreakAfterTimeX(float value) {
    SetSchemaValue(m_ptr, "CGenericConstraint", "m_flBreakAfterTimeX", false, value);
}
float GCGenericConstraint::GetBreakAfterTimeY() const {
    return GetSchemaValue<float>(m_ptr, "CGenericConstraint", "m_flBreakAfterTimeY");
}
void GCGenericConstraint::SetBreakAfterTimeY(float value) {
    SetSchemaValue(m_ptr, "CGenericConstraint", "m_flBreakAfterTimeY", false, value);
}
float GCGenericConstraint::GetBreakAfterTimeZ() const {
    return GetSchemaValue<float>(m_ptr, "CGenericConstraint", "m_flBreakAfterTimeZ");
}
void GCGenericConstraint::SetBreakAfterTimeZ(float value) {
    SetSchemaValue(m_ptr, "CGenericConstraint", "m_flBreakAfterTimeZ", false, value);
}
float GCGenericConstraint::GetBreakAfterTimeStartTimeX() const {
    return GetSchemaValue<float>(m_ptr, "CGenericConstraint", "m_flBreakAfterTimeStartTimeX");
}
void GCGenericConstraint::SetBreakAfterTimeStartTimeX(float value) {
    SetSchemaValue(m_ptr, "CGenericConstraint", "m_flBreakAfterTimeStartTimeX", false, value);
}
float GCGenericConstraint::GetBreakAfterTimeStartTimeY() const {
    return GetSchemaValue<float>(m_ptr, "CGenericConstraint", "m_flBreakAfterTimeStartTimeY");
}
void GCGenericConstraint::SetBreakAfterTimeStartTimeY(float value) {
    SetSchemaValue(m_ptr, "CGenericConstraint", "m_flBreakAfterTimeStartTimeY", false, value);
}
float GCGenericConstraint::GetBreakAfterTimeStartTimeZ() const {
    return GetSchemaValue<float>(m_ptr, "CGenericConstraint", "m_flBreakAfterTimeStartTimeZ");
}
void GCGenericConstraint::SetBreakAfterTimeStartTimeZ(float value) {
    SetSchemaValue(m_ptr, "CGenericConstraint", "m_flBreakAfterTimeStartTimeZ", false, value);
}
float GCGenericConstraint::GetBreakAfterTimeThresholdX() const {
    return GetSchemaValue<float>(m_ptr, "CGenericConstraint", "m_flBreakAfterTimeThresholdX");
}
void GCGenericConstraint::SetBreakAfterTimeThresholdX(float value) {
    SetSchemaValue(m_ptr, "CGenericConstraint", "m_flBreakAfterTimeThresholdX", false, value);
}
float GCGenericConstraint::GetBreakAfterTimeThresholdY() const {
    return GetSchemaValue<float>(m_ptr, "CGenericConstraint", "m_flBreakAfterTimeThresholdY");
}
void GCGenericConstraint::SetBreakAfterTimeThresholdY(float value) {
    SetSchemaValue(m_ptr, "CGenericConstraint", "m_flBreakAfterTimeThresholdY", false, value);
}
float GCGenericConstraint::GetBreakAfterTimeThresholdZ() const {
    return GetSchemaValue<float>(m_ptr, "CGenericConstraint", "m_flBreakAfterTimeThresholdZ");
}
void GCGenericConstraint::SetBreakAfterTimeThresholdZ(float value) {
    SetSchemaValue(m_ptr, "CGenericConstraint", "m_flBreakAfterTimeThresholdZ", false, value);
}
float GCGenericConstraint::GetNotifyForceX() const {
    return GetSchemaValue<float>(m_ptr, "CGenericConstraint", "m_flNotifyForceX");
}
void GCGenericConstraint::SetNotifyForceX(float value) {
    SetSchemaValue(m_ptr, "CGenericConstraint", "m_flNotifyForceX", false, value);
}
float GCGenericConstraint::GetNotifyForceY() const {
    return GetSchemaValue<float>(m_ptr, "CGenericConstraint", "m_flNotifyForceY");
}
void GCGenericConstraint::SetNotifyForceY(float value) {
    SetSchemaValue(m_ptr, "CGenericConstraint", "m_flNotifyForceY", false, value);
}
float GCGenericConstraint::GetNotifyForceZ() const {
    return GetSchemaValue<float>(m_ptr, "CGenericConstraint", "m_flNotifyForceZ");
}
void GCGenericConstraint::SetNotifyForceZ(float value) {
    SetSchemaValue(m_ptr, "CGenericConstraint", "m_flNotifyForceZ", false, value);
}
float GCGenericConstraint::GetNotifyForceMinTimeX() const {
    return GetSchemaValue<float>(m_ptr, "CGenericConstraint", "m_flNotifyForceMinTimeX");
}
void GCGenericConstraint::SetNotifyForceMinTimeX(float value) {
    SetSchemaValue(m_ptr, "CGenericConstraint", "m_flNotifyForceMinTimeX", false, value);
}
float GCGenericConstraint::GetNotifyForceMinTimeY() const {
    return GetSchemaValue<float>(m_ptr, "CGenericConstraint", "m_flNotifyForceMinTimeY");
}
void GCGenericConstraint::SetNotifyForceMinTimeY(float value) {
    SetSchemaValue(m_ptr, "CGenericConstraint", "m_flNotifyForceMinTimeY", false, value);
}
float GCGenericConstraint::GetNotifyForceMinTimeZ() const {
    return GetSchemaValue<float>(m_ptr, "CGenericConstraint", "m_flNotifyForceMinTimeZ");
}
void GCGenericConstraint::SetNotifyForceMinTimeZ(float value) {
    SetSchemaValue(m_ptr, "CGenericConstraint", "m_flNotifyForceMinTimeZ", false, value);
}
float GCGenericConstraint::GetNotifyForceLastTimeX() const {
    return GetSchemaValue<float>(m_ptr, "CGenericConstraint", "m_flNotifyForceLastTimeX");
}
void GCGenericConstraint::SetNotifyForceLastTimeX(float value) {
    SetSchemaValue(m_ptr, "CGenericConstraint", "m_flNotifyForceLastTimeX", false, value);
}
float GCGenericConstraint::GetNotifyForceLastTimeY() const {
    return GetSchemaValue<float>(m_ptr, "CGenericConstraint", "m_flNotifyForceLastTimeY");
}
void GCGenericConstraint::SetNotifyForceLastTimeY(float value) {
    SetSchemaValue(m_ptr, "CGenericConstraint", "m_flNotifyForceLastTimeY", false, value);
}
float GCGenericConstraint::GetNotifyForceLastTimeZ() const {
    return GetSchemaValue<float>(m_ptr, "CGenericConstraint", "m_flNotifyForceLastTimeZ");
}
void GCGenericConstraint::SetNotifyForceLastTimeZ(float value) {
    SetSchemaValue(m_ptr, "CGenericConstraint", "m_flNotifyForceLastTimeZ", false, value);
}
bool GCGenericConstraint::GetAxisNotifiedX() const {
    return GetSchemaValue<bool>(m_ptr, "CGenericConstraint", "m_bAxisNotifiedX");
}
void GCGenericConstraint::SetAxisNotifiedX(bool value) {
    SetSchemaValue(m_ptr, "CGenericConstraint", "m_bAxisNotifiedX", false, value);
}
bool GCGenericConstraint::GetAxisNotifiedY() const {
    return GetSchemaValue<bool>(m_ptr, "CGenericConstraint", "m_bAxisNotifiedY");
}
void GCGenericConstraint::SetAxisNotifiedY(bool value) {
    SetSchemaValue(m_ptr, "CGenericConstraint", "m_bAxisNotifiedY", false, value);
}
bool GCGenericConstraint::GetAxisNotifiedZ() const {
    return GetSchemaValue<bool>(m_ptr, "CGenericConstraint", "m_bAxisNotifiedZ");
}
void GCGenericConstraint::SetAxisNotifiedZ(bool value) {
    SetSchemaValue(m_ptr, "CGenericConstraint", "m_bAxisNotifiedZ", false, value);
}
uint64_t GCGenericConstraint::GetAngularMotionX() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CGenericConstraint", "m_nAngularMotionX");
}
void GCGenericConstraint::SetAngularMotionX(uint64_t value) {
    SetSchemaValue(m_ptr, "CGenericConstraint", "m_nAngularMotionX", false, value);
}
uint64_t GCGenericConstraint::GetAngularMotionY() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CGenericConstraint", "m_nAngularMotionY");
}
void GCGenericConstraint::SetAngularMotionY(uint64_t value) {
    SetSchemaValue(m_ptr, "CGenericConstraint", "m_nAngularMotionY", false, value);
}
uint64_t GCGenericConstraint::GetAngularMotionZ() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CGenericConstraint", "m_nAngularMotionZ");
}
void GCGenericConstraint::SetAngularMotionZ(uint64_t value) {
    SetSchemaValue(m_ptr, "CGenericConstraint", "m_nAngularMotionZ", false, value);
}
float GCGenericConstraint::GetAngularFrequencyX() const {
    return GetSchemaValue<float>(m_ptr, "CGenericConstraint", "m_flAngularFrequencyX");
}
void GCGenericConstraint::SetAngularFrequencyX(float value) {
    SetSchemaValue(m_ptr, "CGenericConstraint", "m_flAngularFrequencyX", false, value);
}
float GCGenericConstraint::GetAngularFrequencyY() const {
    return GetSchemaValue<float>(m_ptr, "CGenericConstraint", "m_flAngularFrequencyY");
}
void GCGenericConstraint::SetAngularFrequencyY(float value) {
    SetSchemaValue(m_ptr, "CGenericConstraint", "m_flAngularFrequencyY", false, value);
}
float GCGenericConstraint::GetAngularFrequencyZ() const {
    return GetSchemaValue<float>(m_ptr, "CGenericConstraint", "m_flAngularFrequencyZ");
}
void GCGenericConstraint::SetAngularFrequencyZ(float value) {
    SetSchemaValue(m_ptr, "CGenericConstraint", "m_flAngularFrequencyZ", false, value);
}
float GCGenericConstraint::GetAngularDampingRatioX() const {
    return GetSchemaValue<float>(m_ptr, "CGenericConstraint", "m_flAngularDampingRatioX");
}
void GCGenericConstraint::SetAngularDampingRatioX(float value) {
    SetSchemaValue(m_ptr, "CGenericConstraint", "m_flAngularDampingRatioX", false, value);
}
float GCGenericConstraint::GetAngularDampingRatioY() const {
    return GetSchemaValue<float>(m_ptr, "CGenericConstraint", "m_flAngularDampingRatioY");
}
void GCGenericConstraint::SetAngularDampingRatioY(float value) {
    SetSchemaValue(m_ptr, "CGenericConstraint", "m_flAngularDampingRatioY", false, value);
}
float GCGenericConstraint::GetAngularDampingRatioZ() const {
    return GetSchemaValue<float>(m_ptr, "CGenericConstraint", "m_flAngularDampingRatioZ");
}
void GCGenericConstraint::SetAngularDampingRatioZ(float value) {
    SetSchemaValue(m_ptr, "CGenericConstraint", "m_flAngularDampingRatioZ", false, value);
}
float GCGenericConstraint::GetMaxAngularImpulseX() const {
    return GetSchemaValue<float>(m_ptr, "CGenericConstraint", "m_flMaxAngularImpulseX");
}
void GCGenericConstraint::SetMaxAngularImpulseX(float value) {
    SetSchemaValue(m_ptr, "CGenericConstraint", "m_flMaxAngularImpulseX", false, value);
}
float GCGenericConstraint::GetMaxAngularImpulseY() const {
    return GetSchemaValue<float>(m_ptr, "CGenericConstraint", "m_flMaxAngularImpulseY");
}
void GCGenericConstraint::SetMaxAngularImpulseY(float value) {
    SetSchemaValue(m_ptr, "CGenericConstraint", "m_flMaxAngularImpulseY", false, value);
}
float GCGenericConstraint::GetMaxAngularImpulseZ() const {
    return GetSchemaValue<float>(m_ptr, "CGenericConstraint", "m_flMaxAngularImpulseZ");
}
void GCGenericConstraint::SetMaxAngularImpulseZ(float value) {
    SetSchemaValue(m_ptr, "CGenericConstraint", "m_flMaxAngularImpulseZ", false, value);
}
GCEntityIOOutput GCGenericConstraint::GetNotifyForceReachedX() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CGenericConstraint", "m_NotifyForceReachedX"));
    return value;
}
void GCGenericConstraint::SetNotifyForceReachedX(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CGenericConstraint", "m_NotifyForceReachedX", false, value);
}
GCEntityIOOutput GCGenericConstraint::GetNotifyForceReachedY() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CGenericConstraint", "m_NotifyForceReachedY"));
    return value;
}
void GCGenericConstraint::SetNotifyForceReachedY(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CGenericConstraint", "m_NotifyForceReachedY", false, value);
}
GCEntityIOOutput GCGenericConstraint::GetNotifyForceReachedZ() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CGenericConstraint", "m_NotifyForceReachedZ"));
    return value;
}
void GCGenericConstraint::SetNotifyForceReachedZ(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CGenericConstraint", "m_NotifyForceReachedZ", false, value);
}
std::string GCGenericConstraint::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCGenericConstraint::IsValid() {
    return (m_ptr != nullptr);
}
GCPhysConstraint GCGenericConstraint::GetParent() const {
    GCPhysConstraint value(m_ptr);
    return value;
}
void GCGenericConstraint::SetParent(GCPhysConstraint value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCGenericConstraint(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCGenericConstraint>("CGenericConstraint")
        .addConstructor<void (*)(std::string)>()
        .addProperty("LinearMotionX", &GCGenericConstraint::GetLinearMotionX, &GCGenericConstraint::SetLinearMotionX)
        .addProperty("LinearMotionY", &GCGenericConstraint::GetLinearMotionY, &GCGenericConstraint::SetLinearMotionY)
        .addProperty("LinearMotionZ", &GCGenericConstraint::GetLinearMotionZ, &GCGenericConstraint::SetLinearMotionZ)
        .addProperty("LinearFrequencyX", &GCGenericConstraint::GetLinearFrequencyX, &GCGenericConstraint::SetLinearFrequencyX)
        .addProperty("LinearFrequencyY", &GCGenericConstraint::GetLinearFrequencyY, &GCGenericConstraint::SetLinearFrequencyY)
        .addProperty("LinearFrequencyZ", &GCGenericConstraint::GetLinearFrequencyZ, &GCGenericConstraint::SetLinearFrequencyZ)
        .addProperty("LinearDampingRatioX", &GCGenericConstraint::GetLinearDampingRatioX, &GCGenericConstraint::SetLinearDampingRatioX)
        .addProperty("LinearDampingRatioY", &GCGenericConstraint::GetLinearDampingRatioY, &GCGenericConstraint::SetLinearDampingRatioY)
        .addProperty("LinearDampingRatioZ", &GCGenericConstraint::GetLinearDampingRatioZ, &GCGenericConstraint::SetLinearDampingRatioZ)
        .addProperty("MaxLinearImpulseX", &GCGenericConstraint::GetMaxLinearImpulseX, &GCGenericConstraint::SetMaxLinearImpulseX)
        .addProperty("MaxLinearImpulseY", &GCGenericConstraint::GetMaxLinearImpulseY, &GCGenericConstraint::SetMaxLinearImpulseY)
        .addProperty("MaxLinearImpulseZ", &GCGenericConstraint::GetMaxLinearImpulseZ, &GCGenericConstraint::SetMaxLinearImpulseZ)
        .addProperty("BreakAfterTimeX", &GCGenericConstraint::GetBreakAfterTimeX, &GCGenericConstraint::SetBreakAfterTimeX)
        .addProperty("BreakAfterTimeY", &GCGenericConstraint::GetBreakAfterTimeY, &GCGenericConstraint::SetBreakAfterTimeY)
        .addProperty("BreakAfterTimeZ", &GCGenericConstraint::GetBreakAfterTimeZ, &GCGenericConstraint::SetBreakAfterTimeZ)
        .addProperty("BreakAfterTimeStartTimeX", &GCGenericConstraint::GetBreakAfterTimeStartTimeX, &GCGenericConstraint::SetBreakAfterTimeStartTimeX)
        .addProperty("BreakAfterTimeStartTimeY", &GCGenericConstraint::GetBreakAfterTimeStartTimeY, &GCGenericConstraint::SetBreakAfterTimeStartTimeY)
        .addProperty("BreakAfterTimeStartTimeZ", &GCGenericConstraint::GetBreakAfterTimeStartTimeZ, &GCGenericConstraint::SetBreakAfterTimeStartTimeZ)
        .addProperty("BreakAfterTimeThresholdX", &GCGenericConstraint::GetBreakAfterTimeThresholdX, &GCGenericConstraint::SetBreakAfterTimeThresholdX)
        .addProperty("BreakAfterTimeThresholdY", &GCGenericConstraint::GetBreakAfterTimeThresholdY, &GCGenericConstraint::SetBreakAfterTimeThresholdY)
        .addProperty("BreakAfterTimeThresholdZ", &GCGenericConstraint::GetBreakAfterTimeThresholdZ, &GCGenericConstraint::SetBreakAfterTimeThresholdZ)
        .addProperty("NotifyForceX", &GCGenericConstraint::GetNotifyForceX, &GCGenericConstraint::SetNotifyForceX)
        .addProperty("NotifyForceY", &GCGenericConstraint::GetNotifyForceY, &GCGenericConstraint::SetNotifyForceY)
        .addProperty("NotifyForceZ", &GCGenericConstraint::GetNotifyForceZ, &GCGenericConstraint::SetNotifyForceZ)
        .addProperty("NotifyForceMinTimeX", &GCGenericConstraint::GetNotifyForceMinTimeX, &GCGenericConstraint::SetNotifyForceMinTimeX)
        .addProperty("NotifyForceMinTimeY", &GCGenericConstraint::GetNotifyForceMinTimeY, &GCGenericConstraint::SetNotifyForceMinTimeY)
        .addProperty("NotifyForceMinTimeZ", &GCGenericConstraint::GetNotifyForceMinTimeZ, &GCGenericConstraint::SetNotifyForceMinTimeZ)
        .addProperty("NotifyForceLastTimeX", &GCGenericConstraint::GetNotifyForceLastTimeX, &GCGenericConstraint::SetNotifyForceLastTimeX)
        .addProperty("NotifyForceLastTimeY", &GCGenericConstraint::GetNotifyForceLastTimeY, &GCGenericConstraint::SetNotifyForceLastTimeY)
        .addProperty("NotifyForceLastTimeZ", &GCGenericConstraint::GetNotifyForceLastTimeZ, &GCGenericConstraint::SetNotifyForceLastTimeZ)
        .addProperty("AxisNotifiedX", &GCGenericConstraint::GetAxisNotifiedX, &GCGenericConstraint::SetAxisNotifiedX)
        .addProperty("AxisNotifiedY", &GCGenericConstraint::GetAxisNotifiedY, &GCGenericConstraint::SetAxisNotifiedY)
        .addProperty("AxisNotifiedZ", &GCGenericConstraint::GetAxisNotifiedZ, &GCGenericConstraint::SetAxisNotifiedZ)
        .addProperty("AngularMotionX", &GCGenericConstraint::GetAngularMotionX, &GCGenericConstraint::SetAngularMotionX)
        .addProperty("AngularMotionY", &GCGenericConstraint::GetAngularMotionY, &GCGenericConstraint::SetAngularMotionY)
        .addProperty("AngularMotionZ", &GCGenericConstraint::GetAngularMotionZ, &GCGenericConstraint::SetAngularMotionZ)
        .addProperty("AngularFrequencyX", &GCGenericConstraint::GetAngularFrequencyX, &GCGenericConstraint::SetAngularFrequencyX)
        .addProperty("AngularFrequencyY", &GCGenericConstraint::GetAngularFrequencyY, &GCGenericConstraint::SetAngularFrequencyY)
        .addProperty("AngularFrequencyZ", &GCGenericConstraint::GetAngularFrequencyZ, &GCGenericConstraint::SetAngularFrequencyZ)
        .addProperty("AngularDampingRatioX", &GCGenericConstraint::GetAngularDampingRatioX, &GCGenericConstraint::SetAngularDampingRatioX)
        .addProperty("AngularDampingRatioY", &GCGenericConstraint::GetAngularDampingRatioY, &GCGenericConstraint::SetAngularDampingRatioY)
        .addProperty("AngularDampingRatioZ", &GCGenericConstraint::GetAngularDampingRatioZ, &GCGenericConstraint::SetAngularDampingRatioZ)
        .addProperty("MaxAngularImpulseX", &GCGenericConstraint::GetMaxAngularImpulseX, &GCGenericConstraint::SetMaxAngularImpulseX)
        .addProperty("MaxAngularImpulseY", &GCGenericConstraint::GetMaxAngularImpulseY, &GCGenericConstraint::SetMaxAngularImpulseY)
        .addProperty("MaxAngularImpulseZ", &GCGenericConstraint::GetMaxAngularImpulseZ, &GCGenericConstraint::SetMaxAngularImpulseZ)
        .addProperty("NotifyForceReachedX", &GCGenericConstraint::GetNotifyForceReachedX, &GCGenericConstraint::SetNotifyForceReachedX)
        .addProperty("NotifyForceReachedY", &GCGenericConstraint::GetNotifyForceReachedY, &GCGenericConstraint::SetNotifyForceReachedY)
        .addProperty("NotifyForceReachedZ", &GCGenericConstraint::GetNotifyForceReachedZ, &GCGenericConstraint::SetNotifyForceReachedZ)
        .addProperty("Parent", &GCGenericConstraint::GetParent, &GCGenericConstraint::SetParent)
        .addFunction("ToPtr", &GCGenericConstraint::ToPtr)
        .addFunction("IsValid", &GCGenericConstraint::IsValid)
        .endClass();
}
GCDecoyGrenade::GCDecoyGrenade(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCDecoyGrenade::GCDecoyGrenade(void *ptr) {
    m_ptr = ptr;
}
std::string GCDecoyGrenade::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCDecoyGrenade::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseCSGrenade GCDecoyGrenade::GetParent() const {
    GCBaseCSGrenade value(m_ptr);
    return value;
}
void GCDecoyGrenade::SetParent(GCBaseCSGrenade value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCDecoyGrenade(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCDecoyGrenade>("CDecoyGrenade")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCDecoyGrenade::GetParent, &GCDecoyGrenade::SetParent)
        .addFunction("ToPtr", &GCDecoyGrenade::ToPtr)
        .addFunction("IsValid", &GCDecoyGrenade::IsValid)
        .endClass();
}
GCWeaponG3SG1::GCWeaponG3SG1(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCWeaponG3SG1::GCWeaponG3SG1(void *ptr) {
    m_ptr = ptr;
}
std::string GCWeaponG3SG1::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCWeaponG3SG1::IsValid() {
    return (m_ptr != nullptr);
}
GCCSWeaponBaseGun GCWeaponG3SG1::GetParent() const {
    GCCSWeaponBaseGun value(m_ptr);
    return value;
}
void GCWeaponG3SG1::SetParent(GCCSWeaponBaseGun value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCWeaponG3SG1(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCWeaponG3SG1>("CWeaponG3SG1")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCWeaponG3SG1::GetParent, &GCWeaponG3SG1::SetParent)
        .addFunction("ToPtr", &GCWeaponG3SG1::ToPtr)
        .addFunction("IsValid", &GCWeaponG3SG1::IsValid)
        .endClass();
}
GCItemDefuser::GCItemDefuser(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCItemDefuser::GCItemDefuser(void *ptr) {
    m_ptr = ptr;
}
GEntitySpottedState_t GCItemDefuser::GetEntitySpottedState() const {
    GEntitySpottedState_t value(GetSchemaPtr(m_ptr, "CItemDefuser", "m_entitySpottedState"));
    return value;
}
void GCItemDefuser::SetEntitySpottedState(GEntitySpottedState_t value) {
    SetSchemaValue(m_ptr, "CItemDefuser", "m_entitySpottedState", false, value);
}
int32_t GCItemDefuser::GetSpotRules() const {
    return GetSchemaValue<int32_t>(m_ptr, "CItemDefuser", "m_nSpotRules");
}
void GCItemDefuser::SetSpotRules(int32_t value) {
    SetSchemaValue(m_ptr, "CItemDefuser", "m_nSpotRules", false, value);
}
std::string GCItemDefuser::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCItemDefuser::IsValid() {
    return (m_ptr != nullptr);
}
GCItem GCItemDefuser::GetParent() const {
    GCItem value(m_ptr);
    return value;
}
void GCItemDefuser::SetParent(GCItem value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCItemDefuser(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCItemDefuser>("CItemDefuser")
        .addConstructor<void (*)(std::string)>()
        .addProperty("EntitySpottedState", &GCItemDefuser::GetEntitySpottedState, &GCItemDefuser::SetEntitySpottedState)
        .addProperty("SpotRules", &GCItemDefuser::GetSpotRules, &GCItemDefuser::SetSpotRules)
        .addProperty("Parent", &GCItemDefuser::GetParent, &GCItemDefuser::SetParent)
        .addFunction("ToPtr", &GCItemDefuser::ToPtr)
        .addFunction("IsValid", &GCItemDefuser::IsValid)
        .endClass();
}
GCConstantForceController::GCConstantForceController(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCConstantForceController::GCConstantForceController(void *ptr) {
    m_ptr = ptr;
}
Vector GCConstantForceController::GetLinear() const {
    return GetSchemaValue<Vector>(m_ptr, "CConstantForceController", "m_linear");
}
void GCConstantForceController::SetLinear(Vector value) {
    SetSchemaValue(m_ptr, "CConstantForceController", "m_linear", false, value);
}
Vector GCConstantForceController::GetAngular() const {
    return GetSchemaValue<Vector>(m_ptr, "CConstantForceController", "m_angular");
}
void GCConstantForceController::SetAngular(Vector value) {
    SetSchemaValue(m_ptr, "CConstantForceController", "m_angular", false, value);
}
Vector GCConstantForceController::GetLinearSave() const {
    return GetSchemaValue<Vector>(m_ptr, "CConstantForceController", "m_linearSave");
}
void GCConstantForceController::SetLinearSave(Vector value) {
    SetSchemaValue(m_ptr, "CConstantForceController", "m_linearSave", false, value);
}
Vector GCConstantForceController::GetAngularSave() const {
    return GetSchemaValue<Vector>(m_ptr, "CConstantForceController", "m_angularSave");
}
void GCConstantForceController::SetAngularSave(Vector value) {
    SetSchemaValue(m_ptr, "CConstantForceController", "m_angularSave", false, value);
}
std::string GCConstantForceController::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCConstantForceController::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCConstantForceController(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCConstantForceController>("CConstantForceController")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Linear", &GCConstantForceController::GetLinear, &GCConstantForceController::SetLinear)
        .addProperty("Angular", &GCConstantForceController::GetAngular, &GCConstantForceController::SetAngular)
        .addProperty("LinearSave", &GCConstantForceController::GetLinearSave, &GCConstantForceController::SetLinearSave)
        .addProperty("AngularSave", &GCConstantForceController::GetAngularSave, &GCConstantForceController::SetAngularSave)
        .addFunction("ToPtr", &GCConstantForceController::ToPtr)
        .addFunction("IsValid", &GCConstantForceController::IsValid)
        .endClass();
}
GCDEagle::GCDEagle(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCDEagle::GCDEagle(void *ptr) {
    m_ptr = ptr;
}
std::string GCDEagle::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCDEagle::IsValid() {
    return (m_ptr != nullptr);
}
GCCSWeaponBaseGun GCDEagle::GetParent() const {
    GCCSWeaponBaseGun value(m_ptr);
    return value;
}
void GCDEagle::SetParent(GCCSWeaponBaseGun value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCDEagle(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCDEagle>("CDEagle")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCDEagle::GetParent, &GCDEagle::SetParent)
        .addFunction("ToPtr", &GCDEagle::ToPtr)
        .addFunction("IsValid", &GCDEagle::IsValid)
        .endClass();
}
GCRagdollProp::GCRagdollProp(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCRagdollProp::GCRagdollProp(void *ptr) {
    m_ptr = ptr;
}
Gragdoll_t GCRagdollProp::GetRagdoll() const {
    Gragdoll_t value(GetSchemaPtr(m_ptr, "CRagdollProp", "m_ragdoll"));
    return value;
}
void GCRagdollProp::SetRagdoll(Gragdoll_t value) {
    SetSchemaValue(m_ptr, "CRagdollProp", "m_ragdoll", false, value);
}
bool GCRagdollProp::GetStartDisabled() const {
    return GetSchemaValue<bool>(m_ptr, "CRagdollProp", "m_bStartDisabled");
}
void GCRagdollProp::SetStartDisabled(bool value) {
    SetSchemaValue(m_ptr, "CRagdollProp", "m_bStartDisabled", false, value);
}
std::vector<Vector> GCRagdollProp::GetRagPos() const {
    CUtlVector<Vector>* vec = GetSchemaValue<CUtlVector<Vector>*>(m_ptr, "CRagdollProp", "m_ragPos"); std::vector<Vector> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCRagdollProp::SetRagPos(std::vector<Vector> value) {
    SetSchemaValueCUtlVector<Vector>(m_ptr, "CRagdollProp", "m_ragPos", false, value);
}
std::vector<QAngle> GCRagdollProp::GetRagAngles() const {
    CUtlVector<QAngle>* vec = GetSchemaValue<CUtlVector<QAngle>*>(m_ptr, "CRagdollProp", "m_ragAngles"); std::vector<QAngle> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCRagdollProp::SetRagAngles(std::vector<QAngle> value) {
    SetSchemaValueCUtlVector<QAngle>(m_ptr, "CRagdollProp", "m_ragAngles", false, value);
}
GCBaseEntity GCRagdollProp::GetRagdollSource() const {
    GCBaseEntity value(*GetSchemaValuePtr<void*>(m_ptr, "CRagdollProp", "m_hRagdollSource"));
    return value;
}
void GCRagdollProp::SetRagdollSource(GCBaseEntity* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'RagdollSource' is not possible.\n");
}
uint32_t GCRagdollProp::GetLastUpdateTickCount() const {
    return GetSchemaValue<uint32_t>(m_ptr, "CRagdollProp", "m_lastUpdateTickCount");
}
void GCRagdollProp::SetLastUpdateTickCount(uint32_t value) {
    SetSchemaValue(m_ptr, "CRagdollProp", "m_lastUpdateTickCount", false, value);
}
bool GCRagdollProp::GetAllAsleep() const {
    return GetSchemaValue<bool>(m_ptr, "CRagdollProp", "m_allAsleep");
}
void GCRagdollProp::SetAllAsleep(bool value) {
    SetSchemaValue(m_ptr, "CRagdollProp", "m_allAsleep", false, value);
}
bool GCRagdollProp::GetFirstCollisionAfterLaunch() const {
    return GetSchemaValue<bool>(m_ptr, "CRagdollProp", "m_bFirstCollisionAfterLaunch");
}
void GCRagdollProp::SetFirstCollisionAfterLaunch(bool value) {
    SetSchemaValue(m_ptr, "CRagdollProp", "m_bFirstCollisionAfterLaunch", false, value);
}
GCBaseEntity GCRagdollProp::GetDamageEntity() const {
    GCBaseEntity value(*GetSchemaValuePtr<void*>(m_ptr, "CRagdollProp", "m_hDamageEntity"));
    return value;
}
void GCRagdollProp::SetDamageEntity(GCBaseEntity* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'DamageEntity' is not possible.\n");
}
GCBaseEntity GCRagdollProp::GetKiller() const {
    GCBaseEntity value(*GetSchemaValuePtr<void*>(m_ptr, "CRagdollProp", "m_hKiller"));
    return value;
}
void GCRagdollProp::SetKiller(GCBaseEntity* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Killer' is not possible.\n");
}
GCBasePlayerPawn GCRagdollProp::GetPhysicsAttacker() const {
    GCBasePlayerPawn value(*GetSchemaValuePtr<void*>(m_ptr, "CRagdollProp", "m_hPhysicsAttacker"));
    return value;
}
void GCRagdollProp::SetPhysicsAttacker(GCBasePlayerPawn* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'PhysicsAttacker' is not possible.\n");
}
float GCRagdollProp::GetLastPhysicsInfluenceTime() const {
    return GetSchemaValue<float>(m_ptr, "CRagdollProp", "m_flLastPhysicsInfluenceTime");
}
void GCRagdollProp::SetLastPhysicsInfluenceTime(float value) {
    SetSchemaValue(m_ptr, "CRagdollProp", "m_flLastPhysicsInfluenceTime", false, value);
}
float GCRagdollProp::GetFadeOutStartTime() const {
    return GetSchemaValue<float>(m_ptr, "CRagdollProp", "m_flFadeOutStartTime");
}
void GCRagdollProp::SetFadeOutStartTime(float value) {
    SetSchemaValue(m_ptr, "CRagdollProp", "m_flFadeOutStartTime", false, value);
}
float GCRagdollProp::GetFadeTime() const {
    return GetSchemaValue<float>(m_ptr, "CRagdollProp", "m_flFadeTime");
}
void GCRagdollProp::SetFadeTime(float value) {
    SetSchemaValue(m_ptr, "CRagdollProp", "m_flFadeTime", false, value);
}
Vector GCRagdollProp::GetLastOrigin() const {
    return GetSchemaValue<Vector>(m_ptr, "CRagdollProp", "m_vecLastOrigin");
}
void GCRagdollProp::SetLastOrigin(Vector value) {
    SetSchemaValue(m_ptr, "CRagdollProp", "m_vecLastOrigin", false, value);
}
float GCRagdollProp::GetAwakeTime() const {
    return GetSchemaValue<float>(m_ptr, "CRagdollProp", "m_flAwakeTime");
}
void GCRagdollProp::SetAwakeTime(float value) {
    SetSchemaValue(m_ptr, "CRagdollProp", "m_flAwakeTime", false, value);
}
float GCRagdollProp::GetLastOriginChangeTime() const {
    return GetSchemaValue<float>(m_ptr, "CRagdollProp", "m_flLastOriginChangeTime");
}
void GCRagdollProp::SetLastOriginChangeTime(float value) {
    SetSchemaValue(m_ptr, "CRagdollProp", "m_flLastOriginChangeTime", false, value);
}
std::string GCRagdollProp::GetStrOriginClassName() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CRagdollProp", "m_strOriginClassName").String();
}
void GCRagdollProp::SetStrOriginClassName(std::string value) {
    SetSchemaValue(m_ptr, "CRagdollProp", "m_strOriginClassName", false, CUtlSymbolLarge(value.c_str()));
}
std::string GCRagdollProp::GetStrSourceClassName() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CRagdollProp", "m_strSourceClassName").String();
}
void GCRagdollProp::SetStrSourceClassName(std::string value) {
    SetSchemaValue(m_ptr, "CRagdollProp", "m_strSourceClassName", false, CUtlSymbolLarge(value.c_str()));
}
bool GCRagdollProp::GetHasBeenPhysgunned() const {
    return GetSchemaValue<bool>(m_ptr, "CRagdollProp", "m_bHasBeenPhysgunned");
}
void GCRagdollProp::SetHasBeenPhysgunned(bool value) {
    SetSchemaValue(m_ptr, "CRagdollProp", "m_bHasBeenPhysgunned", false, value);
}
bool GCRagdollProp::GetShouldTeleportPhysics() const {
    return GetSchemaValue<bool>(m_ptr, "CRagdollProp", "m_bShouldTeleportPhysics");
}
void GCRagdollProp::SetShouldTeleportPhysics(bool value) {
    SetSchemaValue(m_ptr, "CRagdollProp", "m_bShouldTeleportPhysics", false, value);
}
float GCRagdollProp::GetBlendWeight() const {
    return GetSchemaValue<float>(m_ptr, "CRagdollProp", "m_flBlendWeight");
}
void GCRagdollProp::SetBlendWeight(float value) {
    SetSchemaValue(m_ptr, "CRagdollProp", "m_flBlendWeight", false, value);
}
float GCRagdollProp::GetDefaultFadeScale() const {
    return GetSchemaValue<float>(m_ptr, "CRagdollProp", "m_flDefaultFadeScale");
}
void GCRagdollProp::SetDefaultFadeScale(float value) {
    SetSchemaValue(m_ptr, "CRagdollProp", "m_flDefaultFadeScale", false, value);
}
std::vector<Vector> GCRagdollProp::GetRagdollMins() const {
    CUtlVector<Vector>* vec = GetSchemaValue<CUtlVector<Vector>*>(m_ptr, "CRagdollProp", "m_ragdollMins"); std::vector<Vector> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCRagdollProp::SetRagdollMins(std::vector<Vector> value) {
    SetSchemaValueCUtlVector<Vector>(m_ptr, "CRagdollProp", "m_ragdollMins", false, value);
}
std::vector<Vector> GCRagdollProp::GetRagdollMaxs() const {
    CUtlVector<Vector>* vec = GetSchemaValue<CUtlVector<Vector>*>(m_ptr, "CRagdollProp", "m_ragdollMaxs"); std::vector<Vector> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCRagdollProp::SetRagdollMaxs(std::vector<Vector> value) {
    SetSchemaValueCUtlVector<Vector>(m_ptr, "CRagdollProp", "m_ragdollMaxs", false, value);
}
bool GCRagdollProp::GetShouldDeleteActivationRecord() const {
    return GetSchemaValue<bool>(m_ptr, "CRagdollProp", "m_bShouldDeleteActivationRecord");
}
void GCRagdollProp::SetShouldDeleteActivationRecord(bool value) {
    SetSchemaValue(m_ptr, "CRagdollProp", "m_bShouldDeleteActivationRecord", false, value);
}
bool GCRagdollProp::GetValidatePoweredRagdollPose() const {
    return GetSchemaValue<bool>(m_ptr, "CRagdollProp", "m_bValidatePoweredRagdollPose");
}
void GCRagdollProp::SetValidatePoweredRagdollPose(bool value) {
    SetSchemaValue(m_ptr, "CRagdollProp", "m_bValidatePoweredRagdollPose", false, value);
}
std::string GCRagdollProp::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCRagdollProp::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseAnimGraph GCRagdollProp::GetParent() const {
    GCBaseAnimGraph value(m_ptr);
    return value;
}
void GCRagdollProp::SetParent(GCBaseAnimGraph value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCRagdollProp(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCRagdollProp>("CRagdollProp")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Ragdoll", &GCRagdollProp::GetRagdoll, &GCRagdollProp::SetRagdoll)
        .addProperty("StartDisabled", &GCRagdollProp::GetStartDisabled, &GCRagdollProp::SetStartDisabled)
        .addProperty("RagPos", &GCRagdollProp::GetRagPos, &GCRagdollProp::SetRagPos)
        .addProperty("RagAngles", &GCRagdollProp::GetRagAngles, &GCRagdollProp::SetRagAngles)
        .addProperty("RagdollSource", &GCRagdollProp::GetRagdollSource, &GCRagdollProp::SetRagdollSource)
        .addProperty("LastUpdateTickCount", &GCRagdollProp::GetLastUpdateTickCount, &GCRagdollProp::SetLastUpdateTickCount)
        .addProperty("AllAsleep", &GCRagdollProp::GetAllAsleep, &GCRagdollProp::SetAllAsleep)
        .addProperty("FirstCollisionAfterLaunch", &GCRagdollProp::GetFirstCollisionAfterLaunch, &GCRagdollProp::SetFirstCollisionAfterLaunch)
        .addProperty("DamageEntity", &GCRagdollProp::GetDamageEntity, &GCRagdollProp::SetDamageEntity)
        .addProperty("Killer", &GCRagdollProp::GetKiller, &GCRagdollProp::SetKiller)
        .addProperty("PhysicsAttacker", &GCRagdollProp::GetPhysicsAttacker, &GCRagdollProp::SetPhysicsAttacker)
        .addProperty("LastPhysicsInfluenceTime", &GCRagdollProp::GetLastPhysicsInfluenceTime, &GCRagdollProp::SetLastPhysicsInfluenceTime)
        .addProperty("FadeOutStartTime", &GCRagdollProp::GetFadeOutStartTime, &GCRagdollProp::SetFadeOutStartTime)
        .addProperty("FadeTime", &GCRagdollProp::GetFadeTime, &GCRagdollProp::SetFadeTime)
        .addProperty("LastOrigin", &GCRagdollProp::GetLastOrigin, &GCRagdollProp::SetLastOrigin)
        .addProperty("AwakeTime", &GCRagdollProp::GetAwakeTime, &GCRagdollProp::SetAwakeTime)
        .addProperty("LastOriginChangeTime", &GCRagdollProp::GetLastOriginChangeTime, &GCRagdollProp::SetLastOriginChangeTime)
        .addProperty("StrOriginClassName", &GCRagdollProp::GetStrOriginClassName, &GCRagdollProp::SetStrOriginClassName)
        .addProperty("StrSourceClassName", &GCRagdollProp::GetStrSourceClassName, &GCRagdollProp::SetStrSourceClassName)
        .addProperty("HasBeenPhysgunned", &GCRagdollProp::GetHasBeenPhysgunned, &GCRagdollProp::SetHasBeenPhysgunned)
        .addProperty("ShouldTeleportPhysics", &GCRagdollProp::GetShouldTeleportPhysics, &GCRagdollProp::SetShouldTeleportPhysics)
        .addProperty("BlendWeight", &GCRagdollProp::GetBlendWeight, &GCRagdollProp::SetBlendWeight)
        .addProperty("DefaultFadeScale", &GCRagdollProp::GetDefaultFadeScale, &GCRagdollProp::SetDefaultFadeScale)
        .addProperty("RagdollMins", &GCRagdollProp::GetRagdollMins, &GCRagdollProp::SetRagdollMins)
        .addProperty("RagdollMaxs", &GCRagdollProp::GetRagdollMaxs, &GCRagdollProp::SetRagdollMaxs)
        .addProperty("ShouldDeleteActivationRecord", &GCRagdollProp::GetShouldDeleteActivationRecord, &GCRagdollProp::SetShouldDeleteActivationRecord)
        .addProperty("ValidatePoweredRagdollPose", &GCRagdollProp::GetValidatePoweredRagdollPose, &GCRagdollProp::SetValidatePoweredRagdollPose)
        .addProperty("Parent", &GCRagdollProp::GetParent, &GCRagdollProp::SetParent)
        .addFunction("ToPtr", &GCRagdollProp::ToPtr)
        .addFunction("IsValid", &GCRagdollProp::IsValid)
        .endClass();
}
GCItemSoda::GCItemSoda(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCItemSoda::GCItemSoda(void *ptr) {
    m_ptr = ptr;
}
std::string GCItemSoda::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCItemSoda::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseAnimGraph GCItemSoda::GetParent() const {
    GCBaseAnimGraph value(m_ptr);
    return value;
}
void GCItemSoda::SetParent(GCBaseAnimGraph value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCItemSoda(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCItemSoda>("CItemSoda")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCItemSoda::GetParent, &GCItemSoda::SetParent)
        .addFunction("ToPtr", &GCItemSoda::ToPtr)
        .addFunction("IsValid", &GCItemSoda::IsValid)
        .endClass();
}
GCEnvCubemap::GCEnvCubemap(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCEnvCubemap::GCEnvCubemap(void *ptr) {
    m_ptr = ptr;
}
bool GCEnvCubemap::GetEntity_bCustomCubemapTexture() const {
    return GetSchemaValue<bool>(m_ptr, "CEnvCubemap", "m_Entity_bCustomCubemapTexture");
}
void GCEnvCubemap::SetEntity_bCustomCubemapTexture(bool value) {
    SetSchemaValue(m_ptr, "CEnvCubemap", "m_Entity_bCustomCubemapTexture", false, value);
}
float GCEnvCubemap::GetEntity_flInfluenceRadius() const {
    return GetSchemaValue<float>(m_ptr, "CEnvCubemap", "m_Entity_flInfluenceRadius");
}
void GCEnvCubemap::SetEntity_flInfluenceRadius(float value) {
    SetSchemaValue(m_ptr, "CEnvCubemap", "m_Entity_flInfluenceRadius", false, value);
}
Vector GCEnvCubemap::GetEntity_vBoxProjectMins() const {
    return GetSchemaValue<Vector>(m_ptr, "CEnvCubemap", "m_Entity_vBoxProjectMins");
}
void GCEnvCubemap::SetEntity_vBoxProjectMins(Vector value) {
    SetSchemaValue(m_ptr, "CEnvCubemap", "m_Entity_vBoxProjectMins", false, value);
}
Vector GCEnvCubemap::GetEntity_vBoxProjectMaxs() const {
    return GetSchemaValue<Vector>(m_ptr, "CEnvCubemap", "m_Entity_vBoxProjectMaxs");
}
void GCEnvCubemap::SetEntity_vBoxProjectMaxs(Vector value) {
    SetSchemaValue(m_ptr, "CEnvCubemap", "m_Entity_vBoxProjectMaxs", false, value);
}
bool GCEnvCubemap::GetEntity_bMoveable() const {
    return GetSchemaValue<bool>(m_ptr, "CEnvCubemap", "m_Entity_bMoveable");
}
void GCEnvCubemap::SetEntity_bMoveable(bool value) {
    SetSchemaValue(m_ptr, "CEnvCubemap", "m_Entity_bMoveable", false, value);
}
int32_t GCEnvCubemap::GetEntity_nHandshake() const {
    return GetSchemaValue<int32_t>(m_ptr, "CEnvCubemap", "m_Entity_nHandshake");
}
void GCEnvCubemap::SetEntity_nHandshake(int32_t value) {
    SetSchemaValue(m_ptr, "CEnvCubemap", "m_Entity_nHandshake", false, value);
}
int32_t GCEnvCubemap::GetEntity_nEnvCubeMapArrayIndex() const {
    return GetSchemaValue<int32_t>(m_ptr, "CEnvCubemap", "m_Entity_nEnvCubeMapArrayIndex");
}
void GCEnvCubemap::SetEntity_nEnvCubeMapArrayIndex(int32_t value) {
    SetSchemaValue(m_ptr, "CEnvCubemap", "m_Entity_nEnvCubeMapArrayIndex", false, value);
}
int32_t GCEnvCubemap::GetEntity_nPriority() const {
    return GetSchemaValue<int32_t>(m_ptr, "CEnvCubemap", "m_Entity_nPriority");
}
void GCEnvCubemap::SetEntity_nPriority(int32_t value) {
    SetSchemaValue(m_ptr, "CEnvCubemap", "m_Entity_nPriority", false, value);
}
float GCEnvCubemap::GetEntity_flEdgeFadeDist() const {
    return GetSchemaValue<float>(m_ptr, "CEnvCubemap", "m_Entity_flEdgeFadeDist");
}
void GCEnvCubemap::SetEntity_flEdgeFadeDist(float value) {
    SetSchemaValue(m_ptr, "CEnvCubemap", "m_Entity_flEdgeFadeDist", false, value);
}
Vector GCEnvCubemap::GetEntity_vEdgeFadeDists() const {
    return GetSchemaValue<Vector>(m_ptr, "CEnvCubemap", "m_Entity_vEdgeFadeDists");
}
void GCEnvCubemap::SetEntity_vEdgeFadeDists(Vector value) {
    SetSchemaValue(m_ptr, "CEnvCubemap", "m_Entity_vEdgeFadeDists", false, value);
}
float GCEnvCubemap::GetEntity_flDiffuseScale() const {
    return GetSchemaValue<float>(m_ptr, "CEnvCubemap", "m_Entity_flDiffuseScale");
}
void GCEnvCubemap::SetEntity_flDiffuseScale(float value) {
    SetSchemaValue(m_ptr, "CEnvCubemap", "m_Entity_flDiffuseScale", false, value);
}
bool GCEnvCubemap::GetEntity_bStartDisabled() const {
    return GetSchemaValue<bool>(m_ptr, "CEnvCubemap", "m_Entity_bStartDisabled");
}
void GCEnvCubemap::SetEntity_bStartDisabled(bool value) {
    SetSchemaValue(m_ptr, "CEnvCubemap", "m_Entity_bStartDisabled", false, value);
}
bool GCEnvCubemap::GetEntity_bDefaultEnvMap() const {
    return GetSchemaValue<bool>(m_ptr, "CEnvCubemap", "m_Entity_bDefaultEnvMap");
}
void GCEnvCubemap::SetEntity_bDefaultEnvMap(bool value) {
    SetSchemaValue(m_ptr, "CEnvCubemap", "m_Entity_bDefaultEnvMap", false, value);
}
bool GCEnvCubemap::GetEntity_bDefaultSpecEnvMap() const {
    return GetSchemaValue<bool>(m_ptr, "CEnvCubemap", "m_Entity_bDefaultSpecEnvMap");
}
void GCEnvCubemap::SetEntity_bDefaultSpecEnvMap(bool value) {
    SetSchemaValue(m_ptr, "CEnvCubemap", "m_Entity_bDefaultSpecEnvMap", false, value);
}
bool GCEnvCubemap::GetEntity_bIndoorCubeMap() const {
    return GetSchemaValue<bool>(m_ptr, "CEnvCubemap", "m_Entity_bIndoorCubeMap");
}
void GCEnvCubemap::SetEntity_bIndoorCubeMap(bool value) {
    SetSchemaValue(m_ptr, "CEnvCubemap", "m_Entity_bIndoorCubeMap", false, value);
}
bool GCEnvCubemap::GetEntity_bCopyDiffuseFromDefaultCubemap() const {
    return GetSchemaValue<bool>(m_ptr, "CEnvCubemap", "m_Entity_bCopyDiffuseFromDefaultCubemap");
}
void GCEnvCubemap::SetEntity_bCopyDiffuseFromDefaultCubemap(bool value) {
    SetSchemaValue(m_ptr, "CEnvCubemap", "m_Entity_bCopyDiffuseFromDefaultCubemap", false, value);
}
bool GCEnvCubemap::GetEntity_bEnabled() const {
    return GetSchemaValue<bool>(m_ptr, "CEnvCubemap", "m_Entity_bEnabled");
}
void GCEnvCubemap::SetEntity_bEnabled(bool value) {
    SetSchemaValue(m_ptr, "CEnvCubemap", "m_Entity_bEnabled", false, value);
}
std::string GCEnvCubemap::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCEnvCubemap::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseEntity GCEnvCubemap::GetParent() const {
    GCBaseEntity value(m_ptr);
    return value;
}
void GCEnvCubemap::SetParent(GCBaseEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCEnvCubemap(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCEnvCubemap>("CEnvCubemap")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Entity_bCustomCubemapTexture", &GCEnvCubemap::GetEntity_bCustomCubemapTexture, &GCEnvCubemap::SetEntity_bCustomCubemapTexture)
        .addProperty("Entity_flInfluenceRadius", &GCEnvCubemap::GetEntity_flInfluenceRadius, &GCEnvCubemap::SetEntity_flInfluenceRadius)
        .addProperty("Entity_vBoxProjectMins", &GCEnvCubemap::GetEntity_vBoxProjectMins, &GCEnvCubemap::SetEntity_vBoxProjectMins)
        .addProperty("Entity_vBoxProjectMaxs", &GCEnvCubemap::GetEntity_vBoxProjectMaxs, &GCEnvCubemap::SetEntity_vBoxProjectMaxs)
        .addProperty("Entity_bMoveable", &GCEnvCubemap::GetEntity_bMoveable, &GCEnvCubemap::SetEntity_bMoveable)
        .addProperty("Entity_nHandshake", &GCEnvCubemap::GetEntity_nHandshake, &GCEnvCubemap::SetEntity_nHandshake)
        .addProperty("Entity_nEnvCubeMapArrayIndex", &GCEnvCubemap::GetEntity_nEnvCubeMapArrayIndex, &GCEnvCubemap::SetEntity_nEnvCubeMapArrayIndex)
        .addProperty("Entity_nPriority", &GCEnvCubemap::GetEntity_nPriority, &GCEnvCubemap::SetEntity_nPriority)
        .addProperty("Entity_flEdgeFadeDist", &GCEnvCubemap::GetEntity_flEdgeFadeDist, &GCEnvCubemap::SetEntity_flEdgeFadeDist)
        .addProperty("Entity_vEdgeFadeDists", &GCEnvCubemap::GetEntity_vEdgeFadeDists, &GCEnvCubemap::SetEntity_vEdgeFadeDists)
        .addProperty("Entity_flDiffuseScale", &GCEnvCubemap::GetEntity_flDiffuseScale, &GCEnvCubemap::SetEntity_flDiffuseScale)
        .addProperty("Entity_bStartDisabled", &GCEnvCubemap::GetEntity_bStartDisabled, &GCEnvCubemap::SetEntity_bStartDisabled)
        .addProperty("Entity_bDefaultEnvMap", &GCEnvCubemap::GetEntity_bDefaultEnvMap, &GCEnvCubemap::SetEntity_bDefaultEnvMap)
        .addProperty("Entity_bDefaultSpecEnvMap", &GCEnvCubemap::GetEntity_bDefaultSpecEnvMap, &GCEnvCubemap::SetEntity_bDefaultSpecEnvMap)
        .addProperty("Entity_bIndoorCubeMap", &GCEnvCubemap::GetEntity_bIndoorCubeMap, &GCEnvCubemap::SetEntity_bIndoorCubeMap)
        .addProperty("Entity_bCopyDiffuseFromDefaultCubemap", &GCEnvCubemap::GetEntity_bCopyDiffuseFromDefaultCubemap, &GCEnvCubemap::SetEntity_bCopyDiffuseFromDefaultCubemap)
        .addProperty("Entity_bEnabled", &GCEnvCubemap::GetEntity_bEnabled, &GCEnvCubemap::SetEntity_bEnabled)
        .addProperty("Parent", &GCEnvCubemap::GetParent, &GCEnvCubemap::SetParent)
        .addFunction("ToPtr", &GCEnvCubemap::ToPtr)
        .addFunction("IsValid", &GCEnvCubemap::IsValid)
        .endClass();
}
GCBasePlayerControllerAPI::GCBasePlayerControllerAPI(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCBasePlayerControllerAPI::GCBasePlayerControllerAPI(void *ptr) {
    m_ptr = ptr;
}
std::string GCBasePlayerControllerAPI::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCBasePlayerControllerAPI::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCBasePlayerControllerAPI(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCBasePlayerControllerAPI>("CBasePlayerControllerAPI")
        .addConstructor<void (*)(std::string)>()
        .addFunction("ToPtr", &GCBasePlayerControllerAPI::ToPtr)
        .addFunction("IsValid", &GCBasePlayerControllerAPI::IsValid)
        .endClass();
}
GCCSPointScriptExtensions_CCSWeaponBaseVData::GCCSPointScriptExtensions_CCSWeaponBaseVData(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCCSPointScriptExtensions_CCSWeaponBaseVData::GCCSPointScriptExtensions_CCSWeaponBaseVData(void *ptr) {
    m_ptr = ptr;
}
std::string GCCSPointScriptExtensions_CCSWeaponBaseVData::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCCSPointScriptExtensions_CCSWeaponBaseVData::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCCSPointScriptExtensions_CCSWeaponBaseVData(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCCSPointScriptExtensions_CCSWeaponBaseVData>("CCSPointScriptExtensions_CCSWeaponBaseVData")
        .addConstructor<void (*)(std::string)>()
        .addFunction("ToPtr", &GCCSPointScriptExtensions_CCSWeaponBaseVData::ToPtr)
        .addFunction("IsValid", &GCCSPointScriptExtensions_CCSWeaponBaseVData::IsValid)
        .endClass();
}
GCEnvDetailController::GCEnvDetailController(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCEnvDetailController::GCEnvDetailController(void *ptr) {
    m_ptr = ptr;
}
float GCEnvDetailController::GetFadeStartDist() const {
    return GetSchemaValue<float>(m_ptr, "CEnvDetailController", "m_flFadeStartDist");
}
void GCEnvDetailController::SetFadeStartDist(float value) {
    SetSchemaValue(m_ptr, "CEnvDetailController", "m_flFadeStartDist", false, value);
}
float GCEnvDetailController::GetFadeEndDist() const {
    return GetSchemaValue<float>(m_ptr, "CEnvDetailController", "m_flFadeEndDist");
}
void GCEnvDetailController::SetFadeEndDist(float value) {
    SetSchemaValue(m_ptr, "CEnvDetailController", "m_flFadeEndDist", false, value);
}
std::string GCEnvDetailController::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCEnvDetailController::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseEntity GCEnvDetailController::GetParent() const {
    GCBaseEntity value(m_ptr);
    return value;
}
void GCEnvDetailController::SetParent(GCBaseEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCEnvDetailController(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCEnvDetailController>("CEnvDetailController")
        .addConstructor<void (*)(std::string)>()
        .addProperty("FadeStartDist", &GCEnvDetailController::GetFadeStartDist, &GCEnvDetailController::SetFadeStartDist)
        .addProperty("FadeEndDist", &GCEnvDetailController::GetFadeEndDist, &GCEnvDetailController::SetFadeEndDist)
        .addProperty("Parent", &GCEnvDetailController::GetParent, &GCEnvDetailController::SetParent)
        .addFunction("ToPtr", &GCEnvDetailController::ToPtr)
        .addFunction("IsValid", &GCEnvDetailController::IsValid)
        .endClass();
}
GCTriggerOnce::GCTriggerOnce(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCTriggerOnce::GCTriggerOnce(void *ptr) {
    m_ptr = ptr;
}
std::string GCTriggerOnce::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCTriggerOnce::IsValid() {
    return (m_ptr != nullptr);
}
GCTriggerMultiple GCTriggerOnce::GetParent() const {
    GCTriggerMultiple value(m_ptr);
    return value;
}
void GCTriggerOnce::SetParent(GCTriggerMultiple value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCTriggerOnce(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCTriggerOnce>("CTriggerOnce")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCTriggerOnce::GetParent, &GCTriggerOnce::SetParent)
        .addFunction("ToPtr", &GCTriggerOnce::ToPtr)
        .addFunction("IsValid", &GCTriggerOnce::IsValid)
        .endClass();
}
GCInfoTeleportDestination::GCInfoTeleportDestination(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCInfoTeleportDestination::GCInfoTeleportDestination(void *ptr) {
    m_ptr = ptr;
}
std::string GCInfoTeleportDestination::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCInfoTeleportDestination::IsValid() {
    return (m_ptr != nullptr);
}
GCPointEntity GCInfoTeleportDestination::GetParent() const {
    GCPointEntity value(m_ptr);
    return value;
}
void GCInfoTeleportDestination::SetParent(GCPointEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCInfoTeleportDestination(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCInfoTeleportDestination>("CInfoTeleportDestination")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCInfoTeleportDestination::GetParent, &GCInfoTeleportDestination::SetParent)
        .addFunction("ToPtr", &GCInfoTeleportDestination::ToPtr)
        .addFunction("IsValid", &GCInfoTeleportDestination::IsValid)
        .endClass();
}
GCMathRemap::GCMathRemap(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCMathRemap::GCMathRemap(void *ptr) {
    m_ptr = ptr;
}
float GCMathRemap::GetInMin() const {
    return GetSchemaValue<float>(m_ptr, "CMathRemap", "m_flInMin");
}
void GCMathRemap::SetInMin(float value) {
    SetSchemaValue(m_ptr, "CMathRemap", "m_flInMin", false, value);
}
float GCMathRemap::GetInMax() const {
    return GetSchemaValue<float>(m_ptr, "CMathRemap", "m_flInMax");
}
void GCMathRemap::SetInMax(float value) {
    SetSchemaValue(m_ptr, "CMathRemap", "m_flInMax", false, value);
}
float GCMathRemap::GetOut1() const {
    return GetSchemaValue<float>(m_ptr, "CMathRemap", "m_flOut1");
}
void GCMathRemap::SetOut1(float value) {
    SetSchemaValue(m_ptr, "CMathRemap", "m_flOut1", false, value);
}
float GCMathRemap::GetOut2() const {
    return GetSchemaValue<float>(m_ptr, "CMathRemap", "m_flOut2");
}
void GCMathRemap::SetOut2(float value) {
    SetSchemaValue(m_ptr, "CMathRemap", "m_flOut2", false, value);
}
float GCMathRemap::GetOldInValue() const {
    return GetSchemaValue<float>(m_ptr, "CMathRemap", "m_flOldInValue");
}
void GCMathRemap::SetOldInValue(float value) {
    SetSchemaValue(m_ptr, "CMathRemap", "m_flOldInValue", false, value);
}
bool GCMathRemap::GetEnabled() const {
    return GetSchemaValue<bool>(m_ptr, "CMathRemap", "m_bEnabled");
}
void GCMathRemap::SetEnabled(bool value) {
    SetSchemaValue(m_ptr, "CMathRemap", "m_bEnabled", false, value);
}
GCEntityIOOutput GCMathRemap::GetOnRoseAboveMin() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CMathRemap", "m_OnRoseAboveMin"));
    return value;
}
void GCMathRemap::SetOnRoseAboveMin(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CMathRemap", "m_OnRoseAboveMin", false, value);
}
GCEntityIOOutput GCMathRemap::GetOnRoseAboveMax() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CMathRemap", "m_OnRoseAboveMax"));
    return value;
}
void GCMathRemap::SetOnRoseAboveMax(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CMathRemap", "m_OnRoseAboveMax", false, value);
}
GCEntityIOOutput GCMathRemap::GetOnFellBelowMin() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CMathRemap", "m_OnFellBelowMin"));
    return value;
}
void GCMathRemap::SetOnFellBelowMin(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CMathRemap", "m_OnFellBelowMin", false, value);
}
GCEntityIOOutput GCMathRemap::GetOnFellBelowMax() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CMathRemap", "m_OnFellBelowMax"));
    return value;
}
void GCMathRemap::SetOnFellBelowMax(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CMathRemap", "m_OnFellBelowMax", false, value);
}
std::string GCMathRemap::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCMathRemap::IsValid() {
    return (m_ptr != nullptr);
}
GCLogicalEntity GCMathRemap::GetParent() const {
    GCLogicalEntity value(m_ptr);
    return value;
}
void GCMathRemap::SetParent(GCLogicalEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCMathRemap(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCMathRemap>("CMathRemap")
        .addConstructor<void (*)(std::string)>()
        .addProperty("InMin", &GCMathRemap::GetInMin, &GCMathRemap::SetInMin)
        .addProperty("InMax", &GCMathRemap::GetInMax, &GCMathRemap::SetInMax)
        .addProperty("Out1", &GCMathRemap::GetOut1, &GCMathRemap::SetOut1)
        .addProperty("Out2", &GCMathRemap::GetOut2, &GCMathRemap::SetOut2)
        .addProperty("OldInValue", &GCMathRemap::GetOldInValue, &GCMathRemap::SetOldInValue)
        .addProperty("Enabled", &GCMathRemap::GetEnabled, &GCMathRemap::SetEnabled)
        .addProperty("OnRoseAboveMin", &GCMathRemap::GetOnRoseAboveMin, &GCMathRemap::SetOnRoseAboveMin)
        .addProperty("OnRoseAboveMax", &GCMathRemap::GetOnRoseAboveMax, &GCMathRemap::SetOnRoseAboveMax)
        .addProperty("OnFellBelowMin", &GCMathRemap::GetOnFellBelowMin, &GCMathRemap::SetOnFellBelowMin)
        .addProperty("OnFellBelowMax", &GCMathRemap::GetOnFellBelowMax, &GCMathRemap::SetOnFellBelowMax)
        .addProperty("Parent", &GCMathRemap::GetParent, &GCMathRemap::SetParent)
        .addFunction("ToPtr", &GCMathRemap::ToPtr)
        .addFunction("IsValid", &GCMathRemap::IsValid)
        .endClass();
}
GCInstructorEventEntity::GCInstructorEventEntity(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCInstructorEventEntity::GCInstructorEventEntity(void *ptr) {
    m_ptr = ptr;
}
std::string GCInstructorEventEntity::GetName() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CInstructorEventEntity", "m_iszName").String();
}
void GCInstructorEventEntity::SetName(std::string value) {
    SetSchemaValue(m_ptr, "CInstructorEventEntity", "m_iszName", false, CUtlSymbolLarge(value.c_str()));
}
std::string GCInstructorEventEntity::GetHintTargetEntity() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CInstructorEventEntity", "m_iszHintTargetEntity").String();
}
void GCInstructorEventEntity::SetHintTargetEntity(std::string value) {
    SetSchemaValue(m_ptr, "CInstructorEventEntity", "m_iszHintTargetEntity", false, CUtlSymbolLarge(value.c_str()));
}
GCBasePlayerPawn GCInstructorEventEntity::GetTargetPlayer() const {
    GCBasePlayerPawn value(*GetSchemaValuePtr<void*>(m_ptr, "CInstructorEventEntity", "m_hTargetPlayer"));
    return value;
}
void GCInstructorEventEntity::SetTargetPlayer(GCBasePlayerPawn* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'TargetPlayer' is not possible.\n");
}
std::string GCInstructorEventEntity::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCInstructorEventEntity::IsValid() {
    return (m_ptr != nullptr);
}
GCPointEntity GCInstructorEventEntity::GetParent() const {
    GCPointEntity value(m_ptr);
    return value;
}
void GCInstructorEventEntity::SetParent(GCPointEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCInstructorEventEntity(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCInstructorEventEntity>("CInstructorEventEntity")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Name", &GCInstructorEventEntity::GetName, &GCInstructorEventEntity::SetName)
        .addProperty("HintTargetEntity", &GCInstructorEventEntity::GetHintTargetEntity, &GCInstructorEventEntity::SetHintTargetEntity)
        .addProperty("TargetPlayer", &GCInstructorEventEntity::GetTargetPlayer, &GCInstructorEventEntity::SetTargetPlayer)
        .addProperty("Parent", &GCInstructorEventEntity::GetParent, &GCInstructorEventEntity::SetParent)
        .addFunction("ToPtr", &GCInstructorEventEntity::ToPtr)
        .addFunction("IsValid", &GCInstructorEventEntity::IsValid)
        .endClass();
}
GCGradientFog::GCGradientFog(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCGradientFog::GCGradientFog(void *ptr) {
    m_ptr = ptr;
}
float GCGradientFog::GetFogStartDistance() const {
    return GetSchemaValue<float>(m_ptr, "CGradientFog", "m_flFogStartDistance");
}
void GCGradientFog::SetFogStartDistance(float value) {
    SetSchemaValue(m_ptr, "CGradientFog", "m_flFogStartDistance", false, value);
}
float GCGradientFog::GetFogEndDistance() const {
    return GetSchemaValue<float>(m_ptr, "CGradientFog", "m_flFogEndDistance");
}
void GCGradientFog::SetFogEndDistance(float value) {
    SetSchemaValue(m_ptr, "CGradientFog", "m_flFogEndDistance", false, value);
}
bool GCGradientFog::GetHeightFogEnabled() const {
    return GetSchemaValue<bool>(m_ptr, "CGradientFog", "m_bHeightFogEnabled");
}
void GCGradientFog::SetHeightFogEnabled(bool value) {
    SetSchemaValue(m_ptr, "CGradientFog", "m_bHeightFogEnabled", false, value);
}
float GCGradientFog::GetFogStartHeight() const {
    return GetSchemaValue<float>(m_ptr, "CGradientFog", "m_flFogStartHeight");
}
void GCGradientFog::SetFogStartHeight(float value) {
    SetSchemaValue(m_ptr, "CGradientFog", "m_flFogStartHeight", false, value);
}
float GCGradientFog::GetFogEndHeight() const {
    return GetSchemaValue<float>(m_ptr, "CGradientFog", "m_flFogEndHeight");
}
void GCGradientFog::SetFogEndHeight(float value) {
    SetSchemaValue(m_ptr, "CGradientFog", "m_flFogEndHeight", false, value);
}
float GCGradientFog::GetFarZ() const {
    return GetSchemaValue<float>(m_ptr, "CGradientFog", "m_flFarZ");
}
void GCGradientFog::SetFarZ(float value) {
    SetSchemaValue(m_ptr, "CGradientFog", "m_flFarZ", false, value);
}
float GCGradientFog::GetFogMaxOpacity() const {
    return GetSchemaValue<float>(m_ptr, "CGradientFog", "m_flFogMaxOpacity");
}
void GCGradientFog::SetFogMaxOpacity(float value) {
    SetSchemaValue(m_ptr, "CGradientFog", "m_flFogMaxOpacity", false, value);
}
float GCGradientFog::GetFogFalloffExponent() const {
    return GetSchemaValue<float>(m_ptr, "CGradientFog", "m_flFogFalloffExponent");
}
void GCGradientFog::SetFogFalloffExponent(float value) {
    SetSchemaValue(m_ptr, "CGradientFog", "m_flFogFalloffExponent", false, value);
}
float GCGradientFog::GetFogVerticalExponent() const {
    return GetSchemaValue<float>(m_ptr, "CGradientFog", "m_flFogVerticalExponent");
}
void GCGradientFog::SetFogVerticalExponent(float value) {
    SetSchemaValue(m_ptr, "CGradientFog", "m_flFogVerticalExponent", false, value);
}
Color GCGradientFog::GetFogColor() const {
    return GetSchemaValue<Color>(m_ptr, "CGradientFog", "m_fogColor");
}
void GCGradientFog::SetFogColor(Color value) {
    SetSchemaValue(m_ptr, "CGradientFog", "m_fogColor", false, value);
}
float GCGradientFog::GetFogStrength() const {
    return GetSchemaValue<float>(m_ptr, "CGradientFog", "m_flFogStrength");
}
void GCGradientFog::SetFogStrength(float value) {
    SetSchemaValue(m_ptr, "CGradientFog", "m_flFogStrength", false, value);
}
float GCGradientFog::GetFadeTime() const {
    return GetSchemaValue<float>(m_ptr, "CGradientFog", "m_flFadeTime");
}
void GCGradientFog::SetFadeTime(float value) {
    SetSchemaValue(m_ptr, "CGradientFog", "m_flFadeTime", false, value);
}
bool GCGradientFog::GetStartDisabled() const {
    return GetSchemaValue<bool>(m_ptr, "CGradientFog", "m_bStartDisabled");
}
void GCGradientFog::SetStartDisabled(bool value) {
    SetSchemaValue(m_ptr, "CGradientFog", "m_bStartDisabled", false, value);
}
bool GCGradientFog::GetIsEnabled() const {
    return GetSchemaValue<bool>(m_ptr, "CGradientFog", "m_bIsEnabled");
}
void GCGradientFog::SetIsEnabled(bool value) {
    SetSchemaValue(m_ptr, "CGradientFog", "m_bIsEnabled", false, value);
}
bool GCGradientFog::GetGradientFogNeedsTextures() const {
    return GetSchemaValue<bool>(m_ptr, "CGradientFog", "m_bGradientFogNeedsTextures");
}
void GCGradientFog::SetGradientFogNeedsTextures(bool value) {
    SetSchemaValue(m_ptr, "CGradientFog", "m_bGradientFogNeedsTextures", false, value);
}
std::string GCGradientFog::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCGradientFog::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseEntity GCGradientFog::GetParent() const {
    GCBaseEntity value(m_ptr);
    return value;
}
void GCGradientFog::SetParent(GCBaseEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCGradientFog(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCGradientFog>("CGradientFog")
        .addConstructor<void (*)(std::string)>()
        .addProperty("FogStartDistance", &GCGradientFog::GetFogStartDistance, &GCGradientFog::SetFogStartDistance)
        .addProperty("FogEndDistance", &GCGradientFog::GetFogEndDistance, &GCGradientFog::SetFogEndDistance)
        .addProperty("HeightFogEnabled", &GCGradientFog::GetHeightFogEnabled, &GCGradientFog::SetHeightFogEnabled)
        .addProperty("FogStartHeight", &GCGradientFog::GetFogStartHeight, &GCGradientFog::SetFogStartHeight)
        .addProperty("FogEndHeight", &GCGradientFog::GetFogEndHeight, &GCGradientFog::SetFogEndHeight)
        .addProperty("FarZ", &GCGradientFog::GetFarZ, &GCGradientFog::SetFarZ)
        .addProperty("FogMaxOpacity", &GCGradientFog::GetFogMaxOpacity, &GCGradientFog::SetFogMaxOpacity)
        .addProperty("FogFalloffExponent", &GCGradientFog::GetFogFalloffExponent, &GCGradientFog::SetFogFalloffExponent)
        .addProperty("FogVerticalExponent", &GCGradientFog::GetFogVerticalExponent, &GCGradientFog::SetFogVerticalExponent)
        .addProperty("FogColor", &GCGradientFog::GetFogColor, &GCGradientFog::SetFogColor)
        .addProperty("FogStrength", &GCGradientFog::GetFogStrength, &GCGradientFog::SetFogStrength)
        .addProperty("FadeTime", &GCGradientFog::GetFadeTime, &GCGradientFog::SetFadeTime)
        .addProperty("StartDisabled", &GCGradientFog::GetStartDisabled, &GCGradientFog::SetStartDisabled)
        .addProperty("IsEnabled", &GCGradientFog::GetIsEnabled, &GCGradientFog::SetIsEnabled)
        .addProperty("GradientFogNeedsTextures", &GCGradientFog::GetGradientFogNeedsTextures, &GCGradientFog::SetGradientFogNeedsTextures)
        .addProperty("Parent", &GCGradientFog::GetParent, &GCGradientFog::SetParent)
        .addFunction("ToPtr", &GCGradientFog::ToPtr)
        .addFunction("IsValid", &GCGradientFog::IsValid)
        .endClass();
}
GCFootstepControl::GCFootstepControl(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCFootstepControl::GCFootstepControl(void *ptr) {
    m_ptr = ptr;
}
std::string GCFootstepControl::GetSource() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CFootstepControl", "m_source").String();
}
void GCFootstepControl::SetSource(std::string value) {
    SetSchemaValue(m_ptr, "CFootstepControl", "m_source", false, CUtlSymbolLarge(value.c_str()));
}
std::string GCFootstepControl::GetDestination() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CFootstepControl", "m_destination").String();
}
void GCFootstepControl::SetDestination(std::string value) {
    SetSchemaValue(m_ptr, "CFootstepControl", "m_destination", false, CUtlSymbolLarge(value.c_str()));
}
std::string GCFootstepControl::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCFootstepControl::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseTrigger GCFootstepControl::GetParent() const {
    GCBaseTrigger value(m_ptr);
    return value;
}
void GCFootstepControl::SetParent(GCBaseTrigger value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCFootstepControl(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCFootstepControl>("CFootstepControl")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Source", &GCFootstepControl::GetSource, &GCFootstepControl::SetSource)
        .addProperty("Destination", &GCFootstepControl::GetDestination, &GCFootstepControl::SetDestination)
        .addProperty("Parent", &GCFootstepControl::GetParent, &GCFootstepControl::SetParent)
        .addFunction("ToPtr", &GCFootstepControl::ToPtr)
        .addFunction("IsValid", &GCFootstepControl::IsValid)
        .endClass();
}
GCTriggerVolume::GCTriggerVolume(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCTriggerVolume::GCTriggerVolume(void *ptr) {
    m_ptr = ptr;
}
std::string GCTriggerVolume::GetFilterName() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CTriggerVolume", "m_iFilterName").String();
}
void GCTriggerVolume::SetFilterName(std::string value) {
    SetSchemaValue(m_ptr, "CTriggerVolume", "m_iFilterName", false, CUtlSymbolLarge(value.c_str()));
}
GCBaseFilter GCTriggerVolume::GetFilter() const {
    GCBaseFilter value(*GetSchemaValuePtr<void*>(m_ptr, "CTriggerVolume", "m_hFilter"));
    return value;
}
void GCTriggerVolume::SetFilter(GCBaseFilter* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Filter' is not possible.\n");
}
std::string GCTriggerVolume::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCTriggerVolume::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseModelEntity GCTriggerVolume::GetParent() const {
    GCBaseModelEntity value(m_ptr);
    return value;
}
void GCTriggerVolume::SetParent(GCBaseModelEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCTriggerVolume(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCTriggerVolume>("CTriggerVolume")
        .addConstructor<void (*)(std::string)>()
        .addProperty("FilterName", &GCTriggerVolume::GetFilterName, &GCTriggerVolume::SetFilterName)
        .addProperty("Filter", &GCTriggerVolume::GetFilter, &GCTriggerVolume::SetFilter)
        .addProperty("Parent", &GCTriggerVolume::GetParent, &GCTriggerVolume::SetParent)
        .addFunction("ToPtr", &GCTriggerVolume::ToPtr)
        .addFunction("IsValid", &GCTriggerVolume::IsValid)
        .endClass();
}
GCInfoInstructorHintHostageRescueZone::GCInfoInstructorHintHostageRescueZone(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCInfoInstructorHintHostageRescueZone::GCInfoInstructorHintHostageRescueZone(void *ptr) {
    m_ptr = ptr;
}
std::string GCInfoInstructorHintHostageRescueZone::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCInfoInstructorHintHostageRescueZone::IsValid() {
    return (m_ptr != nullptr);
}
GCPointEntity GCInfoInstructorHintHostageRescueZone::GetParent() const {
    GCPointEntity value(m_ptr);
    return value;
}
void GCInfoInstructorHintHostageRescueZone::SetParent(GCPointEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCInfoInstructorHintHostageRescueZone(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCInfoInstructorHintHostageRescueZone>("CInfoInstructorHintHostageRescueZone")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCInfoInstructorHintHostageRescueZone::GetParent, &GCInfoInstructorHintHostageRescueZone::SetParent)
        .addFunction("ToPtr", &GCInfoInstructorHintHostageRescueZone::ToPtr)
        .addFunction("IsValid", &GCInfoInstructorHintHostageRescueZone::IsValid)
        .endClass();
}
GCEnvSoundscapeAlias_snd_soundscape::GCEnvSoundscapeAlias_snd_soundscape(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCEnvSoundscapeAlias_snd_soundscape::GCEnvSoundscapeAlias_snd_soundscape(void *ptr) {
    m_ptr = ptr;
}
std::string GCEnvSoundscapeAlias_snd_soundscape::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCEnvSoundscapeAlias_snd_soundscape::IsValid() {
    return (m_ptr != nullptr);
}
GCEnvSoundscape GCEnvSoundscapeAlias_snd_soundscape::GetParent() const {
    GCEnvSoundscape value(m_ptr);
    return value;
}
void GCEnvSoundscapeAlias_snd_soundscape::SetParent(GCEnvSoundscape value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCEnvSoundscapeAlias_snd_soundscape(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCEnvSoundscapeAlias_snd_soundscape>("CEnvSoundscapeAlias_snd_soundscape")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCEnvSoundscapeAlias_snd_soundscape::GetParent, &GCEnvSoundscapeAlias_snd_soundscape::SetParent)
        .addFunction("ToPtr", &GCEnvSoundscapeAlias_snd_soundscape::ToPtr)
        .addFunction("IsValid", &GCEnvSoundscapeAlias_snd_soundscape::IsValid)
        .endClass();
}
GCFishPool::GCFishPool(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCFishPool::GCFishPool(void *ptr) {
    m_ptr = ptr;
}
int32_t GCFishPool::GetFishCount() const {
    return GetSchemaValue<int32_t>(m_ptr, "CFishPool", "m_fishCount");
}
void GCFishPool::SetFishCount(int32_t value) {
    SetSchemaValue(m_ptr, "CFishPool", "m_fishCount", false, value);
}
float GCFishPool::GetMaxRange() const {
    return GetSchemaValue<float>(m_ptr, "CFishPool", "m_maxRange");
}
void GCFishPool::SetMaxRange(float value) {
    SetSchemaValue(m_ptr, "CFishPool", "m_maxRange", false, value);
}
float GCFishPool::GetSwimDepth() const {
    return GetSchemaValue<float>(m_ptr, "CFishPool", "m_swimDepth");
}
void GCFishPool::SetSwimDepth(float value) {
    SetSchemaValue(m_ptr, "CFishPool", "m_swimDepth", false, value);
}
float GCFishPool::GetWaterLevel() const {
    return GetSchemaValue<float>(m_ptr, "CFishPool", "m_waterLevel");
}
void GCFishPool::SetWaterLevel(float value) {
    SetSchemaValue(m_ptr, "CFishPool", "m_waterLevel", false, value);
}
bool GCFishPool::GetIsDormant() const {
    return GetSchemaValue<bool>(m_ptr, "CFishPool", "m_isDormant");
}
void GCFishPool::SetIsDormant(bool value) {
    SetSchemaValue(m_ptr, "CFishPool", "m_isDormant", false, value);
}
GCountdownTimer GCFishPool::GetVisTimer() const {
    GCountdownTimer value(GetSchemaPtr(m_ptr, "CFishPool", "m_visTimer"));
    return value;
}
void GCFishPool::SetVisTimer(GCountdownTimer value) {
    SetSchemaValue(m_ptr, "CFishPool", "m_visTimer", false, value);
}
std::string GCFishPool::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCFishPool::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseEntity GCFishPool::GetParent() const {
    GCBaseEntity value(m_ptr);
    return value;
}
void GCFishPool::SetParent(GCBaseEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCFishPool(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCFishPool>("CFishPool")
        .addConstructor<void (*)(std::string)>()
        .addProperty("FishCount", &GCFishPool::GetFishCount, &GCFishPool::SetFishCount)
        .addProperty("MaxRange", &GCFishPool::GetMaxRange, &GCFishPool::SetMaxRange)
        .addProperty("SwimDepth", &GCFishPool::GetSwimDepth, &GCFishPool::SetSwimDepth)
        .addProperty("WaterLevel", &GCFishPool::GetWaterLevel, &GCFishPool::SetWaterLevel)
        .addProperty("IsDormant", &GCFishPool::GetIsDormant, &GCFishPool::SetIsDormant)
        .addProperty("VisTimer", &GCFishPool::GetVisTimer, &GCFishPool::SetVisTimer)
        .addProperty("Parent", &GCFishPool::GetParent, &GCFishPool::SetParent)
        .addFunction("ToPtr", &GCFishPool::ToPtr)
        .addFunction("IsValid", &GCFishPool::IsValid)
        .endClass();
}
GCPointClientCommand::GCPointClientCommand(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCPointClientCommand::GCPointClientCommand(void *ptr) {
    m_ptr = ptr;
}
std::string GCPointClientCommand::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCPointClientCommand::IsValid() {
    return (m_ptr != nullptr);
}
GCPointEntity GCPointClientCommand::GetParent() const {
    GCPointEntity value(m_ptr);
    return value;
}
void GCPointClientCommand::SetParent(GCPointEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCPointClientCommand(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCPointClientCommand>("CPointClientCommand")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCPointClientCommand::GetParent, &GCPointClientCommand::SetParent)
        .addFunction("ToPtr", &GCPointClientCommand::ToPtr)
        .addFunction("IsValid", &GCPointClientCommand::IsValid)
        .endClass();
}
GCFuncVPhysicsClip::GCFuncVPhysicsClip(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCFuncVPhysicsClip::GCFuncVPhysicsClip(void *ptr) {
    m_ptr = ptr;
}
bool GCFuncVPhysicsClip::GetDisabled() const {
    return GetSchemaValue<bool>(m_ptr, "CFuncVPhysicsClip", "m_bDisabled");
}
void GCFuncVPhysicsClip::SetDisabled(bool value) {
    SetSchemaValue(m_ptr, "CFuncVPhysicsClip", "m_bDisabled", false, value);
}
std::string GCFuncVPhysicsClip::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCFuncVPhysicsClip::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseModelEntity GCFuncVPhysicsClip::GetParent() const {
    GCBaseModelEntity value(m_ptr);
    return value;
}
void GCFuncVPhysicsClip::SetParent(GCBaseModelEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCFuncVPhysicsClip(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCFuncVPhysicsClip>("CFuncVPhysicsClip")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Disabled", &GCFuncVPhysicsClip::GetDisabled, &GCFuncVPhysicsClip::SetDisabled)
        .addProperty("Parent", &GCFuncVPhysicsClip::GetParent, &GCFuncVPhysicsClip::SetParent)
        .addFunction("ToPtr", &GCFuncVPhysicsClip::ToPtr)
        .addFunction("IsValid", &GCFuncVPhysicsClip::IsValid)
        .endClass();
}
GCCSPlayer_RadioServices::GCCSPlayer_RadioServices(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCCSPlayer_RadioServices::GCCSPlayer_RadioServices(void *ptr) {
    m_ptr = ptr;
}
float GCCSPlayer_RadioServices::GetGotHostageTalkTimer() const {
    return GetSchemaValue<float>(m_ptr, "CCSPlayer_RadioServices", "m_flGotHostageTalkTimer");
}
void GCCSPlayer_RadioServices::SetGotHostageTalkTimer(float value) {
    SetSchemaValue(m_ptr, "CCSPlayer_RadioServices", "m_flGotHostageTalkTimer", false, value);
}
float GCCSPlayer_RadioServices::GetDefusingTalkTimer() const {
    return GetSchemaValue<float>(m_ptr, "CCSPlayer_RadioServices", "m_flDefusingTalkTimer");
}
void GCCSPlayer_RadioServices::SetDefusingTalkTimer(float value) {
    SetSchemaValue(m_ptr, "CCSPlayer_RadioServices", "m_flDefusingTalkTimer", false, value);
}
float GCCSPlayer_RadioServices::GetC4PlantTalkTimer() const {
    return GetSchemaValue<float>(m_ptr, "CCSPlayer_RadioServices", "m_flC4PlantTalkTimer");
}
void GCCSPlayer_RadioServices::SetC4PlantTalkTimer(float value) {
    SetSchemaValue(m_ptr, "CCSPlayer_RadioServices", "m_flC4PlantTalkTimer", false, value);
}
std::vector<float> GCCSPlayer_RadioServices::GetRadioTokenSlots() const {
    float* outValue = GetSchemaValue<float*>(m_ptr, "CCSPlayer_RadioServices", "m_flRadioTokenSlots"); std::vector<float> ret; for(int i = 0; i < 3; i++) { ret.push_back(outValue[i]); } return ret;
}
void GCCSPlayer_RadioServices::SetRadioTokenSlots(std::vector<float> value) {
    float* outValue = GetSchemaValue<float*>(m_ptr, "CCSPlayer_RadioServices", "m_flRadioTokenSlots"); for(int i = 0; i < 3; i++) { outValue[i] = value[i]; } SetSchemaValue(m_ptr, "CCSPlayer_RadioServices", "m_flRadioTokenSlots", false, outValue);
}
bool GCCSPlayer_RadioServices::GetIgnoreRadio() const {
    return GetSchemaValue<bool>(m_ptr, "CCSPlayer_RadioServices", "m_bIgnoreRadio");
}
void GCCSPlayer_RadioServices::SetIgnoreRadio(bool value) {
    SetSchemaValue(m_ptr, "CCSPlayer_RadioServices", "m_bIgnoreRadio", false, value);
}
std::string GCCSPlayer_RadioServices::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCCSPlayer_RadioServices::IsValid() {
    return (m_ptr != nullptr);
}
GCPlayerPawnComponent GCCSPlayer_RadioServices::GetParent() const {
    GCPlayerPawnComponent value(m_ptr);
    return value;
}
void GCCSPlayer_RadioServices::SetParent(GCPlayerPawnComponent value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCCSPlayer_RadioServices(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCCSPlayer_RadioServices>("CCSPlayer_RadioServices")
        .addConstructor<void (*)(std::string)>()
        .addProperty("GotHostageTalkTimer", &GCCSPlayer_RadioServices::GetGotHostageTalkTimer, &GCCSPlayer_RadioServices::SetGotHostageTalkTimer)
        .addProperty("DefusingTalkTimer", &GCCSPlayer_RadioServices::GetDefusingTalkTimer, &GCCSPlayer_RadioServices::SetDefusingTalkTimer)
        .addProperty("C4PlantTalkTimer", &GCCSPlayer_RadioServices::GetC4PlantTalkTimer, &GCCSPlayer_RadioServices::SetC4PlantTalkTimer)
        .addProperty("RadioTokenSlots", &GCCSPlayer_RadioServices::GetRadioTokenSlots, &GCCSPlayer_RadioServices::SetRadioTokenSlots)
        .addProperty("IgnoreRadio", &GCCSPlayer_RadioServices::GetIgnoreRadio, &GCCSPlayer_RadioServices::SetIgnoreRadio)
        .addProperty("Parent", &GCCSPlayer_RadioServices::GetParent, &GCCSPlayer_RadioServices::SetParent)
        .addFunction("ToPtr", &GCCSPlayer_RadioServices::ToPtr)
        .addFunction("IsValid", &GCCSPlayer_RadioServices::IsValid)
        .endClass();
}
GCSceneEntity::GCSceneEntity(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCSceneEntity::GCSceneEntity(void *ptr) {
    m_ptr = ptr;
}
std::string GCSceneEntity::GetSceneFile() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CSceneEntity", "m_iszSceneFile").String();
}
void GCSceneEntity::SetSceneFile(std::string value) {
    SetSchemaValue(m_ptr, "CSceneEntity", "m_iszSceneFile", false, CUtlSymbolLarge(value.c_str()));
}
std::string GCSceneEntity::GetResumeSceneFile() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CSceneEntity", "m_iszResumeSceneFile").String();
}
void GCSceneEntity::SetResumeSceneFile(std::string value) {
    SetSchemaValue(m_ptr, "CSceneEntity", "m_iszResumeSceneFile", false, CUtlSymbolLarge(value.c_str()));
}
std::string GCSceneEntity::GetTarget1() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CSceneEntity", "m_iszTarget1").String();
}
void GCSceneEntity::SetTarget1(std::string value) {
    SetSchemaValue(m_ptr, "CSceneEntity", "m_iszTarget1", false, CUtlSymbolLarge(value.c_str()));
}
std::string GCSceneEntity::GetTarget2() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CSceneEntity", "m_iszTarget2").String();
}
void GCSceneEntity::SetTarget2(std::string value) {
    SetSchemaValue(m_ptr, "CSceneEntity", "m_iszTarget2", false, CUtlSymbolLarge(value.c_str()));
}
std::string GCSceneEntity::GetTarget3() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CSceneEntity", "m_iszTarget3").String();
}
void GCSceneEntity::SetTarget3(std::string value) {
    SetSchemaValue(m_ptr, "CSceneEntity", "m_iszTarget3", false, CUtlSymbolLarge(value.c_str()));
}
std::string GCSceneEntity::GetTarget4() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CSceneEntity", "m_iszTarget4").String();
}
void GCSceneEntity::SetTarget4(std::string value) {
    SetSchemaValue(m_ptr, "CSceneEntity", "m_iszTarget4", false, CUtlSymbolLarge(value.c_str()));
}
std::string GCSceneEntity::GetTarget5() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CSceneEntity", "m_iszTarget5").String();
}
void GCSceneEntity::SetTarget5(std::string value) {
    SetSchemaValue(m_ptr, "CSceneEntity", "m_iszTarget5", false, CUtlSymbolLarge(value.c_str()));
}
std::string GCSceneEntity::GetTarget6() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CSceneEntity", "m_iszTarget6").String();
}
void GCSceneEntity::SetTarget6(std::string value) {
    SetSchemaValue(m_ptr, "CSceneEntity", "m_iszTarget6", false, CUtlSymbolLarge(value.c_str()));
}
std::string GCSceneEntity::GetTarget7() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CSceneEntity", "m_iszTarget7").String();
}
void GCSceneEntity::SetTarget7(std::string value) {
    SetSchemaValue(m_ptr, "CSceneEntity", "m_iszTarget7", false, CUtlSymbolLarge(value.c_str()));
}
std::string GCSceneEntity::GetTarget8() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CSceneEntity", "m_iszTarget8").String();
}
void GCSceneEntity::SetTarget8(std::string value) {
    SetSchemaValue(m_ptr, "CSceneEntity", "m_iszTarget8", false, CUtlSymbolLarge(value.c_str()));
}
GCBaseEntity GCSceneEntity::GetTarget11() const {
    GCBaseEntity value(*GetSchemaValuePtr<void*>(m_ptr, "CSceneEntity", "m_hTarget1"));
    return value;
}
void GCSceneEntity::SetTarget11(GCBaseEntity* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Target11' is not possible.\n");
}
GCBaseEntity GCSceneEntity::GetTarget21() const {
    GCBaseEntity value(*GetSchemaValuePtr<void*>(m_ptr, "CSceneEntity", "m_hTarget2"));
    return value;
}
void GCSceneEntity::SetTarget21(GCBaseEntity* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Target21' is not possible.\n");
}
GCBaseEntity GCSceneEntity::GetTarget31() const {
    GCBaseEntity value(*GetSchemaValuePtr<void*>(m_ptr, "CSceneEntity", "m_hTarget3"));
    return value;
}
void GCSceneEntity::SetTarget31(GCBaseEntity* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Target31' is not possible.\n");
}
GCBaseEntity GCSceneEntity::GetTarget41() const {
    GCBaseEntity value(*GetSchemaValuePtr<void*>(m_ptr, "CSceneEntity", "m_hTarget4"));
    return value;
}
void GCSceneEntity::SetTarget41(GCBaseEntity* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Target41' is not possible.\n");
}
GCBaseEntity GCSceneEntity::GetTarget51() const {
    GCBaseEntity value(*GetSchemaValuePtr<void*>(m_ptr, "CSceneEntity", "m_hTarget5"));
    return value;
}
void GCSceneEntity::SetTarget51(GCBaseEntity* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Target51' is not possible.\n");
}
GCBaseEntity GCSceneEntity::GetTarget61() const {
    GCBaseEntity value(*GetSchemaValuePtr<void*>(m_ptr, "CSceneEntity", "m_hTarget6"));
    return value;
}
void GCSceneEntity::SetTarget61(GCBaseEntity* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Target61' is not possible.\n");
}
GCBaseEntity GCSceneEntity::GetTarget71() const {
    GCBaseEntity value(*GetSchemaValuePtr<void*>(m_ptr, "CSceneEntity", "m_hTarget7"));
    return value;
}
void GCSceneEntity::SetTarget71(GCBaseEntity* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Target71' is not possible.\n");
}
GCBaseEntity GCSceneEntity::GetTarget81() const {
    GCBaseEntity value(*GetSchemaValuePtr<void*>(m_ptr, "CSceneEntity", "m_hTarget8"));
    return value;
}
void GCSceneEntity::SetTarget81(GCBaseEntity* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Target81' is not possible.\n");
}
std::string GCSceneEntity::GetTargetAttachment() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CSceneEntity", "m_sTargetAttachment").String();
}
void GCSceneEntity::SetTargetAttachment(std::string value) {
    SetSchemaValue(m_ptr, "CSceneEntity", "m_sTargetAttachment", false, CUtlSymbolLarge(value.c_str()));
}
bool GCSceneEntity::GetIsPlayingBack() const {
    return GetSchemaValue<bool>(m_ptr, "CSceneEntity", "m_bIsPlayingBack");
}
void GCSceneEntity::SetIsPlayingBack(bool value) {
    SetSchemaValue(m_ptr, "CSceneEntity", "m_bIsPlayingBack", false, value);
}
bool GCSceneEntity::GetPaused() const {
    return GetSchemaValue<bool>(m_ptr, "CSceneEntity", "m_bPaused");
}
void GCSceneEntity::SetPaused(bool value) {
    SetSchemaValue(m_ptr, "CSceneEntity", "m_bPaused", false, value);
}
bool GCSceneEntity::GetMultiplayer() const {
    return GetSchemaValue<bool>(m_ptr, "CSceneEntity", "m_bMultiplayer");
}
void GCSceneEntity::SetMultiplayer(bool value) {
    SetSchemaValue(m_ptr, "CSceneEntity", "m_bMultiplayer", false, value);
}
bool GCSceneEntity::GetAutogenerated() const {
    return GetSchemaValue<bool>(m_ptr, "CSceneEntity", "m_bAutogenerated");
}
void GCSceneEntity::SetAutogenerated(bool value) {
    SetSchemaValue(m_ptr, "CSceneEntity", "m_bAutogenerated", false, value);
}
float GCSceneEntity::GetForceClientTime() const {
    return GetSchemaValue<float>(m_ptr, "CSceneEntity", "m_flForceClientTime");
}
void GCSceneEntity::SetForceClientTime(float value) {
    SetSchemaValue(m_ptr, "CSceneEntity", "m_flForceClientTime", false, value);
}
float GCSceneEntity::GetCurrentTime() const {
    return GetSchemaValue<float>(m_ptr, "CSceneEntity", "m_flCurrentTime");
}
void GCSceneEntity::SetCurrentTime(float value) {
    SetSchemaValue(m_ptr, "CSceneEntity", "m_flCurrentTime", false, value);
}
float GCSceneEntity::GetFrameTime() const {
    return GetSchemaValue<float>(m_ptr, "CSceneEntity", "m_flFrameTime");
}
void GCSceneEntity::SetFrameTime(float value) {
    SetSchemaValue(m_ptr, "CSceneEntity", "m_flFrameTime", false, value);
}
bool GCSceneEntity::GetCancelAtNextInterrupt() const {
    return GetSchemaValue<bool>(m_ptr, "CSceneEntity", "m_bCancelAtNextInterrupt");
}
void GCSceneEntity::SetCancelAtNextInterrupt(bool value) {
    SetSchemaValue(m_ptr, "CSceneEntity", "m_bCancelAtNextInterrupt", false, value);
}
float GCSceneEntity::GetPitch() const {
    return GetSchemaValue<float>(m_ptr, "CSceneEntity", "m_fPitch");
}
void GCSceneEntity::SetPitch(float value) {
    SetSchemaValue(m_ptr, "CSceneEntity", "m_fPitch", false, value);
}
bool GCSceneEntity::GetAutomated() const {
    return GetSchemaValue<bool>(m_ptr, "CSceneEntity", "m_bAutomated");
}
void GCSceneEntity::SetAutomated(bool value) {
    SetSchemaValue(m_ptr, "CSceneEntity", "m_bAutomated", false, value);
}
int32_t GCSceneEntity::GetAutomatedAction() const {
    return GetSchemaValue<int32_t>(m_ptr, "CSceneEntity", "m_nAutomatedAction");
}
void GCSceneEntity::SetAutomatedAction(int32_t value) {
    SetSchemaValue(m_ptr, "CSceneEntity", "m_nAutomatedAction", false, value);
}
float GCSceneEntity::GetAutomationDelay() const {
    return GetSchemaValue<float>(m_ptr, "CSceneEntity", "m_flAutomationDelay");
}
void GCSceneEntity::SetAutomationDelay(float value) {
    SetSchemaValue(m_ptr, "CSceneEntity", "m_flAutomationDelay", false, value);
}
float GCSceneEntity::GetAutomationTime() const {
    return GetSchemaValue<float>(m_ptr, "CSceneEntity", "m_flAutomationTime");
}
void GCSceneEntity::SetAutomationTime(float value) {
    SetSchemaValue(m_ptr, "CSceneEntity", "m_flAutomationTime", false, value);
}
GCBaseEntity GCSceneEntity::GetWaitingForThisResumeScene() const {
    GCBaseEntity value(*GetSchemaValuePtr<void*>(m_ptr, "CSceneEntity", "m_hWaitingForThisResumeScene"));
    return value;
}
void GCSceneEntity::SetWaitingForThisResumeScene(GCBaseEntity* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'WaitingForThisResumeScene' is not possible.\n");
}
bool GCSceneEntity::GetWaitingForResumeScene() const {
    return GetSchemaValue<bool>(m_ptr, "CSceneEntity", "m_bWaitingForResumeScene");
}
void GCSceneEntity::SetWaitingForResumeScene(bool value) {
    SetSchemaValue(m_ptr, "CSceneEntity", "m_bWaitingForResumeScene", false, value);
}
bool GCSceneEntity::GetPausedViaInput() const {
    return GetSchemaValue<bool>(m_ptr, "CSceneEntity", "m_bPausedViaInput");
}
void GCSceneEntity::SetPausedViaInput(bool value) {
    SetSchemaValue(m_ptr, "CSceneEntity", "m_bPausedViaInput", false, value);
}
bool GCSceneEntity::GetPauseAtNextInterrupt() const {
    return GetSchemaValue<bool>(m_ptr, "CSceneEntity", "m_bPauseAtNextInterrupt");
}
void GCSceneEntity::SetPauseAtNextInterrupt(bool value) {
    SetSchemaValue(m_ptr, "CSceneEntity", "m_bPauseAtNextInterrupt", false, value);
}
bool GCSceneEntity::GetWaitingForActor() const {
    return GetSchemaValue<bool>(m_ptr, "CSceneEntity", "m_bWaitingForActor");
}
void GCSceneEntity::SetWaitingForActor(bool value) {
    SetSchemaValue(m_ptr, "CSceneEntity", "m_bWaitingForActor", false, value);
}
bool GCSceneEntity::GetWaitingForInterrupt() const {
    return GetSchemaValue<bool>(m_ptr, "CSceneEntity", "m_bWaitingForInterrupt");
}
void GCSceneEntity::SetWaitingForInterrupt(bool value) {
    SetSchemaValue(m_ptr, "CSceneEntity", "m_bWaitingForInterrupt", false, value);
}
bool GCSceneEntity::GetInterruptedActorsScenes() const {
    return GetSchemaValue<bool>(m_ptr, "CSceneEntity", "m_bInterruptedActorsScenes");
}
void GCSceneEntity::SetInterruptedActorsScenes(bool value) {
    SetSchemaValue(m_ptr, "CSceneEntity", "m_bInterruptedActorsScenes", false, value);
}
bool GCSceneEntity::GetBreakOnNonIdle() const {
    return GetSchemaValue<bool>(m_ptr, "CSceneEntity", "m_bBreakOnNonIdle");
}
void GCSceneEntity::SetBreakOnNonIdle(bool value) {
    SetSchemaValue(m_ptr, "CSceneEntity", "m_bBreakOnNonIdle", false, value);
}
bool GCSceneEntity::GetSceneFinished() const {
    return GetSchemaValue<bool>(m_ptr, "CSceneEntity", "m_bSceneFinished");
}
void GCSceneEntity::SetSceneFinished(bool value) {
    SetSchemaValue(m_ptr, "CSceneEntity", "m_bSceneFinished", false, value);
}
std::vector<GCBaseFlex*> GCSceneEntity::GetActorList() const {
    CUtlVector<GCBaseFlex*>* vec = GetSchemaValue<CUtlVector<GCBaseFlex*>*>(m_ptr, "CSceneEntity", "m_hActorList"); std::vector<GCBaseFlex*> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCSceneEntity::SetActorList(std::vector<GCBaseFlex*> value) {
    SetSchemaValueCUtlVector<GCBaseFlex*>(m_ptr, "CSceneEntity", "m_hActorList", false, value);
}
int32_t GCSceneEntity::GetSceneFlushCounter() const {
    return GetSchemaValue<int32_t>(m_ptr, "CSceneEntity", "m_nSceneFlushCounter");
}
void GCSceneEntity::SetSceneFlushCounter(int32_t value) {
    SetSchemaValue(m_ptr, "CSceneEntity", "m_nSceneFlushCounter", false, value);
}
uint16_t GCSceneEntity::GetSceneStringIndex() const {
    return GetSchemaValue<uint16_t>(m_ptr, "CSceneEntity", "m_nSceneStringIndex");
}
void GCSceneEntity::SetSceneStringIndex(uint16_t value) {
    SetSchemaValue(m_ptr, "CSceneEntity", "m_nSceneStringIndex", false, value);
}
GCEntityIOOutput GCSceneEntity::GetOnStart() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CSceneEntity", "m_OnStart"));
    return value;
}
void GCSceneEntity::SetOnStart(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CSceneEntity", "m_OnStart", false, value);
}
GCEntityIOOutput GCSceneEntity::GetOnCompletion() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CSceneEntity", "m_OnCompletion"));
    return value;
}
void GCSceneEntity::SetOnCompletion(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CSceneEntity", "m_OnCompletion", false, value);
}
GCEntityIOOutput GCSceneEntity::GetOnCanceled() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CSceneEntity", "m_OnCanceled"));
    return value;
}
void GCSceneEntity::SetOnCanceled(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CSceneEntity", "m_OnCanceled", false, value);
}
GCEntityIOOutput GCSceneEntity::GetOnPaused() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CSceneEntity", "m_OnPaused"));
    return value;
}
void GCSceneEntity::SetOnPaused(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CSceneEntity", "m_OnPaused", false, value);
}
GCEntityIOOutput GCSceneEntity::GetOnResumed() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CSceneEntity", "m_OnResumed"));
    return value;
}
void GCSceneEntity::SetOnResumed(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CSceneEntity", "m_OnResumed", false, value);
}
std::vector<GCEntityIOOutput> GCSceneEntity::GetOnTrigger() const {
    GCEntityIOOutput* outValue = GetSchemaValue<GCEntityIOOutput*>(m_ptr, "CSceneEntity", "m_OnTrigger"); std::vector<GCEntityIOOutput> ret; for(int i = 0; i < 16; i++) { ret.push_back(outValue[i]); } return ret;
}
void GCSceneEntity::SetOnTrigger(std::vector<GCEntityIOOutput> value) {
    GCEntityIOOutput* outValue = GetSchemaValue<GCEntityIOOutput*>(m_ptr, "CSceneEntity", "m_OnTrigger"); for(int i = 0; i < 16; i++) { outValue[i] = value[i]; } SetSchemaValue(m_ptr, "CSceneEntity", "m_OnTrigger", false, outValue);
}
GCSceneEntity GCSceneEntity::GetInterruptScene() const {
    GCSceneEntity value(*GetSchemaValuePtr<void*>(m_ptr, "CSceneEntity", "m_hInterruptScene"));
    return value;
}
void GCSceneEntity::SetInterruptScene(GCSceneEntity* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'InterruptScene' is not possible.\n");
}
int32_t GCSceneEntity::GetInterruptCount() const {
    return GetSchemaValue<int32_t>(m_ptr, "CSceneEntity", "m_nInterruptCount");
}
void GCSceneEntity::SetInterruptCount(int32_t value) {
    SetSchemaValue(m_ptr, "CSceneEntity", "m_nInterruptCount", false, value);
}
bool GCSceneEntity::GetSceneMissing() const {
    return GetSchemaValue<bool>(m_ptr, "CSceneEntity", "m_bSceneMissing");
}
void GCSceneEntity::SetSceneMissing(bool value) {
    SetSchemaValue(m_ptr, "CSceneEntity", "m_bSceneMissing", false, value);
}
bool GCSceneEntity::GetInterrupted() const {
    return GetSchemaValue<bool>(m_ptr, "CSceneEntity", "m_bInterrupted");
}
void GCSceneEntity::SetInterrupted(bool value) {
    SetSchemaValue(m_ptr, "CSceneEntity", "m_bInterrupted", false, value);
}
bool GCSceneEntity::GetCompletedEarly() const {
    return GetSchemaValue<bool>(m_ptr, "CSceneEntity", "m_bCompletedEarly");
}
void GCSceneEntity::SetCompletedEarly(bool value) {
    SetSchemaValue(m_ptr, "CSceneEntity", "m_bCompletedEarly", false, value);
}
bool GCSceneEntity::GetInterruptSceneFinished() const {
    return GetSchemaValue<bool>(m_ptr, "CSceneEntity", "m_bInterruptSceneFinished");
}
void GCSceneEntity::SetInterruptSceneFinished(bool value) {
    SetSchemaValue(m_ptr, "CSceneEntity", "m_bInterruptSceneFinished", false, value);
}
bool GCSceneEntity::GetRestoring() const {
    return GetSchemaValue<bool>(m_ptr, "CSceneEntity", "m_bRestoring");
}
void GCSceneEntity::SetRestoring(bool value) {
    SetSchemaValue(m_ptr, "CSceneEntity", "m_bRestoring", false, value);
}
std::string GCSceneEntity::GetSoundName() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CSceneEntity", "m_iszSoundName").String();
}
void GCSceneEntity::SetSoundName(std::string value) {
    SetSchemaValue(m_ptr, "CSceneEntity", "m_iszSoundName", false, CUtlSymbolLarge(value.c_str()));
}
std::string GCSceneEntity::GetSequenceName() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CSceneEntity", "m_iszSequenceName").String();
}
void GCSceneEntity::SetSequenceName(std::string value) {
    SetSchemaValue(m_ptr, "CSceneEntity", "m_iszSequenceName", false, CUtlSymbolLarge(value.c_str()));
}
GCBaseFlex GCSceneEntity::GetActor() const {
    GCBaseFlex value(*GetSchemaValuePtr<void*>(m_ptr, "CSceneEntity", "m_hActor"));
    return value;
}
void GCSceneEntity::SetActor(GCBaseFlex* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Actor' is not possible.\n");
}
GCBaseEntity GCSceneEntity::GetActivator() const {
    GCBaseEntity value(*GetSchemaValuePtr<void*>(m_ptr, "CSceneEntity", "m_hActivator"));
    return value;
}
void GCSceneEntity::SetActivator(GCBaseEntity* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Activator' is not possible.\n");
}
int32_t GCSceneEntity::GetBusyActor() const {
    return GetSchemaValue<int32_t>(m_ptr, "CSceneEntity", "m_BusyActor");
}
void GCSceneEntity::SetBusyActor(int32_t value) {
    SetSchemaValue(m_ptr, "CSceneEntity", "m_BusyActor", false, value);
}
uint64_t GCSceneEntity::GetPlayerDeathBehavior() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CSceneEntity", "m_iPlayerDeathBehavior");
}
void GCSceneEntity::SetPlayerDeathBehavior(uint64_t value) {
    SetSchemaValue(m_ptr, "CSceneEntity", "m_iPlayerDeathBehavior", false, value);
}
std::string GCSceneEntity::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCSceneEntity::IsValid() {
    return (m_ptr != nullptr);
}
GCPointEntity GCSceneEntity::GetParent() const {
    GCPointEntity value(m_ptr);
    return value;
}
void GCSceneEntity::SetParent(GCPointEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCSceneEntity(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCSceneEntity>("CSceneEntity")
        .addConstructor<void (*)(std::string)>()
        .addProperty("SceneFile", &GCSceneEntity::GetSceneFile, &GCSceneEntity::SetSceneFile)
        .addProperty("ResumeSceneFile", &GCSceneEntity::GetResumeSceneFile, &GCSceneEntity::SetResumeSceneFile)
        .addProperty("Target1", &GCSceneEntity::GetTarget1, &GCSceneEntity::SetTarget1)
        .addProperty("Target2", &GCSceneEntity::GetTarget2, &GCSceneEntity::SetTarget2)
        .addProperty("Target3", &GCSceneEntity::GetTarget3, &GCSceneEntity::SetTarget3)
        .addProperty("Target4", &GCSceneEntity::GetTarget4, &GCSceneEntity::SetTarget4)
        .addProperty("Target5", &GCSceneEntity::GetTarget5, &GCSceneEntity::SetTarget5)
        .addProperty("Target6", &GCSceneEntity::GetTarget6, &GCSceneEntity::SetTarget6)
        .addProperty("Target7", &GCSceneEntity::GetTarget7, &GCSceneEntity::SetTarget7)
        .addProperty("Target8", &GCSceneEntity::GetTarget8, &GCSceneEntity::SetTarget8)
        .addProperty("Target11", &GCSceneEntity::GetTarget11, &GCSceneEntity::SetTarget11)
        .addProperty("Target21", &GCSceneEntity::GetTarget21, &GCSceneEntity::SetTarget21)
        .addProperty("Target31", &GCSceneEntity::GetTarget31, &GCSceneEntity::SetTarget31)
        .addProperty("Target41", &GCSceneEntity::GetTarget41, &GCSceneEntity::SetTarget41)
        .addProperty("Target51", &GCSceneEntity::GetTarget51, &GCSceneEntity::SetTarget51)
        .addProperty("Target61", &GCSceneEntity::GetTarget61, &GCSceneEntity::SetTarget61)
        .addProperty("Target71", &GCSceneEntity::GetTarget71, &GCSceneEntity::SetTarget71)
        .addProperty("Target81", &GCSceneEntity::GetTarget81, &GCSceneEntity::SetTarget81)
        .addProperty("TargetAttachment", &GCSceneEntity::GetTargetAttachment, &GCSceneEntity::SetTargetAttachment)
        .addProperty("IsPlayingBack", &GCSceneEntity::GetIsPlayingBack, &GCSceneEntity::SetIsPlayingBack)
        .addProperty("Paused", &GCSceneEntity::GetPaused, &GCSceneEntity::SetPaused)
        .addProperty("Multiplayer", &GCSceneEntity::GetMultiplayer, &GCSceneEntity::SetMultiplayer)
        .addProperty("Autogenerated", &GCSceneEntity::GetAutogenerated, &GCSceneEntity::SetAutogenerated)
        .addProperty("ForceClientTime", &GCSceneEntity::GetForceClientTime, &GCSceneEntity::SetForceClientTime)
        .addProperty("CurrentTime", &GCSceneEntity::GetCurrentTime, &GCSceneEntity::SetCurrentTime)
        .addProperty("FrameTime", &GCSceneEntity::GetFrameTime, &GCSceneEntity::SetFrameTime)
        .addProperty("CancelAtNextInterrupt", &GCSceneEntity::GetCancelAtNextInterrupt, &GCSceneEntity::SetCancelAtNextInterrupt)
        .addProperty("Pitch", &GCSceneEntity::GetPitch, &GCSceneEntity::SetPitch)
        .addProperty("Automated", &GCSceneEntity::GetAutomated, &GCSceneEntity::SetAutomated)
        .addProperty("AutomatedAction", &GCSceneEntity::GetAutomatedAction, &GCSceneEntity::SetAutomatedAction)
        .addProperty("AutomationDelay", &GCSceneEntity::GetAutomationDelay, &GCSceneEntity::SetAutomationDelay)
        .addProperty("AutomationTime", &GCSceneEntity::GetAutomationTime, &GCSceneEntity::SetAutomationTime)
        .addProperty("WaitingForThisResumeScene", &GCSceneEntity::GetWaitingForThisResumeScene, &GCSceneEntity::SetWaitingForThisResumeScene)
        .addProperty("WaitingForResumeScene", &GCSceneEntity::GetWaitingForResumeScene, &GCSceneEntity::SetWaitingForResumeScene)
        .addProperty("PausedViaInput", &GCSceneEntity::GetPausedViaInput, &GCSceneEntity::SetPausedViaInput)
        .addProperty("PauseAtNextInterrupt", &GCSceneEntity::GetPauseAtNextInterrupt, &GCSceneEntity::SetPauseAtNextInterrupt)
        .addProperty("WaitingForActor", &GCSceneEntity::GetWaitingForActor, &GCSceneEntity::SetWaitingForActor)
        .addProperty("WaitingForInterrupt", &GCSceneEntity::GetWaitingForInterrupt, &GCSceneEntity::SetWaitingForInterrupt)
        .addProperty("InterruptedActorsScenes", &GCSceneEntity::GetInterruptedActorsScenes, &GCSceneEntity::SetInterruptedActorsScenes)
        .addProperty("BreakOnNonIdle", &GCSceneEntity::GetBreakOnNonIdle, &GCSceneEntity::SetBreakOnNonIdle)
        .addProperty("SceneFinished", &GCSceneEntity::GetSceneFinished, &GCSceneEntity::SetSceneFinished)
        .addProperty("ActorList", &GCSceneEntity::GetActorList, &GCSceneEntity::SetActorList)
        .addProperty("SceneFlushCounter", &GCSceneEntity::GetSceneFlushCounter, &GCSceneEntity::SetSceneFlushCounter)
        .addProperty("SceneStringIndex", &GCSceneEntity::GetSceneStringIndex, &GCSceneEntity::SetSceneStringIndex)
        .addProperty("OnStart", &GCSceneEntity::GetOnStart, &GCSceneEntity::SetOnStart)
        .addProperty("OnCompletion", &GCSceneEntity::GetOnCompletion, &GCSceneEntity::SetOnCompletion)
        .addProperty("OnCanceled", &GCSceneEntity::GetOnCanceled, &GCSceneEntity::SetOnCanceled)
        .addProperty("OnPaused", &GCSceneEntity::GetOnPaused, &GCSceneEntity::SetOnPaused)
        .addProperty("OnResumed", &GCSceneEntity::GetOnResumed, &GCSceneEntity::SetOnResumed)
        .addProperty("OnTrigger", &GCSceneEntity::GetOnTrigger, &GCSceneEntity::SetOnTrigger)
        .addProperty("InterruptScene", &GCSceneEntity::GetInterruptScene, &GCSceneEntity::SetInterruptScene)
        .addProperty("InterruptCount", &GCSceneEntity::GetInterruptCount, &GCSceneEntity::SetInterruptCount)
        .addProperty("SceneMissing", &GCSceneEntity::GetSceneMissing, &GCSceneEntity::SetSceneMissing)
        .addProperty("Interrupted", &GCSceneEntity::GetInterrupted, &GCSceneEntity::SetInterrupted)
        .addProperty("CompletedEarly", &GCSceneEntity::GetCompletedEarly, &GCSceneEntity::SetCompletedEarly)
        .addProperty("InterruptSceneFinished", &GCSceneEntity::GetInterruptSceneFinished, &GCSceneEntity::SetInterruptSceneFinished)
        .addProperty("Restoring", &GCSceneEntity::GetRestoring, &GCSceneEntity::SetRestoring)
        .addProperty("SoundName", &GCSceneEntity::GetSoundName, &GCSceneEntity::SetSoundName)
        .addProperty("SequenceName", &GCSceneEntity::GetSequenceName, &GCSceneEntity::SetSequenceName)
        .addProperty("Actor", &GCSceneEntity::GetActor, &GCSceneEntity::SetActor)
        .addProperty("Activator", &GCSceneEntity::GetActivator, &GCSceneEntity::SetActivator)
        .addProperty("BusyActor", &GCSceneEntity::GetBusyActor, &GCSceneEntity::SetBusyActor)
        .addProperty("PlayerDeathBehavior", &GCSceneEntity::GetPlayerDeathBehavior, &GCSceneEntity::SetPlayerDeathBehavior)
        .addProperty("Parent", &GCSceneEntity::GetParent, &GCSceneEntity::SetParent)
        .addFunction("ToPtr", &GCSceneEntity::ToPtr)
        .addFunction("IsValid", &GCSceneEntity::IsValid)
        .endClass();
}
GCEnvHudHint::GCEnvHudHint(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCEnvHudHint::GCEnvHudHint(void *ptr) {
    m_ptr = ptr;
}
std::string GCEnvHudHint::GetMessage() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CEnvHudHint", "m_iszMessage").String();
}
void GCEnvHudHint::SetMessage(std::string value) {
    SetSchemaValue(m_ptr, "CEnvHudHint", "m_iszMessage", false, CUtlSymbolLarge(value.c_str()));
}
std::string GCEnvHudHint::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCEnvHudHint::IsValid() {
    return (m_ptr != nullptr);
}
GCPointEntity GCEnvHudHint::GetParent() const {
    GCPointEntity value(m_ptr);
    return value;
}
void GCEnvHudHint::SetParent(GCPointEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCEnvHudHint(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCEnvHudHint>("CEnvHudHint")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Message", &GCEnvHudHint::GetMessage, &GCEnvHudHint::SetMessage)
        .addProperty("Parent", &GCEnvHudHint::GetParent, &GCEnvHudHint::SetParent)
        .addFunction("ToPtr", &GCEnvHudHint::ToPtr)
        .addFunction("IsValid", &GCEnvHudHint::IsValid)
        .endClass();
}
GCParticleSystem::GCParticleSystem(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCParticleSystem::GCParticleSystem(void *ptr) {
    m_ptr = ptr;
}
std::string GCParticleSystem::GetSnapshotFileName() const {
    return GetSchemaValuePtr<char>(m_ptr, "CParticleSystem", "m_szSnapshotFileName");
}
void GCParticleSystem::SetSnapshotFileName(std::string value) {
    WriteSchemaPtrValue(m_ptr, "CParticleSystem", "m_szSnapshotFileName", false, reinterpret_cast<byte*>(const_cast<char*>(value.c_str())), 512);
}
bool GCParticleSystem::GetActive() const {
    return GetSchemaValue<bool>(m_ptr, "CParticleSystem", "m_bActive");
}
void GCParticleSystem::SetActive(bool value) {
    SetSchemaValue(m_ptr, "CParticleSystem", "m_bActive", false, value);
}
bool GCParticleSystem::GetFrozen() const {
    return GetSchemaValue<bool>(m_ptr, "CParticleSystem", "m_bFrozen");
}
void GCParticleSystem::SetFrozen(bool value) {
    SetSchemaValue(m_ptr, "CParticleSystem", "m_bFrozen", false, value);
}
float GCParticleSystem::GetFreezeTransitionDuration() const {
    return GetSchemaValue<float>(m_ptr, "CParticleSystem", "m_flFreezeTransitionDuration");
}
void GCParticleSystem::SetFreezeTransitionDuration(float value) {
    SetSchemaValue(m_ptr, "CParticleSystem", "m_flFreezeTransitionDuration", false, value);
}
int32_t GCParticleSystem::GetStopType() const {
    return GetSchemaValue<int32_t>(m_ptr, "CParticleSystem", "m_nStopType");
}
void GCParticleSystem::SetStopType(int32_t value) {
    SetSchemaValue(m_ptr, "CParticleSystem", "m_nStopType", false, value);
}
bool GCParticleSystem::GetAnimateDuringGameplayPause() const {
    return GetSchemaValue<bool>(m_ptr, "CParticleSystem", "m_bAnimateDuringGameplayPause");
}
void GCParticleSystem::SetAnimateDuringGameplayPause(bool value) {
    SetSchemaValue(m_ptr, "CParticleSystem", "m_bAnimateDuringGameplayPause", false, value);
}
float GCParticleSystem::GetStartTime() const {
    return GetSchemaValue<float>(m_ptr, "CParticleSystem", "m_flStartTime");
}
void GCParticleSystem::SetStartTime(float value) {
    SetSchemaValue(m_ptr, "CParticleSystem", "m_flStartTime", false, value);
}
float GCParticleSystem::GetPreSimTime() const {
    return GetSchemaValue<float>(m_ptr, "CParticleSystem", "m_flPreSimTime");
}
void GCParticleSystem::SetPreSimTime(float value) {
    SetSchemaValue(m_ptr, "CParticleSystem", "m_flPreSimTime", false, value);
}
std::vector<Vector> GCParticleSystem::GetServerControlPoints() const {
    Vector* outValue = GetSchemaValue<Vector*>(m_ptr, "CParticleSystem", "m_vServerControlPoints"); std::vector<Vector> ret; for(int i = 0; i < 4; i++) { ret.push_back(outValue[i]); } return ret;
}
void GCParticleSystem::SetServerControlPoints(std::vector<Vector> value) {
    Vector* outValue = GetSchemaValue<Vector*>(m_ptr, "CParticleSystem", "m_vServerControlPoints"); for(int i = 0; i < 4; i++) { outValue[i] = value[i]; } SetSchemaValue(m_ptr, "CParticleSystem", "m_vServerControlPoints", false, outValue);
}
std::vector<uint8_t> GCParticleSystem::GetServerControlPointAssignments() const {
    uint8_t* outValue = GetSchemaValue<uint8_t*>(m_ptr, "CParticleSystem", "m_iServerControlPointAssignments"); std::vector<uint8_t> ret; for(int i = 0; i < 4; i++) { ret.push_back(outValue[i]); } return ret;
}
void GCParticleSystem::SetServerControlPointAssignments(std::vector<uint8_t> value) {
    uint8_t* outValue = GetSchemaValue<uint8_t*>(m_ptr, "CParticleSystem", "m_iServerControlPointAssignments"); for(int i = 0; i < 4; i++) { outValue[i] = value[i]; } SetSchemaValue(m_ptr, "CParticleSystem", "m_iServerControlPointAssignments", false, outValue);
}
std::vector<GCBaseEntity*> GCParticleSystem::GetControlPointEnts() const {
    GCBaseEntity** outValue = GetSchemaValue<GCBaseEntity**>(m_ptr, "CParticleSystem", "m_hControlPointEnts"); std::vector<GCBaseEntity*> ret; for(int i = 0; i < 64; i++) { ret.push_back(outValue[i]); } return ret;
}
void GCParticleSystem::SetControlPointEnts(std::vector<GCBaseEntity*> value) {
    GCBaseEntity** outValue = GetSchemaValue<GCBaseEntity**>(m_ptr, "CParticleSystem", "m_hControlPointEnts"); for(int i = 0; i < 64; i++) { outValue[i] = value[i]; } SetSchemaValue(m_ptr, "CParticleSystem", "m_hControlPointEnts", false, outValue);
}
bool GCParticleSystem::GetNoSave() const {
    return GetSchemaValue<bool>(m_ptr, "CParticleSystem", "m_bNoSave");
}
void GCParticleSystem::SetNoSave(bool value) {
    SetSchemaValue(m_ptr, "CParticleSystem", "m_bNoSave", false, value);
}
bool GCParticleSystem::GetNoFreeze() const {
    return GetSchemaValue<bool>(m_ptr, "CParticleSystem", "m_bNoFreeze");
}
void GCParticleSystem::SetNoFreeze(bool value) {
    SetSchemaValue(m_ptr, "CParticleSystem", "m_bNoFreeze", false, value);
}
bool GCParticleSystem::GetNoRamp() const {
    return GetSchemaValue<bool>(m_ptr, "CParticleSystem", "m_bNoRamp");
}
void GCParticleSystem::SetNoRamp(bool value) {
    SetSchemaValue(m_ptr, "CParticleSystem", "m_bNoRamp", false, value);
}
bool GCParticleSystem::GetStartActive() const {
    return GetSchemaValue<bool>(m_ptr, "CParticleSystem", "m_bStartActive");
}
void GCParticleSystem::SetStartActive(bool value) {
    SetSchemaValue(m_ptr, "CParticleSystem", "m_bStartActive", false, value);
}
std::string GCParticleSystem::GetEffectName() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CParticleSystem", "m_iszEffectName").String();
}
void GCParticleSystem::SetEffectName(std::string value) {
    SetSchemaValue(m_ptr, "CParticleSystem", "m_iszEffectName", false, CUtlSymbolLarge(value.c_str()));
}
std::vector<CUtlSymbolLarge> GCParticleSystem::GetControlPointNames() const {
    CUtlSymbolLarge* outValue = GetSchemaValue<CUtlSymbolLarge*>(m_ptr, "CParticleSystem", "m_iszControlPointNames"); std::vector<CUtlSymbolLarge> ret; for(int i = 0; i < 64; i++) { ret.push_back(outValue[i]); } return ret;
}
void GCParticleSystem::SetControlPointNames(std::vector<CUtlSymbolLarge> value) {
    CUtlSymbolLarge* outValue = GetSchemaValue<CUtlSymbolLarge*>(m_ptr, "CParticleSystem", "m_iszControlPointNames"); for(int i = 0; i < 64; i++) { outValue[i] = value[i]; } SetSchemaValue(m_ptr, "CParticleSystem", "m_iszControlPointNames", false, outValue);
}
int32_t GCParticleSystem::GetDataCP() const {
    return GetSchemaValue<int32_t>(m_ptr, "CParticleSystem", "m_nDataCP");
}
void GCParticleSystem::SetDataCP(int32_t value) {
    SetSchemaValue(m_ptr, "CParticleSystem", "m_nDataCP", false, value);
}
Vector GCParticleSystem::GetDataCPValue() const {
    return GetSchemaValue<Vector>(m_ptr, "CParticleSystem", "m_vecDataCPValue");
}
void GCParticleSystem::SetDataCPValue(Vector value) {
    SetSchemaValue(m_ptr, "CParticleSystem", "m_vecDataCPValue", false, value);
}
int32_t GCParticleSystem::GetTintCP() const {
    return GetSchemaValue<int32_t>(m_ptr, "CParticleSystem", "m_nTintCP");
}
void GCParticleSystem::SetTintCP(int32_t value) {
    SetSchemaValue(m_ptr, "CParticleSystem", "m_nTintCP", false, value);
}
Color GCParticleSystem::GetTint() const {
    return GetSchemaValue<Color>(m_ptr, "CParticleSystem", "m_clrTint");
}
void GCParticleSystem::SetTint(Color value) {
    SetSchemaValue(m_ptr, "CParticleSystem", "m_clrTint", false, value);
}
std::string GCParticleSystem::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCParticleSystem::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseModelEntity GCParticleSystem::GetParent() const {
    GCBaseModelEntity value(m_ptr);
    return value;
}
void GCParticleSystem::SetParent(GCBaseModelEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCParticleSystem(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCParticleSystem>("CParticleSystem")
        .addConstructor<void (*)(std::string)>()
        .addProperty("SnapshotFileName", &GCParticleSystem::GetSnapshotFileName, &GCParticleSystem::SetSnapshotFileName)
        .addProperty("Active", &GCParticleSystem::GetActive, &GCParticleSystem::SetActive)
        .addProperty("Frozen", &GCParticleSystem::GetFrozen, &GCParticleSystem::SetFrozen)
        .addProperty("FreezeTransitionDuration", &GCParticleSystem::GetFreezeTransitionDuration, &GCParticleSystem::SetFreezeTransitionDuration)
        .addProperty("StopType", &GCParticleSystem::GetStopType, &GCParticleSystem::SetStopType)
        .addProperty("AnimateDuringGameplayPause", &GCParticleSystem::GetAnimateDuringGameplayPause, &GCParticleSystem::SetAnimateDuringGameplayPause)
        .addProperty("StartTime", &GCParticleSystem::GetStartTime, &GCParticleSystem::SetStartTime)
        .addProperty("PreSimTime", &GCParticleSystem::GetPreSimTime, &GCParticleSystem::SetPreSimTime)
        .addProperty("ServerControlPoints", &GCParticleSystem::GetServerControlPoints, &GCParticleSystem::SetServerControlPoints)
        .addProperty("ServerControlPointAssignments", &GCParticleSystem::GetServerControlPointAssignments, &GCParticleSystem::SetServerControlPointAssignments)
        .addProperty("ControlPointEnts", &GCParticleSystem::GetControlPointEnts, &GCParticleSystem::SetControlPointEnts)
        .addProperty("NoSave", &GCParticleSystem::GetNoSave, &GCParticleSystem::SetNoSave)
        .addProperty("NoFreeze", &GCParticleSystem::GetNoFreeze, &GCParticleSystem::SetNoFreeze)
        .addProperty("NoRamp", &GCParticleSystem::GetNoRamp, &GCParticleSystem::SetNoRamp)
        .addProperty("StartActive", &GCParticleSystem::GetStartActive, &GCParticleSystem::SetStartActive)
        .addProperty("EffectName", &GCParticleSystem::GetEffectName, &GCParticleSystem::SetEffectName)
        .addProperty("ControlPointNames", &GCParticleSystem::GetControlPointNames, &GCParticleSystem::SetControlPointNames)
        .addProperty("DataCP", &GCParticleSystem::GetDataCP, &GCParticleSystem::SetDataCP)
        .addProperty("DataCPValue", &GCParticleSystem::GetDataCPValue, &GCParticleSystem::SetDataCPValue)
        .addProperty("TintCP", &GCParticleSystem::GetTintCP, &GCParticleSystem::SetTintCP)
        .addProperty("Tint", &GCParticleSystem::GetTint, &GCParticleSystem::SetTint)
        .addProperty("Parent", &GCParticleSystem::GetParent, &GCParticleSystem::SetParent)
        .addFunction("ToPtr", &GCParticleSystem::ToPtr)
        .addFunction("IsValid", &GCParticleSystem::IsValid)
        .endClass();
}
GAmmoIndex_t::GAmmoIndex_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GAmmoIndex_t::GAmmoIndex_t(void *ptr) {
    m_ptr = ptr;
}
int8_t GAmmoIndex_t::GetValue() const {
    return GetSchemaValue<int8_t>(m_ptr, "AmmoIndex_t", "m_Value");
}
void GAmmoIndex_t::SetValue(int8_t value) {
    SetSchemaValue(m_ptr, "AmmoIndex_t", "m_Value", true, value);
}
std::string GAmmoIndex_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GAmmoIndex_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassAmmoIndex_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GAmmoIndex_t>("AmmoIndex_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Value", &GAmmoIndex_t::GetValue, &GAmmoIndex_t::SetValue)
        .addFunction("ToPtr", &GAmmoIndex_t::ToPtr)
        .addFunction("IsValid", &GAmmoIndex_t::IsValid)
        .endClass();
}
Gsky3dparams_t::Gsky3dparams_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
Gsky3dparams_t::Gsky3dparams_t(void *ptr) {
    m_ptr = ptr;
}
int16_t Gsky3dparams_t::GetScale() const {
    return GetSchemaValue<int16_t>(m_ptr, "sky3dparams_t", "scale");
}
void Gsky3dparams_t::SetScale(int16_t value) {
    SetSchemaValue(m_ptr, "sky3dparams_t", "scale", true, value);
}
Vector Gsky3dparams_t::GetOrigin() const {
    return GetSchemaValue<Vector>(m_ptr, "sky3dparams_t", "origin");
}
void Gsky3dparams_t::SetOrigin(Vector value) {
    SetSchemaValue(m_ptr, "sky3dparams_t", "origin", true, value);
}
bool Gsky3dparams_t::GetClip3DSkyBoxNearToWorldFar() const {
    return GetSchemaValue<bool>(m_ptr, "sky3dparams_t", "bClip3DSkyBoxNearToWorldFar");
}
void Gsky3dparams_t::SetClip3DSkyBoxNearToWorldFar(bool value) {
    SetSchemaValue(m_ptr, "sky3dparams_t", "bClip3DSkyBoxNearToWorldFar", true, value);
}
float Gsky3dparams_t::GetClip3DSkyBoxNearToWorldFarOffset() const {
    return GetSchemaValue<float>(m_ptr, "sky3dparams_t", "flClip3DSkyBoxNearToWorldFarOffset");
}
void Gsky3dparams_t::SetClip3DSkyBoxNearToWorldFarOffset(float value) {
    SetSchemaValue(m_ptr, "sky3dparams_t", "flClip3DSkyBoxNearToWorldFarOffset", true, value);
}
Gfogparams_t Gsky3dparams_t::GetFog() const {
    Gfogparams_t value(GetSchemaPtr(m_ptr, "sky3dparams_t", "fog"));
    return value;
}
void Gsky3dparams_t::SetFog(Gfogparams_t value) {
    SetSchemaValue(m_ptr, "sky3dparams_t", "fog", true, value);
}
WorldGroupId_t Gsky3dparams_t::GetWorldGroupID() const {
    return GetSchemaValue<WorldGroupId_t>(m_ptr, "sky3dparams_t", "m_nWorldGroupID");
}
void Gsky3dparams_t::SetWorldGroupID(WorldGroupId_t value) {
    SetSchemaValue(m_ptr, "sky3dparams_t", "m_nWorldGroupID", true, value);
}
std::string Gsky3dparams_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool Gsky3dparams_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClasssky3dparams_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<Gsky3dparams_t>("sky3dparams_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Scale", &Gsky3dparams_t::GetScale, &Gsky3dparams_t::SetScale)
        .addProperty("Origin", &Gsky3dparams_t::GetOrigin, &Gsky3dparams_t::SetOrigin)
        .addProperty("Clip3DSkyBoxNearToWorldFar", &Gsky3dparams_t::GetClip3DSkyBoxNearToWorldFar, &Gsky3dparams_t::SetClip3DSkyBoxNearToWorldFar)
        .addProperty("Clip3DSkyBoxNearToWorldFarOffset", &Gsky3dparams_t::GetClip3DSkyBoxNearToWorldFarOffset, &Gsky3dparams_t::SetClip3DSkyBoxNearToWorldFarOffset)
        .addProperty("Fog", &Gsky3dparams_t::GetFog, &Gsky3dparams_t::SetFog)
        .addProperty("WorldGroupID", &Gsky3dparams_t::GetWorldGroupID, &Gsky3dparams_t::SetWorldGroupID)
        .addFunction("ToPtr", &Gsky3dparams_t::ToPtr)
        .addFunction("IsValid", &Gsky3dparams_t::IsValid)
        .endClass();
}
GCScriptItem::GCScriptItem(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCScriptItem::GCScriptItem(void *ptr) {
    m_ptr = ptr;
}
uint64_t GCScriptItem::GetMoveTypeOverride() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CScriptItem", "m_MoveTypeOverride");
}
void GCScriptItem::SetMoveTypeOverride(uint64_t value) {
    SetSchemaValue(m_ptr, "CScriptItem", "m_MoveTypeOverride", false, value);
}
std::string GCScriptItem::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCScriptItem::IsValid() {
    return (m_ptr != nullptr);
}
GCItem GCScriptItem::GetParent() const {
    GCItem value(m_ptr);
    return value;
}
void GCScriptItem::SetParent(GCItem value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCScriptItem(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCScriptItem>("CScriptItem")
        .addConstructor<void (*)(std::string)>()
        .addProperty("MoveTypeOverride", &GCScriptItem::GetMoveTypeOverride, &GCScriptItem::SetMoveTypeOverride)
        .addProperty("Parent", &GCScriptItem::GetParent, &GCScriptItem::SetParent)
        .addFunction("ToPtr", &GCScriptItem::ToPtr)
        .addFunction("IsValid", &GCScriptItem::IsValid)
        .endClass();
}
GIntervalTimer::GIntervalTimer(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GIntervalTimer::GIntervalTimer(void *ptr) {
    m_ptr = ptr;
}
float GIntervalTimer::GetTimestamp() const {
    return GetSchemaValue<float>(m_ptr, "IntervalTimer", "m_timestamp");
}
void GIntervalTimer::SetTimestamp(float value) {
    SetSchemaValue(m_ptr, "IntervalTimer", "m_timestamp", false, value);
}
WorldGroupId_t GIntervalTimer::GetWorldGroupId() const {
    return GetSchemaValue<WorldGroupId_t>(m_ptr, "IntervalTimer", "m_nWorldGroupId");
}
void GIntervalTimer::SetWorldGroupId(WorldGroupId_t value) {
    SetSchemaValue(m_ptr, "IntervalTimer", "m_nWorldGroupId", false, value);
}
std::string GIntervalTimer::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GIntervalTimer::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassIntervalTimer(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GIntervalTimer>("IntervalTimer")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Timestamp", &GIntervalTimer::GetTimestamp, &GIntervalTimer::SetTimestamp)
        .addProperty("WorldGroupId", &GIntervalTimer::GetWorldGroupId, &GIntervalTimer::SetWorldGroupId)
        .addFunction("ToPtr", &GIntervalTimer::ToPtr)
        .addFunction("IsValid", &GIntervalTimer::IsValid)
        .endClass();
}
GCWeaponSG556::GCWeaponSG556(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCWeaponSG556::GCWeaponSG556(void *ptr) {
    m_ptr = ptr;
}
std::string GCWeaponSG556::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCWeaponSG556::IsValid() {
    return (m_ptr != nullptr);
}
GCCSWeaponBaseGun GCWeaponSG556::GetParent() const {
    GCCSWeaponBaseGun value(m_ptr);
    return value;
}
void GCWeaponSG556::SetParent(GCCSWeaponBaseGun value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCWeaponSG556(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCWeaponSG556>("CWeaponSG556")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCWeaponSG556::GetParent, &GCWeaponSG556::SetParent)
        .addFunction("ToPtr", &GCWeaponSG556::ToPtr)
        .addFunction("IsValid", &GCWeaponSG556::IsValid)
        .endClass();
}
Gdynpitchvol_base_t::Gdynpitchvol_base_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
Gdynpitchvol_base_t::Gdynpitchvol_base_t(void *ptr) {
    m_ptr = ptr;
}
int32_t Gdynpitchvol_base_t::GetPreset() const {
    return GetSchemaValue<int32_t>(m_ptr, "dynpitchvol_base_t", "preset");
}
void Gdynpitchvol_base_t::SetPreset(int32_t value) {
    SetSchemaValue(m_ptr, "dynpitchvol_base_t", "preset", true, value);
}
int32_t Gdynpitchvol_base_t::GetPitchrun() const {
    return GetSchemaValue<int32_t>(m_ptr, "dynpitchvol_base_t", "pitchrun");
}
void Gdynpitchvol_base_t::SetPitchrun(int32_t value) {
    SetSchemaValue(m_ptr, "dynpitchvol_base_t", "pitchrun", true, value);
}
int32_t Gdynpitchvol_base_t::GetPitchstart() const {
    return GetSchemaValue<int32_t>(m_ptr, "dynpitchvol_base_t", "pitchstart");
}
void Gdynpitchvol_base_t::SetPitchstart(int32_t value) {
    SetSchemaValue(m_ptr, "dynpitchvol_base_t", "pitchstart", true, value);
}
int32_t Gdynpitchvol_base_t::GetSpinup() const {
    return GetSchemaValue<int32_t>(m_ptr, "dynpitchvol_base_t", "spinup");
}
void Gdynpitchvol_base_t::SetSpinup(int32_t value) {
    SetSchemaValue(m_ptr, "dynpitchvol_base_t", "spinup", true, value);
}
int32_t Gdynpitchvol_base_t::GetSpindown() const {
    return GetSchemaValue<int32_t>(m_ptr, "dynpitchvol_base_t", "spindown");
}
void Gdynpitchvol_base_t::SetSpindown(int32_t value) {
    SetSchemaValue(m_ptr, "dynpitchvol_base_t", "spindown", true, value);
}
int32_t Gdynpitchvol_base_t::GetVolrun() const {
    return GetSchemaValue<int32_t>(m_ptr, "dynpitchvol_base_t", "volrun");
}
void Gdynpitchvol_base_t::SetVolrun(int32_t value) {
    SetSchemaValue(m_ptr, "dynpitchvol_base_t", "volrun", true, value);
}
int32_t Gdynpitchvol_base_t::GetVolstart() const {
    return GetSchemaValue<int32_t>(m_ptr, "dynpitchvol_base_t", "volstart");
}
void Gdynpitchvol_base_t::SetVolstart(int32_t value) {
    SetSchemaValue(m_ptr, "dynpitchvol_base_t", "volstart", true, value);
}
int32_t Gdynpitchvol_base_t::GetFadein() const {
    return GetSchemaValue<int32_t>(m_ptr, "dynpitchvol_base_t", "fadein");
}
void Gdynpitchvol_base_t::SetFadein(int32_t value) {
    SetSchemaValue(m_ptr, "dynpitchvol_base_t", "fadein", true, value);
}
int32_t Gdynpitchvol_base_t::GetFadeout() const {
    return GetSchemaValue<int32_t>(m_ptr, "dynpitchvol_base_t", "fadeout");
}
void Gdynpitchvol_base_t::SetFadeout(int32_t value) {
    SetSchemaValue(m_ptr, "dynpitchvol_base_t", "fadeout", true, value);
}
int32_t Gdynpitchvol_base_t::GetLfotype() const {
    return GetSchemaValue<int32_t>(m_ptr, "dynpitchvol_base_t", "lfotype");
}
void Gdynpitchvol_base_t::SetLfotype(int32_t value) {
    SetSchemaValue(m_ptr, "dynpitchvol_base_t", "lfotype", true, value);
}
int32_t Gdynpitchvol_base_t::GetLforate() const {
    return GetSchemaValue<int32_t>(m_ptr, "dynpitchvol_base_t", "lforate");
}
void Gdynpitchvol_base_t::SetLforate(int32_t value) {
    SetSchemaValue(m_ptr, "dynpitchvol_base_t", "lforate", true, value);
}
int32_t Gdynpitchvol_base_t::GetLfomodpitch() const {
    return GetSchemaValue<int32_t>(m_ptr, "dynpitchvol_base_t", "lfomodpitch");
}
void Gdynpitchvol_base_t::SetLfomodpitch(int32_t value) {
    SetSchemaValue(m_ptr, "dynpitchvol_base_t", "lfomodpitch", true, value);
}
int32_t Gdynpitchvol_base_t::GetLfomodvol() const {
    return GetSchemaValue<int32_t>(m_ptr, "dynpitchvol_base_t", "lfomodvol");
}
void Gdynpitchvol_base_t::SetLfomodvol(int32_t value) {
    SetSchemaValue(m_ptr, "dynpitchvol_base_t", "lfomodvol", true, value);
}
int32_t Gdynpitchvol_base_t::GetCspinup() const {
    return GetSchemaValue<int32_t>(m_ptr, "dynpitchvol_base_t", "cspinup");
}
void Gdynpitchvol_base_t::SetCspinup(int32_t value) {
    SetSchemaValue(m_ptr, "dynpitchvol_base_t", "cspinup", true, value);
}
int32_t Gdynpitchvol_base_t::GetCspincount() const {
    return GetSchemaValue<int32_t>(m_ptr, "dynpitchvol_base_t", "cspincount");
}
void Gdynpitchvol_base_t::SetCspincount(int32_t value) {
    SetSchemaValue(m_ptr, "dynpitchvol_base_t", "cspincount", true, value);
}
int32_t Gdynpitchvol_base_t::GetPitch() const {
    return GetSchemaValue<int32_t>(m_ptr, "dynpitchvol_base_t", "pitch");
}
void Gdynpitchvol_base_t::SetPitch(int32_t value) {
    SetSchemaValue(m_ptr, "dynpitchvol_base_t", "pitch", true, value);
}
int32_t Gdynpitchvol_base_t::GetSpinupsav() const {
    return GetSchemaValue<int32_t>(m_ptr, "dynpitchvol_base_t", "spinupsav");
}
void Gdynpitchvol_base_t::SetSpinupsav(int32_t value) {
    SetSchemaValue(m_ptr, "dynpitchvol_base_t", "spinupsav", true, value);
}
int32_t Gdynpitchvol_base_t::GetSpindownsav() const {
    return GetSchemaValue<int32_t>(m_ptr, "dynpitchvol_base_t", "spindownsav");
}
void Gdynpitchvol_base_t::SetSpindownsav(int32_t value) {
    SetSchemaValue(m_ptr, "dynpitchvol_base_t", "spindownsav", true, value);
}
int32_t Gdynpitchvol_base_t::GetPitchfrac() const {
    return GetSchemaValue<int32_t>(m_ptr, "dynpitchvol_base_t", "pitchfrac");
}
void Gdynpitchvol_base_t::SetPitchfrac(int32_t value) {
    SetSchemaValue(m_ptr, "dynpitchvol_base_t", "pitchfrac", true, value);
}
int32_t Gdynpitchvol_base_t::GetVol() const {
    return GetSchemaValue<int32_t>(m_ptr, "dynpitchvol_base_t", "vol");
}
void Gdynpitchvol_base_t::SetVol(int32_t value) {
    SetSchemaValue(m_ptr, "dynpitchvol_base_t", "vol", true, value);
}
int32_t Gdynpitchvol_base_t::GetFadeinsav() const {
    return GetSchemaValue<int32_t>(m_ptr, "dynpitchvol_base_t", "fadeinsav");
}
void Gdynpitchvol_base_t::SetFadeinsav(int32_t value) {
    SetSchemaValue(m_ptr, "dynpitchvol_base_t", "fadeinsav", true, value);
}
int32_t Gdynpitchvol_base_t::GetFadeoutsav() const {
    return GetSchemaValue<int32_t>(m_ptr, "dynpitchvol_base_t", "fadeoutsav");
}
void Gdynpitchvol_base_t::SetFadeoutsav(int32_t value) {
    SetSchemaValue(m_ptr, "dynpitchvol_base_t", "fadeoutsav", true, value);
}
int32_t Gdynpitchvol_base_t::GetVolfrac() const {
    return GetSchemaValue<int32_t>(m_ptr, "dynpitchvol_base_t", "volfrac");
}
void Gdynpitchvol_base_t::SetVolfrac(int32_t value) {
    SetSchemaValue(m_ptr, "dynpitchvol_base_t", "volfrac", true, value);
}
int32_t Gdynpitchvol_base_t::GetLfofrac() const {
    return GetSchemaValue<int32_t>(m_ptr, "dynpitchvol_base_t", "lfofrac");
}
void Gdynpitchvol_base_t::SetLfofrac(int32_t value) {
    SetSchemaValue(m_ptr, "dynpitchvol_base_t", "lfofrac", true, value);
}
int32_t Gdynpitchvol_base_t::GetLfomult() const {
    return GetSchemaValue<int32_t>(m_ptr, "dynpitchvol_base_t", "lfomult");
}
void Gdynpitchvol_base_t::SetLfomult(int32_t value) {
    SetSchemaValue(m_ptr, "dynpitchvol_base_t", "lfomult", true, value);
}
std::string Gdynpitchvol_base_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool Gdynpitchvol_base_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassdynpitchvol_base_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<Gdynpitchvol_base_t>("dynpitchvol_base_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Preset", &Gdynpitchvol_base_t::GetPreset, &Gdynpitchvol_base_t::SetPreset)
        .addProperty("Pitchrun", &Gdynpitchvol_base_t::GetPitchrun, &Gdynpitchvol_base_t::SetPitchrun)
        .addProperty("Pitchstart", &Gdynpitchvol_base_t::GetPitchstart, &Gdynpitchvol_base_t::SetPitchstart)
        .addProperty("Spinup", &Gdynpitchvol_base_t::GetSpinup, &Gdynpitchvol_base_t::SetSpinup)
        .addProperty("Spindown", &Gdynpitchvol_base_t::GetSpindown, &Gdynpitchvol_base_t::SetSpindown)
        .addProperty("Volrun", &Gdynpitchvol_base_t::GetVolrun, &Gdynpitchvol_base_t::SetVolrun)
        .addProperty("Volstart", &Gdynpitchvol_base_t::GetVolstart, &Gdynpitchvol_base_t::SetVolstart)
        .addProperty("Fadein", &Gdynpitchvol_base_t::GetFadein, &Gdynpitchvol_base_t::SetFadein)
        .addProperty("Fadeout", &Gdynpitchvol_base_t::GetFadeout, &Gdynpitchvol_base_t::SetFadeout)
        .addProperty("Lfotype", &Gdynpitchvol_base_t::GetLfotype, &Gdynpitchvol_base_t::SetLfotype)
        .addProperty("Lforate", &Gdynpitchvol_base_t::GetLforate, &Gdynpitchvol_base_t::SetLforate)
        .addProperty("Lfomodpitch", &Gdynpitchvol_base_t::GetLfomodpitch, &Gdynpitchvol_base_t::SetLfomodpitch)
        .addProperty("Lfomodvol", &Gdynpitchvol_base_t::GetLfomodvol, &Gdynpitchvol_base_t::SetLfomodvol)
        .addProperty("Cspinup", &Gdynpitchvol_base_t::GetCspinup, &Gdynpitchvol_base_t::SetCspinup)
        .addProperty("Cspincount", &Gdynpitchvol_base_t::GetCspincount, &Gdynpitchvol_base_t::SetCspincount)
        .addProperty("Pitch", &Gdynpitchvol_base_t::GetPitch, &Gdynpitchvol_base_t::SetPitch)
        .addProperty("Spinupsav", &Gdynpitchvol_base_t::GetSpinupsav, &Gdynpitchvol_base_t::SetSpinupsav)
        .addProperty("Spindownsav", &Gdynpitchvol_base_t::GetSpindownsav, &Gdynpitchvol_base_t::SetSpindownsav)
        .addProperty("Pitchfrac", &Gdynpitchvol_base_t::GetPitchfrac, &Gdynpitchvol_base_t::SetPitchfrac)
        .addProperty("Vol", &Gdynpitchvol_base_t::GetVol, &Gdynpitchvol_base_t::SetVol)
        .addProperty("Fadeinsav", &Gdynpitchvol_base_t::GetFadeinsav, &Gdynpitchvol_base_t::SetFadeinsav)
        .addProperty("Fadeoutsav", &Gdynpitchvol_base_t::GetFadeoutsav, &Gdynpitchvol_base_t::SetFadeoutsav)
        .addProperty("Volfrac", &Gdynpitchvol_base_t::GetVolfrac, &Gdynpitchvol_base_t::SetVolfrac)
        .addProperty("Lfofrac", &Gdynpitchvol_base_t::GetLfofrac, &Gdynpitchvol_base_t::SetLfofrac)
        .addProperty("Lfomult", &Gdynpitchvol_base_t::GetLfomult, &Gdynpitchvol_base_t::SetLfomult)
        .addFunction("ToPtr", &Gdynpitchvol_base_t::ToPtr)
        .addFunction("IsValid", &Gdynpitchvol_base_t::IsValid)
        .endClass();
}
GCDynamicLight::GCDynamicLight(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCDynamicLight::GCDynamicLight(void *ptr) {
    m_ptr = ptr;
}
uint8_t GCDynamicLight::GetActualFlags() const {
    return GetSchemaValue<uint8_t>(m_ptr, "CDynamicLight", "m_ActualFlags");
}
void GCDynamicLight::SetActualFlags(uint8_t value) {
    SetSchemaValue(m_ptr, "CDynamicLight", "m_ActualFlags", false, value);
}
uint8_t GCDynamicLight::GetFlags() const {
    return GetSchemaValue<uint8_t>(m_ptr, "CDynamicLight", "m_Flags");
}
void GCDynamicLight::SetFlags(uint8_t value) {
    SetSchemaValue(m_ptr, "CDynamicLight", "m_Flags", false, value);
}
uint8_t GCDynamicLight::GetLightStyle() const {
    return GetSchemaValue<uint8_t>(m_ptr, "CDynamicLight", "m_LightStyle");
}
void GCDynamicLight::SetLightStyle(uint8_t value) {
    SetSchemaValue(m_ptr, "CDynamicLight", "m_LightStyle", false, value);
}
bool GCDynamicLight::GetOn() const {
    return GetSchemaValue<bool>(m_ptr, "CDynamicLight", "m_On");
}
void GCDynamicLight::SetOn(bool value) {
    SetSchemaValue(m_ptr, "CDynamicLight", "m_On", false, value);
}
float GCDynamicLight::GetRadius() const {
    return GetSchemaValue<float>(m_ptr, "CDynamicLight", "m_Radius");
}
void GCDynamicLight::SetRadius(float value) {
    SetSchemaValue(m_ptr, "CDynamicLight", "m_Radius", false, value);
}
int32_t GCDynamicLight::GetExponent() const {
    return GetSchemaValue<int32_t>(m_ptr, "CDynamicLight", "m_Exponent");
}
void GCDynamicLight::SetExponent(int32_t value) {
    SetSchemaValue(m_ptr, "CDynamicLight", "m_Exponent", false, value);
}
float GCDynamicLight::GetInnerAngle() const {
    return GetSchemaValue<float>(m_ptr, "CDynamicLight", "m_InnerAngle");
}
void GCDynamicLight::SetInnerAngle(float value) {
    SetSchemaValue(m_ptr, "CDynamicLight", "m_InnerAngle", false, value);
}
float GCDynamicLight::GetOuterAngle() const {
    return GetSchemaValue<float>(m_ptr, "CDynamicLight", "m_OuterAngle");
}
void GCDynamicLight::SetOuterAngle(float value) {
    SetSchemaValue(m_ptr, "CDynamicLight", "m_OuterAngle", false, value);
}
float GCDynamicLight::GetSpotRadius() const {
    return GetSchemaValue<float>(m_ptr, "CDynamicLight", "m_SpotRadius");
}
void GCDynamicLight::SetSpotRadius(float value) {
    SetSchemaValue(m_ptr, "CDynamicLight", "m_SpotRadius", false, value);
}
std::string GCDynamicLight::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCDynamicLight::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseModelEntity GCDynamicLight::GetParent() const {
    GCBaseModelEntity value(m_ptr);
    return value;
}
void GCDynamicLight::SetParent(GCBaseModelEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCDynamicLight(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCDynamicLight>("CDynamicLight")
        .addConstructor<void (*)(std::string)>()
        .addProperty("ActualFlags", &GCDynamicLight::GetActualFlags, &GCDynamicLight::SetActualFlags)
        .addProperty("Flags", &GCDynamicLight::GetFlags, &GCDynamicLight::SetFlags)
        .addProperty("LightStyle", &GCDynamicLight::GetLightStyle, &GCDynamicLight::SetLightStyle)
        .addProperty("On", &GCDynamicLight::GetOn, &GCDynamicLight::SetOn)
        .addProperty("Radius", &GCDynamicLight::GetRadius, &GCDynamicLight::SetRadius)
        .addProperty("Exponent", &GCDynamicLight::GetExponent, &GCDynamicLight::SetExponent)
        .addProperty("InnerAngle", &GCDynamicLight::GetInnerAngle, &GCDynamicLight::SetInnerAngle)
        .addProperty("OuterAngle", &GCDynamicLight::GetOuterAngle, &GCDynamicLight::SetOuterAngle)
        .addProperty("SpotRadius", &GCDynamicLight::GetSpotRadius, &GCDynamicLight::SetSpotRadius)
        .addProperty("Parent", &GCDynamicLight::GetParent, &GCDynamicLight::SetParent)
        .addFunction("ToPtr", &GCDynamicLight::ToPtr)
        .addFunction("IsValid", &GCDynamicLight::IsValid)
        .endClass();
}
GCWeaponP90::GCWeaponP90(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCWeaponP90::GCWeaponP90(void *ptr) {
    m_ptr = ptr;
}
std::string GCWeaponP90::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCWeaponP90::IsValid() {
    return (m_ptr != nullptr);
}
GCCSWeaponBaseGun GCWeaponP90::GetParent() const {
    GCCSWeaponBaseGun value(m_ptr);
    return value;
}
void GCWeaponP90::SetParent(GCCSWeaponBaseGun value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCWeaponP90(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCWeaponP90>("CWeaponP90")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCWeaponP90::GetParent, &GCWeaponP90::SetParent)
        .addFunction("ToPtr", &GCWeaponP90::ToPtr)
        .addFunction("IsValid", &GCWeaponP90::IsValid)
        .endClass();
}
GCTriggerToggleSave::GCTriggerToggleSave(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCTriggerToggleSave::GCTriggerToggleSave(void *ptr) {
    m_ptr = ptr;
}
std::string GCTriggerToggleSave::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCTriggerToggleSave::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseTrigger GCTriggerToggleSave::GetParent() const {
    GCBaseTrigger value(m_ptr);
    return value;
}
void GCTriggerToggleSave::SetParent(GCBaseTrigger value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCTriggerToggleSave(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCTriggerToggleSave>("CTriggerToggleSave")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCTriggerToggleSave::GetParent, &GCTriggerToggleSave::SetParent)
        .addFunction("ToPtr", &GCTriggerToggleSave::ToPtr)
        .addFunction("IsValid", &GCTriggerToggleSave::IsValid)
        .endClass();
}
GCPrecipitation::GCPrecipitation(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCPrecipitation::GCPrecipitation(void *ptr) {
    m_ptr = ptr;
}
std::string GCPrecipitation::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCPrecipitation::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseTrigger GCPrecipitation::GetParent() const {
    GCBaseTrigger value(m_ptr);
    return value;
}
void GCPrecipitation::SetParent(GCBaseTrigger value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCPrecipitation(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCPrecipitation>("CPrecipitation")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCPrecipitation::GetParent, &GCPrecipitation::SetParent)
        .addFunction("ToPtr", &GCPrecipitation::ToPtr)
        .addFunction("IsValid", &GCPrecipitation::IsValid)
        .endClass();
}
GCPointServerCommand::GCPointServerCommand(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCPointServerCommand::GCPointServerCommand(void *ptr) {
    m_ptr = ptr;
}
std::string GCPointServerCommand::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCPointServerCommand::IsValid() {
    return (m_ptr != nullptr);
}
GCPointEntity GCPointServerCommand::GetParent() const {
    GCPointEntity value(m_ptr);
    return value;
}
void GCPointServerCommand::SetParent(GCPointEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCPointServerCommand(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCPointServerCommand>("CPointServerCommand")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCPointServerCommand::GetParent, &GCPointServerCommand::SetParent)
        .addFunction("ToPtr", &GCPointServerCommand::ToPtr)
        .addFunction("IsValid", &GCPointServerCommand::IsValid)
        .endClass();
}
GCCSGO_TeamIntroCharacterPosition::GCCSGO_TeamIntroCharacterPosition(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCCSGO_TeamIntroCharacterPosition::GCCSGO_TeamIntroCharacterPosition(void *ptr) {
    m_ptr = ptr;
}
std::string GCCSGO_TeamIntroCharacterPosition::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCCSGO_TeamIntroCharacterPosition::IsValid() {
    return (m_ptr != nullptr);
}
GCCSGO_TeamPreviewCharacterPosition GCCSGO_TeamIntroCharacterPosition::GetParent() const {
    GCCSGO_TeamPreviewCharacterPosition value(m_ptr);
    return value;
}
void GCCSGO_TeamIntroCharacterPosition::SetParent(GCCSGO_TeamPreviewCharacterPosition value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCCSGO_TeamIntroCharacterPosition(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCCSGO_TeamIntroCharacterPosition>("CCSGO_TeamIntroCharacterPosition")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCCSGO_TeamIntroCharacterPosition::GetParent, &GCCSGO_TeamIntroCharacterPosition::SetParent)
        .addFunction("ToPtr", &GCCSGO_TeamIntroCharacterPosition::ToPtr)
        .addFunction("IsValid", &GCCSGO_TeamIntroCharacterPosition::IsValid)
        .endClass();
}
GCLogicCollisionPair::GCLogicCollisionPair(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCLogicCollisionPair::GCLogicCollisionPair(void *ptr) {
    m_ptr = ptr;
}
std::string GCLogicCollisionPair::GetNameAttach1() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CLogicCollisionPair", "m_nameAttach1").String();
}
void GCLogicCollisionPair::SetNameAttach1(std::string value) {
    SetSchemaValue(m_ptr, "CLogicCollisionPair", "m_nameAttach1", false, CUtlSymbolLarge(value.c_str()));
}
std::string GCLogicCollisionPair::GetNameAttach2() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CLogicCollisionPair", "m_nameAttach2").String();
}
void GCLogicCollisionPair::SetNameAttach2(std::string value) {
    SetSchemaValue(m_ptr, "CLogicCollisionPair", "m_nameAttach2", false, CUtlSymbolLarge(value.c_str()));
}
bool GCLogicCollisionPair::GetSupportMultipleEntitiesWithSameName() const {
    return GetSchemaValue<bool>(m_ptr, "CLogicCollisionPair", "m_supportMultipleEntitiesWithSameName");
}
void GCLogicCollisionPair::SetSupportMultipleEntitiesWithSameName(bool value) {
    SetSchemaValue(m_ptr, "CLogicCollisionPair", "m_supportMultipleEntitiesWithSameName", false, value);
}
bool GCLogicCollisionPair::GetDisabled() const {
    return GetSchemaValue<bool>(m_ptr, "CLogicCollisionPair", "m_disabled");
}
void GCLogicCollisionPair::SetDisabled(bool value) {
    SetSchemaValue(m_ptr, "CLogicCollisionPair", "m_disabled", false, value);
}
bool GCLogicCollisionPair::GetSucceeded() const {
    return GetSchemaValue<bool>(m_ptr, "CLogicCollisionPair", "m_succeeded");
}
void GCLogicCollisionPair::SetSucceeded(bool value) {
    SetSchemaValue(m_ptr, "CLogicCollisionPair", "m_succeeded", false, value);
}
std::string GCLogicCollisionPair::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCLogicCollisionPair::IsValid() {
    return (m_ptr != nullptr);
}
GCLogicalEntity GCLogicCollisionPair::GetParent() const {
    GCLogicalEntity value(m_ptr);
    return value;
}
void GCLogicCollisionPair::SetParent(GCLogicalEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCLogicCollisionPair(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCLogicCollisionPair>("CLogicCollisionPair")
        .addConstructor<void (*)(std::string)>()
        .addProperty("NameAttach1", &GCLogicCollisionPair::GetNameAttach1, &GCLogicCollisionPair::SetNameAttach1)
        .addProperty("NameAttach2", &GCLogicCollisionPair::GetNameAttach2, &GCLogicCollisionPair::SetNameAttach2)
        .addProperty("SupportMultipleEntitiesWithSameName", &GCLogicCollisionPair::GetSupportMultipleEntitiesWithSameName, &GCLogicCollisionPair::SetSupportMultipleEntitiesWithSameName)
        .addProperty("Disabled", &GCLogicCollisionPair::GetDisabled, &GCLogicCollisionPair::SetDisabled)
        .addProperty("Succeeded", &GCLogicCollisionPair::GetSucceeded, &GCLogicCollisionPair::SetSucceeded)
        .addProperty("Parent", &GCLogicCollisionPair::GetParent, &GCLogicCollisionPair::SetParent)
        .addFunction("ToPtr", &GCLogicCollisionPair::ToPtr)
        .addFunction("IsValid", &GCLogicCollisionPair::IsValid)
        .endClass();
}
GCSkeletonInstance::GCSkeletonInstance(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCSkeletonInstance::GCSkeletonInstance(void *ptr) {
    m_ptr = ptr;
}
GCModelState GCSkeletonInstance::GetModelState() const {
    GCModelState value(GetSchemaPtr(m_ptr, "CSkeletonInstance", "m_modelState"));
    return value;
}
void GCSkeletonInstance::SetModelState(GCModelState value) {
    SetSchemaValue(m_ptr, "CSkeletonInstance", "m_modelState", false, value);
}
bool GCSkeletonInstance::GetIsAnimationEnabled() const {
    return GetSchemaValue<bool>(m_ptr, "CSkeletonInstance", "m_bIsAnimationEnabled");
}
void GCSkeletonInstance::SetIsAnimationEnabled(bool value) {
    SetSchemaValue(m_ptr, "CSkeletonInstance", "m_bIsAnimationEnabled", false, value);
}
bool GCSkeletonInstance::GetUseParentRenderBounds() const {
    return GetSchemaValue<bool>(m_ptr, "CSkeletonInstance", "m_bUseParentRenderBounds");
}
void GCSkeletonInstance::SetUseParentRenderBounds(bool value) {
    SetSchemaValue(m_ptr, "CSkeletonInstance", "m_bUseParentRenderBounds", false, value);
}
bool GCSkeletonInstance::GetDisableSolidCollisionsForHierarchy() const {
    return GetSchemaValue<bool>(m_ptr, "CSkeletonInstance", "m_bDisableSolidCollisionsForHierarchy");
}
void GCSkeletonInstance::SetDisableSolidCollisionsForHierarchy(bool value) {
    SetSchemaValue(m_ptr, "CSkeletonInstance", "m_bDisableSolidCollisionsForHierarchy", false, value);
}
CUtlStringToken GCSkeletonInstance::GetMaterialGroup() const {
    return GetSchemaValue<CUtlStringToken>(m_ptr, "CSkeletonInstance", "m_materialGroup");
}
void GCSkeletonInstance::SetMaterialGroup(CUtlStringToken value) {
    SetSchemaValue(m_ptr, "CSkeletonInstance", "m_materialGroup", false, value);
}
uint8_t GCSkeletonInstance::GetHitboxSet() const {
    return GetSchemaValue<uint8_t>(m_ptr, "CSkeletonInstance", "m_nHitboxSet");
}
void GCSkeletonInstance::SetHitboxSet(uint8_t value) {
    SetSchemaValue(m_ptr, "CSkeletonInstance", "m_nHitboxSet", false, value);
}
std::string GCSkeletonInstance::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCSkeletonInstance::IsValid() {
    return (m_ptr != nullptr);
}
GCGameSceneNode GCSkeletonInstance::GetParent() const {
    GCGameSceneNode value(m_ptr);
    return value;
}
void GCSkeletonInstance::SetParent(GCGameSceneNode value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCSkeletonInstance(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCSkeletonInstance>("CSkeletonInstance")
        .addConstructor<void (*)(std::string)>()
        .addProperty("ModelState", &GCSkeletonInstance::GetModelState, &GCSkeletonInstance::SetModelState)
        .addProperty("IsAnimationEnabled", &GCSkeletonInstance::GetIsAnimationEnabled, &GCSkeletonInstance::SetIsAnimationEnabled)
        .addProperty("UseParentRenderBounds", &GCSkeletonInstance::GetUseParentRenderBounds, &GCSkeletonInstance::SetUseParentRenderBounds)
        .addProperty("DisableSolidCollisionsForHierarchy", &GCSkeletonInstance::GetDisableSolidCollisionsForHierarchy, &GCSkeletonInstance::SetDisableSolidCollisionsForHierarchy)
        .addProperty("MaterialGroup", &GCSkeletonInstance::GetMaterialGroup, &GCSkeletonInstance::SetMaterialGroup)
        .addProperty("HitboxSet", &GCSkeletonInstance::GetHitboxSet, &GCSkeletonInstance::SetHitboxSet)
        .addProperty("Parent", &GCSkeletonInstance::GetParent, &GCSkeletonInstance::SetParent)
        .addFunction("ToPtr", &GCSkeletonInstance::ToPtr)
        .addFunction("IsValid", &GCSkeletonInstance::IsValid)
        .endClass();
}
GCPhysicsProp::GCPhysicsProp(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCPhysicsProp::GCPhysicsProp(void *ptr) {
    m_ptr = ptr;
}
GCEntityIOOutput GCPhysicsProp::GetMotionEnabled() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CPhysicsProp", "m_MotionEnabled"));
    return value;
}
void GCPhysicsProp::SetMotionEnabled(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CPhysicsProp", "m_MotionEnabled", false, value);
}
GCEntityIOOutput GCPhysicsProp::GetOnAwakened() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CPhysicsProp", "m_OnAwakened"));
    return value;
}
void GCPhysicsProp::SetOnAwakened(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CPhysicsProp", "m_OnAwakened", false, value);
}
GCEntityIOOutput GCPhysicsProp::GetOnAwake() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CPhysicsProp", "m_OnAwake"));
    return value;
}
void GCPhysicsProp::SetOnAwake(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CPhysicsProp", "m_OnAwake", false, value);
}
GCEntityIOOutput GCPhysicsProp::GetOnAsleep() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CPhysicsProp", "m_OnAsleep"));
    return value;
}
void GCPhysicsProp::SetOnAsleep(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CPhysicsProp", "m_OnAsleep", false, value);
}
GCEntityIOOutput GCPhysicsProp::GetOnPlayerUse() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CPhysicsProp", "m_OnPlayerUse"));
    return value;
}
void GCPhysicsProp::SetOnPlayerUse(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CPhysicsProp", "m_OnPlayerUse", false, value);
}
GCEntityIOOutput GCPhysicsProp::GetOnOutOfWorld() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CPhysicsProp", "m_OnOutOfWorld"));
    return value;
}
void GCPhysicsProp::SetOnOutOfWorld(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CPhysicsProp", "m_OnOutOfWorld", false, value);
}
GCEntityIOOutput GCPhysicsProp::GetOnPlayerPickup() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CPhysicsProp", "m_OnPlayerPickup"));
    return value;
}
void GCPhysicsProp::SetOnPlayerPickup(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CPhysicsProp", "m_OnPlayerPickup", false, value);
}
bool GCPhysicsProp::GetForceNavIgnore() const {
    return GetSchemaValue<bool>(m_ptr, "CPhysicsProp", "m_bForceNavIgnore");
}
void GCPhysicsProp::SetForceNavIgnore(bool value) {
    SetSchemaValue(m_ptr, "CPhysicsProp", "m_bForceNavIgnore", false, value);
}
bool GCPhysicsProp::GetNoNavmeshBlocker() const {
    return GetSchemaValue<bool>(m_ptr, "CPhysicsProp", "m_bNoNavmeshBlocker");
}
void GCPhysicsProp::SetNoNavmeshBlocker(bool value) {
    SetSchemaValue(m_ptr, "CPhysicsProp", "m_bNoNavmeshBlocker", false, value);
}
bool GCPhysicsProp::GetForceNpcExclude() const {
    return GetSchemaValue<bool>(m_ptr, "CPhysicsProp", "m_bForceNpcExclude");
}
void GCPhysicsProp::SetForceNpcExclude(bool value) {
    SetSchemaValue(m_ptr, "CPhysicsProp", "m_bForceNpcExclude", false, value);
}
float GCPhysicsProp::GetMassScale() const {
    return GetSchemaValue<float>(m_ptr, "CPhysicsProp", "m_massScale");
}
void GCPhysicsProp::SetMassScale(float value) {
    SetSchemaValue(m_ptr, "CPhysicsProp", "m_massScale", false, value);
}
float GCPhysicsProp::GetInertiaScale() const {
    return GetSchemaValue<float>(m_ptr, "CPhysicsProp", "m_inertiaScale");
}
void GCPhysicsProp::SetInertiaScale(float value) {
    SetSchemaValue(m_ptr, "CPhysicsProp", "m_inertiaScale", false, value);
}
float GCPhysicsProp::GetBuoyancyScale() const {
    return GetSchemaValue<float>(m_ptr, "CPhysicsProp", "m_buoyancyScale");
}
void GCPhysicsProp::SetBuoyancyScale(float value) {
    SetSchemaValue(m_ptr, "CPhysicsProp", "m_buoyancyScale", false, value);
}
int32_t GCPhysicsProp::GetDamageType() const {
    return GetSchemaValue<int32_t>(m_ptr, "CPhysicsProp", "m_damageType");
}
void GCPhysicsProp::SetDamageType(int32_t value) {
    SetSchemaValue(m_ptr, "CPhysicsProp", "m_damageType", false, value);
}
int32_t GCPhysicsProp::GetDamageToEnableMotion() const {
    return GetSchemaValue<int32_t>(m_ptr, "CPhysicsProp", "m_damageToEnableMotion");
}
void GCPhysicsProp::SetDamageToEnableMotion(int32_t value) {
    SetSchemaValue(m_ptr, "CPhysicsProp", "m_damageToEnableMotion", false, value);
}
float GCPhysicsProp::GetForceToEnableMotion() const {
    return GetSchemaValue<float>(m_ptr, "CPhysicsProp", "m_flForceToEnableMotion");
}
void GCPhysicsProp::SetForceToEnableMotion(float value) {
    SetSchemaValue(m_ptr, "CPhysicsProp", "m_flForceToEnableMotion", false, value);
}
bool GCPhysicsProp::GetThrownByPlayer() const {
    return GetSchemaValue<bool>(m_ptr, "CPhysicsProp", "m_bThrownByPlayer");
}
void GCPhysicsProp::SetThrownByPlayer(bool value) {
    SetSchemaValue(m_ptr, "CPhysicsProp", "m_bThrownByPlayer", false, value);
}
bool GCPhysicsProp::GetDroppedByPlayer() const {
    return GetSchemaValue<bool>(m_ptr, "CPhysicsProp", "m_bDroppedByPlayer");
}
void GCPhysicsProp::SetDroppedByPlayer(bool value) {
    SetSchemaValue(m_ptr, "CPhysicsProp", "m_bDroppedByPlayer", false, value);
}
bool GCPhysicsProp::GetTouchedByPlayer() const {
    return GetSchemaValue<bool>(m_ptr, "CPhysicsProp", "m_bTouchedByPlayer");
}
void GCPhysicsProp::SetTouchedByPlayer(bool value) {
    SetSchemaValue(m_ptr, "CPhysicsProp", "m_bTouchedByPlayer", false, value);
}
bool GCPhysicsProp::GetFirstCollisionAfterLaunch() const {
    return GetSchemaValue<bool>(m_ptr, "CPhysicsProp", "m_bFirstCollisionAfterLaunch");
}
void GCPhysicsProp::SetFirstCollisionAfterLaunch(bool value) {
    SetSchemaValue(m_ptr, "CPhysicsProp", "m_bFirstCollisionAfterLaunch", false, value);
}
int32_t GCPhysicsProp::GetExploitableByPlayer() const {
    return GetSchemaValue<int32_t>(m_ptr, "CPhysicsProp", "m_iExploitableByPlayer");
}
void GCPhysicsProp::SetExploitableByPlayer(int32_t value) {
    SetSchemaValue(m_ptr, "CPhysicsProp", "m_iExploitableByPlayer", false, value);
}
bool GCPhysicsProp::GetHasBeenAwakened() const {
    return GetSchemaValue<bool>(m_ptr, "CPhysicsProp", "m_bHasBeenAwakened");
}
void GCPhysicsProp::SetHasBeenAwakened(bool value) {
    SetSchemaValue(m_ptr, "CPhysicsProp", "m_bHasBeenAwakened", false, value);
}
bool GCPhysicsProp::GetIsOverrideProp() const {
    return GetSchemaValue<bool>(m_ptr, "CPhysicsProp", "m_bIsOverrideProp");
}
void GCPhysicsProp::SetIsOverrideProp(bool value) {
    SetSchemaValue(m_ptr, "CPhysicsProp", "m_bIsOverrideProp", false, value);
}
float GCPhysicsProp::GetNextCheckDisableMotionContactsTime() const {
    return GetSchemaValue<float>(m_ptr, "CPhysicsProp", "m_fNextCheckDisableMotionContactsTime");
}
void GCPhysicsProp::SetNextCheckDisableMotionContactsTime(float value) {
    SetSchemaValue(m_ptr, "CPhysicsProp", "m_fNextCheckDisableMotionContactsTime", false, value);
}
int32_t GCPhysicsProp::GetInitialGlowState() const {
    return GetSchemaValue<int32_t>(m_ptr, "CPhysicsProp", "m_iInitialGlowState");
}
void GCPhysicsProp::SetInitialGlowState(int32_t value) {
    SetSchemaValue(m_ptr, "CPhysicsProp", "m_iInitialGlowState", false, value);
}
int32_t GCPhysicsProp::GetGlowRange() const {
    return GetSchemaValue<int32_t>(m_ptr, "CPhysicsProp", "m_nGlowRange");
}
void GCPhysicsProp::SetGlowRange(int32_t value) {
    SetSchemaValue(m_ptr, "CPhysicsProp", "m_nGlowRange", false, value);
}
int32_t GCPhysicsProp::GetGlowRangeMin() const {
    return GetSchemaValue<int32_t>(m_ptr, "CPhysicsProp", "m_nGlowRangeMin");
}
void GCPhysicsProp::SetGlowRangeMin(int32_t value) {
    SetSchemaValue(m_ptr, "CPhysicsProp", "m_nGlowRangeMin", false, value);
}
Color GCPhysicsProp::GetGlowColor() const {
    return GetSchemaValue<Color>(m_ptr, "CPhysicsProp", "m_glowColor");
}
void GCPhysicsProp::SetGlowColor(Color value) {
    SetSchemaValue(m_ptr, "CPhysicsProp", "m_glowColor", false, value);
}
bool GCPhysicsProp::GetShouldAutoConvertBackFromDebris() const {
    return GetSchemaValue<bool>(m_ptr, "CPhysicsProp", "m_bShouldAutoConvertBackFromDebris");
}
void GCPhysicsProp::SetShouldAutoConvertBackFromDebris(bool value) {
    SetSchemaValue(m_ptr, "CPhysicsProp", "m_bShouldAutoConvertBackFromDebris", false, value);
}
bool GCPhysicsProp::GetMuteImpactEffects() const {
    return GetSchemaValue<bool>(m_ptr, "CPhysicsProp", "m_bMuteImpactEffects");
}
void GCPhysicsProp::SetMuteImpactEffects(bool value) {
    SetSchemaValue(m_ptr, "CPhysicsProp", "m_bMuteImpactEffects", false, value);
}
bool GCPhysicsProp::GetAcceptDamageFromHeldObjects() const {
    return GetSchemaValue<bool>(m_ptr, "CPhysicsProp", "m_bAcceptDamageFromHeldObjects");
}
void GCPhysicsProp::SetAcceptDamageFromHeldObjects(bool value) {
    SetSchemaValue(m_ptr, "CPhysicsProp", "m_bAcceptDamageFromHeldObjects", false, value);
}
bool GCPhysicsProp::GetEnableUseOutput() const {
    return GetSchemaValue<bool>(m_ptr, "CPhysicsProp", "m_bEnableUseOutput");
}
void GCPhysicsProp::SetEnableUseOutput(bool value) {
    SetSchemaValue(m_ptr, "CPhysicsProp", "m_bEnableUseOutput", false, value);
}
bool GCPhysicsProp::GetAwake() const {
    return GetSchemaValue<bool>(m_ptr, "CPhysicsProp", "m_bAwake");
}
void GCPhysicsProp::SetAwake(bool value) {
    SetSchemaValue(m_ptr, "CPhysicsProp", "m_bAwake", false, value);
}
std::string GCPhysicsProp::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCPhysicsProp::IsValid() {
    return (m_ptr != nullptr);
}
GCBreakableProp GCPhysicsProp::GetParent() const {
    GCBreakableProp value(m_ptr);
    return value;
}
void GCPhysicsProp::SetParent(GCBreakableProp value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCPhysicsProp(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCPhysicsProp>("CPhysicsProp")
        .addConstructor<void (*)(std::string)>()
        .addProperty("MotionEnabled", &GCPhysicsProp::GetMotionEnabled, &GCPhysicsProp::SetMotionEnabled)
        .addProperty("OnAwakened", &GCPhysicsProp::GetOnAwakened, &GCPhysicsProp::SetOnAwakened)
        .addProperty("OnAwake", &GCPhysicsProp::GetOnAwake, &GCPhysicsProp::SetOnAwake)
        .addProperty("OnAsleep", &GCPhysicsProp::GetOnAsleep, &GCPhysicsProp::SetOnAsleep)
        .addProperty("OnPlayerUse", &GCPhysicsProp::GetOnPlayerUse, &GCPhysicsProp::SetOnPlayerUse)
        .addProperty("OnOutOfWorld", &GCPhysicsProp::GetOnOutOfWorld, &GCPhysicsProp::SetOnOutOfWorld)
        .addProperty("OnPlayerPickup", &GCPhysicsProp::GetOnPlayerPickup, &GCPhysicsProp::SetOnPlayerPickup)
        .addProperty("ForceNavIgnore", &GCPhysicsProp::GetForceNavIgnore, &GCPhysicsProp::SetForceNavIgnore)
        .addProperty("NoNavmeshBlocker", &GCPhysicsProp::GetNoNavmeshBlocker, &GCPhysicsProp::SetNoNavmeshBlocker)
        .addProperty("ForceNpcExclude", &GCPhysicsProp::GetForceNpcExclude, &GCPhysicsProp::SetForceNpcExclude)
        .addProperty("MassScale", &GCPhysicsProp::GetMassScale, &GCPhysicsProp::SetMassScale)
        .addProperty("InertiaScale", &GCPhysicsProp::GetInertiaScale, &GCPhysicsProp::SetInertiaScale)
        .addProperty("BuoyancyScale", &GCPhysicsProp::GetBuoyancyScale, &GCPhysicsProp::SetBuoyancyScale)
        .addProperty("DamageType", &GCPhysicsProp::GetDamageType, &GCPhysicsProp::SetDamageType)
        .addProperty("DamageToEnableMotion", &GCPhysicsProp::GetDamageToEnableMotion, &GCPhysicsProp::SetDamageToEnableMotion)
        .addProperty("ForceToEnableMotion", &GCPhysicsProp::GetForceToEnableMotion, &GCPhysicsProp::SetForceToEnableMotion)
        .addProperty("ThrownByPlayer", &GCPhysicsProp::GetThrownByPlayer, &GCPhysicsProp::SetThrownByPlayer)
        .addProperty("DroppedByPlayer", &GCPhysicsProp::GetDroppedByPlayer, &GCPhysicsProp::SetDroppedByPlayer)
        .addProperty("TouchedByPlayer", &GCPhysicsProp::GetTouchedByPlayer, &GCPhysicsProp::SetTouchedByPlayer)
        .addProperty("FirstCollisionAfterLaunch", &GCPhysicsProp::GetFirstCollisionAfterLaunch, &GCPhysicsProp::SetFirstCollisionAfterLaunch)
        .addProperty("ExploitableByPlayer", &GCPhysicsProp::GetExploitableByPlayer, &GCPhysicsProp::SetExploitableByPlayer)
        .addProperty("HasBeenAwakened", &GCPhysicsProp::GetHasBeenAwakened, &GCPhysicsProp::SetHasBeenAwakened)
        .addProperty("IsOverrideProp", &GCPhysicsProp::GetIsOverrideProp, &GCPhysicsProp::SetIsOverrideProp)
        .addProperty("NextCheckDisableMotionContactsTime", &GCPhysicsProp::GetNextCheckDisableMotionContactsTime, &GCPhysicsProp::SetNextCheckDisableMotionContactsTime)
        .addProperty("InitialGlowState", &GCPhysicsProp::GetInitialGlowState, &GCPhysicsProp::SetInitialGlowState)
        .addProperty("GlowRange", &GCPhysicsProp::GetGlowRange, &GCPhysicsProp::SetGlowRange)
        .addProperty("GlowRangeMin", &GCPhysicsProp::GetGlowRangeMin, &GCPhysicsProp::SetGlowRangeMin)
        .addProperty("GlowColor", &GCPhysicsProp::GetGlowColor, &GCPhysicsProp::SetGlowColor)
        .addProperty("ShouldAutoConvertBackFromDebris", &GCPhysicsProp::GetShouldAutoConvertBackFromDebris, &GCPhysicsProp::SetShouldAutoConvertBackFromDebris)
        .addProperty("MuteImpactEffects", &GCPhysicsProp::GetMuteImpactEffects, &GCPhysicsProp::SetMuteImpactEffects)
        .addProperty("AcceptDamageFromHeldObjects", &GCPhysicsProp::GetAcceptDamageFromHeldObjects, &GCPhysicsProp::SetAcceptDamageFromHeldObjects)
        .addProperty("EnableUseOutput", &GCPhysicsProp::GetEnableUseOutput, &GCPhysicsProp::SetEnableUseOutput)
        .addProperty("Awake", &GCPhysicsProp::GetAwake, &GCPhysicsProp::SetAwake)
        .addProperty("Parent", &GCPhysicsProp::GetParent, &GCPhysicsProp::SetParent)
        .addFunction("ToPtr", &GCPhysicsProp::ToPtr)
        .addFunction("IsValid", &GCPhysicsProp::IsValid)
        .endClass();
}
GCFuncWall::GCFuncWall(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCFuncWall::GCFuncWall(void *ptr) {
    m_ptr = ptr;
}
int32_t GCFuncWall::GetState() const {
    return GetSchemaValue<int32_t>(m_ptr, "CFuncWall", "m_nState");
}
void GCFuncWall::SetState(int32_t value) {
    SetSchemaValue(m_ptr, "CFuncWall", "m_nState", false, value);
}
std::string GCFuncWall::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCFuncWall::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseModelEntity GCFuncWall::GetParent() const {
    GCBaseModelEntity value(m_ptr);
    return value;
}
void GCFuncWall::SetParent(GCBaseModelEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCFuncWall(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCFuncWall>("CFuncWall")
        .addConstructor<void (*)(std::string)>()
        .addProperty("State", &GCFuncWall::GetState, &GCFuncWall::SetState)
        .addProperty("Parent", &GCFuncWall::GetParent, &GCFuncWall::SetParent)
        .addFunction("ToPtr", &GCFuncWall::ToPtr)
        .addFunction("IsValid", &GCFuncWall::IsValid)
        .endClass();
}
GCItemDefuserAlias_item_defuser::GCItemDefuserAlias_item_defuser(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCItemDefuserAlias_item_defuser::GCItemDefuserAlias_item_defuser(void *ptr) {
    m_ptr = ptr;
}
std::string GCItemDefuserAlias_item_defuser::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCItemDefuserAlias_item_defuser::IsValid() {
    return (m_ptr != nullptr);
}
GCItemDefuser GCItemDefuserAlias_item_defuser::GetParent() const {
    GCItemDefuser value(m_ptr);
    return value;
}
void GCItemDefuserAlias_item_defuser::SetParent(GCItemDefuser value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCItemDefuserAlias_item_defuser(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCItemDefuserAlias_item_defuser>("CItemDefuserAlias_item_defuser")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCItemDefuserAlias_item_defuser::GetParent, &GCItemDefuserAlias_item_defuser::SetParent)
        .addFunction("ToPtr", &GCItemDefuserAlias_item_defuser::ToPtr)
        .addFunction("IsValid", &GCItemDefuserAlias_item_defuser::IsValid)
        .endClass();
}
GCBaseGrenade::GCBaseGrenade(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCBaseGrenade::GCBaseGrenade(void *ptr) {
    m_ptr = ptr;
}
GCEntityIOOutput GCBaseGrenade::GetOnPlayerPickup() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CBaseGrenade", "m_OnPlayerPickup"));
    return value;
}
void GCBaseGrenade::SetOnPlayerPickup(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CBaseGrenade", "m_OnPlayerPickup", false, value);
}
GCEntityIOOutput GCBaseGrenade::GetOnExplode() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CBaseGrenade", "m_OnExplode"));
    return value;
}
void GCBaseGrenade::SetOnExplode(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CBaseGrenade", "m_OnExplode", false, value);
}
bool GCBaseGrenade::GetHasWarnedAI() const {
    return GetSchemaValue<bool>(m_ptr, "CBaseGrenade", "m_bHasWarnedAI");
}
void GCBaseGrenade::SetHasWarnedAI(bool value) {
    SetSchemaValue(m_ptr, "CBaseGrenade", "m_bHasWarnedAI", false, value);
}
bool GCBaseGrenade::GetIsSmokeGrenade() const {
    return GetSchemaValue<bool>(m_ptr, "CBaseGrenade", "m_bIsSmokeGrenade");
}
void GCBaseGrenade::SetIsSmokeGrenade(bool value) {
    SetSchemaValue(m_ptr, "CBaseGrenade", "m_bIsSmokeGrenade", false, value);
}
bool GCBaseGrenade::GetIsLive() const {
    return GetSchemaValue<bool>(m_ptr, "CBaseGrenade", "m_bIsLive");
}
void GCBaseGrenade::SetIsLive(bool value) {
    SetSchemaValue(m_ptr, "CBaseGrenade", "m_bIsLive", false, value);
}
float GCBaseGrenade::GetDmgRadius() const {
    return GetSchemaValue<float>(m_ptr, "CBaseGrenade", "m_DmgRadius");
}
void GCBaseGrenade::SetDmgRadius(float value) {
    SetSchemaValue(m_ptr, "CBaseGrenade", "m_DmgRadius", false, value);
}
float GCBaseGrenade::GetDetonateTime() const {
    return GetSchemaValue<float>(m_ptr, "CBaseGrenade", "m_flDetonateTime");
}
void GCBaseGrenade::SetDetonateTime(float value) {
    SetSchemaValue(m_ptr, "CBaseGrenade", "m_flDetonateTime", false, value);
}
float GCBaseGrenade::GetWarnAITime() const {
    return GetSchemaValue<float>(m_ptr, "CBaseGrenade", "m_flWarnAITime");
}
void GCBaseGrenade::SetWarnAITime(float value) {
    SetSchemaValue(m_ptr, "CBaseGrenade", "m_flWarnAITime", false, value);
}
float GCBaseGrenade::GetDamage() const {
    return GetSchemaValue<float>(m_ptr, "CBaseGrenade", "m_flDamage");
}
void GCBaseGrenade::SetDamage(float value) {
    SetSchemaValue(m_ptr, "CBaseGrenade", "m_flDamage", false, value);
}
std::string GCBaseGrenade::GetBounceSound() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CBaseGrenade", "m_iszBounceSound").String();
}
void GCBaseGrenade::SetBounceSound(std::string value) {
    SetSchemaValue(m_ptr, "CBaseGrenade", "m_iszBounceSound", false, CUtlSymbolLarge(value.c_str()));
}
std::string GCBaseGrenade::GetExplosionSound() const {
    return GetSchemaValue<CUtlString>(m_ptr, "CBaseGrenade", "m_ExplosionSound").Get();
}
void GCBaseGrenade::SetExplosionSound(std::string value) {
    SetSchemaValue(m_ptr, "CBaseGrenade", "m_ExplosionSound", false, CUtlString(value.c_str()));
}
GCCSPlayerPawn GCBaseGrenade::GetThrower() const {
    GCCSPlayerPawn value(*GetSchemaValuePtr<void*>(m_ptr, "CBaseGrenade", "m_hThrower"));
    return value;
}
void GCBaseGrenade::SetThrower(GCCSPlayerPawn* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Thrower' is not possible.\n");
}
float GCBaseGrenade::GetNextAttack() const {
    return GetSchemaValue<float>(m_ptr, "CBaseGrenade", "m_flNextAttack");
}
void GCBaseGrenade::SetNextAttack(float value) {
    SetSchemaValue(m_ptr, "CBaseGrenade", "m_flNextAttack", false, value);
}
GCCSPlayerPawn GCBaseGrenade::GetOriginalThrower() const {
    GCCSPlayerPawn value(*GetSchemaValuePtr<void*>(m_ptr, "CBaseGrenade", "m_hOriginalThrower"));
    return value;
}
void GCBaseGrenade::SetOriginalThrower(GCCSPlayerPawn* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'OriginalThrower' is not possible.\n");
}
std::string GCBaseGrenade::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCBaseGrenade::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseFlex GCBaseGrenade::GetParent() const {
    GCBaseFlex value(m_ptr);
    return value;
}
void GCBaseGrenade::SetParent(GCBaseFlex value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCBaseGrenade(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCBaseGrenade>("CBaseGrenade")
        .addConstructor<void (*)(std::string)>()
        .addProperty("OnPlayerPickup", &GCBaseGrenade::GetOnPlayerPickup, &GCBaseGrenade::SetOnPlayerPickup)
        .addProperty("OnExplode", &GCBaseGrenade::GetOnExplode, &GCBaseGrenade::SetOnExplode)
        .addProperty("HasWarnedAI", &GCBaseGrenade::GetHasWarnedAI, &GCBaseGrenade::SetHasWarnedAI)
        .addProperty("IsSmokeGrenade", &GCBaseGrenade::GetIsSmokeGrenade, &GCBaseGrenade::SetIsSmokeGrenade)
        .addProperty("IsLive", &GCBaseGrenade::GetIsLive, &GCBaseGrenade::SetIsLive)
        .addProperty("DmgRadius", &GCBaseGrenade::GetDmgRadius, &GCBaseGrenade::SetDmgRadius)
        .addProperty("DetonateTime", &GCBaseGrenade::GetDetonateTime, &GCBaseGrenade::SetDetonateTime)
        .addProperty("WarnAITime", &GCBaseGrenade::GetWarnAITime, &GCBaseGrenade::SetWarnAITime)
        .addProperty("Damage", &GCBaseGrenade::GetDamage, &GCBaseGrenade::SetDamage)
        .addProperty("BounceSound", &GCBaseGrenade::GetBounceSound, &GCBaseGrenade::SetBounceSound)
        .addProperty("ExplosionSound", &GCBaseGrenade::GetExplosionSound, &GCBaseGrenade::SetExplosionSound)
        .addProperty("Thrower", &GCBaseGrenade::GetThrower, &GCBaseGrenade::SetThrower)
        .addProperty("NextAttack", &GCBaseGrenade::GetNextAttack, &GCBaseGrenade::SetNextAttack)
        .addProperty("OriginalThrower", &GCBaseGrenade::GetOriginalThrower, &GCBaseGrenade::SetOriginalThrower)
        .addProperty("Parent", &GCBaseGrenade::GetParent, &GCBaseGrenade::SetParent)
        .addFunction("ToPtr", &GCBaseGrenade::ToPtr)
        .addFunction("IsValid", &GCBaseGrenade::IsValid)
        .endClass();
}
GCCSPlayerBase_CameraServices::GCCSPlayerBase_CameraServices(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCCSPlayerBase_CameraServices::GCCSPlayerBase_CameraServices(void *ptr) {
    m_ptr = ptr;
}
uint32_t GCCSPlayerBase_CameraServices::GetFOV() const {
    return GetSchemaValue<uint32_t>(m_ptr, "CCSPlayerBase_CameraServices", "m_iFOV");
}
void GCCSPlayerBase_CameraServices::SetFOV(uint32_t value) {
    SetSchemaValue(m_ptr, "CCSPlayerBase_CameraServices", "m_iFOV", false, value);
}
uint32_t GCCSPlayerBase_CameraServices::GetFOVStart() const {
    return GetSchemaValue<uint32_t>(m_ptr, "CCSPlayerBase_CameraServices", "m_iFOVStart");
}
void GCCSPlayerBase_CameraServices::SetFOVStart(uint32_t value) {
    SetSchemaValue(m_ptr, "CCSPlayerBase_CameraServices", "m_iFOVStart", false, value);
}
float GCCSPlayerBase_CameraServices::GetFOVTime() const {
    return GetSchemaValue<float>(m_ptr, "CCSPlayerBase_CameraServices", "m_flFOVTime");
}
void GCCSPlayerBase_CameraServices::SetFOVTime(float value) {
    SetSchemaValue(m_ptr, "CCSPlayerBase_CameraServices", "m_flFOVTime", false, value);
}
float GCCSPlayerBase_CameraServices::GetFOVRate() const {
    return GetSchemaValue<float>(m_ptr, "CCSPlayerBase_CameraServices", "m_flFOVRate");
}
void GCCSPlayerBase_CameraServices::SetFOVRate(float value) {
    SetSchemaValue(m_ptr, "CCSPlayerBase_CameraServices", "m_flFOVRate", false, value);
}
GCBaseEntity GCCSPlayerBase_CameraServices::GetZoomOwner() const {
    GCBaseEntity value(*GetSchemaValuePtr<void*>(m_ptr, "CCSPlayerBase_CameraServices", "m_hZoomOwner"));
    return value;
}
void GCCSPlayerBase_CameraServices::SetZoomOwner(GCBaseEntity* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'ZoomOwner' is not possible.\n");
}
GCBaseEntity GCCSPlayerBase_CameraServices::GetLastFogTrigger() const {
    GCBaseEntity value(*GetSchemaValuePtr<void*>(m_ptr, "CCSPlayerBase_CameraServices", "m_hLastFogTrigger"));
    return value;
}
void GCCSPlayerBase_CameraServices::SetLastFogTrigger(GCBaseEntity* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'LastFogTrigger' is not possible.\n");
}
std::string GCCSPlayerBase_CameraServices::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCCSPlayerBase_CameraServices::IsValid() {
    return (m_ptr != nullptr);
}
GCPlayer_CameraServices GCCSPlayerBase_CameraServices::GetParent() const {
    GCPlayer_CameraServices value(m_ptr);
    return value;
}
void GCCSPlayerBase_CameraServices::SetParent(GCPlayer_CameraServices value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCCSPlayerBase_CameraServices(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCCSPlayerBase_CameraServices>("CCSPlayerBase_CameraServices")
        .addConstructor<void (*)(std::string)>()
        .addProperty("FOV", &GCCSPlayerBase_CameraServices::GetFOV, &GCCSPlayerBase_CameraServices::SetFOV)
        .addProperty("FOVStart", &GCCSPlayerBase_CameraServices::GetFOVStart, &GCCSPlayerBase_CameraServices::SetFOVStart)
        .addProperty("FOVTime", &GCCSPlayerBase_CameraServices::GetFOVTime, &GCCSPlayerBase_CameraServices::SetFOVTime)
        .addProperty("FOVRate", &GCCSPlayerBase_CameraServices::GetFOVRate, &GCCSPlayerBase_CameraServices::SetFOVRate)
        .addProperty("ZoomOwner", &GCCSPlayerBase_CameraServices::GetZoomOwner, &GCCSPlayerBase_CameraServices::SetZoomOwner)
        .addProperty("LastFogTrigger", &GCCSPlayerBase_CameraServices::GetLastFogTrigger, &GCCSPlayerBase_CameraServices::SetLastFogTrigger)
        .addProperty("Parent", &GCCSPlayerBase_CameraServices::GetParent, &GCCSPlayerBase_CameraServices::SetParent)
        .addFunction("ToPtr", &GCCSPlayerBase_CameraServices::ToPtr)
        .addFunction("IsValid", &GCCSPlayerBase_CameraServices::IsValid)
        .endClass();
}
GCCSGO_WingmanIntroCharacterPosition::GCCSGO_WingmanIntroCharacterPosition(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCCSGO_WingmanIntroCharacterPosition::GCCSGO_WingmanIntroCharacterPosition(void *ptr) {
    m_ptr = ptr;
}
std::string GCCSGO_WingmanIntroCharacterPosition::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCCSGO_WingmanIntroCharacterPosition::IsValid() {
    return (m_ptr != nullptr);
}
GCCSGO_TeamIntroCharacterPosition GCCSGO_WingmanIntroCharacterPosition::GetParent() const {
    GCCSGO_TeamIntroCharacterPosition value(m_ptr);
    return value;
}
void GCCSGO_WingmanIntroCharacterPosition::SetParent(GCCSGO_TeamIntroCharacterPosition value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCCSGO_WingmanIntroCharacterPosition(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCCSGO_WingmanIntroCharacterPosition>("CCSGO_WingmanIntroCharacterPosition")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCCSGO_WingmanIntroCharacterPosition::GetParent, &GCCSGO_WingmanIntroCharacterPosition::SetParent)
        .addFunction("ToPtr", &GCCSGO_WingmanIntroCharacterPosition::ToPtr)
        .addFunction("IsValid", &GCCSGO_WingmanIntroCharacterPosition::IsValid)
        .endClass();
}
GCSMatchStats_t::GCSMatchStats_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCSMatchStats_t::GCSMatchStats_t(void *ptr) {
    m_ptr = ptr;
}
int32_t GCSMatchStats_t::GetEnemy5Ks() const {
    return GetSchemaValue<int32_t>(m_ptr, "CSMatchStats_t", "m_iEnemy5Ks");
}
void GCSMatchStats_t::SetEnemy5Ks(int32_t value) {
    SetSchemaValue(m_ptr, "CSMatchStats_t", "m_iEnemy5Ks", true, value);
}
int32_t GCSMatchStats_t::GetEnemy4Ks() const {
    return GetSchemaValue<int32_t>(m_ptr, "CSMatchStats_t", "m_iEnemy4Ks");
}
void GCSMatchStats_t::SetEnemy4Ks(int32_t value) {
    SetSchemaValue(m_ptr, "CSMatchStats_t", "m_iEnemy4Ks", true, value);
}
int32_t GCSMatchStats_t::GetEnemy3Ks() const {
    return GetSchemaValue<int32_t>(m_ptr, "CSMatchStats_t", "m_iEnemy3Ks");
}
void GCSMatchStats_t::SetEnemy3Ks(int32_t value) {
    SetSchemaValue(m_ptr, "CSMatchStats_t", "m_iEnemy3Ks", true, value);
}
int32_t GCSMatchStats_t::GetEnemyKnifeKills() const {
    return GetSchemaValue<int32_t>(m_ptr, "CSMatchStats_t", "m_iEnemyKnifeKills");
}
void GCSMatchStats_t::SetEnemyKnifeKills(int32_t value) {
    SetSchemaValue(m_ptr, "CSMatchStats_t", "m_iEnemyKnifeKills", true, value);
}
int32_t GCSMatchStats_t::GetEnemyTaserKills() const {
    return GetSchemaValue<int32_t>(m_ptr, "CSMatchStats_t", "m_iEnemyTaserKills");
}
void GCSMatchStats_t::SetEnemyTaserKills(int32_t value) {
    SetSchemaValue(m_ptr, "CSMatchStats_t", "m_iEnemyTaserKills", true, value);
}
int32_t GCSMatchStats_t::GetEnemy2Ks() const {
    return GetSchemaValue<int32_t>(m_ptr, "CSMatchStats_t", "m_iEnemy2Ks");
}
void GCSMatchStats_t::SetEnemy2Ks(int32_t value) {
    SetSchemaValue(m_ptr, "CSMatchStats_t", "m_iEnemy2Ks", true, value);
}
int32_t GCSMatchStats_t::GetUtility_Count() const {
    return GetSchemaValue<int32_t>(m_ptr, "CSMatchStats_t", "m_iUtility_Count");
}
void GCSMatchStats_t::SetUtility_Count(int32_t value) {
    SetSchemaValue(m_ptr, "CSMatchStats_t", "m_iUtility_Count", true, value);
}
int32_t GCSMatchStats_t::GetUtility_Successes() const {
    return GetSchemaValue<int32_t>(m_ptr, "CSMatchStats_t", "m_iUtility_Successes");
}
void GCSMatchStats_t::SetUtility_Successes(int32_t value) {
    SetSchemaValue(m_ptr, "CSMatchStats_t", "m_iUtility_Successes", true, value);
}
int32_t GCSMatchStats_t::GetUtility_Enemies() const {
    return GetSchemaValue<int32_t>(m_ptr, "CSMatchStats_t", "m_iUtility_Enemies");
}
void GCSMatchStats_t::SetUtility_Enemies(int32_t value) {
    SetSchemaValue(m_ptr, "CSMatchStats_t", "m_iUtility_Enemies", true, value);
}
int32_t GCSMatchStats_t::GetFlash_Count() const {
    return GetSchemaValue<int32_t>(m_ptr, "CSMatchStats_t", "m_iFlash_Count");
}
void GCSMatchStats_t::SetFlash_Count(int32_t value) {
    SetSchemaValue(m_ptr, "CSMatchStats_t", "m_iFlash_Count", true, value);
}
int32_t GCSMatchStats_t::GetFlash_Successes() const {
    return GetSchemaValue<int32_t>(m_ptr, "CSMatchStats_t", "m_iFlash_Successes");
}
void GCSMatchStats_t::SetFlash_Successes(int32_t value) {
    SetSchemaValue(m_ptr, "CSMatchStats_t", "m_iFlash_Successes", true, value);
}
int32_t GCSMatchStats_t::GetHealthPointsRemovedTotal() const {
    return GetSchemaValue<int32_t>(m_ptr, "CSMatchStats_t", "m_nHealthPointsRemovedTotal");
}
void GCSMatchStats_t::SetHealthPointsRemovedTotal(int32_t value) {
    SetSchemaValue(m_ptr, "CSMatchStats_t", "m_nHealthPointsRemovedTotal", true, value);
}
int32_t GCSMatchStats_t::GetHealthPointsDealtTotal() const {
    return GetSchemaValue<int32_t>(m_ptr, "CSMatchStats_t", "m_nHealthPointsDealtTotal");
}
void GCSMatchStats_t::SetHealthPointsDealtTotal(int32_t value) {
    SetSchemaValue(m_ptr, "CSMatchStats_t", "m_nHealthPointsDealtTotal", true, value);
}
int32_t GCSMatchStats_t::GetShotsFiredTotal() const {
    return GetSchemaValue<int32_t>(m_ptr, "CSMatchStats_t", "m_nShotsFiredTotal");
}
void GCSMatchStats_t::SetShotsFiredTotal(int32_t value) {
    SetSchemaValue(m_ptr, "CSMatchStats_t", "m_nShotsFiredTotal", true, value);
}
int32_t GCSMatchStats_t::GetShotsOnTargetTotal() const {
    return GetSchemaValue<int32_t>(m_ptr, "CSMatchStats_t", "m_nShotsOnTargetTotal");
}
void GCSMatchStats_t::SetShotsOnTargetTotal(int32_t value) {
    SetSchemaValue(m_ptr, "CSMatchStats_t", "m_nShotsOnTargetTotal", true, value);
}
int32_t GCSMatchStats_t::Get1v1Count() const {
    return GetSchemaValue<int32_t>(m_ptr, "CSMatchStats_t", "m_i1v1Count");
}
void GCSMatchStats_t::Set1v1Count(int32_t value) {
    SetSchemaValue(m_ptr, "CSMatchStats_t", "m_i1v1Count", true, value);
}
int32_t GCSMatchStats_t::Get1v1Wins() const {
    return GetSchemaValue<int32_t>(m_ptr, "CSMatchStats_t", "m_i1v1Wins");
}
void GCSMatchStats_t::Set1v1Wins(int32_t value) {
    SetSchemaValue(m_ptr, "CSMatchStats_t", "m_i1v1Wins", true, value);
}
int32_t GCSMatchStats_t::Get1v2Count() const {
    return GetSchemaValue<int32_t>(m_ptr, "CSMatchStats_t", "m_i1v2Count");
}
void GCSMatchStats_t::Set1v2Count(int32_t value) {
    SetSchemaValue(m_ptr, "CSMatchStats_t", "m_i1v2Count", true, value);
}
int32_t GCSMatchStats_t::Get1v2Wins() const {
    return GetSchemaValue<int32_t>(m_ptr, "CSMatchStats_t", "m_i1v2Wins");
}
void GCSMatchStats_t::Set1v2Wins(int32_t value) {
    SetSchemaValue(m_ptr, "CSMatchStats_t", "m_i1v2Wins", true, value);
}
int32_t GCSMatchStats_t::GetEntryCount() const {
    return GetSchemaValue<int32_t>(m_ptr, "CSMatchStats_t", "m_iEntryCount");
}
void GCSMatchStats_t::SetEntryCount(int32_t value) {
    SetSchemaValue(m_ptr, "CSMatchStats_t", "m_iEntryCount", true, value);
}
int32_t GCSMatchStats_t::GetEntryWins() const {
    return GetSchemaValue<int32_t>(m_ptr, "CSMatchStats_t", "m_iEntryWins");
}
void GCSMatchStats_t::SetEntryWins(int32_t value) {
    SetSchemaValue(m_ptr, "CSMatchStats_t", "m_iEntryWins", true, value);
}
std::string GCSMatchStats_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCSMatchStats_t::IsValid() {
    return (m_ptr != nullptr);
}
GCSPerRoundStats_t GCSMatchStats_t::GetParent() const {
    GCSPerRoundStats_t value(m_ptr);
    return value;
}
void GCSMatchStats_t::SetParent(GCSPerRoundStats_t value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCSMatchStats_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCSMatchStats_t>("CSMatchStats_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Enemy5Ks", &GCSMatchStats_t::GetEnemy5Ks, &GCSMatchStats_t::SetEnemy5Ks)
        .addProperty("Enemy4Ks", &GCSMatchStats_t::GetEnemy4Ks, &GCSMatchStats_t::SetEnemy4Ks)
        .addProperty("Enemy3Ks", &GCSMatchStats_t::GetEnemy3Ks, &GCSMatchStats_t::SetEnemy3Ks)
        .addProperty("EnemyKnifeKills", &GCSMatchStats_t::GetEnemyKnifeKills, &GCSMatchStats_t::SetEnemyKnifeKills)
        .addProperty("EnemyTaserKills", &GCSMatchStats_t::GetEnemyTaserKills, &GCSMatchStats_t::SetEnemyTaserKills)
        .addProperty("Enemy2Ks", &GCSMatchStats_t::GetEnemy2Ks, &GCSMatchStats_t::SetEnemy2Ks)
        .addProperty("Utility_Count", &GCSMatchStats_t::GetUtility_Count, &GCSMatchStats_t::SetUtility_Count)
        .addProperty("Utility_Successes", &GCSMatchStats_t::GetUtility_Successes, &GCSMatchStats_t::SetUtility_Successes)
        .addProperty("Utility_Enemies", &GCSMatchStats_t::GetUtility_Enemies, &GCSMatchStats_t::SetUtility_Enemies)
        .addProperty("Flash_Count", &GCSMatchStats_t::GetFlash_Count, &GCSMatchStats_t::SetFlash_Count)
        .addProperty("Flash_Successes", &GCSMatchStats_t::GetFlash_Successes, &GCSMatchStats_t::SetFlash_Successes)
        .addProperty("HealthPointsRemovedTotal", &GCSMatchStats_t::GetHealthPointsRemovedTotal, &GCSMatchStats_t::SetHealthPointsRemovedTotal)
        .addProperty("HealthPointsDealtTotal", &GCSMatchStats_t::GetHealthPointsDealtTotal, &GCSMatchStats_t::SetHealthPointsDealtTotal)
        .addProperty("ShotsFiredTotal", &GCSMatchStats_t::GetShotsFiredTotal, &GCSMatchStats_t::SetShotsFiredTotal)
        .addProperty("ShotsOnTargetTotal", &GCSMatchStats_t::GetShotsOnTargetTotal, &GCSMatchStats_t::SetShotsOnTargetTotal)
        .addProperty("1v1Count", &GCSMatchStats_t::Get1v1Count, &GCSMatchStats_t::Set1v1Count)
        .addProperty("1v1Wins", &GCSMatchStats_t::Get1v1Wins, &GCSMatchStats_t::Set1v1Wins)
        .addProperty("1v2Count", &GCSMatchStats_t::Get1v2Count, &GCSMatchStats_t::Set1v2Count)
        .addProperty("1v2Wins", &GCSMatchStats_t::Get1v2Wins, &GCSMatchStats_t::Set1v2Wins)
        .addProperty("EntryCount", &GCSMatchStats_t::GetEntryCount, &GCSMatchStats_t::SetEntryCount)
        .addProperty("EntryWins", &GCSMatchStats_t::GetEntryWins, &GCSMatchStats_t::SetEntryWins)
        .addProperty("Parent", &GCSMatchStats_t::GetParent, &GCSMatchStats_t::SetParent)
        .addFunction("ToPtr", &GCSMatchStats_t::ToPtr)
        .addFunction("IsValid", &GCSMatchStats_t::IsValid)
        .endClass();
}
GCFuncLadder::GCFuncLadder(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCFuncLadder::GCFuncLadder(void *ptr) {
    m_ptr = ptr;
}
Vector GCFuncLadder::GetLadderDir() const {
    return GetSchemaValue<Vector>(m_ptr, "CFuncLadder", "m_vecLadderDir");
}
void GCFuncLadder::SetLadderDir(Vector value) {
    SetSchemaValue(m_ptr, "CFuncLadder", "m_vecLadderDir", false, value);
}
Vector GCFuncLadder::GetLocalTop() const {
    return GetSchemaValue<Vector>(m_ptr, "CFuncLadder", "m_vecLocalTop");
}
void GCFuncLadder::SetLocalTop(Vector value) {
    SetSchemaValue(m_ptr, "CFuncLadder", "m_vecLocalTop", false, value);
}
Vector GCFuncLadder::GetPlayerMountPositionTop() const {
    return GetSchemaValue<Vector>(m_ptr, "CFuncLadder", "m_vecPlayerMountPositionTop");
}
void GCFuncLadder::SetPlayerMountPositionTop(Vector value) {
    SetSchemaValue(m_ptr, "CFuncLadder", "m_vecPlayerMountPositionTop", false, value);
}
Vector GCFuncLadder::GetPlayerMountPositionBottom() const {
    return GetSchemaValue<Vector>(m_ptr, "CFuncLadder", "m_vecPlayerMountPositionBottom");
}
void GCFuncLadder::SetPlayerMountPositionBottom(Vector value) {
    SetSchemaValue(m_ptr, "CFuncLadder", "m_vecPlayerMountPositionBottom", false, value);
}
float GCFuncLadder::GetAutoRideSpeed() const {
    return GetSchemaValue<float>(m_ptr, "CFuncLadder", "m_flAutoRideSpeed");
}
void GCFuncLadder::SetAutoRideSpeed(float value) {
    SetSchemaValue(m_ptr, "CFuncLadder", "m_flAutoRideSpeed", false, value);
}
bool GCFuncLadder::GetDisabled() const {
    return GetSchemaValue<bool>(m_ptr, "CFuncLadder", "m_bDisabled");
}
void GCFuncLadder::SetDisabled(bool value) {
    SetSchemaValue(m_ptr, "CFuncLadder", "m_bDisabled", false, value);
}
bool GCFuncLadder::GetFakeLadder() const {
    return GetSchemaValue<bool>(m_ptr, "CFuncLadder", "m_bFakeLadder");
}
void GCFuncLadder::SetFakeLadder(bool value) {
    SetSchemaValue(m_ptr, "CFuncLadder", "m_bFakeLadder", false, value);
}
bool GCFuncLadder::GetHasSlack() const {
    return GetSchemaValue<bool>(m_ptr, "CFuncLadder", "m_bHasSlack");
}
void GCFuncLadder::SetHasSlack(bool value) {
    SetSchemaValue(m_ptr, "CFuncLadder", "m_bHasSlack", false, value);
}
std::string GCFuncLadder::GetSurfacePropName() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CFuncLadder", "m_surfacePropName").String();
}
void GCFuncLadder::SetSurfacePropName(std::string value) {
    SetSchemaValue(m_ptr, "CFuncLadder", "m_surfacePropName", false, CUtlSymbolLarge(value.c_str()));
}
GCEntityIOOutput GCFuncLadder::GetOnPlayerGotOnLadder() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CFuncLadder", "m_OnPlayerGotOnLadder"));
    return value;
}
void GCFuncLadder::SetOnPlayerGotOnLadder(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CFuncLadder", "m_OnPlayerGotOnLadder", false, value);
}
GCEntityIOOutput GCFuncLadder::GetOnPlayerGotOffLadder() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CFuncLadder", "m_OnPlayerGotOffLadder"));
    return value;
}
void GCFuncLadder::SetOnPlayerGotOffLadder(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CFuncLadder", "m_OnPlayerGotOffLadder", false, value);
}
std::string GCFuncLadder::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCFuncLadder::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseModelEntity GCFuncLadder::GetParent() const {
    GCBaseModelEntity value(m_ptr);
    return value;
}
void GCFuncLadder::SetParent(GCBaseModelEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCFuncLadder(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCFuncLadder>("CFuncLadder")
        .addConstructor<void (*)(std::string)>()
        .addProperty("LadderDir", &GCFuncLadder::GetLadderDir, &GCFuncLadder::SetLadderDir)
        .addProperty("LocalTop", &GCFuncLadder::GetLocalTop, &GCFuncLadder::SetLocalTop)
        .addProperty("PlayerMountPositionTop", &GCFuncLadder::GetPlayerMountPositionTop, &GCFuncLadder::SetPlayerMountPositionTop)
        .addProperty("PlayerMountPositionBottom", &GCFuncLadder::GetPlayerMountPositionBottom, &GCFuncLadder::SetPlayerMountPositionBottom)
        .addProperty("AutoRideSpeed", &GCFuncLadder::GetAutoRideSpeed, &GCFuncLadder::SetAutoRideSpeed)
        .addProperty("Disabled", &GCFuncLadder::GetDisabled, &GCFuncLadder::SetDisabled)
        .addProperty("FakeLadder", &GCFuncLadder::GetFakeLadder, &GCFuncLadder::SetFakeLadder)
        .addProperty("HasSlack", &GCFuncLadder::GetHasSlack, &GCFuncLadder::SetHasSlack)
        .addProperty("SurfacePropName", &GCFuncLadder::GetSurfacePropName, &GCFuncLadder::SetSurfacePropName)
        .addProperty("OnPlayerGotOnLadder", &GCFuncLadder::GetOnPlayerGotOnLadder, &GCFuncLadder::SetOnPlayerGotOnLadder)
        .addProperty("OnPlayerGotOffLadder", &GCFuncLadder::GetOnPlayerGotOffLadder, &GCFuncLadder::SetOnPlayerGotOffLadder)
        .addProperty("Parent", &GCFuncLadder::GetParent, &GCFuncLadder::SetParent)
        .addFunction("ToPtr", &GCFuncLadder::ToPtr)
        .addFunction("IsValid", &GCFuncLadder::IsValid)
        .endClass();
}
GCTriggerSndSosOpvar::GCTriggerSndSosOpvar(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCTriggerSndSosOpvar::GCTriggerSndSosOpvar(void *ptr) {
    m_ptr = ptr;
}
Vector GCTriggerSndSosOpvar::GetPosition() const {
    return GetSchemaValue<Vector>(m_ptr, "CTriggerSndSosOpvar", "m_flPosition");
}
void GCTriggerSndSosOpvar::SetPosition(Vector value) {
    SetSchemaValue(m_ptr, "CTriggerSndSosOpvar", "m_flPosition", false, value);
}
float GCTriggerSndSosOpvar::GetCenterSize() const {
    return GetSchemaValue<float>(m_ptr, "CTriggerSndSosOpvar", "m_flCenterSize");
}
void GCTriggerSndSosOpvar::SetCenterSize(float value) {
    SetSchemaValue(m_ptr, "CTriggerSndSosOpvar", "m_flCenterSize", false, value);
}
float GCTriggerSndSosOpvar::GetMinVal() const {
    return GetSchemaValue<float>(m_ptr, "CTriggerSndSosOpvar", "m_flMinVal");
}
void GCTriggerSndSosOpvar::SetMinVal(float value) {
    SetSchemaValue(m_ptr, "CTriggerSndSosOpvar", "m_flMinVal", false, value);
}
float GCTriggerSndSosOpvar::GetMaxVal() const {
    return GetSchemaValue<float>(m_ptr, "CTriggerSndSosOpvar", "m_flMaxVal");
}
void GCTriggerSndSosOpvar::SetMaxVal(float value) {
    SetSchemaValue(m_ptr, "CTriggerSndSosOpvar", "m_flMaxVal", false, value);
}
std::string GCTriggerSndSosOpvar::GetOpvarName() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CTriggerSndSosOpvar", "m_opvarName").String();
}
void GCTriggerSndSosOpvar::SetOpvarName(std::string value) {
    SetSchemaValue(m_ptr, "CTriggerSndSosOpvar", "m_opvarName", false, CUtlSymbolLarge(value.c_str()));
}
std::string GCTriggerSndSosOpvar::GetStackName() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CTriggerSndSosOpvar", "m_stackName").String();
}
void GCTriggerSndSosOpvar::SetStackName(std::string value) {
    SetSchemaValue(m_ptr, "CTriggerSndSosOpvar", "m_stackName", false, CUtlSymbolLarge(value.c_str()));
}
std::string GCTriggerSndSosOpvar::GetOperatorName() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CTriggerSndSosOpvar", "m_operatorName").String();
}
void GCTriggerSndSosOpvar::SetOperatorName(std::string value) {
    SetSchemaValue(m_ptr, "CTriggerSndSosOpvar", "m_operatorName", false, CUtlSymbolLarge(value.c_str()));
}
bool GCTriggerSndSosOpvar::GetVolIs2D() const {
    return GetSchemaValue<bool>(m_ptr, "CTriggerSndSosOpvar", "m_bVolIs2D");
}
void GCTriggerSndSosOpvar::SetVolIs2D(bool value) {
    SetSchemaValue(m_ptr, "CTriggerSndSosOpvar", "m_bVolIs2D", false, value);
}
std::string GCTriggerSndSosOpvar::GetOpvarNameChar() const {
    return GetSchemaValuePtr<char>(m_ptr, "CTriggerSndSosOpvar", "m_opvarNameChar");
}
void GCTriggerSndSosOpvar::SetOpvarNameChar(std::string value) {
    WriteSchemaPtrValue(m_ptr, "CTriggerSndSosOpvar", "m_opvarNameChar", false, reinterpret_cast<byte*>(const_cast<char*>(value.c_str())), 256);
}
std::string GCTriggerSndSosOpvar::GetStackNameChar() const {
    return GetSchemaValuePtr<char>(m_ptr, "CTriggerSndSosOpvar", "m_stackNameChar");
}
void GCTriggerSndSosOpvar::SetStackNameChar(std::string value) {
    WriteSchemaPtrValue(m_ptr, "CTriggerSndSosOpvar", "m_stackNameChar", false, reinterpret_cast<byte*>(const_cast<char*>(value.c_str())), 256);
}
std::string GCTriggerSndSosOpvar::GetOperatorNameChar() const {
    return GetSchemaValuePtr<char>(m_ptr, "CTriggerSndSosOpvar", "m_operatorNameChar");
}
void GCTriggerSndSosOpvar::SetOperatorNameChar(std::string value) {
    WriteSchemaPtrValue(m_ptr, "CTriggerSndSosOpvar", "m_operatorNameChar", false, reinterpret_cast<byte*>(const_cast<char*>(value.c_str())), 256);
}
Vector GCTriggerSndSosOpvar::GetVecNormPos() const {
    return GetSchemaValue<Vector>(m_ptr, "CTriggerSndSosOpvar", "m_VecNormPos");
}
void GCTriggerSndSosOpvar::SetVecNormPos(Vector value) {
    SetSchemaValue(m_ptr, "CTriggerSndSosOpvar", "m_VecNormPos", false, value);
}
float GCTriggerSndSosOpvar::GetNormCenterSize() const {
    return GetSchemaValue<float>(m_ptr, "CTriggerSndSosOpvar", "m_flNormCenterSize");
}
void GCTriggerSndSosOpvar::SetNormCenterSize(float value) {
    SetSchemaValue(m_ptr, "CTriggerSndSosOpvar", "m_flNormCenterSize", false, value);
}
std::string GCTriggerSndSosOpvar::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCTriggerSndSosOpvar::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseTrigger GCTriggerSndSosOpvar::GetParent() const {
    GCBaseTrigger value(m_ptr);
    return value;
}
void GCTriggerSndSosOpvar::SetParent(GCBaseTrigger value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCTriggerSndSosOpvar(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCTriggerSndSosOpvar>("CTriggerSndSosOpvar")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Position", &GCTriggerSndSosOpvar::GetPosition, &GCTriggerSndSosOpvar::SetPosition)
        .addProperty("CenterSize", &GCTriggerSndSosOpvar::GetCenterSize, &GCTriggerSndSosOpvar::SetCenterSize)
        .addProperty("MinVal", &GCTriggerSndSosOpvar::GetMinVal, &GCTriggerSndSosOpvar::SetMinVal)
        .addProperty("MaxVal", &GCTriggerSndSosOpvar::GetMaxVal, &GCTriggerSndSosOpvar::SetMaxVal)
        .addProperty("OpvarName", &GCTriggerSndSosOpvar::GetOpvarName, &GCTriggerSndSosOpvar::SetOpvarName)
        .addProperty("StackName", &GCTriggerSndSosOpvar::GetStackName, &GCTriggerSndSosOpvar::SetStackName)
        .addProperty("OperatorName", &GCTriggerSndSosOpvar::GetOperatorName, &GCTriggerSndSosOpvar::SetOperatorName)
        .addProperty("VolIs2D", &GCTriggerSndSosOpvar::GetVolIs2D, &GCTriggerSndSosOpvar::SetVolIs2D)
        .addProperty("OpvarNameChar", &GCTriggerSndSosOpvar::GetOpvarNameChar, &GCTriggerSndSosOpvar::SetOpvarNameChar)
        .addProperty("StackNameChar", &GCTriggerSndSosOpvar::GetStackNameChar, &GCTriggerSndSosOpvar::SetStackNameChar)
        .addProperty("OperatorNameChar", &GCTriggerSndSosOpvar::GetOperatorNameChar, &GCTriggerSndSosOpvar::SetOperatorNameChar)
        .addProperty("VecNormPos", &GCTriggerSndSosOpvar::GetVecNormPos, &GCTriggerSndSosOpvar::SetVecNormPos)
        .addProperty("NormCenterSize", &GCTriggerSndSosOpvar::GetNormCenterSize, &GCTriggerSndSosOpvar::SetNormCenterSize)
        .addProperty("Parent", &GCTriggerSndSosOpvar::GetParent, &GCTriggerSndSosOpvar::SetParent)
        .addFunction("ToPtr", &GCTriggerSndSosOpvar::ToPtr)
        .addFunction("IsValid", &GCTriggerSndSosOpvar::IsValid)
        .endClass();
}
GCItemHeavyAssaultSuit::GCItemHeavyAssaultSuit(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCItemHeavyAssaultSuit::GCItemHeavyAssaultSuit(void *ptr) {
    m_ptr = ptr;
}
std::string GCItemHeavyAssaultSuit::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCItemHeavyAssaultSuit::IsValid() {
    return (m_ptr != nullptr);
}
GCItemAssaultSuit GCItemHeavyAssaultSuit::GetParent() const {
    GCItemAssaultSuit value(m_ptr);
    return value;
}
void GCItemHeavyAssaultSuit::SetParent(GCItemAssaultSuit value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCItemHeavyAssaultSuit(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCItemHeavyAssaultSuit>("CItemHeavyAssaultSuit")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCItemHeavyAssaultSuit::GetParent, &GCItemHeavyAssaultSuit::SetParent)
        .addFunction("ToPtr", &GCItemHeavyAssaultSuit::ToPtr)
        .addFunction("IsValid", &GCItemHeavyAssaultSuit::IsValid)
        .endClass();
}
GCScriptedSequence::GCScriptedSequence(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCScriptedSequence::GCScriptedSequence(void *ptr) {
    m_ptr = ptr;
}
std::string GCScriptedSequence::GetEntry() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CScriptedSequence", "m_iszEntry").String();
}
void GCScriptedSequence::SetEntry(std::string value) {
    SetSchemaValue(m_ptr, "CScriptedSequence", "m_iszEntry", false, CUtlSymbolLarge(value.c_str()));
}
std::string GCScriptedSequence::GetPreIdle() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CScriptedSequence", "m_iszPreIdle").String();
}
void GCScriptedSequence::SetPreIdle(std::string value) {
    SetSchemaValue(m_ptr, "CScriptedSequence", "m_iszPreIdle", false, CUtlSymbolLarge(value.c_str()));
}
std::string GCScriptedSequence::GetPlay() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CScriptedSequence", "m_iszPlay").String();
}
void GCScriptedSequence::SetPlay(std::string value) {
    SetSchemaValue(m_ptr, "CScriptedSequence", "m_iszPlay", false, CUtlSymbolLarge(value.c_str()));
}
std::string GCScriptedSequence::GetPostIdle() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CScriptedSequence", "m_iszPostIdle").String();
}
void GCScriptedSequence::SetPostIdle(std::string value) {
    SetSchemaValue(m_ptr, "CScriptedSequence", "m_iszPostIdle", false, CUtlSymbolLarge(value.c_str()));
}
std::string GCScriptedSequence::GetModifierToAddOnPlay() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CScriptedSequence", "m_iszModifierToAddOnPlay").String();
}
void GCScriptedSequence::SetModifierToAddOnPlay(std::string value) {
    SetSchemaValue(m_ptr, "CScriptedSequence", "m_iszModifierToAddOnPlay", false, CUtlSymbolLarge(value.c_str()));
}
std::string GCScriptedSequence::GetNextScript() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CScriptedSequence", "m_iszNextScript").String();
}
void GCScriptedSequence::SetNextScript(std::string value) {
    SetSchemaValue(m_ptr, "CScriptedSequence", "m_iszNextScript", false, CUtlSymbolLarge(value.c_str()));
}
std::string GCScriptedSequence::GetEntity() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CScriptedSequence", "m_iszEntity").String();
}
void GCScriptedSequence::SetEntity(std::string value) {
    SetSchemaValue(m_ptr, "CScriptedSequence", "m_iszEntity", false, CUtlSymbolLarge(value.c_str()));
}
std::string GCScriptedSequence::GetSyncGroup() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CScriptedSequence", "m_iszSyncGroup").String();
}
void GCScriptedSequence::SetSyncGroup(std::string value) {
    SetSchemaValue(m_ptr, "CScriptedSequence", "m_iszSyncGroup", false, CUtlSymbolLarge(value.c_str()));
}
uint64_t GCScriptedSequence::GetMoveTo() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CScriptedSequence", "m_nMoveTo");
}
void GCScriptedSequence::SetMoveTo(uint64_t value) {
    SetSchemaValue(m_ptr, "CScriptedSequence", "m_nMoveTo", false, value);
}
uint64_t GCScriptedSequence::GetMoveToGait() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CScriptedSequence", "m_nMoveToGait");
}
void GCScriptedSequence::SetMoveToGait(uint64_t value) {
    SetSchemaValue(m_ptr, "CScriptedSequence", "m_nMoveToGait", false, value);
}
bool GCScriptedSequence::GetIsPlayingPreIdle() const {
    return GetSchemaValue<bool>(m_ptr, "CScriptedSequence", "m_bIsPlayingPreIdle");
}
void GCScriptedSequence::SetIsPlayingPreIdle(bool value) {
    SetSchemaValue(m_ptr, "CScriptedSequence", "m_bIsPlayingPreIdle", false, value);
}
bool GCScriptedSequence::GetIsPlayingEntry() const {
    return GetSchemaValue<bool>(m_ptr, "CScriptedSequence", "m_bIsPlayingEntry");
}
void GCScriptedSequence::SetIsPlayingEntry(bool value) {
    SetSchemaValue(m_ptr, "CScriptedSequence", "m_bIsPlayingEntry", false, value);
}
bool GCScriptedSequence::GetIsPlayingAction() const {
    return GetSchemaValue<bool>(m_ptr, "CScriptedSequence", "m_bIsPlayingAction");
}
void GCScriptedSequence::SetIsPlayingAction(bool value) {
    SetSchemaValue(m_ptr, "CScriptedSequence", "m_bIsPlayingAction", false, value);
}
bool GCScriptedSequence::GetIsPlayingPostIdle() const {
    return GetSchemaValue<bool>(m_ptr, "CScriptedSequence", "m_bIsPlayingPostIdle");
}
void GCScriptedSequence::SetIsPlayingPostIdle(bool value) {
    SetSchemaValue(m_ptr, "CScriptedSequence", "m_bIsPlayingPostIdle", false, value);
}
bool GCScriptedSequence::GetDontRotateOther() const {
    return GetSchemaValue<bool>(m_ptr, "CScriptedSequence", "m_bDontRotateOther");
}
void GCScriptedSequence::SetDontRotateOther(bool value) {
    SetSchemaValue(m_ptr, "CScriptedSequence", "m_bDontRotateOther", false, value);
}
bool GCScriptedSequence::GetIsRepeatable() const {
    return GetSchemaValue<bool>(m_ptr, "CScriptedSequence", "m_bIsRepeatable");
}
void GCScriptedSequence::SetIsRepeatable(bool value) {
    SetSchemaValue(m_ptr, "CScriptedSequence", "m_bIsRepeatable", false, value);
}
bool GCScriptedSequence::GetShouldLeaveCorpse() const {
    return GetSchemaValue<bool>(m_ptr, "CScriptedSequence", "m_bShouldLeaveCorpse");
}
void GCScriptedSequence::SetShouldLeaveCorpse(bool value) {
    SetSchemaValue(m_ptr, "CScriptedSequence", "m_bShouldLeaveCorpse", false, value);
}
bool GCScriptedSequence::GetStartOnSpawn() const {
    return GetSchemaValue<bool>(m_ptr, "CScriptedSequence", "m_bStartOnSpawn");
}
void GCScriptedSequence::SetStartOnSpawn(bool value) {
    SetSchemaValue(m_ptr, "CScriptedSequence", "m_bStartOnSpawn", false, value);
}
bool GCScriptedSequence::GetDisallowInterrupts() const {
    return GetSchemaValue<bool>(m_ptr, "CScriptedSequence", "m_bDisallowInterrupts");
}
void GCScriptedSequence::SetDisallowInterrupts(bool value) {
    SetSchemaValue(m_ptr, "CScriptedSequence", "m_bDisallowInterrupts", false, value);
}
bool GCScriptedSequence::GetCanOverrideNPCState() const {
    return GetSchemaValue<bool>(m_ptr, "CScriptedSequence", "m_bCanOverrideNPCState");
}
void GCScriptedSequence::SetCanOverrideNPCState(bool value) {
    SetSchemaValue(m_ptr, "CScriptedSequence", "m_bCanOverrideNPCState", false, value);
}
bool GCScriptedSequence::GetDontTeleportAtEnd() const {
    return GetSchemaValue<bool>(m_ptr, "CScriptedSequence", "m_bDontTeleportAtEnd");
}
void GCScriptedSequence::SetDontTeleportAtEnd(bool value) {
    SetSchemaValue(m_ptr, "CScriptedSequence", "m_bDontTeleportAtEnd", false, value);
}
bool GCScriptedSequence::GetHighPriority() const {
    return GetSchemaValue<bool>(m_ptr, "CScriptedSequence", "m_bHighPriority");
}
void GCScriptedSequence::SetHighPriority(bool value) {
    SetSchemaValue(m_ptr, "CScriptedSequence", "m_bHighPriority", false, value);
}
bool GCScriptedSequence::GetHideDebugComplaints() const {
    return GetSchemaValue<bool>(m_ptr, "CScriptedSequence", "m_bHideDebugComplaints");
}
void GCScriptedSequence::SetHideDebugComplaints(bool value) {
    SetSchemaValue(m_ptr, "CScriptedSequence", "m_bHideDebugComplaints", false, value);
}
bool GCScriptedSequence::GetContinueOnDeath() const {
    return GetSchemaValue<bool>(m_ptr, "CScriptedSequence", "m_bContinueOnDeath");
}
void GCScriptedSequence::SetContinueOnDeath(bool value) {
    SetSchemaValue(m_ptr, "CScriptedSequence", "m_bContinueOnDeath", false, value);
}
bool GCScriptedSequence::GetLoopPreIdleSequence() const {
    return GetSchemaValue<bool>(m_ptr, "CScriptedSequence", "m_bLoopPreIdleSequence");
}
void GCScriptedSequence::SetLoopPreIdleSequence(bool value) {
    SetSchemaValue(m_ptr, "CScriptedSequence", "m_bLoopPreIdleSequence", false, value);
}
bool GCScriptedSequence::GetLoopActionSequence() const {
    return GetSchemaValue<bool>(m_ptr, "CScriptedSequence", "m_bLoopActionSequence");
}
void GCScriptedSequence::SetLoopActionSequence(bool value) {
    SetSchemaValue(m_ptr, "CScriptedSequence", "m_bLoopActionSequence", false, value);
}
bool GCScriptedSequence::GetLoopPostIdleSequence() const {
    return GetSchemaValue<bool>(m_ptr, "CScriptedSequence", "m_bLoopPostIdleSequence");
}
void GCScriptedSequence::SetLoopPostIdleSequence(bool value) {
    SetSchemaValue(m_ptr, "CScriptedSequence", "m_bLoopPostIdleSequence", false, value);
}
bool GCScriptedSequence::GetSynchPostIdles() const {
    return GetSchemaValue<bool>(m_ptr, "CScriptedSequence", "m_bSynchPostIdles");
}
void GCScriptedSequence::SetSynchPostIdles(bool value) {
    SetSchemaValue(m_ptr, "CScriptedSequence", "m_bSynchPostIdles", false, value);
}
bool GCScriptedSequence::GetIgnoreLookAt() const {
    return GetSchemaValue<bool>(m_ptr, "CScriptedSequence", "m_bIgnoreLookAt");
}
void GCScriptedSequence::SetIgnoreLookAt(bool value) {
    SetSchemaValue(m_ptr, "CScriptedSequence", "m_bIgnoreLookAt", false, value);
}
bool GCScriptedSequence::GetIgnoreGravity() const {
    return GetSchemaValue<bool>(m_ptr, "CScriptedSequence", "m_bIgnoreGravity");
}
void GCScriptedSequence::SetIgnoreGravity(bool value) {
    SetSchemaValue(m_ptr, "CScriptedSequence", "m_bIgnoreGravity", false, value);
}
bool GCScriptedSequence::GetDisableNPCCollisions() const {
    return GetSchemaValue<bool>(m_ptr, "CScriptedSequence", "m_bDisableNPCCollisions");
}
void GCScriptedSequence::SetDisableNPCCollisions(bool value) {
    SetSchemaValue(m_ptr, "CScriptedSequence", "m_bDisableNPCCollisions", false, value);
}
bool GCScriptedSequence::GetKeepAnimgraphLockedPost() const {
    return GetSchemaValue<bool>(m_ptr, "CScriptedSequence", "m_bKeepAnimgraphLockedPost");
}
void GCScriptedSequence::SetKeepAnimgraphLockedPost(bool value) {
    SetSchemaValue(m_ptr, "CScriptedSequence", "m_bKeepAnimgraphLockedPost", false, value);
}
bool GCScriptedSequence::GetDontAddModifiers() const {
    return GetSchemaValue<bool>(m_ptr, "CScriptedSequence", "m_bDontAddModifiers");
}
void GCScriptedSequence::SetDontAddModifiers(bool value) {
    SetSchemaValue(m_ptr, "CScriptedSequence", "m_bDontAddModifiers", false, value);
}
float GCScriptedSequence::GetRadius() const {
    return GetSchemaValue<float>(m_ptr, "CScriptedSequence", "m_flRadius");
}
void GCScriptedSequence::SetRadius(float value) {
    SetSchemaValue(m_ptr, "CScriptedSequence", "m_flRadius", false, value);
}
float GCScriptedSequence::GetRepeat() const {
    return GetSchemaValue<float>(m_ptr, "CScriptedSequence", "m_flRepeat");
}
void GCScriptedSequence::SetRepeat(float value) {
    SetSchemaValue(m_ptr, "CScriptedSequence", "m_flRepeat", false, value);
}
float GCScriptedSequence::GetPlayAnimFadeInTime() const {
    return GetSchemaValue<float>(m_ptr, "CScriptedSequence", "m_flPlayAnimFadeInTime");
}
void GCScriptedSequence::SetPlayAnimFadeInTime(float value) {
    SetSchemaValue(m_ptr, "CScriptedSequence", "m_flPlayAnimFadeInTime", false, value);
}
float GCScriptedSequence::GetMoveInterpTime() const {
    return GetSchemaValue<float>(m_ptr, "CScriptedSequence", "m_flMoveInterpTime");
}
void GCScriptedSequence::SetMoveInterpTime(float value) {
    SetSchemaValue(m_ptr, "CScriptedSequence", "m_flMoveInterpTime", false, value);
}
float GCScriptedSequence::GetAngRate() const {
    return GetSchemaValue<float>(m_ptr, "CScriptedSequence", "m_flAngRate");
}
void GCScriptedSequence::SetAngRate(float value) {
    SetSchemaValue(m_ptr, "CScriptedSequence", "m_flAngRate", false, value);
}
int32_t GCScriptedSequence::GetNotReadySequenceCount() const {
    return GetSchemaValue<int32_t>(m_ptr, "CScriptedSequence", "m_nNotReadySequenceCount");
}
void GCScriptedSequence::SetNotReadySequenceCount(int32_t value) {
    SetSchemaValue(m_ptr, "CScriptedSequence", "m_nNotReadySequenceCount", false, value);
}
float GCScriptedSequence::GetStartTime() const {
    return GetSchemaValue<float>(m_ptr, "CScriptedSequence", "m_startTime");
}
void GCScriptedSequence::SetStartTime(float value) {
    SetSchemaValue(m_ptr, "CScriptedSequence", "m_startTime", false, value);
}
bool GCScriptedSequence::GetWaitForBeginSequence() const {
    return GetSchemaValue<bool>(m_ptr, "CScriptedSequence", "m_bWaitForBeginSequence");
}
void GCScriptedSequence::SetWaitForBeginSequence(bool value) {
    SetSchemaValue(m_ptr, "CScriptedSequence", "m_bWaitForBeginSequence", false, value);
}
int32_t GCScriptedSequence::GetSaved_effects() const {
    return GetSchemaValue<int32_t>(m_ptr, "CScriptedSequence", "m_saved_effects");
}
void GCScriptedSequence::SetSaved_effects(int32_t value) {
    SetSchemaValue(m_ptr, "CScriptedSequence", "m_saved_effects", false, value);
}
int32_t GCScriptedSequence::GetSavedFlags() const {
    return GetSchemaValue<int32_t>(m_ptr, "CScriptedSequence", "m_savedFlags");
}
void GCScriptedSequence::SetSavedFlags(int32_t value) {
    SetSchemaValue(m_ptr, "CScriptedSequence", "m_savedFlags", false, value);
}
int32_t GCScriptedSequence::GetSavedCollisionGroup() const {
    return GetSchemaValue<int32_t>(m_ptr, "CScriptedSequence", "m_savedCollisionGroup");
}
void GCScriptedSequence::SetSavedCollisionGroup(int32_t value) {
    SetSchemaValue(m_ptr, "CScriptedSequence", "m_savedCollisionGroup", false, value);
}
bool GCScriptedSequence::GetInterruptable() const {
    return GetSchemaValue<bool>(m_ptr, "CScriptedSequence", "m_bInterruptable");
}
void GCScriptedSequence::SetInterruptable(bool value) {
    SetSchemaValue(m_ptr, "CScriptedSequence", "m_bInterruptable", false, value);
}
bool GCScriptedSequence::GetSequenceStarted() const {
    return GetSchemaValue<bool>(m_ptr, "CScriptedSequence", "m_sequenceStarted");
}
void GCScriptedSequence::SetSequenceStarted(bool value) {
    SetSchemaValue(m_ptr, "CScriptedSequence", "m_sequenceStarted", false, value);
}
bool GCScriptedSequence::GetPositionRelativeToOtherEntity() const {
    return GetSchemaValue<bool>(m_ptr, "CScriptedSequence", "m_bPositionRelativeToOtherEntity");
}
void GCScriptedSequence::SetPositionRelativeToOtherEntity(bool value) {
    SetSchemaValue(m_ptr, "CScriptedSequence", "m_bPositionRelativeToOtherEntity", false, value);
}
GCBaseEntity GCScriptedSequence::GetTargetEnt() const {
    GCBaseEntity value(*GetSchemaValuePtr<void*>(m_ptr, "CScriptedSequence", "m_hTargetEnt"));
    return value;
}
void GCScriptedSequence::SetTargetEnt(GCBaseEntity* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'TargetEnt' is not possible.\n");
}
GCScriptedSequence GCScriptedSequence::GetNextCine() const {
    GCScriptedSequence value(*GetSchemaValuePtr<void*>(m_ptr, "CScriptedSequence", "m_hNextCine"));
    return value;
}
void GCScriptedSequence::SetNextCine(GCScriptedSequence* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'NextCine' is not possible.\n");
}
bool GCScriptedSequence::GetThinking() const {
    return GetSchemaValue<bool>(m_ptr, "CScriptedSequence", "m_bThinking");
}
void GCScriptedSequence::SetThinking(bool value) {
    SetSchemaValue(m_ptr, "CScriptedSequence", "m_bThinking", false, value);
}
bool GCScriptedSequence::GetInitiatedSelfDelete() const {
    return GetSchemaValue<bool>(m_ptr, "CScriptedSequence", "m_bInitiatedSelfDelete");
}
void GCScriptedSequence::SetInitiatedSelfDelete(bool value) {
    SetSchemaValue(m_ptr, "CScriptedSequence", "m_bInitiatedSelfDelete", false, value);
}
bool GCScriptedSequence::GetIsTeleportingDueToMoveTo() const {
    return GetSchemaValue<bool>(m_ptr, "CScriptedSequence", "m_bIsTeleportingDueToMoveTo");
}
void GCScriptedSequence::SetIsTeleportingDueToMoveTo(bool value) {
    SetSchemaValue(m_ptr, "CScriptedSequence", "m_bIsTeleportingDueToMoveTo", false, value);
}
bool GCScriptedSequence::GetAllowCustomInterruptConditions() const {
    return GetSchemaValue<bool>(m_ptr, "CScriptedSequence", "m_bAllowCustomInterruptConditions");
}
void GCScriptedSequence::SetAllowCustomInterruptConditions(bool value) {
    SetSchemaValue(m_ptr, "CScriptedSequence", "m_bAllowCustomInterruptConditions", false, value);
}
GCBaseAnimGraph GCScriptedSequence::GetForcedTarget() const {
    GCBaseAnimGraph value(*GetSchemaValuePtr<void*>(m_ptr, "CScriptedSequence", "m_hForcedTarget"));
    return value;
}
void GCScriptedSequence::SetForcedTarget(GCBaseAnimGraph* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'ForcedTarget' is not possible.\n");
}
bool GCScriptedSequence::GetDontCancelOtherSequences() const {
    return GetSchemaValue<bool>(m_ptr, "CScriptedSequence", "m_bDontCancelOtherSequences");
}
void GCScriptedSequence::SetDontCancelOtherSequences(bool value) {
    SetSchemaValue(m_ptr, "CScriptedSequence", "m_bDontCancelOtherSequences", false, value);
}
bool GCScriptedSequence::GetForceSynch() const {
    return GetSchemaValue<bool>(m_ptr, "CScriptedSequence", "m_bForceSynch");
}
void GCScriptedSequence::SetForceSynch(bool value) {
    SetSchemaValue(m_ptr, "CScriptedSequence", "m_bForceSynch", false, value);
}
bool GCScriptedSequence::GetPreventUpdateYawOnFinish() const {
    return GetSchemaValue<bool>(m_ptr, "CScriptedSequence", "m_bPreventUpdateYawOnFinish");
}
void GCScriptedSequence::SetPreventUpdateYawOnFinish(bool value) {
    SetSchemaValue(m_ptr, "CScriptedSequence", "m_bPreventUpdateYawOnFinish", false, value);
}
bool GCScriptedSequence::GetEnsureOnNavmeshOnFinish() const {
    return GetSchemaValue<bool>(m_ptr, "CScriptedSequence", "m_bEnsureOnNavmeshOnFinish");
}
void GCScriptedSequence::SetEnsureOnNavmeshOnFinish(bool value) {
    SetSchemaValue(m_ptr, "CScriptedSequence", "m_bEnsureOnNavmeshOnFinish", false, value);
}
uint64_t GCScriptedSequence::GetOnDeathBehavior() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CScriptedSequence", "m_onDeathBehavior");
}
void GCScriptedSequence::SetOnDeathBehavior(uint64_t value) {
    SetSchemaValue(m_ptr, "CScriptedSequence", "m_onDeathBehavior", false, value);
}
uint64_t GCScriptedSequence::GetConflictResponse() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CScriptedSequence", "m_ConflictResponse");
}
void GCScriptedSequence::SetConflictResponse(uint64_t value) {
    SetSchemaValue(m_ptr, "CScriptedSequence", "m_ConflictResponse", false, value);
}
GCEntityIOOutput GCScriptedSequence::GetOnBeginSequence() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CScriptedSequence", "m_OnBeginSequence"));
    return value;
}
void GCScriptedSequence::SetOnBeginSequence(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CScriptedSequence", "m_OnBeginSequence", false, value);
}
GCEntityIOOutput GCScriptedSequence::GetOnActionStartOrLoop() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CScriptedSequence", "m_OnActionStartOrLoop"));
    return value;
}
void GCScriptedSequence::SetOnActionStartOrLoop(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CScriptedSequence", "m_OnActionStartOrLoop", false, value);
}
GCEntityIOOutput GCScriptedSequence::GetOnEndSequence() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CScriptedSequence", "m_OnEndSequence"));
    return value;
}
void GCScriptedSequence::SetOnEndSequence(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CScriptedSequence", "m_OnEndSequence", false, value);
}
GCEntityIOOutput GCScriptedSequence::GetOnPostIdleEndSequence() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CScriptedSequence", "m_OnPostIdleEndSequence"));
    return value;
}
void GCScriptedSequence::SetOnPostIdleEndSequence(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CScriptedSequence", "m_OnPostIdleEndSequence", false, value);
}
GCEntityIOOutput GCScriptedSequence::GetOnCancelSequence() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CScriptedSequence", "m_OnCancelSequence"));
    return value;
}
void GCScriptedSequence::SetOnCancelSequence(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CScriptedSequence", "m_OnCancelSequence", false, value);
}
GCEntityIOOutput GCScriptedSequence::GetOnCancelFailedSequence() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CScriptedSequence", "m_OnCancelFailedSequence"));
    return value;
}
void GCScriptedSequence::SetOnCancelFailedSequence(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CScriptedSequence", "m_OnCancelFailedSequence", false, value);
}
std::vector<GCEntityIOOutput> GCScriptedSequence::GetOnScriptEvent() const {
    GCEntityIOOutput* outValue = GetSchemaValue<GCEntityIOOutput*>(m_ptr, "CScriptedSequence", "m_OnScriptEvent"); std::vector<GCEntityIOOutput> ret; for(int i = 0; i < 8; i++) { ret.push_back(outValue[i]); } return ret;
}
void GCScriptedSequence::SetOnScriptEvent(std::vector<GCEntityIOOutput> value) {
    GCEntityIOOutput* outValue = GetSchemaValue<GCEntityIOOutput*>(m_ptr, "CScriptedSequence", "m_OnScriptEvent"); for(int i = 0; i < 8; i++) { outValue[i] = value[i]; } SetSchemaValue(m_ptr, "CScriptedSequence", "m_OnScriptEvent", false, outValue);
}
GCBaseEntity GCScriptedSequence::GetInteractionMainEntity() const {
    GCBaseEntity value(*GetSchemaValuePtr<void*>(m_ptr, "CScriptedSequence", "m_hInteractionMainEntity"));
    return value;
}
void GCScriptedSequence::SetInteractionMainEntity(GCBaseEntity* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'InteractionMainEntity' is not possible.\n");
}
int32_t GCScriptedSequence::GetPlayerDeathBehavior() const {
    return GetSchemaValue<int32_t>(m_ptr, "CScriptedSequence", "m_iPlayerDeathBehavior");
}
void GCScriptedSequence::SetPlayerDeathBehavior(int32_t value) {
    SetSchemaValue(m_ptr, "CScriptedSequence", "m_iPlayerDeathBehavior", false, value);
}
std::string GCScriptedSequence::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCScriptedSequence::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseEntity GCScriptedSequence::GetParent() const {
    GCBaseEntity value(m_ptr);
    return value;
}
void GCScriptedSequence::SetParent(GCBaseEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCScriptedSequence(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCScriptedSequence>("CScriptedSequence")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Entry", &GCScriptedSequence::GetEntry, &GCScriptedSequence::SetEntry)
        .addProperty("PreIdle", &GCScriptedSequence::GetPreIdle, &GCScriptedSequence::SetPreIdle)
        .addProperty("Play", &GCScriptedSequence::GetPlay, &GCScriptedSequence::SetPlay)
        .addProperty("PostIdle", &GCScriptedSequence::GetPostIdle, &GCScriptedSequence::SetPostIdle)
        .addProperty("ModifierToAddOnPlay", &GCScriptedSequence::GetModifierToAddOnPlay, &GCScriptedSequence::SetModifierToAddOnPlay)
        .addProperty("NextScript", &GCScriptedSequence::GetNextScript, &GCScriptedSequence::SetNextScript)
        .addProperty("Entity", &GCScriptedSequence::GetEntity, &GCScriptedSequence::SetEntity)
        .addProperty("SyncGroup", &GCScriptedSequence::GetSyncGroup, &GCScriptedSequence::SetSyncGroup)
        .addProperty("MoveTo", &GCScriptedSequence::GetMoveTo, &GCScriptedSequence::SetMoveTo)
        .addProperty("MoveToGait", &GCScriptedSequence::GetMoveToGait, &GCScriptedSequence::SetMoveToGait)
        .addProperty("IsPlayingPreIdle", &GCScriptedSequence::GetIsPlayingPreIdle, &GCScriptedSequence::SetIsPlayingPreIdle)
        .addProperty("IsPlayingEntry", &GCScriptedSequence::GetIsPlayingEntry, &GCScriptedSequence::SetIsPlayingEntry)
        .addProperty("IsPlayingAction", &GCScriptedSequence::GetIsPlayingAction, &GCScriptedSequence::SetIsPlayingAction)
        .addProperty("IsPlayingPostIdle", &GCScriptedSequence::GetIsPlayingPostIdle, &GCScriptedSequence::SetIsPlayingPostIdle)
        .addProperty("DontRotateOther", &GCScriptedSequence::GetDontRotateOther, &GCScriptedSequence::SetDontRotateOther)
        .addProperty("IsRepeatable", &GCScriptedSequence::GetIsRepeatable, &GCScriptedSequence::SetIsRepeatable)
        .addProperty("ShouldLeaveCorpse", &GCScriptedSequence::GetShouldLeaveCorpse, &GCScriptedSequence::SetShouldLeaveCorpse)
        .addProperty("StartOnSpawn", &GCScriptedSequence::GetStartOnSpawn, &GCScriptedSequence::SetStartOnSpawn)
        .addProperty("DisallowInterrupts", &GCScriptedSequence::GetDisallowInterrupts, &GCScriptedSequence::SetDisallowInterrupts)
        .addProperty("CanOverrideNPCState", &GCScriptedSequence::GetCanOverrideNPCState, &GCScriptedSequence::SetCanOverrideNPCState)
        .addProperty("DontTeleportAtEnd", &GCScriptedSequence::GetDontTeleportAtEnd, &GCScriptedSequence::SetDontTeleportAtEnd)
        .addProperty("HighPriority", &GCScriptedSequence::GetHighPriority, &GCScriptedSequence::SetHighPriority)
        .addProperty("HideDebugComplaints", &GCScriptedSequence::GetHideDebugComplaints, &GCScriptedSequence::SetHideDebugComplaints)
        .addProperty("ContinueOnDeath", &GCScriptedSequence::GetContinueOnDeath, &GCScriptedSequence::SetContinueOnDeath)
        .addProperty("LoopPreIdleSequence", &GCScriptedSequence::GetLoopPreIdleSequence, &GCScriptedSequence::SetLoopPreIdleSequence)
        .addProperty("LoopActionSequence", &GCScriptedSequence::GetLoopActionSequence, &GCScriptedSequence::SetLoopActionSequence)
        .addProperty("LoopPostIdleSequence", &GCScriptedSequence::GetLoopPostIdleSequence, &GCScriptedSequence::SetLoopPostIdleSequence)
        .addProperty("SynchPostIdles", &GCScriptedSequence::GetSynchPostIdles, &GCScriptedSequence::SetSynchPostIdles)
        .addProperty("IgnoreLookAt", &GCScriptedSequence::GetIgnoreLookAt, &GCScriptedSequence::SetIgnoreLookAt)
        .addProperty("IgnoreGravity", &GCScriptedSequence::GetIgnoreGravity, &GCScriptedSequence::SetIgnoreGravity)
        .addProperty("DisableNPCCollisions", &GCScriptedSequence::GetDisableNPCCollisions, &GCScriptedSequence::SetDisableNPCCollisions)
        .addProperty("KeepAnimgraphLockedPost", &GCScriptedSequence::GetKeepAnimgraphLockedPost, &GCScriptedSequence::SetKeepAnimgraphLockedPost)
        .addProperty("DontAddModifiers", &GCScriptedSequence::GetDontAddModifiers, &GCScriptedSequence::SetDontAddModifiers)
        .addProperty("Radius", &GCScriptedSequence::GetRadius, &GCScriptedSequence::SetRadius)
        .addProperty("Repeat", &GCScriptedSequence::GetRepeat, &GCScriptedSequence::SetRepeat)
        .addProperty("PlayAnimFadeInTime", &GCScriptedSequence::GetPlayAnimFadeInTime, &GCScriptedSequence::SetPlayAnimFadeInTime)
        .addProperty("MoveInterpTime", &GCScriptedSequence::GetMoveInterpTime, &GCScriptedSequence::SetMoveInterpTime)
        .addProperty("AngRate", &GCScriptedSequence::GetAngRate, &GCScriptedSequence::SetAngRate)
        .addProperty("NotReadySequenceCount", &GCScriptedSequence::GetNotReadySequenceCount, &GCScriptedSequence::SetNotReadySequenceCount)
        .addProperty("StartTime", &GCScriptedSequence::GetStartTime, &GCScriptedSequence::SetStartTime)
        .addProperty("WaitForBeginSequence", &GCScriptedSequence::GetWaitForBeginSequence, &GCScriptedSequence::SetWaitForBeginSequence)
        .addProperty("Saved_effects", &GCScriptedSequence::GetSaved_effects, &GCScriptedSequence::SetSaved_effects)
        .addProperty("SavedFlags", &GCScriptedSequence::GetSavedFlags, &GCScriptedSequence::SetSavedFlags)
        .addProperty("SavedCollisionGroup", &GCScriptedSequence::GetSavedCollisionGroup, &GCScriptedSequence::SetSavedCollisionGroup)
        .addProperty("Interruptable", &GCScriptedSequence::GetInterruptable, &GCScriptedSequence::SetInterruptable)
        .addProperty("SequenceStarted", &GCScriptedSequence::GetSequenceStarted, &GCScriptedSequence::SetSequenceStarted)
        .addProperty("PositionRelativeToOtherEntity", &GCScriptedSequence::GetPositionRelativeToOtherEntity, &GCScriptedSequence::SetPositionRelativeToOtherEntity)
        .addProperty("TargetEnt", &GCScriptedSequence::GetTargetEnt, &GCScriptedSequence::SetTargetEnt)
        .addProperty("NextCine", &GCScriptedSequence::GetNextCine, &GCScriptedSequence::SetNextCine)
        .addProperty("Thinking", &GCScriptedSequence::GetThinking, &GCScriptedSequence::SetThinking)
        .addProperty("InitiatedSelfDelete", &GCScriptedSequence::GetInitiatedSelfDelete, &GCScriptedSequence::SetInitiatedSelfDelete)
        .addProperty("IsTeleportingDueToMoveTo", &GCScriptedSequence::GetIsTeleportingDueToMoveTo, &GCScriptedSequence::SetIsTeleportingDueToMoveTo)
        .addProperty("AllowCustomInterruptConditions", &GCScriptedSequence::GetAllowCustomInterruptConditions, &GCScriptedSequence::SetAllowCustomInterruptConditions)
        .addProperty("ForcedTarget", &GCScriptedSequence::GetForcedTarget, &GCScriptedSequence::SetForcedTarget)
        .addProperty("DontCancelOtherSequences", &GCScriptedSequence::GetDontCancelOtherSequences, &GCScriptedSequence::SetDontCancelOtherSequences)
        .addProperty("ForceSynch", &GCScriptedSequence::GetForceSynch, &GCScriptedSequence::SetForceSynch)
        .addProperty("PreventUpdateYawOnFinish", &GCScriptedSequence::GetPreventUpdateYawOnFinish, &GCScriptedSequence::SetPreventUpdateYawOnFinish)
        .addProperty("EnsureOnNavmeshOnFinish", &GCScriptedSequence::GetEnsureOnNavmeshOnFinish, &GCScriptedSequence::SetEnsureOnNavmeshOnFinish)
        .addProperty("OnDeathBehavior", &GCScriptedSequence::GetOnDeathBehavior, &GCScriptedSequence::SetOnDeathBehavior)
        .addProperty("ConflictResponse", &GCScriptedSequence::GetConflictResponse, &GCScriptedSequence::SetConflictResponse)
        .addProperty("OnBeginSequence", &GCScriptedSequence::GetOnBeginSequence, &GCScriptedSequence::SetOnBeginSequence)
        .addProperty("OnActionStartOrLoop", &GCScriptedSequence::GetOnActionStartOrLoop, &GCScriptedSequence::SetOnActionStartOrLoop)
        .addProperty("OnEndSequence", &GCScriptedSequence::GetOnEndSequence, &GCScriptedSequence::SetOnEndSequence)
        .addProperty("OnPostIdleEndSequence", &GCScriptedSequence::GetOnPostIdleEndSequence, &GCScriptedSequence::SetOnPostIdleEndSequence)
        .addProperty("OnCancelSequence", &GCScriptedSequence::GetOnCancelSequence, &GCScriptedSequence::SetOnCancelSequence)
        .addProperty("OnCancelFailedSequence", &GCScriptedSequence::GetOnCancelFailedSequence, &GCScriptedSequence::SetOnCancelFailedSequence)
        .addProperty("OnScriptEvent", &GCScriptedSequence::GetOnScriptEvent, &GCScriptedSequence::SetOnScriptEvent)
        .addProperty("InteractionMainEntity", &GCScriptedSequence::GetInteractionMainEntity, &GCScriptedSequence::SetInteractionMainEntity)
        .addProperty("PlayerDeathBehavior", &GCScriptedSequence::GetPlayerDeathBehavior, &GCScriptedSequence::SetPlayerDeathBehavior)
        .addProperty("Parent", &GCScriptedSequence::GetParent, &GCScriptedSequence::SetParent)
        .addFunction("ToPtr", &GCScriptedSequence::ToPtr)
        .addFunction("IsValid", &GCScriptedSequence::IsValid)
        .endClass();
}
GCWeaponNegev::GCWeaponNegev(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCWeaponNegev::GCWeaponNegev(void *ptr) {
    m_ptr = ptr;
}
std::string GCWeaponNegev::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCWeaponNegev::IsValid() {
    return (m_ptr != nullptr);
}
GCCSWeaponBaseGun GCWeaponNegev::GetParent() const {
    GCCSWeaponBaseGun value(m_ptr);
    return value;
}
void GCWeaponNegev::SetParent(GCCSWeaponBaseGun value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCWeaponNegev(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCWeaponNegev>("CWeaponNegev")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCWeaponNegev::GetParent, &GCWeaponNegev::SetParent)
        .addFunction("ToPtr", &GCWeaponNegev::ToPtr)
        .addFunction("IsValid", &GCWeaponNegev::IsValid)
        .endClass();
}
GCWeaponGalilAR::GCWeaponGalilAR(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCWeaponGalilAR::GCWeaponGalilAR(void *ptr) {
    m_ptr = ptr;
}
std::string GCWeaponGalilAR::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCWeaponGalilAR::IsValid() {
    return (m_ptr != nullptr);
}
GCCSWeaponBaseGun GCWeaponGalilAR::GetParent() const {
    GCCSWeaponBaseGun value(m_ptr);
    return value;
}
void GCWeaponGalilAR::SetParent(GCCSWeaponBaseGun value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCWeaponGalilAR(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCWeaponGalilAR>("CWeaponGalilAR")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCWeaponGalilAR::GetParent, &GCWeaponGalilAR::SetParent)
        .addFunction("ToPtr", &GCWeaponGalilAR::ToPtr)
        .addFunction("IsValid", &GCWeaponGalilAR::IsValid)
        .endClass();
}
GCEnvProjectedTexture::GCEnvProjectedTexture(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCEnvProjectedTexture::GCEnvProjectedTexture(void *ptr) {
    m_ptr = ptr;
}
GCBaseEntity GCEnvProjectedTexture::GetTargetEntity() const {
    GCBaseEntity value(*GetSchemaValuePtr<void*>(m_ptr, "CEnvProjectedTexture", "m_hTargetEntity"));
    return value;
}
void GCEnvProjectedTexture::SetTargetEntity(GCBaseEntity* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'TargetEntity' is not possible.\n");
}
bool GCEnvProjectedTexture::GetState() const {
    return GetSchemaValue<bool>(m_ptr, "CEnvProjectedTexture", "m_bState");
}
void GCEnvProjectedTexture::SetState(bool value) {
    SetSchemaValue(m_ptr, "CEnvProjectedTexture", "m_bState", false, value);
}
bool GCEnvProjectedTexture::GetAlwaysUpdate() const {
    return GetSchemaValue<bool>(m_ptr, "CEnvProjectedTexture", "m_bAlwaysUpdate");
}
void GCEnvProjectedTexture::SetAlwaysUpdate(bool value) {
    SetSchemaValue(m_ptr, "CEnvProjectedTexture", "m_bAlwaysUpdate", false, value);
}
float GCEnvProjectedTexture::GetLightFOV() const {
    return GetSchemaValue<float>(m_ptr, "CEnvProjectedTexture", "m_flLightFOV");
}
void GCEnvProjectedTexture::SetLightFOV(float value) {
    SetSchemaValue(m_ptr, "CEnvProjectedTexture", "m_flLightFOV", false, value);
}
bool GCEnvProjectedTexture::GetEnableShadows() const {
    return GetSchemaValue<bool>(m_ptr, "CEnvProjectedTexture", "m_bEnableShadows");
}
void GCEnvProjectedTexture::SetEnableShadows(bool value) {
    SetSchemaValue(m_ptr, "CEnvProjectedTexture", "m_bEnableShadows", false, value);
}
bool GCEnvProjectedTexture::GetSimpleProjection() const {
    return GetSchemaValue<bool>(m_ptr, "CEnvProjectedTexture", "m_bSimpleProjection");
}
void GCEnvProjectedTexture::SetSimpleProjection(bool value) {
    SetSchemaValue(m_ptr, "CEnvProjectedTexture", "m_bSimpleProjection", false, value);
}
bool GCEnvProjectedTexture::GetLightOnlyTarget() const {
    return GetSchemaValue<bool>(m_ptr, "CEnvProjectedTexture", "m_bLightOnlyTarget");
}
void GCEnvProjectedTexture::SetLightOnlyTarget(bool value) {
    SetSchemaValue(m_ptr, "CEnvProjectedTexture", "m_bLightOnlyTarget", false, value);
}
bool GCEnvProjectedTexture::GetLightWorld() const {
    return GetSchemaValue<bool>(m_ptr, "CEnvProjectedTexture", "m_bLightWorld");
}
void GCEnvProjectedTexture::SetLightWorld(bool value) {
    SetSchemaValue(m_ptr, "CEnvProjectedTexture", "m_bLightWorld", false, value);
}
bool GCEnvProjectedTexture::GetCameraSpace() const {
    return GetSchemaValue<bool>(m_ptr, "CEnvProjectedTexture", "m_bCameraSpace");
}
void GCEnvProjectedTexture::SetCameraSpace(bool value) {
    SetSchemaValue(m_ptr, "CEnvProjectedTexture", "m_bCameraSpace", false, value);
}
float GCEnvProjectedTexture::GetBrightnessScale() const {
    return GetSchemaValue<float>(m_ptr, "CEnvProjectedTexture", "m_flBrightnessScale");
}
void GCEnvProjectedTexture::SetBrightnessScale(float value) {
    SetSchemaValue(m_ptr, "CEnvProjectedTexture", "m_flBrightnessScale", false, value);
}
Color GCEnvProjectedTexture::GetLightColor() const {
    return GetSchemaValue<Color>(m_ptr, "CEnvProjectedTexture", "m_LightColor");
}
void GCEnvProjectedTexture::SetLightColor(Color value) {
    SetSchemaValue(m_ptr, "CEnvProjectedTexture", "m_LightColor", false, value);
}
float GCEnvProjectedTexture::GetIntensity() const {
    return GetSchemaValue<float>(m_ptr, "CEnvProjectedTexture", "m_flIntensity");
}
void GCEnvProjectedTexture::SetIntensity(float value) {
    SetSchemaValue(m_ptr, "CEnvProjectedTexture", "m_flIntensity", false, value);
}
float GCEnvProjectedTexture::GetLinearAttenuation() const {
    return GetSchemaValue<float>(m_ptr, "CEnvProjectedTexture", "m_flLinearAttenuation");
}
void GCEnvProjectedTexture::SetLinearAttenuation(float value) {
    SetSchemaValue(m_ptr, "CEnvProjectedTexture", "m_flLinearAttenuation", false, value);
}
float GCEnvProjectedTexture::GetQuadraticAttenuation() const {
    return GetSchemaValue<float>(m_ptr, "CEnvProjectedTexture", "m_flQuadraticAttenuation");
}
void GCEnvProjectedTexture::SetQuadraticAttenuation(float value) {
    SetSchemaValue(m_ptr, "CEnvProjectedTexture", "m_flQuadraticAttenuation", false, value);
}
bool GCEnvProjectedTexture::GetVolumetric() const {
    return GetSchemaValue<bool>(m_ptr, "CEnvProjectedTexture", "m_bVolumetric");
}
void GCEnvProjectedTexture::SetVolumetric(bool value) {
    SetSchemaValue(m_ptr, "CEnvProjectedTexture", "m_bVolumetric", false, value);
}
float GCEnvProjectedTexture::GetNoiseStrength() const {
    return GetSchemaValue<float>(m_ptr, "CEnvProjectedTexture", "m_flNoiseStrength");
}
void GCEnvProjectedTexture::SetNoiseStrength(float value) {
    SetSchemaValue(m_ptr, "CEnvProjectedTexture", "m_flNoiseStrength", false, value);
}
float GCEnvProjectedTexture::GetFlashlightTime() const {
    return GetSchemaValue<float>(m_ptr, "CEnvProjectedTexture", "m_flFlashlightTime");
}
void GCEnvProjectedTexture::SetFlashlightTime(float value) {
    SetSchemaValue(m_ptr, "CEnvProjectedTexture", "m_flFlashlightTime", false, value);
}
uint32_t GCEnvProjectedTexture::GetNumPlanes() const {
    return GetSchemaValue<uint32_t>(m_ptr, "CEnvProjectedTexture", "m_nNumPlanes");
}
void GCEnvProjectedTexture::SetNumPlanes(uint32_t value) {
    SetSchemaValue(m_ptr, "CEnvProjectedTexture", "m_nNumPlanes", false, value);
}
float GCEnvProjectedTexture::GetPlaneOffset() const {
    return GetSchemaValue<float>(m_ptr, "CEnvProjectedTexture", "m_flPlaneOffset");
}
void GCEnvProjectedTexture::SetPlaneOffset(float value) {
    SetSchemaValue(m_ptr, "CEnvProjectedTexture", "m_flPlaneOffset", false, value);
}
float GCEnvProjectedTexture::GetVolumetricIntensity() const {
    return GetSchemaValue<float>(m_ptr, "CEnvProjectedTexture", "m_flVolumetricIntensity");
}
void GCEnvProjectedTexture::SetVolumetricIntensity(float value) {
    SetSchemaValue(m_ptr, "CEnvProjectedTexture", "m_flVolumetricIntensity", false, value);
}
float GCEnvProjectedTexture::GetColorTransitionTime() const {
    return GetSchemaValue<float>(m_ptr, "CEnvProjectedTexture", "m_flColorTransitionTime");
}
void GCEnvProjectedTexture::SetColorTransitionTime(float value) {
    SetSchemaValue(m_ptr, "CEnvProjectedTexture", "m_flColorTransitionTime", false, value);
}
float GCEnvProjectedTexture::GetAmbient() const {
    return GetSchemaValue<float>(m_ptr, "CEnvProjectedTexture", "m_flAmbient");
}
void GCEnvProjectedTexture::SetAmbient(float value) {
    SetSchemaValue(m_ptr, "CEnvProjectedTexture", "m_flAmbient", false, value);
}
std::string GCEnvProjectedTexture::GetSpotlightTextureName() const {
    return GetSchemaValuePtr<char>(m_ptr, "CEnvProjectedTexture", "m_SpotlightTextureName");
}
void GCEnvProjectedTexture::SetSpotlightTextureName(std::string value) {
    WriteSchemaPtrValue(m_ptr, "CEnvProjectedTexture", "m_SpotlightTextureName", false, reinterpret_cast<byte*>(const_cast<char*>(value.c_str())), 512);
}
int32_t GCEnvProjectedTexture::GetSpotlightTextureFrame() const {
    return GetSchemaValue<int32_t>(m_ptr, "CEnvProjectedTexture", "m_nSpotlightTextureFrame");
}
void GCEnvProjectedTexture::SetSpotlightTextureFrame(int32_t value) {
    SetSchemaValue(m_ptr, "CEnvProjectedTexture", "m_nSpotlightTextureFrame", false, value);
}
uint32_t GCEnvProjectedTexture::GetShadowQuality() const {
    return GetSchemaValue<uint32_t>(m_ptr, "CEnvProjectedTexture", "m_nShadowQuality");
}
void GCEnvProjectedTexture::SetShadowQuality(uint32_t value) {
    SetSchemaValue(m_ptr, "CEnvProjectedTexture", "m_nShadowQuality", false, value);
}
float GCEnvProjectedTexture::GetNearZ() const {
    return GetSchemaValue<float>(m_ptr, "CEnvProjectedTexture", "m_flNearZ");
}
void GCEnvProjectedTexture::SetNearZ(float value) {
    SetSchemaValue(m_ptr, "CEnvProjectedTexture", "m_flNearZ", false, value);
}
float GCEnvProjectedTexture::GetFarZ() const {
    return GetSchemaValue<float>(m_ptr, "CEnvProjectedTexture", "m_flFarZ");
}
void GCEnvProjectedTexture::SetFarZ(float value) {
    SetSchemaValue(m_ptr, "CEnvProjectedTexture", "m_flFarZ", false, value);
}
float GCEnvProjectedTexture::GetProjectionSize() const {
    return GetSchemaValue<float>(m_ptr, "CEnvProjectedTexture", "m_flProjectionSize");
}
void GCEnvProjectedTexture::SetProjectionSize(float value) {
    SetSchemaValue(m_ptr, "CEnvProjectedTexture", "m_flProjectionSize", false, value);
}
float GCEnvProjectedTexture::GetRotation() const {
    return GetSchemaValue<float>(m_ptr, "CEnvProjectedTexture", "m_flRotation");
}
void GCEnvProjectedTexture::SetRotation(float value) {
    SetSchemaValue(m_ptr, "CEnvProjectedTexture", "m_flRotation", false, value);
}
bool GCEnvProjectedTexture::GetFlipHorizontal() const {
    return GetSchemaValue<bool>(m_ptr, "CEnvProjectedTexture", "m_bFlipHorizontal");
}
void GCEnvProjectedTexture::SetFlipHorizontal(bool value) {
    SetSchemaValue(m_ptr, "CEnvProjectedTexture", "m_bFlipHorizontal", false, value);
}
std::string GCEnvProjectedTexture::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCEnvProjectedTexture::IsValid() {
    return (m_ptr != nullptr);
}
GCModelPointEntity GCEnvProjectedTexture::GetParent() const {
    GCModelPointEntity value(m_ptr);
    return value;
}
void GCEnvProjectedTexture::SetParent(GCModelPointEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCEnvProjectedTexture(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCEnvProjectedTexture>("CEnvProjectedTexture")
        .addConstructor<void (*)(std::string)>()
        .addProperty("TargetEntity", &GCEnvProjectedTexture::GetTargetEntity, &GCEnvProjectedTexture::SetTargetEntity)
        .addProperty("State", &GCEnvProjectedTexture::GetState, &GCEnvProjectedTexture::SetState)
        .addProperty("AlwaysUpdate", &GCEnvProjectedTexture::GetAlwaysUpdate, &GCEnvProjectedTexture::SetAlwaysUpdate)
        .addProperty("LightFOV", &GCEnvProjectedTexture::GetLightFOV, &GCEnvProjectedTexture::SetLightFOV)
        .addProperty("EnableShadows", &GCEnvProjectedTexture::GetEnableShadows, &GCEnvProjectedTexture::SetEnableShadows)
        .addProperty("SimpleProjection", &GCEnvProjectedTexture::GetSimpleProjection, &GCEnvProjectedTexture::SetSimpleProjection)
        .addProperty("LightOnlyTarget", &GCEnvProjectedTexture::GetLightOnlyTarget, &GCEnvProjectedTexture::SetLightOnlyTarget)
        .addProperty("LightWorld", &GCEnvProjectedTexture::GetLightWorld, &GCEnvProjectedTexture::SetLightWorld)
        .addProperty("CameraSpace", &GCEnvProjectedTexture::GetCameraSpace, &GCEnvProjectedTexture::SetCameraSpace)
        .addProperty("BrightnessScale", &GCEnvProjectedTexture::GetBrightnessScale, &GCEnvProjectedTexture::SetBrightnessScale)
        .addProperty("LightColor", &GCEnvProjectedTexture::GetLightColor, &GCEnvProjectedTexture::SetLightColor)
        .addProperty("Intensity", &GCEnvProjectedTexture::GetIntensity, &GCEnvProjectedTexture::SetIntensity)
        .addProperty("LinearAttenuation", &GCEnvProjectedTexture::GetLinearAttenuation, &GCEnvProjectedTexture::SetLinearAttenuation)
        .addProperty("QuadraticAttenuation", &GCEnvProjectedTexture::GetQuadraticAttenuation, &GCEnvProjectedTexture::SetQuadraticAttenuation)
        .addProperty("Volumetric", &GCEnvProjectedTexture::GetVolumetric, &GCEnvProjectedTexture::SetVolumetric)
        .addProperty("NoiseStrength", &GCEnvProjectedTexture::GetNoiseStrength, &GCEnvProjectedTexture::SetNoiseStrength)
        .addProperty("FlashlightTime", &GCEnvProjectedTexture::GetFlashlightTime, &GCEnvProjectedTexture::SetFlashlightTime)
        .addProperty("NumPlanes", &GCEnvProjectedTexture::GetNumPlanes, &GCEnvProjectedTexture::SetNumPlanes)
        .addProperty("PlaneOffset", &GCEnvProjectedTexture::GetPlaneOffset, &GCEnvProjectedTexture::SetPlaneOffset)
        .addProperty("VolumetricIntensity", &GCEnvProjectedTexture::GetVolumetricIntensity, &GCEnvProjectedTexture::SetVolumetricIntensity)
        .addProperty("ColorTransitionTime", &GCEnvProjectedTexture::GetColorTransitionTime, &GCEnvProjectedTexture::SetColorTransitionTime)
        .addProperty("Ambient", &GCEnvProjectedTexture::GetAmbient, &GCEnvProjectedTexture::SetAmbient)
        .addProperty("SpotlightTextureName", &GCEnvProjectedTexture::GetSpotlightTextureName, &GCEnvProjectedTexture::SetSpotlightTextureName)
        .addProperty("SpotlightTextureFrame", &GCEnvProjectedTexture::GetSpotlightTextureFrame, &GCEnvProjectedTexture::SetSpotlightTextureFrame)
        .addProperty("ShadowQuality", &GCEnvProjectedTexture::GetShadowQuality, &GCEnvProjectedTexture::SetShadowQuality)
        .addProperty("NearZ", &GCEnvProjectedTexture::GetNearZ, &GCEnvProjectedTexture::SetNearZ)
        .addProperty("FarZ", &GCEnvProjectedTexture::GetFarZ, &GCEnvProjectedTexture::SetFarZ)
        .addProperty("ProjectionSize", &GCEnvProjectedTexture::GetProjectionSize, &GCEnvProjectedTexture::SetProjectionSize)
        .addProperty("Rotation", &GCEnvProjectedTexture::GetRotation, &GCEnvProjectedTexture::SetRotation)
        .addProperty("FlipHorizontal", &GCEnvProjectedTexture::GetFlipHorizontal, &GCEnvProjectedTexture::SetFlipHorizontal)
        .addProperty("Parent", &GCEnvProjectedTexture::GetParent, &GCEnvProjectedTexture::SetParent)
        .addFunction("ToPtr", &GCEnvProjectedTexture::ToPtr)
        .addFunction("IsValid", &GCEnvProjectedTexture::IsValid)
        .endClass();
}
GCDynamicPropAlias_prop_dynamic_override::GCDynamicPropAlias_prop_dynamic_override(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCDynamicPropAlias_prop_dynamic_override::GCDynamicPropAlias_prop_dynamic_override(void *ptr) {
    m_ptr = ptr;
}
std::string GCDynamicPropAlias_prop_dynamic_override::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCDynamicPropAlias_prop_dynamic_override::IsValid() {
    return (m_ptr != nullptr);
}
GCDynamicProp GCDynamicPropAlias_prop_dynamic_override::GetParent() const {
    GCDynamicProp value(m_ptr);
    return value;
}
void GCDynamicPropAlias_prop_dynamic_override::SetParent(GCDynamicProp value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCDynamicPropAlias_prop_dynamic_override(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCDynamicPropAlias_prop_dynamic_override>("CDynamicPropAlias_prop_dynamic_override")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCDynamicPropAlias_prop_dynamic_override::GetParent, &GCDynamicPropAlias_prop_dynamic_override::SetParent)
        .addFunction("ToPtr", &GCDynamicPropAlias_prop_dynamic_override::ToPtr)
        .addFunction("IsValid", &GCDynamicPropAlias_prop_dynamic_override::IsValid)
        .endClass();
}
GCSceneListManager::GCSceneListManager(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCSceneListManager::GCSceneListManager(void *ptr) {
    m_ptr = ptr;
}
std::vector<CUtlSymbolLarge> GCSceneListManager::GetScenes() const {
    CUtlSymbolLarge* outValue = GetSchemaValue<CUtlSymbolLarge*>(m_ptr, "CSceneListManager", "m_iszScenes"); std::vector<CUtlSymbolLarge> ret; for(int i = 0; i < 16; i++) { ret.push_back(outValue[i]); } return ret;
}
void GCSceneListManager::SetScenes(std::vector<CUtlSymbolLarge> value) {
    CUtlSymbolLarge* outValue = GetSchemaValue<CUtlSymbolLarge*>(m_ptr, "CSceneListManager", "m_iszScenes"); for(int i = 0; i < 16; i++) { outValue[i] = value[i]; } SetSchemaValue(m_ptr, "CSceneListManager", "m_iszScenes", false, outValue);
}
std::vector<GCBaseEntity*> GCSceneListManager::GetScenes1() const {
    GCBaseEntity** outValue = GetSchemaValue<GCBaseEntity**>(m_ptr, "CSceneListManager", "m_hScenes"); std::vector<GCBaseEntity*> ret; for(int i = 0; i < 16; i++) { ret.push_back(outValue[i]); } return ret;
}
void GCSceneListManager::SetScenes1(std::vector<GCBaseEntity*> value) {
    GCBaseEntity** outValue = GetSchemaValue<GCBaseEntity**>(m_ptr, "CSceneListManager", "m_hScenes"); for(int i = 0; i < 16; i++) { outValue[i] = value[i]; } SetSchemaValue(m_ptr, "CSceneListManager", "m_hScenes", false, outValue);
}
std::string GCSceneListManager::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCSceneListManager::IsValid() {
    return (m_ptr != nullptr);
}
GCLogicalEntity GCSceneListManager::GetParent() const {
    GCLogicalEntity value(m_ptr);
    return value;
}
void GCSceneListManager::SetParent(GCLogicalEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCSceneListManager(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCSceneListManager>("CSceneListManager")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Scenes", &GCSceneListManager::GetScenes, &GCSceneListManager::SetScenes)
        .addProperty("Scenes1", &GCSceneListManager::GetScenes1, &GCSceneListManager::SetScenes1)
        .addProperty("Parent", &GCSceneListManager::GetParent, &GCSceneListManager::SetParent)
        .addFunction("ToPtr", &GCSceneListManager::ToPtr)
        .addFunction("IsValid", &GCSceneListManager::IsValid)
        .endClass();
}
GCSplineConstraint::GCSplineConstraint(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCSplineConstraint::GCSplineConstraint(void *ptr) {
    m_ptr = ptr;
}
Vector GCSplineConstraint::GetAnchorOffsetRestore() const {
    return GetSchemaValue<Vector>(m_ptr, "CSplineConstraint", "m_vAnchorOffsetRestore");
}
void GCSplineConstraint::SetAnchorOffsetRestore(Vector value) {
    SetSchemaValue(m_ptr, "CSplineConstraint", "m_vAnchorOffsetRestore", false, value);
}
std::string GCSplineConstraint::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCSplineConstraint::IsValid() {
    return (m_ptr != nullptr);
}
GCPhysConstraint GCSplineConstraint::GetParent() const {
    GCPhysConstraint value(m_ptr);
    return value;
}
void GCSplineConstraint::SetParent(GCPhysConstraint value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCSplineConstraint(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCSplineConstraint>("CSplineConstraint")
        .addConstructor<void (*)(std::string)>()
        .addProperty("AnchorOffsetRestore", &GCSplineConstraint::GetAnchorOffsetRestore, &GCSplineConstraint::SetAnchorOffsetRestore)
        .addProperty("Parent", &GCSplineConstraint::GetParent, &GCSplineConstraint::SetParent)
        .addFunction("ToPtr", &GCSplineConstraint::ToPtr)
        .addFunction("IsValid", &GCSplineConstraint::IsValid)
        .endClass();
}
GCCSObserver_ViewModelServices::GCCSObserver_ViewModelServices(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCCSObserver_ViewModelServices::GCCSObserver_ViewModelServices(void *ptr) {
    m_ptr = ptr;
}
std::string GCCSObserver_ViewModelServices::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCCSObserver_ViewModelServices::IsValid() {
    return (m_ptr != nullptr);
}
GCPlayer_ViewModelServices GCCSObserver_ViewModelServices::GetParent() const {
    GCPlayer_ViewModelServices value(m_ptr);
    return value;
}
void GCCSObserver_ViewModelServices::SetParent(GCPlayer_ViewModelServices value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCCSObserver_ViewModelServices(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCCSObserver_ViewModelServices>("CCSObserver_ViewModelServices")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCCSObserver_ViewModelServices::GetParent, &GCCSObserver_ViewModelServices::SetParent)
        .addFunction("ToPtr", &GCCSObserver_ViewModelServices::ToPtr)
        .addFunction("IsValid", &GCCSObserver_ViewModelServices::IsValid)
        .endClass();
}
GCDynamicPropAlias_dynamic_prop::GCDynamicPropAlias_dynamic_prop(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCDynamicPropAlias_dynamic_prop::GCDynamicPropAlias_dynamic_prop(void *ptr) {
    m_ptr = ptr;
}
std::string GCDynamicPropAlias_dynamic_prop::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCDynamicPropAlias_dynamic_prop::IsValid() {
    return (m_ptr != nullptr);
}
GCDynamicProp GCDynamicPropAlias_dynamic_prop::GetParent() const {
    GCDynamicProp value(m_ptr);
    return value;
}
void GCDynamicPropAlias_dynamic_prop::SetParent(GCDynamicProp value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCDynamicPropAlias_dynamic_prop(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCDynamicPropAlias_dynamic_prop>("CDynamicPropAlias_dynamic_prop")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCDynamicPropAlias_dynamic_prop::GetParent, &GCDynamicPropAlias_dynamic_prop::SetParent)
        .addFunction("ToPtr", &GCDynamicPropAlias_dynamic_prop::ToPtr)
        .addFunction("IsValid", &GCDynamicPropAlias_dynamic_prop::IsValid)
        .endClass();
}
GModelConfigHandle_t::GModelConfigHandle_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GModelConfigHandle_t::GModelConfigHandle_t(void *ptr) {
    m_ptr = ptr;
}
uint32_t GModelConfigHandle_t::GetValue() const {
    return GetSchemaValue<uint32_t>(m_ptr, "ModelConfigHandle_t", "m_Value");
}
void GModelConfigHandle_t::SetValue(uint32_t value) {
    SetSchemaValue(m_ptr, "ModelConfigHandle_t", "m_Value", true, value);
}
std::string GModelConfigHandle_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GModelConfigHandle_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassModelConfigHandle_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GModelConfigHandle_t>("ModelConfigHandle_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Value", &GModelConfigHandle_t::GetValue, &GModelConfigHandle_t::SetValue)
        .addFunction("ToPtr", &GModelConfigHandle_t::ToPtr)
        .addFunction("IsValid", &GModelConfigHandle_t::IsValid)
        .endClass();
}
GCPhysicsPropMultiplayer::GCPhysicsPropMultiplayer(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCPhysicsPropMultiplayer::GCPhysicsPropMultiplayer(void *ptr) {
    m_ptr = ptr;
}
std::string GCPhysicsPropMultiplayer::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCPhysicsPropMultiplayer::IsValid() {
    return (m_ptr != nullptr);
}
GCPhysicsProp GCPhysicsPropMultiplayer::GetParent() const {
    GCPhysicsProp value(m_ptr);
    return value;
}
void GCPhysicsPropMultiplayer::SetParent(GCPhysicsProp value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCPhysicsPropMultiplayer(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCPhysicsPropMultiplayer>("CPhysicsPropMultiplayer")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCPhysicsPropMultiplayer::GetParent, &GCPhysicsPropMultiplayer::SetParent)
        .addFunction("ToPtr", &GCPhysicsPropMultiplayer::ToPtr)
        .addFunction("IsValid", &GCPhysicsPropMultiplayer::IsValid)
        .endClass();
}
GCFuncTrackChange::GCFuncTrackChange(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCFuncTrackChange::GCFuncTrackChange(void *ptr) {
    m_ptr = ptr;
}
GCPathTrack GCFuncTrackChange::GetTrackTop() const {
    GCPathTrack value(*GetSchemaValuePtr<void*>(m_ptr, "CFuncTrackChange", "m_trackTop"));
    return value;
}
void GCFuncTrackChange::SetTrackTop(GCPathTrack* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'TrackTop' is not possible.\n");
}
GCPathTrack GCFuncTrackChange::GetTrackBottom() const {
    GCPathTrack value(*GetSchemaValuePtr<void*>(m_ptr, "CFuncTrackChange", "m_trackBottom"));
    return value;
}
void GCFuncTrackChange::SetTrackBottom(GCPathTrack* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'TrackBottom' is not possible.\n");
}
GCFuncTrackTrain GCFuncTrackChange::GetTrain() const {
    GCFuncTrackTrain value(*GetSchemaValuePtr<void*>(m_ptr, "CFuncTrackChange", "m_train"));
    return value;
}
void GCFuncTrackChange::SetTrain(GCFuncTrackTrain* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Train' is not possible.\n");
}
std::string GCFuncTrackChange::GetTrackTopName() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CFuncTrackChange", "m_trackTopName").String();
}
void GCFuncTrackChange::SetTrackTopName(std::string value) {
    SetSchemaValue(m_ptr, "CFuncTrackChange", "m_trackTopName", false, CUtlSymbolLarge(value.c_str()));
}
std::string GCFuncTrackChange::GetTrackBottomName() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CFuncTrackChange", "m_trackBottomName").String();
}
void GCFuncTrackChange::SetTrackBottomName(std::string value) {
    SetSchemaValue(m_ptr, "CFuncTrackChange", "m_trackBottomName", false, CUtlSymbolLarge(value.c_str()));
}
std::string GCFuncTrackChange::GetTrainName() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CFuncTrackChange", "m_trainName").String();
}
void GCFuncTrackChange::SetTrainName(std::string value) {
    SetSchemaValue(m_ptr, "CFuncTrackChange", "m_trainName", false, CUtlSymbolLarge(value.c_str()));
}
uint64_t GCFuncTrackChange::GetCode() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CFuncTrackChange", "m_code");
}
void GCFuncTrackChange::SetCode(uint64_t value) {
    SetSchemaValue(m_ptr, "CFuncTrackChange", "m_code", false, value);
}
int32_t GCFuncTrackChange::GetTargetState() const {
    return GetSchemaValue<int32_t>(m_ptr, "CFuncTrackChange", "m_targetState");
}
void GCFuncTrackChange::SetTargetState(int32_t value) {
    SetSchemaValue(m_ptr, "CFuncTrackChange", "m_targetState", false, value);
}
int32_t GCFuncTrackChange::GetUse() const {
    return GetSchemaValue<int32_t>(m_ptr, "CFuncTrackChange", "m_use");
}
void GCFuncTrackChange::SetUse(int32_t value) {
    SetSchemaValue(m_ptr, "CFuncTrackChange", "m_use", false, value);
}
std::string GCFuncTrackChange::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCFuncTrackChange::IsValid() {
    return (m_ptr != nullptr);
}
GCFuncPlatRot GCFuncTrackChange::GetParent() const {
    GCFuncPlatRot value(m_ptr);
    return value;
}
void GCFuncTrackChange::SetParent(GCFuncPlatRot value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCFuncTrackChange(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCFuncTrackChange>("CFuncTrackChange")
        .addConstructor<void (*)(std::string)>()
        .addProperty("TrackTop", &GCFuncTrackChange::GetTrackTop, &GCFuncTrackChange::SetTrackTop)
        .addProperty("TrackBottom", &GCFuncTrackChange::GetTrackBottom, &GCFuncTrackChange::SetTrackBottom)
        .addProperty("Train", &GCFuncTrackChange::GetTrain, &GCFuncTrackChange::SetTrain)
        .addProperty("TrackTopName", &GCFuncTrackChange::GetTrackTopName, &GCFuncTrackChange::SetTrackTopName)
        .addProperty("TrackBottomName", &GCFuncTrackChange::GetTrackBottomName, &GCFuncTrackChange::SetTrackBottomName)
        .addProperty("TrainName", &GCFuncTrackChange::GetTrainName, &GCFuncTrackChange::SetTrainName)
        .addProperty("Code", &GCFuncTrackChange::GetCode, &GCFuncTrackChange::SetCode)
        .addProperty("TargetState", &GCFuncTrackChange::GetTargetState, &GCFuncTrackChange::SetTargetState)
        .addProperty("Use", &GCFuncTrackChange::GetUse, &GCFuncTrackChange::SetUse)
        .addProperty("Parent", &GCFuncTrackChange::GetParent, &GCFuncTrackChange::SetParent)
        .addFunction("ToPtr", &GCFuncTrackChange::ToPtr)
        .addFunction("IsValid", &GCFuncTrackChange::IsValid)
        .endClass();
}
GCMarkupVolume::GCMarkupVolume(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCMarkupVolume::GCMarkupVolume(void *ptr) {
    m_ptr = ptr;
}
bool GCMarkupVolume::GetDisabled() const {
    return GetSchemaValue<bool>(m_ptr, "CMarkupVolume", "m_bDisabled");
}
void GCMarkupVolume::SetDisabled(bool value) {
    SetSchemaValue(m_ptr, "CMarkupVolume", "m_bDisabled", false, value);
}
std::string GCMarkupVolume::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCMarkupVolume::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseModelEntity GCMarkupVolume::GetParent() const {
    GCBaseModelEntity value(m_ptr);
    return value;
}
void GCMarkupVolume::SetParent(GCBaseModelEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCMarkupVolume(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCMarkupVolume>("CMarkupVolume")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Disabled", &GCMarkupVolume::GetDisabled, &GCMarkupVolume::SetDisabled)
        .addProperty("Parent", &GCMarkupVolume::GetParent, &GCMarkupVolume::SetParent)
        .addFunction("ToPtr", &GCMarkupVolume::ToPtr)
        .addFunction("IsValid", &GCMarkupVolume::IsValid)
        .endClass();
}
GCInfoPlayerTerrorist::GCInfoPlayerTerrorist(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCInfoPlayerTerrorist::GCInfoPlayerTerrorist(void *ptr) {
    m_ptr = ptr;
}
std::string GCInfoPlayerTerrorist::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCInfoPlayerTerrorist::IsValid() {
    return (m_ptr != nullptr);
}
GSpawnPoint GCInfoPlayerTerrorist::GetParent() const {
    GSpawnPoint value(m_ptr);
    return value;
}
void GCInfoPlayerTerrorist::SetParent(GSpawnPoint value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCInfoPlayerTerrorist(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCInfoPlayerTerrorist>("CInfoPlayerTerrorist")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCInfoPlayerTerrorist::GetParent, &GCInfoPlayerTerrorist::SetParent)
        .addFunction("ToPtr", &GCInfoPlayerTerrorist::ToPtr)
        .addFunction("IsValid", &GCInfoPlayerTerrorist::IsValid)
        .endClass();
}
GVelocitySampler::GVelocitySampler(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GVelocitySampler::GVelocitySampler(void *ptr) {
    m_ptr = ptr;
}
Vector GVelocitySampler::GetPrevSample() const {
    return GetSchemaValue<Vector>(m_ptr, "VelocitySampler", "m_prevSample");
}
void GVelocitySampler::SetPrevSample(Vector value) {
    SetSchemaValue(m_ptr, "VelocitySampler", "m_prevSample", false, value);
}
float GVelocitySampler::GetPrevSampleTime() const {
    return GetSchemaValue<float>(m_ptr, "VelocitySampler", "m_fPrevSampleTime");
}
void GVelocitySampler::SetPrevSampleTime(float value) {
    SetSchemaValue(m_ptr, "VelocitySampler", "m_fPrevSampleTime", false, value);
}
float GVelocitySampler::GetIdealSampleRate() const {
    return GetSchemaValue<float>(m_ptr, "VelocitySampler", "m_fIdealSampleRate");
}
void GVelocitySampler::SetIdealSampleRate(float value) {
    SetSchemaValue(m_ptr, "VelocitySampler", "m_fIdealSampleRate", false, value);
}
std::string GVelocitySampler::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GVelocitySampler::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassVelocitySampler(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GVelocitySampler>("VelocitySampler")
        .addConstructor<void (*)(std::string)>()
        .addProperty("PrevSample", &GVelocitySampler::GetPrevSample, &GVelocitySampler::SetPrevSample)
        .addProperty("PrevSampleTime", &GVelocitySampler::GetPrevSampleTime, &GVelocitySampler::SetPrevSampleTime)
        .addProperty("IdealSampleRate", &GVelocitySampler::GetIdealSampleRate, &GVelocitySampler::SetIdealSampleRate)
        .addFunction("ToPtr", &GVelocitySampler::ToPtr)
        .addFunction("IsValid", &GVelocitySampler::IsValid)
        .endClass();
}
GCTankTargetChange::GCTankTargetChange(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCTankTargetChange::GCTankTargetChange(void *ptr) {
    m_ptr = ptr;
}
std::string GCTankTargetChange::GetNewTargetName() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CTankTargetChange", "m_newTargetName").String();
}
void GCTankTargetChange::SetNewTargetName(std::string value) {
    SetSchemaValue(m_ptr, "CTankTargetChange", "m_newTargetName", false, CUtlSymbolLarge(value.c_str()));
}
std::string GCTankTargetChange::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCTankTargetChange::IsValid() {
    return (m_ptr != nullptr);
}
GCPointEntity GCTankTargetChange::GetParent() const {
    GCPointEntity value(m_ptr);
    return value;
}
void GCTankTargetChange::SetParent(GCPointEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCTankTargetChange(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCTankTargetChange>("CTankTargetChange")
        .addConstructor<void (*)(std::string)>()
        .addProperty("NewTargetName", &GCTankTargetChange::GetNewTargetName, &GCTankTargetChange::SetNewTargetName)
        .addProperty("Parent", &GCTankTargetChange::GetParent, &GCTankTargetChange::SetParent)
        .addFunction("ToPtr", &GCTankTargetChange::ToPtr)
        .addFunction("IsValid", &GCTankTargetChange::IsValid)
        .endClass();
}
GCLogicCompare::GCLogicCompare(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCLogicCompare::GCLogicCompare(void *ptr) {
    m_ptr = ptr;
}
float GCLogicCompare::GetInValue() const {
    return GetSchemaValue<float>(m_ptr, "CLogicCompare", "m_flInValue");
}
void GCLogicCompare::SetInValue(float value) {
    SetSchemaValue(m_ptr, "CLogicCompare", "m_flInValue", false, value);
}
float GCLogicCompare::GetCompareValue() const {
    return GetSchemaValue<float>(m_ptr, "CLogicCompare", "m_flCompareValue");
}
void GCLogicCompare::SetCompareValue(float value) {
    SetSchemaValue(m_ptr, "CLogicCompare", "m_flCompareValue", false, value);
}
std::string GCLogicCompare::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCLogicCompare::IsValid() {
    return (m_ptr != nullptr);
}
GCLogicalEntity GCLogicCompare::GetParent() const {
    GCLogicalEntity value(m_ptr);
    return value;
}
void GCLogicCompare::SetParent(GCLogicalEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCLogicCompare(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCLogicCompare>("CLogicCompare")
        .addConstructor<void (*)(std::string)>()
        .addProperty("InValue", &GCLogicCompare::GetInValue, &GCLogicCompare::SetInValue)
        .addProperty("CompareValue", &GCLogicCompare::GetCompareValue, &GCLogicCompare::SetCompareValue)
        .addProperty("Parent", &GCLogicCompare::GetParent, &GCLogicCompare::SetParent)
        .addFunction("ToPtr", &GCLogicCompare::ToPtr)
        .addFunction("IsValid", &GCLogicCompare::IsValid)
        .endClass();
}
GCCSPlayer_BulletServices::GCCSPlayer_BulletServices(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCCSPlayer_BulletServices::GCCSPlayer_BulletServices(void *ptr) {
    m_ptr = ptr;
}
int32_t GCCSPlayer_BulletServices::GetTotalHitsOnServer() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSPlayer_BulletServices", "m_totalHitsOnServer");
}
void GCCSPlayer_BulletServices::SetTotalHitsOnServer(int32_t value) {
    SetSchemaValue(m_ptr, "CCSPlayer_BulletServices", "m_totalHitsOnServer", false, value);
}
std::string GCCSPlayer_BulletServices::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCCSPlayer_BulletServices::IsValid() {
    return (m_ptr != nullptr);
}
GCPlayerPawnComponent GCCSPlayer_BulletServices::GetParent() const {
    GCPlayerPawnComponent value(m_ptr);
    return value;
}
void GCCSPlayer_BulletServices::SetParent(GCPlayerPawnComponent value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCCSPlayer_BulletServices(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCCSPlayer_BulletServices>("CCSPlayer_BulletServices")
        .addConstructor<void (*)(std::string)>()
        .addProperty("TotalHitsOnServer", &GCCSPlayer_BulletServices::GetTotalHitsOnServer, &GCCSPlayer_BulletServices::SetTotalHitsOnServer)
        .addProperty("Parent", &GCCSPlayer_BulletServices::GetParent, &GCCSPlayer_BulletServices::SetParent)
        .addFunction("ToPtr", &GCCSPlayer_BulletServices::ToPtr)
        .addFunction("IsValid", &GCCSPlayer_BulletServices::IsValid)
        .endClass();
}
GCLogicRelay::GCLogicRelay(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCLogicRelay::GCLogicRelay(void *ptr) {
    m_ptr = ptr;
}
GCEntityIOOutput GCLogicRelay::GetOnTrigger() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CLogicRelay", "m_OnTrigger"));
    return value;
}
void GCLogicRelay::SetOnTrigger(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CLogicRelay", "m_OnTrigger", false, value);
}
GCEntityIOOutput GCLogicRelay::GetOnSpawn() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CLogicRelay", "m_OnSpawn"));
    return value;
}
void GCLogicRelay::SetOnSpawn(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CLogicRelay", "m_OnSpawn", false, value);
}
bool GCLogicRelay::GetDisabled() const {
    return GetSchemaValue<bool>(m_ptr, "CLogicRelay", "m_bDisabled");
}
void GCLogicRelay::SetDisabled(bool value) {
    SetSchemaValue(m_ptr, "CLogicRelay", "m_bDisabled", false, value);
}
bool GCLogicRelay::GetWaitForRefire() const {
    return GetSchemaValue<bool>(m_ptr, "CLogicRelay", "m_bWaitForRefire");
}
void GCLogicRelay::SetWaitForRefire(bool value) {
    SetSchemaValue(m_ptr, "CLogicRelay", "m_bWaitForRefire", false, value);
}
bool GCLogicRelay::GetTriggerOnce() const {
    return GetSchemaValue<bool>(m_ptr, "CLogicRelay", "m_bTriggerOnce");
}
void GCLogicRelay::SetTriggerOnce(bool value) {
    SetSchemaValue(m_ptr, "CLogicRelay", "m_bTriggerOnce", false, value);
}
bool GCLogicRelay::GetFastRetrigger() const {
    return GetSchemaValue<bool>(m_ptr, "CLogicRelay", "m_bFastRetrigger");
}
void GCLogicRelay::SetFastRetrigger(bool value) {
    SetSchemaValue(m_ptr, "CLogicRelay", "m_bFastRetrigger", false, value);
}
bool GCLogicRelay::GetPassthoughCaller() const {
    return GetSchemaValue<bool>(m_ptr, "CLogicRelay", "m_bPassthoughCaller");
}
void GCLogicRelay::SetPassthoughCaller(bool value) {
    SetSchemaValue(m_ptr, "CLogicRelay", "m_bPassthoughCaller", false, value);
}
std::string GCLogicRelay::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCLogicRelay::IsValid() {
    return (m_ptr != nullptr);
}
GCLogicalEntity GCLogicRelay::GetParent() const {
    GCLogicalEntity value(m_ptr);
    return value;
}
void GCLogicRelay::SetParent(GCLogicalEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCLogicRelay(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCLogicRelay>("CLogicRelay")
        .addConstructor<void (*)(std::string)>()
        .addProperty("OnTrigger", &GCLogicRelay::GetOnTrigger, &GCLogicRelay::SetOnTrigger)
        .addProperty("OnSpawn", &GCLogicRelay::GetOnSpawn, &GCLogicRelay::SetOnSpawn)
        .addProperty("Disabled", &GCLogicRelay::GetDisabled, &GCLogicRelay::SetDisabled)
        .addProperty("WaitForRefire", &GCLogicRelay::GetWaitForRefire, &GCLogicRelay::SetWaitForRefire)
        .addProperty("TriggerOnce", &GCLogicRelay::GetTriggerOnce, &GCLogicRelay::SetTriggerOnce)
        .addProperty("FastRetrigger", &GCLogicRelay::GetFastRetrigger, &GCLogicRelay::SetFastRetrigger)
        .addProperty("PassthoughCaller", &GCLogicRelay::GetPassthoughCaller, &GCLogicRelay::SetPassthoughCaller)
        .addProperty("Parent", &GCLogicRelay::GetParent, &GCLogicRelay::SetParent)
        .addFunction("ToPtr", &GCLogicRelay::ToPtr)
        .addFunction("IsValid", &GCLogicRelay::IsValid)
        .endClass();
}
GCPlayer_ItemServices::GCPlayer_ItemServices(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCPlayer_ItemServices::GCPlayer_ItemServices(void *ptr) {
    m_ptr = ptr;
}
std::string GCPlayer_ItemServices::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCPlayer_ItemServices::IsValid() {
    return (m_ptr != nullptr);
}
GCPlayerPawnComponent GCPlayer_ItemServices::GetParent() const {
    GCPlayerPawnComponent value(m_ptr);
    return value;
}
void GCPlayer_ItemServices::SetParent(GCPlayerPawnComponent value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCPlayer_ItemServices(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCPlayer_ItemServices>("CPlayer_ItemServices")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCPlayer_ItemServices::GetParent, &GCPlayer_ItemServices::SetParent)
        .addFunction("ToPtr", &GCPlayer_ItemServices::ToPtr)
        .addFunction("IsValid", &GCPlayer_ItemServices::IsValid)
        .endClass();
}
GCKeepUpright::GCKeepUpright(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCKeepUpright::GCKeepUpright(void *ptr) {
    m_ptr = ptr;
}
Vector GCKeepUpright::GetWorldGoalAxis() const {
    return GetSchemaValue<Vector>(m_ptr, "CKeepUpright", "m_worldGoalAxis");
}
void GCKeepUpright::SetWorldGoalAxis(Vector value) {
    SetSchemaValue(m_ptr, "CKeepUpright", "m_worldGoalAxis", false, value);
}
Vector GCKeepUpright::GetLocalTestAxis() const {
    return GetSchemaValue<Vector>(m_ptr, "CKeepUpright", "m_localTestAxis");
}
void GCKeepUpright::SetLocalTestAxis(Vector value) {
    SetSchemaValue(m_ptr, "CKeepUpright", "m_localTestAxis", false, value);
}
std::string GCKeepUpright::GetNameAttach() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CKeepUpright", "m_nameAttach").String();
}
void GCKeepUpright::SetNameAttach(std::string value) {
    SetSchemaValue(m_ptr, "CKeepUpright", "m_nameAttach", false, CUtlSymbolLarge(value.c_str()));
}
GCBaseEntity GCKeepUpright::GetAttachedObject() const {
    GCBaseEntity value(*GetSchemaValuePtr<void*>(m_ptr, "CKeepUpright", "m_attachedObject"));
    return value;
}
void GCKeepUpright::SetAttachedObject(GCBaseEntity* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'AttachedObject' is not possible.\n");
}
float GCKeepUpright::GetAngularLimit() const {
    return GetSchemaValue<float>(m_ptr, "CKeepUpright", "m_angularLimit");
}
void GCKeepUpright::SetAngularLimit(float value) {
    SetSchemaValue(m_ptr, "CKeepUpright", "m_angularLimit", false, value);
}
bool GCKeepUpright::GetActive() const {
    return GetSchemaValue<bool>(m_ptr, "CKeepUpright", "m_bActive");
}
void GCKeepUpright::SetActive(bool value) {
    SetSchemaValue(m_ptr, "CKeepUpright", "m_bActive", false, value);
}
bool GCKeepUpright::GetDampAllRotation() const {
    return GetSchemaValue<bool>(m_ptr, "CKeepUpright", "m_bDampAllRotation");
}
void GCKeepUpright::SetDampAllRotation(bool value) {
    SetSchemaValue(m_ptr, "CKeepUpright", "m_bDampAllRotation", false, value);
}
std::string GCKeepUpright::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCKeepUpright::IsValid() {
    return (m_ptr != nullptr);
}
GCPointEntity GCKeepUpright::GetParent() const {
    GCPointEntity value(m_ptr);
    return value;
}
void GCKeepUpright::SetParent(GCPointEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCKeepUpright(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCKeepUpright>("CKeepUpright")
        .addConstructor<void (*)(std::string)>()
        .addProperty("WorldGoalAxis", &GCKeepUpright::GetWorldGoalAxis, &GCKeepUpright::SetWorldGoalAxis)
        .addProperty("LocalTestAxis", &GCKeepUpright::GetLocalTestAxis, &GCKeepUpright::SetLocalTestAxis)
        .addProperty("NameAttach", &GCKeepUpright::GetNameAttach, &GCKeepUpright::SetNameAttach)
        .addProperty("AttachedObject", &GCKeepUpright::GetAttachedObject, &GCKeepUpright::SetAttachedObject)
        .addProperty("AngularLimit", &GCKeepUpright::GetAngularLimit, &GCKeepUpright::SetAngularLimit)
        .addProperty("Active", &GCKeepUpright::GetActive, &GCKeepUpright::SetActive)
        .addProperty("DampAllRotation", &GCKeepUpright::GetDampAllRotation, &GCKeepUpright::SetDampAllRotation)
        .addProperty("Parent", &GCKeepUpright::GetParent, &GCKeepUpright::SetParent)
        .addFunction("ToPtr", &GCKeepUpright::ToPtr)
        .addFunction("IsValid", &GCKeepUpright::IsValid)
        .endClass();
}
GCRevertSaved::GCRevertSaved(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCRevertSaved::GCRevertSaved(void *ptr) {
    m_ptr = ptr;
}
float GCRevertSaved::GetLoadTime() const {
    return GetSchemaValue<float>(m_ptr, "CRevertSaved", "m_loadTime");
}
void GCRevertSaved::SetLoadTime(float value) {
    SetSchemaValue(m_ptr, "CRevertSaved", "m_loadTime", false, value);
}
float GCRevertSaved::GetDuration() const {
    return GetSchemaValue<float>(m_ptr, "CRevertSaved", "m_Duration");
}
void GCRevertSaved::SetDuration(float value) {
    SetSchemaValue(m_ptr, "CRevertSaved", "m_Duration", false, value);
}
float GCRevertSaved::GetHoldTime() const {
    return GetSchemaValue<float>(m_ptr, "CRevertSaved", "m_HoldTime");
}
void GCRevertSaved::SetHoldTime(float value) {
    SetSchemaValue(m_ptr, "CRevertSaved", "m_HoldTime", false, value);
}
std::string GCRevertSaved::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCRevertSaved::IsValid() {
    return (m_ptr != nullptr);
}
GCModelPointEntity GCRevertSaved::GetParent() const {
    GCModelPointEntity value(m_ptr);
    return value;
}
void GCRevertSaved::SetParent(GCModelPointEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCRevertSaved(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCRevertSaved>("CRevertSaved")
        .addConstructor<void (*)(std::string)>()
        .addProperty("LoadTime", &GCRevertSaved::GetLoadTime, &GCRevertSaved::SetLoadTime)
        .addProperty("Duration", &GCRevertSaved::GetDuration, &GCRevertSaved::SetDuration)
        .addProperty("HoldTime", &GCRevertSaved::GetHoldTime, &GCRevertSaved::SetHoldTime)
        .addProperty("Parent", &GCRevertSaved::GetParent, &GCRevertSaved::SetParent)
        .addFunction("ToPtr", &GCRevertSaved::ToPtr)
        .addFunction("IsValid", &GCRevertSaved::IsValid)
        .endClass();
}
GCFuncWater::GCFuncWater(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCFuncWater::GCFuncWater(void *ptr) {
    m_ptr = ptr;
}
GCBuoyancyHelper GCFuncWater::GetBuoyancyHelper() const {
    GCBuoyancyHelper value(GetSchemaPtr(m_ptr, "CFuncWater", "m_BuoyancyHelper"));
    return value;
}
void GCFuncWater::SetBuoyancyHelper(GCBuoyancyHelper value) {
    SetSchemaValue(m_ptr, "CFuncWater", "m_BuoyancyHelper", false, value);
}
std::string GCFuncWater::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCFuncWater::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseModelEntity GCFuncWater::GetParent() const {
    GCBaseModelEntity value(m_ptr);
    return value;
}
void GCFuncWater::SetParent(GCBaseModelEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCFuncWater(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCFuncWater>("CFuncWater")
        .addConstructor<void (*)(std::string)>()
        .addProperty("BuoyancyHelper", &GCFuncWater::GetBuoyancyHelper, &GCFuncWater::SetBuoyancyHelper)
        .addProperty("Parent", &GCFuncWater::GetParent, &GCFuncWater::SetParent)
        .addFunction("ToPtr", &GCFuncWater::ToPtr)
        .addFunction("IsValid", &GCFuncWater::IsValid)
        .endClass();
}
GCFuncTimescale::GCFuncTimescale(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCFuncTimescale::GCFuncTimescale(void *ptr) {
    m_ptr = ptr;
}
float GCFuncTimescale::GetDesiredTimescale() const {
    return GetSchemaValue<float>(m_ptr, "CFuncTimescale", "m_flDesiredTimescale");
}
void GCFuncTimescale::SetDesiredTimescale(float value) {
    SetSchemaValue(m_ptr, "CFuncTimescale", "m_flDesiredTimescale", false, value);
}
float GCFuncTimescale::GetAcceleration() const {
    return GetSchemaValue<float>(m_ptr, "CFuncTimescale", "m_flAcceleration");
}
void GCFuncTimescale::SetAcceleration(float value) {
    SetSchemaValue(m_ptr, "CFuncTimescale", "m_flAcceleration", false, value);
}
float GCFuncTimescale::GetMinBlendRate() const {
    return GetSchemaValue<float>(m_ptr, "CFuncTimescale", "m_flMinBlendRate");
}
void GCFuncTimescale::SetMinBlendRate(float value) {
    SetSchemaValue(m_ptr, "CFuncTimescale", "m_flMinBlendRate", false, value);
}
float GCFuncTimescale::GetBlendDeltaMultiplier() const {
    return GetSchemaValue<float>(m_ptr, "CFuncTimescale", "m_flBlendDeltaMultiplier");
}
void GCFuncTimescale::SetBlendDeltaMultiplier(float value) {
    SetSchemaValue(m_ptr, "CFuncTimescale", "m_flBlendDeltaMultiplier", false, value);
}
bool GCFuncTimescale::GetIsStarted() const {
    return GetSchemaValue<bool>(m_ptr, "CFuncTimescale", "m_isStarted");
}
void GCFuncTimescale::SetIsStarted(bool value) {
    SetSchemaValue(m_ptr, "CFuncTimescale", "m_isStarted", false, value);
}
std::string GCFuncTimescale::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCFuncTimescale::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseEntity GCFuncTimescale::GetParent() const {
    GCBaseEntity value(m_ptr);
    return value;
}
void GCFuncTimescale::SetParent(GCBaseEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCFuncTimescale(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCFuncTimescale>("CFuncTimescale")
        .addConstructor<void (*)(std::string)>()
        .addProperty("DesiredTimescale", &GCFuncTimescale::GetDesiredTimescale, &GCFuncTimescale::SetDesiredTimescale)
        .addProperty("Acceleration", &GCFuncTimescale::GetAcceleration, &GCFuncTimescale::SetAcceleration)
        .addProperty("MinBlendRate", &GCFuncTimescale::GetMinBlendRate, &GCFuncTimescale::SetMinBlendRate)
        .addProperty("BlendDeltaMultiplier", &GCFuncTimescale::GetBlendDeltaMultiplier, &GCFuncTimescale::SetBlendDeltaMultiplier)
        .addProperty("IsStarted", &GCFuncTimescale::GetIsStarted, &GCFuncTimescale::SetIsStarted)
        .addProperty("Parent", &GCFuncTimescale::GetParent, &GCFuncTimescale::SetParent)
        .addFunction("ToPtr", &GCFuncTimescale::ToPtr)
        .addFunction("IsValid", &GCFuncTimescale::IsValid)
        .endClass();
}
GCBtActionMoveTo::GCBtActionMoveTo(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCBtActionMoveTo::GCBtActionMoveTo(void *ptr) {
    m_ptr = ptr;
}
std::string GCBtActionMoveTo::GetDestinationInputKey() const {
    return GetSchemaValue<CUtlString>(m_ptr, "CBtActionMoveTo", "m_szDestinationInputKey").Get();
}
void GCBtActionMoveTo::SetDestinationInputKey(std::string value) {
    SetSchemaValue(m_ptr, "CBtActionMoveTo", "m_szDestinationInputKey", false, CUtlString(value.c_str()));
}
std::string GCBtActionMoveTo::GetHidingSpotInputKey() const {
    return GetSchemaValue<CUtlString>(m_ptr, "CBtActionMoveTo", "m_szHidingSpotInputKey").Get();
}
void GCBtActionMoveTo::SetHidingSpotInputKey(std::string value) {
    SetSchemaValue(m_ptr, "CBtActionMoveTo", "m_szHidingSpotInputKey", false, CUtlString(value.c_str()));
}
std::string GCBtActionMoveTo::GetThreatInputKey() const {
    return GetSchemaValue<CUtlString>(m_ptr, "CBtActionMoveTo", "m_szThreatInputKey").Get();
}
void GCBtActionMoveTo::SetThreatInputKey(std::string value) {
    SetSchemaValue(m_ptr, "CBtActionMoveTo", "m_szThreatInputKey", false, CUtlString(value.c_str()));
}
Vector GCBtActionMoveTo::GetDestination() const {
    return GetSchemaValue<Vector>(m_ptr, "CBtActionMoveTo", "m_vecDestination");
}
void GCBtActionMoveTo::SetDestination(Vector value) {
    SetSchemaValue(m_ptr, "CBtActionMoveTo", "m_vecDestination", false, value);
}
bool GCBtActionMoveTo::GetAutoLookAdjust() const {
    return GetSchemaValue<bool>(m_ptr, "CBtActionMoveTo", "m_bAutoLookAdjust");
}
void GCBtActionMoveTo::SetAutoLookAdjust(bool value) {
    SetSchemaValue(m_ptr, "CBtActionMoveTo", "m_bAutoLookAdjust", false, value);
}
bool GCBtActionMoveTo::GetComputePath() const {
    return GetSchemaValue<bool>(m_ptr, "CBtActionMoveTo", "m_bComputePath");
}
void GCBtActionMoveTo::SetComputePath(bool value) {
    SetSchemaValue(m_ptr, "CBtActionMoveTo", "m_bComputePath", false, value);
}
float GCBtActionMoveTo::GetDamagingAreasPenaltyCost() const {
    return GetSchemaValue<float>(m_ptr, "CBtActionMoveTo", "m_flDamagingAreasPenaltyCost");
}
void GCBtActionMoveTo::SetDamagingAreasPenaltyCost(float value) {
    SetSchemaValue(m_ptr, "CBtActionMoveTo", "m_flDamagingAreasPenaltyCost", false, value);
}
GCountdownTimer GCBtActionMoveTo::GetCheckApproximateCornersTimer() const {
    GCountdownTimer value(GetSchemaPtr(m_ptr, "CBtActionMoveTo", "m_CheckApproximateCornersTimer"));
    return value;
}
void GCBtActionMoveTo::SetCheckApproximateCornersTimer(GCountdownTimer value) {
    SetSchemaValue(m_ptr, "CBtActionMoveTo", "m_CheckApproximateCornersTimer", false, value);
}
GCountdownTimer GCBtActionMoveTo::GetCheckHighPriorityItem() const {
    GCountdownTimer value(GetSchemaPtr(m_ptr, "CBtActionMoveTo", "m_CheckHighPriorityItem"));
    return value;
}
void GCBtActionMoveTo::SetCheckHighPriorityItem(GCountdownTimer value) {
    SetSchemaValue(m_ptr, "CBtActionMoveTo", "m_CheckHighPriorityItem", false, value);
}
GCountdownTimer GCBtActionMoveTo::GetRepathTimer() const {
    GCountdownTimer value(GetSchemaPtr(m_ptr, "CBtActionMoveTo", "m_RepathTimer"));
    return value;
}
void GCBtActionMoveTo::SetRepathTimer(GCountdownTimer value) {
    SetSchemaValue(m_ptr, "CBtActionMoveTo", "m_RepathTimer", false, value);
}
float GCBtActionMoveTo::GetArrivalEpsilon() const {
    return GetSchemaValue<float>(m_ptr, "CBtActionMoveTo", "m_flArrivalEpsilon");
}
void GCBtActionMoveTo::SetArrivalEpsilon(float value) {
    SetSchemaValue(m_ptr, "CBtActionMoveTo", "m_flArrivalEpsilon", false, value);
}
float GCBtActionMoveTo::GetAdditionalArrivalEpsilon2D() const {
    return GetSchemaValue<float>(m_ptr, "CBtActionMoveTo", "m_flAdditionalArrivalEpsilon2D");
}
void GCBtActionMoveTo::SetAdditionalArrivalEpsilon2D(float value) {
    SetSchemaValue(m_ptr, "CBtActionMoveTo", "m_flAdditionalArrivalEpsilon2D", false, value);
}
float GCBtActionMoveTo::GetHidingSpotCheckDistanceThreshold() const {
    return GetSchemaValue<float>(m_ptr, "CBtActionMoveTo", "m_flHidingSpotCheckDistanceThreshold");
}
void GCBtActionMoveTo::SetHidingSpotCheckDistanceThreshold(float value) {
    SetSchemaValue(m_ptr, "CBtActionMoveTo", "m_flHidingSpotCheckDistanceThreshold", false, value);
}
float GCBtActionMoveTo::GetNearestAreaDistanceThreshold() const {
    return GetSchemaValue<float>(m_ptr, "CBtActionMoveTo", "m_flNearestAreaDistanceThreshold");
}
void GCBtActionMoveTo::SetNearestAreaDistanceThreshold(float value) {
    SetSchemaValue(m_ptr, "CBtActionMoveTo", "m_flNearestAreaDistanceThreshold", false, value);
}
std::string GCBtActionMoveTo::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCBtActionMoveTo::IsValid() {
    return (m_ptr != nullptr);
}
GCBtNode GCBtActionMoveTo::GetParent() const {
    GCBtNode value(m_ptr);
    return value;
}
void GCBtActionMoveTo::SetParent(GCBtNode value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCBtActionMoveTo(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCBtActionMoveTo>("CBtActionMoveTo")
        .addConstructor<void (*)(std::string)>()
        .addProperty("DestinationInputKey", &GCBtActionMoveTo::GetDestinationInputKey, &GCBtActionMoveTo::SetDestinationInputKey)
        .addProperty("HidingSpotInputKey", &GCBtActionMoveTo::GetHidingSpotInputKey, &GCBtActionMoveTo::SetHidingSpotInputKey)
        .addProperty("ThreatInputKey", &GCBtActionMoveTo::GetThreatInputKey, &GCBtActionMoveTo::SetThreatInputKey)
        .addProperty("Destination", &GCBtActionMoveTo::GetDestination, &GCBtActionMoveTo::SetDestination)
        .addProperty("AutoLookAdjust", &GCBtActionMoveTo::GetAutoLookAdjust, &GCBtActionMoveTo::SetAutoLookAdjust)
        .addProperty("ComputePath", &GCBtActionMoveTo::GetComputePath, &GCBtActionMoveTo::SetComputePath)
        .addProperty("DamagingAreasPenaltyCost", &GCBtActionMoveTo::GetDamagingAreasPenaltyCost, &GCBtActionMoveTo::SetDamagingAreasPenaltyCost)
        .addProperty("CheckApproximateCornersTimer", &GCBtActionMoveTo::GetCheckApproximateCornersTimer, &GCBtActionMoveTo::SetCheckApproximateCornersTimer)
        .addProperty("CheckHighPriorityItem", &GCBtActionMoveTo::GetCheckHighPriorityItem, &GCBtActionMoveTo::SetCheckHighPriorityItem)
        .addProperty("RepathTimer", &GCBtActionMoveTo::GetRepathTimer, &GCBtActionMoveTo::SetRepathTimer)
        .addProperty("ArrivalEpsilon", &GCBtActionMoveTo::GetArrivalEpsilon, &GCBtActionMoveTo::SetArrivalEpsilon)
        .addProperty("AdditionalArrivalEpsilon2D", &GCBtActionMoveTo::GetAdditionalArrivalEpsilon2D, &GCBtActionMoveTo::SetAdditionalArrivalEpsilon2D)
        .addProperty("HidingSpotCheckDistanceThreshold", &GCBtActionMoveTo::GetHidingSpotCheckDistanceThreshold, &GCBtActionMoveTo::SetHidingSpotCheckDistanceThreshold)
        .addProperty("NearestAreaDistanceThreshold", &GCBtActionMoveTo::GetNearestAreaDistanceThreshold, &GCBtActionMoveTo::SetNearestAreaDistanceThreshold)
        .addProperty("Parent", &GCBtActionMoveTo::GetParent, &GCBtActionMoveTo::SetParent)
        .addFunction("ToPtr", &GCBtActionMoveTo::ToPtr)
        .addFunction("IsValid", &GCBtActionMoveTo::IsValid)
        .endClass();
}
GCTonemapController2::GCTonemapController2(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCTonemapController2::GCTonemapController2(void *ptr) {
    m_ptr = ptr;
}
float GCTonemapController2::GetAutoExposureMin() const {
    return GetSchemaValue<float>(m_ptr, "CTonemapController2", "m_flAutoExposureMin");
}
void GCTonemapController2::SetAutoExposureMin(float value) {
    SetSchemaValue(m_ptr, "CTonemapController2", "m_flAutoExposureMin", false, value);
}
float GCTonemapController2::GetAutoExposureMax() const {
    return GetSchemaValue<float>(m_ptr, "CTonemapController2", "m_flAutoExposureMax");
}
void GCTonemapController2::SetAutoExposureMax(float value) {
    SetSchemaValue(m_ptr, "CTonemapController2", "m_flAutoExposureMax", false, value);
}
float GCTonemapController2::GetTonemapPercentTarget() const {
    return GetSchemaValue<float>(m_ptr, "CTonemapController2", "m_flTonemapPercentTarget");
}
void GCTonemapController2::SetTonemapPercentTarget(float value) {
    SetSchemaValue(m_ptr, "CTonemapController2", "m_flTonemapPercentTarget", false, value);
}
float GCTonemapController2::GetTonemapPercentBrightPixels() const {
    return GetSchemaValue<float>(m_ptr, "CTonemapController2", "m_flTonemapPercentBrightPixels");
}
void GCTonemapController2::SetTonemapPercentBrightPixels(float value) {
    SetSchemaValue(m_ptr, "CTonemapController2", "m_flTonemapPercentBrightPixels", false, value);
}
float GCTonemapController2::GetTonemapMinAvgLum() const {
    return GetSchemaValue<float>(m_ptr, "CTonemapController2", "m_flTonemapMinAvgLum");
}
void GCTonemapController2::SetTonemapMinAvgLum(float value) {
    SetSchemaValue(m_ptr, "CTonemapController2", "m_flTonemapMinAvgLum", false, value);
}
float GCTonemapController2::GetExposureAdaptationSpeedUp() const {
    return GetSchemaValue<float>(m_ptr, "CTonemapController2", "m_flExposureAdaptationSpeedUp");
}
void GCTonemapController2::SetExposureAdaptationSpeedUp(float value) {
    SetSchemaValue(m_ptr, "CTonemapController2", "m_flExposureAdaptationSpeedUp", false, value);
}
float GCTonemapController2::GetExposureAdaptationSpeedDown() const {
    return GetSchemaValue<float>(m_ptr, "CTonemapController2", "m_flExposureAdaptationSpeedDown");
}
void GCTonemapController2::SetExposureAdaptationSpeedDown(float value) {
    SetSchemaValue(m_ptr, "CTonemapController2", "m_flExposureAdaptationSpeedDown", false, value);
}
float GCTonemapController2::GetTonemapEVSmoothingRange() const {
    return GetSchemaValue<float>(m_ptr, "CTonemapController2", "m_flTonemapEVSmoothingRange");
}
void GCTonemapController2::SetTonemapEVSmoothingRange(float value) {
    SetSchemaValue(m_ptr, "CTonemapController2", "m_flTonemapEVSmoothingRange", false, value);
}
std::string GCTonemapController2::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCTonemapController2::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseEntity GCTonemapController2::GetParent() const {
    GCBaseEntity value(m_ptr);
    return value;
}
void GCTonemapController2::SetParent(GCBaseEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCTonemapController2(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCTonemapController2>("CTonemapController2")
        .addConstructor<void (*)(std::string)>()
        .addProperty("AutoExposureMin", &GCTonemapController2::GetAutoExposureMin, &GCTonemapController2::SetAutoExposureMin)
        .addProperty("AutoExposureMax", &GCTonemapController2::GetAutoExposureMax, &GCTonemapController2::SetAutoExposureMax)
        .addProperty("TonemapPercentTarget", &GCTonemapController2::GetTonemapPercentTarget, &GCTonemapController2::SetTonemapPercentTarget)
        .addProperty("TonemapPercentBrightPixels", &GCTonemapController2::GetTonemapPercentBrightPixels, &GCTonemapController2::SetTonemapPercentBrightPixels)
        .addProperty("TonemapMinAvgLum", &GCTonemapController2::GetTonemapMinAvgLum, &GCTonemapController2::SetTonemapMinAvgLum)
        .addProperty("ExposureAdaptationSpeedUp", &GCTonemapController2::GetExposureAdaptationSpeedUp, &GCTonemapController2::SetExposureAdaptationSpeedUp)
        .addProperty("ExposureAdaptationSpeedDown", &GCTonemapController2::GetExposureAdaptationSpeedDown, &GCTonemapController2::SetExposureAdaptationSpeedDown)
        .addProperty("TonemapEVSmoothingRange", &GCTonemapController2::GetTonemapEVSmoothingRange, &GCTonemapController2::SetTonemapEVSmoothingRange)
        .addProperty("Parent", &GCTonemapController2::GetParent, &GCTonemapController2::SetParent)
        .addFunction("ToPtr", &GCTonemapController2::ToPtr)
        .addFunction("IsValid", &GCTonemapController2::IsValid)
        .endClass();
}
GCRopeKeyframeAlias_move_rope::GCRopeKeyframeAlias_move_rope(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCRopeKeyframeAlias_move_rope::GCRopeKeyframeAlias_move_rope(void *ptr) {
    m_ptr = ptr;
}
std::string GCRopeKeyframeAlias_move_rope::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCRopeKeyframeAlias_move_rope::IsValid() {
    return (m_ptr != nullptr);
}
GCRopeKeyframe GCRopeKeyframeAlias_move_rope::GetParent() const {
    GCRopeKeyframe value(m_ptr);
    return value;
}
void GCRopeKeyframeAlias_move_rope::SetParent(GCRopeKeyframe value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCRopeKeyframeAlias_move_rope(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCRopeKeyframeAlias_move_rope>("CRopeKeyframeAlias_move_rope")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCRopeKeyframeAlias_move_rope::GetParent, &GCRopeKeyframeAlias_move_rope::SetParent)
        .addFunction("ToPtr", &GCRopeKeyframeAlias_move_rope::ToPtr)
        .addFunction("IsValid", &GCRopeKeyframeAlias_move_rope::IsValid)
        .endClass();
}
GCEnvInstructorVRHint::GCEnvInstructorVRHint(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCEnvInstructorVRHint::GCEnvInstructorVRHint(void *ptr) {
    m_ptr = ptr;
}
std::string GCEnvInstructorVRHint::GetName() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CEnvInstructorVRHint", "m_iszName").String();
}
void GCEnvInstructorVRHint::SetName(std::string value) {
    SetSchemaValue(m_ptr, "CEnvInstructorVRHint", "m_iszName", false, CUtlSymbolLarge(value.c_str()));
}
std::string GCEnvInstructorVRHint::GetHintTargetEntity() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CEnvInstructorVRHint", "m_iszHintTargetEntity").String();
}
void GCEnvInstructorVRHint::SetHintTargetEntity(std::string value) {
    SetSchemaValue(m_ptr, "CEnvInstructorVRHint", "m_iszHintTargetEntity", false, CUtlSymbolLarge(value.c_str()));
}
int32_t GCEnvInstructorVRHint::GetTimeout() const {
    return GetSchemaValue<int32_t>(m_ptr, "CEnvInstructorVRHint", "m_iTimeout");
}
void GCEnvInstructorVRHint::SetTimeout(int32_t value) {
    SetSchemaValue(m_ptr, "CEnvInstructorVRHint", "m_iTimeout", false, value);
}
std::string GCEnvInstructorVRHint::GetCaption() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CEnvInstructorVRHint", "m_iszCaption").String();
}
void GCEnvInstructorVRHint::SetCaption(std::string value) {
    SetSchemaValue(m_ptr, "CEnvInstructorVRHint", "m_iszCaption", false, CUtlSymbolLarge(value.c_str()));
}
std::string GCEnvInstructorVRHint::GetStartSound() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CEnvInstructorVRHint", "m_iszStartSound").String();
}
void GCEnvInstructorVRHint::SetStartSound(std::string value) {
    SetSchemaValue(m_ptr, "CEnvInstructorVRHint", "m_iszStartSound", false, CUtlSymbolLarge(value.c_str()));
}
int32_t GCEnvInstructorVRHint::GetLayoutFileType() const {
    return GetSchemaValue<int32_t>(m_ptr, "CEnvInstructorVRHint", "m_iLayoutFileType");
}
void GCEnvInstructorVRHint::SetLayoutFileType(int32_t value) {
    SetSchemaValue(m_ptr, "CEnvInstructorVRHint", "m_iLayoutFileType", false, value);
}
std::string GCEnvInstructorVRHint::GetCustomLayoutFile() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CEnvInstructorVRHint", "m_iszCustomLayoutFile").String();
}
void GCEnvInstructorVRHint::SetCustomLayoutFile(std::string value) {
    SetSchemaValue(m_ptr, "CEnvInstructorVRHint", "m_iszCustomLayoutFile", false, CUtlSymbolLarge(value.c_str()));
}
int32_t GCEnvInstructorVRHint::GetAttachType() const {
    return GetSchemaValue<int32_t>(m_ptr, "CEnvInstructorVRHint", "m_iAttachType");
}
void GCEnvInstructorVRHint::SetAttachType(int32_t value) {
    SetSchemaValue(m_ptr, "CEnvInstructorVRHint", "m_iAttachType", false, value);
}
float GCEnvInstructorVRHint::GetHeightOffset() const {
    return GetSchemaValue<float>(m_ptr, "CEnvInstructorVRHint", "m_flHeightOffset");
}
void GCEnvInstructorVRHint::SetHeightOffset(float value) {
    SetSchemaValue(m_ptr, "CEnvInstructorVRHint", "m_flHeightOffset", false, value);
}
std::string GCEnvInstructorVRHint::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCEnvInstructorVRHint::IsValid() {
    return (m_ptr != nullptr);
}
GCPointEntity GCEnvInstructorVRHint::GetParent() const {
    GCPointEntity value(m_ptr);
    return value;
}
void GCEnvInstructorVRHint::SetParent(GCPointEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCEnvInstructorVRHint(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCEnvInstructorVRHint>("CEnvInstructorVRHint")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Name", &GCEnvInstructorVRHint::GetName, &GCEnvInstructorVRHint::SetName)
        .addProperty("HintTargetEntity", &GCEnvInstructorVRHint::GetHintTargetEntity, &GCEnvInstructorVRHint::SetHintTargetEntity)
        .addProperty("Timeout", &GCEnvInstructorVRHint::GetTimeout, &GCEnvInstructorVRHint::SetTimeout)
        .addProperty("Caption", &GCEnvInstructorVRHint::GetCaption, &GCEnvInstructorVRHint::SetCaption)
        .addProperty("StartSound", &GCEnvInstructorVRHint::GetStartSound, &GCEnvInstructorVRHint::SetStartSound)
        .addProperty("LayoutFileType", &GCEnvInstructorVRHint::GetLayoutFileType, &GCEnvInstructorVRHint::SetLayoutFileType)
        .addProperty("CustomLayoutFile", &GCEnvInstructorVRHint::GetCustomLayoutFile, &GCEnvInstructorVRHint::SetCustomLayoutFile)
        .addProperty("AttachType", &GCEnvInstructorVRHint::GetAttachType, &GCEnvInstructorVRHint::SetAttachType)
        .addProperty("HeightOffset", &GCEnvInstructorVRHint::GetHeightOffset, &GCEnvInstructorVRHint::SetHeightOffset)
        .addProperty("Parent", &GCEnvInstructorVRHint::GetParent, &GCEnvInstructorVRHint::SetParent)
        .addFunction("ToPtr", &GCEnvInstructorVRHint::ToPtr)
        .addFunction("IsValid", &GCEnvInstructorVRHint::IsValid)
        .endClass();
}
GCWeaponXM1014::GCWeaponXM1014(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCWeaponXM1014::GCWeaponXM1014(void *ptr) {
    m_ptr = ptr;
}
std::string GCWeaponXM1014::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCWeaponXM1014::IsValid() {
    return (m_ptr != nullptr);
}
GCCSWeaponBase GCWeaponXM1014::GetParent() const {
    GCCSWeaponBase value(m_ptr);
    return value;
}
void GCWeaponXM1014::SetParent(GCCSWeaponBase value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCWeaponXM1014(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCWeaponXM1014>("CWeaponXM1014")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCWeaponXM1014::GetParent, &GCWeaponXM1014::SetParent)
        .addFunction("ToPtr", &GCWeaponXM1014::ToPtr)
        .addFunction("IsValid", &GCWeaponXM1014::IsValid)
        .endClass();
}
GCPlatTrigger::GCPlatTrigger(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCPlatTrigger::GCPlatTrigger(void *ptr) {
    m_ptr = ptr;
}
GCFuncPlat GCPlatTrigger::GetPlatform() const {
    GCFuncPlat value(*GetSchemaValuePtr<void*>(m_ptr, "CPlatTrigger", "m_pPlatform"));
    return value;
}
void GCPlatTrigger::SetPlatform(GCFuncPlat* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Platform' is not possible.\n");
}
std::string GCPlatTrigger::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCPlatTrigger::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseModelEntity GCPlatTrigger::GetParent() const {
    GCBaseModelEntity value(m_ptr);
    return value;
}
void GCPlatTrigger::SetParent(GCBaseModelEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCPlatTrigger(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCPlatTrigger>("CPlatTrigger")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Platform", &GCPlatTrigger::GetPlatform, &GCPlatTrigger::SetPlatform)
        .addProperty("Parent", &GCPlatTrigger::GetParent, &GCPlatTrigger::SetParent)
        .addFunction("ToPtr", &GCPlatTrigger::ToPtr)
        .addFunction("IsValid", &GCPlatTrigger::IsValid)
        .endClass();
}
GCEnvWindShared::GCEnvWindShared(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCEnvWindShared::GCEnvWindShared(void *ptr) {
    m_ptr = ptr;
}
float GCEnvWindShared::GetStartTime() const {
    return GetSchemaValue<float>(m_ptr, "CEnvWindShared", "m_flStartTime");
}
void GCEnvWindShared::SetStartTime(float value) {
    SetSchemaValue(m_ptr, "CEnvWindShared", "m_flStartTime", false, value);
}
uint32_t GCEnvWindShared::GetWindSeed() const {
    return GetSchemaValue<uint32_t>(m_ptr, "CEnvWindShared", "m_iWindSeed");
}
void GCEnvWindShared::SetWindSeed(uint32_t value) {
    SetSchemaValue(m_ptr, "CEnvWindShared", "m_iWindSeed", false, value);
}
uint16_t GCEnvWindShared::GetMinWind() const {
    return GetSchemaValue<uint16_t>(m_ptr, "CEnvWindShared", "m_iMinWind");
}
void GCEnvWindShared::SetMinWind(uint16_t value) {
    SetSchemaValue(m_ptr, "CEnvWindShared", "m_iMinWind", false, value);
}
uint16_t GCEnvWindShared::GetMaxWind() const {
    return GetSchemaValue<uint16_t>(m_ptr, "CEnvWindShared", "m_iMaxWind");
}
void GCEnvWindShared::SetMaxWind(uint16_t value) {
    SetSchemaValue(m_ptr, "CEnvWindShared", "m_iMaxWind", false, value);
}
int32_t GCEnvWindShared::GetWindRadius() const {
    return GetSchemaValue<int32_t>(m_ptr, "CEnvWindShared", "m_windRadius");
}
void GCEnvWindShared::SetWindRadius(int32_t value) {
    SetSchemaValue(m_ptr, "CEnvWindShared", "m_windRadius", false, value);
}
uint16_t GCEnvWindShared::GetMinGust() const {
    return GetSchemaValue<uint16_t>(m_ptr, "CEnvWindShared", "m_iMinGust");
}
void GCEnvWindShared::SetMinGust(uint16_t value) {
    SetSchemaValue(m_ptr, "CEnvWindShared", "m_iMinGust", false, value);
}
uint16_t GCEnvWindShared::GetMaxGust() const {
    return GetSchemaValue<uint16_t>(m_ptr, "CEnvWindShared", "m_iMaxGust");
}
void GCEnvWindShared::SetMaxGust(uint16_t value) {
    SetSchemaValue(m_ptr, "CEnvWindShared", "m_iMaxGust", false, value);
}
float GCEnvWindShared::GetMinGustDelay() const {
    return GetSchemaValue<float>(m_ptr, "CEnvWindShared", "m_flMinGustDelay");
}
void GCEnvWindShared::SetMinGustDelay(float value) {
    SetSchemaValue(m_ptr, "CEnvWindShared", "m_flMinGustDelay", false, value);
}
float GCEnvWindShared::GetMaxGustDelay() const {
    return GetSchemaValue<float>(m_ptr, "CEnvWindShared", "m_flMaxGustDelay");
}
void GCEnvWindShared::SetMaxGustDelay(float value) {
    SetSchemaValue(m_ptr, "CEnvWindShared", "m_flMaxGustDelay", false, value);
}
float GCEnvWindShared::GetGustDuration() const {
    return GetSchemaValue<float>(m_ptr, "CEnvWindShared", "m_flGustDuration");
}
void GCEnvWindShared::SetGustDuration(float value) {
    SetSchemaValue(m_ptr, "CEnvWindShared", "m_flGustDuration", false, value);
}
uint16_t GCEnvWindShared::GetGustDirChange() const {
    return GetSchemaValue<uint16_t>(m_ptr, "CEnvWindShared", "m_iGustDirChange");
}
void GCEnvWindShared::SetGustDirChange(uint16_t value) {
    SetSchemaValue(m_ptr, "CEnvWindShared", "m_iGustDirChange", false, value);
}
Vector GCEnvWindShared::GetLocation() const {
    return GetSchemaValue<Vector>(m_ptr, "CEnvWindShared", "m_location");
}
void GCEnvWindShared::SetLocation(Vector value) {
    SetSchemaValue(m_ptr, "CEnvWindShared", "m_location", false, value);
}
int32_t GCEnvWindShared::GetGustSound() const {
    return GetSchemaValue<int32_t>(m_ptr, "CEnvWindShared", "m_iszGustSound");
}
void GCEnvWindShared::SetGustSound(int32_t value) {
    SetSchemaValue(m_ptr, "CEnvWindShared", "m_iszGustSound", false, value);
}
int32_t GCEnvWindShared::GetWindDir() const {
    return GetSchemaValue<int32_t>(m_ptr, "CEnvWindShared", "m_iWindDir");
}
void GCEnvWindShared::SetWindDir(int32_t value) {
    SetSchemaValue(m_ptr, "CEnvWindShared", "m_iWindDir", false, value);
}
float GCEnvWindShared::GetWindSpeed() const {
    return GetSchemaValue<float>(m_ptr, "CEnvWindShared", "m_flWindSpeed");
}
void GCEnvWindShared::SetWindSpeed(float value) {
    SetSchemaValue(m_ptr, "CEnvWindShared", "m_flWindSpeed", false, value);
}
Vector GCEnvWindShared::GetCurrentWindVector() const {
    return GetSchemaValue<Vector>(m_ptr, "CEnvWindShared", "m_currentWindVector");
}
void GCEnvWindShared::SetCurrentWindVector(Vector value) {
    SetSchemaValue(m_ptr, "CEnvWindShared", "m_currentWindVector", false, value);
}
Vector GCEnvWindShared::GetCurrentSwayVector() const {
    return GetSchemaValue<Vector>(m_ptr, "CEnvWindShared", "m_CurrentSwayVector");
}
void GCEnvWindShared::SetCurrentSwayVector(Vector value) {
    SetSchemaValue(m_ptr, "CEnvWindShared", "m_CurrentSwayVector", false, value);
}
Vector GCEnvWindShared::GetPrevSwayVector() const {
    return GetSchemaValue<Vector>(m_ptr, "CEnvWindShared", "m_PrevSwayVector");
}
void GCEnvWindShared::SetPrevSwayVector(Vector value) {
    SetSchemaValue(m_ptr, "CEnvWindShared", "m_PrevSwayVector", false, value);
}
uint16_t GCEnvWindShared::GetInitialWindDir() const {
    return GetSchemaValue<uint16_t>(m_ptr, "CEnvWindShared", "m_iInitialWindDir");
}
void GCEnvWindShared::SetInitialWindDir(uint16_t value) {
    SetSchemaValue(m_ptr, "CEnvWindShared", "m_iInitialWindDir", false, value);
}
float GCEnvWindShared::GetInitialWindSpeed() const {
    return GetSchemaValue<float>(m_ptr, "CEnvWindShared", "m_flInitialWindSpeed");
}
void GCEnvWindShared::SetInitialWindSpeed(float value) {
    SetSchemaValue(m_ptr, "CEnvWindShared", "m_flInitialWindSpeed", false, value);
}
GCEntityIOOutput GCEnvWindShared::GetOnGustStart() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CEnvWindShared", "m_OnGustStart"));
    return value;
}
void GCEnvWindShared::SetOnGustStart(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CEnvWindShared", "m_OnGustStart", false, value);
}
GCEntityIOOutput GCEnvWindShared::GetOnGustEnd() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CEnvWindShared", "m_OnGustEnd"));
    return value;
}
void GCEnvWindShared::SetOnGustEnd(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CEnvWindShared", "m_OnGustEnd", false, value);
}
float GCEnvWindShared::GetVariationTime() const {
    return GetSchemaValue<float>(m_ptr, "CEnvWindShared", "m_flVariationTime");
}
void GCEnvWindShared::SetVariationTime(float value) {
    SetSchemaValue(m_ptr, "CEnvWindShared", "m_flVariationTime", false, value);
}
float GCEnvWindShared::GetSwayTime() const {
    return GetSchemaValue<float>(m_ptr, "CEnvWindShared", "m_flSwayTime");
}
void GCEnvWindShared::SetSwayTime(float value) {
    SetSchemaValue(m_ptr, "CEnvWindShared", "m_flSwayTime", false, value);
}
float GCEnvWindShared::GetSimTime() const {
    return GetSchemaValue<float>(m_ptr, "CEnvWindShared", "m_flSimTime");
}
void GCEnvWindShared::SetSimTime(float value) {
    SetSchemaValue(m_ptr, "CEnvWindShared", "m_flSimTime", false, value);
}
float GCEnvWindShared::GetSwitchTime() const {
    return GetSchemaValue<float>(m_ptr, "CEnvWindShared", "m_flSwitchTime");
}
void GCEnvWindShared::SetSwitchTime(float value) {
    SetSchemaValue(m_ptr, "CEnvWindShared", "m_flSwitchTime", false, value);
}
float GCEnvWindShared::GetAveWindSpeed() const {
    return GetSchemaValue<float>(m_ptr, "CEnvWindShared", "m_flAveWindSpeed");
}
void GCEnvWindShared::SetAveWindSpeed(float value) {
    SetSchemaValue(m_ptr, "CEnvWindShared", "m_flAveWindSpeed", false, value);
}
bool GCEnvWindShared::GetGusting() const {
    return GetSchemaValue<bool>(m_ptr, "CEnvWindShared", "m_bGusting");
}
void GCEnvWindShared::SetGusting(bool value) {
    SetSchemaValue(m_ptr, "CEnvWindShared", "m_bGusting", false, value);
}
float GCEnvWindShared::GetWindAngleVariation() const {
    return GetSchemaValue<float>(m_ptr, "CEnvWindShared", "m_flWindAngleVariation");
}
void GCEnvWindShared::SetWindAngleVariation(float value) {
    SetSchemaValue(m_ptr, "CEnvWindShared", "m_flWindAngleVariation", false, value);
}
float GCEnvWindShared::GetWindSpeedVariation() const {
    return GetSchemaValue<float>(m_ptr, "CEnvWindShared", "m_flWindSpeedVariation");
}
void GCEnvWindShared::SetWindSpeedVariation(float value) {
    SetSchemaValue(m_ptr, "CEnvWindShared", "m_flWindSpeedVariation", false, value);
}
CEntityIndex GCEnvWindShared::GetEntIndex() const {
    return GetSchemaValue<CEntityIndex>(m_ptr, "CEnvWindShared", "m_iEntIndex");
}
void GCEnvWindShared::SetEntIndex(CEntityIndex value) {
    SetSchemaValue(m_ptr, "CEnvWindShared", "m_iEntIndex", false, value);
}
std::string GCEnvWindShared::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCEnvWindShared::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCEnvWindShared(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCEnvWindShared>("CEnvWindShared")
        .addConstructor<void (*)(std::string)>()
        .addProperty("StartTime", &GCEnvWindShared::GetStartTime, &GCEnvWindShared::SetStartTime)
        .addProperty("WindSeed", &GCEnvWindShared::GetWindSeed, &GCEnvWindShared::SetWindSeed)
        .addProperty("MinWind", &GCEnvWindShared::GetMinWind, &GCEnvWindShared::SetMinWind)
        .addProperty("MaxWind", &GCEnvWindShared::GetMaxWind, &GCEnvWindShared::SetMaxWind)
        .addProperty("WindRadius", &GCEnvWindShared::GetWindRadius, &GCEnvWindShared::SetWindRadius)
        .addProperty("MinGust", &GCEnvWindShared::GetMinGust, &GCEnvWindShared::SetMinGust)
        .addProperty("MaxGust", &GCEnvWindShared::GetMaxGust, &GCEnvWindShared::SetMaxGust)
        .addProperty("MinGustDelay", &GCEnvWindShared::GetMinGustDelay, &GCEnvWindShared::SetMinGustDelay)
        .addProperty("MaxGustDelay", &GCEnvWindShared::GetMaxGustDelay, &GCEnvWindShared::SetMaxGustDelay)
        .addProperty("GustDuration", &GCEnvWindShared::GetGustDuration, &GCEnvWindShared::SetGustDuration)
        .addProperty("GustDirChange", &GCEnvWindShared::GetGustDirChange, &GCEnvWindShared::SetGustDirChange)
        .addProperty("Location", &GCEnvWindShared::GetLocation, &GCEnvWindShared::SetLocation)
        .addProperty("GustSound", &GCEnvWindShared::GetGustSound, &GCEnvWindShared::SetGustSound)
        .addProperty("WindDir", &GCEnvWindShared::GetWindDir, &GCEnvWindShared::SetWindDir)
        .addProperty("WindSpeed", &GCEnvWindShared::GetWindSpeed, &GCEnvWindShared::SetWindSpeed)
        .addProperty("CurrentWindVector", &GCEnvWindShared::GetCurrentWindVector, &GCEnvWindShared::SetCurrentWindVector)
        .addProperty("CurrentSwayVector", &GCEnvWindShared::GetCurrentSwayVector, &GCEnvWindShared::SetCurrentSwayVector)
        .addProperty("PrevSwayVector", &GCEnvWindShared::GetPrevSwayVector, &GCEnvWindShared::SetPrevSwayVector)
        .addProperty("InitialWindDir", &GCEnvWindShared::GetInitialWindDir, &GCEnvWindShared::SetInitialWindDir)
        .addProperty("InitialWindSpeed", &GCEnvWindShared::GetInitialWindSpeed, &GCEnvWindShared::SetInitialWindSpeed)
        .addProperty("OnGustStart", &GCEnvWindShared::GetOnGustStart, &GCEnvWindShared::SetOnGustStart)
        .addProperty("OnGustEnd", &GCEnvWindShared::GetOnGustEnd, &GCEnvWindShared::SetOnGustEnd)
        .addProperty("VariationTime", &GCEnvWindShared::GetVariationTime, &GCEnvWindShared::SetVariationTime)
        .addProperty("SwayTime", &GCEnvWindShared::GetSwayTime, &GCEnvWindShared::SetSwayTime)
        .addProperty("SimTime", &GCEnvWindShared::GetSimTime, &GCEnvWindShared::SetSimTime)
        .addProperty("SwitchTime", &GCEnvWindShared::GetSwitchTime, &GCEnvWindShared::SetSwitchTime)
        .addProperty("AveWindSpeed", &GCEnvWindShared::GetAveWindSpeed, &GCEnvWindShared::SetAveWindSpeed)
        .addProperty("Gusting", &GCEnvWindShared::GetGusting, &GCEnvWindShared::SetGusting)
        .addProperty("WindAngleVariation", &GCEnvWindShared::GetWindAngleVariation, &GCEnvWindShared::SetWindAngleVariation)
        .addProperty("WindSpeedVariation", &GCEnvWindShared::GetWindSpeedVariation, &GCEnvWindShared::SetWindSpeedVariation)
        .addProperty("EntIndex", &GCEnvWindShared::GetEntIndex, &GCEnvWindShared::SetEntIndex)
        .addFunction("ToPtr", &GCEnvWindShared::ToPtr)
        .addFunction("IsValid", &GCEnvWindShared::IsValid)
        .endClass();
}
GCMolotovGrenade::GCMolotovGrenade(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCMolotovGrenade::GCMolotovGrenade(void *ptr) {
    m_ptr = ptr;
}
std::string GCMolotovGrenade::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCMolotovGrenade::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseCSGrenade GCMolotovGrenade::GetParent() const {
    GCBaseCSGrenade value(m_ptr);
    return value;
}
void GCMolotovGrenade::SetParent(GCBaseCSGrenade value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCMolotovGrenade(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCMolotovGrenade>("CMolotovGrenade")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCMolotovGrenade::GetParent, &GCMolotovGrenade::SetParent)
        .addFunction("ToPtr", &GCMolotovGrenade::ToPtr)
        .addFunction("IsValid", &GCMolotovGrenade::IsValid)
        .endClass();
}
GCPointHurt::GCPointHurt(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCPointHurt::GCPointHurt(void *ptr) {
    m_ptr = ptr;
}
int32_t GCPointHurt::GetDamage() const {
    return GetSchemaValue<int32_t>(m_ptr, "CPointHurt", "m_nDamage");
}
void GCPointHurt::SetDamage(int32_t value) {
    SetSchemaValue(m_ptr, "CPointHurt", "m_nDamage", false, value);
}
int32_t GCPointHurt::GetBitsDamageType() const {
    return GetSchemaValue<int32_t>(m_ptr, "CPointHurt", "m_bitsDamageType");
}
void GCPointHurt::SetBitsDamageType(int32_t value) {
    SetSchemaValue(m_ptr, "CPointHurt", "m_bitsDamageType", false, value);
}
float GCPointHurt::GetRadius() const {
    return GetSchemaValue<float>(m_ptr, "CPointHurt", "m_flRadius");
}
void GCPointHurt::SetRadius(float value) {
    SetSchemaValue(m_ptr, "CPointHurt", "m_flRadius", false, value);
}
float GCPointHurt::GetDelay() const {
    return GetSchemaValue<float>(m_ptr, "CPointHurt", "m_flDelay");
}
void GCPointHurt::SetDelay(float value) {
    SetSchemaValue(m_ptr, "CPointHurt", "m_flDelay", false, value);
}
std::string GCPointHurt::GetStrTarget() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CPointHurt", "m_strTarget").String();
}
void GCPointHurt::SetStrTarget(std::string value) {
    SetSchemaValue(m_ptr, "CPointHurt", "m_strTarget", false, CUtlSymbolLarge(value.c_str()));
}
GCBaseEntity GCPointHurt::GetActivator() const {
    GCBaseEntity value(*GetSchemaValuePtr<void*>(m_ptr, "CPointHurt", "m_pActivator"));
    return value;
}
void GCPointHurt::SetActivator(GCBaseEntity* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Activator' is not possible.\n");
}
std::string GCPointHurt::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCPointHurt::IsValid() {
    return (m_ptr != nullptr);
}
GCPointEntity GCPointHurt::GetParent() const {
    GCPointEntity value(m_ptr);
    return value;
}
void GCPointHurt::SetParent(GCPointEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCPointHurt(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCPointHurt>("CPointHurt")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Damage", &GCPointHurt::GetDamage, &GCPointHurt::SetDamage)
        .addProperty("BitsDamageType", &GCPointHurt::GetBitsDamageType, &GCPointHurt::SetBitsDamageType)
        .addProperty("Radius", &GCPointHurt::GetRadius, &GCPointHurt::SetRadius)
        .addProperty("Delay", &GCPointHurt::GetDelay, &GCPointHurt::SetDelay)
        .addProperty("StrTarget", &GCPointHurt::GetStrTarget, &GCPointHurt::SetStrTarget)
        .addProperty("Activator", &GCPointHurt::GetActivator, &GCPointHurt::SetActivator)
        .addProperty("Parent", &GCPointHurt::GetParent, &GCPointHurt::SetParent)
        .addFunction("ToPtr", &GCPointHurt::ToPtr)
        .addFunction("IsValid", &GCPointHurt::IsValid)
        .endClass();
}
GCPointValueRemapper::GCPointValueRemapper(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCPointValueRemapper::GCPointValueRemapper(void *ptr) {
    m_ptr = ptr;
}
bool GCPointValueRemapper::GetDisabled() const {
    return GetSchemaValue<bool>(m_ptr, "CPointValueRemapper", "m_bDisabled");
}
void GCPointValueRemapper::SetDisabled(bool value) {
    SetSchemaValue(m_ptr, "CPointValueRemapper", "m_bDisabled", false, value);
}
bool GCPointValueRemapper::GetUpdateOnClient() const {
    return GetSchemaValue<bool>(m_ptr, "CPointValueRemapper", "m_bUpdateOnClient");
}
void GCPointValueRemapper::SetUpdateOnClient(bool value) {
    SetSchemaValue(m_ptr, "CPointValueRemapper", "m_bUpdateOnClient", false, value);
}
uint64_t GCPointValueRemapper::GetInputType() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CPointValueRemapper", "m_nInputType");
}
void GCPointValueRemapper::SetInputType(uint64_t value) {
    SetSchemaValue(m_ptr, "CPointValueRemapper", "m_nInputType", false, value);
}
std::string GCPointValueRemapper::GetRemapLineStartName() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CPointValueRemapper", "m_iszRemapLineStartName").String();
}
void GCPointValueRemapper::SetRemapLineStartName(std::string value) {
    SetSchemaValue(m_ptr, "CPointValueRemapper", "m_iszRemapLineStartName", false, CUtlSymbolLarge(value.c_str()));
}
std::string GCPointValueRemapper::GetRemapLineEndName() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CPointValueRemapper", "m_iszRemapLineEndName").String();
}
void GCPointValueRemapper::SetRemapLineEndName(std::string value) {
    SetSchemaValue(m_ptr, "CPointValueRemapper", "m_iszRemapLineEndName", false, CUtlSymbolLarge(value.c_str()));
}
GCBaseEntity GCPointValueRemapper::GetRemapLineStart() const {
    GCBaseEntity value(*GetSchemaValuePtr<void*>(m_ptr, "CPointValueRemapper", "m_hRemapLineStart"));
    return value;
}
void GCPointValueRemapper::SetRemapLineStart(GCBaseEntity* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'RemapLineStart' is not possible.\n");
}
GCBaseEntity GCPointValueRemapper::GetRemapLineEnd() const {
    GCBaseEntity value(*GetSchemaValuePtr<void*>(m_ptr, "CPointValueRemapper", "m_hRemapLineEnd"));
    return value;
}
void GCPointValueRemapper::SetRemapLineEnd(GCBaseEntity* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'RemapLineEnd' is not possible.\n");
}
float GCPointValueRemapper::GetMaximumChangePerSecond() const {
    return GetSchemaValue<float>(m_ptr, "CPointValueRemapper", "m_flMaximumChangePerSecond");
}
void GCPointValueRemapper::SetMaximumChangePerSecond(float value) {
    SetSchemaValue(m_ptr, "CPointValueRemapper", "m_flMaximumChangePerSecond", false, value);
}
float GCPointValueRemapper::GetDisengageDistance() const {
    return GetSchemaValue<float>(m_ptr, "CPointValueRemapper", "m_flDisengageDistance");
}
void GCPointValueRemapper::SetDisengageDistance(float value) {
    SetSchemaValue(m_ptr, "CPointValueRemapper", "m_flDisengageDistance", false, value);
}
float GCPointValueRemapper::GetEngageDistance() const {
    return GetSchemaValue<float>(m_ptr, "CPointValueRemapper", "m_flEngageDistance");
}
void GCPointValueRemapper::SetEngageDistance(float value) {
    SetSchemaValue(m_ptr, "CPointValueRemapper", "m_flEngageDistance", false, value);
}
bool GCPointValueRemapper::GetRequiresUseKey() const {
    return GetSchemaValue<bool>(m_ptr, "CPointValueRemapper", "m_bRequiresUseKey");
}
void GCPointValueRemapper::SetRequiresUseKey(bool value) {
    SetSchemaValue(m_ptr, "CPointValueRemapper", "m_bRequiresUseKey", false, value);
}
uint64_t GCPointValueRemapper::GetOutputType() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CPointValueRemapper", "m_nOutputType");
}
void GCPointValueRemapper::SetOutputType(uint64_t value) {
    SetSchemaValue(m_ptr, "CPointValueRemapper", "m_nOutputType", false, value);
}
std::string GCPointValueRemapper::GetOutputEntityName() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CPointValueRemapper", "m_iszOutputEntityName").String();
}
void GCPointValueRemapper::SetOutputEntityName(std::string value) {
    SetSchemaValue(m_ptr, "CPointValueRemapper", "m_iszOutputEntityName", false, CUtlSymbolLarge(value.c_str()));
}
std::string GCPointValueRemapper::GetOutputEntity2Name() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CPointValueRemapper", "m_iszOutputEntity2Name").String();
}
void GCPointValueRemapper::SetOutputEntity2Name(std::string value) {
    SetSchemaValue(m_ptr, "CPointValueRemapper", "m_iszOutputEntity2Name", false, CUtlSymbolLarge(value.c_str()));
}
std::string GCPointValueRemapper::GetOutputEntity3Name() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CPointValueRemapper", "m_iszOutputEntity3Name").String();
}
void GCPointValueRemapper::SetOutputEntity3Name(std::string value) {
    SetSchemaValue(m_ptr, "CPointValueRemapper", "m_iszOutputEntity3Name", false, CUtlSymbolLarge(value.c_str()));
}
std::string GCPointValueRemapper::GetOutputEntity4Name() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CPointValueRemapper", "m_iszOutputEntity4Name").String();
}
void GCPointValueRemapper::SetOutputEntity4Name(std::string value) {
    SetSchemaValue(m_ptr, "CPointValueRemapper", "m_iszOutputEntity4Name", false, CUtlSymbolLarge(value.c_str()));
}
std::vector<GCBaseEntity*> GCPointValueRemapper::GetOutputEntities() const {
    CUtlVector<GCBaseEntity*>* vec = GetSchemaValue<CUtlVector<GCBaseEntity*>*>(m_ptr, "CPointValueRemapper", "m_hOutputEntities"); std::vector<GCBaseEntity*> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCPointValueRemapper::SetOutputEntities(std::vector<GCBaseEntity*> value) {
    SetSchemaValueCUtlVector<GCBaseEntity*>(m_ptr, "CPointValueRemapper", "m_hOutputEntities", false, value);
}
uint64_t GCPointValueRemapper::GetHapticsType() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CPointValueRemapper", "m_nHapticsType");
}
void GCPointValueRemapper::SetHapticsType(uint64_t value) {
    SetSchemaValue(m_ptr, "CPointValueRemapper", "m_nHapticsType", false, value);
}
uint64_t GCPointValueRemapper::GetMomentumType() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CPointValueRemapper", "m_nMomentumType");
}
void GCPointValueRemapper::SetMomentumType(uint64_t value) {
    SetSchemaValue(m_ptr, "CPointValueRemapper", "m_nMomentumType", false, value);
}
float GCPointValueRemapper::GetMomentumModifier() const {
    return GetSchemaValue<float>(m_ptr, "CPointValueRemapper", "m_flMomentumModifier");
}
void GCPointValueRemapper::SetMomentumModifier(float value) {
    SetSchemaValue(m_ptr, "CPointValueRemapper", "m_flMomentumModifier", false, value);
}
float GCPointValueRemapper::GetSnapValue() const {
    return GetSchemaValue<float>(m_ptr, "CPointValueRemapper", "m_flSnapValue");
}
void GCPointValueRemapper::SetSnapValue(float value) {
    SetSchemaValue(m_ptr, "CPointValueRemapper", "m_flSnapValue", false, value);
}
float GCPointValueRemapper::GetCurrentMomentum() const {
    return GetSchemaValue<float>(m_ptr, "CPointValueRemapper", "m_flCurrentMomentum");
}
void GCPointValueRemapper::SetCurrentMomentum(float value) {
    SetSchemaValue(m_ptr, "CPointValueRemapper", "m_flCurrentMomentum", false, value);
}
uint64_t GCPointValueRemapper::GetRatchetType() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CPointValueRemapper", "m_nRatchetType");
}
void GCPointValueRemapper::SetRatchetType(uint64_t value) {
    SetSchemaValue(m_ptr, "CPointValueRemapper", "m_nRatchetType", false, value);
}
float GCPointValueRemapper::GetRatchetOffset() const {
    return GetSchemaValue<float>(m_ptr, "CPointValueRemapper", "m_flRatchetOffset");
}
void GCPointValueRemapper::SetRatchetOffset(float value) {
    SetSchemaValue(m_ptr, "CPointValueRemapper", "m_flRatchetOffset", false, value);
}
float GCPointValueRemapper::GetInputOffset() const {
    return GetSchemaValue<float>(m_ptr, "CPointValueRemapper", "m_flInputOffset");
}
void GCPointValueRemapper::SetInputOffset(float value) {
    SetSchemaValue(m_ptr, "CPointValueRemapper", "m_flInputOffset", false, value);
}
bool GCPointValueRemapper::GetEngaged() const {
    return GetSchemaValue<bool>(m_ptr, "CPointValueRemapper", "m_bEngaged");
}
void GCPointValueRemapper::SetEngaged(bool value) {
    SetSchemaValue(m_ptr, "CPointValueRemapper", "m_bEngaged", false, value);
}
bool GCPointValueRemapper::GetFirstUpdate() const {
    return GetSchemaValue<bool>(m_ptr, "CPointValueRemapper", "m_bFirstUpdate");
}
void GCPointValueRemapper::SetFirstUpdate(bool value) {
    SetSchemaValue(m_ptr, "CPointValueRemapper", "m_bFirstUpdate", false, value);
}
float GCPointValueRemapper::GetPreviousValue() const {
    return GetSchemaValue<float>(m_ptr, "CPointValueRemapper", "m_flPreviousValue");
}
void GCPointValueRemapper::SetPreviousValue(float value) {
    SetSchemaValue(m_ptr, "CPointValueRemapper", "m_flPreviousValue", false, value);
}
float GCPointValueRemapper::GetPreviousUpdateTickTime() const {
    return GetSchemaValue<float>(m_ptr, "CPointValueRemapper", "m_flPreviousUpdateTickTime");
}
void GCPointValueRemapper::SetPreviousUpdateTickTime(float value) {
    SetSchemaValue(m_ptr, "CPointValueRemapper", "m_flPreviousUpdateTickTime", false, value);
}
Vector GCPointValueRemapper::GetPreviousTestPoint() const {
    return GetSchemaValue<Vector>(m_ptr, "CPointValueRemapper", "m_vecPreviousTestPoint");
}
void GCPointValueRemapper::SetPreviousTestPoint(Vector value) {
    SetSchemaValue(m_ptr, "CPointValueRemapper", "m_vecPreviousTestPoint", false, value);
}
GCBasePlayerPawn GCPointValueRemapper::GetUsingPlayer() const {
    GCBasePlayerPawn value(*GetSchemaValuePtr<void*>(m_ptr, "CPointValueRemapper", "m_hUsingPlayer"));
    return value;
}
void GCPointValueRemapper::SetUsingPlayer(GCBasePlayerPawn* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'UsingPlayer' is not possible.\n");
}
float GCPointValueRemapper::GetCustomOutputValue() const {
    return GetSchemaValue<float>(m_ptr, "CPointValueRemapper", "m_flCustomOutputValue");
}
void GCPointValueRemapper::SetCustomOutputValue(float value) {
    SetSchemaValue(m_ptr, "CPointValueRemapper", "m_flCustomOutputValue", false, value);
}
std::string GCPointValueRemapper::GetSoundEngage() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CPointValueRemapper", "m_iszSoundEngage").String();
}
void GCPointValueRemapper::SetSoundEngage(std::string value) {
    SetSchemaValue(m_ptr, "CPointValueRemapper", "m_iszSoundEngage", false, CUtlSymbolLarge(value.c_str()));
}
std::string GCPointValueRemapper::GetSoundDisengage() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CPointValueRemapper", "m_iszSoundDisengage").String();
}
void GCPointValueRemapper::SetSoundDisengage(std::string value) {
    SetSchemaValue(m_ptr, "CPointValueRemapper", "m_iszSoundDisengage", false, CUtlSymbolLarge(value.c_str()));
}
std::string GCPointValueRemapper::GetSoundReachedValueZero() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CPointValueRemapper", "m_iszSoundReachedValueZero").String();
}
void GCPointValueRemapper::SetSoundReachedValueZero(std::string value) {
    SetSchemaValue(m_ptr, "CPointValueRemapper", "m_iszSoundReachedValueZero", false, CUtlSymbolLarge(value.c_str()));
}
std::string GCPointValueRemapper::GetSoundReachedValueOne() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CPointValueRemapper", "m_iszSoundReachedValueOne").String();
}
void GCPointValueRemapper::SetSoundReachedValueOne(std::string value) {
    SetSchemaValue(m_ptr, "CPointValueRemapper", "m_iszSoundReachedValueOne", false, CUtlSymbolLarge(value.c_str()));
}
std::string GCPointValueRemapper::GetSoundMovingLoop() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CPointValueRemapper", "m_iszSoundMovingLoop").String();
}
void GCPointValueRemapper::SetSoundMovingLoop(std::string value) {
    SetSchemaValue(m_ptr, "CPointValueRemapper", "m_iszSoundMovingLoop", false, CUtlSymbolLarge(value.c_str()));
}
GCEntityIOOutput GCPointValueRemapper::GetOnReachedValueZero() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CPointValueRemapper", "m_OnReachedValueZero"));
    return value;
}
void GCPointValueRemapper::SetOnReachedValueZero(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CPointValueRemapper", "m_OnReachedValueZero", false, value);
}
GCEntityIOOutput GCPointValueRemapper::GetOnReachedValueOne() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CPointValueRemapper", "m_OnReachedValueOne"));
    return value;
}
void GCPointValueRemapper::SetOnReachedValueOne(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CPointValueRemapper", "m_OnReachedValueOne", false, value);
}
GCEntityIOOutput GCPointValueRemapper::GetOnReachedValueCustom() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CPointValueRemapper", "m_OnReachedValueCustom"));
    return value;
}
void GCPointValueRemapper::SetOnReachedValueCustom(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CPointValueRemapper", "m_OnReachedValueCustom", false, value);
}
GCEntityIOOutput GCPointValueRemapper::GetOnEngage() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CPointValueRemapper", "m_OnEngage"));
    return value;
}
void GCPointValueRemapper::SetOnEngage(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CPointValueRemapper", "m_OnEngage", false, value);
}
GCEntityIOOutput GCPointValueRemapper::GetOnDisengage() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CPointValueRemapper", "m_OnDisengage"));
    return value;
}
void GCPointValueRemapper::SetOnDisengage(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CPointValueRemapper", "m_OnDisengage", false, value);
}
std::string GCPointValueRemapper::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCPointValueRemapper::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseEntity GCPointValueRemapper::GetParent() const {
    GCBaseEntity value(m_ptr);
    return value;
}
void GCPointValueRemapper::SetParent(GCBaseEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCPointValueRemapper(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCPointValueRemapper>("CPointValueRemapper")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Disabled", &GCPointValueRemapper::GetDisabled, &GCPointValueRemapper::SetDisabled)
        .addProperty("UpdateOnClient", &GCPointValueRemapper::GetUpdateOnClient, &GCPointValueRemapper::SetUpdateOnClient)
        .addProperty("InputType", &GCPointValueRemapper::GetInputType, &GCPointValueRemapper::SetInputType)
        .addProperty("RemapLineStartName", &GCPointValueRemapper::GetRemapLineStartName, &GCPointValueRemapper::SetRemapLineStartName)
        .addProperty("RemapLineEndName", &GCPointValueRemapper::GetRemapLineEndName, &GCPointValueRemapper::SetRemapLineEndName)
        .addProperty("RemapLineStart", &GCPointValueRemapper::GetRemapLineStart, &GCPointValueRemapper::SetRemapLineStart)
        .addProperty("RemapLineEnd", &GCPointValueRemapper::GetRemapLineEnd, &GCPointValueRemapper::SetRemapLineEnd)
        .addProperty("MaximumChangePerSecond", &GCPointValueRemapper::GetMaximumChangePerSecond, &GCPointValueRemapper::SetMaximumChangePerSecond)
        .addProperty("DisengageDistance", &GCPointValueRemapper::GetDisengageDistance, &GCPointValueRemapper::SetDisengageDistance)
        .addProperty("EngageDistance", &GCPointValueRemapper::GetEngageDistance, &GCPointValueRemapper::SetEngageDistance)
        .addProperty("RequiresUseKey", &GCPointValueRemapper::GetRequiresUseKey, &GCPointValueRemapper::SetRequiresUseKey)
        .addProperty("OutputType", &GCPointValueRemapper::GetOutputType, &GCPointValueRemapper::SetOutputType)
        .addProperty("OutputEntityName", &GCPointValueRemapper::GetOutputEntityName, &GCPointValueRemapper::SetOutputEntityName)
        .addProperty("OutputEntity2Name", &GCPointValueRemapper::GetOutputEntity2Name, &GCPointValueRemapper::SetOutputEntity2Name)
        .addProperty("OutputEntity3Name", &GCPointValueRemapper::GetOutputEntity3Name, &GCPointValueRemapper::SetOutputEntity3Name)
        .addProperty("OutputEntity4Name", &GCPointValueRemapper::GetOutputEntity4Name, &GCPointValueRemapper::SetOutputEntity4Name)
        .addProperty("OutputEntities", &GCPointValueRemapper::GetOutputEntities, &GCPointValueRemapper::SetOutputEntities)
        .addProperty("HapticsType", &GCPointValueRemapper::GetHapticsType, &GCPointValueRemapper::SetHapticsType)
        .addProperty("MomentumType", &GCPointValueRemapper::GetMomentumType, &GCPointValueRemapper::SetMomentumType)
        .addProperty("MomentumModifier", &GCPointValueRemapper::GetMomentumModifier, &GCPointValueRemapper::SetMomentumModifier)
        .addProperty("SnapValue", &GCPointValueRemapper::GetSnapValue, &GCPointValueRemapper::SetSnapValue)
        .addProperty("CurrentMomentum", &GCPointValueRemapper::GetCurrentMomentum, &GCPointValueRemapper::SetCurrentMomentum)
        .addProperty("RatchetType", &GCPointValueRemapper::GetRatchetType, &GCPointValueRemapper::SetRatchetType)
        .addProperty("RatchetOffset", &GCPointValueRemapper::GetRatchetOffset, &GCPointValueRemapper::SetRatchetOffset)
        .addProperty("InputOffset", &GCPointValueRemapper::GetInputOffset, &GCPointValueRemapper::SetInputOffset)
        .addProperty("Engaged", &GCPointValueRemapper::GetEngaged, &GCPointValueRemapper::SetEngaged)
        .addProperty("FirstUpdate", &GCPointValueRemapper::GetFirstUpdate, &GCPointValueRemapper::SetFirstUpdate)
        .addProperty("PreviousValue", &GCPointValueRemapper::GetPreviousValue, &GCPointValueRemapper::SetPreviousValue)
        .addProperty("PreviousUpdateTickTime", &GCPointValueRemapper::GetPreviousUpdateTickTime, &GCPointValueRemapper::SetPreviousUpdateTickTime)
        .addProperty("PreviousTestPoint", &GCPointValueRemapper::GetPreviousTestPoint, &GCPointValueRemapper::SetPreviousTestPoint)
        .addProperty("UsingPlayer", &GCPointValueRemapper::GetUsingPlayer, &GCPointValueRemapper::SetUsingPlayer)
        .addProperty("CustomOutputValue", &GCPointValueRemapper::GetCustomOutputValue, &GCPointValueRemapper::SetCustomOutputValue)
        .addProperty("SoundEngage", &GCPointValueRemapper::GetSoundEngage, &GCPointValueRemapper::SetSoundEngage)
        .addProperty("SoundDisengage", &GCPointValueRemapper::GetSoundDisengage, &GCPointValueRemapper::SetSoundDisengage)
        .addProperty("SoundReachedValueZero", &GCPointValueRemapper::GetSoundReachedValueZero, &GCPointValueRemapper::SetSoundReachedValueZero)
        .addProperty("SoundReachedValueOne", &GCPointValueRemapper::GetSoundReachedValueOne, &GCPointValueRemapper::SetSoundReachedValueOne)
        .addProperty("SoundMovingLoop", &GCPointValueRemapper::GetSoundMovingLoop, &GCPointValueRemapper::SetSoundMovingLoop)
        .addProperty("OnReachedValueZero", &GCPointValueRemapper::GetOnReachedValueZero, &GCPointValueRemapper::SetOnReachedValueZero)
        .addProperty("OnReachedValueOne", &GCPointValueRemapper::GetOnReachedValueOne, &GCPointValueRemapper::SetOnReachedValueOne)
        .addProperty("OnReachedValueCustom", &GCPointValueRemapper::GetOnReachedValueCustom, &GCPointValueRemapper::SetOnReachedValueCustom)
        .addProperty("OnEngage", &GCPointValueRemapper::GetOnEngage, &GCPointValueRemapper::SetOnEngage)
        .addProperty("OnDisengage", &GCPointValueRemapper::GetOnDisengage, &GCPointValueRemapper::SetOnDisengage)
        .addProperty("Parent", &GCPointValueRemapper::GetParent, &GCPointValueRemapper::SetParent)
        .addFunction("ToPtr", &GCPointValueRemapper::ToPtr)
        .addFunction("IsValid", &GCPointValueRemapper::IsValid)
        .endClass();
}
GCLogicNPCCounterAABB::GCLogicNPCCounterAABB(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCLogicNPCCounterAABB::GCLogicNPCCounterAABB(void *ptr) {
    m_ptr = ptr;
}
Vector GCLogicNPCCounterAABB::GetDistanceOuterMins() const {
    return GetSchemaValue<Vector>(m_ptr, "CLogicNPCCounterAABB", "m_vDistanceOuterMins");
}
void GCLogicNPCCounterAABB::SetDistanceOuterMins(Vector value) {
    SetSchemaValue(m_ptr, "CLogicNPCCounterAABB", "m_vDistanceOuterMins", false, value);
}
Vector GCLogicNPCCounterAABB::GetDistanceOuterMaxs() const {
    return GetSchemaValue<Vector>(m_ptr, "CLogicNPCCounterAABB", "m_vDistanceOuterMaxs");
}
void GCLogicNPCCounterAABB::SetDistanceOuterMaxs(Vector value) {
    SetSchemaValue(m_ptr, "CLogicNPCCounterAABB", "m_vDistanceOuterMaxs", false, value);
}
Vector GCLogicNPCCounterAABB::GetOuterMins() const {
    return GetSchemaValue<Vector>(m_ptr, "CLogicNPCCounterAABB", "m_vOuterMins");
}
void GCLogicNPCCounterAABB::SetOuterMins(Vector value) {
    SetSchemaValue(m_ptr, "CLogicNPCCounterAABB", "m_vOuterMins", false, value);
}
Vector GCLogicNPCCounterAABB::GetOuterMaxs() const {
    return GetSchemaValue<Vector>(m_ptr, "CLogicNPCCounterAABB", "m_vOuterMaxs");
}
void GCLogicNPCCounterAABB::SetOuterMaxs(Vector value) {
    SetSchemaValue(m_ptr, "CLogicNPCCounterAABB", "m_vOuterMaxs", false, value);
}
std::string GCLogicNPCCounterAABB::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCLogicNPCCounterAABB::IsValid() {
    return (m_ptr != nullptr);
}
GCLogicNPCCounter GCLogicNPCCounterAABB::GetParent() const {
    GCLogicNPCCounter value(m_ptr);
    return value;
}
void GCLogicNPCCounterAABB::SetParent(GCLogicNPCCounter value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCLogicNPCCounterAABB(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCLogicNPCCounterAABB>("CLogicNPCCounterAABB")
        .addConstructor<void (*)(std::string)>()
        .addProperty("DistanceOuterMins", &GCLogicNPCCounterAABB::GetDistanceOuterMins, &GCLogicNPCCounterAABB::SetDistanceOuterMins)
        .addProperty("DistanceOuterMaxs", &GCLogicNPCCounterAABB::GetDistanceOuterMaxs, &GCLogicNPCCounterAABB::SetDistanceOuterMaxs)
        .addProperty("OuterMins", &GCLogicNPCCounterAABB::GetOuterMins, &GCLogicNPCCounterAABB::SetOuterMins)
        .addProperty("OuterMaxs", &GCLogicNPCCounterAABB::GetOuterMaxs, &GCLogicNPCCounterAABB::SetOuterMaxs)
        .addProperty("Parent", &GCLogicNPCCounterAABB::GetParent, &GCLogicNPCCounterAABB::SetParent)
        .addFunction("ToPtr", &GCLogicNPCCounterAABB::ToPtr)
        .addFunction("IsValid", &GCLogicNPCCounterAABB::IsValid)
        .endClass();
}
GCLightOrthoEntity::GCLightOrthoEntity(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCLightOrthoEntity::GCLightOrthoEntity(void *ptr) {
    m_ptr = ptr;
}
std::string GCLightOrthoEntity::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCLightOrthoEntity::IsValid() {
    return (m_ptr != nullptr);
}
GCLightEntity GCLightOrthoEntity::GetParent() const {
    GCLightEntity value(m_ptr);
    return value;
}
void GCLightOrthoEntity::SetParent(GCLightEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCLightOrthoEntity(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCLightOrthoEntity>("CLightOrthoEntity")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCLightOrthoEntity::GetParent, &GCLightOrthoEntity::SetParent)
        .addFunction("ToPtr", &GCLightOrthoEntity::ToPtr)
        .addFunction("IsValid", &GCLightOrthoEntity::IsValid)
        .endClass();
}
GCEnvSoundscapeTriggerable::GCEnvSoundscapeTriggerable(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCEnvSoundscapeTriggerable::GCEnvSoundscapeTriggerable(void *ptr) {
    m_ptr = ptr;
}
std::string GCEnvSoundscapeTriggerable::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCEnvSoundscapeTriggerable::IsValid() {
    return (m_ptr != nullptr);
}
GCEnvSoundscape GCEnvSoundscapeTriggerable::GetParent() const {
    GCEnvSoundscape value(m_ptr);
    return value;
}
void GCEnvSoundscapeTriggerable::SetParent(GCEnvSoundscape value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCEnvSoundscapeTriggerable(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCEnvSoundscapeTriggerable>("CEnvSoundscapeTriggerable")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCEnvSoundscapeTriggerable::GetParent, &GCEnvSoundscapeTriggerable::SetParent)
        .addFunction("ToPtr", &GCEnvSoundscapeTriggerable::ToPtr)
        .addFunction("IsValid", &GCEnvSoundscapeTriggerable::IsValid)
        .endClass();
}
GCSoundOpvarSetPointEntity::GCSoundOpvarSetPointEntity(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCSoundOpvarSetPointEntity::GCSoundOpvarSetPointEntity(void *ptr) {
    m_ptr = ptr;
}
GCEntityIOOutput GCSoundOpvarSetPointEntity::GetOnEnter() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CSoundOpvarSetPointEntity", "m_OnEnter"));
    return value;
}
void GCSoundOpvarSetPointEntity::SetOnEnter(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CSoundOpvarSetPointEntity", "m_OnEnter", false, value);
}
GCEntityIOOutput GCSoundOpvarSetPointEntity::GetOnExit() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CSoundOpvarSetPointEntity", "m_OnExit"));
    return value;
}
void GCSoundOpvarSetPointEntity::SetOnExit(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CSoundOpvarSetPointEntity", "m_OnExit", false, value);
}
bool GCSoundOpvarSetPointEntity::GetAutoDisable() const {
    return GetSchemaValue<bool>(m_ptr, "CSoundOpvarSetPointEntity", "m_bAutoDisable");
}
void GCSoundOpvarSetPointEntity::SetAutoDisable(bool value) {
    SetSchemaValue(m_ptr, "CSoundOpvarSetPointEntity", "m_bAutoDisable", false, value);
}
float GCSoundOpvarSetPointEntity::GetDistanceMin() const {
    return GetSchemaValue<float>(m_ptr, "CSoundOpvarSetPointEntity", "m_flDistanceMin");
}
void GCSoundOpvarSetPointEntity::SetDistanceMin(float value) {
    SetSchemaValue(m_ptr, "CSoundOpvarSetPointEntity", "m_flDistanceMin", false, value);
}
float GCSoundOpvarSetPointEntity::GetDistanceMax() const {
    return GetSchemaValue<float>(m_ptr, "CSoundOpvarSetPointEntity", "m_flDistanceMax");
}
void GCSoundOpvarSetPointEntity::SetDistanceMax(float value) {
    SetSchemaValue(m_ptr, "CSoundOpvarSetPointEntity", "m_flDistanceMax", false, value);
}
float GCSoundOpvarSetPointEntity::GetDistanceMapMin() const {
    return GetSchemaValue<float>(m_ptr, "CSoundOpvarSetPointEntity", "m_flDistanceMapMin");
}
void GCSoundOpvarSetPointEntity::SetDistanceMapMin(float value) {
    SetSchemaValue(m_ptr, "CSoundOpvarSetPointEntity", "m_flDistanceMapMin", false, value);
}
float GCSoundOpvarSetPointEntity::GetDistanceMapMax() const {
    return GetSchemaValue<float>(m_ptr, "CSoundOpvarSetPointEntity", "m_flDistanceMapMax");
}
void GCSoundOpvarSetPointEntity::SetDistanceMapMax(float value) {
    SetSchemaValue(m_ptr, "CSoundOpvarSetPointEntity", "m_flDistanceMapMax", false, value);
}
float GCSoundOpvarSetPointEntity::GetOcclusionRadius() const {
    return GetSchemaValue<float>(m_ptr, "CSoundOpvarSetPointEntity", "m_flOcclusionRadius");
}
void GCSoundOpvarSetPointEntity::SetOcclusionRadius(float value) {
    SetSchemaValue(m_ptr, "CSoundOpvarSetPointEntity", "m_flOcclusionRadius", false, value);
}
float GCSoundOpvarSetPointEntity::GetOcclusionMin() const {
    return GetSchemaValue<float>(m_ptr, "CSoundOpvarSetPointEntity", "m_flOcclusionMin");
}
void GCSoundOpvarSetPointEntity::SetOcclusionMin(float value) {
    SetSchemaValue(m_ptr, "CSoundOpvarSetPointEntity", "m_flOcclusionMin", false, value);
}
float GCSoundOpvarSetPointEntity::GetOcclusionMax() const {
    return GetSchemaValue<float>(m_ptr, "CSoundOpvarSetPointEntity", "m_flOcclusionMax");
}
void GCSoundOpvarSetPointEntity::SetOcclusionMax(float value) {
    SetSchemaValue(m_ptr, "CSoundOpvarSetPointEntity", "m_flOcclusionMax", false, value);
}
float GCSoundOpvarSetPointEntity::GetValSetOnDisable() const {
    return GetSchemaValue<float>(m_ptr, "CSoundOpvarSetPointEntity", "m_flValSetOnDisable");
}
void GCSoundOpvarSetPointEntity::SetValSetOnDisable(float value) {
    SetSchemaValue(m_ptr, "CSoundOpvarSetPointEntity", "m_flValSetOnDisable", false, value);
}
bool GCSoundOpvarSetPointEntity::GetSetValueOnDisable() const {
    return GetSchemaValue<bool>(m_ptr, "CSoundOpvarSetPointEntity", "m_bSetValueOnDisable");
}
void GCSoundOpvarSetPointEntity::SetSetValueOnDisable(bool value) {
    SetSchemaValue(m_ptr, "CSoundOpvarSetPointEntity", "m_bSetValueOnDisable", false, value);
}
int32_t GCSoundOpvarSetPointEntity::GetSimulationMode() const {
    return GetSchemaValue<int32_t>(m_ptr, "CSoundOpvarSetPointEntity", "m_nSimulationMode");
}
void GCSoundOpvarSetPointEntity::SetSimulationMode(int32_t value) {
    SetSchemaValue(m_ptr, "CSoundOpvarSetPointEntity", "m_nSimulationMode", false, value);
}
int32_t GCSoundOpvarSetPointEntity::GetVisibilitySamples() const {
    return GetSchemaValue<int32_t>(m_ptr, "CSoundOpvarSetPointEntity", "m_nVisibilitySamples");
}
void GCSoundOpvarSetPointEntity::SetVisibilitySamples(int32_t value) {
    SetSchemaValue(m_ptr, "CSoundOpvarSetPointEntity", "m_nVisibilitySamples", false, value);
}
Vector GCSoundOpvarSetPointEntity::GetDynamicProxyPoint() const {
    return GetSchemaValue<Vector>(m_ptr, "CSoundOpvarSetPointEntity", "m_vDynamicProxyPoint");
}
void GCSoundOpvarSetPointEntity::SetDynamicProxyPoint(Vector value) {
    SetSchemaValue(m_ptr, "CSoundOpvarSetPointEntity", "m_vDynamicProxyPoint", false, value);
}
float GCSoundOpvarSetPointEntity::GetDynamicMaximumOcclusion() const {
    return GetSchemaValue<float>(m_ptr, "CSoundOpvarSetPointEntity", "m_flDynamicMaximumOcclusion");
}
void GCSoundOpvarSetPointEntity::SetDynamicMaximumOcclusion(float value) {
    SetSchemaValue(m_ptr, "CSoundOpvarSetPointEntity", "m_flDynamicMaximumOcclusion", false, value);
}
GCEntityInstance GCSoundOpvarSetPointEntity::GetDynamicEntity() const {
    GCEntityInstance value(*GetSchemaValuePtr<void*>(m_ptr, "CSoundOpvarSetPointEntity", "m_hDynamicEntity"));
    return value;
}
void GCSoundOpvarSetPointEntity::SetDynamicEntity(GCEntityInstance* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'DynamicEntity' is not possible.\n");
}
std::string GCSoundOpvarSetPointEntity::GetDynamicEntityName() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CSoundOpvarSetPointEntity", "m_iszDynamicEntityName").String();
}
void GCSoundOpvarSetPointEntity::SetDynamicEntityName(std::string value) {
    SetSchemaValue(m_ptr, "CSoundOpvarSetPointEntity", "m_iszDynamicEntityName", false, CUtlSymbolLarge(value.c_str()));
}
float GCSoundOpvarSetPointEntity::GetPathingDistanceNormFactor() const {
    return GetSchemaValue<float>(m_ptr, "CSoundOpvarSetPointEntity", "m_flPathingDistanceNormFactor");
}
void GCSoundOpvarSetPointEntity::SetPathingDistanceNormFactor(float value) {
    SetSchemaValue(m_ptr, "CSoundOpvarSetPointEntity", "m_flPathingDistanceNormFactor", false, value);
}
Vector GCSoundOpvarSetPointEntity::GetPathingSourcePos() const {
    return GetSchemaValue<Vector>(m_ptr, "CSoundOpvarSetPointEntity", "m_vPathingSourcePos");
}
void GCSoundOpvarSetPointEntity::SetPathingSourcePos(Vector value) {
    SetSchemaValue(m_ptr, "CSoundOpvarSetPointEntity", "m_vPathingSourcePos", false, value);
}
Vector GCSoundOpvarSetPointEntity::GetPathingListenerPos() const {
    return GetSchemaValue<Vector>(m_ptr, "CSoundOpvarSetPointEntity", "m_vPathingListenerPos");
}
void GCSoundOpvarSetPointEntity::SetPathingListenerPos(Vector value) {
    SetSchemaValue(m_ptr, "CSoundOpvarSetPointEntity", "m_vPathingListenerPos", false, value);
}
Vector GCSoundOpvarSetPointEntity::GetPathingDirection() const {
    return GetSchemaValue<Vector>(m_ptr, "CSoundOpvarSetPointEntity", "m_vPathingDirection");
}
void GCSoundOpvarSetPointEntity::SetPathingDirection(Vector value) {
    SetSchemaValue(m_ptr, "CSoundOpvarSetPointEntity", "m_vPathingDirection", false, value);
}
int32_t GCSoundOpvarSetPointEntity::GetPathingSourceIndex() const {
    return GetSchemaValue<int32_t>(m_ptr, "CSoundOpvarSetPointEntity", "m_nPathingSourceIndex");
}
void GCSoundOpvarSetPointEntity::SetPathingSourceIndex(int32_t value) {
    SetSchemaValue(m_ptr, "CSoundOpvarSetPointEntity", "m_nPathingSourceIndex", false, value);
}
std::string GCSoundOpvarSetPointEntity::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCSoundOpvarSetPointEntity::IsValid() {
    return (m_ptr != nullptr);
}
GCSoundOpvarSetPointBase GCSoundOpvarSetPointEntity::GetParent() const {
    GCSoundOpvarSetPointBase value(m_ptr);
    return value;
}
void GCSoundOpvarSetPointEntity::SetParent(GCSoundOpvarSetPointBase value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCSoundOpvarSetPointEntity(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCSoundOpvarSetPointEntity>("CSoundOpvarSetPointEntity")
        .addConstructor<void (*)(std::string)>()
        .addProperty("OnEnter", &GCSoundOpvarSetPointEntity::GetOnEnter, &GCSoundOpvarSetPointEntity::SetOnEnter)
        .addProperty("OnExit", &GCSoundOpvarSetPointEntity::GetOnExit, &GCSoundOpvarSetPointEntity::SetOnExit)
        .addProperty("AutoDisable", &GCSoundOpvarSetPointEntity::GetAutoDisable, &GCSoundOpvarSetPointEntity::SetAutoDisable)
        .addProperty("DistanceMin", &GCSoundOpvarSetPointEntity::GetDistanceMin, &GCSoundOpvarSetPointEntity::SetDistanceMin)
        .addProperty("DistanceMax", &GCSoundOpvarSetPointEntity::GetDistanceMax, &GCSoundOpvarSetPointEntity::SetDistanceMax)
        .addProperty("DistanceMapMin", &GCSoundOpvarSetPointEntity::GetDistanceMapMin, &GCSoundOpvarSetPointEntity::SetDistanceMapMin)
        .addProperty("DistanceMapMax", &GCSoundOpvarSetPointEntity::GetDistanceMapMax, &GCSoundOpvarSetPointEntity::SetDistanceMapMax)
        .addProperty("OcclusionRadius", &GCSoundOpvarSetPointEntity::GetOcclusionRadius, &GCSoundOpvarSetPointEntity::SetOcclusionRadius)
        .addProperty("OcclusionMin", &GCSoundOpvarSetPointEntity::GetOcclusionMin, &GCSoundOpvarSetPointEntity::SetOcclusionMin)
        .addProperty("OcclusionMax", &GCSoundOpvarSetPointEntity::GetOcclusionMax, &GCSoundOpvarSetPointEntity::SetOcclusionMax)
        .addProperty("ValSetOnDisable", &GCSoundOpvarSetPointEntity::GetValSetOnDisable, &GCSoundOpvarSetPointEntity::SetValSetOnDisable)
        .addProperty("SetValueOnDisable", &GCSoundOpvarSetPointEntity::GetSetValueOnDisable, &GCSoundOpvarSetPointEntity::SetSetValueOnDisable)
        .addProperty("SimulationMode", &GCSoundOpvarSetPointEntity::GetSimulationMode, &GCSoundOpvarSetPointEntity::SetSimulationMode)
        .addProperty("VisibilitySamples", &GCSoundOpvarSetPointEntity::GetVisibilitySamples, &GCSoundOpvarSetPointEntity::SetVisibilitySamples)
        .addProperty("DynamicProxyPoint", &GCSoundOpvarSetPointEntity::GetDynamicProxyPoint, &GCSoundOpvarSetPointEntity::SetDynamicProxyPoint)
        .addProperty("DynamicMaximumOcclusion", &GCSoundOpvarSetPointEntity::GetDynamicMaximumOcclusion, &GCSoundOpvarSetPointEntity::SetDynamicMaximumOcclusion)
        .addProperty("DynamicEntity", &GCSoundOpvarSetPointEntity::GetDynamicEntity, &GCSoundOpvarSetPointEntity::SetDynamicEntity)
        .addProperty("DynamicEntityName", &GCSoundOpvarSetPointEntity::GetDynamicEntityName, &GCSoundOpvarSetPointEntity::SetDynamicEntityName)
        .addProperty("PathingDistanceNormFactor", &GCSoundOpvarSetPointEntity::GetPathingDistanceNormFactor, &GCSoundOpvarSetPointEntity::SetPathingDistanceNormFactor)
        .addProperty("PathingSourcePos", &GCSoundOpvarSetPointEntity::GetPathingSourcePos, &GCSoundOpvarSetPointEntity::SetPathingSourcePos)
        .addProperty("PathingListenerPos", &GCSoundOpvarSetPointEntity::GetPathingListenerPos, &GCSoundOpvarSetPointEntity::SetPathingListenerPos)
        .addProperty("PathingDirection", &GCSoundOpvarSetPointEntity::GetPathingDirection, &GCSoundOpvarSetPointEntity::SetPathingDirection)
        .addProperty("PathingSourceIndex", &GCSoundOpvarSetPointEntity::GetPathingSourceIndex, &GCSoundOpvarSetPointEntity::SetPathingSourceIndex)
        .addProperty("Parent", &GCSoundOpvarSetPointEntity::GetParent, &GCSoundOpvarSetPointEntity::SetParent)
        .addFunction("ToPtr", &GCSoundOpvarSetPointEntity::ToPtr)
        .addFunction("IsValid", &GCSoundOpvarSetPointEntity::IsValid)
        .endClass();
}
GCBasePlayerPawn::GCBasePlayerPawn(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCBasePlayerPawn::GCBasePlayerPawn(void *ptr) {
    m_ptr = ptr;
}
GCPlayer_WeaponServices GCBasePlayerPawn::GetWeaponServices() const {
    GCPlayer_WeaponServices value(*GetSchemaValuePtr<void*>(m_ptr, "CBasePlayerPawn", "m_pWeaponServices"));
    return value;
}
void GCBasePlayerPawn::SetWeaponServices(GCPlayer_WeaponServices* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'WeaponServices' is not possible.\n");
}
GCPlayer_ItemServices GCBasePlayerPawn::GetItemServices() const {
    GCPlayer_ItemServices value(*GetSchemaValuePtr<void*>(m_ptr, "CBasePlayerPawn", "m_pItemServices"));
    return value;
}
void GCBasePlayerPawn::SetItemServices(GCPlayer_ItemServices* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'ItemServices' is not possible.\n");
}
GCPlayer_AutoaimServices GCBasePlayerPawn::GetAutoaimServices() const {
    GCPlayer_AutoaimServices value(*GetSchemaValuePtr<void*>(m_ptr, "CBasePlayerPawn", "m_pAutoaimServices"));
    return value;
}
void GCBasePlayerPawn::SetAutoaimServices(GCPlayer_AutoaimServices* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'AutoaimServices' is not possible.\n");
}
GCPlayer_ObserverServices GCBasePlayerPawn::GetObserverServices() const {
    GCPlayer_ObserverServices value(*GetSchemaValuePtr<void*>(m_ptr, "CBasePlayerPawn", "m_pObserverServices"));
    return value;
}
void GCBasePlayerPawn::SetObserverServices(GCPlayer_ObserverServices* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'ObserverServices' is not possible.\n");
}
GCPlayer_WaterServices GCBasePlayerPawn::GetWaterServices() const {
    GCPlayer_WaterServices value(*GetSchemaValuePtr<void*>(m_ptr, "CBasePlayerPawn", "m_pWaterServices"));
    return value;
}
void GCBasePlayerPawn::SetWaterServices(GCPlayer_WaterServices* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'WaterServices' is not possible.\n");
}
GCPlayer_UseServices GCBasePlayerPawn::GetUseServices() const {
    GCPlayer_UseServices value(*GetSchemaValuePtr<void*>(m_ptr, "CBasePlayerPawn", "m_pUseServices"));
    return value;
}
void GCBasePlayerPawn::SetUseServices(GCPlayer_UseServices* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'UseServices' is not possible.\n");
}
GCPlayer_FlashlightServices GCBasePlayerPawn::GetFlashlightServices() const {
    GCPlayer_FlashlightServices value(*GetSchemaValuePtr<void*>(m_ptr, "CBasePlayerPawn", "m_pFlashlightServices"));
    return value;
}
void GCBasePlayerPawn::SetFlashlightServices(GCPlayer_FlashlightServices* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'FlashlightServices' is not possible.\n");
}
GCPlayer_CameraServices GCBasePlayerPawn::GetCameraServices() const {
    GCPlayer_CameraServices value(*GetSchemaValuePtr<void*>(m_ptr, "CBasePlayerPawn", "m_pCameraServices"));
    return value;
}
void GCBasePlayerPawn::SetCameraServices(GCPlayer_CameraServices* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'CameraServices' is not possible.\n");
}
GCPlayer_MovementServices GCBasePlayerPawn::GetMovementServices() const {
    GCPlayer_MovementServices value(*GetSchemaValuePtr<void*>(m_ptr, "CBasePlayerPawn", "m_pMovementServices"));
    return value;
}
void GCBasePlayerPawn::SetMovementServices(GCPlayer_MovementServices* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'MovementServices' is not possible.\n");
}
std::vector<GViewAngleServerChange_t> GCBasePlayerPawn::GetServerViewAngleChanges() const {
    CUtlVector<GViewAngleServerChange_t>* vec = GetSchemaValue<CUtlVector<GViewAngleServerChange_t>*>(m_ptr, "CBasePlayerPawn", "m_ServerViewAngleChanges"); std::vector<GViewAngleServerChange_t> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCBasePlayerPawn::SetServerViewAngleChanges(std::vector<GViewAngleServerChange_t> value) {
    SetSchemaValueCUtlVector<GViewAngleServerChange_t>(m_ptr, "CBasePlayerPawn", "m_ServerViewAngleChanges", false, value);
}
uint32_t GCBasePlayerPawn::GetHighestGeneratedServerViewAngleChangeIndex() const {
    return GetSchemaValue<uint32_t>(m_ptr, "CBasePlayerPawn", "m_nHighestGeneratedServerViewAngleChangeIndex");
}
void GCBasePlayerPawn::SetHighestGeneratedServerViewAngleChangeIndex(uint32_t value) {
    SetSchemaValue(m_ptr, "CBasePlayerPawn", "m_nHighestGeneratedServerViewAngleChangeIndex", false, value);
}
QAngle GCBasePlayerPawn::Get_angle() const {
    return GetSchemaValue<QAngle>(m_ptr, "CBasePlayerPawn", "v_angle");
}
void GCBasePlayerPawn::Set_angle(QAngle value) {
    SetSchemaValue(m_ptr, "CBasePlayerPawn", "v_angle", false, value);
}
QAngle GCBasePlayerPawn::Get_anglePrevious() const {
    return GetSchemaValue<QAngle>(m_ptr, "CBasePlayerPawn", "v_anglePrevious");
}
void GCBasePlayerPawn::Set_anglePrevious(QAngle value) {
    SetSchemaValue(m_ptr, "CBasePlayerPawn", "v_anglePrevious", false, value);
}
uint32_t GCBasePlayerPawn::GetHideHUD() const {
    return GetSchemaValue<uint32_t>(m_ptr, "CBasePlayerPawn", "m_iHideHUD");
}
void GCBasePlayerPawn::SetHideHUD(uint32_t value) {
    SetSchemaValue(m_ptr, "CBasePlayerPawn", "m_iHideHUD", false, value);
}
Gsky3dparams_t GCBasePlayerPawn::GetSkybox3d() const {
    Gsky3dparams_t value(GetSchemaPtr(m_ptr, "CBasePlayerPawn", "m_skybox3d"));
    return value;
}
void GCBasePlayerPawn::SetSkybox3d(Gsky3dparams_t value) {
    SetSchemaValue(m_ptr, "CBasePlayerPawn", "m_skybox3d", false, value);
}
float GCBasePlayerPawn::GetTimeLastHurt() const {
    return GetSchemaValue<float>(m_ptr, "CBasePlayerPawn", "m_fTimeLastHurt");
}
void GCBasePlayerPawn::SetTimeLastHurt(float value) {
    SetSchemaValue(m_ptr, "CBasePlayerPawn", "m_fTimeLastHurt", false, value);
}
float GCBasePlayerPawn::GetDeathTime() const {
    return GetSchemaValue<float>(m_ptr, "CBasePlayerPawn", "m_flDeathTime");
}
void GCBasePlayerPawn::SetDeathTime(float value) {
    SetSchemaValue(m_ptr, "CBasePlayerPawn", "m_flDeathTime", false, value);
}
float GCBasePlayerPawn::GetNextSuicideTime() const {
    return GetSchemaValue<float>(m_ptr, "CBasePlayerPawn", "m_fNextSuicideTime");
}
void GCBasePlayerPawn::SetNextSuicideTime(float value) {
    SetSchemaValue(m_ptr, "CBasePlayerPawn", "m_fNextSuicideTime", false, value);
}
bool GCBasePlayerPawn::GetInitHUD() const {
    return GetSchemaValue<bool>(m_ptr, "CBasePlayerPawn", "m_fInitHUD");
}
void GCBasePlayerPawn::SetInitHUD(bool value) {
    SetSchemaValue(m_ptr, "CBasePlayerPawn", "m_fInitHUD", false, value);
}
GCAI_Expresser GCBasePlayerPawn::GetExpresser() const {
    GCAI_Expresser value(*GetSchemaValuePtr<void*>(m_ptr, "CBasePlayerPawn", "m_pExpresser"));
    return value;
}
void GCBasePlayerPawn::SetExpresser(GCAI_Expresser* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Expresser' is not possible.\n");
}
GCBasePlayerController GCBasePlayerPawn::GetController() const {
    GCBasePlayerController value(*GetSchemaValuePtr<void*>(m_ptr, "CBasePlayerPawn", "m_hController"));
    return value;
}
void GCBasePlayerPawn::SetController(GCBasePlayerController* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Controller' is not possible.\n");
}
float GCBasePlayerPawn::GetHltvReplayDelay() const {
    return GetSchemaValue<float>(m_ptr, "CBasePlayerPawn", "m_fHltvReplayDelay");
}
void GCBasePlayerPawn::SetHltvReplayDelay(float value) {
    SetSchemaValue(m_ptr, "CBasePlayerPawn", "m_fHltvReplayDelay", false, value);
}
float GCBasePlayerPawn::GetHltvReplayEnd() const {
    return GetSchemaValue<float>(m_ptr, "CBasePlayerPawn", "m_fHltvReplayEnd");
}
void GCBasePlayerPawn::SetHltvReplayEnd(float value) {
    SetSchemaValue(m_ptr, "CBasePlayerPawn", "m_fHltvReplayEnd", false, value);
}
CEntityIndex GCBasePlayerPawn::GetHltvReplayEntity() const {
    return GetSchemaValue<CEntityIndex>(m_ptr, "CBasePlayerPawn", "m_iHltvReplayEntity");
}
void GCBasePlayerPawn::SetHltvReplayEntity(CEntityIndex value) {
    SetSchemaValue(m_ptr, "CBasePlayerPawn", "m_iHltvReplayEntity", false, value);
}
std::vector<Gsndopvarlatchdata_t> GCBasePlayerPawn::GetSndOpvarLatchData() const {
    CUtlVector<Gsndopvarlatchdata_t>* vec = GetSchemaValue<CUtlVector<Gsndopvarlatchdata_t>*>(m_ptr, "CBasePlayerPawn", "m_sndOpvarLatchData"); std::vector<Gsndopvarlatchdata_t> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCBasePlayerPawn::SetSndOpvarLatchData(std::vector<Gsndopvarlatchdata_t> value) {
    SetSchemaValueCUtlVector<Gsndopvarlatchdata_t>(m_ptr, "CBasePlayerPawn", "m_sndOpvarLatchData", false, value);
}
std::string GCBasePlayerPawn::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCBasePlayerPawn::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseCombatCharacter GCBasePlayerPawn::GetParent() const {
    GCBaseCombatCharacter value(m_ptr);
    return value;
}
void GCBasePlayerPawn::SetParent(GCBaseCombatCharacter value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCBasePlayerPawn(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCBasePlayerPawn>("CBasePlayerPawn")
        .addConstructor<void (*)(std::string)>()
        .addProperty("WeaponServices", &GCBasePlayerPawn::GetWeaponServices, &GCBasePlayerPawn::SetWeaponServices)
        .addProperty("ItemServices", &GCBasePlayerPawn::GetItemServices, &GCBasePlayerPawn::SetItemServices)
        .addProperty("AutoaimServices", &GCBasePlayerPawn::GetAutoaimServices, &GCBasePlayerPawn::SetAutoaimServices)
        .addProperty("ObserverServices", &GCBasePlayerPawn::GetObserverServices, &GCBasePlayerPawn::SetObserverServices)
        .addProperty("WaterServices", &GCBasePlayerPawn::GetWaterServices, &GCBasePlayerPawn::SetWaterServices)
        .addProperty("UseServices", &GCBasePlayerPawn::GetUseServices, &GCBasePlayerPawn::SetUseServices)
        .addProperty("FlashlightServices", &GCBasePlayerPawn::GetFlashlightServices, &GCBasePlayerPawn::SetFlashlightServices)
        .addProperty("CameraServices", &GCBasePlayerPawn::GetCameraServices, &GCBasePlayerPawn::SetCameraServices)
        .addProperty("MovementServices", &GCBasePlayerPawn::GetMovementServices, &GCBasePlayerPawn::SetMovementServices)
        .addProperty("ServerViewAngleChanges", &GCBasePlayerPawn::GetServerViewAngleChanges, &GCBasePlayerPawn::SetServerViewAngleChanges)
        .addProperty("HighestGeneratedServerViewAngleChangeIndex", &GCBasePlayerPawn::GetHighestGeneratedServerViewAngleChangeIndex, &GCBasePlayerPawn::SetHighestGeneratedServerViewAngleChangeIndex)
        .addProperty("_angle", &GCBasePlayerPawn::Get_angle, &GCBasePlayerPawn::Set_angle)
        .addProperty("_anglePrevious", &GCBasePlayerPawn::Get_anglePrevious, &GCBasePlayerPawn::Set_anglePrevious)
        .addProperty("HideHUD", &GCBasePlayerPawn::GetHideHUD, &GCBasePlayerPawn::SetHideHUD)
        .addProperty("Skybox3d", &GCBasePlayerPawn::GetSkybox3d, &GCBasePlayerPawn::SetSkybox3d)
        .addProperty("TimeLastHurt", &GCBasePlayerPawn::GetTimeLastHurt, &GCBasePlayerPawn::SetTimeLastHurt)
        .addProperty("DeathTime", &GCBasePlayerPawn::GetDeathTime, &GCBasePlayerPawn::SetDeathTime)
        .addProperty("NextSuicideTime", &GCBasePlayerPawn::GetNextSuicideTime, &GCBasePlayerPawn::SetNextSuicideTime)
        .addProperty("InitHUD", &GCBasePlayerPawn::GetInitHUD, &GCBasePlayerPawn::SetInitHUD)
        .addProperty("Expresser", &GCBasePlayerPawn::GetExpresser, &GCBasePlayerPawn::SetExpresser)
        .addProperty("Controller", &GCBasePlayerPawn::GetController, &GCBasePlayerPawn::SetController)
        .addProperty("HltvReplayDelay", &GCBasePlayerPawn::GetHltvReplayDelay, &GCBasePlayerPawn::SetHltvReplayDelay)
        .addProperty("HltvReplayEnd", &GCBasePlayerPawn::GetHltvReplayEnd, &GCBasePlayerPawn::SetHltvReplayEnd)
        .addProperty("HltvReplayEntity", &GCBasePlayerPawn::GetHltvReplayEntity, &GCBasePlayerPawn::SetHltvReplayEntity)
        .addProperty("SndOpvarLatchData", &GCBasePlayerPawn::GetSndOpvarLatchData, &GCBasePlayerPawn::SetSndOpvarLatchData)
        .addProperty("Parent", &GCBasePlayerPawn::GetParent, &GCBasePlayerPawn::SetParent)
        .addFunction("ToPtr", &GCBasePlayerPawn::ToPtr)
        .addFunction("IsValid", &GCBasePlayerPawn::IsValid)
        .endClass();
}
GCGameMoney::GCGameMoney(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCGameMoney::GCGameMoney(void *ptr) {
    m_ptr = ptr;
}
GCEntityIOOutput GCGameMoney::GetOnMoneySpent() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CGameMoney", "m_OnMoneySpent"));
    return value;
}
void GCGameMoney::SetOnMoneySpent(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CGameMoney", "m_OnMoneySpent", false, value);
}
GCEntityIOOutput GCGameMoney::GetOnMoneySpentFail() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CGameMoney", "m_OnMoneySpentFail"));
    return value;
}
void GCGameMoney::SetOnMoneySpentFail(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CGameMoney", "m_OnMoneySpentFail", false, value);
}
int32_t GCGameMoney::GetMoney() const {
    return GetSchemaValue<int32_t>(m_ptr, "CGameMoney", "m_nMoney");
}
void GCGameMoney::SetMoney(int32_t value) {
    SetSchemaValue(m_ptr, "CGameMoney", "m_nMoney", false, value);
}
std::string GCGameMoney::GetStrAwardText() const {
    return GetSchemaValue<CUtlString>(m_ptr, "CGameMoney", "m_strAwardText").Get();
}
void GCGameMoney::SetStrAwardText(std::string value) {
    SetSchemaValue(m_ptr, "CGameMoney", "m_strAwardText", false, CUtlString(value.c_str()));
}
std::string GCGameMoney::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCGameMoney::IsValid() {
    return (m_ptr != nullptr);
}
GCRulePointEntity GCGameMoney::GetParent() const {
    GCRulePointEntity value(m_ptr);
    return value;
}
void GCGameMoney::SetParent(GCRulePointEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCGameMoney(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCGameMoney>("CGameMoney")
        .addConstructor<void (*)(std::string)>()
        .addProperty("OnMoneySpent", &GCGameMoney::GetOnMoneySpent, &GCGameMoney::SetOnMoneySpent)
        .addProperty("OnMoneySpentFail", &GCGameMoney::GetOnMoneySpentFail, &GCGameMoney::SetOnMoneySpentFail)
        .addProperty("Money", &GCGameMoney::GetMoney, &GCGameMoney::SetMoney)
        .addProperty("StrAwardText", &GCGameMoney::GetStrAwardText, &GCGameMoney::SetStrAwardText)
        .addProperty("Parent", &GCGameMoney::GetParent, &GCGameMoney::SetParent)
        .addFunction("ToPtr", &GCGameMoney::ToPtr)
        .addFunction("IsValid", &GCGameMoney::IsValid)
        .endClass();
}
GCLogicPlayerProxy::GCLogicPlayerProxy(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCLogicPlayerProxy::GCLogicPlayerProxy(void *ptr) {
    m_ptr = ptr;
}
GCBaseEntity GCLogicPlayerProxy::GetPlayer() const {
    GCBaseEntity value(*GetSchemaValuePtr<void*>(m_ptr, "CLogicPlayerProxy", "m_hPlayer"));
    return value;
}
void GCLogicPlayerProxy::SetPlayer(GCBaseEntity* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Player' is not possible.\n");
}
GCEntityIOOutput GCLogicPlayerProxy::GetPlayerHasAmmo() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CLogicPlayerProxy", "m_PlayerHasAmmo"));
    return value;
}
void GCLogicPlayerProxy::SetPlayerHasAmmo(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CLogicPlayerProxy", "m_PlayerHasAmmo", false, value);
}
GCEntityIOOutput GCLogicPlayerProxy::GetPlayerHasNoAmmo() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CLogicPlayerProxy", "m_PlayerHasNoAmmo"));
    return value;
}
void GCLogicPlayerProxy::SetPlayerHasNoAmmo(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CLogicPlayerProxy", "m_PlayerHasNoAmmo", false, value);
}
GCEntityIOOutput GCLogicPlayerProxy::GetPlayerDied() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CLogicPlayerProxy", "m_PlayerDied"));
    return value;
}
void GCLogicPlayerProxy::SetPlayerDied(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CLogicPlayerProxy", "m_PlayerDied", false, value);
}
std::string GCLogicPlayerProxy::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCLogicPlayerProxy::IsValid() {
    return (m_ptr != nullptr);
}
GCLogicalEntity GCLogicPlayerProxy::GetParent() const {
    GCLogicalEntity value(m_ptr);
    return value;
}
void GCLogicPlayerProxy::SetParent(GCLogicalEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCLogicPlayerProxy(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCLogicPlayerProxy>("CLogicPlayerProxy")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Player", &GCLogicPlayerProxy::GetPlayer, &GCLogicPlayerProxy::SetPlayer)
        .addProperty("PlayerHasAmmo", &GCLogicPlayerProxy::GetPlayerHasAmmo, &GCLogicPlayerProxy::SetPlayerHasAmmo)
        .addProperty("PlayerHasNoAmmo", &GCLogicPlayerProxy::GetPlayerHasNoAmmo, &GCLogicPlayerProxy::SetPlayerHasNoAmmo)
        .addProperty("PlayerDied", &GCLogicPlayerProxy::GetPlayerDied, &GCLogicPlayerProxy::SetPlayerDied)
        .addProperty("Parent", &GCLogicPlayerProxy::GetParent, &GCLogicPlayerProxy::SetParent)
        .addFunction("ToPtr", &GCLogicPlayerProxy::ToPtr)
        .addFunction("IsValid", &GCLogicPlayerProxy::IsValid)
        .endClass();
}
GCPlayer_ObserverServices::GCPlayer_ObserverServices(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCPlayer_ObserverServices::GCPlayer_ObserverServices(void *ptr) {
    m_ptr = ptr;
}
uint8_t GCPlayer_ObserverServices::GetObserverMode() const {
    return GetSchemaValue<uint8_t>(m_ptr, "CPlayer_ObserverServices", "m_iObserverMode");
}
void GCPlayer_ObserverServices::SetObserverMode(uint8_t value) {
    SetSchemaValue(m_ptr, "CPlayer_ObserverServices", "m_iObserverMode", false, value);
}
GCBaseEntity GCPlayer_ObserverServices::GetObserverTarget() const {
    GCBaseEntity value(*GetSchemaValuePtr<void*>(m_ptr, "CPlayer_ObserverServices", "m_hObserverTarget"));
    return value;
}
void GCPlayer_ObserverServices::SetObserverTarget(GCBaseEntity* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'ObserverTarget' is not possible.\n");
}
uint64_t GCPlayer_ObserverServices::GetObserverLastMode() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CPlayer_ObserverServices", "m_iObserverLastMode");
}
void GCPlayer_ObserverServices::SetObserverLastMode(uint64_t value) {
    SetSchemaValue(m_ptr, "CPlayer_ObserverServices", "m_iObserverLastMode", false, value);
}
bool GCPlayer_ObserverServices::GetForcedObserverMode() const {
    return GetSchemaValue<bool>(m_ptr, "CPlayer_ObserverServices", "m_bForcedObserverMode");
}
void GCPlayer_ObserverServices::SetForcedObserverMode(bool value) {
    SetSchemaValue(m_ptr, "CPlayer_ObserverServices", "m_bForcedObserverMode", false, value);
}
std::string GCPlayer_ObserverServices::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCPlayer_ObserverServices::IsValid() {
    return (m_ptr != nullptr);
}
GCPlayerPawnComponent GCPlayer_ObserverServices::GetParent() const {
    GCPlayerPawnComponent value(m_ptr);
    return value;
}
void GCPlayer_ObserverServices::SetParent(GCPlayerPawnComponent value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCPlayer_ObserverServices(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCPlayer_ObserverServices>("CPlayer_ObserverServices")
        .addConstructor<void (*)(std::string)>()
        .addProperty("ObserverMode", &GCPlayer_ObserverServices::GetObserverMode, &GCPlayer_ObserverServices::SetObserverMode)
        .addProperty("ObserverTarget", &GCPlayer_ObserverServices::GetObserverTarget, &GCPlayer_ObserverServices::SetObserverTarget)
        .addProperty("ObserverLastMode", &GCPlayer_ObserverServices::GetObserverLastMode, &GCPlayer_ObserverServices::SetObserverLastMode)
        .addProperty("ForcedObserverMode", &GCPlayer_ObserverServices::GetForcedObserverMode, &GCPlayer_ObserverServices::SetForcedObserverMode)
        .addProperty("Parent", &GCPlayer_ObserverServices::GetParent, &GCPlayer_ObserverServices::SetParent)
        .addFunction("ToPtr", &GCPlayer_ObserverServices::ToPtr)
        .addFunction("IsValid", &GCPlayer_ObserverServices::IsValid)
        .endClass();
}
GCWeaponZoneRepulsor::GCWeaponZoneRepulsor(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCWeaponZoneRepulsor::GCWeaponZoneRepulsor(void *ptr) {
    m_ptr = ptr;
}
std::string GCWeaponZoneRepulsor::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCWeaponZoneRepulsor::IsValid() {
    return (m_ptr != nullptr);
}
GCCSWeaponBaseGun GCWeaponZoneRepulsor::GetParent() const {
    GCCSWeaponBaseGun value(m_ptr);
    return value;
}
void GCWeaponZoneRepulsor::SetParent(GCCSWeaponBaseGun value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCWeaponZoneRepulsor(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCWeaponZoneRepulsor>("CWeaponZoneRepulsor")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCWeaponZoneRepulsor::GetParent, &GCWeaponZoneRepulsor::SetParent)
        .addFunction("ToPtr", &GCWeaponZoneRepulsor::ToPtr)
        .addFunction("IsValid", &GCWeaponZoneRepulsor::IsValid)
        .endClass();
}
GCPhysImpact::GCPhysImpact(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCPhysImpact::GCPhysImpact(void *ptr) {
    m_ptr = ptr;
}
float GCPhysImpact::GetDamage() const {
    return GetSchemaValue<float>(m_ptr, "CPhysImpact", "m_damage");
}
void GCPhysImpact::SetDamage(float value) {
    SetSchemaValue(m_ptr, "CPhysImpact", "m_damage", false, value);
}
float GCPhysImpact::GetDistance() const {
    return GetSchemaValue<float>(m_ptr, "CPhysImpact", "m_distance");
}
void GCPhysImpact::SetDistance(float value) {
    SetSchemaValue(m_ptr, "CPhysImpact", "m_distance", false, value);
}
std::string GCPhysImpact::GetDirectionEntityName() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CPhysImpact", "m_directionEntityName").String();
}
void GCPhysImpact::SetDirectionEntityName(std::string value) {
    SetSchemaValue(m_ptr, "CPhysImpact", "m_directionEntityName", false, CUtlSymbolLarge(value.c_str()));
}
std::string GCPhysImpact::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCPhysImpact::IsValid() {
    return (m_ptr != nullptr);
}
GCPointEntity GCPhysImpact::GetParent() const {
    GCPointEntity value(m_ptr);
    return value;
}
void GCPhysImpact::SetParent(GCPointEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCPhysImpact(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCPhysImpact>("CPhysImpact")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Damage", &GCPhysImpact::GetDamage, &GCPhysImpact::SetDamage)
        .addProperty("Distance", &GCPhysImpact::GetDistance, &GCPhysImpact::SetDistance)
        .addProperty("DirectionEntityName", &GCPhysImpact::GetDirectionEntityName, &GCPhysImpact::SetDirectionEntityName)
        .addProperty("Parent", &GCPhysImpact::GetParent, &GCPhysImpact::SetParent)
        .addFunction("ToPtr", &GCPhysImpact::ToPtr)
        .addFunction("IsValid", &GCPhysImpact::IsValid)
        .endClass();
}
GCEnvCombinedLightProbeVolume::GCEnvCombinedLightProbeVolume(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCEnvCombinedLightProbeVolume::GCEnvCombinedLightProbeVolume(void *ptr) {
    m_ptr = ptr;
}
Color GCEnvCombinedLightProbeVolume::GetEntity_Color() const {
    return GetSchemaValue<Color>(m_ptr, "CEnvCombinedLightProbeVolume", "m_Entity_Color");
}
void GCEnvCombinedLightProbeVolume::SetEntity_Color(Color value) {
    SetSchemaValue(m_ptr, "CEnvCombinedLightProbeVolume", "m_Entity_Color", false, value);
}
float GCEnvCombinedLightProbeVolume::GetEntity_flBrightness() const {
    return GetSchemaValue<float>(m_ptr, "CEnvCombinedLightProbeVolume", "m_Entity_flBrightness");
}
void GCEnvCombinedLightProbeVolume::SetEntity_flBrightness(float value) {
    SetSchemaValue(m_ptr, "CEnvCombinedLightProbeVolume", "m_Entity_flBrightness", false, value);
}
bool GCEnvCombinedLightProbeVolume::GetEntity_bCustomCubemapTexture() const {
    return GetSchemaValue<bool>(m_ptr, "CEnvCombinedLightProbeVolume", "m_Entity_bCustomCubemapTexture");
}
void GCEnvCombinedLightProbeVolume::SetEntity_bCustomCubemapTexture(bool value) {
    SetSchemaValue(m_ptr, "CEnvCombinedLightProbeVolume", "m_Entity_bCustomCubemapTexture", false, value);
}
Vector GCEnvCombinedLightProbeVolume::GetEntity_vBoxMins() const {
    return GetSchemaValue<Vector>(m_ptr, "CEnvCombinedLightProbeVolume", "m_Entity_vBoxMins");
}
void GCEnvCombinedLightProbeVolume::SetEntity_vBoxMins(Vector value) {
    SetSchemaValue(m_ptr, "CEnvCombinedLightProbeVolume", "m_Entity_vBoxMins", false, value);
}
Vector GCEnvCombinedLightProbeVolume::GetEntity_vBoxMaxs() const {
    return GetSchemaValue<Vector>(m_ptr, "CEnvCombinedLightProbeVolume", "m_Entity_vBoxMaxs");
}
void GCEnvCombinedLightProbeVolume::SetEntity_vBoxMaxs(Vector value) {
    SetSchemaValue(m_ptr, "CEnvCombinedLightProbeVolume", "m_Entity_vBoxMaxs", false, value);
}
bool GCEnvCombinedLightProbeVolume::GetEntity_bMoveable() const {
    return GetSchemaValue<bool>(m_ptr, "CEnvCombinedLightProbeVolume", "m_Entity_bMoveable");
}
void GCEnvCombinedLightProbeVolume::SetEntity_bMoveable(bool value) {
    SetSchemaValue(m_ptr, "CEnvCombinedLightProbeVolume", "m_Entity_bMoveable", false, value);
}
int32_t GCEnvCombinedLightProbeVolume::GetEntity_nHandshake() const {
    return GetSchemaValue<int32_t>(m_ptr, "CEnvCombinedLightProbeVolume", "m_Entity_nHandshake");
}
void GCEnvCombinedLightProbeVolume::SetEntity_nHandshake(int32_t value) {
    SetSchemaValue(m_ptr, "CEnvCombinedLightProbeVolume", "m_Entity_nHandshake", false, value);
}
int32_t GCEnvCombinedLightProbeVolume::GetEntity_nEnvCubeMapArrayIndex() const {
    return GetSchemaValue<int32_t>(m_ptr, "CEnvCombinedLightProbeVolume", "m_Entity_nEnvCubeMapArrayIndex");
}
void GCEnvCombinedLightProbeVolume::SetEntity_nEnvCubeMapArrayIndex(int32_t value) {
    SetSchemaValue(m_ptr, "CEnvCombinedLightProbeVolume", "m_Entity_nEnvCubeMapArrayIndex", false, value);
}
int32_t GCEnvCombinedLightProbeVolume::GetEntity_nPriority() const {
    return GetSchemaValue<int32_t>(m_ptr, "CEnvCombinedLightProbeVolume", "m_Entity_nPriority");
}
void GCEnvCombinedLightProbeVolume::SetEntity_nPriority(int32_t value) {
    SetSchemaValue(m_ptr, "CEnvCombinedLightProbeVolume", "m_Entity_nPriority", false, value);
}
bool GCEnvCombinedLightProbeVolume::GetEntity_bStartDisabled() const {
    return GetSchemaValue<bool>(m_ptr, "CEnvCombinedLightProbeVolume", "m_Entity_bStartDisabled");
}
void GCEnvCombinedLightProbeVolume::SetEntity_bStartDisabled(bool value) {
    SetSchemaValue(m_ptr, "CEnvCombinedLightProbeVolume", "m_Entity_bStartDisabled", false, value);
}
float GCEnvCombinedLightProbeVolume::GetEntity_flEdgeFadeDist() const {
    return GetSchemaValue<float>(m_ptr, "CEnvCombinedLightProbeVolume", "m_Entity_flEdgeFadeDist");
}
void GCEnvCombinedLightProbeVolume::SetEntity_flEdgeFadeDist(float value) {
    SetSchemaValue(m_ptr, "CEnvCombinedLightProbeVolume", "m_Entity_flEdgeFadeDist", false, value);
}
Vector GCEnvCombinedLightProbeVolume::GetEntity_vEdgeFadeDists() const {
    return GetSchemaValue<Vector>(m_ptr, "CEnvCombinedLightProbeVolume", "m_Entity_vEdgeFadeDists");
}
void GCEnvCombinedLightProbeVolume::SetEntity_vEdgeFadeDists(Vector value) {
    SetSchemaValue(m_ptr, "CEnvCombinedLightProbeVolume", "m_Entity_vEdgeFadeDists", false, value);
}
int32_t GCEnvCombinedLightProbeVolume::GetEntity_nLightProbeSizeX() const {
    return GetSchemaValue<int32_t>(m_ptr, "CEnvCombinedLightProbeVolume", "m_Entity_nLightProbeSizeX");
}
void GCEnvCombinedLightProbeVolume::SetEntity_nLightProbeSizeX(int32_t value) {
    SetSchemaValue(m_ptr, "CEnvCombinedLightProbeVolume", "m_Entity_nLightProbeSizeX", false, value);
}
int32_t GCEnvCombinedLightProbeVolume::GetEntity_nLightProbeSizeY() const {
    return GetSchemaValue<int32_t>(m_ptr, "CEnvCombinedLightProbeVolume", "m_Entity_nLightProbeSizeY");
}
void GCEnvCombinedLightProbeVolume::SetEntity_nLightProbeSizeY(int32_t value) {
    SetSchemaValue(m_ptr, "CEnvCombinedLightProbeVolume", "m_Entity_nLightProbeSizeY", false, value);
}
int32_t GCEnvCombinedLightProbeVolume::GetEntity_nLightProbeSizeZ() const {
    return GetSchemaValue<int32_t>(m_ptr, "CEnvCombinedLightProbeVolume", "m_Entity_nLightProbeSizeZ");
}
void GCEnvCombinedLightProbeVolume::SetEntity_nLightProbeSizeZ(int32_t value) {
    SetSchemaValue(m_ptr, "CEnvCombinedLightProbeVolume", "m_Entity_nLightProbeSizeZ", false, value);
}
int32_t GCEnvCombinedLightProbeVolume::GetEntity_nLightProbeAtlasX() const {
    return GetSchemaValue<int32_t>(m_ptr, "CEnvCombinedLightProbeVolume", "m_Entity_nLightProbeAtlasX");
}
void GCEnvCombinedLightProbeVolume::SetEntity_nLightProbeAtlasX(int32_t value) {
    SetSchemaValue(m_ptr, "CEnvCombinedLightProbeVolume", "m_Entity_nLightProbeAtlasX", false, value);
}
int32_t GCEnvCombinedLightProbeVolume::GetEntity_nLightProbeAtlasY() const {
    return GetSchemaValue<int32_t>(m_ptr, "CEnvCombinedLightProbeVolume", "m_Entity_nLightProbeAtlasY");
}
void GCEnvCombinedLightProbeVolume::SetEntity_nLightProbeAtlasY(int32_t value) {
    SetSchemaValue(m_ptr, "CEnvCombinedLightProbeVolume", "m_Entity_nLightProbeAtlasY", false, value);
}
int32_t GCEnvCombinedLightProbeVolume::GetEntity_nLightProbeAtlasZ() const {
    return GetSchemaValue<int32_t>(m_ptr, "CEnvCombinedLightProbeVolume", "m_Entity_nLightProbeAtlasZ");
}
void GCEnvCombinedLightProbeVolume::SetEntity_nLightProbeAtlasZ(int32_t value) {
    SetSchemaValue(m_ptr, "CEnvCombinedLightProbeVolume", "m_Entity_nLightProbeAtlasZ", false, value);
}
bool GCEnvCombinedLightProbeVolume::GetEntity_bEnabled() const {
    return GetSchemaValue<bool>(m_ptr, "CEnvCombinedLightProbeVolume", "m_Entity_bEnabled");
}
void GCEnvCombinedLightProbeVolume::SetEntity_bEnabled(bool value) {
    SetSchemaValue(m_ptr, "CEnvCombinedLightProbeVolume", "m_Entity_bEnabled", false, value);
}
std::string GCEnvCombinedLightProbeVolume::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCEnvCombinedLightProbeVolume::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseEntity GCEnvCombinedLightProbeVolume::GetParent() const {
    GCBaseEntity value(m_ptr);
    return value;
}
void GCEnvCombinedLightProbeVolume::SetParent(GCBaseEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCEnvCombinedLightProbeVolume(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCEnvCombinedLightProbeVolume>("CEnvCombinedLightProbeVolume")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Entity_Color", &GCEnvCombinedLightProbeVolume::GetEntity_Color, &GCEnvCombinedLightProbeVolume::SetEntity_Color)
        .addProperty("Entity_flBrightness", &GCEnvCombinedLightProbeVolume::GetEntity_flBrightness, &GCEnvCombinedLightProbeVolume::SetEntity_flBrightness)
        .addProperty("Entity_bCustomCubemapTexture", &GCEnvCombinedLightProbeVolume::GetEntity_bCustomCubemapTexture, &GCEnvCombinedLightProbeVolume::SetEntity_bCustomCubemapTexture)
        .addProperty("Entity_vBoxMins", &GCEnvCombinedLightProbeVolume::GetEntity_vBoxMins, &GCEnvCombinedLightProbeVolume::SetEntity_vBoxMins)
        .addProperty("Entity_vBoxMaxs", &GCEnvCombinedLightProbeVolume::GetEntity_vBoxMaxs, &GCEnvCombinedLightProbeVolume::SetEntity_vBoxMaxs)
        .addProperty("Entity_bMoveable", &GCEnvCombinedLightProbeVolume::GetEntity_bMoveable, &GCEnvCombinedLightProbeVolume::SetEntity_bMoveable)
        .addProperty("Entity_nHandshake", &GCEnvCombinedLightProbeVolume::GetEntity_nHandshake, &GCEnvCombinedLightProbeVolume::SetEntity_nHandshake)
        .addProperty("Entity_nEnvCubeMapArrayIndex", &GCEnvCombinedLightProbeVolume::GetEntity_nEnvCubeMapArrayIndex, &GCEnvCombinedLightProbeVolume::SetEntity_nEnvCubeMapArrayIndex)
        .addProperty("Entity_nPriority", &GCEnvCombinedLightProbeVolume::GetEntity_nPriority, &GCEnvCombinedLightProbeVolume::SetEntity_nPriority)
        .addProperty("Entity_bStartDisabled", &GCEnvCombinedLightProbeVolume::GetEntity_bStartDisabled, &GCEnvCombinedLightProbeVolume::SetEntity_bStartDisabled)
        .addProperty("Entity_flEdgeFadeDist", &GCEnvCombinedLightProbeVolume::GetEntity_flEdgeFadeDist, &GCEnvCombinedLightProbeVolume::SetEntity_flEdgeFadeDist)
        .addProperty("Entity_vEdgeFadeDists", &GCEnvCombinedLightProbeVolume::GetEntity_vEdgeFadeDists, &GCEnvCombinedLightProbeVolume::SetEntity_vEdgeFadeDists)
        .addProperty("Entity_nLightProbeSizeX", &GCEnvCombinedLightProbeVolume::GetEntity_nLightProbeSizeX, &GCEnvCombinedLightProbeVolume::SetEntity_nLightProbeSizeX)
        .addProperty("Entity_nLightProbeSizeY", &GCEnvCombinedLightProbeVolume::GetEntity_nLightProbeSizeY, &GCEnvCombinedLightProbeVolume::SetEntity_nLightProbeSizeY)
        .addProperty("Entity_nLightProbeSizeZ", &GCEnvCombinedLightProbeVolume::GetEntity_nLightProbeSizeZ, &GCEnvCombinedLightProbeVolume::SetEntity_nLightProbeSizeZ)
        .addProperty("Entity_nLightProbeAtlasX", &GCEnvCombinedLightProbeVolume::GetEntity_nLightProbeAtlasX, &GCEnvCombinedLightProbeVolume::SetEntity_nLightProbeAtlasX)
        .addProperty("Entity_nLightProbeAtlasY", &GCEnvCombinedLightProbeVolume::GetEntity_nLightProbeAtlasY, &GCEnvCombinedLightProbeVolume::SetEntity_nLightProbeAtlasY)
        .addProperty("Entity_nLightProbeAtlasZ", &GCEnvCombinedLightProbeVolume::GetEntity_nLightProbeAtlasZ, &GCEnvCombinedLightProbeVolume::SetEntity_nLightProbeAtlasZ)
        .addProperty("Entity_bEnabled", &GCEnvCombinedLightProbeVolume::GetEntity_bEnabled, &GCEnvCombinedLightProbeVolume::SetEntity_bEnabled)
        .addProperty("Parent", &GCEnvCombinedLightProbeVolume::GetParent, &GCEnvCombinedLightProbeVolume::SetParent)
        .addFunction("ToPtr", &GCEnvCombinedLightProbeVolume::ToPtr)
        .addFunction("IsValid", &GCEnvCombinedLightProbeVolume::IsValid)
        .endClass();
}
GCCSPlayer_WaterServices::GCCSPlayer_WaterServices(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCCSPlayer_WaterServices::GCCSPlayer_WaterServices(void *ptr) {
    m_ptr = ptr;
}
float GCCSPlayer_WaterServices::GetNextDrownDamageTime() const {
    return GetSchemaValue<float>(m_ptr, "CCSPlayer_WaterServices", "m_NextDrownDamageTime");
}
void GCCSPlayer_WaterServices::SetNextDrownDamageTime(float value) {
    SetSchemaValue(m_ptr, "CCSPlayer_WaterServices", "m_NextDrownDamageTime", false, value);
}
int32_t GCCSPlayer_WaterServices::GetDrownDmgRate() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSPlayer_WaterServices", "m_nDrownDmgRate");
}
void GCCSPlayer_WaterServices::SetDrownDmgRate(int32_t value) {
    SetSchemaValue(m_ptr, "CCSPlayer_WaterServices", "m_nDrownDmgRate", false, value);
}
float GCCSPlayer_WaterServices::GetAirFinishedTime() const {
    return GetSchemaValue<float>(m_ptr, "CCSPlayer_WaterServices", "m_AirFinishedTime");
}
void GCCSPlayer_WaterServices::SetAirFinishedTime(float value) {
    SetSchemaValue(m_ptr, "CCSPlayer_WaterServices", "m_AirFinishedTime", false, value);
}
float GCCSPlayer_WaterServices::GetWaterJumpTime() const {
    return GetSchemaValue<float>(m_ptr, "CCSPlayer_WaterServices", "m_flWaterJumpTime");
}
void GCCSPlayer_WaterServices::SetWaterJumpTime(float value) {
    SetSchemaValue(m_ptr, "CCSPlayer_WaterServices", "m_flWaterJumpTime", false, value);
}
Vector GCCSPlayer_WaterServices::GetWaterJumpVel() const {
    return GetSchemaValue<Vector>(m_ptr, "CCSPlayer_WaterServices", "m_vecWaterJumpVel");
}
void GCCSPlayer_WaterServices::SetWaterJumpVel(Vector value) {
    SetSchemaValue(m_ptr, "CCSPlayer_WaterServices", "m_vecWaterJumpVel", false, value);
}
float GCCSPlayer_WaterServices::GetSwimSoundTime() const {
    return GetSchemaValue<float>(m_ptr, "CCSPlayer_WaterServices", "m_flSwimSoundTime");
}
void GCCSPlayer_WaterServices::SetSwimSoundTime(float value) {
    SetSchemaValue(m_ptr, "CCSPlayer_WaterServices", "m_flSwimSoundTime", false, value);
}
std::string GCCSPlayer_WaterServices::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCCSPlayer_WaterServices::IsValid() {
    return (m_ptr != nullptr);
}
GCPlayer_WaterServices GCCSPlayer_WaterServices::GetParent() const {
    GCPlayer_WaterServices value(m_ptr);
    return value;
}
void GCCSPlayer_WaterServices::SetParent(GCPlayer_WaterServices value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCCSPlayer_WaterServices(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCCSPlayer_WaterServices>("CCSPlayer_WaterServices")
        .addConstructor<void (*)(std::string)>()
        .addProperty("NextDrownDamageTime", &GCCSPlayer_WaterServices::GetNextDrownDamageTime, &GCCSPlayer_WaterServices::SetNextDrownDamageTime)
        .addProperty("DrownDmgRate", &GCCSPlayer_WaterServices::GetDrownDmgRate, &GCCSPlayer_WaterServices::SetDrownDmgRate)
        .addProperty("AirFinishedTime", &GCCSPlayer_WaterServices::GetAirFinishedTime, &GCCSPlayer_WaterServices::SetAirFinishedTime)
        .addProperty("WaterJumpTime", &GCCSPlayer_WaterServices::GetWaterJumpTime, &GCCSPlayer_WaterServices::SetWaterJumpTime)
        .addProperty("WaterJumpVel", &GCCSPlayer_WaterServices::GetWaterJumpVel, &GCCSPlayer_WaterServices::SetWaterJumpVel)
        .addProperty("SwimSoundTime", &GCCSPlayer_WaterServices::GetSwimSoundTime, &GCCSPlayer_WaterServices::SetSwimSoundTime)
        .addProperty("Parent", &GCCSPlayer_WaterServices::GetParent, &GCCSPlayer_WaterServices::SetParent)
        .addFunction("ToPtr", &GCCSPlayer_WaterServices::ToPtr)
        .addFunction("IsValid", &GCCSPlayer_WaterServices::IsValid)
        .endClass();
}
GCWeaponM249::GCWeaponM249(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCWeaponM249::GCWeaponM249(void *ptr) {
    m_ptr = ptr;
}
std::string GCWeaponM249::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCWeaponM249::IsValid() {
    return (m_ptr != nullptr);
}
GCCSWeaponBaseGun GCWeaponM249::GetParent() const {
    GCCSWeaponBaseGun value(m_ptr);
    return value;
}
void GCWeaponM249::SetParent(GCCSWeaponBaseGun value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCWeaponM249(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCWeaponM249>("CWeaponM249")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCWeaponM249::GetParent, &GCWeaponM249::SetParent)
        .addFunction("ToPtr", &GCWeaponM249::ToPtr)
        .addFunction("IsValid", &GCWeaponM249::IsValid)
        .endClass();
}
GCEnvParticleGlow::GCEnvParticleGlow(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCEnvParticleGlow::GCEnvParticleGlow(void *ptr) {
    m_ptr = ptr;
}
float GCEnvParticleGlow::GetAlphaScale() const {
    return GetSchemaValue<float>(m_ptr, "CEnvParticleGlow", "m_flAlphaScale");
}
void GCEnvParticleGlow::SetAlphaScale(float value) {
    SetSchemaValue(m_ptr, "CEnvParticleGlow", "m_flAlphaScale", false, value);
}
float GCEnvParticleGlow::GetRadiusScale() const {
    return GetSchemaValue<float>(m_ptr, "CEnvParticleGlow", "m_flRadiusScale");
}
void GCEnvParticleGlow::SetRadiusScale(float value) {
    SetSchemaValue(m_ptr, "CEnvParticleGlow", "m_flRadiusScale", false, value);
}
float GCEnvParticleGlow::GetSelfIllumScale() const {
    return GetSchemaValue<float>(m_ptr, "CEnvParticleGlow", "m_flSelfIllumScale");
}
void GCEnvParticleGlow::SetSelfIllumScale(float value) {
    SetSchemaValue(m_ptr, "CEnvParticleGlow", "m_flSelfIllumScale", false, value);
}
Color GCEnvParticleGlow::GetColorTint() const {
    return GetSchemaValue<Color>(m_ptr, "CEnvParticleGlow", "m_ColorTint");
}
void GCEnvParticleGlow::SetColorTint(Color value) {
    SetSchemaValue(m_ptr, "CEnvParticleGlow", "m_ColorTint", false, value);
}
std::string GCEnvParticleGlow::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCEnvParticleGlow::IsValid() {
    return (m_ptr != nullptr);
}
GCParticleSystem GCEnvParticleGlow::GetParent() const {
    GCParticleSystem value(m_ptr);
    return value;
}
void GCEnvParticleGlow::SetParent(GCParticleSystem value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCEnvParticleGlow(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCEnvParticleGlow>("CEnvParticleGlow")
        .addConstructor<void (*)(std::string)>()
        .addProperty("AlphaScale", &GCEnvParticleGlow::GetAlphaScale, &GCEnvParticleGlow::SetAlphaScale)
        .addProperty("RadiusScale", &GCEnvParticleGlow::GetRadiusScale, &GCEnvParticleGlow::SetRadiusScale)
        .addProperty("SelfIllumScale", &GCEnvParticleGlow::GetSelfIllumScale, &GCEnvParticleGlow::SetSelfIllumScale)
        .addProperty("ColorTint", &GCEnvParticleGlow::GetColorTint, &GCEnvParticleGlow::SetColorTint)
        .addProperty("Parent", &GCEnvParticleGlow::GetParent, &GCEnvParticleGlow::SetParent)
        .addFunction("ToPtr", &GCEnvParticleGlow::ToPtr)
        .addFunction("IsValid", &GCEnvParticleGlow::IsValid)
        .endClass();
}
GCFuncVehicleClip::GCFuncVehicleClip(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCFuncVehicleClip::GCFuncVehicleClip(void *ptr) {
    m_ptr = ptr;
}
std::string GCFuncVehicleClip::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCFuncVehicleClip::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseModelEntity GCFuncVehicleClip::GetParent() const {
    GCBaseModelEntity value(m_ptr);
    return value;
}
void GCFuncVehicleClip::SetParent(GCBaseModelEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCFuncVehicleClip(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCFuncVehicleClip>("CFuncVehicleClip")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCFuncVehicleClip::GetParent, &GCFuncVehicleClip::SetParent)
        .addFunction("ToPtr", &GCFuncVehicleClip::ToPtr)
        .addFunction("IsValid", &GCFuncVehicleClip::IsValid)
        .endClass();
}
GCSoundAreaEntityBase::GCSoundAreaEntityBase(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCSoundAreaEntityBase::GCSoundAreaEntityBase(void *ptr) {
    m_ptr = ptr;
}
bool GCSoundAreaEntityBase::GetDisabled() const {
    return GetSchemaValue<bool>(m_ptr, "CSoundAreaEntityBase", "m_bDisabled");
}
void GCSoundAreaEntityBase::SetDisabled(bool value) {
    SetSchemaValue(m_ptr, "CSoundAreaEntityBase", "m_bDisabled", false, value);
}
std::string GCSoundAreaEntityBase::GetSoundAreaType() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CSoundAreaEntityBase", "m_iszSoundAreaType").String();
}
void GCSoundAreaEntityBase::SetSoundAreaType(std::string value) {
    SetSchemaValue(m_ptr, "CSoundAreaEntityBase", "m_iszSoundAreaType", false, CUtlSymbolLarge(value.c_str()));
}
Vector GCSoundAreaEntityBase::GetPos() const {
    return GetSchemaValue<Vector>(m_ptr, "CSoundAreaEntityBase", "m_vPos");
}
void GCSoundAreaEntityBase::SetPos(Vector value) {
    SetSchemaValue(m_ptr, "CSoundAreaEntityBase", "m_vPos", false, value);
}
std::string GCSoundAreaEntityBase::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCSoundAreaEntityBase::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseEntity GCSoundAreaEntityBase::GetParent() const {
    GCBaseEntity value(m_ptr);
    return value;
}
void GCSoundAreaEntityBase::SetParent(GCBaseEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCSoundAreaEntityBase(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCSoundAreaEntityBase>("CSoundAreaEntityBase")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Disabled", &GCSoundAreaEntityBase::GetDisabled, &GCSoundAreaEntityBase::SetDisabled)
        .addProperty("SoundAreaType", &GCSoundAreaEntityBase::GetSoundAreaType, &GCSoundAreaEntityBase::SetSoundAreaType)
        .addProperty("Pos", &GCSoundAreaEntityBase::GetPos, &GCSoundAreaEntityBase::SetPos)
        .addProperty("Parent", &GCSoundAreaEntityBase::GetParent, &GCSoundAreaEntityBase::SetParent)
        .addFunction("ToPtr", &GCSoundAreaEntityBase::ToPtr)
        .addFunction("IsValid", &GCSoundAreaEntityBase::IsValid)
        .endClass();
}
GCFuncBrush::GCFuncBrush(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCFuncBrush::GCFuncBrush(void *ptr) {
    m_ptr = ptr;
}
uint64_t GCFuncBrush::GetSolidity() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CFuncBrush", "m_iSolidity");
}
void GCFuncBrush::SetSolidity(uint64_t value) {
    SetSchemaValue(m_ptr, "CFuncBrush", "m_iSolidity", false, value);
}
int32_t GCFuncBrush::GetDisabled() const {
    return GetSchemaValue<int32_t>(m_ptr, "CFuncBrush", "m_iDisabled");
}
void GCFuncBrush::SetDisabled(int32_t value) {
    SetSchemaValue(m_ptr, "CFuncBrush", "m_iDisabled", false, value);
}
bool GCFuncBrush::GetSolidBsp() const {
    return GetSchemaValue<bool>(m_ptr, "CFuncBrush", "m_bSolidBsp");
}
void GCFuncBrush::SetSolidBsp(bool value) {
    SetSchemaValue(m_ptr, "CFuncBrush", "m_bSolidBsp", false, value);
}
std::string GCFuncBrush::GetExcludedClass() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CFuncBrush", "m_iszExcludedClass").String();
}
void GCFuncBrush::SetExcludedClass(std::string value) {
    SetSchemaValue(m_ptr, "CFuncBrush", "m_iszExcludedClass", false, CUtlSymbolLarge(value.c_str()));
}
bool GCFuncBrush::GetInvertExclusion() const {
    return GetSchemaValue<bool>(m_ptr, "CFuncBrush", "m_bInvertExclusion");
}
void GCFuncBrush::SetInvertExclusion(bool value) {
    SetSchemaValue(m_ptr, "CFuncBrush", "m_bInvertExclusion", false, value);
}
bool GCFuncBrush::GetScriptedMovement() const {
    return GetSchemaValue<bool>(m_ptr, "CFuncBrush", "m_bScriptedMovement");
}
void GCFuncBrush::SetScriptedMovement(bool value) {
    SetSchemaValue(m_ptr, "CFuncBrush", "m_bScriptedMovement", false, value);
}
std::string GCFuncBrush::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCFuncBrush::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseModelEntity GCFuncBrush::GetParent() const {
    GCBaseModelEntity value(m_ptr);
    return value;
}
void GCFuncBrush::SetParent(GCBaseModelEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCFuncBrush(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCFuncBrush>("CFuncBrush")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Solidity", &GCFuncBrush::GetSolidity, &GCFuncBrush::SetSolidity)
        .addProperty("Disabled", &GCFuncBrush::GetDisabled, &GCFuncBrush::SetDisabled)
        .addProperty("SolidBsp", &GCFuncBrush::GetSolidBsp, &GCFuncBrush::SetSolidBsp)
        .addProperty("ExcludedClass", &GCFuncBrush::GetExcludedClass, &GCFuncBrush::SetExcludedClass)
        .addProperty("InvertExclusion", &GCFuncBrush::GetInvertExclusion, &GCFuncBrush::SetInvertExclusion)
        .addProperty("ScriptedMovement", &GCFuncBrush::GetScriptedMovement, &GCFuncBrush::SetScriptedMovement)
        .addProperty("Parent", &GCFuncBrush::GetParent, &GCFuncBrush::SetParent)
        .addFunction("ToPtr", &GCFuncBrush::ToPtr)
        .addFunction("IsValid", &GCFuncBrush::IsValid)
        .endClass();
}
GCEnvFunnel::GCEnvFunnel(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCEnvFunnel::GCEnvFunnel(void *ptr) {
    m_ptr = ptr;
}
std::string GCEnvFunnel::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCEnvFunnel::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseEntity GCEnvFunnel::GetParent() const {
    GCBaseEntity value(m_ptr);
    return value;
}
void GCEnvFunnel::SetParent(GCBaseEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCEnvFunnel(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCEnvFunnel>("CEnvFunnel")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCEnvFunnel::GetParent, &GCEnvFunnel::SetParent)
        .addFunction("ToPtr", &GCEnvFunnel::ToPtr)
        .addFunction("IsValid", &GCEnvFunnel::IsValid)
        .endClass();
}
GSequenceHistory_t::GSequenceHistory_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GSequenceHistory_t::GSequenceHistory_t(void *ptr) {
    m_ptr = ptr;
}
float GSequenceHistory_t::GetSeqStartTime() const {
    return GetSchemaValue<float>(m_ptr, "SequenceHistory_t", "m_flSeqStartTime");
}
void GSequenceHistory_t::SetSeqStartTime(float value) {
    SetSchemaValue(m_ptr, "SequenceHistory_t", "m_flSeqStartTime", true, value);
}
float GSequenceHistory_t::GetSeqFixedCycle() const {
    return GetSchemaValue<float>(m_ptr, "SequenceHistory_t", "m_flSeqFixedCycle");
}
void GSequenceHistory_t::SetSeqFixedCycle(float value) {
    SetSchemaValue(m_ptr, "SequenceHistory_t", "m_flSeqFixedCycle", true, value);
}
uint64_t GSequenceHistory_t::GetSeqLoopMode() const {
    return GetSchemaValue<uint64_t>(m_ptr, "SequenceHistory_t", "m_nSeqLoopMode");
}
void GSequenceHistory_t::SetSeqLoopMode(uint64_t value) {
    SetSchemaValue(m_ptr, "SequenceHistory_t", "m_nSeqLoopMode", true, value);
}
float GSequenceHistory_t::GetPlaybackRate() const {
    return GetSchemaValue<float>(m_ptr, "SequenceHistory_t", "m_flPlaybackRate");
}
void GSequenceHistory_t::SetPlaybackRate(float value) {
    SetSchemaValue(m_ptr, "SequenceHistory_t", "m_flPlaybackRate", true, value);
}
float GSequenceHistory_t::GetCyclesPerSecond() const {
    return GetSchemaValue<float>(m_ptr, "SequenceHistory_t", "m_flCyclesPerSecond");
}
void GSequenceHistory_t::SetCyclesPerSecond(float value) {
    SetSchemaValue(m_ptr, "SequenceHistory_t", "m_flCyclesPerSecond", true, value);
}
std::string GSequenceHistory_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GSequenceHistory_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassSequenceHistory_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GSequenceHistory_t>("SequenceHistory_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("SeqStartTime", &GSequenceHistory_t::GetSeqStartTime, &GSequenceHistory_t::SetSeqStartTime)
        .addProperty("SeqFixedCycle", &GSequenceHistory_t::GetSeqFixedCycle, &GSequenceHistory_t::SetSeqFixedCycle)
        .addProperty("SeqLoopMode", &GSequenceHistory_t::GetSeqLoopMode, &GSequenceHistory_t::SetSeqLoopMode)
        .addProperty("PlaybackRate", &GSequenceHistory_t::GetPlaybackRate, &GSequenceHistory_t::SetPlaybackRate)
        .addProperty("CyclesPerSecond", &GSequenceHistory_t::GetCyclesPerSecond, &GSequenceHistory_t::SetCyclesPerSecond)
        .addFunction("ToPtr", &GSequenceHistory_t::ToPtr)
        .addFunction("IsValid", &GSequenceHistory_t::IsValid)
        .endClass();
}
GCCSGameModeRules_Noop::GCCSGameModeRules_Noop(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCCSGameModeRules_Noop::GCCSGameModeRules_Noop(void *ptr) {
    m_ptr = ptr;
}
std::string GCCSGameModeRules_Noop::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCCSGameModeRules_Noop::IsValid() {
    return (m_ptr != nullptr);
}
GCCSGameModeRules GCCSGameModeRules_Noop::GetParent() const {
    GCCSGameModeRules value(m_ptr);
    return value;
}
void GCCSGameModeRules_Noop::SetParent(GCCSGameModeRules value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCCSGameModeRules_Noop(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCCSGameModeRules_Noop>("CCSGameModeRules_Noop")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCCSGameModeRules_Noop::GetParent, &GCCSGameModeRules_Noop::SetParent)
        .addFunction("ToPtr", &GCCSGameModeRules_Noop::ToPtr)
        .addFunction("IsValid", &GCCSGameModeRules_Noop::IsValid)
        .endClass();
}
GCPointAngularVelocitySensor::GCPointAngularVelocitySensor(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCPointAngularVelocitySensor::GCPointAngularVelocitySensor(void *ptr) {
    m_ptr = ptr;
}
GCBaseEntity GCPointAngularVelocitySensor::GetTargetEntity() const {
    GCBaseEntity value(*GetSchemaValuePtr<void*>(m_ptr, "CPointAngularVelocitySensor", "m_hTargetEntity"));
    return value;
}
void GCPointAngularVelocitySensor::SetTargetEntity(GCBaseEntity* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'TargetEntity' is not possible.\n");
}
float GCPointAngularVelocitySensor::GetThreshold() const {
    return GetSchemaValue<float>(m_ptr, "CPointAngularVelocitySensor", "m_flThreshold");
}
void GCPointAngularVelocitySensor::SetThreshold(float value) {
    SetSchemaValue(m_ptr, "CPointAngularVelocitySensor", "m_flThreshold", false, value);
}
int32_t GCPointAngularVelocitySensor::GetLastCompareResult() const {
    return GetSchemaValue<int32_t>(m_ptr, "CPointAngularVelocitySensor", "m_nLastCompareResult");
}
void GCPointAngularVelocitySensor::SetLastCompareResult(int32_t value) {
    SetSchemaValue(m_ptr, "CPointAngularVelocitySensor", "m_nLastCompareResult", false, value);
}
int32_t GCPointAngularVelocitySensor::GetLastFireResult() const {
    return GetSchemaValue<int32_t>(m_ptr, "CPointAngularVelocitySensor", "m_nLastFireResult");
}
void GCPointAngularVelocitySensor::SetLastFireResult(int32_t value) {
    SetSchemaValue(m_ptr, "CPointAngularVelocitySensor", "m_nLastFireResult", false, value);
}
float GCPointAngularVelocitySensor::GetFireTime() const {
    return GetSchemaValue<float>(m_ptr, "CPointAngularVelocitySensor", "m_flFireTime");
}
void GCPointAngularVelocitySensor::SetFireTime(float value) {
    SetSchemaValue(m_ptr, "CPointAngularVelocitySensor", "m_flFireTime", false, value);
}
float GCPointAngularVelocitySensor::GetFireInterval() const {
    return GetSchemaValue<float>(m_ptr, "CPointAngularVelocitySensor", "m_flFireInterval");
}
void GCPointAngularVelocitySensor::SetFireInterval(float value) {
    SetSchemaValue(m_ptr, "CPointAngularVelocitySensor", "m_flFireInterval", false, value);
}
float GCPointAngularVelocitySensor::GetLastAngVelocity() const {
    return GetSchemaValue<float>(m_ptr, "CPointAngularVelocitySensor", "m_flLastAngVelocity");
}
void GCPointAngularVelocitySensor::SetLastAngVelocity(float value) {
    SetSchemaValue(m_ptr, "CPointAngularVelocitySensor", "m_flLastAngVelocity", false, value);
}
QAngle GCPointAngularVelocitySensor::GetLastOrientation() const {
    return GetSchemaValue<QAngle>(m_ptr, "CPointAngularVelocitySensor", "m_lastOrientation");
}
void GCPointAngularVelocitySensor::SetLastOrientation(QAngle value) {
    SetSchemaValue(m_ptr, "CPointAngularVelocitySensor", "m_lastOrientation", false, value);
}
Vector GCPointAngularVelocitySensor::GetAxis() const {
    return GetSchemaValue<Vector>(m_ptr, "CPointAngularVelocitySensor", "m_vecAxis");
}
void GCPointAngularVelocitySensor::SetAxis(Vector value) {
    SetSchemaValue(m_ptr, "CPointAngularVelocitySensor", "m_vecAxis", false, value);
}
bool GCPointAngularVelocitySensor::GetUseHelper() const {
    return GetSchemaValue<bool>(m_ptr, "CPointAngularVelocitySensor", "m_bUseHelper");
}
void GCPointAngularVelocitySensor::SetUseHelper(bool value) {
    SetSchemaValue(m_ptr, "CPointAngularVelocitySensor", "m_bUseHelper", false, value);
}
GCEntityIOOutput GCPointAngularVelocitySensor::GetOnLessThan() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CPointAngularVelocitySensor", "m_OnLessThan"));
    return value;
}
void GCPointAngularVelocitySensor::SetOnLessThan(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CPointAngularVelocitySensor", "m_OnLessThan", false, value);
}
GCEntityIOOutput GCPointAngularVelocitySensor::GetOnLessThanOrEqualTo() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CPointAngularVelocitySensor", "m_OnLessThanOrEqualTo"));
    return value;
}
void GCPointAngularVelocitySensor::SetOnLessThanOrEqualTo(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CPointAngularVelocitySensor", "m_OnLessThanOrEqualTo", false, value);
}
GCEntityIOOutput GCPointAngularVelocitySensor::GetOnGreaterThan() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CPointAngularVelocitySensor", "m_OnGreaterThan"));
    return value;
}
void GCPointAngularVelocitySensor::SetOnGreaterThan(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CPointAngularVelocitySensor", "m_OnGreaterThan", false, value);
}
GCEntityIOOutput GCPointAngularVelocitySensor::GetOnGreaterThanOrEqualTo() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CPointAngularVelocitySensor", "m_OnGreaterThanOrEqualTo"));
    return value;
}
void GCPointAngularVelocitySensor::SetOnGreaterThanOrEqualTo(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CPointAngularVelocitySensor", "m_OnGreaterThanOrEqualTo", false, value);
}
GCEntityIOOutput GCPointAngularVelocitySensor::GetOnEqualTo() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CPointAngularVelocitySensor", "m_OnEqualTo"));
    return value;
}
void GCPointAngularVelocitySensor::SetOnEqualTo(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CPointAngularVelocitySensor", "m_OnEqualTo", false, value);
}
std::string GCPointAngularVelocitySensor::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCPointAngularVelocitySensor::IsValid() {
    return (m_ptr != nullptr);
}
GCPointEntity GCPointAngularVelocitySensor::GetParent() const {
    GCPointEntity value(m_ptr);
    return value;
}
void GCPointAngularVelocitySensor::SetParent(GCPointEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCPointAngularVelocitySensor(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCPointAngularVelocitySensor>("CPointAngularVelocitySensor")
        .addConstructor<void (*)(std::string)>()
        .addProperty("TargetEntity", &GCPointAngularVelocitySensor::GetTargetEntity, &GCPointAngularVelocitySensor::SetTargetEntity)
        .addProperty("Threshold", &GCPointAngularVelocitySensor::GetThreshold, &GCPointAngularVelocitySensor::SetThreshold)
        .addProperty("LastCompareResult", &GCPointAngularVelocitySensor::GetLastCompareResult, &GCPointAngularVelocitySensor::SetLastCompareResult)
        .addProperty("LastFireResult", &GCPointAngularVelocitySensor::GetLastFireResult, &GCPointAngularVelocitySensor::SetLastFireResult)
        .addProperty("FireTime", &GCPointAngularVelocitySensor::GetFireTime, &GCPointAngularVelocitySensor::SetFireTime)
        .addProperty("FireInterval", &GCPointAngularVelocitySensor::GetFireInterval, &GCPointAngularVelocitySensor::SetFireInterval)
        .addProperty("LastAngVelocity", &GCPointAngularVelocitySensor::GetLastAngVelocity, &GCPointAngularVelocitySensor::SetLastAngVelocity)
        .addProperty("LastOrientation", &GCPointAngularVelocitySensor::GetLastOrientation, &GCPointAngularVelocitySensor::SetLastOrientation)
        .addProperty("Axis", &GCPointAngularVelocitySensor::GetAxis, &GCPointAngularVelocitySensor::SetAxis)
        .addProperty("UseHelper", &GCPointAngularVelocitySensor::GetUseHelper, &GCPointAngularVelocitySensor::SetUseHelper)
        .addProperty("OnLessThan", &GCPointAngularVelocitySensor::GetOnLessThan, &GCPointAngularVelocitySensor::SetOnLessThan)
        .addProperty("OnLessThanOrEqualTo", &GCPointAngularVelocitySensor::GetOnLessThanOrEqualTo, &GCPointAngularVelocitySensor::SetOnLessThanOrEqualTo)
        .addProperty("OnGreaterThan", &GCPointAngularVelocitySensor::GetOnGreaterThan, &GCPointAngularVelocitySensor::SetOnGreaterThan)
        .addProperty("OnGreaterThanOrEqualTo", &GCPointAngularVelocitySensor::GetOnGreaterThanOrEqualTo, &GCPointAngularVelocitySensor::SetOnGreaterThanOrEqualTo)
        .addProperty("OnEqualTo", &GCPointAngularVelocitySensor::GetOnEqualTo, &GCPointAngularVelocitySensor::SetOnEqualTo)
        .addProperty("Parent", &GCPointAngularVelocitySensor::GetParent, &GCPointAngularVelocitySensor::SetParent)
        .addFunction("ToPtr", &GCPointAngularVelocitySensor::ToPtr)
        .addFunction("IsValid", &GCPointAngularVelocitySensor::IsValid)
        .endClass();
}
GCBaseCSGrenadeProjectile::GCBaseCSGrenadeProjectile(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCBaseCSGrenadeProjectile::GCBaseCSGrenadeProjectile(void *ptr) {
    m_ptr = ptr;
}
Vector GCBaseCSGrenadeProjectile::GetInitialPosition() const {
    return GetSchemaValue<Vector>(m_ptr, "CBaseCSGrenadeProjectile", "m_vInitialPosition");
}
void GCBaseCSGrenadeProjectile::SetInitialPosition(Vector value) {
    SetSchemaValue(m_ptr, "CBaseCSGrenadeProjectile", "m_vInitialPosition", false, value);
}
Vector GCBaseCSGrenadeProjectile::GetInitialVelocity() const {
    return GetSchemaValue<Vector>(m_ptr, "CBaseCSGrenadeProjectile", "m_vInitialVelocity");
}
void GCBaseCSGrenadeProjectile::SetInitialVelocity(Vector value) {
    SetSchemaValue(m_ptr, "CBaseCSGrenadeProjectile", "m_vInitialVelocity", false, value);
}
int32_t GCBaseCSGrenadeProjectile::GetBounces() const {
    return GetSchemaValue<int32_t>(m_ptr, "CBaseCSGrenadeProjectile", "m_nBounces");
}
void GCBaseCSGrenadeProjectile::SetBounces(int32_t value) {
    SetSchemaValue(m_ptr, "CBaseCSGrenadeProjectile", "m_nBounces", false, value);
}
int32_t GCBaseCSGrenadeProjectile::GetExplodeEffectTickBegin() const {
    return GetSchemaValue<int32_t>(m_ptr, "CBaseCSGrenadeProjectile", "m_nExplodeEffectTickBegin");
}
void GCBaseCSGrenadeProjectile::SetExplodeEffectTickBegin(int32_t value) {
    SetSchemaValue(m_ptr, "CBaseCSGrenadeProjectile", "m_nExplodeEffectTickBegin", false, value);
}
Vector GCBaseCSGrenadeProjectile::GetExplodeEffectOrigin() const {
    return GetSchemaValue<Vector>(m_ptr, "CBaseCSGrenadeProjectile", "m_vecExplodeEffectOrigin");
}
void GCBaseCSGrenadeProjectile::SetExplodeEffectOrigin(Vector value) {
    SetSchemaValue(m_ptr, "CBaseCSGrenadeProjectile", "m_vecExplodeEffectOrigin", false, value);
}
float GCBaseCSGrenadeProjectile::GetSpawnTime() const {
    return GetSchemaValue<float>(m_ptr, "CBaseCSGrenadeProjectile", "m_flSpawnTime");
}
void GCBaseCSGrenadeProjectile::SetSpawnTime(float value) {
    SetSchemaValue(m_ptr, "CBaseCSGrenadeProjectile", "m_flSpawnTime", false, value);
}
uint8_t GCBaseCSGrenadeProjectile::GetOGSExtraFlags() const {
    return GetSchemaValue<uint8_t>(m_ptr, "CBaseCSGrenadeProjectile", "m_unOGSExtraFlags");
}
void GCBaseCSGrenadeProjectile::SetOGSExtraFlags(uint8_t value) {
    SetSchemaValue(m_ptr, "CBaseCSGrenadeProjectile", "m_unOGSExtraFlags", false, value);
}
bool GCBaseCSGrenadeProjectile::GetDetonationRecorded() const {
    return GetSchemaValue<bool>(m_ptr, "CBaseCSGrenadeProjectile", "m_bDetonationRecorded");
}
void GCBaseCSGrenadeProjectile::SetDetonationRecorded(bool value) {
    SetSchemaValue(m_ptr, "CBaseCSGrenadeProjectile", "m_bDetonationRecorded", false, value);
}
uint16_t GCBaseCSGrenadeProjectile::GetItemIndex() const {
    return GetSchemaValue<uint16_t>(m_ptr, "CBaseCSGrenadeProjectile", "m_nItemIndex");
}
void GCBaseCSGrenadeProjectile::SetItemIndex(uint16_t value) {
    SetSchemaValue(m_ptr, "CBaseCSGrenadeProjectile", "m_nItemIndex", false, value);
}
Vector GCBaseCSGrenadeProjectile::GetOriginalSpawnLocation() const {
    return GetSchemaValue<Vector>(m_ptr, "CBaseCSGrenadeProjectile", "m_vecOriginalSpawnLocation");
}
void GCBaseCSGrenadeProjectile::SetOriginalSpawnLocation(Vector value) {
    SetSchemaValue(m_ptr, "CBaseCSGrenadeProjectile", "m_vecOriginalSpawnLocation", false, value);
}
float GCBaseCSGrenadeProjectile::GetLastBounceSoundTime() const {
    return GetSchemaValue<float>(m_ptr, "CBaseCSGrenadeProjectile", "m_flLastBounceSoundTime");
}
void GCBaseCSGrenadeProjectile::SetLastBounceSoundTime(float value) {
    SetSchemaValue(m_ptr, "CBaseCSGrenadeProjectile", "m_flLastBounceSoundTime", false, value);
}
Vector GCBaseCSGrenadeProjectile::GetGrenadeSpin() const {
    return GetSchemaValue<Vector>(m_ptr, "CBaseCSGrenadeProjectile", "m_vecGrenadeSpin");
}
void GCBaseCSGrenadeProjectile::SetGrenadeSpin(Vector value) {
    SetSchemaValue(m_ptr, "CBaseCSGrenadeProjectile", "m_vecGrenadeSpin", false, value);
}
Vector GCBaseCSGrenadeProjectile::GetLastHitSurfaceNormal() const {
    return GetSchemaValue<Vector>(m_ptr, "CBaseCSGrenadeProjectile", "m_vecLastHitSurfaceNormal");
}
void GCBaseCSGrenadeProjectile::SetLastHitSurfaceNormal(Vector value) {
    SetSchemaValue(m_ptr, "CBaseCSGrenadeProjectile", "m_vecLastHitSurfaceNormal", false, value);
}
int32_t GCBaseCSGrenadeProjectile::GetTicksAtZeroVelocity() const {
    return GetSchemaValue<int32_t>(m_ptr, "CBaseCSGrenadeProjectile", "m_nTicksAtZeroVelocity");
}
void GCBaseCSGrenadeProjectile::SetTicksAtZeroVelocity(int32_t value) {
    SetSchemaValue(m_ptr, "CBaseCSGrenadeProjectile", "m_nTicksAtZeroVelocity", false, value);
}
bool GCBaseCSGrenadeProjectile::GetHasEverHitPlayer() const {
    return GetSchemaValue<bool>(m_ptr, "CBaseCSGrenadeProjectile", "m_bHasEverHitPlayer");
}
void GCBaseCSGrenadeProjectile::SetHasEverHitPlayer(bool value) {
    SetSchemaValue(m_ptr, "CBaseCSGrenadeProjectile", "m_bHasEverHitPlayer", false, value);
}
bool GCBaseCSGrenadeProjectile::GetClearFromPlayers() const {
    return GetSchemaValue<bool>(m_ptr, "CBaseCSGrenadeProjectile", "m_bClearFromPlayers");
}
void GCBaseCSGrenadeProjectile::SetClearFromPlayers(bool value) {
    SetSchemaValue(m_ptr, "CBaseCSGrenadeProjectile", "m_bClearFromPlayers", false, value);
}
std::string GCBaseCSGrenadeProjectile::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCBaseCSGrenadeProjectile::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseGrenade GCBaseCSGrenadeProjectile::GetParent() const {
    GCBaseGrenade value(m_ptr);
    return value;
}
void GCBaseCSGrenadeProjectile::SetParent(GCBaseGrenade value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCBaseCSGrenadeProjectile(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCBaseCSGrenadeProjectile>("CBaseCSGrenadeProjectile")
        .addConstructor<void (*)(std::string)>()
        .addProperty("InitialPosition", &GCBaseCSGrenadeProjectile::GetInitialPosition, &GCBaseCSGrenadeProjectile::SetInitialPosition)
        .addProperty("InitialVelocity", &GCBaseCSGrenadeProjectile::GetInitialVelocity, &GCBaseCSGrenadeProjectile::SetInitialVelocity)
        .addProperty("Bounces", &GCBaseCSGrenadeProjectile::GetBounces, &GCBaseCSGrenadeProjectile::SetBounces)
        .addProperty("ExplodeEffectTickBegin", &GCBaseCSGrenadeProjectile::GetExplodeEffectTickBegin, &GCBaseCSGrenadeProjectile::SetExplodeEffectTickBegin)
        .addProperty("ExplodeEffectOrigin", &GCBaseCSGrenadeProjectile::GetExplodeEffectOrigin, &GCBaseCSGrenadeProjectile::SetExplodeEffectOrigin)
        .addProperty("SpawnTime", &GCBaseCSGrenadeProjectile::GetSpawnTime, &GCBaseCSGrenadeProjectile::SetSpawnTime)
        .addProperty("OGSExtraFlags", &GCBaseCSGrenadeProjectile::GetOGSExtraFlags, &GCBaseCSGrenadeProjectile::SetOGSExtraFlags)
        .addProperty("DetonationRecorded", &GCBaseCSGrenadeProjectile::GetDetonationRecorded, &GCBaseCSGrenadeProjectile::SetDetonationRecorded)
        .addProperty("ItemIndex", &GCBaseCSGrenadeProjectile::GetItemIndex, &GCBaseCSGrenadeProjectile::SetItemIndex)
        .addProperty("OriginalSpawnLocation", &GCBaseCSGrenadeProjectile::GetOriginalSpawnLocation, &GCBaseCSGrenadeProjectile::SetOriginalSpawnLocation)
        .addProperty("LastBounceSoundTime", &GCBaseCSGrenadeProjectile::GetLastBounceSoundTime, &GCBaseCSGrenadeProjectile::SetLastBounceSoundTime)
        .addProperty("GrenadeSpin", &GCBaseCSGrenadeProjectile::GetGrenadeSpin, &GCBaseCSGrenadeProjectile::SetGrenadeSpin)
        .addProperty("LastHitSurfaceNormal", &GCBaseCSGrenadeProjectile::GetLastHitSurfaceNormal, &GCBaseCSGrenadeProjectile::SetLastHitSurfaceNormal)
        .addProperty("TicksAtZeroVelocity", &GCBaseCSGrenadeProjectile::GetTicksAtZeroVelocity, &GCBaseCSGrenadeProjectile::SetTicksAtZeroVelocity)
        .addProperty("HasEverHitPlayer", &GCBaseCSGrenadeProjectile::GetHasEverHitPlayer, &GCBaseCSGrenadeProjectile::SetHasEverHitPlayer)
        .addProperty("ClearFromPlayers", &GCBaseCSGrenadeProjectile::GetClearFromPlayers, &GCBaseCSGrenadeProjectile::SetClearFromPlayers)
        .addProperty("Parent", &GCBaseCSGrenadeProjectile::GetParent, &GCBaseCSGrenadeProjectile::SetParent)
        .addFunction("ToPtr", &GCBaseCSGrenadeProjectile::ToPtr)
        .addFunction("IsValid", &GCBaseCSGrenadeProjectile::IsValid)
        .endClass();
}
GCHostageRescueZoneShim::GCHostageRescueZoneShim(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCHostageRescueZoneShim::GCHostageRescueZoneShim(void *ptr) {
    m_ptr = ptr;
}
std::string GCHostageRescueZoneShim::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCHostageRescueZoneShim::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseTrigger GCHostageRescueZoneShim::GetParent() const {
    GCBaseTrigger value(m_ptr);
    return value;
}
void GCHostageRescueZoneShim::SetParent(GCBaseTrigger value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCHostageRescueZoneShim(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCHostageRescueZoneShim>("CHostageRescueZoneShim")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCHostageRescueZoneShim::GetParent, &GCHostageRescueZoneShim::SetParent)
        .addFunction("ToPtr", &GCHostageRescueZoneShim::ToPtr)
        .addFunction("IsValid", &GCHostageRescueZoneShim::IsValid)
        .endClass();
}
GCEnvInstructorHint::GCEnvInstructorHint(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCEnvInstructorHint::GCEnvInstructorHint(void *ptr) {
    m_ptr = ptr;
}
std::string GCEnvInstructorHint::GetName() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CEnvInstructorHint", "m_iszName").String();
}
void GCEnvInstructorHint::SetName(std::string value) {
    SetSchemaValue(m_ptr, "CEnvInstructorHint", "m_iszName", false, CUtlSymbolLarge(value.c_str()));
}
std::string GCEnvInstructorHint::GetReplace_Key() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CEnvInstructorHint", "m_iszReplace_Key").String();
}
void GCEnvInstructorHint::SetReplace_Key(std::string value) {
    SetSchemaValue(m_ptr, "CEnvInstructorHint", "m_iszReplace_Key", false, CUtlSymbolLarge(value.c_str()));
}
std::string GCEnvInstructorHint::GetHintTargetEntity() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CEnvInstructorHint", "m_iszHintTargetEntity").String();
}
void GCEnvInstructorHint::SetHintTargetEntity(std::string value) {
    SetSchemaValue(m_ptr, "CEnvInstructorHint", "m_iszHintTargetEntity", false, CUtlSymbolLarge(value.c_str()));
}
int32_t GCEnvInstructorHint::GetTimeout() const {
    return GetSchemaValue<int32_t>(m_ptr, "CEnvInstructorHint", "m_iTimeout");
}
void GCEnvInstructorHint::SetTimeout(int32_t value) {
    SetSchemaValue(m_ptr, "CEnvInstructorHint", "m_iTimeout", false, value);
}
int32_t GCEnvInstructorHint::GetDisplayLimit() const {
    return GetSchemaValue<int32_t>(m_ptr, "CEnvInstructorHint", "m_iDisplayLimit");
}
void GCEnvInstructorHint::SetDisplayLimit(int32_t value) {
    SetSchemaValue(m_ptr, "CEnvInstructorHint", "m_iDisplayLimit", false, value);
}
std::string GCEnvInstructorHint::GetIcon_Onscreen() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CEnvInstructorHint", "m_iszIcon_Onscreen").String();
}
void GCEnvInstructorHint::SetIcon_Onscreen(std::string value) {
    SetSchemaValue(m_ptr, "CEnvInstructorHint", "m_iszIcon_Onscreen", false, CUtlSymbolLarge(value.c_str()));
}
std::string GCEnvInstructorHint::GetIcon_Offscreen() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CEnvInstructorHint", "m_iszIcon_Offscreen").String();
}
void GCEnvInstructorHint::SetIcon_Offscreen(std::string value) {
    SetSchemaValue(m_ptr, "CEnvInstructorHint", "m_iszIcon_Offscreen", false, CUtlSymbolLarge(value.c_str()));
}
std::string GCEnvInstructorHint::GetCaption() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CEnvInstructorHint", "m_iszCaption").String();
}
void GCEnvInstructorHint::SetCaption(std::string value) {
    SetSchemaValue(m_ptr, "CEnvInstructorHint", "m_iszCaption", false, CUtlSymbolLarge(value.c_str()));
}
std::string GCEnvInstructorHint::GetActivatorCaption() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CEnvInstructorHint", "m_iszActivatorCaption").String();
}
void GCEnvInstructorHint::SetActivatorCaption(std::string value) {
    SetSchemaValue(m_ptr, "CEnvInstructorHint", "m_iszActivatorCaption", false, CUtlSymbolLarge(value.c_str()));
}
Color GCEnvInstructorHint::GetColor() const {
    return GetSchemaValue<Color>(m_ptr, "CEnvInstructorHint", "m_Color");
}
void GCEnvInstructorHint::SetColor(Color value) {
    SetSchemaValue(m_ptr, "CEnvInstructorHint", "m_Color", false, value);
}
float GCEnvInstructorHint::GetIconOffset() const {
    return GetSchemaValue<float>(m_ptr, "CEnvInstructorHint", "m_fIconOffset");
}
void GCEnvInstructorHint::SetIconOffset(float value) {
    SetSchemaValue(m_ptr, "CEnvInstructorHint", "m_fIconOffset", false, value);
}
float GCEnvInstructorHint::GetRange() const {
    return GetSchemaValue<float>(m_ptr, "CEnvInstructorHint", "m_fRange");
}
void GCEnvInstructorHint::SetRange(float value) {
    SetSchemaValue(m_ptr, "CEnvInstructorHint", "m_fRange", false, value);
}
uint8_t GCEnvInstructorHint::GetPulseOption() const {
    return GetSchemaValue<uint8_t>(m_ptr, "CEnvInstructorHint", "m_iPulseOption");
}
void GCEnvInstructorHint::SetPulseOption(uint8_t value) {
    SetSchemaValue(m_ptr, "CEnvInstructorHint", "m_iPulseOption", false, value);
}
uint8_t GCEnvInstructorHint::GetAlphaOption() const {
    return GetSchemaValue<uint8_t>(m_ptr, "CEnvInstructorHint", "m_iAlphaOption");
}
void GCEnvInstructorHint::SetAlphaOption(uint8_t value) {
    SetSchemaValue(m_ptr, "CEnvInstructorHint", "m_iAlphaOption", false, value);
}
uint8_t GCEnvInstructorHint::GetShakeOption() const {
    return GetSchemaValue<uint8_t>(m_ptr, "CEnvInstructorHint", "m_iShakeOption");
}
void GCEnvInstructorHint::SetShakeOption(uint8_t value) {
    SetSchemaValue(m_ptr, "CEnvInstructorHint", "m_iShakeOption", false, value);
}
bool GCEnvInstructorHint::GetStatic() const {
    return GetSchemaValue<bool>(m_ptr, "CEnvInstructorHint", "m_bStatic");
}
void GCEnvInstructorHint::SetStatic(bool value) {
    SetSchemaValue(m_ptr, "CEnvInstructorHint", "m_bStatic", false, value);
}
bool GCEnvInstructorHint::GetNoOffscreen() const {
    return GetSchemaValue<bool>(m_ptr, "CEnvInstructorHint", "m_bNoOffscreen");
}
void GCEnvInstructorHint::SetNoOffscreen(bool value) {
    SetSchemaValue(m_ptr, "CEnvInstructorHint", "m_bNoOffscreen", false, value);
}
bool GCEnvInstructorHint::GetForceCaption() const {
    return GetSchemaValue<bool>(m_ptr, "CEnvInstructorHint", "m_bForceCaption");
}
void GCEnvInstructorHint::SetForceCaption(bool value) {
    SetSchemaValue(m_ptr, "CEnvInstructorHint", "m_bForceCaption", false, value);
}
int32_t GCEnvInstructorHint::GetInstanceType() const {
    return GetSchemaValue<int32_t>(m_ptr, "CEnvInstructorHint", "m_iInstanceType");
}
void GCEnvInstructorHint::SetInstanceType(int32_t value) {
    SetSchemaValue(m_ptr, "CEnvInstructorHint", "m_iInstanceType", false, value);
}
bool GCEnvInstructorHint::GetSuppressRest() const {
    return GetSchemaValue<bool>(m_ptr, "CEnvInstructorHint", "m_bSuppressRest");
}
void GCEnvInstructorHint::SetSuppressRest(bool value) {
    SetSchemaValue(m_ptr, "CEnvInstructorHint", "m_bSuppressRest", false, value);
}
std::string GCEnvInstructorHint::GetBinding() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CEnvInstructorHint", "m_iszBinding").String();
}
void GCEnvInstructorHint::SetBinding(std::string value) {
    SetSchemaValue(m_ptr, "CEnvInstructorHint", "m_iszBinding", false, CUtlSymbolLarge(value.c_str()));
}
bool GCEnvInstructorHint::GetAllowNoDrawTarget() const {
    return GetSchemaValue<bool>(m_ptr, "CEnvInstructorHint", "m_bAllowNoDrawTarget");
}
void GCEnvInstructorHint::SetAllowNoDrawTarget(bool value) {
    SetSchemaValue(m_ptr, "CEnvInstructorHint", "m_bAllowNoDrawTarget", false, value);
}
bool GCEnvInstructorHint::GetAutoStart() const {
    return GetSchemaValue<bool>(m_ptr, "CEnvInstructorHint", "m_bAutoStart");
}
void GCEnvInstructorHint::SetAutoStart(bool value) {
    SetSchemaValue(m_ptr, "CEnvInstructorHint", "m_bAutoStart", false, value);
}
bool GCEnvInstructorHint::GetLocalPlayerOnly() const {
    return GetSchemaValue<bool>(m_ptr, "CEnvInstructorHint", "m_bLocalPlayerOnly");
}
void GCEnvInstructorHint::SetLocalPlayerOnly(bool value) {
    SetSchemaValue(m_ptr, "CEnvInstructorHint", "m_bLocalPlayerOnly", false, value);
}
std::string GCEnvInstructorHint::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCEnvInstructorHint::IsValid() {
    return (m_ptr != nullptr);
}
GCPointEntity GCEnvInstructorHint::GetParent() const {
    GCPointEntity value(m_ptr);
    return value;
}
void GCEnvInstructorHint::SetParent(GCPointEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCEnvInstructorHint(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCEnvInstructorHint>("CEnvInstructorHint")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Name", &GCEnvInstructorHint::GetName, &GCEnvInstructorHint::SetName)
        .addProperty("Replace_Key", &GCEnvInstructorHint::GetReplace_Key, &GCEnvInstructorHint::SetReplace_Key)
        .addProperty("HintTargetEntity", &GCEnvInstructorHint::GetHintTargetEntity, &GCEnvInstructorHint::SetHintTargetEntity)
        .addProperty("Timeout", &GCEnvInstructorHint::GetTimeout, &GCEnvInstructorHint::SetTimeout)
        .addProperty("DisplayLimit", &GCEnvInstructorHint::GetDisplayLimit, &GCEnvInstructorHint::SetDisplayLimit)
        .addProperty("Icon_Onscreen", &GCEnvInstructorHint::GetIcon_Onscreen, &GCEnvInstructorHint::SetIcon_Onscreen)
        .addProperty("Icon_Offscreen", &GCEnvInstructorHint::GetIcon_Offscreen, &GCEnvInstructorHint::SetIcon_Offscreen)
        .addProperty("Caption", &GCEnvInstructorHint::GetCaption, &GCEnvInstructorHint::SetCaption)
        .addProperty("ActivatorCaption", &GCEnvInstructorHint::GetActivatorCaption, &GCEnvInstructorHint::SetActivatorCaption)
        .addProperty("Color", &GCEnvInstructorHint::GetColor, &GCEnvInstructorHint::SetColor)
        .addProperty("IconOffset", &GCEnvInstructorHint::GetIconOffset, &GCEnvInstructorHint::SetIconOffset)
        .addProperty("Range", &GCEnvInstructorHint::GetRange, &GCEnvInstructorHint::SetRange)
        .addProperty("PulseOption", &GCEnvInstructorHint::GetPulseOption, &GCEnvInstructorHint::SetPulseOption)
        .addProperty("AlphaOption", &GCEnvInstructorHint::GetAlphaOption, &GCEnvInstructorHint::SetAlphaOption)
        .addProperty("ShakeOption", &GCEnvInstructorHint::GetShakeOption, &GCEnvInstructorHint::SetShakeOption)
        .addProperty("Static", &GCEnvInstructorHint::GetStatic, &GCEnvInstructorHint::SetStatic)
        .addProperty("NoOffscreen", &GCEnvInstructorHint::GetNoOffscreen, &GCEnvInstructorHint::SetNoOffscreen)
        .addProperty("ForceCaption", &GCEnvInstructorHint::GetForceCaption, &GCEnvInstructorHint::SetForceCaption)
        .addProperty("InstanceType", &GCEnvInstructorHint::GetInstanceType, &GCEnvInstructorHint::SetInstanceType)
        .addProperty("SuppressRest", &GCEnvInstructorHint::GetSuppressRest, &GCEnvInstructorHint::SetSuppressRest)
        .addProperty("Binding", &GCEnvInstructorHint::GetBinding, &GCEnvInstructorHint::SetBinding)
        .addProperty("AllowNoDrawTarget", &GCEnvInstructorHint::GetAllowNoDrawTarget, &GCEnvInstructorHint::SetAllowNoDrawTarget)
        .addProperty("AutoStart", &GCEnvInstructorHint::GetAutoStart, &GCEnvInstructorHint::SetAutoStart)
        .addProperty("LocalPlayerOnly", &GCEnvInstructorHint::GetLocalPlayerOnly, &GCEnvInstructorHint::SetLocalPlayerOnly)
        .addProperty("Parent", &GCEnvInstructorHint::GetParent, &GCEnvInstructorHint::SetParent)
        .addFunction("ToPtr", &GCEnvInstructorHint::ToPtr)
        .addFunction("IsValid", &GCEnvInstructorHint::IsValid)
        .endClass();
}
GCEnvTracer::GCEnvTracer(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCEnvTracer::GCEnvTracer(void *ptr) {
    m_ptr = ptr;
}
Vector GCEnvTracer::GetEnd() const {
    return GetSchemaValue<Vector>(m_ptr, "CEnvTracer", "m_vecEnd");
}
void GCEnvTracer::SetEnd(Vector value) {
    SetSchemaValue(m_ptr, "CEnvTracer", "m_vecEnd", false, value);
}
float GCEnvTracer::GetDelay() const {
    return GetSchemaValue<float>(m_ptr, "CEnvTracer", "m_flDelay");
}
void GCEnvTracer::SetDelay(float value) {
    SetSchemaValue(m_ptr, "CEnvTracer", "m_flDelay", false, value);
}
std::string GCEnvTracer::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCEnvTracer::IsValid() {
    return (m_ptr != nullptr);
}
GCPointEntity GCEnvTracer::GetParent() const {
    GCPointEntity value(m_ptr);
    return value;
}
void GCEnvTracer::SetParent(GCPointEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCEnvTracer(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCEnvTracer>("CEnvTracer")
        .addConstructor<void (*)(std::string)>()
        .addProperty("End", &GCEnvTracer::GetEnd, &GCEnvTracer::SetEnd)
        .addProperty("Delay", &GCEnvTracer::GetDelay, &GCEnvTracer::SetDelay)
        .addProperty("Parent", &GCEnvTracer::GetParent, &GCEnvTracer::SetParent)
        .addFunction("ToPtr", &GCEnvTracer::ToPtr)
        .addFunction("IsValid", &GCEnvTracer::IsValid)
        .endClass();
}
GCInfoGameEventProxy::GCInfoGameEventProxy(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCInfoGameEventProxy::GCInfoGameEventProxy(void *ptr) {
    m_ptr = ptr;
}
std::string GCInfoGameEventProxy::GetEventName() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CInfoGameEventProxy", "m_iszEventName").String();
}
void GCInfoGameEventProxy::SetEventName(std::string value) {
    SetSchemaValue(m_ptr, "CInfoGameEventProxy", "m_iszEventName", false, CUtlSymbolLarge(value.c_str()));
}
float GCInfoGameEventProxy::GetRange() const {
    return GetSchemaValue<float>(m_ptr, "CInfoGameEventProxy", "m_flRange");
}
void GCInfoGameEventProxy::SetRange(float value) {
    SetSchemaValue(m_ptr, "CInfoGameEventProxy", "m_flRange", false, value);
}
std::string GCInfoGameEventProxy::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCInfoGameEventProxy::IsValid() {
    return (m_ptr != nullptr);
}
GCPointEntity GCInfoGameEventProxy::GetParent() const {
    GCPointEntity value(m_ptr);
    return value;
}
void GCInfoGameEventProxy::SetParent(GCPointEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCInfoGameEventProxy(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCInfoGameEventProxy>("CInfoGameEventProxy")
        .addConstructor<void (*)(std::string)>()
        .addProperty("EventName", &GCInfoGameEventProxy::GetEventName, &GCInfoGameEventProxy::SetEventName)
        .addProperty("Range", &GCInfoGameEventProxy::GetRange, &GCInfoGameEventProxy::SetRange)
        .addProperty("Parent", &GCInfoGameEventProxy::GetParent, &GCInfoGameEventProxy::SetParent)
        .addFunction("ToPtr", &GCInfoGameEventProxy::ToPtr)
        .addFunction("IsValid", &GCInfoGameEventProxy::IsValid)
        .endClass();
}
GCPointCamera::GCPointCamera(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCPointCamera::GCPointCamera(void *ptr) {
    m_ptr = ptr;
}
float GCPointCamera::GetFOV() const {
    return GetSchemaValue<float>(m_ptr, "CPointCamera", "m_FOV");
}
void GCPointCamera::SetFOV(float value) {
    SetSchemaValue(m_ptr, "CPointCamera", "m_FOV", false, value);
}
float GCPointCamera::GetResolution() const {
    return GetSchemaValue<float>(m_ptr, "CPointCamera", "m_Resolution");
}
void GCPointCamera::SetResolution(float value) {
    SetSchemaValue(m_ptr, "CPointCamera", "m_Resolution", false, value);
}
bool GCPointCamera::GetFogEnable() const {
    return GetSchemaValue<bool>(m_ptr, "CPointCamera", "m_bFogEnable");
}
void GCPointCamera::SetFogEnable(bool value) {
    SetSchemaValue(m_ptr, "CPointCamera", "m_bFogEnable", false, value);
}
Color GCPointCamera::GetFogColor() const {
    return GetSchemaValue<Color>(m_ptr, "CPointCamera", "m_FogColor");
}
void GCPointCamera::SetFogColor(Color value) {
    SetSchemaValue(m_ptr, "CPointCamera", "m_FogColor", false, value);
}
float GCPointCamera::GetFogStart() const {
    return GetSchemaValue<float>(m_ptr, "CPointCamera", "m_flFogStart");
}
void GCPointCamera::SetFogStart(float value) {
    SetSchemaValue(m_ptr, "CPointCamera", "m_flFogStart", false, value);
}
float GCPointCamera::GetFogEnd() const {
    return GetSchemaValue<float>(m_ptr, "CPointCamera", "m_flFogEnd");
}
void GCPointCamera::SetFogEnd(float value) {
    SetSchemaValue(m_ptr, "CPointCamera", "m_flFogEnd", false, value);
}
float GCPointCamera::GetFogMaxDensity() const {
    return GetSchemaValue<float>(m_ptr, "CPointCamera", "m_flFogMaxDensity");
}
void GCPointCamera::SetFogMaxDensity(float value) {
    SetSchemaValue(m_ptr, "CPointCamera", "m_flFogMaxDensity", false, value);
}
bool GCPointCamera::GetActive() const {
    return GetSchemaValue<bool>(m_ptr, "CPointCamera", "m_bActive");
}
void GCPointCamera::SetActive(bool value) {
    SetSchemaValue(m_ptr, "CPointCamera", "m_bActive", false, value);
}
bool GCPointCamera::GetUseScreenAspectRatio() const {
    return GetSchemaValue<bool>(m_ptr, "CPointCamera", "m_bUseScreenAspectRatio");
}
void GCPointCamera::SetUseScreenAspectRatio(bool value) {
    SetSchemaValue(m_ptr, "CPointCamera", "m_bUseScreenAspectRatio", false, value);
}
float GCPointCamera::GetAspectRatio() const {
    return GetSchemaValue<float>(m_ptr, "CPointCamera", "m_flAspectRatio");
}
void GCPointCamera::SetAspectRatio(float value) {
    SetSchemaValue(m_ptr, "CPointCamera", "m_flAspectRatio", false, value);
}
bool GCPointCamera::GetNoSky() const {
    return GetSchemaValue<bool>(m_ptr, "CPointCamera", "m_bNoSky");
}
void GCPointCamera::SetNoSky(bool value) {
    SetSchemaValue(m_ptr, "CPointCamera", "m_bNoSky", false, value);
}
float GCPointCamera::GetBrightness() const {
    return GetSchemaValue<float>(m_ptr, "CPointCamera", "m_fBrightness");
}
void GCPointCamera::SetBrightness(float value) {
    SetSchemaValue(m_ptr, "CPointCamera", "m_fBrightness", false, value);
}
float GCPointCamera::GetZFar() const {
    return GetSchemaValue<float>(m_ptr, "CPointCamera", "m_flZFar");
}
void GCPointCamera::SetZFar(float value) {
    SetSchemaValue(m_ptr, "CPointCamera", "m_flZFar", false, value);
}
float GCPointCamera::GetZNear() const {
    return GetSchemaValue<float>(m_ptr, "CPointCamera", "m_flZNear");
}
void GCPointCamera::SetZNear(float value) {
    SetSchemaValue(m_ptr, "CPointCamera", "m_flZNear", false, value);
}
bool GCPointCamera::GetCanHLTVUse() const {
    return GetSchemaValue<bool>(m_ptr, "CPointCamera", "m_bCanHLTVUse");
}
void GCPointCamera::SetCanHLTVUse(bool value) {
    SetSchemaValue(m_ptr, "CPointCamera", "m_bCanHLTVUse", false, value);
}
bool GCPointCamera::GetDofEnabled() const {
    return GetSchemaValue<bool>(m_ptr, "CPointCamera", "m_bDofEnabled");
}
void GCPointCamera::SetDofEnabled(bool value) {
    SetSchemaValue(m_ptr, "CPointCamera", "m_bDofEnabled", false, value);
}
float GCPointCamera::GetDofNearBlurry() const {
    return GetSchemaValue<float>(m_ptr, "CPointCamera", "m_flDofNearBlurry");
}
void GCPointCamera::SetDofNearBlurry(float value) {
    SetSchemaValue(m_ptr, "CPointCamera", "m_flDofNearBlurry", false, value);
}
float GCPointCamera::GetDofNearCrisp() const {
    return GetSchemaValue<float>(m_ptr, "CPointCamera", "m_flDofNearCrisp");
}
void GCPointCamera::SetDofNearCrisp(float value) {
    SetSchemaValue(m_ptr, "CPointCamera", "m_flDofNearCrisp", false, value);
}
float GCPointCamera::GetDofFarCrisp() const {
    return GetSchemaValue<float>(m_ptr, "CPointCamera", "m_flDofFarCrisp");
}
void GCPointCamera::SetDofFarCrisp(float value) {
    SetSchemaValue(m_ptr, "CPointCamera", "m_flDofFarCrisp", false, value);
}
float GCPointCamera::GetDofFarBlurry() const {
    return GetSchemaValue<float>(m_ptr, "CPointCamera", "m_flDofFarBlurry");
}
void GCPointCamera::SetDofFarBlurry(float value) {
    SetSchemaValue(m_ptr, "CPointCamera", "m_flDofFarBlurry", false, value);
}
float GCPointCamera::GetDofTiltToGround() const {
    return GetSchemaValue<float>(m_ptr, "CPointCamera", "m_flDofTiltToGround");
}
void GCPointCamera::SetDofTiltToGround(float value) {
    SetSchemaValue(m_ptr, "CPointCamera", "m_flDofTiltToGround", false, value);
}
float GCPointCamera::GetTargetFOV() const {
    return GetSchemaValue<float>(m_ptr, "CPointCamera", "m_TargetFOV");
}
void GCPointCamera::SetTargetFOV(float value) {
    SetSchemaValue(m_ptr, "CPointCamera", "m_TargetFOV", false, value);
}
float GCPointCamera::GetDegreesPerSecond() const {
    return GetSchemaValue<float>(m_ptr, "CPointCamera", "m_DegreesPerSecond");
}
void GCPointCamera::SetDegreesPerSecond(float value) {
    SetSchemaValue(m_ptr, "CPointCamera", "m_DegreesPerSecond", false, value);
}
bool GCPointCamera::GetIsOn() const {
    return GetSchemaValue<bool>(m_ptr, "CPointCamera", "m_bIsOn");
}
void GCPointCamera::SetIsOn(bool value) {
    SetSchemaValue(m_ptr, "CPointCamera", "m_bIsOn", false, value);
}
GCPointCamera GCPointCamera::GetNext() const {
    GCPointCamera value(*GetSchemaValuePtr<void*>(m_ptr, "CPointCamera", "m_pNext"));
    return value;
}
void GCPointCamera::SetNext(GCPointCamera* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Next' is not possible.\n");
}
std::string GCPointCamera::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCPointCamera::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseEntity GCPointCamera::GetParent() const {
    GCBaseEntity value(m_ptr);
    return value;
}
void GCPointCamera::SetParent(GCBaseEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCPointCamera(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCPointCamera>("CPointCamera")
        .addConstructor<void (*)(std::string)>()
        .addProperty("FOV", &GCPointCamera::GetFOV, &GCPointCamera::SetFOV)
        .addProperty("Resolution", &GCPointCamera::GetResolution, &GCPointCamera::SetResolution)
        .addProperty("FogEnable", &GCPointCamera::GetFogEnable, &GCPointCamera::SetFogEnable)
        .addProperty("FogColor", &GCPointCamera::GetFogColor, &GCPointCamera::SetFogColor)
        .addProperty("FogStart", &GCPointCamera::GetFogStart, &GCPointCamera::SetFogStart)
        .addProperty("FogEnd", &GCPointCamera::GetFogEnd, &GCPointCamera::SetFogEnd)
        .addProperty("FogMaxDensity", &GCPointCamera::GetFogMaxDensity, &GCPointCamera::SetFogMaxDensity)
        .addProperty("Active", &GCPointCamera::GetActive, &GCPointCamera::SetActive)
        .addProperty("UseScreenAspectRatio", &GCPointCamera::GetUseScreenAspectRatio, &GCPointCamera::SetUseScreenAspectRatio)
        .addProperty("AspectRatio", &GCPointCamera::GetAspectRatio, &GCPointCamera::SetAspectRatio)
        .addProperty("NoSky", &GCPointCamera::GetNoSky, &GCPointCamera::SetNoSky)
        .addProperty("Brightness", &GCPointCamera::GetBrightness, &GCPointCamera::SetBrightness)
        .addProperty("ZFar", &GCPointCamera::GetZFar, &GCPointCamera::SetZFar)
        .addProperty("ZNear", &GCPointCamera::GetZNear, &GCPointCamera::SetZNear)
        .addProperty("CanHLTVUse", &GCPointCamera::GetCanHLTVUse, &GCPointCamera::SetCanHLTVUse)
        .addProperty("DofEnabled", &GCPointCamera::GetDofEnabled, &GCPointCamera::SetDofEnabled)
        .addProperty("DofNearBlurry", &GCPointCamera::GetDofNearBlurry, &GCPointCamera::SetDofNearBlurry)
        .addProperty("DofNearCrisp", &GCPointCamera::GetDofNearCrisp, &GCPointCamera::SetDofNearCrisp)
        .addProperty("DofFarCrisp", &GCPointCamera::GetDofFarCrisp, &GCPointCamera::SetDofFarCrisp)
        .addProperty("DofFarBlurry", &GCPointCamera::GetDofFarBlurry, &GCPointCamera::SetDofFarBlurry)
        .addProperty("DofTiltToGround", &GCPointCamera::GetDofTiltToGround, &GCPointCamera::SetDofTiltToGround)
        .addProperty("TargetFOV", &GCPointCamera::GetTargetFOV, &GCPointCamera::SetTargetFOV)
        .addProperty("DegreesPerSecond", &GCPointCamera::GetDegreesPerSecond, &GCPointCamera::SetDegreesPerSecond)
        .addProperty("IsOn", &GCPointCamera::GetIsOn, &GCPointCamera::SetIsOn)
        .addProperty("Next", &GCPointCamera::GetNext, &GCPointCamera::SetNext)
        .addProperty("Parent", &GCPointCamera::GetParent, &GCPointCamera::SetParent)
        .addFunction("ToPtr", &GCPointCamera::ToPtr)
        .addFunction("IsValid", &GCPointCamera::IsValid)
        .endClass();
}
GCBodyComponentSkeletonInstance::GCBodyComponentSkeletonInstance(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCBodyComponentSkeletonInstance::GCBodyComponentSkeletonInstance(void *ptr) {
    m_ptr = ptr;
}
GCSkeletonInstance GCBodyComponentSkeletonInstance::GetSkeletonInstance() const {
    GCSkeletonInstance value(GetSchemaPtr(m_ptr, "CBodyComponentSkeletonInstance", "m_skeletonInstance"));
    return value;
}
void GCBodyComponentSkeletonInstance::SetSkeletonInstance(GCSkeletonInstance value) {
    SetSchemaValue(m_ptr, "CBodyComponentSkeletonInstance", "m_skeletonInstance", false, value);
}
std::string GCBodyComponentSkeletonInstance::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCBodyComponentSkeletonInstance::IsValid() {
    return (m_ptr != nullptr);
}
GCBodyComponent GCBodyComponentSkeletonInstance::GetParent() const {
    GCBodyComponent value(m_ptr);
    return value;
}
void GCBodyComponentSkeletonInstance::SetParent(GCBodyComponent value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCBodyComponentSkeletonInstance(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCBodyComponentSkeletonInstance>("CBodyComponentSkeletonInstance")
        .addConstructor<void (*)(std::string)>()
        .addProperty("SkeletonInstance", &GCBodyComponentSkeletonInstance::GetSkeletonInstance, &GCBodyComponentSkeletonInstance::SetSkeletonInstance)
        .addProperty("Parent", &GCBodyComponentSkeletonInstance::GetParent, &GCBodyComponentSkeletonInstance::SetParent)
        .addFunction("ToPtr", &GCBodyComponentSkeletonInstance::ToPtr)
        .addFunction("IsValid", &GCBodyComponentSkeletonInstance::IsValid)
        .endClass();
}
GCFuncLadderAlias_func_useableladder::GCFuncLadderAlias_func_useableladder(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCFuncLadderAlias_func_useableladder::GCFuncLadderAlias_func_useableladder(void *ptr) {
    m_ptr = ptr;
}
std::string GCFuncLadderAlias_func_useableladder::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCFuncLadderAlias_func_useableladder::IsValid() {
    return (m_ptr != nullptr);
}
GCFuncLadder GCFuncLadderAlias_func_useableladder::GetParent() const {
    GCFuncLadder value(m_ptr);
    return value;
}
void GCFuncLadderAlias_func_useableladder::SetParent(GCFuncLadder value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCFuncLadderAlias_func_useableladder(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCFuncLadderAlias_func_useableladder>("CFuncLadderAlias_func_useableladder")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCFuncLadderAlias_func_useableladder::GetParent, &GCFuncLadderAlias_func_useableladder::SetParent)
        .addFunction("ToPtr", &GCFuncLadderAlias_func_useableladder::ToPtr)
        .addFunction("IsValid", &GCFuncLadderAlias_func_useableladder::IsValid)
        .endClass();
}
GCBaseMoveBehavior::GCBaseMoveBehavior(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCBaseMoveBehavior::GCBaseMoveBehavior(void *ptr) {
    m_ptr = ptr;
}
int32_t GCBaseMoveBehavior::GetPositionInterpolator() const {
    return GetSchemaValue<int32_t>(m_ptr, "CBaseMoveBehavior", "m_iPositionInterpolator");
}
void GCBaseMoveBehavior::SetPositionInterpolator(int32_t value) {
    SetSchemaValue(m_ptr, "CBaseMoveBehavior", "m_iPositionInterpolator", false, value);
}
int32_t GCBaseMoveBehavior::GetRotationInterpolator() const {
    return GetSchemaValue<int32_t>(m_ptr, "CBaseMoveBehavior", "m_iRotationInterpolator");
}
void GCBaseMoveBehavior::SetRotationInterpolator(int32_t value) {
    SetSchemaValue(m_ptr, "CBaseMoveBehavior", "m_iRotationInterpolator", false, value);
}
float GCBaseMoveBehavior::GetAnimStartTime() const {
    return GetSchemaValue<float>(m_ptr, "CBaseMoveBehavior", "m_flAnimStartTime");
}
void GCBaseMoveBehavior::SetAnimStartTime(float value) {
    SetSchemaValue(m_ptr, "CBaseMoveBehavior", "m_flAnimStartTime", false, value);
}
float GCBaseMoveBehavior::GetAnimEndTime() const {
    return GetSchemaValue<float>(m_ptr, "CBaseMoveBehavior", "m_flAnimEndTime");
}
void GCBaseMoveBehavior::SetAnimEndTime(float value) {
    SetSchemaValue(m_ptr, "CBaseMoveBehavior", "m_flAnimEndTime", false, value);
}
float GCBaseMoveBehavior::GetAverageSpeedAcrossFrame() const {
    return GetSchemaValue<float>(m_ptr, "CBaseMoveBehavior", "m_flAverageSpeedAcrossFrame");
}
void GCBaseMoveBehavior::SetAverageSpeedAcrossFrame(float value) {
    SetSchemaValue(m_ptr, "CBaseMoveBehavior", "m_flAverageSpeedAcrossFrame", false, value);
}
GCPathKeyFrame GCBaseMoveBehavior::GetCurrentKeyFrame() const {
    GCPathKeyFrame value(*GetSchemaValuePtr<void*>(m_ptr, "CBaseMoveBehavior", "m_pCurrentKeyFrame"));
    return value;
}
void GCBaseMoveBehavior::SetCurrentKeyFrame(GCPathKeyFrame* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'CurrentKeyFrame' is not possible.\n");
}
GCPathKeyFrame GCBaseMoveBehavior::GetTargetKeyFrame() const {
    GCPathKeyFrame value(*GetSchemaValuePtr<void*>(m_ptr, "CBaseMoveBehavior", "m_pTargetKeyFrame"));
    return value;
}
void GCBaseMoveBehavior::SetTargetKeyFrame(GCPathKeyFrame* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'TargetKeyFrame' is not possible.\n");
}
GCPathKeyFrame GCBaseMoveBehavior::GetPreKeyFrame() const {
    GCPathKeyFrame value(*GetSchemaValuePtr<void*>(m_ptr, "CBaseMoveBehavior", "m_pPreKeyFrame"));
    return value;
}
void GCBaseMoveBehavior::SetPreKeyFrame(GCPathKeyFrame* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'PreKeyFrame' is not possible.\n");
}
GCPathKeyFrame GCBaseMoveBehavior::GetPostKeyFrame() const {
    GCPathKeyFrame value(*GetSchemaValuePtr<void*>(m_ptr, "CBaseMoveBehavior", "m_pPostKeyFrame"));
    return value;
}
void GCBaseMoveBehavior::SetPostKeyFrame(GCPathKeyFrame* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'PostKeyFrame' is not possible.\n");
}
float GCBaseMoveBehavior::GetTimeIntoFrame() const {
    return GetSchemaValue<float>(m_ptr, "CBaseMoveBehavior", "m_flTimeIntoFrame");
}
void GCBaseMoveBehavior::SetTimeIntoFrame(float value) {
    SetSchemaValue(m_ptr, "CBaseMoveBehavior", "m_flTimeIntoFrame", false, value);
}
int32_t GCBaseMoveBehavior::GetDirection() const {
    return GetSchemaValue<int32_t>(m_ptr, "CBaseMoveBehavior", "m_iDirection");
}
void GCBaseMoveBehavior::SetDirection(int32_t value) {
    SetSchemaValue(m_ptr, "CBaseMoveBehavior", "m_iDirection", false, value);
}
std::string GCBaseMoveBehavior::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCBaseMoveBehavior::IsValid() {
    return (m_ptr != nullptr);
}
GCPathKeyFrame GCBaseMoveBehavior::GetParent() const {
    GCPathKeyFrame value(m_ptr);
    return value;
}
void GCBaseMoveBehavior::SetParent(GCPathKeyFrame value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCBaseMoveBehavior(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCBaseMoveBehavior>("CBaseMoveBehavior")
        .addConstructor<void (*)(std::string)>()
        .addProperty("PositionInterpolator", &GCBaseMoveBehavior::GetPositionInterpolator, &GCBaseMoveBehavior::SetPositionInterpolator)
        .addProperty("RotationInterpolator", &GCBaseMoveBehavior::GetRotationInterpolator, &GCBaseMoveBehavior::SetRotationInterpolator)
        .addProperty("AnimStartTime", &GCBaseMoveBehavior::GetAnimStartTime, &GCBaseMoveBehavior::SetAnimStartTime)
        .addProperty("AnimEndTime", &GCBaseMoveBehavior::GetAnimEndTime, &GCBaseMoveBehavior::SetAnimEndTime)
        .addProperty("AverageSpeedAcrossFrame", &GCBaseMoveBehavior::GetAverageSpeedAcrossFrame, &GCBaseMoveBehavior::SetAverageSpeedAcrossFrame)
        .addProperty("CurrentKeyFrame", &GCBaseMoveBehavior::GetCurrentKeyFrame, &GCBaseMoveBehavior::SetCurrentKeyFrame)
        .addProperty("TargetKeyFrame", &GCBaseMoveBehavior::GetTargetKeyFrame, &GCBaseMoveBehavior::SetTargetKeyFrame)
        .addProperty("PreKeyFrame", &GCBaseMoveBehavior::GetPreKeyFrame, &GCBaseMoveBehavior::SetPreKeyFrame)
        .addProperty("PostKeyFrame", &GCBaseMoveBehavior::GetPostKeyFrame, &GCBaseMoveBehavior::SetPostKeyFrame)
        .addProperty("TimeIntoFrame", &GCBaseMoveBehavior::GetTimeIntoFrame, &GCBaseMoveBehavior::SetTimeIntoFrame)
        .addProperty("Direction", &GCBaseMoveBehavior::GetDirection, &GCBaseMoveBehavior::SetDirection)
        .addProperty("Parent", &GCBaseMoveBehavior::GetParent, &GCBaseMoveBehavior::SetParent)
        .addFunction("ToPtr", &GCBaseMoveBehavior::ToPtr)
        .addFunction("IsValid", &GCBaseMoveBehavior::IsValid)
        .endClass();
}
GCFuncInteractionLayerClip::GCFuncInteractionLayerClip(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCFuncInteractionLayerClip::GCFuncInteractionLayerClip(void *ptr) {
    m_ptr = ptr;
}
bool GCFuncInteractionLayerClip::GetDisabled() const {
    return GetSchemaValue<bool>(m_ptr, "CFuncInteractionLayerClip", "m_bDisabled");
}
void GCFuncInteractionLayerClip::SetDisabled(bool value) {
    SetSchemaValue(m_ptr, "CFuncInteractionLayerClip", "m_bDisabled", false, value);
}
std::string GCFuncInteractionLayerClip::GetInteractsAs() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CFuncInteractionLayerClip", "m_iszInteractsAs").String();
}
void GCFuncInteractionLayerClip::SetInteractsAs(std::string value) {
    SetSchemaValue(m_ptr, "CFuncInteractionLayerClip", "m_iszInteractsAs", false, CUtlSymbolLarge(value.c_str()));
}
std::string GCFuncInteractionLayerClip::GetInteractsWith() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CFuncInteractionLayerClip", "m_iszInteractsWith").String();
}
void GCFuncInteractionLayerClip::SetInteractsWith(std::string value) {
    SetSchemaValue(m_ptr, "CFuncInteractionLayerClip", "m_iszInteractsWith", false, CUtlSymbolLarge(value.c_str()));
}
std::string GCFuncInteractionLayerClip::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCFuncInteractionLayerClip::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseModelEntity GCFuncInteractionLayerClip::GetParent() const {
    GCBaseModelEntity value(m_ptr);
    return value;
}
void GCFuncInteractionLayerClip::SetParent(GCBaseModelEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCFuncInteractionLayerClip(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCFuncInteractionLayerClip>("CFuncInteractionLayerClip")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Disabled", &GCFuncInteractionLayerClip::GetDisabled, &GCFuncInteractionLayerClip::SetDisabled)
        .addProperty("InteractsAs", &GCFuncInteractionLayerClip::GetInteractsAs, &GCFuncInteractionLayerClip::SetInteractsAs)
        .addProperty("InteractsWith", &GCFuncInteractionLayerClip::GetInteractsWith, &GCFuncInteractionLayerClip::SetInteractsWith)
        .addProperty("Parent", &GCFuncInteractionLayerClip::GetParent, &GCFuncInteractionLayerClip::SetParent)
        .addFunction("ToPtr", &GCFuncInteractionLayerClip::ToPtr)
        .addFunction("IsValid", &GCFuncInteractionLayerClip::IsValid)
        .endClass();
}
GCWeaponMAC10::GCWeaponMAC10(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCWeaponMAC10::GCWeaponMAC10(void *ptr) {
    m_ptr = ptr;
}
std::string GCWeaponMAC10::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCWeaponMAC10::IsValid() {
    return (m_ptr != nullptr);
}
GCCSWeaponBaseGun GCWeaponMAC10::GetParent() const {
    GCCSWeaponBaseGun value(m_ptr);
    return value;
}
void GCWeaponMAC10::SetParent(GCCSWeaponBaseGun value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCWeaponMAC10(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCWeaponMAC10>("CWeaponMAC10")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCWeaponMAC10::GetParent, &GCWeaponMAC10::SetParent)
        .addFunction("ToPtr", &GCWeaponMAC10::ToPtr)
        .addFunction("IsValid", &GCWeaponMAC10::IsValid)
        .endClass();
}
GCGameRules::GCGameRules(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCGameRules::GCGameRules(void *ptr) {
    m_ptr = ptr;
}
GCNetworkVarChainer GCGameRules::Get__pChainEntity() const {
    GCNetworkVarChainer value(GetSchemaPtr(m_ptr, "CGameRules", "__m_pChainEntity"));
    return value;
}
void GCGameRules::Set__pChainEntity(GCNetworkVarChainer value) {
    SetSchemaValue(m_ptr, "CGameRules", "__m_pChainEntity", false, value);
}
std::string GCGameRules::GetQuestName() const {
    return GetSchemaValuePtr<char>(m_ptr, "CGameRules", "m_szQuestName");
}
void GCGameRules::SetQuestName(std::string value) {
    WriteSchemaPtrValue(m_ptr, "CGameRules", "m_szQuestName", false, reinterpret_cast<byte*>(const_cast<char*>(value.c_str())), 128);
}
int32_t GCGameRules::GetQuestPhase() const {
    return GetSchemaValue<int32_t>(m_ptr, "CGameRules", "m_nQuestPhase");
}
void GCGameRules::SetQuestPhase(int32_t value) {
    SetSchemaValue(m_ptr, "CGameRules", "m_nQuestPhase", false, value);
}
int32_t GCGameRules::GetTotalPausedTicks() const {
    return GetSchemaValue<int32_t>(m_ptr, "CGameRules", "m_nTotalPausedTicks");
}
void GCGameRules::SetTotalPausedTicks(int32_t value) {
    SetSchemaValue(m_ptr, "CGameRules", "m_nTotalPausedTicks", false, value);
}
int32_t GCGameRules::GetPauseStartTick() const {
    return GetSchemaValue<int32_t>(m_ptr, "CGameRules", "m_nPauseStartTick");
}
void GCGameRules::SetPauseStartTick(int32_t value) {
    SetSchemaValue(m_ptr, "CGameRules", "m_nPauseStartTick", false, value);
}
bool GCGameRules::GetGamePaused() const {
    return GetSchemaValue<bool>(m_ptr, "CGameRules", "m_bGamePaused");
}
void GCGameRules::SetGamePaused(bool value) {
    SetSchemaValue(m_ptr, "CGameRules", "m_bGamePaused", false, value);
}
std::string GCGameRules::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCGameRules::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCGameRules(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCGameRules>("CGameRules")
        .addConstructor<void (*)(std::string)>()
        .addProperty("__pChainEntity", &GCGameRules::Get__pChainEntity, &GCGameRules::Set__pChainEntity)
        .addProperty("QuestName", &GCGameRules::GetQuestName, &GCGameRules::SetQuestName)
        .addProperty("QuestPhase", &GCGameRules::GetQuestPhase, &GCGameRules::SetQuestPhase)
        .addProperty("TotalPausedTicks", &GCGameRules::GetTotalPausedTicks, &GCGameRules::SetTotalPausedTicks)
        .addProperty("PauseStartTick", &GCGameRules::GetPauseStartTick, &GCGameRules::SetPauseStartTick)
        .addProperty("GamePaused", &GCGameRules::GetGamePaused, &GCGameRules::SetGamePaused)
        .addFunction("ToPtr", &GCGameRules::ToPtr)
        .addFunction("IsValid", &GCGameRules::IsValid)
        .endClass();
}
GCWeaponRevolver::GCWeaponRevolver(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCWeaponRevolver::GCWeaponRevolver(void *ptr) {
    m_ptr = ptr;
}
std::string GCWeaponRevolver::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCWeaponRevolver::IsValid() {
    return (m_ptr != nullptr);
}
GCCSWeaponBaseGun GCWeaponRevolver::GetParent() const {
    GCCSWeaponBaseGun value(m_ptr);
    return value;
}
void GCWeaponRevolver::SetParent(GCCSWeaponBaseGun value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCWeaponRevolver(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCWeaponRevolver>("CWeaponRevolver")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCWeaponRevolver::GetParent, &GCWeaponRevolver::SetParent)
        .addFunction("ToPtr", &GCWeaponRevolver::ToPtr)
        .addFunction("IsValid", &GCWeaponRevolver::IsValid)
        .endClass();
}
GCOrnamentProp::GCOrnamentProp(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCOrnamentProp::GCOrnamentProp(void *ptr) {
    m_ptr = ptr;
}
std::string GCOrnamentProp::GetInitialOwner() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "COrnamentProp", "m_initialOwner").String();
}
void GCOrnamentProp::SetInitialOwner(std::string value) {
    SetSchemaValue(m_ptr, "COrnamentProp", "m_initialOwner", false, CUtlSymbolLarge(value.c_str()));
}
std::string GCOrnamentProp::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCOrnamentProp::IsValid() {
    return (m_ptr != nullptr);
}
GCDynamicProp GCOrnamentProp::GetParent() const {
    GCDynamicProp value(m_ptr);
    return value;
}
void GCOrnamentProp::SetParent(GCDynamicProp value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCOrnamentProp(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCOrnamentProp>("COrnamentProp")
        .addConstructor<void (*)(std::string)>()
        .addProperty("InitialOwner", &GCOrnamentProp::GetInitialOwner, &GCOrnamentProp::SetInitialOwner)
        .addProperty("Parent", &GCOrnamentProp::GetParent, &GCOrnamentProp::SetParent)
        .addFunction("ToPtr", &GCOrnamentProp::ToPtr)
        .addFunction("IsValid", &GCOrnamentProp::IsValid)
        .endClass();
}
GCLogicGameEvent::GCLogicGameEvent(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCLogicGameEvent::GCLogicGameEvent(void *ptr) {
    m_ptr = ptr;
}
std::string GCLogicGameEvent::GetEventName() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CLogicGameEvent", "m_iszEventName").String();
}
void GCLogicGameEvent::SetEventName(std::string value) {
    SetSchemaValue(m_ptr, "CLogicGameEvent", "m_iszEventName", false, CUtlSymbolLarge(value.c_str()));
}
std::string GCLogicGameEvent::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCLogicGameEvent::IsValid() {
    return (m_ptr != nullptr);
}
GCLogicalEntity GCLogicGameEvent::GetParent() const {
    GCLogicalEntity value(m_ptr);
    return value;
}
void GCLogicGameEvent::SetParent(GCLogicalEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCLogicGameEvent(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCLogicGameEvent>("CLogicGameEvent")
        .addConstructor<void (*)(std::string)>()
        .addProperty("EventName", &GCLogicGameEvent::GetEventName, &GCLogicGameEvent::SetEventName)
        .addProperty("Parent", &GCLogicGameEvent::GetParent, &GCLogicGameEvent::SetParent)
        .addFunction("ToPtr", &GCLogicGameEvent::ToPtr)
        .addFunction("IsValid", &GCLogicGameEvent::IsValid)
        .endClass();
}
GCEnvMuzzleFlash::GCEnvMuzzleFlash(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCEnvMuzzleFlash::GCEnvMuzzleFlash(void *ptr) {
    m_ptr = ptr;
}
float GCEnvMuzzleFlash::GetScale() const {
    return GetSchemaValue<float>(m_ptr, "CEnvMuzzleFlash", "m_flScale");
}
void GCEnvMuzzleFlash::SetScale(float value) {
    SetSchemaValue(m_ptr, "CEnvMuzzleFlash", "m_flScale", false, value);
}
std::string GCEnvMuzzleFlash::GetParentAttachment() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CEnvMuzzleFlash", "m_iszParentAttachment").String();
}
void GCEnvMuzzleFlash::SetParentAttachment(std::string value) {
    SetSchemaValue(m_ptr, "CEnvMuzzleFlash", "m_iszParentAttachment", false, CUtlSymbolLarge(value.c_str()));
}
std::string GCEnvMuzzleFlash::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCEnvMuzzleFlash::IsValid() {
    return (m_ptr != nullptr);
}
GCPointEntity GCEnvMuzzleFlash::GetParent() const {
    GCPointEntity value(m_ptr);
    return value;
}
void GCEnvMuzzleFlash::SetParent(GCPointEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCEnvMuzzleFlash(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCEnvMuzzleFlash>("CEnvMuzzleFlash")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Scale", &GCEnvMuzzleFlash::GetScale, &GCEnvMuzzleFlash::SetScale)
        .addProperty("ParentAttachment", &GCEnvMuzzleFlash::GetParentAttachment, &GCEnvMuzzleFlash::SetParentAttachment)
        .addProperty("Parent", &GCEnvMuzzleFlash::GetParent, &GCEnvMuzzleFlash::SetParent)
        .addFunction("ToPtr", &GCEnvMuzzleFlash::ToPtr)
        .addFunction("IsValid", &GCEnvMuzzleFlash::IsValid)
        .endClass();
}
GCPlayerSprayDecal::GCPlayerSprayDecal(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCPlayerSprayDecal::GCPlayerSprayDecal(void *ptr) {
    m_ptr = ptr;
}
int32_t GCPlayerSprayDecal::GetUniqueID() const {
    return GetSchemaValue<int32_t>(m_ptr, "CPlayerSprayDecal", "m_nUniqueID");
}
void GCPlayerSprayDecal::SetUniqueID(int32_t value) {
    SetSchemaValue(m_ptr, "CPlayerSprayDecal", "m_nUniqueID", false, value);
}
uint32_t GCPlayerSprayDecal::GetAccountID() const {
    return GetSchemaValue<uint32_t>(m_ptr, "CPlayerSprayDecal", "m_unAccountID");
}
void GCPlayerSprayDecal::SetAccountID(uint32_t value) {
    SetSchemaValue(m_ptr, "CPlayerSprayDecal", "m_unAccountID", false, value);
}
uint32_t GCPlayerSprayDecal::GetTraceID() const {
    return GetSchemaValue<uint32_t>(m_ptr, "CPlayerSprayDecal", "m_unTraceID");
}
void GCPlayerSprayDecal::SetTraceID(uint32_t value) {
    SetSchemaValue(m_ptr, "CPlayerSprayDecal", "m_unTraceID", false, value);
}
uint32_t GCPlayerSprayDecal::GetRtGcTime() const {
    return GetSchemaValue<uint32_t>(m_ptr, "CPlayerSprayDecal", "m_rtGcTime");
}
void GCPlayerSprayDecal::SetRtGcTime(uint32_t value) {
    SetSchemaValue(m_ptr, "CPlayerSprayDecal", "m_rtGcTime", false, value);
}
Vector GCPlayerSprayDecal::GetEndPos() const {
    return GetSchemaValue<Vector>(m_ptr, "CPlayerSprayDecal", "m_vecEndPos");
}
void GCPlayerSprayDecal::SetEndPos(Vector value) {
    SetSchemaValue(m_ptr, "CPlayerSprayDecal", "m_vecEndPos", false, value);
}
Vector GCPlayerSprayDecal::GetStart() const {
    return GetSchemaValue<Vector>(m_ptr, "CPlayerSprayDecal", "m_vecStart");
}
void GCPlayerSprayDecal::SetStart(Vector value) {
    SetSchemaValue(m_ptr, "CPlayerSprayDecal", "m_vecStart", false, value);
}
Vector GCPlayerSprayDecal::GetLeft() const {
    return GetSchemaValue<Vector>(m_ptr, "CPlayerSprayDecal", "m_vecLeft");
}
void GCPlayerSprayDecal::SetLeft(Vector value) {
    SetSchemaValue(m_ptr, "CPlayerSprayDecal", "m_vecLeft", false, value);
}
Vector GCPlayerSprayDecal::GetNormal() const {
    return GetSchemaValue<Vector>(m_ptr, "CPlayerSprayDecal", "m_vecNormal");
}
void GCPlayerSprayDecal::SetNormal(Vector value) {
    SetSchemaValue(m_ptr, "CPlayerSprayDecal", "m_vecNormal", false, value);
}
int32_t GCPlayerSprayDecal::GetPlayer() const {
    return GetSchemaValue<int32_t>(m_ptr, "CPlayerSprayDecal", "m_nPlayer");
}
void GCPlayerSprayDecal::SetPlayer(int32_t value) {
    SetSchemaValue(m_ptr, "CPlayerSprayDecal", "m_nPlayer", false, value);
}
int32_t GCPlayerSprayDecal::GetEntity() const {
    return GetSchemaValue<int32_t>(m_ptr, "CPlayerSprayDecal", "m_nEntity");
}
void GCPlayerSprayDecal::SetEntity(int32_t value) {
    SetSchemaValue(m_ptr, "CPlayerSprayDecal", "m_nEntity", false, value);
}
int32_t GCPlayerSprayDecal::GetHitbox() const {
    return GetSchemaValue<int32_t>(m_ptr, "CPlayerSprayDecal", "m_nHitbox");
}
void GCPlayerSprayDecal::SetHitbox(int32_t value) {
    SetSchemaValue(m_ptr, "CPlayerSprayDecal", "m_nHitbox", false, value);
}
float GCPlayerSprayDecal::GetCreationTime() const {
    return GetSchemaValue<float>(m_ptr, "CPlayerSprayDecal", "m_flCreationTime");
}
void GCPlayerSprayDecal::SetCreationTime(float value) {
    SetSchemaValue(m_ptr, "CPlayerSprayDecal", "m_flCreationTime", false, value);
}
int32_t GCPlayerSprayDecal::GetTintID() const {
    return GetSchemaValue<int32_t>(m_ptr, "CPlayerSprayDecal", "m_nTintID");
}
void GCPlayerSprayDecal::SetTintID(int32_t value) {
    SetSchemaValue(m_ptr, "CPlayerSprayDecal", "m_nTintID", false, value);
}
uint8_t GCPlayerSprayDecal::GetVersion() const {
    return GetSchemaValue<uint8_t>(m_ptr, "CPlayerSprayDecal", "m_nVersion");
}
void GCPlayerSprayDecal::SetVersion(uint8_t value) {
    SetSchemaValue(m_ptr, "CPlayerSprayDecal", "m_nVersion", false, value);
}
std::vector<uint8_t> GCPlayerSprayDecal::GetSignature() const {
    uint8_t* outValue = GetSchemaValue<uint8_t*>(m_ptr, "CPlayerSprayDecal", "m_ubSignature"); std::vector<uint8_t> ret; for(int i = 0; i < 128; i++) { ret.push_back(outValue[i]); } return ret;
}
void GCPlayerSprayDecal::SetSignature(std::vector<uint8_t> value) {
    uint8_t* outValue = GetSchemaValue<uint8_t*>(m_ptr, "CPlayerSprayDecal", "m_ubSignature"); for(int i = 0; i < 128; i++) { outValue[i] = value[i]; } SetSchemaValue(m_ptr, "CPlayerSprayDecal", "m_ubSignature", false, outValue);
}
std::string GCPlayerSprayDecal::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCPlayerSprayDecal::IsValid() {
    return (m_ptr != nullptr);
}
GCModelPointEntity GCPlayerSprayDecal::GetParent() const {
    GCModelPointEntity value(m_ptr);
    return value;
}
void GCPlayerSprayDecal::SetParent(GCModelPointEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCPlayerSprayDecal(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCPlayerSprayDecal>("CPlayerSprayDecal")
        .addConstructor<void (*)(std::string)>()
        .addProperty("UniqueID", &GCPlayerSprayDecal::GetUniqueID, &GCPlayerSprayDecal::SetUniqueID)
        .addProperty("AccountID", &GCPlayerSprayDecal::GetAccountID, &GCPlayerSprayDecal::SetAccountID)
        .addProperty("TraceID", &GCPlayerSprayDecal::GetTraceID, &GCPlayerSprayDecal::SetTraceID)
        .addProperty("RtGcTime", &GCPlayerSprayDecal::GetRtGcTime, &GCPlayerSprayDecal::SetRtGcTime)
        .addProperty("EndPos", &GCPlayerSprayDecal::GetEndPos, &GCPlayerSprayDecal::SetEndPos)
        .addProperty("Start", &GCPlayerSprayDecal::GetStart, &GCPlayerSprayDecal::SetStart)
        .addProperty("Left", &GCPlayerSprayDecal::GetLeft, &GCPlayerSprayDecal::SetLeft)
        .addProperty("Normal", &GCPlayerSprayDecal::GetNormal, &GCPlayerSprayDecal::SetNormal)
        .addProperty("Player", &GCPlayerSprayDecal::GetPlayer, &GCPlayerSprayDecal::SetPlayer)
        .addProperty("Entity", &GCPlayerSprayDecal::GetEntity, &GCPlayerSprayDecal::SetEntity)
        .addProperty("Hitbox", &GCPlayerSprayDecal::GetHitbox, &GCPlayerSprayDecal::SetHitbox)
        .addProperty("CreationTime", &GCPlayerSprayDecal::GetCreationTime, &GCPlayerSprayDecal::SetCreationTime)
        .addProperty("TintID", &GCPlayerSprayDecal::GetTintID, &GCPlayerSprayDecal::SetTintID)
        .addProperty("Version", &GCPlayerSprayDecal::GetVersion, &GCPlayerSprayDecal::SetVersion)
        .addProperty("Signature", &GCPlayerSprayDecal::GetSignature, &GCPlayerSprayDecal::SetSignature)
        .addProperty("Parent", &GCPlayerSprayDecal::GetParent, &GCPlayerSprayDecal::SetParent)
        .addFunction("ToPtr", &GCPlayerSprayDecal::ToPtr)
        .addFunction("IsValid", &GCPlayerSprayDecal::IsValid)
        .endClass();
}
GCBombTarget::GCBombTarget(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCBombTarget::GCBombTarget(void *ptr) {
    m_ptr = ptr;
}
GCEntityIOOutput GCBombTarget::GetOnBombExplode() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CBombTarget", "m_OnBombExplode"));
    return value;
}
void GCBombTarget::SetOnBombExplode(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CBombTarget", "m_OnBombExplode", false, value);
}
GCEntityIOOutput GCBombTarget::GetOnBombPlanted() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CBombTarget", "m_OnBombPlanted"));
    return value;
}
void GCBombTarget::SetOnBombPlanted(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CBombTarget", "m_OnBombPlanted", false, value);
}
GCEntityIOOutput GCBombTarget::GetOnBombDefused() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CBombTarget", "m_OnBombDefused"));
    return value;
}
void GCBombTarget::SetOnBombDefused(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CBombTarget", "m_OnBombDefused", false, value);
}
bool GCBombTarget::GetIsBombSiteB() const {
    return GetSchemaValue<bool>(m_ptr, "CBombTarget", "m_bIsBombSiteB");
}
void GCBombTarget::SetIsBombSiteB(bool value) {
    SetSchemaValue(m_ptr, "CBombTarget", "m_bIsBombSiteB", false, value);
}
bool GCBombTarget::GetIsHeistBombTarget() const {
    return GetSchemaValue<bool>(m_ptr, "CBombTarget", "m_bIsHeistBombTarget");
}
void GCBombTarget::SetIsHeistBombTarget(bool value) {
    SetSchemaValue(m_ptr, "CBombTarget", "m_bIsHeistBombTarget", false, value);
}
bool GCBombTarget::GetBombPlantedHere() const {
    return GetSchemaValue<bool>(m_ptr, "CBombTarget", "m_bBombPlantedHere");
}
void GCBombTarget::SetBombPlantedHere(bool value) {
    SetSchemaValue(m_ptr, "CBombTarget", "m_bBombPlantedHere", false, value);
}
std::string GCBombTarget::GetMountTarget() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CBombTarget", "m_szMountTarget").String();
}
void GCBombTarget::SetMountTarget(std::string value) {
    SetSchemaValue(m_ptr, "CBombTarget", "m_szMountTarget", false, CUtlSymbolLarge(value.c_str()));
}
GCBaseEntity GCBombTarget::GetInstructorHint() const {
    GCBaseEntity value(*GetSchemaValuePtr<void*>(m_ptr, "CBombTarget", "m_hInstructorHint"));
    return value;
}
void GCBombTarget::SetInstructorHint(GCBaseEntity* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'InstructorHint' is not possible.\n");
}
int32_t GCBombTarget::GetBombSiteDesignation() const {
    return GetSchemaValue<int32_t>(m_ptr, "CBombTarget", "m_nBombSiteDesignation");
}
void GCBombTarget::SetBombSiteDesignation(int32_t value) {
    SetSchemaValue(m_ptr, "CBombTarget", "m_nBombSiteDesignation", false, value);
}
std::string GCBombTarget::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCBombTarget::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseTrigger GCBombTarget::GetParent() const {
    GCBaseTrigger value(m_ptr);
    return value;
}
void GCBombTarget::SetParent(GCBaseTrigger value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCBombTarget(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCBombTarget>("CBombTarget")
        .addConstructor<void (*)(std::string)>()
        .addProperty("OnBombExplode", &GCBombTarget::GetOnBombExplode, &GCBombTarget::SetOnBombExplode)
        .addProperty("OnBombPlanted", &GCBombTarget::GetOnBombPlanted, &GCBombTarget::SetOnBombPlanted)
        .addProperty("OnBombDefused", &GCBombTarget::GetOnBombDefused, &GCBombTarget::SetOnBombDefused)
        .addProperty("IsBombSiteB", &GCBombTarget::GetIsBombSiteB, &GCBombTarget::SetIsBombSiteB)
        .addProperty("IsHeistBombTarget", &GCBombTarget::GetIsHeistBombTarget, &GCBombTarget::SetIsHeistBombTarget)
        .addProperty("BombPlantedHere", &GCBombTarget::GetBombPlantedHere, &GCBombTarget::SetBombPlantedHere)
        .addProperty("MountTarget", &GCBombTarget::GetMountTarget, &GCBombTarget::SetMountTarget)
        .addProperty("InstructorHint", &GCBombTarget::GetInstructorHint, &GCBombTarget::SetInstructorHint)
        .addProperty("BombSiteDesignation", &GCBombTarget::GetBombSiteDesignation, &GCBombTarget::SetBombSiteDesignation)
        .addProperty("Parent", &GCBombTarget::GetParent, &GCBombTarget::SetParent)
        .addFunction("ToPtr", &GCBombTarget::ToPtr)
        .addFunction("IsValid", &GCBombTarget::IsValid)
        .endClass();
}
GCPhysicsSpring::GCPhysicsSpring(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCPhysicsSpring::GCPhysicsSpring(void *ptr) {
    m_ptr = ptr;
}
float GCPhysicsSpring::GetFrequency() const {
    return GetSchemaValue<float>(m_ptr, "CPhysicsSpring", "m_flFrequency");
}
void GCPhysicsSpring::SetFrequency(float value) {
    SetSchemaValue(m_ptr, "CPhysicsSpring", "m_flFrequency", false, value);
}
float GCPhysicsSpring::GetDampingRatio() const {
    return GetSchemaValue<float>(m_ptr, "CPhysicsSpring", "m_flDampingRatio");
}
void GCPhysicsSpring::SetDampingRatio(float value) {
    SetSchemaValue(m_ptr, "CPhysicsSpring", "m_flDampingRatio", false, value);
}
float GCPhysicsSpring::GetRestLength() const {
    return GetSchemaValue<float>(m_ptr, "CPhysicsSpring", "m_flRestLength");
}
void GCPhysicsSpring::SetRestLength(float value) {
    SetSchemaValue(m_ptr, "CPhysicsSpring", "m_flRestLength", false, value);
}
std::string GCPhysicsSpring::GetNameAttachStart() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CPhysicsSpring", "m_nameAttachStart").String();
}
void GCPhysicsSpring::SetNameAttachStart(std::string value) {
    SetSchemaValue(m_ptr, "CPhysicsSpring", "m_nameAttachStart", false, CUtlSymbolLarge(value.c_str()));
}
std::string GCPhysicsSpring::GetNameAttachEnd() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CPhysicsSpring", "m_nameAttachEnd").String();
}
void GCPhysicsSpring::SetNameAttachEnd(std::string value) {
    SetSchemaValue(m_ptr, "CPhysicsSpring", "m_nameAttachEnd", false, CUtlSymbolLarge(value.c_str()));
}
Vector GCPhysicsSpring::GetStart() const {
    return GetSchemaValue<Vector>(m_ptr, "CPhysicsSpring", "m_start");
}
void GCPhysicsSpring::SetStart(Vector value) {
    SetSchemaValue(m_ptr, "CPhysicsSpring", "m_start", false, value);
}
Vector GCPhysicsSpring::GetEnd() const {
    return GetSchemaValue<Vector>(m_ptr, "CPhysicsSpring", "m_end");
}
void GCPhysicsSpring::SetEnd(Vector value) {
    SetSchemaValue(m_ptr, "CPhysicsSpring", "m_end", false, value);
}
uint32_t GCPhysicsSpring::GetTeleportTick() const {
    return GetSchemaValue<uint32_t>(m_ptr, "CPhysicsSpring", "m_teleportTick");
}
void GCPhysicsSpring::SetTeleportTick(uint32_t value) {
    SetSchemaValue(m_ptr, "CPhysicsSpring", "m_teleportTick", false, value);
}
std::string GCPhysicsSpring::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCPhysicsSpring::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseEntity GCPhysicsSpring::GetParent() const {
    GCBaseEntity value(m_ptr);
    return value;
}
void GCPhysicsSpring::SetParent(GCBaseEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCPhysicsSpring(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCPhysicsSpring>("CPhysicsSpring")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Frequency", &GCPhysicsSpring::GetFrequency, &GCPhysicsSpring::SetFrequency)
        .addProperty("DampingRatio", &GCPhysicsSpring::GetDampingRatio, &GCPhysicsSpring::SetDampingRatio)
        .addProperty("RestLength", &GCPhysicsSpring::GetRestLength, &GCPhysicsSpring::SetRestLength)
        .addProperty("NameAttachStart", &GCPhysicsSpring::GetNameAttachStart, &GCPhysicsSpring::SetNameAttachStart)
        .addProperty("NameAttachEnd", &GCPhysicsSpring::GetNameAttachEnd, &GCPhysicsSpring::SetNameAttachEnd)
        .addProperty("Start", &GCPhysicsSpring::GetStart, &GCPhysicsSpring::SetStart)
        .addProperty("End", &GCPhysicsSpring::GetEnd, &GCPhysicsSpring::SetEnd)
        .addProperty("TeleportTick", &GCPhysicsSpring::GetTeleportTick, &GCPhysicsSpring::SetTeleportTick)
        .addProperty("Parent", &GCPhysicsSpring::GetParent, &GCPhysicsSpring::SetParent)
        .addFunction("ToPtr", &GCPhysicsSpring::ToPtr)
        .addFunction("IsValid", &GCPhysicsSpring::IsValid)
        .endClass();
}
GCEnvLightProbeVolume::GCEnvLightProbeVolume(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCEnvLightProbeVolume::GCEnvLightProbeVolume(void *ptr) {
    m_ptr = ptr;
}
Vector GCEnvLightProbeVolume::GetEntity_vBoxMins() const {
    return GetSchemaValue<Vector>(m_ptr, "CEnvLightProbeVolume", "m_Entity_vBoxMins");
}
void GCEnvLightProbeVolume::SetEntity_vBoxMins(Vector value) {
    SetSchemaValue(m_ptr, "CEnvLightProbeVolume", "m_Entity_vBoxMins", false, value);
}
Vector GCEnvLightProbeVolume::GetEntity_vBoxMaxs() const {
    return GetSchemaValue<Vector>(m_ptr, "CEnvLightProbeVolume", "m_Entity_vBoxMaxs");
}
void GCEnvLightProbeVolume::SetEntity_vBoxMaxs(Vector value) {
    SetSchemaValue(m_ptr, "CEnvLightProbeVolume", "m_Entity_vBoxMaxs", false, value);
}
bool GCEnvLightProbeVolume::GetEntity_bMoveable() const {
    return GetSchemaValue<bool>(m_ptr, "CEnvLightProbeVolume", "m_Entity_bMoveable");
}
void GCEnvLightProbeVolume::SetEntity_bMoveable(bool value) {
    SetSchemaValue(m_ptr, "CEnvLightProbeVolume", "m_Entity_bMoveable", false, value);
}
int32_t GCEnvLightProbeVolume::GetEntity_nHandshake() const {
    return GetSchemaValue<int32_t>(m_ptr, "CEnvLightProbeVolume", "m_Entity_nHandshake");
}
void GCEnvLightProbeVolume::SetEntity_nHandshake(int32_t value) {
    SetSchemaValue(m_ptr, "CEnvLightProbeVolume", "m_Entity_nHandshake", false, value);
}
int32_t GCEnvLightProbeVolume::GetEntity_nPriority() const {
    return GetSchemaValue<int32_t>(m_ptr, "CEnvLightProbeVolume", "m_Entity_nPriority");
}
void GCEnvLightProbeVolume::SetEntity_nPriority(int32_t value) {
    SetSchemaValue(m_ptr, "CEnvLightProbeVolume", "m_Entity_nPriority", false, value);
}
bool GCEnvLightProbeVolume::GetEntity_bStartDisabled() const {
    return GetSchemaValue<bool>(m_ptr, "CEnvLightProbeVolume", "m_Entity_bStartDisabled");
}
void GCEnvLightProbeVolume::SetEntity_bStartDisabled(bool value) {
    SetSchemaValue(m_ptr, "CEnvLightProbeVolume", "m_Entity_bStartDisabled", false, value);
}
int32_t GCEnvLightProbeVolume::GetEntity_nLightProbeSizeX() const {
    return GetSchemaValue<int32_t>(m_ptr, "CEnvLightProbeVolume", "m_Entity_nLightProbeSizeX");
}
void GCEnvLightProbeVolume::SetEntity_nLightProbeSizeX(int32_t value) {
    SetSchemaValue(m_ptr, "CEnvLightProbeVolume", "m_Entity_nLightProbeSizeX", false, value);
}
int32_t GCEnvLightProbeVolume::GetEntity_nLightProbeSizeY() const {
    return GetSchemaValue<int32_t>(m_ptr, "CEnvLightProbeVolume", "m_Entity_nLightProbeSizeY");
}
void GCEnvLightProbeVolume::SetEntity_nLightProbeSizeY(int32_t value) {
    SetSchemaValue(m_ptr, "CEnvLightProbeVolume", "m_Entity_nLightProbeSizeY", false, value);
}
int32_t GCEnvLightProbeVolume::GetEntity_nLightProbeSizeZ() const {
    return GetSchemaValue<int32_t>(m_ptr, "CEnvLightProbeVolume", "m_Entity_nLightProbeSizeZ");
}
void GCEnvLightProbeVolume::SetEntity_nLightProbeSizeZ(int32_t value) {
    SetSchemaValue(m_ptr, "CEnvLightProbeVolume", "m_Entity_nLightProbeSizeZ", false, value);
}
int32_t GCEnvLightProbeVolume::GetEntity_nLightProbeAtlasX() const {
    return GetSchemaValue<int32_t>(m_ptr, "CEnvLightProbeVolume", "m_Entity_nLightProbeAtlasX");
}
void GCEnvLightProbeVolume::SetEntity_nLightProbeAtlasX(int32_t value) {
    SetSchemaValue(m_ptr, "CEnvLightProbeVolume", "m_Entity_nLightProbeAtlasX", false, value);
}
int32_t GCEnvLightProbeVolume::GetEntity_nLightProbeAtlasY() const {
    return GetSchemaValue<int32_t>(m_ptr, "CEnvLightProbeVolume", "m_Entity_nLightProbeAtlasY");
}
void GCEnvLightProbeVolume::SetEntity_nLightProbeAtlasY(int32_t value) {
    SetSchemaValue(m_ptr, "CEnvLightProbeVolume", "m_Entity_nLightProbeAtlasY", false, value);
}
int32_t GCEnvLightProbeVolume::GetEntity_nLightProbeAtlasZ() const {
    return GetSchemaValue<int32_t>(m_ptr, "CEnvLightProbeVolume", "m_Entity_nLightProbeAtlasZ");
}
void GCEnvLightProbeVolume::SetEntity_nLightProbeAtlasZ(int32_t value) {
    SetSchemaValue(m_ptr, "CEnvLightProbeVolume", "m_Entity_nLightProbeAtlasZ", false, value);
}
bool GCEnvLightProbeVolume::GetEntity_bEnabled() const {
    return GetSchemaValue<bool>(m_ptr, "CEnvLightProbeVolume", "m_Entity_bEnabled");
}
void GCEnvLightProbeVolume::SetEntity_bEnabled(bool value) {
    SetSchemaValue(m_ptr, "CEnvLightProbeVolume", "m_Entity_bEnabled", false, value);
}
std::string GCEnvLightProbeVolume::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCEnvLightProbeVolume::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseEntity GCEnvLightProbeVolume::GetParent() const {
    GCBaseEntity value(m_ptr);
    return value;
}
void GCEnvLightProbeVolume::SetParent(GCBaseEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCEnvLightProbeVolume(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCEnvLightProbeVolume>("CEnvLightProbeVolume")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Entity_vBoxMins", &GCEnvLightProbeVolume::GetEntity_vBoxMins, &GCEnvLightProbeVolume::SetEntity_vBoxMins)
        .addProperty("Entity_vBoxMaxs", &GCEnvLightProbeVolume::GetEntity_vBoxMaxs, &GCEnvLightProbeVolume::SetEntity_vBoxMaxs)
        .addProperty("Entity_bMoveable", &GCEnvLightProbeVolume::GetEntity_bMoveable, &GCEnvLightProbeVolume::SetEntity_bMoveable)
        .addProperty("Entity_nHandshake", &GCEnvLightProbeVolume::GetEntity_nHandshake, &GCEnvLightProbeVolume::SetEntity_nHandshake)
        .addProperty("Entity_nPriority", &GCEnvLightProbeVolume::GetEntity_nPriority, &GCEnvLightProbeVolume::SetEntity_nPriority)
        .addProperty("Entity_bStartDisabled", &GCEnvLightProbeVolume::GetEntity_bStartDisabled, &GCEnvLightProbeVolume::SetEntity_bStartDisabled)
        .addProperty("Entity_nLightProbeSizeX", &GCEnvLightProbeVolume::GetEntity_nLightProbeSizeX, &GCEnvLightProbeVolume::SetEntity_nLightProbeSizeX)
        .addProperty("Entity_nLightProbeSizeY", &GCEnvLightProbeVolume::GetEntity_nLightProbeSizeY, &GCEnvLightProbeVolume::SetEntity_nLightProbeSizeY)
        .addProperty("Entity_nLightProbeSizeZ", &GCEnvLightProbeVolume::GetEntity_nLightProbeSizeZ, &GCEnvLightProbeVolume::SetEntity_nLightProbeSizeZ)
        .addProperty("Entity_nLightProbeAtlasX", &GCEnvLightProbeVolume::GetEntity_nLightProbeAtlasX, &GCEnvLightProbeVolume::SetEntity_nLightProbeAtlasX)
        .addProperty("Entity_nLightProbeAtlasY", &GCEnvLightProbeVolume::GetEntity_nLightProbeAtlasY, &GCEnvLightProbeVolume::SetEntity_nLightProbeAtlasY)
        .addProperty("Entity_nLightProbeAtlasZ", &GCEnvLightProbeVolume::GetEntity_nLightProbeAtlasZ, &GCEnvLightProbeVolume::SetEntity_nLightProbeAtlasZ)
        .addProperty("Entity_bEnabled", &GCEnvLightProbeVolume::GetEntity_bEnabled, &GCEnvLightProbeVolume::SetEntity_bEnabled)
        .addProperty("Parent", &GCEnvLightProbeVolume::GetParent, &GCEnvLightProbeVolume::SetParent)
        .addFunction("ToPtr", &GCEnvLightProbeVolume::ToPtr)
        .addFunction("IsValid", &GCEnvLightProbeVolume::IsValid)
        .endClass();
}
GCCSGameModeRules_ArmsRace::GCCSGameModeRules_ArmsRace(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCCSGameModeRules_ArmsRace::GCCSGameModeRules_ArmsRace(void *ptr) {
    m_ptr = ptr;
}
std::vector<CUtlString> GCCSGameModeRules_ArmsRace::GetWeaponSequence() const {
    CUtlVector<CUtlString>* vec = GetSchemaValue<CUtlVector<CUtlString>*>(m_ptr, "CCSGameModeRules_ArmsRace", "m_WeaponSequence"); std::vector<CUtlString> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCCSGameModeRules_ArmsRace::SetWeaponSequence(std::vector<CUtlString> value) {
    SetSchemaValueCUtlVector<CUtlString>(m_ptr, "CCSGameModeRules_ArmsRace", "m_WeaponSequence", false, value);
}
std::string GCCSGameModeRules_ArmsRace::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCCSGameModeRules_ArmsRace::IsValid() {
    return (m_ptr != nullptr);
}
GCCSGameModeRules GCCSGameModeRules_ArmsRace::GetParent() const {
    GCCSGameModeRules value(m_ptr);
    return value;
}
void GCCSGameModeRules_ArmsRace::SetParent(GCCSGameModeRules value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCCSGameModeRules_ArmsRace(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCCSGameModeRules_ArmsRace>("CCSGameModeRules_ArmsRace")
        .addConstructor<void (*)(std::string)>()
        .addProperty("WeaponSequence", &GCCSGameModeRules_ArmsRace::GetWeaponSequence, &GCCSGameModeRules_ArmsRace::SetWeaponSequence)
        .addProperty("Parent", &GCCSGameModeRules_ArmsRace::GetParent, &GCCSGameModeRules_ArmsRace::SetParent)
        .addFunction("ToPtr", &GCCSGameModeRules_ArmsRace::ToPtr)
        .addFunction("IsValid", &GCCSGameModeRules_ArmsRace::IsValid)
        .endClass();
}
GCScriptTriggerPush::GCScriptTriggerPush(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCScriptTriggerPush::GCScriptTriggerPush(void *ptr) {
    m_ptr = ptr;
}
Vector GCScriptTriggerPush::GetExtent() const {
    return GetSchemaValue<Vector>(m_ptr, "CScriptTriggerPush", "m_vExtent");
}
void GCScriptTriggerPush::SetExtent(Vector value) {
    SetSchemaValue(m_ptr, "CScriptTriggerPush", "m_vExtent", false, value);
}
std::string GCScriptTriggerPush::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCScriptTriggerPush::IsValid() {
    return (m_ptr != nullptr);
}
GCTriggerPush GCScriptTriggerPush::GetParent() const {
    GCTriggerPush value(m_ptr);
    return value;
}
void GCScriptTriggerPush::SetParent(GCTriggerPush value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCScriptTriggerPush(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCScriptTriggerPush>("CScriptTriggerPush")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Extent", &GCScriptTriggerPush::GetExtent, &GCScriptTriggerPush::SetExtent)
        .addProperty("Parent", &GCScriptTriggerPush::GetParent, &GCScriptTriggerPush::SetParent)
        .addFunction("ToPtr", &GCScriptTriggerPush::ToPtr)
        .addFunction("IsValid", &GCScriptTriggerPush::IsValid)
        .endClass();
}
GCEnvEntityIgniter::GCEnvEntityIgniter(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCEnvEntityIgniter::GCEnvEntityIgniter(void *ptr) {
    m_ptr = ptr;
}
float GCEnvEntityIgniter::GetLifetime() const {
    return GetSchemaValue<float>(m_ptr, "CEnvEntityIgniter", "m_flLifetime");
}
void GCEnvEntityIgniter::SetLifetime(float value) {
    SetSchemaValue(m_ptr, "CEnvEntityIgniter", "m_flLifetime", false, value);
}
std::string GCEnvEntityIgniter::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCEnvEntityIgniter::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseEntity GCEnvEntityIgniter::GetParent() const {
    GCBaseEntity value(m_ptr);
    return value;
}
void GCEnvEntityIgniter::SetParent(GCBaseEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCEnvEntityIgniter(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCEnvEntityIgniter>("CEnvEntityIgniter")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Lifetime", &GCEnvEntityIgniter::GetLifetime, &GCEnvEntityIgniter::SetLifetime)
        .addProperty("Parent", &GCEnvEntityIgniter::GetParent, &GCEnvEntityIgniter::SetParent)
        .addFunction("ToPtr", &GCEnvEntityIgniter::ToPtr)
        .addFunction("IsValid", &GCEnvEntityIgniter::IsValid)
        .endClass();
}
GCFuncWallToggle::GCFuncWallToggle(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCFuncWallToggle::GCFuncWallToggle(void *ptr) {
    m_ptr = ptr;
}
std::string GCFuncWallToggle::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCFuncWallToggle::IsValid() {
    return (m_ptr != nullptr);
}
GCFuncWall GCFuncWallToggle::GetParent() const {
    GCFuncWall value(m_ptr);
    return value;
}
void GCFuncWallToggle::SetParent(GCFuncWall value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCFuncWallToggle(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCFuncWallToggle>("CFuncWallToggle")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCFuncWallToggle::GetParent, &GCFuncWallToggle::SetParent)
        .addFunction("ToPtr", &GCFuncWallToggle::ToPtr)
        .addFunction("IsValid", &GCFuncWallToggle::IsValid)
        .endClass();
}
GCDamageRecord::GCDamageRecord(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCDamageRecord::GCDamageRecord(void *ptr) {
    m_ptr = ptr;
}
GCCSPlayerPawn GCDamageRecord::GetPlayerDamager() const {
    GCCSPlayerPawn value(*GetSchemaValuePtr<void*>(m_ptr, "CDamageRecord", "m_PlayerDamager"));
    return value;
}
void GCDamageRecord::SetPlayerDamager(GCCSPlayerPawn* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'PlayerDamager' is not possible.\n");
}
GCCSPlayerPawn GCDamageRecord::GetPlayerRecipient() const {
    GCCSPlayerPawn value(*GetSchemaValuePtr<void*>(m_ptr, "CDamageRecord", "m_PlayerRecipient"));
    return value;
}
void GCDamageRecord::SetPlayerRecipient(GCCSPlayerPawn* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'PlayerRecipient' is not possible.\n");
}
GCCSPlayerController GCDamageRecord::GetPlayerControllerDamager() const {
    GCCSPlayerController value(*GetSchemaValuePtr<void*>(m_ptr, "CDamageRecord", "m_hPlayerControllerDamager"));
    return value;
}
void GCDamageRecord::SetPlayerControllerDamager(GCCSPlayerController* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'PlayerControllerDamager' is not possible.\n");
}
GCCSPlayerController GCDamageRecord::GetPlayerControllerRecipient() const {
    GCCSPlayerController value(*GetSchemaValuePtr<void*>(m_ptr, "CDamageRecord", "m_hPlayerControllerRecipient"));
    return value;
}
void GCDamageRecord::SetPlayerControllerRecipient(GCCSPlayerController* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'PlayerControllerRecipient' is not possible.\n");
}
std::string GCDamageRecord::GetPlayerDamagerName() const {
    return GetSchemaValue<CUtlString>(m_ptr, "CDamageRecord", "m_szPlayerDamagerName").Get();
}
void GCDamageRecord::SetPlayerDamagerName(std::string value) {
    SetSchemaValue(m_ptr, "CDamageRecord", "m_szPlayerDamagerName", false, CUtlString(value.c_str()));
}
std::string GCDamageRecord::GetPlayerRecipientName() const {
    return GetSchemaValue<CUtlString>(m_ptr, "CDamageRecord", "m_szPlayerRecipientName").Get();
}
void GCDamageRecord::SetPlayerRecipientName(std::string value) {
    SetSchemaValue(m_ptr, "CDamageRecord", "m_szPlayerRecipientName", false, CUtlString(value.c_str()));
}
uint64_t GCDamageRecord::GetDamagerXuid() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CDamageRecord", "m_DamagerXuid");
}
void GCDamageRecord::SetDamagerXuid(uint64_t value) {
    SetSchemaValue(m_ptr, "CDamageRecord", "m_DamagerXuid", false, value);
}
uint64_t GCDamageRecord::GetRecipientXuid() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CDamageRecord", "m_RecipientXuid");
}
void GCDamageRecord::SetRecipientXuid(uint64_t value) {
    SetSchemaValue(m_ptr, "CDamageRecord", "m_RecipientXuid", false, value);
}
int32_t GCDamageRecord::GetDamage() const {
    return GetSchemaValue<int32_t>(m_ptr, "CDamageRecord", "m_iDamage");
}
void GCDamageRecord::SetDamage(int32_t value) {
    SetSchemaValue(m_ptr, "CDamageRecord", "m_iDamage", false, value);
}
int32_t GCDamageRecord::GetActualHealthRemoved() const {
    return GetSchemaValue<int32_t>(m_ptr, "CDamageRecord", "m_iActualHealthRemoved");
}
void GCDamageRecord::SetActualHealthRemoved(int32_t value) {
    SetSchemaValue(m_ptr, "CDamageRecord", "m_iActualHealthRemoved", false, value);
}
int32_t GCDamageRecord::GetNumHits() const {
    return GetSchemaValue<int32_t>(m_ptr, "CDamageRecord", "m_iNumHits");
}
void GCDamageRecord::SetNumHits(int32_t value) {
    SetSchemaValue(m_ptr, "CDamageRecord", "m_iNumHits", false, value);
}
int32_t GCDamageRecord::GetLastBulletUpdate() const {
    return GetSchemaValue<int32_t>(m_ptr, "CDamageRecord", "m_iLastBulletUpdate");
}
void GCDamageRecord::SetLastBulletUpdate(int32_t value) {
    SetSchemaValue(m_ptr, "CDamageRecord", "m_iLastBulletUpdate", false, value);
}
bool GCDamageRecord::GetIsOtherEnemy() const {
    return GetSchemaValue<bool>(m_ptr, "CDamageRecord", "m_bIsOtherEnemy");
}
void GCDamageRecord::SetIsOtherEnemy(bool value) {
    SetSchemaValue(m_ptr, "CDamageRecord", "m_bIsOtherEnemy", false, value);
}
uint64_t GCDamageRecord::GetKillType() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CDamageRecord", "m_killType");
}
void GCDamageRecord::SetKillType(uint64_t value) {
    SetSchemaValue(m_ptr, "CDamageRecord", "m_killType", false, value);
}
std::string GCDamageRecord::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCDamageRecord::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCDamageRecord(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCDamageRecord>("CDamageRecord")
        .addConstructor<void (*)(std::string)>()
        .addProperty("PlayerDamager", &GCDamageRecord::GetPlayerDamager, &GCDamageRecord::SetPlayerDamager)
        .addProperty("PlayerRecipient", &GCDamageRecord::GetPlayerRecipient, &GCDamageRecord::SetPlayerRecipient)
        .addProperty("PlayerControllerDamager", &GCDamageRecord::GetPlayerControllerDamager, &GCDamageRecord::SetPlayerControllerDamager)
        .addProperty("PlayerControllerRecipient", &GCDamageRecord::GetPlayerControllerRecipient, &GCDamageRecord::SetPlayerControllerRecipient)
        .addProperty("PlayerDamagerName", &GCDamageRecord::GetPlayerDamagerName, &GCDamageRecord::SetPlayerDamagerName)
        .addProperty("PlayerRecipientName", &GCDamageRecord::GetPlayerRecipientName, &GCDamageRecord::SetPlayerRecipientName)
        .addProperty("DamagerXuid", &GCDamageRecord::GetDamagerXuid, &GCDamageRecord::SetDamagerXuid)
        .addProperty("RecipientXuid", &GCDamageRecord::GetRecipientXuid, &GCDamageRecord::SetRecipientXuid)
        .addProperty("Damage", &GCDamageRecord::GetDamage, &GCDamageRecord::SetDamage)
        .addProperty("ActualHealthRemoved", &GCDamageRecord::GetActualHealthRemoved, &GCDamageRecord::SetActualHealthRemoved)
        .addProperty("NumHits", &GCDamageRecord::GetNumHits, &GCDamageRecord::SetNumHits)
        .addProperty("LastBulletUpdate", &GCDamageRecord::GetLastBulletUpdate, &GCDamageRecord::SetLastBulletUpdate)
        .addProperty("IsOtherEnemy", &GCDamageRecord::GetIsOtherEnemy, &GCDamageRecord::SetIsOtherEnemy)
        .addProperty("KillType", &GCDamageRecord::GetKillType, &GCDamageRecord::SetKillType)
        .addFunction("ToPtr", &GCDamageRecord::ToPtr)
        .addFunction("IsValid", &GCDamageRecord::IsValid)
        .endClass();
}
GCLogicAutosave::GCLogicAutosave(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCLogicAutosave::GCLogicAutosave(void *ptr) {
    m_ptr = ptr;
}
bool GCLogicAutosave::GetForceNewLevelUnit() const {
    return GetSchemaValue<bool>(m_ptr, "CLogicAutosave", "m_bForceNewLevelUnit");
}
void GCLogicAutosave::SetForceNewLevelUnit(bool value) {
    SetSchemaValue(m_ptr, "CLogicAutosave", "m_bForceNewLevelUnit", false, value);
}
int32_t GCLogicAutosave::GetMinHitPoints() const {
    return GetSchemaValue<int32_t>(m_ptr, "CLogicAutosave", "m_minHitPoints");
}
void GCLogicAutosave::SetMinHitPoints(int32_t value) {
    SetSchemaValue(m_ptr, "CLogicAutosave", "m_minHitPoints", false, value);
}
int32_t GCLogicAutosave::GetMinHitPointsToCommit() const {
    return GetSchemaValue<int32_t>(m_ptr, "CLogicAutosave", "m_minHitPointsToCommit");
}
void GCLogicAutosave::SetMinHitPointsToCommit(int32_t value) {
    SetSchemaValue(m_ptr, "CLogicAutosave", "m_minHitPointsToCommit", false, value);
}
std::string GCLogicAutosave::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCLogicAutosave::IsValid() {
    return (m_ptr != nullptr);
}
GCLogicalEntity GCLogicAutosave::GetParent() const {
    GCLogicalEntity value(m_ptr);
    return value;
}
void GCLogicAutosave::SetParent(GCLogicalEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCLogicAutosave(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCLogicAutosave>("CLogicAutosave")
        .addConstructor<void (*)(std::string)>()
        .addProperty("ForceNewLevelUnit", &GCLogicAutosave::GetForceNewLevelUnit, &GCLogicAutosave::SetForceNewLevelUnit)
        .addProperty("MinHitPoints", &GCLogicAutosave::GetMinHitPoints, &GCLogicAutosave::SetMinHitPoints)
        .addProperty("MinHitPointsToCommit", &GCLogicAutosave::GetMinHitPointsToCommit, &GCLogicAutosave::SetMinHitPointsToCommit)
        .addProperty("Parent", &GCLogicAutosave::GetParent, &GCLogicAutosave::SetParent)
        .addFunction("ToPtr", &GCLogicAutosave::ToPtr)
        .addFunction("IsValid", &GCLogicAutosave::IsValid)
        .endClass();
}
GCCSPlayerController_DamageServices::GCCSPlayerController_DamageServices(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCCSPlayerController_DamageServices::GCCSPlayerController_DamageServices(void *ptr) {
    m_ptr = ptr;
}
int32_t GCCSPlayerController_DamageServices::GetSendUpdate() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSPlayerController_DamageServices", "m_nSendUpdate");
}
void GCCSPlayerController_DamageServices::SetSendUpdate(int32_t value) {
    SetSchemaValue(m_ptr, "CCSPlayerController_DamageServices", "m_nSendUpdate", false, value);
}
std::vector<GCDamageRecord> GCCSPlayerController_DamageServices::GetDamageList() const {
    CUtlVector<GCDamageRecord>* vec = GetSchemaValue<CUtlVector<GCDamageRecord>*>(m_ptr, "CCSPlayerController_DamageServices", "m_DamageList"); std::vector<GCDamageRecord> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCCSPlayerController_DamageServices::SetDamageList(std::vector<GCDamageRecord> value) {
    SetSchemaValueCUtlVector<GCDamageRecord>(m_ptr, "CCSPlayerController_DamageServices", "m_DamageList", false, value);
}
std::string GCCSPlayerController_DamageServices::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCCSPlayerController_DamageServices::IsValid() {
    return (m_ptr != nullptr);
}
GCPlayerControllerComponent GCCSPlayerController_DamageServices::GetParent() const {
    GCPlayerControllerComponent value(m_ptr);
    return value;
}
void GCCSPlayerController_DamageServices::SetParent(GCPlayerControllerComponent value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCCSPlayerController_DamageServices(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCCSPlayerController_DamageServices>("CCSPlayerController_DamageServices")
        .addConstructor<void (*)(std::string)>()
        .addProperty("SendUpdate", &GCCSPlayerController_DamageServices::GetSendUpdate, &GCCSPlayerController_DamageServices::SetSendUpdate)
        .addProperty("DamageList", &GCCSPlayerController_DamageServices::GetDamageList, &GCCSPlayerController_DamageServices::SetDamageList)
        .addProperty("Parent", &GCCSPlayerController_DamageServices::GetParent, &GCCSPlayerController_DamageServices::SetParent)
        .addFunction("ToPtr", &GCCSPlayerController_DamageServices::ToPtr)
        .addFunction("IsValid", &GCCSPlayerController_DamageServices::IsValid)
        .endClass();
}
GCRenderComponent::GCRenderComponent(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCRenderComponent::GCRenderComponent(void *ptr) {
    m_ptr = ptr;
}
GCNetworkVarChainer GCRenderComponent::Get__pChainEntity() const {
    GCNetworkVarChainer value(GetSchemaPtr(m_ptr, "CRenderComponent", "__m_pChainEntity"));
    return value;
}
void GCRenderComponent::Set__pChainEntity(GCNetworkVarChainer value) {
    SetSchemaValue(m_ptr, "CRenderComponent", "__m_pChainEntity", false, value);
}
bool GCRenderComponent::GetIsRenderingWithViewModels() const {
    return GetSchemaValue<bool>(m_ptr, "CRenderComponent", "m_bIsRenderingWithViewModels");
}
void GCRenderComponent::SetIsRenderingWithViewModels(bool value) {
    SetSchemaValue(m_ptr, "CRenderComponent", "m_bIsRenderingWithViewModels", false, value);
}
uint32_t GCRenderComponent::GetSplitscreenFlags() const {
    return GetSchemaValue<uint32_t>(m_ptr, "CRenderComponent", "m_nSplitscreenFlags");
}
void GCRenderComponent::SetSplitscreenFlags(uint32_t value) {
    SetSchemaValue(m_ptr, "CRenderComponent", "m_nSplitscreenFlags", false, value);
}
bool GCRenderComponent::GetEnableRendering() const {
    return GetSchemaValue<bool>(m_ptr, "CRenderComponent", "m_bEnableRendering");
}
void GCRenderComponent::SetEnableRendering(bool value) {
    SetSchemaValue(m_ptr, "CRenderComponent", "m_bEnableRendering", false, value);
}
bool GCRenderComponent::GetInterpolationReadyToDraw() const {
    return GetSchemaValue<bool>(m_ptr, "CRenderComponent", "m_bInterpolationReadyToDraw");
}
void GCRenderComponent::SetInterpolationReadyToDraw(bool value) {
    SetSchemaValue(m_ptr, "CRenderComponent", "m_bInterpolationReadyToDraw", false, value);
}
std::string GCRenderComponent::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCRenderComponent::IsValid() {
    return (m_ptr != nullptr);
}
GCEntityComponent GCRenderComponent::GetParent() const {
    GCEntityComponent value(m_ptr);
    return value;
}
void GCRenderComponent::SetParent(GCEntityComponent value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCRenderComponent(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCRenderComponent>("CRenderComponent")
        .addConstructor<void (*)(std::string)>()
        .addProperty("__pChainEntity", &GCRenderComponent::Get__pChainEntity, &GCRenderComponent::Set__pChainEntity)
        .addProperty("IsRenderingWithViewModels", &GCRenderComponent::GetIsRenderingWithViewModels, &GCRenderComponent::SetIsRenderingWithViewModels)
        .addProperty("SplitscreenFlags", &GCRenderComponent::GetSplitscreenFlags, &GCRenderComponent::SetSplitscreenFlags)
        .addProperty("EnableRendering", &GCRenderComponent::GetEnableRendering, &GCRenderComponent::SetEnableRendering)
        .addProperty("InterpolationReadyToDraw", &GCRenderComponent::GetInterpolationReadyToDraw, &GCRenderComponent::SetInterpolationReadyToDraw)
        .addProperty("Parent", &GCRenderComponent::GetParent, &GCRenderComponent::SetParent)
        .addFunction("ToPtr", &GCRenderComponent::ToPtr)
        .addFunction("IsValid", &GCRenderComponent::IsValid)
        .endClass();
}
GCSoundEventPathCornerEntity::GCSoundEventPathCornerEntity(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCSoundEventPathCornerEntity::GCSoundEventPathCornerEntity(void *ptr) {
    m_ptr = ptr;
}
std::string GCSoundEventPathCornerEntity::GetPathCorner() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CSoundEventPathCornerEntity", "m_iszPathCorner").String();
}
void GCSoundEventPathCornerEntity::SetPathCorner(std::string value) {
    SetSchemaValue(m_ptr, "CSoundEventPathCornerEntity", "m_iszPathCorner", false, CUtlSymbolLarge(value.c_str()));
}
int32_t GCSoundEventPathCornerEntity::GetCountMax() const {
    return GetSchemaValue<int32_t>(m_ptr, "CSoundEventPathCornerEntity", "m_iCountMax");
}
void GCSoundEventPathCornerEntity::SetCountMax(int32_t value) {
    SetSchemaValue(m_ptr, "CSoundEventPathCornerEntity", "m_iCountMax", false, value);
}
float GCSoundEventPathCornerEntity::GetDistanceMax() const {
    return GetSchemaValue<float>(m_ptr, "CSoundEventPathCornerEntity", "m_flDistanceMax");
}
void GCSoundEventPathCornerEntity::SetDistanceMax(float value) {
    SetSchemaValue(m_ptr, "CSoundEventPathCornerEntity", "m_flDistanceMax", false, value);
}
float GCSoundEventPathCornerEntity::GetDistMaxSqr() const {
    return GetSchemaValue<float>(m_ptr, "CSoundEventPathCornerEntity", "m_flDistMaxSqr");
}
void GCSoundEventPathCornerEntity::SetDistMaxSqr(float value) {
    SetSchemaValue(m_ptr, "CSoundEventPathCornerEntity", "m_flDistMaxSqr", false, value);
}
float GCSoundEventPathCornerEntity::GetDotProductMax() const {
    return GetSchemaValue<float>(m_ptr, "CSoundEventPathCornerEntity", "m_flDotProductMax");
}
void GCSoundEventPathCornerEntity::SetDotProductMax(float value) {
    SetSchemaValue(m_ptr, "CSoundEventPathCornerEntity", "m_flDotProductMax", false, value);
}
bool GCSoundEventPathCornerEntity::GetPlaying() const {
    return GetSchemaValue<bool>(m_ptr, "CSoundEventPathCornerEntity", "m_bPlaying");
}
void GCSoundEventPathCornerEntity::SetPlaying(bool value) {
    SetSchemaValue(m_ptr, "CSoundEventPathCornerEntity", "m_bPlaying", false, value);
}
std::string GCSoundEventPathCornerEntity::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCSoundEventPathCornerEntity::IsValid() {
    return (m_ptr != nullptr);
}
GCSoundEventEntity GCSoundEventPathCornerEntity::GetParent() const {
    GCSoundEventEntity value(m_ptr);
    return value;
}
void GCSoundEventPathCornerEntity::SetParent(GCSoundEventEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCSoundEventPathCornerEntity(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCSoundEventPathCornerEntity>("CSoundEventPathCornerEntity")
        .addConstructor<void (*)(std::string)>()
        .addProperty("PathCorner", &GCSoundEventPathCornerEntity::GetPathCorner, &GCSoundEventPathCornerEntity::SetPathCorner)
        .addProperty("CountMax", &GCSoundEventPathCornerEntity::GetCountMax, &GCSoundEventPathCornerEntity::SetCountMax)
        .addProperty("DistanceMax", &GCSoundEventPathCornerEntity::GetDistanceMax, &GCSoundEventPathCornerEntity::SetDistanceMax)
        .addProperty("DistMaxSqr", &GCSoundEventPathCornerEntity::GetDistMaxSqr, &GCSoundEventPathCornerEntity::SetDistMaxSqr)
        .addProperty("DotProductMax", &GCSoundEventPathCornerEntity::GetDotProductMax, &GCSoundEventPathCornerEntity::SetDotProductMax)
        .addProperty("Playing", &GCSoundEventPathCornerEntity::GetPlaying, &GCSoundEventPathCornerEntity::SetPlaying)
        .addProperty("Parent", &GCSoundEventPathCornerEntity::GetParent, &GCSoundEventPathCornerEntity::SetParent)
        .addFunction("ToPtr", &GCSoundEventPathCornerEntity::ToPtr)
        .addFunction("IsValid", &GCSoundEventPathCornerEntity::IsValid)
        .endClass();
}
GCEnvSoundscapeProxyAlias_snd_soundscape_proxy::GCEnvSoundscapeProxyAlias_snd_soundscape_proxy(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCEnvSoundscapeProxyAlias_snd_soundscape_proxy::GCEnvSoundscapeProxyAlias_snd_soundscape_proxy(void *ptr) {
    m_ptr = ptr;
}
std::string GCEnvSoundscapeProxyAlias_snd_soundscape_proxy::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCEnvSoundscapeProxyAlias_snd_soundscape_proxy::IsValid() {
    return (m_ptr != nullptr);
}
GCEnvSoundscapeProxy GCEnvSoundscapeProxyAlias_snd_soundscape_proxy::GetParent() const {
    GCEnvSoundscapeProxy value(m_ptr);
    return value;
}
void GCEnvSoundscapeProxyAlias_snd_soundscape_proxy::SetParent(GCEnvSoundscapeProxy value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCEnvSoundscapeProxyAlias_snd_soundscape_proxy(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCEnvSoundscapeProxyAlias_snd_soundscape_proxy>("CEnvSoundscapeProxyAlias_snd_soundscape_proxy")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCEnvSoundscapeProxyAlias_snd_soundscape_proxy::GetParent, &GCEnvSoundscapeProxyAlias_snd_soundscape_proxy::SetParent)
        .addFunction("ToPtr", &GCEnvSoundscapeProxyAlias_snd_soundscape_proxy::ToPtr)
        .addFunction("IsValid", &GCEnvSoundscapeProxyAlias_snd_soundscape_proxy::IsValid)
        .endClass();
}
GCLightComponent::GCLightComponent(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCLightComponent::GCLightComponent(void *ptr) {
    m_ptr = ptr;
}
GCNetworkVarChainer GCLightComponent::Get__pChainEntity() const {
    GCNetworkVarChainer value(GetSchemaPtr(m_ptr, "CLightComponent", "__m_pChainEntity"));
    return value;
}
void GCLightComponent::Set__pChainEntity(GCNetworkVarChainer value) {
    SetSchemaValue(m_ptr, "CLightComponent", "__m_pChainEntity", false, value);
}
Color GCLightComponent::GetColor() const {
    return GetSchemaValue<Color>(m_ptr, "CLightComponent", "m_Color");
}
void GCLightComponent::SetColor(Color value) {
    SetSchemaValue(m_ptr, "CLightComponent", "m_Color", false, value);
}
Color GCLightComponent::GetSecondaryColor() const {
    return GetSchemaValue<Color>(m_ptr, "CLightComponent", "m_SecondaryColor");
}
void GCLightComponent::SetSecondaryColor(Color value) {
    SetSchemaValue(m_ptr, "CLightComponent", "m_SecondaryColor", false, value);
}
float GCLightComponent::GetBrightness() const {
    return GetSchemaValue<float>(m_ptr, "CLightComponent", "m_flBrightness");
}
void GCLightComponent::SetBrightness(float value) {
    SetSchemaValue(m_ptr, "CLightComponent", "m_flBrightness", false, value);
}
float GCLightComponent::GetBrightnessScale() const {
    return GetSchemaValue<float>(m_ptr, "CLightComponent", "m_flBrightnessScale");
}
void GCLightComponent::SetBrightnessScale(float value) {
    SetSchemaValue(m_ptr, "CLightComponent", "m_flBrightnessScale", false, value);
}
float GCLightComponent::GetBrightnessMult() const {
    return GetSchemaValue<float>(m_ptr, "CLightComponent", "m_flBrightnessMult");
}
void GCLightComponent::SetBrightnessMult(float value) {
    SetSchemaValue(m_ptr, "CLightComponent", "m_flBrightnessMult", false, value);
}
float GCLightComponent::GetRange() const {
    return GetSchemaValue<float>(m_ptr, "CLightComponent", "m_flRange");
}
void GCLightComponent::SetRange(float value) {
    SetSchemaValue(m_ptr, "CLightComponent", "m_flRange", false, value);
}
float GCLightComponent::GetFalloff() const {
    return GetSchemaValue<float>(m_ptr, "CLightComponent", "m_flFalloff");
}
void GCLightComponent::SetFalloff(float value) {
    SetSchemaValue(m_ptr, "CLightComponent", "m_flFalloff", false, value);
}
float GCLightComponent::GetAttenuation0() const {
    return GetSchemaValue<float>(m_ptr, "CLightComponent", "m_flAttenuation0");
}
void GCLightComponent::SetAttenuation0(float value) {
    SetSchemaValue(m_ptr, "CLightComponent", "m_flAttenuation0", false, value);
}
float GCLightComponent::GetAttenuation1() const {
    return GetSchemaValue<float>(m_ptr, "CLightComponent", "m_flAttenuation1");
}
void GCLightComponent::SetAttenuation1(float value) {
    SetSchemaValue(m_ptr, "CLightComponent", "m_flAttenuation1", false, value);
}
float GCLightComponent::GetAttenuation2() const {
    return GetSchemaValue<float>(m_ptr, "CLightComponent", "m_flAttenuation2");
}
void GCLightComponent::SetAttenuation2(float value) {
    SetSchemaValue(m_ptr, "CLightComponent", "m_flAttenuation2", false, value);
}
float GCLightComponent::GetTheta() const {
    return GetSchemaValue<float>(m_ptr, "CLightComponent", "m_flTheta");
}
void GCLightComponent::SetTheta(float value) {
    SetSchemaValue(m_ptr, "CLightComponent", "m_flTheta", false, value);
}
float GCLightComponent::GetPhi() const {
    return GetSchemaValue<float>(m_ptr, "CLightComponent", "m_flPhi");
}
void GCLightComponent::SetPhi(float value) {
    SetSchemaValue(m_ptr, "CLightComponent", "m_flPhi", false, value);
}
int32_t GCLightComponent::GetCascades() const {
    return GetSchemaValue<int32_t>(m_ptr, "CLightComponent", "m_nCascades");
}
void GCLightComponent::SetCascades(int32_t value) {
    SetSchemaValue(m_ptr, "CLightComponent", "m_nCascades", false, value);
}
int32_t GCLightComponent::GetCastShadows() const {
    return GetSchemaValue<int32_t>(m_ptr, "CLightComponent", "m_nCastShadows");
}
void GCLightComponent::SetCastShadows(int32_t value) {
    SetSchemaValue(m_ptr, "CLightComponent", "m_nCastShadows", false, value);
}
int32_t GCLightComponent::GetShadowWidth() const {
    return GetSchemaValue<int32_t>(m_ptr, "CLightComponent", "m_nShadowWidth");
}
void GCLightComponent::SetShadowWidth(int32_t value) {
    SetSchemaValue(m_ptr, "CLightComponent", "m_nShadowWidth", false, value);
}
int32_t GCLightComponent::GetShadowHeight() const {
    return GetSchemaValue<int32_t>(m_ptr, "CLightComponent", "m_nShadowHeight");
}
void GCLightComponent::SetShadowHeight(int32_t value) {
    SetSchemaValue(m_ptr, "CLightComponent", "m_nShadowHeight", false, value);
}
bool GCLightComponent::GetRenderDiffuse() const {
    return GetSchemaValue<bool>(m_ptr, "CLightComponent", "m_bRenderDiffuse");
}
void GCLightComponent::SetRenderDiffuse(bool value) {
    SetSchemaValue(m_ptr, "CLightComponent", "m_bRenderDiffuse", false, value);
}
int32_t GCLightComponent::GetRenderSpecular() const {
    return GetSchemaValue<int32_t>(m_ptr, "CLightComponent", "m_nRenderSpecular");
}
void GCLightComponent::SetRenderSpecular(int32_t value) {
    SetSchemaValue(m_ptr, "CLightComponent", "m_nRenderSpecular", false, value);
}
bool GCLightComponent::GetRenderTransmissive() const {
    return GetSchemaValue<bool>(m_ptr, "CLightComponent", "m_bRenderTransmissive");
}
void GCLightComponent::SetRenderTransmissive(bool value) {
    SetSchemaValue(m_ptr, "CLightComponent", "m_bRenderTransmissive", false, value);
}
float GCLightComponent::GetOrthoLightWidth() const {
    return GetSchemaValue<float>(m_ptr, "CLightComponent", "m_flOrthoLightWidth");
}
void GCLightComponent::SetOrthoLightWidth(float value) {
    SetSchemaValue(m_ptr, "CLightComponent", "m_flOrthoLightWidth", false, value);
}
float GCLightComponent::GetOrthoLightHeight() const {
    return GetSchemaValue<float>(m_ptr, "CLightComponent", "m_flOrthoLightHeight");
}
void GCLightComponent::SetOrthoLightHeight(float value) {
    SetSchemaValue(m_ptr, "CLightComponent", "m_flOrthoLightHeight", false, value);
}
int32_t GCLightComponent::GetStyle() const {
    return GetSchemaValue<int32_t>(m_ptr, "CLightComponent", "m_nStyle");
}
void GCLightComponent::SetStyle(int32_t value) {
    SetSchemaValue(m_ptr, "CLightComponent", "m_nStyle", false, value);
}
std::string GCLightComponent::GetPattern() const {
    return GetSchemaValue<CUtlString>(m_ptr, "CLightComponent", "m_Pattern").Get();
}
void GCLightComponent::SetPattern(std::string value) {
    SetSchemaValue(m_ptr, "CLightComponent", "m_Pattern", false, CUtlString(value.c_str()));
}
int32_t GCLightComponent::GetCascadeRenderStaticObjects() const {
    return GetSchemaValue<int32_t>(m_ptr, "CLightComponent", "m_nCascadeRenderStaticObjects");
}
void GCLightComponent::SetCascadeRenderStaticObjects(int32_t value) {
    SetSchemaValue(m_ptr, "CLightComponent", "m_nCascadeRenderStaticObjects", false, value);
}
float GCLightComponent::GetShadowCascadeCrossFade() const {
    return GetSchemaValue<float>(m_ptr, "CLightComponent", "m_flShadowCascadeCrossFade");
}
void GCLightComponent::SetShadowCascadeCrossFade(float value) {
    SetSchemaValue(m_ptr, "CLightComponent", "m_flShadowCascadeCrossFade", false, value);
}
float GCLightComponent::GetShadowCascadeDistanceFade() const {
    return GetSchemaValue<float>(m_ptr, "CLightComponent", "m_flShadowCascadeDistanceFade");
}
void GCLightComponent::SetShadowCascadeDistanceFade(float value) {
    SetSchemaValue(m_ptr, "CLightComponent", "m_flShadowCascadeDistanceFade", false, value);
}
float GCLightComponent::GetShadowCascadeDistance0() const {
    return GetSchemaValue<float>(m_ptr, "CLightComponent", "m_flShadowCascadeDistance0");
}
void GCLightComponent::SetShadowCascadeDistance0(float value) {
    SetSchemaValue(m_ptr, "CLightComponent", "m_flShadowCascadeDistance0", false, value);
}
float GCLightComponent::GetShadowCascadeDistance1() const {
    return GetSchemaValue<float>(m_ptr, "CLightComponent", "m_flShadowCascadeDistance1");
}
void GCLightComponent::SetShadowCascadeDistance1(float value) {
    SetSchemaValue(m_ptr, "CLightComponent", "m_flShadowCascadeDistance1", false, value);
}
float GCLightComponent::GetShadowCascadeDistance2() const {
    return GetSchemaValue<float>(m_ptr, "CLightComponent", "m_flShadowCascadeDistance2");
}
void GCLightComponent::SetShadowCascadeDistance2(float value) {
    SetSchemaValue(m_ptr, "CLightComponent", "m_flShadowCascadeDistance2", false, value);
}
float GCLightComponent::GetShadowCascadeDistance3() const {
    return GetSchemaValue<float>(m_ptr, "CLightComponent", "m_flShadowCascadeDistance3");
}
void GCLightComponent::SetShadowCascadeDistance3(float value) {
    SetSchemaValue(m_ptr, "CLightComponent", "m_flShadowCascadeDistance3", false, value);
}
int32_t GCLightComponent::GetShadowCascadeResolution0() const {
    return GetSchemaValue<int32_t>(m_ptr, "CLightComponent", "m_nShadowCascadeResolution0");
}
void GCLightComponent::SetShadowCascadeResolution0(int32_t value) {
    SetSchemaValue(m_ptr, "CLightComponent", "m_nShadowCascadeResolution0", false, value);
}
int32_t GCLightComponent::GetShadowCascadeResolution1() const {
    return GetSchemaValue<int32_t>(m_ptr, "CLightComponent", "m_nShadowCascadeResolution1");
}
void GCLightComponent::SetShadowCascadeResolution1(int32_t value) {
    SetSchemaValue(m_ptr, "CLightComponent", "m_nShadowCascadeResolution1", false, value);
}
int32_t GCLightComponent::GetShadowCascadeResolution2() const {
    return GetSchemaValue<int32_t>(m_ptr, "CLightComponent", "m_nShadowCascadeResolution2");
}
void GCLightComponent::SetShadowCascadeResolution2(int32_t value) {
    SetSchemaValue(m_ptr, "CLightComponent", "m_nShadowCascadeResolution2", false, value);
}
int32_t GCLightComponent::GetShadowCascadeResolution3() const {
    return GetSchemaValue<int32_t>(m_ptr, "CLightComponent", "m_nShadowCascadeResolution3");
}
void GCLightComponent::SetShadowCascadeResolution3(int32_t value) {
    SetSchemaValue(m_ptr, "CLightComponent", "m_nShadowCascadeResolution3", false, value);
}
bool GCLightComponent::GetUsesBakedShadowing() const {
    return GetSchemaValue<bool>(m_ptr, "CLightComponent", "m_bUsesBakedShadowing");
}
void GCLightComponent::SetUsesBakedShadowing(bool value) {
    SetSchemaValue(m_ptr, "CLightComponent", "m_bUsesBakedShadowing", false, value);
}
int32_t GCLightComponent::GetShadowPriority() const {
    return GetSchemaValue<int32_t>(m_ptr, "CLightComponent", "m_nShadowPriority");
}
void GCLightComponent::SetShadowPriority(int32_t value) {
    SetSchemaValue(m_ptr, "CLightComponent", "m_nShadowPriority", false, value);
}
int32_t GCLightComponent::GetBakedShadowIndex() const {
    return GetSchemaValue<int32_t>(m_ptr, "CLightComponent", "m_nBakedShadowIndex");
}
void GCLightComponent::SetBakedShadowIndex(int32_t value) {
    SetSchemaValue(m_ptr, "CLightComponent", "m_nBakedShadowIndex", false, value);
}
bool GCLightComponent::GetRenderToCubemaps() const {
    return GetSchemaValue<bool>(m_ptr, "CLightComponent", "m_bRenderToCubemaps");
}
void GCLightComponent::SetRenderToCubemaps(bool value) {
    SetSchemaValue(m_ptr, "CLightComponent", "m_bRenderToCubemaps", false, value);
}
int32_t GCLightComponent::GetDirectLight() const {
    return GetSchemaValue<int32_t>(m_ptr, "CLightComponent", "m_nDirectLight");
}
void GCLightComponent::SetDirectLight(int32_t value) {
    SetSchemaValue(m_ptr, "CLightComponent", "m_nDirectLight", false, value);
}
int32_t GCLightComponent::GetIndirectLight() const {
    return GetSchemaValue<int32_t>(m_ptr, "CLightComponent", "m_nIndirectLight");
}
void GCLightComponent::SetIndirectLight(int32_t value) {
    SetSchemaValue(m_ptr, "CLightComponent", "m_nIndirectLight", false, value);
}
float GCLightComponent::GetFadeMinDist() const {
    return GetSchemaValue<float>(m_ptr, "CLightComponent", "m_flFadeMinDist");
}
void GCLightComponent::SetFadeMinDist(float value) {
    SetSchemaValue(m_ptr, "CLightComponent", "m_flFadeMinDist", false, value);
}
float GCLightComponent::GetFadeMaxDist() const {
    return GetSchemaValue<float>(m_ptr, "CLightComponent", "m_flFadeMaxDist");
}
void GCLightComponent::SetFadeMaxDist(float value) {
    SetSchemaValue(m_ptr, "CLightComponent", "m_flFadeMaxDist", false, value);
}
float GCLightComponent::GetShadowFadeMinDist() const {
    return GetSchemaValue<float>(m_ptr, "CLightComponent", "m_flShadowFadeMinDist");
}
void GCLightComponent::SetShadowFadeMinDist(float value) {
    SetSchemaValue(m_ptr, "CLightComponent", "m_flShadowFadeMinDist", false, value);
}
float GCLightComponent::GetShadowFadeMaxDist() const {
    return GetSchemaValue<float>(m_ptr, "CLightComponent", "m_flShadowFadeMaxDist");
}
void GCLightComponent::SetShadowFadeMaxDist(float value) {
    SetSchemaValue(m_ptr, "CLightComponent", "m_flShadowFadeMaxDist", false, value);
}
bool GCLightComponent::GetEnabled() const {
    return GetSchemaValue<bool>(m_ptr, "CLightComponent", "m_bEnabled");
}
void GCLightComponent::SetEnabled(bool value) {
    SetSchemaValue(m_ptr, "CLightComponent", "m_bEnabled", false, value);
}
bool GCLightComponent::GetFlicker() const {
    return GetSchemaValue<bool>(m_ptr, "CLightComponent", "m_bFlicker");
}
void GCLightComponent::SetFlicker(bool value) {
    SetSchemaValue(m_ptr, "CLightComponent", "m_bFlicker", false, value);
}
bool GCLightComponent::GetPrecomputedFieldsValid() const {
    return GetSchemaValue<bool>(m_ptr, "CLightComponent", "m_bPrecomputedFieldsValid");
}
void GCLightComponent::SetPrecomputedFieldsValid(bool value) {
    SetSchemaValue(m_ptr, "CLightComponent", "m_bPrecomputedFieldsValid", false, value);
}
Vector GCLightComponent::GetPrecomputedBoundsMins() const {
    return GetSchemaValue<Vector>(m_ptr, "CLightComponent", "m_vPrecomputedBoundsMins");
}
void GCLightComponent::SetPrecomputedBoundsMins(Vector value) {
    SetSchemaValue(m_ptr, "CLightComponent", "m_vPrecomputedBoundsMins", false, value);
}
Vector GCLightComponent::GetPrecomputedBoundsMaxs() const {
    return GetSchemaValue<Vector>(m_ptr, "CLightComponent", "m_vPrecomputedBoundsMaxs");
}
void GCLightComponent::SetPrecomputedBoundsMaxs(Vector value) {
    SetSchemaValue(m_ptr, "CLightComponent", "m_vPrecomputedBoundsMaxs", false, value);
}
Vector GCLightComponent::GetPrecomputedOBBOrigin() const {
    return GetSchemaValue<Vector>(m_ptr, "CLightComponent", "m_vPrecomputedOBBOrigin");
}
void GCLightComponent::SetPrecomputedOBBOrigin(Vector value) {
    SetSchemaValue(m_ptr, "CLightComponent", "m_vPrecomputedOBBOrigin", false, value);
}
QAngle GCLightComponent::GetPrecomputedOBBAngles() const {
    return GetSchemaValue<QAngle>(m_ptr, "CLightComponent", "m_vPrecomputedOBBAngles");
}
void GCLightComponent::SetPrecomputedOBBAngles(QAngle value) {
    SetSchemaValue(m_ptr, "CLightComponent", "m_vPrecomputedOBBAngles", false, value);
}
Vector GCLightComponent::GetPrecomputedOBBExtent() const {
    return GetSchemaValue<Vector>(m_ptr, "CLightComponent", "m_vPrecomputedOBBExtent");
}
void GCLightComponent::SetPrecomputedOBBExtent(Vector value) {
    SetSchemaValue(m_ptr, "CLightComponent", "m_vPrecomputedOBBExtent", false, value);
}
float GCLightComponent::GetPrecomputedMaxRange() const {
    return GetSchemaValue<float>(m_ptr, "CLightComponent", "m_flPrecomputedMaxRange");
}
void GCLightComponent::SetPrecomputedMaxRange(float value) {
    SetSchemaValue(m_ptr, "CLightComponent", "m_flPrecomputedMaxRange", false, value);
}
int32_t GCLightComponent::GetFogLightingMode() const {
    return GetSchemaValue<int32_t>(m_ptr, "CLightComponent", "m_nFogLightingMode");
}
void GCLightComponent::SetFogLightingMode(int32_t value) {
    SetSchemaValue(m_ptr, "CLightComponent", "m_nFogLightingMode", false, value);
}
float GCLightComponent::GetFogContributionStength() const {
    return GetSchemaValue<float>(m_ptr, "CLightComponent", "m_flFogContributionStength");
}
void GCLightComponent::SetFogContributionStength(float value) {
    SetSchemaValue(m_ptr, "CLightComponent", "m_flFogContributionStength", false, value);
}
float GCLightComponent::GetNearClipPlane() const {
    return GetSchemaValue<float>(m_ptr, "CLightComponent", "m_flNearClipPlane");
}
void GCLightComponent::SetNearClipPlane(float value) {
    SetSchemaValue(m_ptr, "CLightComponent", "m_flNearClipPlane", false, value);
}
Color GCLightComponent::GetSkyColor() const {
    return GetSchemaValue<Color>(m_ptr, "CLightComponent", "m_SkyColor");
}
void GCLightComponent::SetSkyColor(Color value) {
    SetSchemaValue(m_ptr, "CLightComponent", "m_SkyColor", false, value);
}
float GCLightComponent::GetSkyIntensity() const {
    return GetSchemaValue<float>(m_ptr, "CLightComponent", "m_flSkyIntensity");
}
void GCLightComponent::SetSkyIntensity(float value) {
    SetSchemaValue(m_ptr, "CLightComponent", "m_flSkyIntensity", false, value);
}
Color GCLightComponent::GetSkyAmbientBounce() const {
    return GetSchemaValue<Color>(m_ptr, "CLightComponent", "m_SkyAmbientBounce");
}
void GCLightComponent::SetSkyAmbientBounce(Color value) {
    SetSchemaValue(m_ptr, "CLightComponent", "m_SkyAmbientBounce", false, value);
}
bool GCLightComponent::GetUseSecondaryColor() const {
    return GetSchemaValue<bool>(m_ptr, "CLightComponent", "m_bUseSecondaryColor");
}
void GCLightComponent::SetUseSecondaryColor(bool value) {
    SetSchemaValue(m_ptr, "CLightComponent", "m_bUseSecondaryColor", false, value);
}
bool GCLightComponent::GetMixedShadows() const {
    return GetSchemaValue<bool>(m_ptr, "CLightComponent", "m_bMixedShadows");
}
void GCLightComponent::SetMixedShadows(bool value) {
    SetSchemaValue(m_ptr, "CLightComponent", "m_bMixedShadows", false, value);
}
float GCLightComponent::GetLightStyleStartTime() const {
    return GetSchemaValue<float>(m_ptr, "CLightComponent", "m_flLightStyleStartTime");
}
void GCLightComponent::SetLightStyleStartTime(float value) {
    SetSchemaValue(m_ptr, "CLightComponent", "m_flLightStyleStartTime", false, value);
}
float GCLightComponent::GetCapsuleLength() const {
    return GetSchemaValue<float>(m_ptr, "CLightComponent", "m_flCapsuleLength");
}
void GCLightComponent::SetCapsuleLength(float value) {
    SetSchemaValue(m_ptr, "CLightComponent", "m_flCapsuleLength", false, value);
}
float GCLightComponent::GetMinRoughness() const {
    return GetSchemaValue<float>(m_ptr, "CLightComponent", "m_flMinRoughness");
}
void GCLightComponent::SetMinRoughness(float value) {
    SetSchemaValue(m_ptr, "CLightComponent", "m_flMinRoughness", false, value);
}
bool GCLightComponent::GetPvsModifyEntity() const {
    return GetSchemaValue<bool>(m_ptr, "CLightComponent", "m_bPvsModifyEntity");
}
void GCLightComponent::SetPvsModifyEntity(bool value) {
    SetSchemaValue(m_ptr, "CLightComponent", "m_bPvsModifyEntity", false, value);
}
std::string GCLightComponent::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCLightComponent::IsValid() {
    return (m_ptr != nullptr);
}
GCEntityComponent GCLightComponent::GetParent() const {
    GCEntityComponent value(m_ptr);
    return value;
}
void GCLightComponent::SetParent(GCEntityComponent value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCLightComponent(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCLightComponent>("CLightComponent")
        .addConstructor<void (*)(std::string)>()
        .addProperty("__pChainEntity", &GCLightComponent::Get__pChainEntity, &GCLightComponent::Set__pChainEntity)
        .addProperty("Color", &GCLightComponent::GetColor, &GCLightComponent::SetColor)
        .addProperty("SecondaryColor", &GCLightComponent::GetSecondaryColor, &GCLightComponent::SetSecondaryColor)
        .addProperty("Brightness", &GCLightComponent::GetBrightness, &GCLightComponent::SetBrightness)
        .addProperty("BrightnessScale", &GCLightComponent::GetBrightnessScale, &GCLightComponent::SetBrightnessScale)
        .addProperty("BrightnessMult", &GCLightComponent::GetBrightnessMult, &GCLightComponent::SetBrightnessMult)
        .addProperty("Range", &GCLightComponent::GetRange, &GCLightComponent::SetRange)
        .addProperty("Falloff", &GCLightComponent::GetFalloff, &GCLightComponent::SetFalloff)
        .addProperty("Attenuation0", &GCLightComponent::GetAttenuation0, &GCLightComponent::SetAttenuation0)
        .addProperty("Attenuation1", &GCLightComponent::GetAttenuation1, &GCLightComponent::SetAttenuation1)
        .addProperty("Attenuation2", &GCLightComponent::GetAttenuation2, &GCLightComponent::SetAttenuation2)
        .addProperty("Theta", &GCLightComponent::GetTheta, &GCLightComponent::SetTheta)
        .addProperty("Phi", &GCLightComponent::GetPhi, &GCLightComponent::SetPhi)
        .addProperty("Cascades", &GCLightComponent::GetCascades, &GCLightComponent::SetCascades)
        .addProperty("CastShadows", &GCLightComponent::GetCastShadows, &GCLightComponent::SetCastShadows)
        .addProperty("ShadowWidth", &GCLightComponent::GetShadowWidth, &GCLightComponent::SetShadowWidth)
        .addProperty("ShadowHeight", &GCLightComponent::GetShadowHeight, &GCLightComponent::SetShadowHeight)
        .addProperty("RenderDiffuse", &GCLightComponent::GetRenderDiffuse, &GCLightComponent::SetRenderDiffuse)
        .addProperty("RenderSpecular", &GCLightComponent::GetRenderSpecular, &GCLightComponent::SetRenderSpecular)
        .addProperty("RenderTransmissive", &GCLightComponent::GetRenderTransmissive, &GCLightComponent::SetRenderTransmissive)
        .addProperty("OrthoLightWidth", &GCLightComponent::GetOrthoLightWidth, &GCLightComponent::SetOrthoLightWidth)
        .addProperty("OrthoLightHeight", &GCLightComponent::GetOrthoLightHeight, &GCLightComponent::SetOrthoLightHeight)
        .addProperty("Style", &GCLightComponent::GetStyle, &GCLightComponent::SetStyle)
        .addProperty("Pattern", &GCLightComponent::GetPattern, &GCLightComponent::SetPattern)
        .addProperty("CascadeRenderStaticObjects", &GCLightComponent::GetCascadeRenderStaticObjects, &GCLightComponent::SetCascadeRenderStaticObjects)
        .addProperty("ShadowCascadeCrossFade", &GCLightComponent::GetShadowCascadeCrossFade, &GCLightComponent::SetShadowCascadeCrossFade)
        .addProperty("ShadowCascadeDistanceFade", &GCLightComponent::GetShadowCascadeDistanceFade, &GCLightComponent::SetShadowCascadeDistanceFade)
        .addProperty("ShadowCascadeDistance0", &GCLightComponent::GetShadowCascadeDistance0, &GCLightComponent::SetShadowCascadeDistance0)
        .addProperty("ShadowCascadeDistance1", &GCLightComponent::GetShadowCascadeDistance1, &GCLightComponent::SetShadowCascadeDistance1)
        .addProperty("ShadowCascadeDistance2", &GCLightComponent::GetShadowCascadeDistance2, &GCLightComponent::SetShadowCascadeDistance2)
        .addProperty("ShadowCascadeDistance3", &GCLightComponent::GetShadowCascadeDistance3, &GCLightComponent::SetShadowCascadeDistance3)
        .addProperty("ShadowCascadeResolution0", &GCLightComponent::GetShadowCascadeResolution0, &GCLightComponent::SetShadowCascadeResolution0)
        .addProperty("ShadowCascadeResolution1", &GCLightComponent::GetShadowCascadeResolution1, &GCLightComponent::SetShadowCascadeResolution1)
        .addProperty("ShadowCascadeResolution2", &GCLightComponent::GetShadowCascadeResolution2, &GCLightComponent::SetShadowCascadeResolution2)
        .addProperty("ShadowCascadeResolution3", &GCLightComponent::GetShadowCascadeResolution3, &GCLightComponent::SetShadowCascadeResolution3)
        .addProperty("UsesBakedShadowing", &GCLightComponent::GetUsesBakedShadowing, &GCLightComponent::SetUsesBakedShadowing)
        .addProperty("ShadowPriority", &GCLightComponent::GetShadowPriority, &GCLightComponent::SetShadowPriority)
        .addProperty("BakedShadowIndex", &GCLightComponent::GetBakedShadowIndex, &GCLightComponent::SetBakedShadowIndex)
        .addProperty("RenderToCubemaps", &GCLightComponent::GetRenderToCubemaps, &GCLightComponent::SetRenderToCubemaps)
        .addProperty("DirectLight", &GCLightComponent::GetDirectLight, &GCLightComponent::SetDirectLight)
        .addProperty("IndirectLight", &GCLightComponent::GetIndirectLight, &GCLightComponent::SetIndirectLight)
        .addProperty("FadeMinDist", &GCLightComponent::GetFadeMinDist, &GCLightComponent::SetFadeMinDist)
        .addProperty("FadeMaxDist", &GCLightComponent::GetFadeMaxDist, &GCLightComponent::SetFadeMaxDist)
        .addProperty("ShadowFadeMinDist", &GCLightComponent::GetShadowFadeMinDist, &GCLightComponent::SetShadowFadeMinDist)
        .addProperty("ShadowFadeMaxDist", &GCLightComponent::GetShadowFadeMaxDist, &GCLightComponent::SetShadowFadeMaxDist)
        .addProperty("Enabled", &GCLightComponent::GetEnabled, &GCLightComponent::SetEnabled)
        .addProperty("Flicker", &GCLightComponent::GetFlicker, &GCLightComponent::SetFlicker)
        .addProperty("PrecomputedFieldsValid", &GCLightComponent::GetPrecomputedFieldsValid, &GCLightComponent::SetPrecomputedFieldsValid)
        .addProperty("PrecomputedBoundsMins", &GCLightComponent::GetPrecomputedBoundsMins, &GCLightComponent::SetPrecomputedBoundsMins)
        .addProperty("PrecomputedBoundsMaxs", &GCLightComponent::GetPrecomputedBoundsMaxs, &GCLightComponent::SetPrecomputedBoundsMaxs)
        .addProperty("PrecomputedOBBOrigin", &GCLightComponent::GetPrecomputedOBBOrigin, &GCLightComponent::SetPrecomputedOBBOrigin)
        .addProperty("PrecomputedOBBAngles", &GCLightComponent::GetPrecomputedOBBAngles, &GCLightComponent::SetPrecomputedOBBAngles)
        .addProperty("PrecomputedOBBExtent", &GCLightComponent::GetPrecomputedOBBExtent, &GCLightComponent::SetPrecomputedOBBExtent)
        .addProperty("PrecomputedMaxRange", &GCLightComponent::GetPrecomputedMaxRange, &GCLightComponent::SetPrecomputedMaxRange)
        .addProperty("FogLightingMode", &GCLightComponent::GetFogLightingMode, &GCLightComponent::SetFogLightingMode)
        .addProperty("FogContributionStength", &GCLightComponent::GetFogContributionStength, &GCLightComponent::SetFogContributionStength)
        .addProperty("NearClipPlane", &GCLightComponent::GetNearClipPlane, &GCLightComponent::SetNearClipPlane)
        .addProperty("SkyColor", &GCLightComponent::GetSkyColor, &GCLightComponent::SetSkyColor)
        .addProperty("SkyIntensity", &GCLightComponent::GetSkyIntensity, &GCLightComponent::SetSkyIntensity)
        .addProperty("SkyAmbientBounce", &GCLightComponent::GetSkyAmbientBounce, &GCLightComponent::SetSkyAmbientBounce)
        .addProperty("UseSecondaryColor", &GCLightComponent::GetUseSecondaryColor, &GCLightComponent::SetUseSecondaryColor)
        .addProperty("MixedShadows", &GCLightComponent::GetMixedShadows, &GCLightComponent::SetMixedShadows)
        .addProperty("LightStyleStartTime", &GCLightComponent::GetLightStyleStartTime, &GCLightComponent::SetLightStyleStartTime)
        .addProperty("CapsuleLength", &GCLightComponent::GetCapsuleLength, &GCLightComponent::SetCapsuleLength)
        .addProperty("MinRoughness", &GCLightComponent::GetMinRoughness, &GCLightComponent::SetMinRoughness)
        .addProperty("PvsModifyEntity", &GCLightComponent::GetPvsModifyEntity, &GCLightComponent::SetPvsModifyEntity)
        .addProperty("Parent", &GCLightComponent::GetParent, &GCLightComponent::SetParent)
        .addFunction("ToPtr", &GCLightComponent::ToPtr)
        .addFunction("IsValid", &GCLightComponent::IsValid)
        .endClass();
}
GCSmokeGrenadeProjectile::GCSmokeGrenadeProjectile(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCSmokeGrenadeProjectile::GCSmokeGrenadeProjectile(void *ptr) {
    m_ptr = ptr;
}
int32_t GCSmokeGrenadeProjectile::GetSmokeEffectTickBegin() const {
    return GetSchemaValue<int32_t>(m_ptr, "CSmokeGrenadeProjectile", "m_nSmokeEffectTickBegin");
}
void GCSmokeGrenadeProjectile::SetSmokeEffectTickBegin(int32_t value) {
    SetSchemaValue(m_ptr, "CSmokeGrenadeProjectile", "m_nSmokeEffectTickBegin", false, value);
}
bool GCSmokeGrenadeProjectile::GetDidSmokeEffect() const {
    return GetSchemaValue<bool>(m_ptr, "CSmokeGrenadeProjectile", "m_bDidSmokeEffect");
}
void GCSmokeGrenadeProjectile::SetDidSmokeEffect(bool value) {
    SetSchemaValue(m_ptr, "CSmokeGrenadeProjectile", "m_bDidSmokeEffect", false, value);
}
int32_t GCSmokeGrenadeProjectile::GetRandomSeed() const {
    return GetSchemaValue<int32_t>(m_ptr, "CSmokeGrenadeProjectile", "m_nRandomSeed");
}
void GCSmokeGrenadeProjectile::SetRandomSeed(int32_t value) {
    SetSchemaValue(m_ptr, "CSmokeGrenadeProjectile", "m_nRandomSeed", false, value);
}
Vector GCSmokeGrenadeProjectile::GetSmokeColor() const {
    return GetSchemaValue<Vector>(m_ptr, "CSmokeGrenadeProjectile", "m_vSmokeColor");
}
void GCSmokeGrenadeProjectile::SetSmokeColor(Vector value) {
    SetSchemaValue(m_ptr, "CSmokeGrenadeProjectile", "m_vSmokeColor", false, value);
}
Vector GCSmokeGrenadeProjectile::GetSmokeDetonationPos() const {
    return GetSchemaValue<Vector>(m_ptr, "CSmokeGrenadeProjectile", "m_vSmokeDetonationPos");
}
void GCSmokeGrenadeProjectile::SetSmokeDetonationPos(Vector value) {
    SetSchemaValue(m_ptr, "CSmokeGrenadeProjectile", "m_vSmokeDetonationPos", false, value);
}
std::vector<uint8> GCSmokeGrenadeProjectile::GetVoxelFrameData() const {
    CUtlVector<uint8>* vec = GetSchemaValue<CUtlVector<uint8>*>(m_ptr, "CSmokeGrenadeProjectile", "m_VoxelFrameData"); std::vector<uint8> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCSmokeGrenadeProjectile::SetVoxelFrameData(std::vector<uint8> value) {
    SetSchemaValueCUtlVector<uint8>(m_ptr, "CSmokeGrenadeProjectile", "m_VoxelFrameData", false, value);
}
float GCSmokeGrenadeProjectile::GetLastBounce() const {
    return GetSchemaValue<float>(m_ptr, "CSmokeGrenadeProjectile", "m_flLastBounce");
}
void GCSmokeGrenadeProjectile::SetLastBounce(float value) {
    SetSchemaValue(m_ptr, "CSmokeGrenadeProjectile", "m_flLastBounce", false, value);
}
float GCSmokeGrenadeProjectile::GetFllastSimulationTime() const {
    return GetSchemaValue<float>(m_ptr, "CSmokeGrenadeProjectile", "m_fllastSimulationTime");
}
void GCSmokeGrenadeProjectile::SetFllastSimulationTime(float value) {
    SetSchemaValue(m_ptr, "CSmokeGrenadeProjectile", "m_fllastSimulationTime", false, value);
}
std::string GCSmokeGrenadeProjectile::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCSmokeGrenadeProjectile::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseCSGrenadeProjectile GCSmokeGrenadeProjectile::GetParent() const {
    GCBaseCSGrenadeProjectile value(m_ptr);
    return value;
}
void GCSmokeGrenadeProjectile::SetParent(GCBaseCSGrenadeProjectile value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCSmokeGrenadeProjectile(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCSmokeGrenadeProjectile>("CSmokeGrenadeProjectile")
        .addConstructor<void (*)(std::string)>()
        .addProperty("SmokeEffectTickBegin", &GCSmokeGrenadeProjectile::GetSmokeEffectTickBegin, &GCSmokeGrenadeProjectile::SetSmokeEffectTickBegin)
        .addProperty("DidSmokeEffect", &GCSmokeGrenadeProjectile::GetDidSmokeEffect, &GCSmokeGrenadeProjectile::SetDidSmokeEffect)
        .addProperty("RandomSeed", &GCSmokeGrenadeProjectile::GetRandomSeed, &GCSmokeGrenadeProjectile::SetRandomSeed)
        .addProperty("SmokeColor", &GCSmokeGrenadeProjectile::GetSmokeColor, &GCSmokeGrenadeProjectile::SetSmokeColor)
        .addProperty("SmokeDetonationPos", &GCSmokeGrenadeProjectile::GetSmokeDetonationPos, &GCSmokeGrenadeProjectile::SetSmokeDetonationPos)
        .addProperty("VoxelFrameData", &GCSmokeGrenadeProjectile::GetVoxelFrameData, &GCSmokeGrenadeProjectile::SetVoxelFrameData)
        .addProperty("LastBounce", &GCSmokeGrenadeProjectile::GetLastBounce, &GCSmokeGrenadeProjectile::SetLastBounce)
        .addProperty("FllastSimulationTime", &GCSmokeGrenadeProjectile::GetFllastSimulationTime, &GCSmokeGrenadeProjectile::SetFllastSimulationTime)
        .addProperty("Parent", &GCSmokeGrenadeProjectile::GetParent, &GCSmokeGrenadeProjectile::SetParent)
        .addFunction("ToPtr", &GCSmokeGrenadeProjectile::ToPtr)
        .addFunction("IsValid", &GCSmokeGrenadeProjectile::IsValid)
        .endClass();
}
GCScriptTriggerMultiple::GCScriptTriggerMultiple(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCScriptTriggerMultiple::GCScriptTriggerMultiple(void *ptr) {
    m_ptr = ptr;
}
Vector GCScriptTriggerMultiple::GetExtent() const {
    return GetSchemaValue<Vector>(m_ptr, "CScriptTriggerMultiple", "m_vExtent");
}
void GCScriptTriggerMultiple::SetExtent(Vector value) {
    SetSchemaValue(m_ptr, "CScriptTriggerMultiple", "m_vExtent", false, value);
}
std::string GCScriptTriggerMultiple::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCScriptTriggerMultiple::IsValid() {
    return (m_ptr != nullptr);
}
GCTriggerMultiple GCScriptTriggerMultiple::GetParent() const {
    GCTriggerMultiple value(m_ptr);
    return value;
}
void GCScriptTriggerMultiple::SetParent(GCTriggerMultiple value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCScriptTriggerMultiple(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCScriptTriggerMultiple>("CScriptTriggerMultiple")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Extent", &GCScriptTriggerMultiple::GetExtent, &GCScriptTriggerMultiple::SetExtent)
        .addProperty("Parent", &GCScriptTriggerMultiple::GetParent, &GCScriptTriggerMultiple::SetParent)
        .addFunction("ToPtr", &GCScriptTriggerMultiple::ToPtr)
        .addFunction("IsValid", &GCScriptTriggerMultiple::IsValid)
        .endClass();
}
GCSoundOpvarSetAutoRoomEntity::GCSoundOpvarSetAutoRoomEntity(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCSoundOpvarSetAutoRoomEntity::GCSoundOpvarSetAutoRoomEntity(void *ptr) {
    m_ptr = ptr;
}
std::vector<GSoundOpvarTraceResult_t> GCSoundOpvarSetAutoRoomEntity::GetTraceResults() const {
    CUtlVector<GSoundOpvarTraceResult_t>* vec = GetSchemaValue<CUtlVector<GSoundOpvarTraceResult_t>*>(m_ptr, "CSoundOpvarSetAutoRoomEntity", "m_traceResults"); std::vector<GSoundOpvarTraceResult_t> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCSoundOpvarSetAutoRoomEntity::SetTraceResults(std::vector<GSoundOpvarTraceResult_t> value) {
    SetSchemaValueCUtlVector<GSoundOpvarTraceResult_t>(m_ptr, "CSoundOpvarSetAutoRoomEntity", "m_traceResults", false, value);
}
float GCSoundOpvarSetAutoRoomEntity::GetSize() const {
    return GetSchemaValue<float>(m_ptr, "CSoundOpvarSetAutoRoomEntity", "m_flSize");
}
void GCSoundOpvarSetAutoRoomEntity::SetSize(float value) {
    SetSchemaValue(m_ptr, "CSoundOpvarSetAutoRoomEntity", "m_flSize", false, value);
}
float GCSoundOpvarSetAutoRoomEntity::GetHeightTolerance() const {
    return GetSchemaValue<float>(m_ptr, "CSoundOpvarSetAutoRoomEntity", "m_flHeightTolerance");
}
void GCSoundOpvarSetAutoRoomEntity::SetHeightTolerance(float value) {
    SetSchemaValue(m_ptr, "CSoundOpvarSetAutoRoomEntity", "m_flHeightTolerance", false, value);
}
float GCSoundOpvarSetAutoRoomEntity::GetSizeSqr() const {
    return GetSchemaValue<float>(m_ptr, "CSoundOpvarSetAutoRoomEntity", "m_flSizeSqr");
}
void GCSoundOpvarSetAutoRoomEntity::SetSizeSqr(float value) {
    SetSchemaValue(m_ptr, "CSoundOpvarSetAutoRoomEntity", "m_flSizeSqr", false, value);
}
std::string GCSoundOpvarSetAutoRoomEntity::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCSoundOpvarSetAutoRoomEntity::IsValid() {
    return (m_ptr != nullptr);
}
GCSoundOpvarSetPointEntity GCSoundOpvarSetAutoRoomEntity::GetParent() const {
    GCSoundOpvarSetPointEntity value(m_ptr);
    return value;
}
void GCSoundOpvarSetAutoRoomEntity::SetParent(GCSoundOpvarSetPointEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCSoundOpvarSetAutoRoomEntity(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCSoundOpvarSetAutoRoomEntity>("CSoundOpvarSetAutoRoomEntity")
        .addConstructor<void (*)(std::string)>()
        .addProperty("TraceResults", &GCSoundOpvarSetAutoRoomEntity::GetTraceResults, &GCSoundOpvarSetAutoRoomEntity::SetTraceResults)
        .addProperty("Size", &GCSoundOpvarSetAutoRoomEntity::GetSize, &GCSoundOpvarSetAutoRoomEntity::SetSize)
        .addProperty("HeightTolerance", &GCSoundOpvarSetAutoRoomEntity::GetHeightTolerance, &GCSoundOpvarSetAutoRoomEntity::SetHeightTolerance)
        .addProperty("SizeSqr", &GCSoundOpvarSetAutoRoomEntity::GetSizeSqr, &GCSoundOpvarSetAutoRoomEntity::SetSizeSqr)
        .addProperty("Parent", &GCSoundOpvarSetAutoRoomEntity::GetParent, &GCSoundOpvarSetAutoRoomEntity::SetParent)
        .addFunction("ToPtr", &GCSoundOpvarSetAutoRoomEntity::ToPtr)
        .addFunction("IsValid", &GCSoundOpvarSetAutoRoomEntity::IsValid)
        .endClass();
}
GCBodyComponentPoint::GCBodyComponentPoint(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCBodyComponentPoint::GCBodyComponentPoint(void *ptr) {
    m_ptr = ptr;
}
GCGameSceneNode GCBodyComponentPoint::GetSceneNode() const {
    GCGameSceneNode value(GetSchemaPtr(m_ptr, "CBodyComponentPoint", "m_sceneNode"));
    return value;
}
void GCBodyComponentPoint::SetSceneNode(GCGameSceneNode value) {
    SetSchemaValue(m_ptr, "CBodyComponentPoint", "m_sceneNode", false, value);
}
std::string GCBodyComponentPoint::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCBodyComponentPoint::IsValid() {
    return (m_ptr != nullptr);
}
GCBodyComponent GCBodyComponentPoint::GetParent() const {
    GCBodyComponent value(m_ptr);
    return value;
}
void GCBodyComponentPoint::SetParent(GCBodyComponent value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCBodyComponentPoint(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCBodyComponentPoint>("CBodyComponentPoint")
        .addConstructor<void (*)(std::string)>()
        .addProperty("SceneNode", &GCBodyComponentPoint::GetSceneNode, &GCBodyComponentPoint::SetSceneNode)
        .addProperty("Parent", &GCBodyComponentPoint::GetParent, &GCBodyComponentPoint::SetParent)
        .addFunction("ToPtr", &GCBodyComponentPoint::ToPtr)
        .addFunction("IsValid", &GCBodyComponentPoint::IsValid)
        .endClass();
}
GFilterDamageType::GFilterDamageType(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GFilterDamageType::GFilterDamageType(void *ptr) {
    m_ptr = ptr;
}
int32_t GFilterDamageType::GetDamageType() const {
    return GetSchemaValue<int32_t>(m_ptr, "FilterDamageType", "m_iDamageType");
}
void GFilterDamageType::SetDamageType(int32_t value) {
    SetSchemaValue(m_ptr, "FilterDamageType", "m_iDamageType", false, value);
}
std::string GFilterDamageType::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GFilterDamageType::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseFilter GFilterDamageType::GetParent() const {
    GCBaseFilter value(m_ptr);
    return value;
}
void GFilterDamageType::SetParent(GCBaseFilter value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassFilterDamageType(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GFilterDamageType>("FilterDamageType")
        .addConstructor<void (*)(std::string)>()
        .addProperty("DamageType", &GFilterDamageType::GetDamageType, &GFilterDamageType::SetDamageType)
        .addProperty("Parent", &GFilterDamageType::GetParent, &GFilterDamageType::SetParent)
        .addFunction("ToPtr", &GFilterDamageType::ToPtr)
        .addFunction("IsValid", &GFilterDamageType::IsValid)
        .endClass();
}
GCBot::GCBot(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCBot::GCBot(void *ptr) {
    m_ptr = ptr;
}
GCCSPlayerController GCBot::GetController() const {
    GCCSPlayerController value(*GetSchemaValuePtr<void*>(m_ptr, "CBot", "m_pController"));
    return value;
}
void GCBot::SetController(GCCSPlayerController* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Controller' is not possible.\n");
}
GCCSPlayerPawn GCBot::GetPlayer() const {
    GCCSPlayerPawn value(*GetSchemaValuePtr<void*>(m_ptr, "CBot", "m_pPlayer"));
    return value;
}
void GCBot::SetPlayer(GCCSPlayerPawn* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Player' is not possible.\n");
}
bool GCBot::GetHasSpawned() const {
    return GetSchemaValue<bool>(m_ptr, "CBot", "m_bHasSpawned");
}
void GCBot::SetHasSpawned(bool value) {
    SetSchemaValue(m_ptr, "CBot", "m_bHasSpawned", false, value);
}
uint32_t GCBot::GetId() const {
    return GetSchemaValue<uint32_t>(m_ptr, "CBot", "m_id");
}
void GCBot::SetId(uint32_t value) {
    SetSchemaValue(m_ptr, "CBot", "m_id", false, value);
}
bool GCBot::GetIsRunning() const {
    return GetSchemaValue<bool>(m_ptr, "CBot", "m_isRunning");
}
void GCBot::SetIsRunning(bool value) {
    SetSchemaValue(m_ptr, "CBot", "m_isRunning", false, value);
}
bool GCBot::GetIsCrouching() const {
    return GetSchemaValue<bool>(m_ptr, "CBot", "m_isCrouching");
}
void GCBot::SetIsCrouching(bool value) {
    SetSchemaValue(m_ptr, "CBot", "m_isCrouching", false, value);
}
float GCBot::GetForwardSpeed() const {
    return GetSchemaValue<float>(m_ptr, "CBot", "m_forwardSpeed");
}
void GCBot::SetForwardSpeed(float value) {
    SetSchemaValue(m_ptr, "CBot", "m_forwardSpeed", false, value);
}
float GCBot::GetLeftSpeed() const {
    return GetSchemaValue<float>(m_ptr, "CBot", "m_leftSpeed");
}
void GCBot::SetLeftSpeed(float value) {
    SetSchemaValue(m_ptr, "CBot", "m_leftSpeed", false, value);
}
float GCBot::GetVerticalSpeed() const {
    return GetSchemaValue<float>(m_ptr, "CBot", "m_verticalSpeed");
}
void GCBot::SetVerticalSpeed(float value) {
    SetSchemaValue(m_ptr, "CBot", "m_verticalSpeed", false, value);
}
uint64_t GCBot::GetButtonFlags() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CBot", "m_buttonFlags");
}
void GCBot::SetButtonFlags(uint64_t value) {
    SetSchemaValue(m_ptr, "CBot", "m_buttonFlags", false, value);
}
float GCBot::GetJumpTimestamp() const {
    return GetSchemaValue<float>(m_ptr, "CBot", "m_jumpTimestamp");
}
void GCBot::SetJumpTimestamp(float value) {
    SetSchemaValue(m_ptr, "CBot", "m_jumpTimestamp", false, value);
}
Vector GCBot::GetViewForward() const {
    return GetSchemaValue<Vector>(m_ptr, "CBot", "m_viewForward");
}
void GCBot::SetViewForward(Vector value) {
    SetSchemaValue(m_ptr, "CBot", "m_viewForward", false, value);
}
int32_t GCBot::GetPostureStackIndex() const {
    return GetSchemaValue<int32_t>(m_ptr, "CBot", "m_postureStackIndex");
}
void GCBot::SetPostureStackIndex(int32_t value) {
    SetSchemaValue(m_ptr, "CBot", "m_postureStackIndex", false, value);
}
std::string GCBot::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCBot::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCBot(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCBot>("CBot")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Controller", &GCBot::GetController, &GCBot::SetController)
        .addProperty("Player", &GCBot::GetPlayer, &GCBot::SetPlayer)
        .addProperty("HasSpawned", &GCBot::GetHasSpawned, &GCBot::SetHasSpawned)
        .addProperty("Id", &GCBot::GetId, &GCBot::SetId)
        .addProperty("IsRunning", &GCBot::GetIsRunning, &GCBot::SetIsRunning)
        .addProperty("IsCrouching", &GCBot::GetIsCrouching, &GCBot::SetIsCrouching)
        .addProperty("ForwardSpeed", &GCBot::GetForwardSpeed, &GCBot::SetForwardSpeed)
        .addProperty("LeftSpeed", &GCBot::GetLeftSpeed, &GCBot::SetLeftSpeed)
        .addProperty("VerticalSpeed", &GCBot::GetVerticalSpeed, &GCBot::SetVerticalSpeed)
        .addProperty("ButtonFlags", &GCBot::GetButtonFlags, &GCBot::SetButtonFlags)
        .addProperty("JumpTimestamp", &GCBot::GetJumpTimestamp, &GCBot::SetJumpTimestamp)
        .addProperty("ViewForward", &GCBot::GetViewForward, &GCBot::SetViewForward)
        .addProperty("PostureStackIndex", &GCBot::GetPostureStackIndex, &GCBot::SetPostureStackIndex)
        .addFunction("ToPtr", &GCBot::ToPtr)
        .addFunction("IsValid", &GCBot::IsValid)
        .endClass();
}
GCMotorController::GCMotorController(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCMotorController::GCMotorController(void *ptr) {
    m_ptr = ptr;
}
float GCMotorController::GetSpeed() const {
    return GetSchemaValue<float>(m_ptr, "CMotorController", "m_speed");
}
void GCMotorController::SetSpeed(float value) {
    SetSchemaValue(m_ptr, "CMotorController", "m_speed", false, value);
}
float GCMotorController::GetMaxTorque() const {
    return GetSchemaValue<float>(m_ptr, "CMotorController", "m_maxTorque");
}
void GCMotorController::SetMaxTorque(float value) {
    SetSchemaValue(m_ptr, "CMotorController", "m_maxTorque", false, value);
}
Vector GCMotorController::GetAxis() const {
    return GetSchemaValue<Vector>(m_ptr, "CMotorController", "m_axis");
}
void GCMotorController::SetAxis(Vector value) {
    SetSchemaValue(m_ptr, "CMotorController", "m_axis", false, value);
}
float GCMotorController::GetInertiaFactor() const {
    return GetSchemaValue<float>(m_ptr, "CMotorController", "m_inertiaFactor");
}
void GCMotorController::SetInertiaFactor(float value) {
    SetSchemaValue(m_ptr, "CMotorController", "m_inertiaFactor", false, value);
}
std::string GCMotorController::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCMotorController::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCMotorController(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCMotorController>("CMotorController")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Speed", &GCMotorController::GetSpeed, &GCMotorController::SetSpeed)
        .addProperty("MaxTorque", &GCMotorController::GetMaxTorque, &GCMotorController::SetMaxTorque)
        .addProperty("Axis", &GCMotorController::GetAxis, &GCMotorController::SetAxis)
        .addProperty("InertiaFactor", &GCMotorController::GetInertiaFactor, &GCMotorController::SetInertiaFactor)
        .addFunction("ToPtr", &GCMotorController::ToPtr)
        .addFunction("IsValid", &GCMotorController::IsValid)
        .endClass();
}
GCSoundAreaEntitySphere::GCSoundAreaEntitySphere(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCSoundAreaEntitySphere::GCSoundAreaEntitySphere(void *ptr) {
    m_ptr = ptr;
}
float GCSoundAreaEntitySphere::GetRadius() const {
    return GetSchemaValue<float>(m_ptr, "CSoundAreaEntitySphere", "m_flRadius");
}
void GCSoundAreaEntitySphere::SetRadius(float value) {
    SetSchemaValue(m_ptr, "CSoundAreaEntitySphere", "m_flRadius", false, value);
}
std::string GCSoundAreaEntitySphere::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCSoundAreaEntitySphere::IsValid() {
    return (m_ptr != nullptr);
}
GCSoundAreaEntityBase GCSoundAreaEntitySphere::GetParent() const {
    GCSoundAreaEntityBase value(m_ptr);
    return value;
}
void GCSoundAreaEntitySphere::SetParent(GCSoundAreaEntityBase value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCSoundAreaEntitySphere(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCSoundAreaEntitySphere>("CSoundAreaEntitySphere")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Radius", &GCSoundAreaEntitySphere::GetRadius, &GCSoundAreaEntitySphere::SetRadius)
        .addProperty("Parent", &GCSoundAreaEntitySphere::GetParent, &GCSoundAreaEntitySphere::SetParent)
        .addFunction("ToPtr", &GCSoundAreaEntitySphere::ToPtr)
        .addFunction("IsValid", &GCSoundAreaEntitySphere::IsValid)
        .endClass();
}
GCCSPlayer_UseServices::GCCSPlayer_UseServices(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCCSPlayer_UseServices::GCCSPlayer_UseServices(void *ptr) {
    m_ptr = ptr;
}
GCBaseEntity GCCSPlayer_UseServices::GetLastKnownUseEntity() const {
    GCBaseEntity value(*GetSchemaValuePtr<void*>(m_ptr, "CCSPlayer_UseServices", "m_hLastKnownUseEntity"));
    return value;
}
void GCCSPlayer_UseServices::SetLastKnownUseEntity(GCBaseEntity* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'LastKnownUseEntity' is not possible.\n");
}
float GCCSPlayer_UseServices::GetLastUseTimeStamp() const {
    return GetSchemaValue<float>(m_ptr, "CCSPlayer_UseServices", "m_flLastUseTimeStamp");
}
void GCCSPlayer_UseServices::SetLastUseTimeStamp(float value) {
    SetSchemaValue(m_ptr, "CCSPlayer_UseServices", "m_flLastUseTimeStamp", false, value);
}
float GCCSPlayer_UseServices::GetTimeLastUsedWindow() const {
    return GetSchemaValue<float>(m_ptr, "CCSPlayer_UseServices", "m_flTimeLastUsedWindow");
}
void GCCSPlayer_UseServices::SetTimeLastUsedWindow(float value) {
    SetSchemaValue(m_ptr, "CCSPlayer_UseServices", "m_flTimeLastUsedWindow", false, value);
}
std::string GCCSPlayer_UseServices::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCCSPlayer_UseServices::IsValid() {
    return (m_ptr != nullptr);
}
GCPlayer_UseServices GCCSPlayer_UseServices::GetParent() const {
    GCPlayer_UseServices value(m_ptr);
    return value;
}
void GCCSPlayer_UseServices::SetParent(GCPlayer_UseServices value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCCSPlayer_UseServices(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCCSPlayer_UseServices>("CCSPlayer_UseServices")
        .addConstructor<void (*)(std::string)>()
        .addProperty("LastKnownUseEntity", &GCCSPlayer_UseServices::GetLastKnownUseEntity, &GCCSPlayer_UseServices::SetLastKnownUseEntity)
        .addProperty("LastUseTimeStamp", &GCCSPlayer_UseServices::GetLastUseTimeStamp, &GCCSPlayer_UseServices::SetLastUseTimeStamp)
        .addProperty("TimeLastUsedWindow", &GCCSPlayer_UseServices::GetTimeLastUsedWindow, &GCCSPlayer_UseServices::SetTimeLastUsedWindow)
        .addProperty("Parent", &GCCSPlayer_UseServices::GetParent, &GCCSPlayer_UseServices::SetParent)
        .addFunction("ToPtr", &GCCSPlayer_UseServices::ToPtr)
        .addFunction("IsValid", &GCCSPlayer_UseServices::IsValid)
        .endClass();
}
GCCSGO_WingmanIntroCounterTerroristPosition::GCCSGO_WingmanIntroCounterTerroristPosition(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCCSGO_WingmanIntroCounterTerroristPosition::GCCSGO_WingmanIntroCounterTerroristPosition(void *ptr) {
    m_ptr = ptr;
}
std::string GCCSGO_WingmanIntroCounterTerroristPosition::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCCSGO_WingmanIntroCounterTerroristPosition::IsValid() {
    return (m_ptr != nullptr);
}
GCCSGO_WingmanIntroCharacterPosition GCCSGO_WingmanIntroCounterTerroristPosition::GetParent() const {
    GCCSGO_WingmanIntroCharacterPosition value(m_ptr);
    return value;
}
void GCCSGO_WingmanIntroCounterTerroristPosition::SetParent(GCCSGO_WingmanIntroCharacterPosition value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCCSGO_WingmanIntroCounterTerroristPosition(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCCSGO_WingmanIntroCounterTerroristPosition>("CCSGO_WingmanIntroCounterTerroristPosition")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCCSGO_WingmanIntroCounterTerroristPosition::GetParent, &GCCSGO_WingmanIntroCounterTerroristPosition::SetParent)
        .addFunction("ToPtr", &GCCSGO_WingmanIntroCounterTerroristPosition::ToPtr)
        .addFunction("IsValid", &GCCSGO_WingmanIntroCounterTerroristPosition::IsValid)
        .endClass();
}
GCItemKevlar::GCItemKevlar(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCItemKevlar::GCItemKevlar(void *ptr) {
    m_ptr = ptr;
}
std::string GCItemKevlar::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCItemKevlar::IsValid() {
    return (m_ptr != nullptr);
}
GCItem GCItemKevlar::GetParent() const {
    GCItem value(m_ptr);
    return value;
}
void GCItemKevlar::SetParent(GCItem value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCItemKevlar(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCItemKevlar>("CItemKevlar")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCItemKevlar::GetParent, &GCItemKevlar::SetParent)
        .addFunction("ToPtr", &GCItemKevlar::ToPtr)
        .addFunction("IsValid", &GCItemKevlar::IsValid)
        .endClass();
}
GCTriggerHurt::GCTriggerHurt(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCTriggerHurt::GCTriggerHurt(void *ptr) {
    m_ptr = ptr;
}
float GCTriggerHurt::GetOriginalDamage() const {
    return GetSchemaValue<float>(m_ptr, "CTriggerHurt", "m_flOriginalDamage");
}
void GCTriggerHurt::SetOriginalDamage(float value) {
    SetSchemaValue(m_ptr, "CTriggerHurt", "m_flOriginalDamage", false, value);
}
float GCTriggerHurt::GetDamage() const {
    return GetSchemaValue<float>(m_ptr, "CTriggerHurt", "m_flDamage");
}
void GCTriggerHurt::SetDamage(float value) {
    SetSchemaValue(m_ptr, "CTriggerHurt", "m_flDamage", false, value);
}
float GCTriggerHurt::GetDamageCap() const {
    return GetSchemaValue<float>(m_ptr, "CTriggerHurt", "m_flDamageCap");
}
void GCTriggerHurt::SetDamageCap(float value) {
    SetSchemaValue(m_ptr, "CTriggerHurt", "m_flDamageCap", false, value);
}
float GCTriggerHurt::GetLastDmgTime() const {
    return GetSchemaValue<float>(m_ptr, "CTriggerHurt", "m_flLastDmgTime");
}
void GCTriggerHurt::SetLastDmgTime(float value) {
    SetSchemaValue(m_ptr, "CTriggerHurt", "m_flLastDmgTime", false, value);
}
float GCTriggerHurt::GetForgivenessDelay() const {
    return GetSchemaValue<float>(m_ptr, "CTriggerHurt", "m_flForgivenessDelay");
}
void GCTriggerHurt::SetForgivenessDelay(float value) {
    SetSchemaValue(m_ptr, "CTriggerHurt", "m_flForgivenessDelay", false, value);
}
int32_t GCTriggerHurt::GetBitsDamageInflict() const {
    return GetSchemaValue<int32_t>(m_ptr, "CTriggerHurt", "m_bitsDamageInflict");
}
void GCTriggerHurt::SetBitsDamageInflict(int32_t value) {
    SetSchemaValue(m_ptr, "CTriggerHurt", "m_bitsDamageInflict", false, value);
}
int32_t GCTriggerHurt::GetDamageModel() const {
    return GetSchemaValue<int32_t>(m_ptr, "CTriggerHurt", "m_damageModel");
}
void GCTriggerHurt::SetDamageModel(int32_t value) {
    SetSchemaValue(m_ptr, "CTriggerHurt", "m_damageModel", false, value);
}
bool GCTriggerHurt::GetNoDmgForce() const {
    return GetSchemaValue<bool>(m_ptr, "CTriggerHurt", "m_bNoDmgForce");
}
void GCTriggerHurt::SetNoDmgForce(bool value) {
    SetSchemaValue(m_ptr, "CTriggerHurt", "m_bNoDmgForce", false, value);
}
Vector GCTriggerHurt::GetDamageForce() const {
    return GetSchemaValue<Vector>(m_ptr, "CTriggerHurt", "m_vDamageForce");
}
void GCTriggerHurt::SetDamageForce(Vector value) {
    SetSchemaValue(m_ptr, "CTriggerHurt", "m_vDamageForce", false, value);
}
bool GCTriggerHurt::GetThinkAlways() const {
    return GetSchemaValue<bool>(m_ptr, "CTriggerHurt", "m_thinkAlways");
}
void GCTriggerHurt::SetThinkAlways(bool value) {
    SetSchemaValue(m_ptr, "CTriggerHurt", "m_thinkAlways", false, value);
}
float GCTriggerHurt::GetHurtThinkPeriod() const {
    return GetSchemaValue<float>(m_ptr, "CTriggerHurt", "m_hurtThinkPeriod");
}
void GCTriggerHurt::SetHurtThinkPeriod(float value) {
    SetSchemaValue(m_ptr, "CTriggerHurt", "m_hurtThinkPeriod", false, value);
}
GCEntityIOOutput GCTriggerHurt::GetOnHurt() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CTriggerHurt", "m_OnHurt"));
    return value;
}
void GCTriggerHurt::SetOnHurt(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CTriggerHurt", "m_OnHurt", false, value);
}
GCEntityIOOutput GCTriggerHurt::GetOnHurtPlayer() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CTriggerHurt", "m_OnHurtPlayer"));
    return value;
}
void GCTriggerHurt::SetOnHurtPlayer(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CTriggerHurt", "m_OnHurtPlayer", false, value);
}
std::string GCTriggerHurt::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCTriggerHurt::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseTrigger GCTriggerHurt::GetParent() const {
    GCBaseTrigger value(m_ptr);
    return value;
}
void GCTriggerHurt::SetParent(GCBaseTrigger value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCTriggerHurt(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCTriggerHurt>("CTriggerHurt")
        .addConstructor<void (*)(std::string)>()
        .addProperty("OriginalDamage", &GCTriggerHurt::GetOriginalDamage, &GCTriggerHurt::SetOriginalDamage)
        .addProperty("Damage", &GCTriggerHurt::GetDamage, &GCTriggerHurt::SetDamage)
        .addProperty("DamageCap", &GCTriggerHurt::GetDamageCap, &GCTriggerHurt::SetDamageCap)
        .addProperty("LastDmgTime", &GCTriggerHurt::GetLastDmgTime, &GCTriggerHurt::SetLastDmgTime)
        .addProperty("ForgivenessDelay", &GCTriggerHurt::GetForgivenessDelay, &GCTriggerHurt::SetForgivenessDelay)
        .addProperty("BitsDamageInflict", &GCTriggerHurt::GetBitsDamageInflict, &GCTriggerHurt::SetBitsDamageInflict)
        .addProperty("DamageModel", &GCTriggerHurt::GetDamageModel, &GCTriggerHurt::SetDamageModel)
        .addProperty("NoDmgForce", &GCTriggerHurt::GetNoDmgForce, &GCTriggerHurt::SetNoDmgForce)
        .addProperty("DamageForce", &GCTriggerHurt::GetDamageForce, &GCTriggerHurt::SetDamageForce)
        .addProperty("ThinkAlways", &GCTriggerHurt::GetThinkAlways, &GCTriggerHurt::SetThinkAlways)
        .addProperty("HurtThinkPeriod", &GCTriggerHurt::GetHurtThinkPeriod, &GCTriggerHurt::SetHurtThinkPeriod)
        .addProperty("OnHurt", &GCTriggerHurt::GetOnHurt, &GCTriggerHurt::SetOnHurt)
        .addProperty("OnHurtPlayer", &GCTriggerHurt::GetOnHurtPlayer, &GCTriggerHurt::SetOnHurtPlayer)
        .addProperty("Parent", &GCTriggerHurt::GetParent, &GCTriggerHurt::SetParent)
        .addFunction("ToPtr", &GCTriggerHurt::ToPtr)
        .addFunction("IsValid", &GCTriggerHurt::IsValid)
        .endClass();
}
GCPhysBallSocket::GCPhysBallSocket(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCPhysBallSocket::GCPhysBallSocket(void *ptr) {
    m_ptr = ptr;
}
float GCPhysBallSocket::GetJointFriction() const {
    return GetSchemaValue<float>(m_ptr, "CPhysBallSocket", "m_flJointFriction");
}
void GCPhysBallSocket::SetJointFriction(float value) {
    SetSchemaValue(m_ptr, "CPhysBallSocket", "m_flJointFriction", false, value);
}
bool GCPhysBallSocket::GetEnableSwingLimit() const {
    return GetSchemaValue<bool>(m_ptr, "CPhysBallSocket", "m_bEnableSwingLimit");
}
void GCPhysBallSocket::SetEnableSwingLimit(bool value) {
    SetSchemaValue(m_ptr, "CPhysBallSocket", "m_bEnableSwingLimit", false, value);
}
float GCPhysBallSocket::GetSwingLimit() const {
    return GetSchemaValue<float>(m_ptr, "CPhysBallSocket", "m_flSwingLimit");
}
void GCPhysBallSocket::SetSwingLimit(float value) {
    SetSchemaValue(m_ptr, "CPhysBallSocket", "m_flSwingLimit", false, value);
}
bool GCPhysBallSocket::GetEnableTwistLimit() const {
    return GetSchemaValue<bool>(m_ptr, "CPhysBallSocket", "m_bEnableTwistLimit");
}
void GCPhysBallSocket::SetEnableTwistLimit(bool value) {
    SetSchemaValue(m_ptr, "CPhysBallSocket", "m_bEnableTwistLimit", false, value);
}
float GCPhysBallSocket::GetMinTwistAngle() const {
    return GetSchemaValue<float>(m_ptr, "CPhysBallSocket", "m_flMinTwistAngle");
}
void GCPhysBallSocket::SetMinTwistAngle(float value) {
    SetSchemaValue(m_ptr, "CPhysBallSocket", "m_flMinTwistAngle", false, value);
}
float GCPhysBallSocket::GetMaxTwistAngle() const {
    return GetSchemaValue<float>(m_ptr, "CPhysBallSocket", "m_flMaxTwistAngle");
}
void GCPhysBallSocket::SetMaxTwistAngle(float value) {
    SetSchemaValue(m_ptr, "CPhysBallSocket", "m_flMaxTwistAngle", false, value);
}
std::string GCPhysBallSocket::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCPhysBallSocket::IsValid() {
    return (m_ptr != nullptr);
}
GCPhysConstraint GCPhysBallSocket::GetParent() const {
    GCPhysConstraint value(m_ptr);
    return value;
}
void GCPhysBallSocket::SetParent(GCPhysConstraint value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCPhysBallSocket(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCPhysBallSocket>("CPhysBallSocket")
        .addConstructor<void (*)(std::string)>()
        .addProperty("JointFriction", &GCPhysBallSocket::GetJointFriction, &GCPhysBallSocket::SetJointFriction)
        .addProperty("EnableSwingLimit", &GCPhysBallSocket::GetEnableSwingLimit, &GCPhysBallSocket::SetEnableSwingLimit)
        .addProperty("SwingLimit", &GCPhysBallSocket::GetSwingLimit, &GCPhysBallSocket::SetSwingLimit)
        .addProperty("EnableTwistLimit", &GCPhysBallSocket::GetEnableTwistLimit, &GCPhysBallSocket::SetEnableTwistLimit)
        .addProperty("MinTwistAngle", &GCPhysBallSocket::GetMinTwistAngle, &GCPhysBallSocket::SetMinTwistAngle)
        .addProperty("MaxTwistAngle", &GCPhysBallSocket::GetMaxTwistAngle, &GCPhysBallSocket::SetMaxTwistAngle)
        .addProperty("Parent", &GCPhysBallSocket::GetParent, &GCPhysBallSocket::SetParent)
        .addFunction("ToPtr", &GCPhysBallSocket::ToPtr)
        .addFunction("IsValid", &GCPhysBallSocket::IsValid)
        .endClass();
}
GCMapVetoPickController::GCMapVetoPickController(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCMapVetoPickController::GCMapVetoPickController(void *ptr) {
    m_ptr = ptr;
}
bool GCMapVetoPickController::GetPlayedIntroVcd() const {
    return GetSchemaValue<bool>(m_ptr, "CMapVetoPickController", "m_bPlayedIntroVcd");
}
void GCMapVetoPickController::SetPlayedIntroVcd(bool value) {
    SetSchemaValue(m_ptr, "CMapVetoPickController", "m_bPlayedIntroVcd", false, value);
}
bool GCMapVetoPickController::GetNeedToPlayFiveSecondsRemaining() const {
    return GetSchemaValue<bool>(m_ptr, "CMapVetoPickController", "m_bNeedToPlayFiveSecondsRemaining");
}
void GCMapVetoPickController::SetNeedToPlayFiveSecondsRemaining(bool value) {
    SetSchemaValue(m_ptr, "CMapVetoPickController", "m_bNeedToPlayFiveSecondsRemaining", false, value);
}
double GCMapVetoPickController::GetDblPreMatchDraftSequenceTime() const {
    return GetSchemaValue<double>(m_ptr, "CMapVetoPickController", "m_dblPreMatchDraftSequenceTime");
}
void GCMapVetoPickController::SetDblPreMatchDraftSequenceTime(double value) {
    SetSchemaValue(m_ptr, "CMapVetoPickController", "m_dblPreMatchDraftSequenceTime", false, value);
}
bool GCMapVetoPickController::GetPreMatchDraftStateChanged() const {
    return GetSchemaValue<bool>(m_ptr, "CMapVetoPickController", "m_bPreMatchDraftStateChanged");
}
void GCMapVetoPickController::SetPreMatchDraftStateChanged(bool value) {
    SetSchemaValue(m_ptr, "CMapVetoPickController", "m_bPreMatchDraftStateChanged", false, value);
}
int32_t GCMapVetoPickController::GetDraftType() const {
    return GetSchemaValue<int32_t>(m_ptr, "CMapVetoPickController", "m_nDraftType");
}
void GCMapVetoPickController::SetDraftType(int32_t value) {
    SetSchemaValue(m_ptr, "CMapVetoPickController", "m_nDraftType", false, value);
}
int32_t GCMapVetoPickController::GetTeamWinningCoinToss() const {
    return GetSchemaValue<int32_t>(m_ptr, "CMapVetoPickController", "m_nTeamWinningCoinToss");
}
void GCMapVetoPickController::SetTeamWinningCoinToss(int32_t value) {
    SetSchemaValue(m_ptr, "CMapVetoPickController", "m_nTeamWinningCoinToss", false, value);
}
std::vector<int32_t> GCMapVetoPickController::GetTeamWithFirstChoice() const {
    int32_t* outValue = GetSchemaValue<int32_t*>(m_ptr, "CMapVetoPickController", "m_nTeamWithFirstChoice"); std::vector<int32_t> ret; for(int i = 0; i < 64; i++) { ret.push_back(outValue[i]); } return ret;
}
void GCMapVetoPickController::SetTeamWithFirstChoice(std::vector<int32_t> value) {
    int32_t* outValue = GetSchemaValue<int32_t*>(m_ptr, "CMapVetoPickController", "m_nTeamWithFirstChoice"); for(int i = 0; i < 64; i++) { outValue[i] = value[i]; } SetSchemaValue(m_ptr, "CMapVetoPickController", "m_nTeamWithFirstChoice", false, outValue);
}
std::vector<int32_t> GCMapVetoPickController::GetVoteMapIdsList() const {
    int32_t* outValue = GetSchemaValue<int32_t*>(m_ptr, "CMapVetoPickController", "m_nVoteMapIdsList"); std::vector<int32_t> ret; for(int i = 0; i < 7; i++) { ret.push_back(outValue[i]); } return ret;
}
void GCMapVetoPickController::SetVoteMapIdsList(std::vector<int32_t> value) {
    int32_t* outValue = GetSchemaValue<int32_t*>(m_ptr, "CMapVetoPickController", "m_nVoteMapIdsList"); for(int i = 0; i < 7; i++) { outValue[i] = value[i]; } SetSchemaValue(m_ptr, "CMapVetoPickController", "m_nVoteMapIdsList", false, outValue);
}
std::vector<int32_t> GCMapVetoPickController::GetAccountIDs() const {
    int32_t* outValue = GetSchemaValue<int32_t*>(m_ptr, "CMapVetoPickController", "m_nAccountIDs"); std::vector<int32_t> ret; for(int i = 0; i < 64; i++) { ret.push_back(outValue[i]); } return ret;
}
void GCMapVetoPickController::SetAccountIDs(std::vector<int32_t> value) {
    int32_t* outValue = GetSchemaValue<int32_t*>(m_ptr, "CMapVetoPickController", "m_nAccountIDs"); for(int i = 0; i < 64; i++) { outValue[i] = value[i]; } SetSchemaValue(m_ptr, "CMapVetoPickController", "m_nAccountIDs", false, outValue);
}
std::vector<int32_t> GCMapVetoPickController::GetMapId0() const {
    int32_t* outValue = GetSchemaValue<int32_t*>(m_ptr, "CMapVetoPickController", "m_nMapId0"); std::vector<int32_t> ret; for(int i = 0; i < 64; i++) { ret.push_back(outValue[i]); } return ret;
}
void GCMapVetoPickController::SetMapId0(std::vector<int32_t> value) {
    int32_t* outValue = GetSchemaValue<int32_t*>(m_ptr, "CMapVetoPickController", "m_nMapId0"); for(int i = 0; i < 64; i++) { outValue[i] = value[i]; } SetSchemaValue(m_ptr, "CMapVetoPickController", "m_nMapId0", false, outValue);
}
std::vector<int32_t> GCMapVetoPickController::GetMapId1() const {
    int32_t* outValue = GetSchemaValue<int32_t*>(m_ptr, "CMapVetoPickController", "m_nMapId1"); std::vector<int32_t> ret; for(int i = 0; i < 64; i++) { ret.push_back(outValue[i]); } return ret;
}
void GCMapVetoPickController::SetMapId1(std::vector<int32_t> value) {
    int32_t* outValue = GetSchemaValue<int32_t*>(m_ptr, "CMapVetoPickController", "m_nMapId1"); for(int i = 0; i < 64; i++) { outValue[i] = value[i]; } SetSchemaValue(m_ptr, "CMapVetoPickController", "m_nMapId1", false, outValue);
}
std::vector<int32_t> GCMapVetoPickController::GetMapId2() const {
    int32_t* outValue = GetSchemaValue<int32_t*>(m_ptr, "CMapVetoPickController", "m_nMapId2"); std::vector<int32_t> ret; for(int i = 0; i < 64; i++) { ret.push_back(outValue[i]); } return ret;
}
void GCMapVetoPickController::SetMapId2(std::vector<int32_t> value) {
    int32_t* outValue = GetSchemaValue<int32_t*>(m_ptr, "CMapVetoPickController", "m_nMapId2"); for(int i = 0; i < 64; i++) { outValue[i] = value[i]; } SetSchemaValue(m_ptr, "CMapVetoPickController", "m_nMapId2", false, outValue);
}
std::vector<int32_t> GCMapVetoPickController::GetMapId3() const {
    int32_t* outValue = GetSchemaValue<int32_t*>(m_ptr, "CMapVetoPickController", "m_nMapId3"); std::vector<int32_t> ret; for(int i = 0; i < 64; i++) { ret.push_back(outValue[i]); } return ret;
}
void GCMapVetoPickController::SetMapId3(std::vector<int32_t> value) {
    int32_t* outValue = GetSchemaValue<int32_t*>(m_ptr, "CMapVetoPickController", "m_nMapId3"); for(int i = 0; i < 64; i++) { outValue[i] = value[i]; } SetSchemaValue(m_ptr, "CMapVetoPickController", "m_nMapId3", false, outValue);
}
std::vector<int32_t> GCMapVetoPickController::GetMapId4() const {
    int32_t* outValue = GetSchemaValue<int32_t*>(m_ptr, "CMapVetoPickController", "m_nMapId4"); std::vector<int32_t> ret; for(int i = 0; i < 64; i++) { ret.push_back(outValue[i]); } return ret;
}
void GCMapVetoPickController::SetMapId4(std::vector<int32_t> value) {
    int32_t* outValue = GetSchemaValue<int32_t*>(m_ptr, "CMapVetoPickController", "m_nMapId4"); for(int i = 0; i < 64; i++) { outValue[i] = value[i]; } SetSchemaValue(m_ptr, "CMapVetoPickController", "m_nMapId4", false, outValue);
}
std::vector<int32_t> GCMapVetoPickController::GetMapId5() const {
    int32_t* outValue = GetSchemaValue<int32_t*>(m_ptr, "CMapVetoPickController", "m_nMapId5"); std::vector<int32_t> ret; for(int i = 0; i < 64; i++) { ret.push_back(outValue[i]); } return ret;
}
void GCMapVetoPickController::SetMapId5(std::vector<int32_t> value) {
    int32_t* outValue = GetSchemaValue<int32_t*>(m_ptr, "CMapVetoPickController", "m_nMapId5"); for(int i = 0; i < 64; i++) { outValue[i] = value[i]; } SetSchemaValue(m_ptr, "CMapVetoPickController", "m_nMapId5", false, outValue);
}
std::vector<int32_t> GCMapVetoPickController::GetStartingSide0() const {
    int32_t* outValue = GetSchemaValue<int32_t*>(m_ptr, "CMapVetoPickController", "m_nStartingSide0"); std::vector<int32_t> ret; for(int i = 0; i < 64; i++) { ret.push_back(outValue[i]); } return ret;
}
void GCMapVetoPickController::SetStartingSide0(std::vector<int32_t> value) {
    int32_t* outValue = GetSchemaValue<int32_t*>(m_ptr, "CMapVetoPickController", "m_nStartingSide0"); for(int i = 0; i < 64; i++) { outValue[i] = value[i]; } SetSchemaValue(m_ptr, "CMapVetoPickController", "m_nStartingSide0", false, outValue);
}
int32_t GCMapVetoPickController::GetCurrentPhase() const {
    return GetSchemaValue<int32_t>(m_ptr, "CMapVetoPickController", "m_nCurrentPhase");
}
void GCMapVetoPickController::SetCurrentPhase(int32_t value) {
    SetSchemaValue(m_ptr, "CMapVetoPickController", "m_nCurrentPhase", false, value);
}
int32_t GCMapVetoPickController::GetPhaseStartTick() const {
    return GetSchemaValue<int32_t>(m_ptr, "CMapVetoPickController", "m_nPhaseStartTick");
}
void GCMapVetoPickController::SetPhaseStartTick(int32_t value) {
    SetSchemaValue(m_ptr, "CMapVetoPickController", "m_nPhaseStartTick", false, value);
}
int32_t GCMapVetoPickController::GetPhaseDurationTicks() const {
    return GetSchemaValue<int32_t>(m_ptr, "CMapVetoPickController", "m_nPhaseDurationTicks");
}
void GCMapVetoPickController::SetPhaseDurationTicks(int32_t value) {
    SetSchemaValue(m_ptr, "CMapVetoPickController", "m_nPhaseDurationTicks", false, value);
}
std::string GCMapVetoPickController::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCMapVetoPickController::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseEntity GCMapVetoPickController::GetParent() const {
    GCBaseEntity value(m_ptr);
    return value;
}
void GCMapVetoPickController::SetParent(GCBaseEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCMapVetoPickController(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCMapVetoPickController>("CMapVetoPickController")
        .addConstructor<void (*)(std::string)>()
        .addProperty("PlayedIntroVcd", &GCMapVetoPickController::GetPlayedIntroVcd, &GCMapVetoPickController::SetPlayedIntroVcd)
        .addProperty("NeedToPlayFiveSecondsRemaining", &GCMapVetoPickController::GetNeedToPlayFiveSecondsRemaining, &GCMapVetoPickController::SetNeedToPlayFiveSecondsRemaining)
        .addProperty("DblPreMatchDraftSequenceTime", &GCMapVetoPickController::GetDblPreMatchDraftSequenceTime, &GCMapVetoPickController::SetDblPreMatchDraftSequenceTime)
        .addProperty("PreMatchDraftStateChanged", &GCMapVetoPickController::GetPreMatchDraftStateChanged, &GCMapVetoPickController::SetPreMatchDraftStateChanged)
        .addProperty("DraftType", &GCMapVetoPickController::GetDraftType, &GCMapVetoPickController::SetDraftType)
        .addProperty("TeamWinningCoinToss", &GCMapVetoPickController::GetTeamWinningCoinToss, &GCMapVetoPickController::SetTeamWinningCoinToss)
        .addProperty("TeamWithFirstChoice", &GCMapVetoPickController::GetTeamWithFirstChoice, &GCMapVetoPickController::SetTeamWithFirstChoice)
        .addProperty("VoteMapIdsList", &GCMapVetoPickController::GetVoteMapIdsList, &GCMapVetoPickController::SetVoteMapIdsList)
        .addProperty("AccountIDs", &GCMapVetoPickController::GetAccountIDs, &GCMapVetoPickController::SetAccountIDs)
        .addProperty("MapId0", &GCMapVetoPickController::GetMapId0, &GCMapVetoPickController::SetMapId0)
        .addProperty("MapId1", &GCMapVetoPickController::GetMapId1, &GCMapVetoPickController::SetMapId1)
        .addProperty("MapId2", &GCMapVetoPickController::GetMapId2, &GCMapVetoPickController::SetMapId2)
        .addProperty("MapId3", &GCMapVetoPickController::GetMapId3, &GCMapVetoPickController::SetMapId3)
        .addProperty("MapId4", &GCMapVetoPickController::GetMapId4, &GCMapVetoPickController::SetMapId4)
        .addProperty("MapId5", &GCMapVetoPickController::GetMapId5, &GCMapVetoPickController::SetMapId5)
        .addProperty("StartingSide0", &GCMapVetoPickController::GetStartingSide0, &GCMapVetoPickController::SetStartingSide0)
        .addProperty("CurrentPhase", &GCMapVetoPickController::GetCurrentPhase, &GCMapVetoPickController::SetCurrentPhase)
        .addProperty("PhaseStartTick", &GCMapVetoPickController::GetPhaseStartTick, &GCMapVetoPickController::SetPhaseStartTick)
        .addProperty("PhaseDurationTicks", &GCMapVetoPickController::GetPhaseDurationTicks, &GCMapVetoPickController::SetPhaseDurationTicks)
        .addProperty("Parent", &GCMapVetoPickController::GetParent, &GCMapVetoPickController::SetParent)
        .addFunction("ToPtr", &GCMapVetoPickController::ToPtr)
        .addFunction("IsValid", &GCMapVetoPickController::IsValid)
        .endClass();
}
GCCSMinimapBoundary::GCCSMinimapBoundary(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCCSMinimapBoundary::GCCSMinimapBoundary(void *ptr) {
    m_ptr = ptr;
}
std::string GCCSMinimapBoundary::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCCSMinimapBoundary::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseEntity GCCSMinimapBoundary::GetParent() const {
    GCBaseEntity value(m_ptr);
    return value;
}
void GCCSMinimapBoundary::SetParent(GCBaseEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCCSMinimapBoundary(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCCSMinimapBoundary>("CCSMinimapBoundary")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCCSMinimapBoundary::GetParent, &GCCSMinimapBoundary::SetParent)
        .addFunction("ToPtr", &GCCSMinimapBoundary::ToPtr)
        .addFunction("IsValid", &GCCSMinimapBoundary::IsValid)
        .endClass();
}
GCSoundEnt::GCSoundEnt(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCSoundEnt::GCSoundEnt(void *ptr) {
    m_ptr = ptr;
}
int32_t GCSoundEnt::GetFreeSound() const {
    return GetSchemaValue<int32_t>(m_ptr, "CSoundEnt", "m_iFreeSound");
}
void GCSoundEnt::SetFreeSound(int32_t value) {
    SetSchemaValue(m_ptr, "CSoundEnt", "m_iFreeSound", false, value);
}
int32_t GCSoundEnt::GetActiveSound() const {
    return GetSchemaValue<int32_t>(m_ptr, "CSoundEnt", "m_iActiveSound");
}
void GCSoundEnt::SetActiveSound(int32_t value) {
    SetSchemaValue(m_ptr, "CSoundEnt", "m_iActiveSound", false, value);
}
int32_t GCSoundEnt::GetCLastActiveSounds() const {
    return GetSchemaValue<int32_t>(m_ptr, "CSoundEnt", "m_cLastActiveSounds");
}
void GCSoundEnt::SetCLastActiveSounds(int32_t value) {
    SetSchemaValue(m_ptr, "CSoundEnt", "m_cLastActiveSounds", false, value);
}
std::vector<GCSound> GCSoundEnt::GetSoundPool() const {
    GCSound* outValue = GetSchemaValue<GCSound*>(m_ptr, "CSoundEnt", "m_SoundPool"); std::vector<GCSound> ret; for(int i = 0; i < 128; i++) { ret.push_back(outValue[i]); } return ret;
}
void GCSoundEnt::SetSoundPool(std::vector<GCSound> value) {
    GCSound* outValue = GetSchemaValue<GCSound*>(m_ptr, "CSoundEnt", "m_SoundPool"); for(int i = 0; i < 128; i++) { outValue[i] = value[i]; } SetSchemaValue(m_ptr, "CSoundEnt", "m_SoundPool", false, outValue);
}
std::string GCSoundEnt::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCSoundEnt::IsValid() {
    return (m_ptr != nullptr);
}
GCPointEntity GCSoundEnt::GetParent() const {
    GCPointEntity value(m_ptr);
    return value;
}
void GCSoundEnt::SetParent(GCPointEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCSoundEnt(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCSoundEnt>("CSoundEnt")
        .addConstructor<void (*)(std::string)>()
        .addProperty("FreeSound", &GCSoundEnt::GetFreeSound, &GCSoundEnt::SetFreeSound)
        .addProperty("ActiveSound", &GCSoundEnt::GetActiveSound, &GCSoundEnt::SetActiveSound)
        .addProperty("CLastActiveSounds", &GCSoundEnt::GetCLastActiveSounds, &GCSoundEnt::SetCLastActiveSounds)
        .addProperty("SoundPool", &GCSoundEnt::GetSoundPool, &GCSoundEnt::SetSoundPool)
        .addProperty("Parent", &GCSoundEnt::GetParent, &GCSoundEnt::SetParent)
        .addFunction("ToPtr", &GCSoundEnt::ToPtr)
        .addFunction("IsValid", &GCSoundEnt::IsValid)
        .endClass();
}
GCInfoSpawnGroupLandmark::GCInfoSpawnGroupLandmark(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCInfoSpawnGroupLandmark::GCInfoSpawnGroupLandmark(void *ptr) {
    m_ptr = ptr;
}
std::string GCInfoSpawnGroupLandmark::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCInfoSpawnGroupLandmark::IsValid() {
    return (m_ptr != nullptr);
}
GCPointEntity GCInfoSpawnGroupLandmark::GetParent() const {
    GCPointEntity value(m_ptr);
    return value;
}
void GCInfoSpawnGroupLandmark::SetParent(GCPointEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCInfoSpawnGroupLandmark(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCInfoSpawnGroupLandmark>("CInfoSpawnGroupLandmark")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCInfoSpawnGroupLandmark::GetParent, &GCInfoSpawnGroupLandmark::SetParent)
        .addFunction("ToPtr", &GCInfoSpawnGroupLandmark::ToPtr)
        .addFunction("IsValid", &GCInfoSpawnGroupLandmark::IsValid)
        .endClass();
}
GCPlayer_MovementServices_Humanoid::GCPlayer_MovementServices_Humanoid(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCPlayer_MovementServices_Humanoid::GCPlayer_MovementServices_Humanoid(void *ptr) {
    m_ptr = ptr;
}
float GCPlayer_MovementServices_Humanoid::GetStepSoundTime() const {
    return GetSchemaValue<float>(m_ptr, "CPlayer_MovementServices_Humanoid", "m_flStepSoundTime");
}
void GCPlayer_MovementServices_Humanoid::SetStepSoundTime(float value) {
    SetSchemaValue(m_ptr, "CPlayer_MovementServices_Humanoid", "m_flStepSoundTime", false, value);
}
float GCPlayer_MovementServices_Humanoid::GetFallVelocity() const {
    return GetSchemaValue<float>(m_ptr, "CPlayer_MovementServices_Humanoid", "m_flFallVelocity");
}
void GCPlayer_MovementServices_Humanoid::SetFallVelocity(float value) {
    SetSchemaValue(m_ptr, "CPlayer_MovementServices_Humanoid", "m_flFallVelocity", false, value);
}
bool GCPlayer_MovementServices_Humanoid::GetInCrouch() const {
    return GetSchemaValue<bool>(m_ptr, "CPlayer_MovementServices_Humanoid", "m_bInCrouch");
}
void GCPlayer_MovementServices_Humanoid::SetInCrouch(bool value) {
    SetSchemaValue(m_ptr, "CPlayer_MovementServices_Humanoid", "m_bInCrouch", false, value);
}
uint32_t GCPlayer_MovementServices_Humanoid::GetCrouchState() const {
    return GetSchemaValue<uint32_t>(m_ptr, "CPlayer_MovementServices_Humanoid", "m_nCrouchState");
}
void GCPlayer_MovementServices_Humanoid::SetCrouchState(uint32_t value) {
    SetSchemaValue(m_ptr, "CPlayer_MovementServices_Humanoid", "m_nCrouchState", false, value);
}
float GCPlayer_MovementServices_Humanoid::GetCrouchTransitionStartTime() const {
    return GetSchemaValue<float>(m_ptr, "CPlayer_MovementServices_Humanoid", "m_flCrouchTransitionStartTime");
}
void GCPlayer_MovementServices_Humanoid::SetCrouchTransitionStartTime(float value) {
    SetSchemaValue(m_ptr, "CPlayer_MovementServices_Humanoid", "m_flCrouchTransitionStartTime", false, value);
}
bool GCPlayer_MovementServices_Humanoid::GetDucked() const {
    return GetSchemaValue<bool>(m_ptr, "CPlayer_MovementServices_Humanoid", "m_bDucked");
}
void GCPlayer_MovementServices_Humanoid::SetDucked(bool value) {
    SetSchemaValue(m_ptr, "CPlayer_MovementServices_Humanoid", "m_bDucked", false, value);
}
bool GCPlayer_MovementServices_Humanoid::GetDucking() const {
    return GetSchemaValue<bool>(m_ptr, "CPlayer_MovementServices_Humanoid", "m_bDucking");
}
void GCPlayer_MovementServices_Humanoid::SetDucking(bool value) {
    SetSchemaValue(m_ptr, "CPlayer_MovementServices_Humanoid", "m_bDucking", false, value);
}
bool GCPlayer_MovementServices_Humanoid::GetInDuckJump() const {
    return GetSchemaValue<bool>(m_ptr, "CPlayer_MovementServices_Humanoid", "m_bInDuckJump");
}
void GCPlayer_MovementServices_Humanoid::SetInDuckJump(bool value) {
    SetSchemaValue(m_ptr, "CPlayer_MovementServices_Humanoid", "m_bInDuckJump", false, value);
}
Vector GCPlayer_MovementServices_Humanoid::GetGroundNormal() const {
    return GetSchemaValue<Vector>(m_ptr, "CPlayer_MovementServices_Humanoid", "m_groundNormal");
}
void GCPlayer_MovementServices_Humanoid::SetGroundNormal(Vector value) {
    SetSchemaValue(m_ptr, "CPlayer_MovementServices_Humanoid", "m_groundNormal", false, value);
}
float GCPlayer_MovementServices_Humanoid::GetSurfaceFriction() const {
    return GetSchemaValue<float>(m_ptr, "CPlayer_MovementServices_Humanoid", "m_flSurfaceFriction");
}
void GCPlayer_MovementServices_Humanoid::SetSurfaceFriction(float value) {
    SetSchemaValue(m_ptr, "CPlayer_MovementServices_Humanoid", "m_flSurfaceFriction", false, value);
}
CUtlStringToken GCPlayer_MovementServices_Humanoid::GetSurfaceProps() const {
    return GetSchemaValue<CUtlStringToken>(m_ptr, "CPlayer_MovementServices_Humanoid", "m_surfaceProps");
}
void GCPlayer_MovementServices_Humanoid::SetSurfaceProps(CUtlStringToken value) {
    SetSchemaValue(m_ptr, "CPlayer_MovementServices_Humanoid", "m_surfaceProps", false, value);
}
int32_t GCPlayer_MovementServices_Humanoid::GetStepside() const {
    return GetSchemaValue<int32_t>(m_ptr, "CPlayer_MovementServices_Humanoid", "m_nStepside");
}
void GCPlayer_MovementServices_Humanoid::SetStepside(int32_t value) {
    SetSchemaValue(m_ptr, "CPlayer_MovementServices_Humanoid", "m_nStepside", false, value);
}
int32_t GCPlayer_MovementServices_Humanoid::GetTargetVolume() const {
    return GetSchemaValue<int32_t>(m_ptr, "CPlayer_MovementServices_Humanoid", "m_iTargetVolume");
}
void GCPlayer_MovementServices_Humanoid::SetTargetVolume(int32_t value) {
    SetSchemaValue(m_ptr, "CPlayer_MovementServices_Humanoid", "m_iTargetVolume", false, value);
}
Vector GCPlayer_MovementServices_Humanoid::GetSmoothedVelocity() const {
    return GetSchemaValue<Vector>(m_ptr, "CPlayer_MovementServices_Humanoid", "m_vecSmoothedVelocity");
}
void GCPlayer_MovementServices_Humanoid::SetSmoothedVelocity(Vector value) {
    SetSchemaValue(m_ptr, "CPlayer_MovementServices_Humanoid", "m_vecSmoothedVelocity", false, value);
}
std::string GCPlayer_MovementServices_Humanoid::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCPlayer_MovementServices_Humanoid::IsValid() {
    return (m_ptr != nullptr);
}
GCPlayer_MovementServices GCPlayer_MovementServices_Humanoid::GetParent() const {
    GCPlayer_MovementServices value(m_ptr);
    return value;
}
void GCPlayer_MovementServices_Humanoid::SetParent(GCPlayer_MovementServices value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCPlayer_MovementServices_Humanoid(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCPlayer_MovementServices_Humanoid>("CPlayer_MovementServices_Humanoid")
        .addConstructor<void (*)(std::string)>()
        .addProperty("StepSoundTime", &GCPlayer_MovementServices_Humanoid::GetStepSoundTime, &GCPlayer_MovementServices_Humanoid::SetStepSoundTime)
        .addProperty("FallVelocity", &GCPlayer_MovementServices_Humanoid::GetFallVelocity, &GCPlayer_MovementServices_Humanoid::SetFallVelocity)
        .addProperty("InCrouch", &GCPlayer_MovementServices_Humanoid::GetInCrouch, &GCPlayer_MovementServices_Humanoid::SetInCrouch)
        .addProperty("CrouchState", &GCPlayer_MovementServices_Humanoid::GetCrouchState, &GCPlayer_MovementServices_Humanoid::SetCrouchState)
        .addProperty("CrouchTransitionStartTime", &GCPlayer_MovementServices_Humanoid::GetCrouchTransitionStartTime, &GCPlayer_MovementServices_Humanoid::SetCrouchTransitionStartTime)
        .addProperty("Ducked", &GCPlayer_MovementServices_Humanoid::GetDucked, &GCPlayer_MovementServices_Humanoid::SetDucked)
        .addProperty("Ducking", &GCPlayer_MovementServices_Humanoid::GetDucking, &GCPlayer_MovementServices_Humanoid::SetDucking)
        .addProperty("InDuckJump", &GCPlayer_MovementServices_Humanoid::GetInDuckJump, &GCPlayer_MovementServices_Humanoid::SetInDuckJump)
        .addProperty("GroundNormal", &GCPlayer_MovementServices_Humanoid::GetGroundNormal, &GCPlayer_MovementServices_Humanoid::SetGroundNormal)
        .addProperty("SurfaceFriction", &GCPlayer_MovementServices_Humanoid::GetSurfaceFriction, &GCPlayer_MovementServices_Humanoid::SetSurfaceFriction)
        .addProperty("SurfaceProps", &GCPlayer_MovementServices_Humanoid::GetSurfaceProps, &GCPlayer_MovementServices_Humanoid::SetSurfaceProps)
        .addProperty("Stepside", &GCPlayer_MovementServices_Humanoid::GetStepside, &GCPlayer_MovementServices_Humanoid::SetStepside)
        .addProperty("TargetVolume", &GCPlayer_MovementServices_Humanoid::GetTargetVolume, &GCPlayer_MovementServices_Humanoid::SetTargetVolume)
        .addProperty("SmoothedVelocity", &GCPlayer_MovementServices_Humanoid::GetSmoothedVelocity, &GCPlayer_MovementServices_Humanoid::SetSmoothedVelocity)
        .addProperty("Parent", &GCPlayer_MovementServices_Humanoid::GetParent, &GCPlayer_MovementServices_Humanoid::SetParent)
        .addFunction("ToPtr", &GCPlayer_MovementServices_Humanoid::ToPtr)
        .addFunction("IsValid", &GCPlayer_MovementServices_Humanoid::IsValid)
        .endClass();
}
GCTriggerSave::GCTriggerSave(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCTriggerSave::GCTriggerSave(void *ptr) {
    m_ptr = ptr;
}
bool GCTriggerSave::GetForceNewLevelUnit() const {
    return GetSchemaValue<bool>(m_ptr, "CTriggerSave", "m_bForceNewLevelUnit");
}
void GCTriggerSave::SetForceNewLevelUnit(bool value) {
    SetSchemaValue(m_ptr, "CTriggerSave", "m_bForceNewLevelUnit", false, value);
}
float GCTriggerSave::GetDangerousTimer() const {
    return GetSchemaValue<float>(m_ptr, "CTriggerSave", "m_fDangerousTimer");
}
void GCTriggerSave::SetDangerousTimer(float value) {
    SetSchemaValue(m_ptr, "CTriggerSave", "m_fDangerousTimer", false, value);
}
int32_t GCTriggerSave::GetMinHitPoints() const {
    return GetSchemaValue<int32_t>(m_ptr, "CTriggerSave", "m_minHitPoints");
}
void GCTriggerSave::SetMinHitPoints(int32_t value) {
    SetSchemaValue(m_ptr, "CTriggerSave", "m_minHitPoints", false, value);
}
std::string GCTriggerSave::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCTriggerSave::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseTrigger GCTriggerSave::GetParent() const {
    GCBaseTrigger value(m_ptr);
    return value;
}
void GCTriggerSave::SetParent(GCBaseTrigger value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCTriggerSave(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCTriggerSave>("CTriggerSave")
        .addConstructor<void (*)(std::string)>()
        .addProperty("ForceNewLevelUnit", &GCTriggerSave::GetForceNewLevelUnit, &GCTriggerSave::SetForceNewLevelUnit)
        .addProperty("DangerousTimer", &GCTriggerSave::GetDangerousTimer, &GCTriggerSave::SetDangerousTimer)
        .addProperty("MinHitPoints", &GCTriggerSave::GetMinHitPoints, &GCTriggerSave::SetMinHitPoints)
        .addProperty("Parent", &GCTriggerSave::GetParent, &GCTriggerSave::SetParent)
        .addFunction("ToPtr", &GCTriggerSave::ToPtr)
        .addFunction("IsValid", &GCTriggerSave::IsValid)
        .endClass();
}
GCPhysWheelConstraint::GCPhysWheelConstraint(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCPhysWheelConstraint::GCPhysWheelConstraint(void *ptr) {
    m_ptr = ptr;
}
float GCPhysWheelConstraint::GetSuspensionFrequency() const {
    return GetSchemaValue<float>(m_ptr, "CPhysWheelConstraint", "m_flSuspensionFrequency");
}
void GCPhysWheelConstraint::SetSuspensionFrequency(float value) {
    SetSchemaValue(m_ptr, "CPhysWheelConstraint", "m_flSuspensionFrequency", false, value);
}
float GCPhysWheelConstraint::GetSuspensionDampingRatio() const {
    return GetSchemaValue<float>(m_ptr, "CPhysWheelConstraint", "m_flSuspensionDampingRatio");
}
void GCPhysWheelConstraint::SetSuspensionDampingRatio(float value) {
    SetSchemaValue(m_ptr, "CPhysWheelConstraint", "m_flSuspensionDampingRatio", false, value);
}
float GCPhysWheelConstraint::GetSuspensionHeightOffset() const {
    return GetSchemaValue<float>(m_ptr, "CPhysWheelConstraint", "m_flSuspensionHeightOffset");
}
void GCPhysWheelConstraint::SetSuspensionHeightOffset(float value) {
    SetSchemaValue(m_ptr, "CPhysWheelConstraint", "m_flSuspensionHeightOffset", false, value);
}
bool GCPhysWheelConstraint::GetEnableSuspensionLimit() const {
    return GetSchemaValue<bool>(m_ptr, "CPhysWheelConstraint", "m_bEnableSuspensionLimit");
}
void GCPhysWheelConstraint::SetEnableSuspensionLimit(bool value) {
    SetSchemaValue(m_ptr, "CPhysWheelConstraint", "m_bEnableSuspensionLimit", false, value);
}
float GCPhysWheelConstraint::GetMinSuspensionOffset() const {
    return GetSchemaValue<float>(m_ptr, "CPhysWheelConstraint", "m_flMinSuspensionOffset");
}
void GCPhysWheelConstraint::SetMinSuspensionOffset(float value) {
    SetSchemaValue(m_ptr, "CPhysWheelConstraint", "m_flMinSuspensionOffset", false, value);
}
float GCPhysWheelConstraint::GetMaxSuspensionOffset() const {
    return GetSchemaValue<float>(m_ptr, "CPhysWheelConstraint", "m_flMaxSuspensionOffset");
}
void GCPhysWheelConstraint::SetMaxSuspensionOffset(float value) {
    SetSchemaValue(m_ptr, "CPhysWheelConstraint", "m_flMaxSuspensionOffset", false, value);
}
bool GCPhysWheelConstraint::GetEnableSteeringLimit() const {
    return GetSchemaValue<bool>(m_ptr, "CPhysWheelConstraint", "m_bEnableSteeringLimit");
}
void GCPhysWheelConstraint::SetEnableSteeringLimit(bool value) {
    SetSchemaValue(m_ptr, "CPhysWheelConstraint", "m_bEnableSteeringLimit", false, value);
}
float GCPhysWheelConstraint::GetMinSteeringAngle() const {
    return GetSchemaValue<float>(m_ptr, "CPhysWheelConstraint", "m_flMinSteeringAngle");
}
void GCPhysWheelConstraint::SetMinSteeringAngle(float value) {
    SetSchemaValue(m_ptr, "CPhysWheelConstraint", "m_flMinSteeringAngle", false, value);
}
float GCPhysWheelConstraint::GetMaxSteeringAngle() const {
    return GetSchemaValue<float>(m_ptr, "CPhysWheelConstraint", "m_flMaxSteeringAngle");
}
void GCPhysWheelConstraint::SetMaxSteeringAngle(float value) {
    SetSchemaValue(m_ptr, "CPhysWheelConstraint", "m_flMaxSteeringAngle", false, value);
}
float GCPhysWheelConstraint::GetSteeringAxisFriction() const {
    return GetSchemaValue<float>(m_ptr, "CPhysWheelConstraint", "m_flSteeringAxisFriction");
}
void GCPhysWheelConstraint::SetSteeringAxisFriction(float value) {
    SetSchemaValue(m_ptr, "CPhysWheelConstraint", "m_flSteeringAxisFriction", false, value);
}
float GCPhysWheelConstraint::GetSpinAxisFriction() const {
    return GetSchemaValue<float>(m_ptr, "CPhysWheelConstraint", "m_flSpinAxisFriction");
}
void GCPhysWheelConstraint::SetSpinAxisFriction(float value) {
    SetSchemaValue(m_ptr, "CPhysWheelConstraint", "m_flSpinAxisFriction", false, value);
}
std::string GCPhysWheelConstraint::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCPhysWheelConstraint::IsValid() {
    return (m_ptr != nullptr);
}
GCPhysConstraint GCPhysWheelConstraint::GetParent() const {
    GCPhysConstraint value(m_ptr);
    return value;
}
void GCPhysWheelConstraint::SetParent(GCPhysConstraint value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCPhysWheelConstraint(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCPhysWheelConstraint>("CPhysWheelConstraint")
        .addConstructor<void (*)(std::string)>()
        .addProperty("SuspensionFrequency", &GCPhysWheelConstraint::GetSuspensionFrequency, &GCPhysWheelConstraint::SetSuspensionFrequency)
        .addProperty("SuspensionDampingRatio", &GCPhysWheelConstraint::GetSuspensionDampingRatio, &GCPhysWheelConstraint::SetSuspensionDampingRatio)
        .addProperty("SuspensionHeightOffset", &GCPhysWheelConstraint::GetSuspensionHeightOffset, &GCPhysWheelConstraint::SetSuspensionHeightOffset)
        .addProperty("EnableSuspensionLimit", &GCPhysWheelConstraint::GetEnableSuspensionLimit, &GCPhysWheelConstraint::SetEnableSuspensionLimit)
        .addProperty("MinSuspensionOffset", &GCPhysWheelConstraint::GetMinSuspensionOffset, &GCPhysWheelConstraint::SetMinSuspensionOffset)
        .addProperty("MaxSuspensionOffset", &GCPhysWheelConstraint::GetMaxSuspensionOffset, &GCPhysWheelConstraint::SetMaxSuspensionOffset)
        .addProperty("EnableSteeringLimit", &GCPhysWheelConstraint::GetEnableSteeringLimit, &GCPhysWheelConstraint::SetEnableSteeringLimit)
        .addProperty("MinSteeringAngle", &GCPhysWheelConstraint::GetMinSteeringAngle, &GCPhysWheelConstraint::SetMinSteeringAngle)
        .addProperty("MaxSteeringAngle", &GCPhysWheelConstraint::GetMaxSteeringAngle, &GCPhysWheelConstraint::SetMaxSteeringAngle)
        .addProperty("SteeringAxisFriction", &GCPhysWheelConstraint::GetSteeringAxisFriction, &GCPhysWheelConstraint::SetSteeringAxisFriction)
        .addProperty("SpinAxisFriction", &GCPhysWheelConstraint::GetSpinAxisFriction, &GCPhysWheelConstraint::SetSpinAxisFriction)
        .addProperty("Parent", &GCPhysWheelConstraint::GetParent, &GCPhysWheelConstraint::SetParent)
        .addFunction("ToPtr", &GCPhysWheelConstraint::ToPtr)
        .addFunction("IsValid", &GCPhysWheelConstraint::IsValid)
        .endClass();
}
GCPhysFixed::GCPhysFixed(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCPhysFixed::GCPhysFixed(void *ptr) {
    m_ptr = ptr;
}
float GCPhysFixed::GetLinearFrequency() const {
    return GetSchemaValue<float>(m_ptr, "CPhysFixed", "m_flLinearFrequency");
}
void GCPhysFixed::SetLinearFrequency(float value) {
    SetSchemaValue(m_ptr, "CPhysFixed", "m_flLinearFrequency", false, value);
}
float GCPhysFixed::GetLinearDampingRatio() const {
    return GetSchemaValue<float>(m_ptr, "CPhysFixed", "m_flLinearDampingRatio");
}
void GCPhysFixed::SetLinearDampingRatio(float value) {
    SetSchemaValue(m_ptr, "CPhysFixed", "m_flLinearDampingRatio", false, value);
}
float GCPhysFixed::GetAngularFrequency() const {
    return GetSchemaValue<float>(m_ptr, "CPhysFixed", "m_flAngularFrequency");
}
void GCPhysFixed::SetAngularFrequency(float value) {
    SetSchemaValue(m_ptr, "CPhysFixed", "m_flAngularFrequency", false, value);
}
float GCPhysFixed::GetAngularDampingRatio() const {
    return GetSchemaValue<float>(m_ptr, "CPhysFixed", "m_flAngularDampingRatio");
}
void GCPhysFixed::SetAngularDampingRatio(float value) {
    SetSchemaValue(m_ptr, "CPhysFixed", "m_flAngularDampingRatio", false, value);
}
bool GCPhysFixed::GetEnableLinearConstraint() const {
    return GetSchemaValue<bool>(m_ptr, "CPhysFixed", "m_bEnableLinearConstraint");
}
void GCPhysFixed::SetEnableLinearConstraint(bool value) {
    SetSchemaValue(m_ptr, "CPhysFixed", "m_bEnableLinearConstraint", false, value);
}
bool GCPhysFixed::GetEnableAngularConstraint() const {
    return GetSchemaValue<bool>(m_ptr, "CPhysFixed", "m_bEnableAngularConstraint");
}
void GCPhysFixed::SetEnableAngularConstraint(bool value) {
    SetSchemaValue(m_ptr, "CPhysFixed", "m_bEnableAngularConstraint", false, value);
}
std::string GCPhysFixed::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCPhysFixed::IsValid() {
    return (m_ptr != nullptr);
}
GCPhysConstraint GCPhysFixed::GetParent() const {
    GCPhysConstraint value(m_ptr);
    return value;
}
void GCPhysFixed::SetParent(GCPhysConstraint value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCPhysFixed(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCPhysFixed>("CPhysFixed")
        .addConstructor<void (*)(std::string)>()
        .addProperty("LinearFrequency", &GCPhysFixed::GetLinearFrequency, &GCPhysFixed::SetLinearFrequency)
        .addProperty("LinearDampingRatio", &GCPhysFixed::GetLinearDampingRatio, &GCPhysFixed::SetLinearDampingRatio)
        .addProperty("AngularFrequency", &GCPhysFixed::GetAngularFrequency, &GCPhysFixed::SetAngularFrequency)
        .addProperty("AngularDampingRatio", &GCPhysFixed::GetAngularDampingRatio, &GCPhysFixed::SetAngularDampingRatio)
        .addProperty("EnableLinearConstraint", &GCPhysFixed::GetEnableLinearConstraint, &GCPhysFixed::SetEnableLinearConstraint)
        .addProperty("EnableAngularConstraint", &GCPhysFixed::GetEnableAngularConstraint, &GCPhysFixed::SetEnableAngularConstraint)
        .addProperty("Parent", &GCPhysFixed::GetParent, &GCPhysFixed::SetParent)
        .addFunction("ToPtr", &GCPhysFixed::ToPtr)
        .addFunction("IsValid", &GCPhysFixed::IsValid)
        .endClass();
}
GCSkillFloat::GCSkillFloat(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCSkillFloat::GCSkillFloat(void *ptr) {
    m_ptr = ptr;
}
std::vector<float> GCSkillFloat::GetValue() const {
    float* outValue = GetSchemaValue<float*>(m_ptr, "CSkillFloat", "m_pValue"); std::vector<float> ret; for(int i = 0; i < 4; i++) { ret.push_back(outValue[i]); } return ret;
}
void GCSkillFloat::SetValue(std::vector<float> value) {
    float* outValue = GetSchemaValue<float*>(m_ptr, "CSkillFloat", "m_pValue"); for(int i = 0; i < 4; i++) { outValue[i] = value[i]; } SetSchemaValue(m_ptr, "CSkillFloat", "m_pValue", false, outValue);
}
std::string GCSkillFloat::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCSkillFloat::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCSkillFloat(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCSkillFloat>("CSkillFloat")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Value", &GCSkillFloat::GetValue, &GCSkillFloat::SetValue)
        .addFunction("ToPtr", &GCSkillFloat::ToPtr)
        .addFunction("IsValid", &GCSkillFloat::IsValid)
        .endClass();
}
GCEnvSoundscapeTriggerableAlias_snd_soundscape_triggerable::GCEnvSoundscapeTriggerableAlias_snd_soundscape_triggerable(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCEnvSoundscapeTriggerableAlias_snd_soundscape_triggerable::GCEnvSoundscapeTriggerableAlias_snd_soundscape_triggerable(void *ptr) {
    m_ptr = ptr;
}
std::string GCEnvSoundscapeTriggerableAlias_snd_soundscape_triggerable::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCEnvSoundscapeTriggerableAlias_snd_soundscape_triggerable::IsValid() {
    return (m_ptr != nullptr);
}
GCEnvSoundscapeTriggerable GCEnvSoundscapeTriggerableAlias_snd_soundscape_triggerable::GetParent() const {
    GCEnvSoundscapeTriggerable value(m_ptr);
    return value;
}
void GCEnvSoundscapeTriggerableAlias_snd_soundscape_triggerable::SetParent(GCEnvSoundscapeTriggerable value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCEnvSoundscapeTriggerableAlias_snd_soundscape_triggerable(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCEnvSoundscapeTriggerableAlias_snd_soundscape_triggerable>("CEnvSoundscapeTriggerableAlias_snd_soundscape_triggerable")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCEnvSoundscapeTriggerableAlias_snd_soundscape_triggerable::GetParent, &GCEnvSoundscapeTriggerableAlias_snd_soundscape_triggerable::SetParent)
        .addFunction("ToPtr", &GCEnvSoundscapeTriggerableAlias_snd_soundscape_triggerable::ToPtr)
        .addFunction("IsValid", &GCEnvSoundscapeTriggerableAlias_snd_soundscape_triggerable::IsValid)
        .endClass();
}
GCCSPlayerController_InGameMoneyServices::GCCSPlayerController_InGameMoneyServices(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCCSPlayerController_InGameMoneyServices::GCCSPlayerController_InGameMoneyServices(void *ptr) {
    m_ptr = ptr;
}
bool GCCSPlayerController_InGameMoneyServices::GetReceivesMoneyNextRound() const {
    return GetSchemaValue<bool>(m_ptr, "CCSPlayerController_InGameMoneyServices", "m_bReceivesMoneyNextRound");
}
void GCCSPlayerController_InGameMoneyServices::SetReceivesMoneyNextRound(bool value) {
    SetSchemaValue(m_ptr, "CCSPlayerController_InGameMoneyServices", "m_bReceivesMoneyNextRound", false, value);
}
int32_t GCCSPlayerController_InGameMoneyServices::GetMoneyEarnedForNextRound() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSPlayerController_InGameMoneyServices", "m_iMoneyEarnedForNextRound");
}
void GCCSPlayerController_InGameMoneyServices::SetMoneyEarnedForNextRound(int32_t value) {
    SetSchemaValue(m_ptr, "CCSPlayerController_InGameMoneyServices", "m_iMoneyEarnedForNextRound", false, value);
}
int32_t GCCSPlayerController_InGameMoneyServices::GetAccount() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSPlayerController_InGameMoneyServices", "m_iAccount");
}
void GCCSPlayerController_InGameMoneyServices::SetAccount(int32_t value) {
    SetSchemaValue(m_ptr, "CCSPlayerController_InGameMoneyServices", "m_iAccount", false, value);
}
int32_t GCCSPlayerController_InGameMoneyServices::GetStartAccount() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSPlayerController_InGameMoneyServices", "m_iStartAccount");
}
void GCCSPlayerController_InGameMoneyServices::SetStartAccount(int32_t value) {
    SetSchemaValue(m_ptr, "CCSPlayerController_InGameMoneyServices", "m_iStartAccount", false, value);
}
int32_t GCCSPlayerController_InGameMoneyServices::GetTotalCashSpent() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSPlayerController_InGameMoneyServices", "m_iTotalCashSpent");
}
void GCCSPlayerController_InGameMoneyServices::SetTotalCashSpent(int32_t value) {
    SetSchemaValue(m_ptr, "CCSPlayerController_InGameMoneyServices", "m_iTotalCashSpent", false, value);
}
int32_t GCCSPlayerController_InGameMoneyServices::GetCashSpentThisRound() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSPlayerController_InGameMoneyServices", "m_iCashSpentThisRound");
}
void GCCSPlayerController_InGameMoneyServices::SetCashSpentThisRound(int32_t value) {
    SetSchemaValue(m_ptr, "CCSPlayerController_InGameMoneyServices", "m_iCashSpentThisRound", false, value);
}
std::string GCCSPlayerController_InGameMoneyServices::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCCSPlayerController_InGameMoneyServices::IsValid() {
    return (m_ptr != nullptr);
}
GCPlayerControllerComponent GCCSPlayerController_InGameMoneyServices::GetParent() const {
    GCPlayerControllerComponent value(m_ptr);
    return value;
}
void GCCSPlayerController_InGameMoneyServices::SetParent(GCPlayerControllerComponent value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCCSPlayerController_InGameMoneyServices(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCCSPlayerController_InGameMoneyServices>("CCSPlayerController_InGameMoneyServices")
        .addConstructor<void (*)(std::string)>()
        .addProperty("ReceivesMoneyNextRound", &GCCSPlayerController_InGameMoneyServices::GetReceivesMoneyNextRound, &GCCSPlayerController_InGameMoneyServices::SetReceivesMoneyNextRound)
        .addProperty("MoneyEarnedForNextRound", &GCCSPlayerController_InGameMoneyServices::GetMoneyEarnedForNextRound, &GCCSPlayerController_InGameMoneyServices::SetMoneyEarnedForNextRound)
        .addProperty("Account", &GCCSPlayerController_InGameMoneyServices::GetAccount, &GCCSPlayerController_InGameMoneyServices::SetAccount)
        .addProperty("StartAccount", &GCCSPlayerController_InGameMoneyServices::GetStartAccount, &GCCSPlayerController_InGameMoneyServices::SetStartAccount)
        .addProperty("TotalCashSpent", &GCCSPlayerController_InGameMoneyServices::GetTotalCashSpent, &GCCSPlayerController_InGameMoneyServices::SetTotalCashSpent)
        .addProperty("CashSpentThisRound", &GCCSPlayerController_InGameMoneyServices::GetCashSpentThisRound, &GCCSPlayerController_InGameMoneyServices::SetCashSpentThisRound)
        .addProperty("Parent", &GCCSPlayerController_InGameMoneyServices::GetParent, &GCCSPlayerController_InGameMoneyServices::SetParent)
        .addFunction("ToPtr", &GCCSPlayerController_InGameMoneyServices::ToPtr)
        .addFunction("IsValid", &GCCSPlayerController_InGameMoneyServices::IsValid)
        .endClass();
}
GCSprite::GCSprite(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCSprite::GCSprite(void *ptr) {
    m_ptr = ptr;
}
GCBaseEntity GCSprite::GetAttachedToEntity() const {
    GCBaseEntity value(*GetSchemaValuePtr<void*>(m_ptr, "CSprite", "m_hAttachedToEntity"));
    return value;
}
void GCSprite::SetAttachedToEntity(GCBaseEntity* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'AttachedToEntity' is not possible.\n");
}
float GCSprite::GetSpriteFramerate() const {
    return GetSchemaValue<float>(m_ptr, "CSprite", "m_flSpriteFramerate");
}
void GCSprite::SetSpriteFramerate(float value) {
    SetSchemaValue(m_ptr, "CSprite", "m_flSpriteFramerate", false, value);
}
float GCSprite::GetFrame() const {
    return GetSchemaValue<float>(m_ptr, "CSprite", "m_flFrame");
}
void GCSprite::SetFrame(float value) {
    SetSchemaValue(m_ptr, "CSprite", "m_flFrame", false, value);
}
float GCSprite::GetDieTime() const {
    return GetSchemaValue<float>(m_ptr, "CSprite", "m_flDieTime");
}
void GCSprite::SetDieTime(float value) {
    SetSchemaValue(m_ptr, "CSprite", "m_flDieTime", false, value);
}
uint32_t GCSprite::GetBrightness() const {
    return GetSchemaValue<uint32_t>(m_ptr, "CSprite", "m_nBrightness");
}
void GCSprite::SetBrightness(uint32_t value) {
    SetSchemaValue(m_ptr, "CSprite", "m_nBrightness", false, value);
}
float GCSprite::GetBrightnessDuration() const {
    return GetSchemaValue<float>(m_ptr, "CSprite", "m_flBrightnessDuration");
}
void GCSprite::SetBrightnessDuration(float value) {
    SetSchemaValue(m_ptr, "CSprite", "m_flBrightnessDuration", false, value);
}
float GCSprite::GetSpriteScale() const {
    return GetSchemaValue<float>(m_ptr, "CSprite", "m_flSpriteScale");
}
void GCSprite::SetSpriteScale(float value) {
    SetSchemaValue(m_ptr, "CSprite", "m_flSpriteScale", false, value);
}
float GCSprite::GetScaleDuration() const {
    return GetSchemaValue<float>(m_ptr, "CSprite", "m_flScaleDuration");
}
void GCSprite::SetScaleDuration(float value) {
    SetSchemaValue(m_ptr, "CSprite", "m_flScaleDuration", false, value);
}
bool GCSprite::GetWorldSpaceScale() const {
    return GetSchemaValue<bool>(m_ptr, "CSprite", "m_bWorldSpaceScale");
}
void GCSprite::SetWorldSpaceScale(bool value) {
    SetSchemaValue(m_ptr, "CSprite", "m_bWorldSpaceScale", false, value);
}
float GCSprite::GetGlowProxySize() const {
    return GetSchemaValue<float>(m_ptr, "CSprite", "m_flGlowProxySize");
}
void GCSprite::SetGlowProxySize(float value) {
    SetSchemaValue(m_ptr, "CSprite", "m_flGlowProxySize", false, value);
}
float GCSprite::GetHDRColorScale() const {
    return GetSchemaValue<float>(m_ptr, "CSprite", "m_flHDRColorScale");
}
void GCSprite::SetHDRColorScale(float value) {
    SetSchemaValue(m_ptr, "CSprite", "m_flHDRColorScale", false, value);
}
float GCSprite::GetLastTime() const {
    return GetSchemaValue<float>(m_ptr, "CSprite", "m_flLastTime");
}
void GCSprite::SetLastTime(float value) {
    SetSchemaValue(m_ptr, "CSprite", "m_flLastTime", false, value);
}
float GCSprite::GetMaxFrame() const {
    return GetSchemaValue<float>(m_ptr, "CSprite", "m_flMaxFrame");
}
void GCSprite::SetMaxFrame(float value) {
    SetSchemaValue(m_ptr, "CSprite", "m_flMaxFrame", false, value);
}
float GCSprite::GetStartScale() const {
    return GetSchemaValue<float>(m_ptr, "CSprite", "m_flStartScale");
}
void GCSprite::SetStartScale(float value) {
    SetSchemaValue(m_ptr, "CSprite", "m_flStartScale", false, value);
}
float GCSprite::GetDestScale() const {
    return GetSchemaValue<float>(m_ptr, "CSprite", "m_flDestScale");
}
void GCSprite::SetDestScale(float value) {
    SetSchemaValue(m_ptr, "CSprite", "m_flDestScale", false, value);
}
float GCSprite::GetScaleTimeStart() const {
    return GetSchemaValue<float>(m_ptr, "CSprite", "m_flScaleTimeStart");
}
void GCSprite::SetScaleTimeStart(float value) {
    SetSchemaValue(m_ptr, "CSprite", "m_flScaleTimeStart", false, value);
}
int32_t GCSprite::GetStartBrightness() const {
    return GetSchemaValue<int32_t>(m_ptr, "CSprite", "m_nStartBrightness");
}
void GCSprite::SetStartBrightness(int32_t value) {
    SetSchemaValue(m_ptr, "CSprite", "m_nStartBrightness", false, value);
}
int32_t GCSprite::GetDestBrightness() const {
    return GetSchemaValue<int32_t>(m_ptr, "CSprite", "m_nDestBrightness");
}
void GCSprite::SetDestBrightness(int32_t value) {
    SetSchemaValue(m_ptr, "CSprite", "m_nDestBrightness", false, value);
}
float GCSprite::GetBrightnessTimeStart() const {
    return GetSchemaValue<float>(m_ptr, "CSprite", "m_flBrightnessTimeStart");
}
void GCSprite::SetBrightnessTimeStart(float value) {
    SetSchemaValue(m_ptr, "CSprite", "m_flBrightnessTimeStart", false, value);
}
int32_t GCSprite::GetSpriteWidth() const {
    return GetSchemaValue<int32_t>(m_ptr, "CSprite", "m_nSpriteWidth");
}
void GCSprite::SetSpriteWidth(int32_t value) {
    SetSchemaValue(m_ptr, "CSprite", "m_nSpriteWidth", false, value);
}
int32_t GCSprite::GetSpriteHeight() const {
    return GetSchemaValue<int32_t>(m_ptr, "CSprite", "m_nSpriteHeight");
}
void GCSprite::SetSpriteHeight(int32_t value) {
    SetSchemaValue(m_ptr, "CSprite", "m_nSpriteHeight", false, value);
}
std::string GCSprite::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCSprite::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseModelEntity GCSprite::GetParent() const {
    GCBaseModelEntity value(m_ptr);
    return value;
}
void GCSprite::SetParent(GCBaseModelEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCSprite(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCSprite>("CSprite")
        .addConstructor<void (*)(std::string)>()
        .addProperty("AttachedToEntity", &GCSprite::GetAttachedToEntity, &GCSprite::SetAttachedToEntity)
        .addProperty("SpriteFramerate", &GCSprite::GetSpriteFramerate, &GCSprite::SetSpriteFramerate)
        .addProperty("Frame", &GCSprite::GetFrame, &GCSprite::SetFrame)
        .addProperty("DieTime", &GCSprite::GetDieTime, &GCSprite::SetDieTime)
        .addProperty("Brightness", &GCSprite::GetBrightness, &GCSprite::SetBrightness)
        .addProperty("BrightnessDuration", &GCSprite::GetBrightnessDuration, &GCSprite::SetBrightnessDuration)
        .addProperty("SpriteScale", &GCSprite::GetSpriteScale, &GCSprite::SetSpriteScale)
        .addProperty("ScaleDuration", &GCSprite::GetScaleDuration, &GCSprite::SetScaleDuration)
        .addProperty("WorldSpaceScale", &GCSprite::GetWorldSpaceScale, &GCSprite::SetWorldSpaceScale)
        .addProperty("GlowProxySize", &GCSprite::GetGlowProxySize, &GCSprite::SetGlowProxySize)
        .addProperty("HDRColorScale", &GCSprite::GetHDRColorScale, &GCSprite::SetHDRColorScale)
        .addProperty("LastTime", &GCSprite::GetLastTime, &GCSprite::SetLastTime)
        .addProperty("MaxFrame", &GCSprite::GetMaxFrame, &GCSprite::SetMaxFrame)
        .addProperty("StartScale", &GCSprite::GetStartScale, &GCSprite::SetStartScale)
        .addProperty("DestScale", &GCSprite::GetDestScale, &GCSprite::SetDestScale)
        .addProperty("ScaleTimeStart", &GCSprite::GetScaleTimeStart, &GCSprite::SetScaleTimeStart)
        .addProperty("StartBrightness", &GCSprite::GetStartBrightness, &GCSprite::SetStartBrightness)
        .addProperty("DestBrightness", &GCSprite::GetDestBrightness, &GCSprite::SetDestBrightness)
        .addProperty("BrightnessTimeStart", &GCSprite::GetBrightnessTimeStart, &GCSprite::SetBrightnessTimeStart)
        .addProperty("SpriteWidth", &GCSprite::GetSpriteWidth, &GCSprite::SetSpriteWidth)
        .addProperty("SpriteHeight", &GCSprite::GetSpriteHeight, &GCSprite::SetSpriteHeight)
        .addProperty("Parent", &GCSprite::GetParent, &GCSprite::SetParent)
        .addFunction("ToPtr", &GCSprite::ToPtr)
        .addFunction("IsValid", &GCSprite::IsValid)
        .endClass();
}
GCSoundOpvarSetAABBEntity::GCSoundOpvarSetAABBEntity(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCSoundOpvarSetAABBEntity::GCSoundOpvarSetAABBEntity(void *ptr) {
    m_ptr = ptr;
}
Vector GCSoundOpvarSetAABBEntity::GetDistanceInnerMins() const {
    return GetSchemaValue<Vector>(m_ptr, "CSoundOpvarSetAABBEntity", "m_vDistanceInnerMins");
}
void GCSoundOpvarSetAABBEntity::SetDistanceInnerMins(Vector value) {
    SetSchemaValue(m_ptr, "CSoundOpvarSetAABBEntity", "m_vDistanceInnerMins", false, value);
}
Vector GCSoundOpvarSetAABBEntity::GetDistanceInnerMaxs() const {
    return GetSchemaValue<Vector>(m_ptr, "CSoundOpvarSetAABBEntity", "m_vDistanceInnerMaxs");
}
void GCSoundOpvarSetAABBEntity::SetDistanceInnerMaxs(Vector value) {
    SetSchemaValue(m_ptr, "CSoundOpvarSetAABBEntity", "m_vDistanceInnerMaxs", false, value);
}
Vector GCSoundOpvarSetAABBEntity::GetDistanceOuterMins() const {
    return GetSchemaValue<Vector>(m_ptr, "CSoundOpvarSetAABBEntity", "m_vDistanceOuterMins");
}
void GCSoundOpvarSetAABBEntity::SetDistanceOuterMins(Vector value) {
    SetSchemaValue(m_ptr, "CSoundOpvarSetAABBEntity", "m_vDistanceOuterMins", false, value);
}
Vector GCSoundOpvarSetAABBEntity::GetDistanceOuterMaxs() const {
    return GetSchemaValue<Vector>(m_ptr, "CSoundOpvarSetAABBEntity", "m_vDistanceOuterMaxs");
}
void GCSoundOpvarSetAABBEntity::SetDistanceOuterMaxs(Vector value) {
    SetSchemaValue(m_ptr, "CSoundOpvarSetAABBEntity", "m_vDistanceOuterMaxs", false, value);
}
int32_t GCSoundOpvarSetAABBEntity::GetAABBDirection() const {
    return GetSchemaValue<int32_t>(m_ptr, "CSoundOpvarSetAABBEntity", "m_nAABBDirection");
}
void GCSoundOpvarSetAABBEntity::SetAABBDirection(int32_t value) {
    SetSchemaValue(m_ptr, "CSoundOpvarSetAABBEntity", "m_nAABBDirection", false, value);
}
Vector GCSoundOpvarSetAABBEntity::GetInnerMins() const {
    return GetSchemaValue<Vector>(m_ptr, "CSoundOpvarSetAABBEntity", "m_vInnerMins");
}
void GCSoundOpvarSetAABBEntity::SetInnerMins(Vector value) {
    SetSchemaValue(m_ptr, "CSoundOpvarSetAABBEntity", "m_vInnerMins", false, value);
}
Vector GCSoundOpvarSetAABBEntity::GetInnerMaxs() const {
    return GetSchemaValue<Vector>(m_ptr, "CSoundOpvarSetAABBEntity", "m_vInnerMaxs");
}
void GCSoundOpvarSetAABBEntity::SetInnerMaxs(Vector value) {
    SetSchemaValue(m_ptr, "CSoundOpvarSetAABBEntity", "m_vInnerMaxs", false, value);
}
Vector GCSoundOpvarSetAABBEntity::GetOuterMins() const {
    return GetSchemaValue<Vector>(m_ptr, "CSoundOpvarSetAABBEntity", "m_vOuterMins");
}
void GCSoundOpvarSetAABBEntity::SetOuterMins(Vector value) {
    SetSchemaValue(m_ptr, "CSoundOpvarSetAABBEntity", "m_vOuterMins", false, value);
}
Vector GCSoundOpvarSetAABBEntity::GetOuterMaxs() const {
    return GetSchemaValue<Vector>(m_ptr, "CSoundOpvarSetAABBEntity", "m_vOuterMaxs");
}
void GCSoundOpvarSetAABBEntity::SetOuterMaxs(Vector value) {
    SetSchemaValue(m_ptr, "CSoundOpvarSetAABBEntity", "m_vOuterMaxs", false, value);
}
std::string GCSoundOpvarSetAABBEntity::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCSoundOpvarSetAABBEntity::IsValid() {
    return (m_ptr != nullptr);
}
GCSoundOpvarSetPointEntity GCSoundOpvarSetAABBEntity::GetParent() const {
    GCSoundOpvarSetPointEntity value(m_ptr);
    return value;
}
void GCSoundOpvarSetAABBEntity::SetParent(GCSoundOpvarSetPointEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCSoundOpvarSetAABBEntity(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCSoundOpvarSetAABBEntity>("CSoundOpvarSetAABBEntity")
        .addConstructor<void (*)(std::string)>()
        .addProperty("DistanceInnerMins", &GCSoundOpvarSetAABBEntity::GetDistanceInnerMins, &GCSoundOpvarSetAABBEntity::SetDistanceInnerMins)
        .addProperty("DistanceInnerMaxs", &GCSoundOpvarSetAABBEntity::GetDistanceInnerMaxs, &GCSoundOpvarSetAABBEntity::SetDistanceInnerMaxs)
        .addProperty("DistanceOuterMins", &GCSoundOpvarSetAABBEntity::GetDistanceOuterMins, &GCSoundOpvarSetAABBEntity::SetDistanceOuterMins)
        .addProperty("DistanceOuterMaxs", &GCSoundOpvarSetAABBEntity::GetDistanceOuterMaxs, &GCSoundOpvarSetAABBEntity::SetDistanceOuterMaxs)
        .addProperty("AABBDirection", &GCSoundOpvarSetAABBEntity::GetAABBDirection, &GCSoundOpvarSetAABBEntity::SetAABBDirection)
        .addProperty("InnerMins", &GCSoundOpvarSetAABBEntity::GetInnerMins, &GCSoundOpvarSetAABBEntity::SetInnerMins)
        .addProperty("InnerMaxs", &GCSoundOpvarSetAABBEntity::GetInnerMaxs, &GCSoundOpvarSetAABBEntity::SetInnerMaxs)
        .addProperty("OuterMins", &GCSoundOpvarSetAABBEntity::GetOuterMins, &GCSoundOpvarSetAABBEntity::SetOuterMins)
        .addProperty("OuterMaxs", &GCSoundOpvarSetAABBEntity::GetOuterMaxs, &GCSoundOpvarSetAABBEntity::SetOuterMaxs)
        .addProperty("Parent", &GCSoundOpvarSetAABBEntity::GetParent, &GCSoundOpvarSetAABBEntity::SetParent)
        .addFunction("ToPtr", &GCSoundOpvarSetAABBEntity::ToPtr)
        .addFunction("IsValid", &GCSoundOpvarSetAABBEntity::IsValid)
        .endClass();
}
GCWeaponM4A1::GCWeaponM4A1(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCWeaponM4A1::GCWeaponM4A1(void *ptr) {
    m_ptr = ptr;
}
std::string GCWeaponM4A1::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCWeaponM4A1::IsValid() {
    return (m_ptr != nullptr);
}
GCCSWeaponBaseGun GCWeaponM4A1::GetParent() const {
    GCCSWeaponBaseGun value(m_ptr);
    return value;
}
void GCWeaponM4A1::SetParent(GCCSWeaponBaseGun value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCWeaponM4A1(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCWeaponM4A1>("CWeaponM4A1")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCWeaponM4A1::GetParent, &GCWeaponM4A1::SetParent)
        .addFunction("ToPtr", &GCWeaponM4A1::ToPtr)
        .addFunction("IsValid", &GCWeaponM4A1::IsValid)
        .endClass();
}
GCBeam::GCBeam(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCBeam::GCBeam(void *ptr) {
    m_ptr = ptr;
}
float GCBeam::GetFrameRate() const {
    return GetSchemaValue<float>(m_ptr, "CBeam", "m_flFrameRate");
}
void GCBeam::SetFrameRate(float value) {
    SetSchemaValue(m_ptr, "CBeam", "m_flFrameRate", false, value);
}
float GCBeam::GetHDRColorScale() const {
    return GetSchemaValue<float>(m_ptr, "CBeam", "m_flHDRColorScale");
}
void GCBeam::SetHDRColorScale(float value) {
    SetSchemaValue(m_ptr, "CBeam", "m_flHDRColorScale", false, value);
}
float GCBeam::GetFireTime() const {
    return GetSchemaValue<float>(m_ptr, "CBeam", "m_flFireTime");
}
void GCBeam::SetFireTime(float value) {
    SetSchemaValue(m_ptr, "CBeam", "m_flFireTime", false, value);
}
float GCBeam::GetDamage() const {
    return GetSchemaValue<float>(m_ptr, "CBeam", "m_flDamage");
}
void GCBeam::SetDamage(float value) {
    SetSchemaValue(m_ptr, "CBeam", "m_flDamage", false, value);
}
uint8_t GCBeam::GetNumBeamEnts() const {
    return GetSchemaValue<uint8_t>(m_ptr, "CBeam", "m_nNumBeamEnts");
}
void GCBeam::SetNumBeamEnts(uint8_t value) {
    SetSchemaValue(m_ptr, "CBeam", "m_nNumBeamEnts", false, value);
}
uint64_t GCBeam::GetBeamType() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CBeam", "m_nBeamType");
}
void GCBeam::SetBeamType(uint64_t value) {
    SetSchemaValue(m_ptr, "CBeam", "m_nBeamType", false, value);
}
uint32_t GCBeam::GetBeamFlags() const {
    return GetSchemaValue<uint32_t>(m_ptr, "CBeam", "m_nBeamFlags");
}
void GCBeam::SetBeamFlags(uint32_t value) {
    SetSchemaValue(m_ptr, "CBeam", "m_nBeamFlags", false, value);
}
std::vector<GCBaseEntity*> GCBeam::GetAttachEntity() const {
    GCBaseEntity** outValue = GetSchemaValue<GCBaseEntity**>(m_ptr, "CBeam", "m_hAttachEntity"); std::vector<GCBaseEntity*> ret; for(int i = 0; i < 10; i++) { ret.push_back(outValue[i]); } return ret;
}
void GCBeam::SetAttachEntity(std::vector<GCBaseEntity*> value) {
    GCBaseEntity** outValue = GetSchemaValue<GCBaseEntity**>(m_ptr, "CBeam", "m_hAttachEntity"); for(int i = 0; i < 10; i++) { outValue[i] = value[i]; } SetSchemaValue(m_ptr, "CBeam", "m_hAttachEntity", false, outValue);
}
float GCBeam::GetWidth() const {
    return GetSchemaValue<float>(m_ptr, "CBeam", "m_fWidth");
}
void GCBeam::SetWidth(float value) {
    SetSchemaValue(m_ptr, "CBeam", "m_fWidth", false, value);
}
float GCBeam::GetEndWidth() const {
    return GetSchemaValue<float>(m_ptr, "CBeam", "m_fEndWidth");
}
void GCBeam::SetEndWidth(float value) {
    SetSchemaValue(m_ptr, "CBeam", "m_fEndWidth", false, value);
}
float GCBeam::GetFadeLength() const {
    return GetSchemaValue<float>(m_ptr, "CBeam", "m_fFadeLength");
}
void GCBeam::SetFadeLength(float value) {
    SetSchemaValue(m_ptr, "CBeam", "m_fFadeLength", false, value);
}
float GCBeam::GetHaloScale() const {
    return GetSchemaValue<float>(m_ptr, "CBeam", "m_fHaloScale");
}
void GCBeam::SetHaloScale(float value) {
    SetSchemaValue(m_ptr, "CBeam", "m_fHaloScale", false, value);
}
float GCBeam::GetAmplitude() const {
    return GetSchemaValue<float>(m_ptr, "CBeam", "m_fAmplitude");
}
void GCBeam::SetAmplitude(float value) {
    SetSchemaValue(m_ptr, "CBeam", "m_fAmplitude", false, value);
}
float GCBeam::GetStartFrame() const {
    return GetSchemaValue<float>(m_ptr, "CBeam", "m_fStartFrame");
}
void GCBeam::SetStartFrame(float value) {
    SetSchemaValue(m_ptr, "CBeam", "m_fStartFrame", false, value);
}
float GCBeam::GetSpeed() const {
    return GetSchemaValue<float>(m_ptr, "CBeam", "m_fSpeed");
}
void GCBeam::SetSpeed(float value) {
    SetSchemaValue(m_ptr, "CBeam", "m_fSpeed", false, value);
}
float GCBeam::GetFrame() const {
    return GetSchemaValue<float>(m_ptr, "CBeam", "m_flFrame");
}
void GCBeam::SetFrame(float value) {
    SetSchemaValue(m_ptr, "CBeam", "m_flFrame", false, value);
}
uint64_t GCBeam::GetClipStyle() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CBeam", "m_nClipStyle");
}
void GCBeam::SetClipStyle(uint64_t value) {
    SetSchemaValue(m_ptr, "CBeam", "m_nClipStyle", false, value);
}
bool GCBeam::GetTurnedOff() const {
    return GetSchemaValue<bool>(m_ptr, "CBeam", "m_bTurnedOff");
}
void GCBeam::SetTurnedOff(bool value) {
    SetSchemaValue(m_ptr, "CBeam", "m_bTurnedOff", false, value);
}
Vector GCBeam::GetEndPos() const {
    return GetSchemaValue<Vector>(m_ptr, "CBeam", "m_vecEndPos");
}
void GCBeam::SetEndPos(Vector value) {
    SetSchemaValue(m_ptr, "CBeam", "m_vecEndPos", false, value);
}
GCBaseEntity GCBeam::GetEndEntity() const {
    GCBaseEntity value(*GetSchemaValuePtr<void*>(m_ptr, "CBeam", "m_hEndEntity"));
    return value;
}
void GCBeam::SetEndEntity(GCBaseEntity* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'EndEntity' is not possible.\n");
}
int32_t GCBeam::GetDissolveType() const {
    return GetSchemaValue<int32_t>(m_ptr, "CBeam", "m_nDissolveType");
}
void GCBeam::SetDissolveType(int32_t value) {
    SetSchemaValue(m_ptr, "CBeam", "m_nDissolveType", false, value);
}
std::string GCBeam::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCBeam::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseModelEntity GCBeam::GetParent() const {
    GCBaseModelEntity value(m_ptr);
    return value;
}
void GCBeam::SetParent(GCBaseModelEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCBeam(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCBeam>("CBeam")
        .addConstructor<void (*)(std::string)>()
        .addProperty("FrameRate", &GCBeam::GetFrameRate, &GCBeam::SetFrameRate)
        .addProperty("HDRColorScale", &GCBeam::GetHDRColorScale, &GCBeam::SetHDRColorScale)
        .addProperty("FireTime", &GCBeam::GetFireTime, &GCBeam::SetFireTime)
        .addProperty("Damage", &GCBeam::GetDamage, &GCBeam::SetDamage)
        .addProperty("NumBeamEnts", &GCBeam::GetNumBeamEnts, &GCBeam::SetNumBeamEnts)
        .addProperty("BeamType", &GCBeam::GetBeamType, &GCBeam::SetBeamType)
        .addProperty("BeamFlags", &GCBeam::GetBeamFlags, &GCBeam::SetBeamFlags)
        .addProperty("AttachEntity", &GCBeam::GetAttachEntity, &GCBeam::SetAttachEntity)
        .addProperty("Width", &GCBeam::GetWidth, &GCBeam::SetWidth)
        .addProperty("EndWidth", &GCBeam::GetEndWidth, &GCBeam::SetEndWidth)
        .addProperty("FadeLength", &GCBeam::GetFadeLength, &GCBeam::SetFadeLength)
        .addProperty("HaloScale", &GCBeam::GetHaloScale, &GCBeam::SetHaloScale)
        .addProperty("Amplitude", &GCBeam::GetAmplitude, &GCBeam::SetAmplitude)
        .addProperty("StartFrame", &GCBeam::GetStartFrame, &GCBeam::SetStartFrame)
        .addProperty("Speed", &GCBeam::GetSpeed, &GCBeam::SetSpeed)
        .addProperty("Frame", &GCBeam::GetFrame, &GCBeam::SetFrame)
        .addProperty("ClipStyle", &GCBeam::GetClipStyle, &GCBeam::SetClipStyle)
        .addProperty("TurnedOff", &GCBeam::GetTurnedOff, &GCBeam::SetTurnedOff)
        .addProperty("EndPos", &GCBeam::GetEndPos, &GCBeam::SetEndPos)
        .addProperty("EndEntity", &GCBeam::GetEndEntity, &GCBeam::SetEndEntity)
        .addProperty("DissolveType", &GCBeam::GetDissolveType, &GCBeam::SetDissolveType)
        .addProperty("Parent", &GCBeam::GetParent, &GCBeam::SetParent)
        .addFunction("ToPtr", &GCBeam::ToPtr)
        .addFunction("IsValid", &GCBeam::IsValid)
        .endClass();
}
GCCommentaryViewPosition::GCCommentaryViewPosition(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCCommentaryViewPosition::GCCommentaryViewPosition(void *ptr) {
    m_ptr = ptr;
}
std::string GCCommentaryViewPosition::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCCommentaryViewPosition::IsValid() {
    return (m_ptr != nullptr);
}
GCSprite GCCommentaryViewPosition::GetParent() const {
    GCSprite value(m_ptr);
    return value;
}
void GCCommentaryViewPosition::SetParent(GCSprite value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCCommentaryViewPosition(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCCommentaryViewPosition>("CCommentaryViewPosition")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCCommentaryViewPosition::GetParent, &GCCommentaryViewPosition::SetParent)
        .addFunction("ToPtr", &GCCommentaryViewPosition::ToPtr)
        .addFunction("IsValid", &GCCommentaryViewPosition::IsValid)
        .endClass();
}
GCTonemapController2Alias_env_tonemap_controller2::GCTonemapController2Alias_env_tonemap_controller2(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCTonemapController2Alias_env_tonemap_controller2::GCTonemapController2Alias_env_tonemap_controller2(void *ptr) {
    m_ptr = ptr;
}
std::string GCTonemapController2Alias_env_tonemap_controller2::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCTonemapController2Alias_env_tonemap_controller2::IsValid() {
    return (m_ptr != nullptr);
}
GCTonemapController2 GCTonemapController2Alias_env_tonemap_controller2::GetParent() const {
    GCTonemapController2 value(m_ptr);
    return value;
}
void GCTonemapController2Alias_env_tonemap_controller2::SetParent(GCTonemapController2 value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCTonemapController2Alias_env_tonemap_controller2(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCTonemapController2Alias_env_tonemap_controller2>("CTonemapController2Alias_env_tonemap_controller2")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCTonemapController2Alias_env_tonemap_controller2::GetParent, &GCTonemapController2Alias_env_tonemap_controller2::SetParent)
        .addFunction("ToPtr", &GCTonemapController2Alias_env_tonemap_controller2::ToPtr)
        .addFunction("IsValid", &GCTonemapController2Alias_env_tonemap_controller2::IsValid)
        .endClass();
}
GCPhysPulley::GCPhysPulley(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCPhysPulley::GCPhysPulley(void *ptr) {
    m_ptr = ptr;
}
Vector GCPhysPulley::GetPosition2() const {
    return GetSchemaValue<Vector>(m_ptr, "CPhysPulley", "m_position2");
}
void GCPhysPulley::SetPosition2(Vector value) {
    SetSchemaValue(m_ptr, "CPhysPulley", "m_position2", false, value);
}
std::vector<Vector> GCPhysPulley::GetOffset() const {
    Vector* outValue = GetSchemaValue<Vector*>(m_ptr, "CPhysPulley", "m_offset"); std::vector<Vector> ret; for(int i = 0; i < 2; i++) { ret.push_back(outValue[i]); } return ret;
}
void GCPhysPulley::SetOffset(std::vector<Vector> value) {
    Vector* outValue = GetSchemaValue<Vector*>(m_ptr, "CPhysPulley", "m_offset"); for(int i = 0; i < 2; i++) { outValue[i] = value[i]; } SetSchemaValue(m_ptr, "CPhysPulley", "m_offset", false, outValue);
}
float GCPhysPulley::GetAddLength() const {
    return GetSchemaValue<float>(m_ptr, "CPhysPulley", "m_addLength");
}
void GCPhysPulley::SetAddLength(float value) {
    SetSchemaValue(m_ptr, "CPhysPulley", "m_addLength", false, value);
}
float GCPhysPulley::GetGearRatio() const {
    return GetSchemaValue<float>(m_ptr, "CPhysPulley", "m_gearRatio");
}
void GCPhysPulley::SetGearRatio(float value) {
    SetSchemaValue(m_ptr, "CPhysPulley", "m_gearRatio", false, value);
}
std::string GCPhysPulley::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCPhysPulley::IsValid() {
    return (m_ptr != nullptr);
}
GCPhysConstraint GCPhysPulley::GetParent() const {
    GCPhysConstraint value(m_ptr);
    return value;
}
void GCPhysPulley::SetParent(GCPhysConstraint value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCPhysPulley(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCPhysPulley>("CPhysPulley")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Position2", &GCPhysPulley::GetPosition2, &GCPhysPulley::SetPosition2)
        .addProperty("Offset", &GCPhysPulley::GetOffset, &GCPhysPulley::SetOffset)
        .addProperty("AddLength", &GCPhysPulley::GetAddLength, &GCPhysPulley::SetAddLength)
        .addProperty("GearRatio", &GCPhysPulley::GetGearRatio, &GCPhysPulley::SetGearRatio)
        .addProperty("Parent", &GCPhysPulley::GetParent, &GCPhysPulley::SetParent)
        .addFunction("ToPtr", &GCPhysPulley::ToPtr)
        .addFunction("IsValid", &GCPhysPulley::IsValid)
        .endClass();
}
GCGameRulesProxy::GCGameRulesProxy(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCGameRulesProxy::GCGameRulesProxy(void *ptr) {
    m_ptr = ptr;
}
std::string GCGameRulesProxy::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCGameRulesProxy::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseEntity GCGameRulesProxy::GetParent() const {
    GCBaseEntity value(m_ptr);
    return value;
}
void GCGameRulesProxy::SetParent(GCBaseEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCGameRulesProxy(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCGameRulesProxy>("CGameRulesProxy")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCGameRulesProxy::GetParent, &GCGameRulesProxy::SetParent)
        .addFunction("ToPtr", &GCGameRulesProxy::ToPtr)
        .addFunction("IsValid", &GCGameRulesProxy::IsValid)
        .endClass();
}
GCWeaponMP7::GCWeaponMP7(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCWeaponMP7::GCWeaponMP7(void *ptr) {
    m_ptr = ptr;
}
std::string GCWeaponMP7::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCWeaponMP7::IsValid() {
    return (m_ptr != nullptr);
}
GCCSWeaponBaseGun GCWeaponMP7::GetParent() const {
    GCCSWeaponBaseGun value(m_ptr);
    return value;
}
void GCWeaponMP7::SetParent(GCCSWeaponBaseGun value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCWeaponMP7(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCWeaponMP7>("CWeaponMP7")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCWeaponMP7::GetParent, &GCWeaponMP7::SetParent)
        .addFunction("ToPtr", &GCWeaponMP7::ToPtr)
        .addFunction("IsValid", &GCWeaponMP7::IsValid)
        .endClass();
}
GCCSPlayerController_ActionTrackingServices::GCCSPlayerController_ActionTrackingServices(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCCSPlayerController_ActionTrackingServices::GCCSPlayerController_ActionTrackingServices(void *ptr) {
    m_ptr = ptr;
}
std::vector<GCSPerRoundStats_t> GCCSPlayerController_ActionTrackingServices::GetPerRoundStats() const {
    CUtlVector<GCSPerRoundStats_t>* vec = GetSchemaValue<CUtlVector<GCSPerRoundStats_t>*>(m_ptr, "CCSPlayerController_ActionTrackingServices", "m_perRoundStats"); std::vector<GCSPerRoundStats_t> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCCSPlayerController_ActionTrackingServices::SetPerRoundStats(std::vector<GCSPerRoundStats_t> value) {
    SetSchemaValueCUtlVector<GCSPerRoundStats_t>(m_ptr, "CCSPlayerController_ActionTrackingServices", "m_perRoundStats", false, value);
}
GCSMatchStats_t GCCSPlayerController_ActionTrackingServices::GetMatchStats() const {
    GCSMatchStats_t value(GetSchemaPtr(m_ptr, "CCSPlayerController_ActionTrackingServices", "m_matchStats"));
    return value;
}
void GCCSPlayerController_ActionTrackingServices::SetMatchStats(GCSMatchStats_t value) {
    SetSchemaValue(m_ptr, "CCSPlayerController_ActionTrackingServices", "m_matchStats", false, value);
}
int32_t GCCSPlayerController_ActionTrackingServices::GetNumRoundKills() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSPlayerController_ActionTrackingServices", "m_iNumRoundKills");
}
void GCCSPlayerController_ActionTrackingServices::SetNumRoundKills(int32_t value) {
    SetSchemaValue(m_ptr, "CCSPlayerController_ActionTrackingServices", "m_iNumRoundKills", false, value);
}
int32_t GCCSPlayerController_ActionTrackingServices::GetNumRoundKillsHeadshots() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSPlayerController_ActionTrackingServices", "m_iNumRoundKillsHeadshots");
}
void GCCSPlayerController_ActionTrackingServices::SetNumRoundKillsHeadshots(int32_t value) {
    SetSchemaValue(m_ptr, "CCSPlayerController_ActionTrackingServices", "m_iNumRoundKillsHeadshots", false, value);
}
uint32_t GCCSPlayerController_ActionTrackingServices::GetTotalRoundDamageDealt() const {
    return GetSchemaValue<uint32_t>(m_ptr, "CCSPlayerController_ActionTrackingServices", "m_unTotalRoundDamageDealt");
}
void GCCSPlayerController_ActionTrackingServices::SetTotalRoundDamageDealt(uint32_t value) {
    SetSchemaValue(m_ptr, "CCSPlayerController_ActionTrackingServices", "m_unTotalRoundDamageDealt", false, value);
}
std::string GCCSPlayerController_ActionTrackingServices::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCCSPlayerController_ActionTrackingServices::IsValid() {
    return (m_ptr != nullptr);
}
GCPlayerControllerComponent GCCSPlayerController_ActionTrackingServices::GetParent() const {
    GCPlayerControllerComponent value(m_ptr);
    return value;
}
void GCCSPlayerController_ActionTrackingServices::SetParent(GCPlayerControllerComponent value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCCSPlayerController_ActionTrackingServices(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCCSPlayerController_ActionTrackingServices>("CCSPlayerController_ActionTrackingServices")
        .addConstructor<void (*)(std::string)>()
        .addProperty("PerRoundStats", &GCCSPlayerController_ActionTrackingServices::GetPerRoundStats, &GCCSPlayerController_ActionTrackingServices::SetPerRoundStats)
        .addProperty("MatchStats", &GCCSPlayerController_ActionTrackingServices::GetMatchStats, &GCCSPlayerController_ActionTrackingServices::SetMatchStats)
        .addProperty("NumRoundKills", &GCCSPlayerController_ActionTrackingServices::GetNumRoundKills, &GCCSPlayerController_ActionTrackingServices::SetNumRoundKills)
        .addProperty("NumRoundKillsHeadshots", &GCCSPlayerController_ActionTrackingServices::GetNumRoundKillsHeadshots, &GCCSPlayerController_ActionTrackingServices::SetNumRoundKillsHeadshots)
        .addProperty("TotalRoundDamageDealt", &GCCSPlayerController_ActionTrackingServices::GetTotalRoundDamageDealt, &GCCSPlayerController_ActionTrackingServices::SetTotalRoundDamageDealt)
        .addProperty("Parent", &GCCSPlayerController_ActionTrackingServices::GetParent, &GCCSPlayerController_ActionTrackingServices::SetParent)
        .addFunction("ToPtr", &GCCSPlayerController_ActionTrackingServices::ToPtr)
        .addFunction("IsValid", &GCCSPlayerController_ActionTrackingServices::IsValid)
        .endClass();
}
GCPrecipitationBlocker::GCPrecipitationBlocker(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCPrecipitationBlocker::GCPrecipitationBlocker(void *ptr) {
    m_ptr = ptr;
}
std::string GCPrecipitationBlocker::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCPrecipitationBlocker::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseModelEntity GCPrecipitationBlocker::GetParent() const {
    GCBaseModelEntity value(m_ptr);
    return value;
}
void GCPrecipitationBlocker::SetParent(GCBaseModelEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCPrecipitationBlocker(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCPrecipitationBlocker>("CPrecipitationBlocker")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCPrecipitationBlocker::GetParent, &GCPrecipitationBlocker::SetParent)
        .addFunction("ToPtr", &GCPrecipitationBlocker::ToPtr)
        .addFunction("IsValid", &GCPrecipitationBlocker::IsValid)
        .endClass();
}
GCBaseFlexAlias_funCBaseFlex::GCBaseFlexAlias_funCBaseFlex(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCBaseFlexAlias_funCBaseFlex::GCBaseFlexAlias_funCBaseFlex(void *ptr) {
    m_ptr = ptr;
}
std::string GCBaseFlexAlias_funCBaseFlex::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCBaseFlexAlias_funCBaseFlex::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseFlex GCBaseFlexAlias_funCBaseFlex::GetParent() const {
    GCBaseFlex value(m_ptr);
    return value;
}
void GCBaseFlexAlias_funCBaseFlex::SetParent(GCBaseFlex value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCBaseFlexAlias_funCBaseFlex(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCBaseFlexAlias_funCBaseFlex>("CBaseFlexAlias_funCBaseFlex")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCBaseFlexAlias_funCBaseFlex::GetParent, &GCBaseFlexAlias_funCBaseFlex::SetParent)
        .addFunction("ToPtr", &GCBaseFlexAlias_funCBaseFlex::ToPtr)
        .addFunction("IsValid", &GCBaseFlexAlias_funCBaseFlex::IsValid)
        .endClass();
}
GCFish::GCFish(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCFish::GCFish(void *ptr) {
    m_ptr = ptr;
}
GCFishPool GCFish::GetPool() const {
    GCFishPool value(*GetSchemaValuePtr<void*>(m_ptr, "CFish", "m_pool"));
    return value;
}
void GCFish::SetPool(GCFishPool* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Pool' is not possible.\n");
}
uint32_t GCFish::GetId() const {
    return GetSchemaValue<uint32_t>(m_ptr, "CFish", "m_id");
}
void GCFish::SetId(uint32_t value) {
    SetSchemaValue(m_ptr, "CFish", "m_id", false, value);
}
float GCFish::GetX() const {
    return GetSchemaValue<float>(m_ptr, "CFish", "m_x");
}
void GCFish::SetX(float value) {
    SetSchemaValue(m_ptr, "CFish", "m_x", false, value);
}
float GCFish::GetY() const {
    return GetSchemaValue<float>(m_ptr, "CFish", "m_y");
}
void GCFish::SetY(float value) {
    SetSchemaValue(m_ptr, "CFish", "m_y", false, value);
}
float GCFish::GetZ() const {
    return GetSchemaValue<float>(m_ptr, "CFish", "m_z");
}
void GCFish::SetZ(float value) {
    SetSchemaValue(m_ptr, "CFish", "m_z", false, value);
}
float GCFish::GetAngle() const {
    return GetSchemaValue<float>(m_ptr, "CFish", "m_angle");
}
void GCFish::SetAngle(float value) {
    SetSchemaValue(m_ptr, "CFish", "m_angle", false, value);
}
float GCFish::GetAngleChange() const {
    return GetSchemaValue<float>(m_ptr, "CFish", "m_angleChange");
}
void GCFish::SetAngleChange(float value) {
    SetSchemaValue(m_ptr, "CFish", "m_angleChange", false, value);
}
Vector GCFish::GetForward() const {
    return GetSchemaValue<Vector>(m_ptr, "CFish", "m_forward");
}
void GCFish::SetForward(Vector value) {
    SetSchemaValue(m_ptr, "CFish", "m_forward", false, value);
}
Vector GCFish::GetPerp() const {
    return GetSchemaValue<Vector>(m_ptr, "CFish", "m_perp");
}
void GCFish::SetPerp(Vector value) {
    SetSchemaValue(m_ptr, "CFish", "m_perp", false, value);
}
Vector GCFish::GetPoolOrigin() const {
    return GetSchemaValue<Vector>(m_ptr, "CFish", "m_poolOrigin");
}
void GCFish::SetPoolOrigin(Vector value) {
    SetSchemaValue(m_ptr, "CFish", "m_poolOrigin", false, value);
}
float GCFish::GetWaterLevel() const {
    return GetSchemaValue<float>(m_ptr, "CFish", "m_waterLevel");
}
void GCFish::SetWaterLevel(float value) {
    SetSchemaValue(m_ptr, "CFish", "m_waterLevel", false, value);
}
float GCFish::GetSpeed() const {
    return GetSchemaValue<float>(m_ptr, "CFish", "m_speed");
}
void GCFish::SetSpeed(float value) {
    SetSchemaValue(m_ptr, "CFish", "m_speed", false, value);
}
float GCFish::GetDesiredSpeed() const {
    return GetSchemaValue<float>(m_ptr, "CFish", "m_desiredSpeed");
}
void GCFish::SetDesiredSpeed(float value) {
    SetSchemaValue(m_ptr, "CFish", "m_desiredSpeed", false, value);
}
float GCFish::GetCalmSpeed() const {
    return GetSchemaValue<float>(m_ptr, "CFish", "m_calmSpeed");
}
void GCFish::SetCalmSpeed(float value) {
    SetSchemaValue(m_ptr, "CFish", "m_calmSpeed", false, value);
}
float GCFish::GetPanicSpeed() const {
    return GetSchemaValue<float>(m_ptr, "CFish", "m_panicSpeed");
}
void GCFish::SetPanicSpeed(float value) {
    SetSchemaValue(m_ptr, "CFish", "m_panicSpeed", false, value);
}
float GCFish::GetAvoidRange() const {
    return GetSchemaValue<float>(m_ptr, "CFish", "m_avoidRange");
}
void GCFish::SetAvoidRange(float value) {
    SetSchemaValue(m_ptr, "CFish", "m_avoidRange", false, value);
}
GCountdownTimer GCFish::GetTurnTimer() const {
    GCountdownTimer value(GetSchemaPtr(m_ptr, "CFish", "m_turnTimer"));
    return value;
}
void GCFish::SetTurnTimer(GCountdownTimer value) {
    SetSchemaValue(m_ptr, "CFish", "m_turnTimer", false, value);
}
bool GCFish::GetTurnClockwise() const {
    return GetSchemaValue<bool>(m_ptr, "CFish", "m_turnClockwise");
}
void GCFish::SetTurnClockwise(bool value) {
    SetSchemaValue(m_ptr, "CFish", "m_turnClockwise", false, value);
}
GCountdownTimer GCFish::GetGoTimer() const {
    GCountdownTimer value(GetSchemaPtr(m_ptr, "CFish", "m_goTimer"));
    return value;
}
void GCFish::SetGoTimer(GCountdownTimer value) {
    SetSchemaValue(m_ptr, "CFish", "m_goTimer", false, value);
}
GCountdownTimer GCFish::GetMoveTimer() const {
    GCountdownTimer value(GetSchemaPtr(m_ptr, "CFish", "m_moveTimer"));
    return value;
}
void GCFish::SetMoveTimer(GCountdownTimer value) {
    SetSchemaValue(m_ptr, "CFish", "m_moveTimer", false, value);
}
GCountdownTimer GCFish::GetPanicTimer() const {
    GCountdownTimer value(GetSchemaPtr(m_ptr, "CFish", "m_panicTimer"));
    return value;
}
void GCFish::SetPanicTimer(GCountdownTimer value) {
    SetSchemaValue(m_ptr, "CFish", "m_panicTimer", false, value);
}
GCountdownTimer GCFish::GetDisperseTimer() const {
    GCountdownTimer value(GetSchemaPtr(m_ptr, "CFish", "m_disperseTimer"));
    return value;
}
void GCFish::SetDisperseTimer(GCountdownTimer value) {
    SetSchemaValue(m_ptr, "CFish", "m_disperseTimer", false, value);
}
GCountdownTimer GCFish::GetProximityTimer() const {
    GCountdownTimer value(GetSchemaPtr(m_ptr, "CFish", "m_proximityTimer"));
    return value;
}
void GCFish::SetProximityTimer(GCountdownTimer value) {
    SetSchemaValue(m_ptr, "CFish", "m_proximityTimer", false, value);
}
std::vector<GCFish*> GCFish::GetVisible() const {
    CUtlVector<GCFish*>* vec = GetSchemaValue<CUtlVector<GCFish*>*>(m_ptr, "CFish", "m_visible"); std::vector<GCFish*> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCFish::SetVisible(std::vector<GCFish*> value) {
    SetSchemaValueCUtlVector<GCFish*>(m_ptr, "CFish", "m_visible", false, value);
}
std::string GCFish::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCFish::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseAnimGraph GCFish::GetParent() const {
    GCBaseAnimGraph value(m_ptr);
    return value;
}
void GCFish::SetParent(GCBaseAnimGraph value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCFish(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCFish>("CFish")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Pool", &GCFish::GetPool, &GCFish::SetPool)
        .addProperty("Id", &GCFish::GetId, &GCFish::SetId)
        .addProperty("X", &GCFish::GetX, &GCFish::SetX)
        .addProperty("Y", &GCFish::GetY, &GCFish::SetY)
        .addProperty("Z", &GCFish::GetZ, &GCFish::SetZ)
        .addProperty("Angle", &GCFish::GetAngle, &GCFish::SetAngle)
        .addProperty("AngleChange", &GCFish::GetAngleChange, &GCFish::SetAngleChange)
        .addProperty("Forward", &GCFish::GetForward, &GCFish::SetForward)
        .addProperty("Perp", &GCFish::GetPerp, &GCFish::SetPerp)
        .addProperty("PoolOrigin", &GCFish::GetPoolOrigin, &GCFish::SetPoolOrigin)
        .addProperty("WaterLevel", &GCFish::GetWaterLevel, &GCFish::SetWaterLevel)
        .addProperty("Speed", &GCFish::GetSpeed, &GCFish::SetSpeed)
        .addProperty("DesiredSpeed", &GCFish::GetDesiredSpeed, &GCFish::SetDesiredSpeed)
        .addProperty("CalmSpeed", &GCFish::GetCalmSpeed, &GCFish::SetCalmSpeed)
        .addProperty("PanicSpeed", &GCFish::GetPanicSpeed, &GCFish::SetPanicSpeed)
        .addProperty("AvoidRange", &GCFish::GetAvoidRange, &GCFish::SetAvoidRange)
        .addProperty("TurnTimer", &GCFish::GetTurnTimer, &GCFish::SetTurnTimer)
        .addProperty("TurnClockwise", &GCFish::GetTurnClockwise, &GCFish::SetTurnClockwise)
        .addProperty("GoTimer", &GCFish::GetGoTimer, &GCFish::SetGoTimer)
        .addProperty("MoveTimer", &GCFish::GetMoveTimer, &GCFish::SetMoveTimer)
        .addProperty("PanicTimer", &GCFish::GetPanicTimer, &GCFish::SetPanicTimer)
        .addProperty("DisperseTimer", &GCFish::GetDisperseTimer, &GCFish::SetDisperseTimer)
        .addProperty("ProximityTimer", &GCFish::GetProximityTimer, &GCFish::SetProximityTimer)
        .addProperty("Visible", &GCFish::GetVisible, &GCFish::SetVisible)
        .addProperty("Parent", &GCFish::GetParent, &GCFish::SetParent)
        .addFunction("ToPtr", &GCFish::ToPtr)
        .addFunction("IsValid", &GCFish::IsValid)
        .endClass();
}
GCEnvFireSource::GCEnvFireSource(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCEnvFireSource::GCEnvFireSource(void *ptr) {
    m_ptr = ptr;
}
bool GCEnvFireSource::GetEnabled() const {
    return GetSchemaValue<bool>(m_ptr, "CEnvFireSource", "m_bEnabled");
}
void GCEnvFireSource::SetEnabled(bool value) {
    SetSchemaValue(m_ptr, "CEnvFireSource", "m_bEnabled", false, value);
}
float GCEnvFireSource::GetRadius() const {
    return GetSchemaValue<float>(m_ptr, "CEnvFireSource", "m_radius");
}
void GCEnvFireSource::SetRadius(float value) {
    SetSchemaValue(m_ptr, "CEnvFireSource", "m_radius", false, value);
}
float GCEnvFireSource::GetDamage() const {
    return GetSchemaValue<float>(m_ptr, "CEnvFireSource", "m_damage");
}
void GCEnvFireSource::SetDamage(float value) {
    SetSchemaValue(m_ptr, "CEnvFireSource", "m_damage", false, value);
}
std::string GCEnvFireSource::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCEnvFireSource::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseEntity GCEnvFireSource::GetParent() const {
    GCBaseEntity value(m_ptr);
    return value;
}
void GCEnvFireSource::SetParent(GCBaseEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCEnvFireSource(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCEnvFireSource>("CEnvFireSource")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Enabled", &GCEnvFireSource::GetEnabled, &GCEnvFireSource::SetEnabled)
        .addProperty("Radius", &GCEnvFireSource::GetRadius, &GCEnvFireSource::SetRadius)
        .addProperty("Damage", &GCEnvFireSource::GetDamage, &GCEnvFireSource::SetDamage)
        .addProperty("Parent", &GCEnvFireSource::GetParent, &GCEnvFireSource::SetParent)
        .addFunction("ToPtr", &GCEnvFireSource::ToPtr)
        .addFunction("IsValid", &GCEnvFireSource::IsValid)
        .endClass();
}
GCInfoLadderDismount::GCInfoLadderDismount(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCInfoLadderDismount::GCInfoLadderDismount(void *ptr) {
    m_ptr = ptr;
}
std::string GCInfoLadderDismount::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCInfoLadderDismount::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseEntity GCInfoLadderDismount::GetParent() const {
    GCBaseEntity value(m_ptr);
    return value;
}
void GCInfoLadderDismount::SetParent(GCBaseEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCInfoLadderDismount(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCInfoLadderDismount>("CInfoLadderDismount")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCInfoLadderDismount::GetParent, &GCInfoLadderDismount::SetParent)
        .addFunction("ToPtr", &GCInfoLadderDismount::ToPtr)
        .addFunction("IsValid", &GCInfoLadderDismount::IsValid)
        .endClass();
}
GCTriggerGameEvent::GCTriggerGameEvent(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCTriggerGameEvent::GCTriggerGameEvent(void *ptr) {
    m_ptr = ptr;
}
std::string GCTriggerGameEvent::GetStrStartTouchEventName() const {
    return GetSchemaValue<CUtlString>(m_ptr, "CTriggerGameEvent", "m_strStartTouchEventName").Get();
}
void GCTriggerGameEvent::SetStrStartTouchEventName(std::string value) {
    SetSchemaValue(m_ptr, "CTriggerGameEvent", "m_strStartTouchEventName", false, CUtlString(value.c_str()));
}
std::string GCTriggerGameEvent::GetStrEndTouchEventName() const {
    return GetSchemaValue<CUtlString>(m_ptr, "CTriggerGameEvent", "m_strEndTouchEventName").Get();
}
void GCTriggerGameEvent::SetStrEndTouchEventName(std::string value) {
    SetSchemaValue(m_ptr, "CTriggerGameEvent", "m_strEndTouchEventName", false, CUtlString(value.c_str()));
}
std::string GCTriggerGameEvent::GetStrTriggerID() const {
    return GetSchemaValue<CUtlString>(m_ptr, "CTriggerGameEvent", "m_strTriggerID").Get();
}
void GCTriggerGameEvent::SetStrTriggerID(std::string value) {
    SetSchemaValue(m_ptr, "CTriggerGameEvent", "m_strTriggerID", false, CUtlString(value.c_str()));
}
std::string GCTriggerGameEvent::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCTriggerGameEvent::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseTrigger GCTriggerGameEvent::GetParent() const {
    GCBaseTrigger value(m_ptr);
    return value;
}
void GCTriggerGameEvent::SetParent(GCBaseTrigger value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCTriggerGameEvent(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCTriggerGameEvent>("CTriggerGameEvent")
        .addConstructor<void (*)(std::string)>()
        .addProperty("StrStartTouchEventName", &GCTriggerGameEvent::GetStrStartTouchEventName, &GCTriggerGameEvent::SetStrStartTouchEventName)
        .addProperty("StrEndTouchEventName", &GCTriggerGameEvent::GetStrEndTouchEventName, &GCTriggerGameEvent::SetStrEndTouchEventName)
        .addProperty("StrTriggerID", &GCTriggerGameEvent::GetStrTriggerID, &GCTriggerGameEvent::SetStrTriggerID)
        .addProperty("Parent", &GCTriggerGameEvent::GetParent, &GCTriggerGameEvent::SetParent)
        .addFunction("ToPtr", &GCTriggerGameEvent::ToPtr)
        .addFunction("IsValid", &GCTriggerGameEvent::IsValid)
        .endClass();
}
GSimpleConstraintSoundProfile::GSimpleConstraintSoundProfile(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GSimpleConstraintSoundProfile::GSimpleConstraintSoundProfile(void *ptr) {
    m_ptr = ptr;
}
GSimpleConstraintSoundProfile GSimpleConstraintSoundProfile::GetKeypoints() const {
    GSimpleConstraintSoundProfile value(GetSchemaPtr(m_ptr, "SimpleConstraintSoundProfile", "eKeypoints"));
    return value;
}
void GSimpleConstraintSoundProfile::SetKeypoints(GSimpleConstraintSoundProfile value) {
    SetSchemaValue(m_ptr, "SimpleConstraintSoundProfile", "eKeypoints", false, value);
}
std::vector<float> GSimpleConstraintSoundProfile::GetKeyPoints() const {
    float* outValue = GetSchemaValue<float*>(m_ptr, "SimpleConstraintSoundProfile", "m_keyPoints"); std::vector<float> ret; for(int i = 0; i < 2; i++) { ret.push_back(outValue[i]); } return ret;
}
void GSimpleConstraintSoundProfile::SetKeyPoints(std::vector<float> value) {
    float* outValue = GetSchemaValue<float*>(m_ptr, "SimpleConstraintSoundProfile", "m_keyPoints"); for(int i = 0; i < 2; i++) { outValue[i] = value[i]; } SetSchemaValue(m_ptr, "SimpleConstraintSoundProfile", "m_keyPoints", false, outValue);
}
std::vector<float> GSimpleConstraintSoundProfile::GetReversalSoundThresholds() const {
    float* outValue = GetSchemaValue<float*>(m_ptr, "SimpleConstraintSoundProfile", "m_reversalSoundThresholds"); std::vector<float> ret; for(int i = 0; i < 3; i++) { ret.push_back(outValue[i]); } return ret;
}
void GSimpleConstraintSoundProfile::SetReversalSoundThresholds(std::vector<float> value) {
    float* outValue = GetSchemaValue<float*>(m_ptr, "SimpleConstraintSoundProfile", "m_reversalSoundThresholds"); for(int i = 0; i < 3; i++) { outValue[i] = value[i]; } SetSchemaValue(m_ptr, "SimpleConstraintSoundProfile", "m_reversalSoundThresholds", false, outValue);
}
std::string GSimpleConstraintSoundProfile::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GSimpleConstraintSoundProfile::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassSimpleConstraintSoundProfile(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GSimpleConstraintSoundProfile>("SimpleConstraintSoundProfile")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Keypoints", &GSimpleConstraintSoundProfile::GetKeypoints, &GSimpleConstraintSoundProfile::SetKeypoints)
        .addProperty("KeyPoints", &GSimpleConstraintSoundProfile::GetKeyPoints, &GSimpleConstraintSoundProfile::SetKeyPoints)
        .addProperty("ReversalSoundThresholds", &GSimpleConstraintSoundProfile::GetReversalSoundThresholds, &GSimpleConstraintSoundProfile::SetReversalSoundThresholds)
        .addFunction("ToPtr", &GSimpleConstraintSoundProfile::ToPtr)
        .addFunction("IsValid", &GSimpleConstraintSoundProfile::IsValid)
        .endClass();
}
GCDebugHistory::GCDebugHistory(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCDebugHistory::GCDebugHistory(void *ptr) {
    m_ptr = ptr;
}
int32_t GCDebugHistory::GetNpcEvents() const {
    return GetSchemaValue<int32_t>(m_ptr, "CDebugHistory", "m_nNpcEvents");
}
void GCDebugHistory::SetNpcEvents(int32_t value) {
    SetSchemaValue(m_ptr, "CDebugHistory", "m_nNpcEvents", false, value);
}
std::string GCDebugHistory::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCDebugHistory::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseEntity GCDebugHistory::GetParent() const {
    GCBaseEntity value(m_ptr);
    return value;
}
void GCDebugHistory::SetParent(GCBaseEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCDebugHistory(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCDebugHistory>("CDebugHistory")
        .addConstructor<void (*)(std::string)>()
        .addProperty("NpcEvents", &GCDebugHistory::GetNpcEvents, &GCDebugHistory::SetNpcEvents)
        .addProperty("Parent", &GCDebugHistory::GetParent, &GCDebugHistory::SetParent)
        .addFunction("ToPtr", &GCDebugHistory::ToPtr)
        .addFunction("IsValid", &GCDebugHistory::IsValid)
        .endClass();
}
GCInfoData::GCInfoData(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCInfoData::GCInfoData(void *ptr) {
    m_ptr = ptr;
}
std::string GCInfoData::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCInfoData::IsValid() {
    return (m_ptr != nullptr);
}
GCServerOnlyEntity GCInfoData::GetParent() const {
    GCServerOnlyEntity value(m_ptr);
    return value;
}
void GCInfoData::SetParent(GCServerOnlyEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCInfoData(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCInfoData>("CInfoData")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCInfoData::GetParent, &GCInfoData::SetParent)
        .addFunction("ToPtr", &GCInfoData::ToPtr)
        .addFunction("IsValid", &GCInfoData::IsValid)
        .endClass();
}
GCHostageCarriableProp::GCHostageCarriableProp(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCHostageCarriableProp::GCHostageCarriableProp(void *ptr) {
    m_ptr = ptr;
}
std::string GCHostageCarriableProp::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCHostageCarriableProp::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseAnimGraph GCHostageCarriableProp::GetParent() const {
    GCBaseAnimGraph value(m_ptr);
    return value;
}
void GCHostageCarriableProp::SetParent(GCBaseAnimGraph value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCHostageCarriableProp(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCHostageCarriableProp>("CHostageCarriableProp")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCHostageCarriableProp::GetParent, &GCHostageCarriableProp::SetParent)
        .addFunction("ToPtr", &GCHostageCarriableProp::ToPtr)
        .addFunction("IsValid", &GCHostageCarriableProp::IsValid)
        .endClass();
}
GCLightSpotEntity::GCLightSpotEntity(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCLightSpotEntity::GCLightSpotEntity(void *ptr) {
    m_ptr = ptr;
}
std::string GCLightSpotEntity::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCLightSpotEntity::IsValid() {
    return (m_ptr != nullptr);
}
GCLightEntity GCLightSpotEntity::GetParent() const {
    GCLightEntity value(m_ptr);
    return value;
}
void GCLightSpotEntity::SetParent(GCLightEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCLightSpotEntity(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCLightSpotEntity>("CLightSpotEntity")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCLightSpotEntity::GetParent, &GCLightSpotEntity::SetParent)
        .addFunction("ToPtr", &GCLightSpotEntity::ToPtr)
        .addFunction("IsValid", &GCLightSpotEntity::IsValid)
        .endClass();
}
GCFuncRotating::GCFuncRotating(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCFuncRotating::GCFuncRotating(void *ptr) {
    m_ptr = ptr;
}
GCEntityIOOutput GCFuncRotating::GetOnStopped() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CFuncRotating", "m_OnStopped"));
    return value;
}
void GCFuncRotating::SetOnStopped(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CFuncRotating", "m_OnStopped", false, value);
}
GCEntityIOOutput GCFuncRotating::GetOnStarted() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CFuncRotating", "m_OnStarted"));
    return value;
}
void GCFuncRotating::SetOnStarted(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CFuncRotating", "m_OnStarted", false, value);
}
GCEntityIOOutput GCFuncRotating::GetOnReachedStart() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CFuncRotating", "m_OnReachedStart"));
    return value;
}
void GCFuncRotating::SetOnReachedStart(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CFuncRotating", "m_OnReachedStart", false, value);
}
Vector GCFuncRotating::GetLocalRotationVector() const {
    return GetSchemaValue<Vector>(m_ptr, "CFuncRotating", "m_localRotationVector");
}
void GCFuncRotating::SetLocalRotationVector(Vector value) {
    SetSchemaValue(m_ptr, "CFuncRotating", "m_localRotationVector", false, value);
}
float GCFuncRotating::GetFanFriction() const {
    return GetSchemaValue<float>(m_ptr, "CFuncRotating", "m_flFanFriction");
}
void GCFuncRotating::SetFanFriction(float value) {
    SetSchemaValue(m_ptr, "CFuncRotating", "m_flFanFriction", false, value);
}
float GCFuncRotating::GetAttenuation() const {
    return GetSchemaValue<float>(m_ptr, "CFuncRotating", "m_flAttenuation");
}
void GCFuncRotating::SetAttenuation(float value) {
    SetSchemaValue(m_ptr, "CFuncRotating", "m_flAttenuation", false, value);
}
float GCFuncRotating::GetVolume() const {
    return GetSchemaValue<float>(m_ptr, "CFuncRotating", "m_flVolume");
}
void GCFuncRotating::SetVolume(float value) {
    SetSchemaValue(m_ptr, "CFuncRotating", "m_flVolume", false, value);
}
float GCFuncRotating::GetTargetSpeed() const {
    return GetSchemaValue<float>(m_ptr, "CFuncRotating", "m_flTargetSpeed");
}
void GCFuncRotating::SetTargetSpeed(float value) {
    SetSchemaValue(m_ptr, "CFuncRotating", "m_flTargetSpeed", false, value);
}
float GCFuncRotating::GetMaxSpeed() const {
    return GetSchemaValue<float>(m_ptr, "CFuncRotating", "m_flMaxSpeed");
}
void GCFuncRotating::SetMaxSpeed(float value) {
    SetSchemaValue(m_ptr, "CFuncRotating", "m_flMaxSpeed", false, value);
}
float GCFuncRotating::GetBlockDamage() const {
    return GetSchemaValue<float>(m_ptr, "CFuncRotating", "m_flBlockDamage");
}
void GCFuncRotating::SetBlockDamage(float value) {
    SetSchemaValue(m_ptr, "CFuncRotating", "m_flBlockDamage", false, value);
}
std::string GCFuncRotating::GetNoiseRunning() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CFuncRotating", "m_NoiseRunning").String();
}
void GCFuncRotating::SetNoiseRunning(std::string value) {
    SetSchemaValue(m_ptr, "CFuncRotating", "m_NoiseRunning", false, CUtlSymbolLarge(value.c_str()));
}
bool GCFuncRotating::GetReversed() const {
    return GetSchemaValue<bool>(m_ptr, "CFuncRotating", "m_bReversed");
}
void GCFuncRotating::SetReversed(bool value) {
    SetSchemaValue(m_ptr, "CFuncRotating", "m_bReversed", false, value);
}
bool GCFuncRotating::GetAccelDecel() const {
    return GetSchemaValue<bool>(m_ptr, "CFuncRotating", "m_bAccelDecel");
}
void GCFuncRotating::SetAccelDecel(bool value) {
    SetSchemaValue(m_ptr, "CFuncRotating", "m_bAccelDecel", false, value);
}
QAngle GCFuncRotating::GetPrevLocalAngles() const {
    return GetSchemaValue<QAngle>(m_ptr, "CFuncRotating", "m_prevLocalAngles");
}
void GCFuncRotating::SetPrevLocalAngles(QAngle value) {
    SetSchemaValue(m_ptr, "CFuncRotating", "m_prevLocalAngles", false, value);
}
QAngle GCFuncRotating::GetStart() const {
    return GetSchemaValue<QAngle>(m_ptr, "CFuncRotating", "m_angStart");
}
void GCFuncRotating::SetStart(QAngle value) {
    SetSchemaValue(m_ptr, "CFuncRotating", "m_angStart", false, value);
}
bool GCFuncRotating::GetStopAtStartPos() const {
    return GetSchemaValue<bool>(m_ptr, "CFuncRotating", "m_bStopAtStartPos");
}
void GCFuncRotating::SetStopAtStartPos(bool value) {
    SetSchemaValue(m_ptr, "CFuncRotating", "m_bStopAtStartPos", false, value);
}
Vector GCFuncRotating::GetClientOrigin() const {
    return GetSchemaValue<Vector>(m_ptr, "CFuncRotating", "m_vecClientOrigin");
}
void GCFuncRotating::SetClientOrigin(Vector value) {
    SetSchemaValue(m_ptr, "CFuncRotating", "m_vecClientOrigin", false, value);
}
QAngle GCFuncRotating::GetClientAngles() const {
    return GetSchemaValue<QAngle>(m_ptr, "CFuncRotating", "m_vecClientAngles");
}
void GCFuncRotating::SetClientAngles(QAngle value) {
    SetSchemaValue(m_ptr, "CFuncRotating", "m_vecClientAngles", false, value);
}
std::string GCFuncRotating::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCFuncRotating::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseModelEntity GCFuncRotating::GetParent() const {
    GCBaseModelEntity value(m_ptr);
    return value;
}
void GCFuncRotating::SetParent(GCBaseModelEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCFuncRotating(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCFuncRotating>("CFuncRotating")
        .addConstructor<void (*)(std::string)>()
        .addProperty("OnStopped", &GCFuncRotating::GetOnStopped, &GCFuncRotating::SetOnStopped)
        .addProperty("OnStarted", &GCFuncRotating::GetOnStarted, &GCFuncRotating::SetOnStarted)
        .addProperty("OnReachedStart", &GCFuncRotating::GetOnReachedStart, &GCFuncRotating::SetOnReachedStart)
        .addProperty("LocalRotationVector", &GCFuncRotating::GetLocalRotationVector, &GCFuncRotating::SetLocalRotationVector)
        .addProperty("FanFriction", &GCFuncRotating::GetFanFriction, &GCFuncRotating::SetFanFriction)
        .addProperty("Attenuation", &GCFuncRotating::GetAttenuation, &GCFuncRotating::SetAttenuation)
        .addProperty("Volume", &GCFuncRotating::GetVolume, &GCFuncRotating::SetVolume)
        .addProperty("TargetSpeed", &GCFuncRotating::GetTargetSpeed, &GCFuncRotating::SetTargetSpeed)
        .addProperty("MaxSpeed", &GCFuncRotating::GetMaxSpeed, &GCFuncRotating::SetMaxSpeed)
        .addProperty("BlockDamage", &GCFuncRotating::GetBlockDamage, &GCFuncRotating::SetBlockDamage)
        .addProperty("NoiseRunning", &GCFuncRotating::GetNoiseRunning, &GCFuncRotating::SetNoiseRunning)
        .addProperty("Reversed", &GCFuncRotating::GetReversed, &GCFuncRotating::SetReversed)
        .addProperty("AccelDecel", &GCFuncRotating::GetAccelDecel, &GCFuncRotating::SetAccelDecel)
        .addProperty("PrevLocalAngles", &GCFuncRotating::GetPrevLocalAngles, &GCFuncRotating::SetPrevLocalAngles)
        .addProperty("Start", &GCFuncRotating::GetStart, &GCFuncRotating::SetStart)
        .addProperty("StopAtStartPos", &GCFuncRotating::GetStopAtStartPos, &GCFuncRotating::SetStopAtStartPos)
        .addProperty("ClientOrigin", &GCFuncRotating::GetClientOrigin, &GCFuncRotating::SetClientOrigin)
        .addProperty("ClientAngles", &GCFuncRotating::GetClientAngles, &GCFuncRotating::SetClientAngles)
        .addProperty("Parent", &GCFuncRotating::GetParent, &GCFuncRotating::SetParent)
        .addFunction("ToPtr", &GCFuncRotating::ToPtr)
        .addFunction("IsValid", &GCFuncRotating::IsValid)
        .endClass();
}
GCDecoyProjectile::GCDecoyProjectile(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCDecoyProjectile::GCDecoyProjectile(void *ptr) {
    m_ptr = ptr;
}
int32_t GCDecoyProjectile::GetDecoyShotTick() const {
    return GetSchemaValue<int32_t>(m_ptr, "CDecoyProjectile", "m_nDecoyShotTick");
}
void GCDecoyProjectile::SetDecoyShotTick(int32_t value) {
    SetSchemaValue(m_ptr, "CDecoyProjectile", "m_nDecoyShotTick", false, value);
}
int32_t GCDecoyProjectile::GetShotsRemaining() const {
    return GetSchemaValue<int32_t>(m_ptr, "CDecoyProjectile", "m_shotsRemaining");
}
void GCDecoyProjectile::SetShotsRemaining(int32_t value) {
    SetSchemaValue(m_ptr, "CDecoyProjectile", "m_shotsRemaining", false, value);
}
float GCDecoyProjectile::GetExpireTime() const {
    return GetSchemaValue<float>(m_ptr, "CDecoyProjectile", "m_fExpireTime");
}
void GCDecoyProjectile::SetExpireTime(float value) {
    SetSchemaValue(m_ptr, "CDecoyProjectile", "m_fExpireTime", false, value);
}
uint16_t GCDecoyProjectile::GetDecoyWeaponDefIndex() const {
    return GetSchemaValue<uint16_t>(m_ptr, "CDecoyProjectile", "m_decoyWeaponDefIndex");
}
void GCDecoyProjectile::SetDecoyWeaponDefIndex(uint16_t value) {
    SetSchemaValue(m_ptr, "CDecoyProjectile", "m_decoyWeaponDefIndex", false, value);
}
std::string GCDecoyProjectile::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCDecoyProjectile::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseCSGrenadeProjectile GCDecoyProjectile::GetParent() const {
    GCBaseCSGrenadeProjectile value(m_ptr);
    return value;
}
void GCDecoyProjectile::SetParent(GCBaseCSGrenadeProjectile value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCDecoyProjectile(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCDecoyProjectile>("CDecoyProjectile")
        .addConstructor<void (*)(std::string)>()
        .addProperty("DecoyShotTick", &GCDecoyProjectile::GetDecoyShotTick, &GCDecoyProjectile::SetDecoyShotTick)
        .addProperty("ShotsRemaining", &GCDecoyProjectile::GetShotsRemaining, &GCDecoyProjectile::SetShotsRemaining)
        .addProperty("ExpireTime", &GCDecoyProjectile::GetExpireTime, &GCDecoyProjectile::SetExpireTime)
        .addProperty("DecoyWeaponDefIndex", &GCDecoyProjectile::GetDecoyWeaponDefIndex, &GCDecoyProjectile::SetDecoyWeaponDefIndex)
        .addProperty("Parent", &GCDecoyProjectile::GetParent, &GCDecoyProjectile::SetParent)
        .addFunction("ToPtr", &GCDecoyProjectile::ToPtr)
        .addFunction("IsValid", &GCDecoyProjectile::IsValid)
        .endClass();
}
GCCSPlace::GCCSPlace(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCCSPlace::GCCSPlace(void *ptr) {
    m_ptr = ptr;
}
std::string GCCSPlace::GetName() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CCSPlace", "m_name").String();
}
void GCCSPlace::SetName(std::string value) {
    SetSchemaValue(m_ptr, "CCSPlace", "m_name", false, CUtlSymbolLarge(value.c_str()));
}
std::string GCCSPlace::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCCSPlace::IsValid() {
    return (m_ptr != nullptr);
}
GCServerOnlyModelEntity GCCSPlace::GetParent() const {
    GCServerOnlyModelEntity value(m_ptr);
    return value;
}
void GCCSPlace::SetParent(GCServerOnlyModelEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCCSPlace(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCCSPlace>("CCSPlace")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Name", &GCCSPlace::GetName, &GCCSPlace::SetName)
        .addProperty("Parent", &GCCSPlace::GetParent, &GCCSPlace::SetParent)
        .addFunction("ToPtr", &GCCSPlace::ToPtr)
        .addFunction("IsValid", &GCCSPlace::IsValid)
        .endClass();
}
GCFuncTrainControls::GCFuncTrainControls(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCFuncTrainControls::GCFuncTrainControls(void *ptr) {
    m_ptr = ptr;
}
std::string GCFuncTrainControls::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCFuncTrainControls::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseModelEntity GCFuncTrainControls::GetParent() const {
    GCBaseModelEntity value(m_ptr);
    return value;
}
void GCFuncTrainControls::SetParent(GCBaseModelEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCFuncTrainControls(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCFuncTrainControls>("CFuncTrainControls")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCFuncTrainControls::GetParent, &GCFuncTrainControls::SetParent)
        .addFunction("ToPtr", &GCFuncTrainControls::ToPtr)
        .addFunction("IsValid", &GCFuncTrainControls::IsValid)
        .endClass();
}
GCEntityDissolve::GCEntityDissolve(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCEntityDissolve::GCEntityDissolve(void *ptr) {
    m_ptr = ptr;
}
float GCEntityDissolve::GetFadeInStart() const {
    return GetSchemaValue<float>(m_ptr, "CEntityDissolve", "m_flFadeInStart");
}
void GCEntityDissolve::SetFadeInStart(float value) {
    SetSchemaValue(m_ptr, "CEntityDissolve", "m_flFadeInStart", false, value);
}
float GCEntityDissolve::GetFadeInLength() const {
    return GetSchemaValue<float>(m_ptr, "CEntityDissolve", "m_flFadeInLength");
}
void GCEntityDissolve::SetFadeInLength(float value) {
    SetSchemaValue(m_ptr, "CEntityDissolve", "m_flFadeInLength", false, value);
}
float GCEntityDissolve::GetFadeOutModelStart() const {
    return GetSchemaValue<float>(m_ptr, "CEntityDissolve", "m_flFadeOutModelStart");
}
void GCEntityDissolve::SetFadeOutModelStart(float value) {
    SetSchemaValue(m_ptr, "CEntityDissolve", "m_flFadeOutModelStart", false, value);
}
float GCEntityDissolve::GetFadeOutModelLength() const {
    return GetSchemaValue<float>(m_ptr, "CEntityDissolve", "m_flFadeOutModelLength");
}
void GCEntityDissolve::SetFadeOutModelLength(float value) {
    SetSchemaValue(m_ptr, "CEntityDissolve", "m_flFadeOutModelLength", false, value);
}
float GCEntityDissolve::GetFadeOutStart() const {
    return GetSchemaValue<float>(m_ptr, "CEntityDissolve", "m_flFadeOutStart");
}
void GCEntityDissolve::SetFadeOutStart(float value) {
    SetSchemaValue(m_ptr, "CEntityDissolve", "m_flFadeOutStart", false, value);
}
float GCEntityDissolve::GetFadeOutLength() const {
    return GetSchemaValue<float>(m_ptr, "CEntityDissolve", "m_flFadeOutLength");
}
void GCEntityDissolve::SetFadeOutLength(float value) {
    SetSchemaValue(m_ptr, "CEntityDissolve", "m_flFadeOutLength", false, value);
}
float GCEntityDissolve::GetStartTime() const {
    return GetSchemaValue<float>(m_ptr, "CEntityDissolve", "m_flStartTime");
}
void GCEntityDissolve::SetStartTime(float value) {
    SetSchemaValue(m_ptr, "CEntityDissolve", "m_flStartTime", false, value);
}
uint64_t GCEntityDissolve::GetDissolveType() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CEntityDissolve", "m_nDissolveType");
}
void GCEntityDissolve::SetDissolveType(uint64_t value) {
    SetSchemaValue(m_ptr, "CEntityDissolve", "m_nDissolveType", false, value);
}
Vector GCEntityDissolve::GetDissolverOrigin() const {
    return GetSchemaValue<Vector>(m_ptr, "CEntityDissolve", "m_vDissolverOrigin");
}
void GCEntityDissolve::SetDissolverOrigin(Vector value) {
    SetSchemaValue(m_ptr, "CEntityDissolve", "m_vDissolverOrigin", false, value);
}
uint32_t GCEntityDissolve::GetMagnitude() const {
    return GetSchemaValue<uint32_t>(m_ptr, "CEntityDissolve", "m_nMagnitude");
}
void GCEntityDissolve::SetMagnitude(uint32_t value) {
    SetSchemaValue(m_ptr, "CEntityDissolve", "m_nMagnitude", false, value);
}
std::string GCEntityDissolve::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCEntityDissolve::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseModelEntity GCEntityDissolve::GetParent() const {
    GCBaseModelEntity value(m_ptr);
    return value;
}
void GCEntityDissolve::SetParent(GCBaseModelEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCEntityDissolve(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCEntityDissolve>("CEntityDissolve")
        .addConstructor<void (*)(std::string)>()
        .addProperty("FadeInStart", &GCEntityDissolve::GetFadeInStart, &GCEntityDissolve::SetFadeInStart)
        .addProperty("FadeInLength", &GCEntityDissolve::GetFadeInLength, &GCEntityDissolve::SetFadeInLength)
        .addProperty("FadeOutModelStart", &GCEntityDissolve::GetFadeOutModelStart, &GCEntityDissolve::SetFadeOutModelStart)
        .addProperty("FadeOutModelLength", &GCEntityDissolve::GetFadeOutModelLength, &GCEntityDissolve::SetFadeOutModelLength)
        .addProperty("FadeOutStart", &GCEntityDissolve::GetFadeOutStart, &GCEntityDissolve::SetFadeOutStart)
        .addProperty("FadeOutLength", &GCEntityDissolve::GetFadeOutLength, &GCEntityDissolve::SetFadeOutLength)
        .addProperty("StartTime", &GCEntityDissolve::GetStartTime, &GCEntityDissolve::SetStartTime)
        .addProperty("DissolveType", &GCEntityDissolve::GetDissolveType, &GCEntityDissolve::SetDissolveType)
        .addProperty("DissolverOrigin", &GCEntityDissolve::GetDissolverOrigin, &GCEntityDissolve::SetDissolverOrigin)
        .addProperty("Magnitude", &GCEntityDissolve::GetMagnitude, &GCEntityDissolve::SetMagnitude)
        .addProperty("Parent", &GCEntityDissolve::GetParent, &GCEntityDissolve::SetParent)
        .addFunction("ToPtr", &GCEntityDissolve::ToPtr)
        .addFunction("IsValid", &GCEntityDissolve::IsValid)
        .endClass();
}
GCPointAngleSensor::GCPointAngleSensor(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCPointAngleSensor::GCPointAngleSensor(void *ptr) {
    m_ptr = ptr;
}
bool GCPointAngleSensor::GetDisabled() const {
    return GetSchemaValue<bool>(m_ptr, "CPointAngleSensor", "m_bDisabled");
}
void GCPointAngleSensor::SetDisabled(bool value) {
    SetSchemaValue(m_ptr, "CPointAngleSensor", "m_bDisabled", false, value);
}
std::string GCPointAngleSensor::GetLookAtName() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CPointAngleSensor", "m_nLookAtName").String();
}
void GCPointAngleSensor::SetLookAtName(std::string value) {
    SetSchemaValue(m_ptr, "CPointAngleSensor", "m_nLookAtName", false, CUtlSymbolLarge(value.c_str()));
}
GCBaseEntity GCPointAngleSensor::GetTargetEntity() const {
    GCBaseEntity value(*GetSchemaValuePtr<void*>(m_ptr, "CPointAngleSensor", "m_hTargetEntity"));
    return value;
}
void GCPointAngleSensor::SetTargetEntity(GCBaseEntity* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'TargetEntity' is not possible.\n");
}
GCBaseEntity GCPointAngleSensor::GetLookAtEntity() const {
    GCBaseEntity value(*GetSchemaValuePtr<void*>(m_ptr, "CPointAngleSensor", "m_hLookAtEntity"));
    return value;
}
void GCPointAngleSensor::SetLookAtEntity(GCBaseEntity* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'LookAtEntity' is not possible.\n");
}
float GCPointAngleSensor::GetDuration() const {
    return GetSchemaValue<float>(m_ptr, "CPointAngleSensor", "m_flDuration");
}
void GCPointAngleSensor::SetDuration(float value) {
    SetSchemaValue(m_ptr, "CPointAngleSensor", "m_flDuration", false, value);
}
float GCPointAngleSensor::GetDotTolerance() const {
    return GetSchemaValue<float>(m_ptr, "CPointAngleSensor", "m_flDotTolerance");
}
void GCPointAngleSensor::SetDotTolerance(float value) {
    SetSchemaValue(m_ptr, "CPointAngleSensor", "m_flDotTolerance", false, value);
}
float GCPointAngleSensor::GetFacingTime() const {
    return GetSchemaValue<float>(m_ptr, "CPointAngleSensor", "m_flFacingTime");
}
void GCPointAngleSensor::SetFacingTime(float value) {
    SetSchemaValue(m_ptr, "CPointAngleSensor", "m_flFacingTime", false, value);
}
bool GCPointAngleSensor::GetFired() const {
    return GetSchemaValue<bool>(m_ptr, "CPointAngleSensor", "m_bFired");
}
void GCPointAngleSensor::SetFired(bool value) {
    SetSchemaValue(m_ptr, "CPointAngleSensor", "m_bFired", false, value);
}
GCEntityIOOutput GCPointAngleSensor::GetOnFacingLookat() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CPointAngleSensor", "m_OnFacingLookat"));
    return value;
}
void GCPointAngleSensor::SetOnFacingLookat(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CPointAngleSensor", "m_OnFacingLookat", false, value);
}
GCEntityIOOutput GCPointAngleSensor::GetOnNotFacingLookat() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CPointAngleSensor", "m_OnNotFacingLookat"));
    return value;
}
void GCPointAngleSensor::SetOnNotFacingLookat(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CPointAngleSensor", "m_OnNotFacingLookat", false, value);
}
std::string GCPointAngleSensor::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCPointAngleSensor::IsValid() {
    return (m_ptr != nullptr);
}
GCPointEntity GCPointAngleSensor::GetParent() const {
    GCPointEntity value(m_ptr);
    return value;
}
void GCPointAngleSensor::SetParent(GCPointEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCPointAngleSensor(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCPointAngleSensor>("CPointAngleSensor")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Disabled", &GCPointAngleSensor::GetDisabled, &GCPointAngleSensor::SetDisabled)
        .addProperty("LookAtName", &GCPointAngleSensor::GetLookAtName, &GCPointAngleSensor::SetLookAtName)
        .addProperty("TargetEntity", &GCPointAngleSensor::GetTargetEntity, &GCPointAngleSensor::SetTargetEntity)
        .addProperty("LookAtEntity", &GCPointAngleSensor::GetLookAtEntity, &GCPointAngleSensor::SetLookAtEntity)
        .addProperty("Duration", &GCPointAngleSensor::GetDuration, &GCPointAngleSensor::SetDuration)
        .addProperty("DotTolerance", &GCPointAngleSensor::GetDotTolerance, &GCPointAngleSensor::SetDotTolerance)
        .addProperty("FacingTime", &GCPointAngleSensor::GetFacingTime, &GCPointAngleSensor::SetFacingTime)
        .addProperty("Fired", &GCPointAngleSensor::GetFired, &GCPointAngleSensor::SetFired)
        .addProperty("OnFacingLookat", &GCPointAngleSensor::GetOnFacingLookat, &GCPointAngleSensor::SetOnFacingLookat)
        .addProperty("OnNotFacingLookat", &GCPointAngleSensor::GetOnNotFacingLookat, &GCPointAngleSensor::SetOnNotFacingLookat)
        .addProperty("Parent", &GCPointAngleSensor::GetParent, &GCPointAngleSensor::SetParent)
        .addFunction("ToPtr", &GCPointAngleSensor::ToPtr)
        .addFunction("IsValid", &GCPointAngleSensor::IsValid)
        .endClass();
}
GCSoundEventOBBEntity::GCSoundEventOBBEntity(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCSoundEventOBBEntity::GCSoundEventOBBEntity(void *ptr) {
    m_ptr = ptr;
}
Vector GCSoundEventOBBEntity::GetMins() const {
    return GetSchemaValue<Vector>(m_ptr, "CSoundEventOBBEntity", "m_vMins");
}
void GCSoundEventOBBEntity::SetMins(Vector value) {
    SetSchemaValue(m_ptr, "CSoundEventOBBEntity", "m_vMins", false, value);
}
Vector GCSoundEventOBBEntity::GetMaxs() const {
    return GetSchemaValue<Vector>(m_ptr, "CSoundEventOBBEntity", "m_vMaxs");
}
void GCSoundEventOBBEntity::SetMaxs(Vector value) {
    SetSchemaValue(m_ptr, "CSoundEventOBBEntity", "m_vMaxs", false, value);
}
std::string GCSoundEventOBBEntity::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCSoundEventOBBEntity::IsValid() {
    return (m_ptr != nullptr);
}
GCSoundEventEntity GCSoundEventOBBEntity::GetParent() const {
    GCSoundEventEntity value(m_ptr);
    return value;
}
void GCSoundEventOBBEntity::SetParent(GCSoundEventEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCSoundEventOBBEntity(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCSoundEventOBBEntity>("CSoundEventOBBEntity")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Mins", &GCSoundEventOBBEntity::GetMins, &GCSoundEventOBBEntity::SetMins)
        .addProperty("Maxs", &GCSoundEventOBBEntity::GetMaxs, &GCSoundEventOBBEntity::SetMaxs)
        .addProperty("Parent", &GCSoundEventOBBEntity::GetParent, &GCSoundEventOBBEntity::SetParent)
        .addFunction("ToPtr", &GCSoundEventOBBEntity::ToPtr)
        .addFunction("IsValid", &GCSoundEventOBBEntity::IsValid)
        .endClass();
}
GCBtNodeCondition::GCBtNodeCondition(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCBtNodeCondition::GCBtNodeCondition(void *ptr) {
    m_ptr = ptr;
}
bool GCBtNodeCondition::GetNegated() const {
    return GetSchemaValue<bool>(m_ptr, "CBtNodeCondition", "m_bNegated");
}
void GCBtNodeCondition::SetNegated(bool value) {
    SetSchemaValue(m_ptr, "CBtNodeCondition", "m_bNegated", false, value);
}
std::string GCBtNodeCondition::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCBtNodeCondition::IsValid() {
    return (m_ptr != nullptr);
}
GCBtNodeDecorator GCBtNodeCondition::GetParent() const {
    GCBtNodeDecorator value(m_ptr);
    return value;
}
void GCBtNodeCondition::SetParent(GCBtNodeDecorator value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCBtNodeCondition(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCBtNodeCondition>("CBtNodeCondition")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Negated", &GCBtNodeCondition::GetNegated, &GCBtNodeCondition::SetNegated)
        .addProperty("Parent", &GCBtNodeCondition::GetParent, &GCBtNodeCondition::SetParent)
        .addFunction("ToPtr", &GCBtNodeCondition::ToPtr)
        .addFunction("IsValid", &GCBtNodeCondition::IsValid)
        .endClass();
}
GCSharedGapTypeQueryRegistration::GCSharedGapTypeQueryRegistration(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCSharedGapTypeQueryRegistration::GCSharedGapTypeQueryRegistration(void *ptr) {
    m_ptr = ptr;
}
std::string GCSharedGapTypeQueryRegistration::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCSharedGapTypeQueryRegistration::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCSharedGapTypeQueryRegistration(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCSharedGapTypeQueryRegistration>("CSharedGapTypeQueryRegistration")
        .addConstructor<void (*)(std::string)>()
        .addFunction("ToPtr", &GCSharedGapTypeQueryRegistration::ToPtr)
        .addFunction("IsValid", &GCSharedGapTypeQueryRegistration::IsValid)
        .endClass();
}
GCEnvVolumetricFogVolume::GCEnvVolumetricFogVolume(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCEnvVolumetricFogVolume::GCEnvVolumetricFogVolume(void *ptr) {
    m_ptr = ptr;
}
bool GCEnvVolumetricFogVolume::GetActive() const {
    return GetSchemaValue<bool>(m_ptr, "CEnvVolumetricFogVolume", "m_bActive");
}
void GCEnvVolumetricFogVolume::SetActive(bool value) {
    SetSchemaValue(m_ptr, "CEnvVolumetricFogVolume", "m_bActive", false, value);
}
Vector GCEnvVolumetricFogVolume::GetBoxMins() const {
    return GetSchemaValue<Vector>(m_ptr, "CEnvVolumetricFogVolume", "m_vBoxMins");
}
void GCEnvVolumetricFogVolume::SetBoxMins(Vector value) {
    SetSchemaValue(m_ptr, "CEnvVolumetricFogVolume", "m_vBoxMins", false, value);
}
Vector GCEnvVolumetricFogVolume::GetBoxMaxs() const {
    return GetSchemaValue<Vector>(m_ptr, "CEnvVolumetricFogVolume", "m_vBoxMaxs");
}
void GCEnvVolumetricFogVolume::SetBoxMaxs(Vector value) {
    SetSchemaValue(m_ptr, "CEnvVolumetricFogVolume", "m_vBoxMaxs", false, value);
}
bool GCEnvVolumetricFogVolume::GetStartDisabled() const {
    return GetSchemaValue<bool>(m_ptr, "CEnvVolumetricFogVolume", "m_bStartDisabled");
}
void GCEnvVolumetricFogVolume::SetStartDisabled(bool value) {
    SetSchemaValue(m_ptr, "CEnvVolumetricFogVolume", "m_bStartDisabled", false, value);
}
float GCEnvVolumetricFogVolume::GetStrength() const {
    return GetSchemaValue<float>(m_ptr, "CEnvVolumetricFogVolume", "m_flStrength");
}
void GCEnvVolumetricFogVolume::SetStrength(float value) {
    SetSchemaValue(m_ptr, "CEnvVolumetricFogVolume", "m_flStrength", false, value);
}
int32_t GCEnvVolumetricFogVolume::GetFalloffShape() const {
    return GetSchemaValue<int32_t>(m_ptr, "CEnvVolumetricFogVolume", "m_nFalloffShape");
}
void GCEnvVolumetricFogVolume::SetFalloffShape(int32_t value) {
    SetSchemaValue(m_ptr, "CEnvVolumetricFogVolume", "m_nFalloffShape", false, value);
}
float GCEnvVolumetricFogVolume::GetFalloffExponent() const {
    return GetSchemaValue<float>(m_ptr, "CEnvVolumetricFogVolume", "m_flFalloffExponent");
}
void GCEnvVolumetricFogVolume::SetFalloffExponent(float value) {
    SetSchemaValue(m_ptr, "CEnvVolumetricFogVolume", "m_flFalloffExponent", false, value);
}
float GCEnvVolumetricFogVolume::GetHeightFogDepth() const {
    return GetSchemaValue<float>(m_ptr, "CEnvVolumetricFogVolume", "m_flHeightFogDepth");
}
void GCEnvVolumetricFogVolume::SetHeightFogDepth(float value) {
    SetSchemaValue(m_ptr, "CEnvVolumetricFogVolume", "m_flHeightFogDepth", false, value);
}
float GCEnvVolumetricFogVolume::GetHeightFogEdgeWidth() const {
    return GetSchemaValue<float>(m_ptr, "CEnvVolumetricFogVolume", "m_fHeightFogEdgeWidth");
}
void GCEnvVolumetricFogVolume::SetHeightFogEdgeWidth(float value) {
    SetSchemaValue(m_ptr, "CEnvVolumetricFogVolume", "m_fHeightFogEdgeWidth", false, value);
}
float GCEnvVolumetricFogVolume::GetIndirectLightStrength() const {
    return GetSchemaValue<float>(m_ptr, "CEnvVolumetricFogVolume", "m_fIndirectLightStrength");
}
void GCEnvVolumetricFogVolume::SetIndirectLightStrength(float value) {
    SetSchemaValue(m_ptr, "CEnvVolumetricFogVolume", "m_fIndirectLightStrength", false, value);
}
float GCEnvVolumetricFogVolume::GetSunLightStrength() const {
    return GetSchemaValue<float>(m_ptr, "CEnvVolumetricFogVolume", "m_fSunLightStrength");
}
void GCEnvVolumetricFogVolume::SetSunLightStrength(float value) {
    SetSchemaValue(m_ptr, "CEnvVolumetricFogVolume", "m_fSunLightStrength", false, value);
}
float GCEnvVolumetricFogVolume::GetNoiseStrength() const {
    return GetSchemaValue<float>(m_ptr, "CEnvVolumetricFogVolume", "m_fNoiseStrength");
}
void GCEnvVolumetricFogVolume::SetNoiseStrength(float value) {
    SetSchemaValue(m_ptr, "CEnvVolumetricFogVolume", "m_fNoiseStrength", false, value);
}
bool GCEnvVolumetricFogVolume::GetOverrideIndirectLightStrength() const {
    return GetSchemaValue<bool>(m_ptr, "CEnvVolumetricFogVolume", "m_bOverrideIndirectLightStrength");
}
void GCEnvVolumetricFogVolume::SetOverrideIndirectLightStrength(bool value) {
    SetSchemaValue(m_ptr, "CEnvVolumetricFogVolume", "m_bOverrideIndirectLightStrength", false, value);
}
bool GCEnvVolumetricFogVolume::GetOverrideSunLightStrength() const {
    return GetSchemaValue<bool>(m_ptr, "CEnvVolumetricFogVolume", "m_bOverrideSunLightStrength");
}
void GCEnvVolumetricFogVolume::SetOverrideSunLightStrength(bool value) {
    SetSchemaValue(m_ptr, "CEnvVolumetricFogVolume", "m_bOverrideSunLightStrength", false, value);
}
bool GCEnvVolumetricFogVolume::GetOverrideNoiseStrength() const {
    return GetSchemaValue<bool>(m_ptr, "CEnvVolumetricFogVolume", "m_bOverrideNoiseStrength");
}
void GCEnvVolumetricFogVolume::SetOverrideNoiseStrength(bool value) {
    SetSchemaValue(m_ptr, "CEnvVolumetricFogVolume", "m_bOverrideNoiseStrength", false, value);
}
std::string GCEnvVolumetricFogVolume::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCEnvVolumetricFogVolume::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseEntity GCEnvVolumetricFogVolume::GetParent() const {
    GCBaseEntity value(m_ptr);
    return value;
}
void GCEnvVolumetricFogVolume::SetParent(GCBaseEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCEnvVolumetricFogVolume(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCEnvVolumetricFogVolume>("CEnvVolumetricFogVolume")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Active", &GCEnvVolumetricFogVolume::GetActive, &GCEnvVolumetricFogVolume::SetActive)
        .addProperty("BoxMins", &GCEnvVolumetricFogVolume::GetBoxMins, &GCEnvVolumetricFogVolume::SetBoxMins)
        .addProperty("BoxMaxs", &GCEnvVolumetricFogVolume::GetBoxMaxs, &GCEnvVolumetricFogVolume::SetBoxMaxs)
        .addProperty("StartDisabled", &GCEnvVolumetricFogVolume::GetStartDisabled, &GCEnvVolumetricFogVolume::SetStartDisabled)
        .addProperty("Strength", &GCEnvVolumetricFogVolume::GetStrength, &GCEnvVolumetricFogVolume::SetStrength)
        .addProperty("FalloffShape", &GCEnvVolumetricFogVolume::GetFalloffShape, &GCEnvVolumetricFogVolume::SetFalloffShape)
        .addProperty("FalloffExponent", &GCEnvVolumetricFogVolume::GetFalloffExponent, &GCEnvVolumetricFogVolume::SetFalloffExponent)
        .addProperty("HeightFogDepth", &GCEnvVolumetricFogVolume::GetHeightFogDepth, &GCEnvVolumetricFogVolume::SetHeightFogDepth)
        .addProperty("HeightFogEdgeWidth", &GCEnvVolumetricFogVolume::GetHeightFogEdgeWidth, &GCEnvVolumetricFogVolume::SetHeightFogEdgeWidth)
        .addProperty("IndirectLightStrength", &GCEnvVolumetricFogVolume::GetIndirectLightStrength, &GCEnvVolumetricFogVolume::SetIndirectLightStrength)
        .addProperty("SunLightStrength", &GCEnvVolumetricFogVolume::GetSunLightStrength, &GCEnvVolumetricFogVolume::SetSunLightStrength)
        .addProperty("NoiseStrength", &GCEnvVolumetricFogVolume::GetNoiseStrength, &GCEnvVolumetricFogVolume::SetNoiseStrength)
        .addProperty("OverrideIndirectLightStrength", &GCEnvVolumetricFogVolume::GetOverrideIndirectLightStrength, &GCEnvVolumetricFogVolume::SetOverrideIndirectLightStrength)
        .addProperty("OverrideSunLightStrength", &GCEnvVolumetricFogVolume::GetOverrideSunLightStrength, &GCEnvVolumetricFogVolume::SetOverrideSunLightStrength)
        .addProperty("OverrideNoiseStrength", &GCEnvVolumetricFogVolume::GetOverrideNoiseStrength, &GCEnvVolumetricFogVolume::SetOverrideNoiseStrength)
        .addProperty("Parent", &GCEnvVolumetricFogVolume::GetParent, &GCEnvVolumetricFogVolume::SetParent)
        .addFunction("ToPtr", &GCEnvVolumetricFogVolume::ToPtr)
        .addFunction("IsValid", &GCEnvVolumetricFogVolume::IsValid)
        .endClass();
}
GCEnvBeam::GCEnvBeam(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCEnvBeam::GCEnvBeam(void *ptr) {
    m_ptr = ptr;
}
int32_t GCEnvBeam::GetActive() const {
    return GetSchemaValue<int32_t>(m_ptr, "CEnvBeam", "m_active");
}
void GCEnvBeam::SetActive(int32_t value) {
    SetSchemaValue(m_ptr, "CEnvBeam", "m_active", false, value);
}
std::string GCEnvBeam::GetStartEntity() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CEnvBeam", "m_iszStartEntity").String();
}
void GCEnvBeam::SetStartEntity(std::string value) {
    SetSchemaValue(m_ptr, "CEnvBeam", "m_iszStartEntity", false, CUtlSymbolLarge(value.c_str()));
}
std::string GCEnvBeam::GetEndEntity() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CEnvBeam", "m_iszEndEntity").String();
}
void GCEnvBeam::SetEndEntity(std::string value) {
    SetSchemaValue(m_ptr, "CEnvBeam", "m_iszEndEntity", false, CUtlSymbolLarge(value.c_str()));
}
float GCEnvBeam::GetLife() const {
    return GetSchemaValue<float>(m_ptr, "CEnvBeam", "m_life");
}
void GCEnvBeam::SetLife(float value) {
    SetSchemaValue(m_ptr, "CEnvBeam", "m_life", false, value);
}
float GCEnvBeam::GetBoltWidth() const {
    return GetSchemaValue<float>(m_ptr, "CEnvBeam", "m_boltWidth");
}
void GCEnvBeam::SetBoltWidth(float value) {
    SetSchemaValue(m_ptr, "CEnvBeam", "m_boltWidth", false, value);
}
float GCEnvBeam::GetNoiseAmplitude() const {
    return GetSchemaValue<float>(m_ptr, "CEnvBeam", "m_noiseAmplitude");
}
void GCEnvBeam::SetNoiseAmplitude(float value) {
    SetSchemaValue(m_ptr, "CEnvBeam", "m_noiseAmplitude", false, value);
}
int32_t GCEnvBeam::GetSpeed() const {
    return GetSchemaValue<int32_t>(m_ptr, "CEnvBeam", "m_speed");
}
void GCEnvBeam::SetSpeed(int32_t value) {
    SetSchemaValue(m_ptr, "CEnvBeam", "m_speed", false, value);
}
float GCEnvBeam::GetRestrike() const {
    return GetSchemaValue<float>(m_ptr, "CEnvBeam", "m_restrike");
}
void GCEnvBeam::SetRestrike(float value) {
    SetSchemaValue(m_ptr, "CEnvBeam", "m_restrike", false, value);
}
std::string GCEnvBeam::GetSpriteName() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CEnvBeam", "m_iszSpriteName").String();
}
void GCEnvBeam::SetSpriteName(std::string value) {
    SetSchemaValue(m_ptr, "CEnvBeam", "m_iszSpriteName", false, CUtlSymbolLarge(value.c_str()));
}
int32_t GCEnvBeam::GetFrameStart() const {
    return GetSchemaValue<int32_t>(m_ptr, "CEnvBeam", "m_frameStart");
}
void GCEnvBeam::SetFrameStart(int32_t value) {
    SetSchemaValue(m_ptr, "CEnvBeam", "m_frameStart", false, value);
}
Vector GCEnvBeam::GetEndPointWorld() const {
    return GetSchemaValue<Vector>(m_ptr, "CEnvBeam", "m_vEndPointWorld");
}
void GCEnvBeam::SetEndPointWorld(Vector value) {
    SetSchemaValue(m_ptr, "CEnvBeam", "m_vEndPointWorld", false, value);
}
Vector GCEnvBeam::GetEndPointRelative() const {
    return GetSchemaValue<Vector>(m_ptr, "CEnvBeam", "m_vEndPointRelative");
}
void GCEnvBeam::SetEndPointRelative(Vector value) {
    SetSchemaValue(m_ptr, "CEnvBeam", "m_vEndPointRelative", false, value);
}
float GCEnvBeam::GetRadius() const {
    return GetSchemaValue<float>(m_ptr, "CEnvBeam", "m_radius");
}
void GCEnvBeam::SetRadius(float value) {
    SetSchemaValue(m_ptr, "CEnvBeam", "m_radius", false, value);
}
uint64_t GCEnvBeam::GetTouchType() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CEnvBeam", "m_TouchType");
}
void GCEnvBeam::SetTouchType(uint64_t value) {
    SetSchemaValue(m_ptr, "CEnvBeam", "m_TouchType", false, value);
}
std::string GCEnvBeam::GetFilterName() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CEnvBeam", "m_iFilterName").String();
}
void GCEnvBeam::SetFilterName(std::string value) {
    SetSchemaValue(m_ptr, "CEnvBeam", "m_iFilterName", false, CUtlSymbolLarge(value.c_str()));
}
GCBaseEntity GCEnvBeam::GetFilter() const {
    GCBaseEntity value(*GetSchemaValuePtr<void*>(m_ptr, "CEnvBeam", "m_hFilter"));
    return value;
}
void GCEnvBeam::SetFilter(GCBaseEntity* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Filter' is not possible.\n");
}
std::string GCEnvBeam::GetDecal() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CEnvBeam", "m_iszDecal").String();
}
void GCEnvBeam::SetDecal(std::string value) {
    SetSchemaValue(m_ptr, "CEnvBeam", "m_iszDecal", false, CUtlSymbolLarge(value.c_str()));
}
GCEntityIOOutput GCEnvBeam::GetOnTouchedByEntity() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CEnvBeam", "m_OnTouchedByEntity"));
    return value;
}
void GCEnvBeam::SetOnTouchedByEntity(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CEnvBeam", "m_OnTouchedByEntity", false, value);
}
std::string GCEnvBeam::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCEnvBeam::IsValid() {
    return (m_ptr != nullptr);
}
GCBeam GCEnvBeam::GetParent() const {
    GCBeam value(m_ptr);
    return value;
}
void GCEnvBeam::SetParent(GCBeam value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCEnvBeam(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCEnvBeam>("CEnvBeam")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Active", &GCEnvBeam::GetActive, &GCEnvBeam::SetActive)
        .addProperty("StartEntity", &GCEnvBeam::GetStartEntity, &GCEnvBeam::SetStartEntity)
        .addProperty("EndEntity", &GCEnvBeam::GetEndEntity, &GCEnvBeam::SetEndEntity)
        .addProperty("Life", &GCEnvBeam::GetLife, &GCEnvBeam::SetLife)
        .addProperty("BoltWidth", &GCEnvBeam::GetBoltWidth, &GCEnvBeam::SetBoltWidth)
        .addProperty("NoiseAmplitude", &GCEnvBeam::GetNoiseAmplitude, &GCEnvBeam::SetNoiseAmplitude)
        .addProperty("Speed", &GCEnvBeam::GetSpeed, &GCEnvBeam::SetSpeed)
        .addProperty("Restrike", &GCEnvBeam::GetRestrike, &GCEnvBeam::SetRestrike)
        .addProperty("SpriteName", &GCEnvBeam::GetSpriteName, &GCEnvBeam::SetSpriteName)
        .addProperty("FrameStart", &GCEnvBeam::GetFrameStart, &GCEnvBeam::SetFrameStart)
        .addProperty("EndPointWorld", &GCEnvBeam::GetEndPointWorld, &GCEnvBeam::SetEndPointWorld)
        .addProperty("EndPointRelative", &GCEnvBeam::GetEndPointRelative, &GCEnvBeam::SetEndPointRelative)
        .addProperty("Radius", &GCEnvBeam::GetRadius, &GCEnvBeam::SetRadius)
        .addProperty("TouchType", &GCEnvBeam::GetTouchType, &GCEnvBeam::SetTouchType)
        .addProperty("FilterName", &GCEnvBeam::GetFilterName, &GCEnvBeam::SetFilterName)
        .addProperty("Filter", &GCEnvBeam::GetFilter, &GCEnvBeam::SetFilter)
        .addProperty("Decal", &GCEnvBeam::GetDecal, &GCEnvBeam::SetDecal)
        .addProperty("OnTouchedByEntity", &GCEnvBeam::GetOnTouchedByEntity, &GCEnvBeam::SetOnTouchedByEntity)
        .addProperty("Parent", &GCEnvBeam::GetParent, &GCEnvBeam::SetParent)
        .addFunction("ToPtr", &GCEnvBeam::ToPtr)
        .addFunction("IsValid", &GCEnvBeam::IsValid)
        .endClass();
}
GCFuncIllusionary::GCFuncIllusionary(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCFuncIllusionary::GCFuncIllusionary(void *ptr) {
    m_ptr = ptr;
}
std::string GCFuncIllusionary::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCFuncIllusionary::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseModelEntity GCFuncIllusionary::GetParent() const {
    GCBaseModelEntity value(m_ptr);
    return value;
}
void GCFuncIllusionary::SetParent(GCBaseModelEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCFuncIllusionary(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCFuncIllusionary>("CFuncIllusionary")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCFuncIllusionary::GetParent, &GCFuncIllusionary::SetParent)
        .addFunction("ToPtr", &GCFuncIllusionary::ToPtr)
        .addFunction("IsValid", &GCFuncIllusionary::IsValid)
        .endClass();
}
GCPhysMagnet::GCPhysMagnet(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCPhysMagnet::GCPhysMagnet(void *ptr) {
    m_ptr = ptr;
}
GCEntityIOOutput GCPhysMagnet::GetOnMagnetAttach() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CPhysMagnet", "m_OnMagnetAttach"));
    return value;
}
void GCPhysMagnet::SetOnMagnetAttach(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CPhysMagnet", "m_OnMagnetAttach", false, value);
}
GCEntityIOOutput GCPhysMagnet::GetOnMagnetDetach() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CPhysMagnet", "m_OnMagnetDetach"));
    return value;
}
void GCPhysMagnet::SetOnMagnetDetach(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CPhysMagnet", "m_OnMagnetDetach", false, value);
}
float GCPhysMagnet::GetMassScale() const {
    return GetSchemaValue<float>(m_ptr, "CPhysMagnet", "m_massScale");
}
void GCPhysMagnet::SetMassScale(float value) {
    SetSchemaValue(m_ptr, "CPhysMagnet", "m_massScale", false, value);
}
float GCPhysMagnet::GetForceLimit() const {
    return GetSchemaValue<float>(m_ptr, "CPhysMagnet", "m_forceLimit");
}
void GCPhysMagnet::SetForceLimit(float value) {
    SetSchemaValue(m_ptr, "CPhysMagnet", "m_forceLimit", false, value);
}
float GCPhysMagnet::GetTorqueLimit() const {
    return GetSchemaValue<float>(m_ptr, "CPhysMagnet", "m_torqueLimit");
}
void GCPhysMagnet::SetTorqueLimit(float value) {
    SetSchemaValue(m_ptr, "CPhysMagnet", "m_torqueLimit", false, value);
}
std::vector<Gmagnetted_objects_t> GCPhysMagnet::GetMagnettedEntities() const {
    CUtlVector<Gmagnetted_objects_t>* vec = GetSchemaValue<CUtlVector<Gmagnetted_objects_t>*>(m_ptr, "CPhysMagnet", "m_MagnettedEntities"); std::vector<Gmagnetted_objects_t> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCPhysMagnet::SetMagnettedEntities(std::vector<Gmagnetted_objects_t> value) {
    SetSchemaValueCUtlVector<Gmagnetted_objects_t>(m_ptr, "CPhysMagnet", "m_MagnettedEntities", false, value);
}
bool GCPhysMagnet::GetActive() const {
    return GetSchemaValue<bool>(m_ptr, "CPhysMagnet", "m_bActive");
}
void GCPhysMagnet::SetActive(bool value) {
    SetSchemaValue(m_ptr, "CPhysMagnet", "m_bActive", false, value);
}
bool GCPhysMagnet::GetHasHitSomething() const {
    return GetSchemaValue<bool>(m_ptr, "CPhysMagnet", "m_bHasHitSomething");
}
void GCPhysMagnet::SetHasHitSomething(bool value) {
    SetSchemaValue(m_ptr, "CPhysMagnet", "m_bHasHitSomething", false, value);
}
float GCPhysMagnet::GetTotalMass() const {
    return GetSchemaValue<float>(m_ptr, "CPhysMagnet", "m_flTotalMass");
}
void GCPhysMagnet::SetTotalMass(float value) {
    SetSchemaValue(m_ptr, "CPhysMagnet", "m_flTotalMass", false, value);
}
float GCPhysMagnet::GetRadius() const {
    return GetSchemaValue<float>(m_ptr, "CPhysMagnet", "m_flRadius");
}
void GCPhysMagnet::SetRadius(float value) {
    SetSchemaValue(m_ptr, "CPhysMagnet", "m_flRadius", false, value);
}
float GCPhysMagnet::GetNextSuckTime() const {
    return GetSchemaValue<float>(m_ptr, "CPhysMagnet", "m_flNextSuckTime");
}
void GCPhysMagnet::SetNextSuckTime(float value) {
    SetSchemaValue(m_ptr, "CPhysMagnet", "m_flNextSuckTime", false, value);
}
int32_t GCPhysMagnet::GetMaxObjectsAttached() const {
    return GetSchemaValue<int32_t>(m_ptr, "CPhysMagnet", "m_iMaxObjectsAttached");
}
void GCPhysMagnet::SetMaxObjectsAttached(int32_t value) {
    SetSchemaValue(m_ptr, "CPhysMagnet", "m_iMaxObjectsAttached", false, value);
}
std::string GCPhysMagnet::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCPhysMagnet::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseAnimGraph GCPhysMagnet::GetParent() const {
    GCBaseAnimGraph value(m_ptr);
    return value;
}
void GCPhysMagnet::SetParent(GCBaseAnimGraph value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCPhysMagnet(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCPhysMagnet>("CPhysMagnet")
        .addConstructor<void (*)(std::string)>()
        .addProperty("OnMagnetAttach", &GCPhysMagnet::GetOnMagnetAttach, &GCPhysMagnet::SetOnMagnetAttach)
        .addProperty("OnMagnetDetach", &GCPhysMagnet::GetOnMagnetDetach, &GCPhysMagnet::SetOnMagnetDetach)
        .addProperty("MassScale", &GCPhysMagnet::GetMassScale, &GCPhysMagnet::SetMassScale)
        .addProperty("ForceLimit", &GCPhysMagnet::GetForceLimit, &GCPhysMagnet::SetForceLimit)
        .addProperty("TorqueLimit", &GCPhysMagnet::GetTorqueLimit, &GCPhysMagnet::SetTorqueLimit)
        .addProperty("MagnettedEntities", &GCPhysMagnet::GetMagnettedEntities, &GCPhysMagnet::SetMagnettedEntities)
        .addProperty("Active", &GCPhysMagnet::GetActive, &GCPhysMagnet::SetActive)
        .addProperty("HasHitSomething", &GCPhysMagnet::GetHasHitSomething, &GCPhysMagnet::SetHasHitSomething)
        .addProperty("TotalMass", &GCPhysMagnet::GetTotalMass, &GCPhysMagnet::SetTotalMass)
        .addProperty("Radius", &GCPhysMagnet::GetRadius, &GCPhysMagnet::SetRadius)
        .addProperty("NextSuckTime", &GCPhysMagnet::GetNextSuckTime, &GCPhysMagnet::SetNextSuckTime)
        .addProperty("MaxObjectsAttached", &GCPhysMagnet::GetMaxObjectsAttached, &GCPhysMagnet::SetMaxObjectsAttached)
        .addProperty("Parent", &GCPhysMagnet::GetParent, &GCPhysMagnet::SetParent)
        .addFunction("ToPtr", &GCPhysMagnet::ToPtr)
        .addFunction("IsValid", &GCPhysMagnet::IsValid)
        .endClass();
}
GCSceneEntityAlias_logic_choreographed_scene::GCSceneEntityAlias_logic_choreographed_scene(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCSceneEntityAlias_logic_choreographed_scene::GCSceneEntityAlias_logic_choreographed_scene(void *ptr) {
    m_ptr = ptr;
}
std::string GCSceneEntityAlias_logic_choreographed_scene::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCSceneEntityAlias_logic_choreographed_scene::IsValid() {
    return (m_ptr != nullptr);
}
GCSceneEntity GCSceneEntityAlias_logic_choreographed_scene::GetParent() const {
    GCSceneEntity value(m_ptr);
    return value;
}
void GCSceneEntityAlias_logic_choreographed_scene::SetParent(GCSceneEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCSceneEntityAlias_logic_choreographed_scene(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCSceneEntityAlias_logic_choreographed_scene>("CSceneEntityAlias_logic_choreographed_scene")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCSceneEntityAlias_logic_choreographed_scene::GetParent, &GCSceneEntityAlias_logic_choreographed_scene::SetParent)
        .addFunction("ToPtr", &GCSceneEntityAlias_logic_choreographed_scene::ToPtr)
        .addFunction("IsValid", &GCSceneEntityAlias_logic_choreographed_scene::IsValid)
        .endClass();
}
GCFuncNavBlocker::GCFuncNavBlocker(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCFuncNavBlocker::GCFuncNavBlocker(void *ptr) {
    m_ptr = ptr;
}
bool GCFuncNavBlocker::GetDisabled() const {
    return GetSchemaValue<bool>(m_ptr, "CFuncNavBlocker", "m_bDisabled");
}
void GCFuncNavBlocker::SetDisabled(bool value) {
    SetSchemaValue(m_ptr, "CFuncNavBlocker", "m_bDisabled", false, value);
}
int32_t GCFuncNavBlocker::GetBlockedTeamNumber() const {
    return GetSchemaValue<int32_t>(m_ptr, "CFuncNavBlocker", "m_nBlockedTeamNumber");
}
void GCFuncNavBlocker::SetBlockedTeamNumber(int32_t value) {
    SetSchemaValue(m_ptr, "CFuncNavBlocker", "m_nBlockedTeamNumber", false, value);
}
std::string GCFuncNavBlocker::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCFuncNavBlocker::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseModelEntity GCFuncNavBlocker::GetParent() const {
    GCBaseModelEntity value(m_ptr);
    return value;
}
void GCFuncNavBlocker::SetParent(GCBaseModelEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCFuncNavBlocker(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCFuncNavBlocker>("CFuncNavBlocker")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Disabled", &GCFuncNavBlocker::GetDisabled, &GCFuncNavBlocker::SetDisabled)
        .addProperty("BlockedTeamNumber", &GCFuncNavBlocker::GetBlockedTeamNumber, &GCFuncNavBlocker::SetBlockedTeamNumber)
        .addProperty("Parent", &GCFuncNavBlocker::GetParent, &GCFuncNavBlocker::SetParent)
        .addFunction("ToPtr", &GCFuncNavBlocker::ToPtr)
        .addFunction("IsValid", &GCFuncNavBlocker::IsValid)
        .endClass();
}
GCRagdollMagnet::GCRagdollMagnet(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCRagdollMagnet::GCRagdollMagnet(void *ptr) {
    m_ptr = ptr;
}
bool GCRagdollMagnet::GetDisabled() const {
    return GetSchemaValue<bool>(m_ptr, "CRagdollMagnet", "m_bDisabled");
}
void GCRagdollMagnet::SetDisabled(bool value) {
    SetSchemaValue(m_ptr, "CRagdollMagnet", "m_bDisabled", false, value);
}
float GCRagdollMagnet::GetRadius() const {
    return GetSchemaValue<float>(m_ptr, "CRagdollMagnet", "m_radius");
}
void GCRagdollMagnet::SetRadius(float value) {
    SetSchemaValue(m_ptr, "CRagdollMagnet", "m_radius", false, value);
}
float GCRagdollMagnet::GetForce() const {
    return GetSchemaValue<float>(m_ptr, "CRagdollMagnet", "m_force");
}
void GCRagdollMagnet::SetForce(float value) {
    SetSchemaValue(m_ptr, "CRagdollMagnet", "m_force", false, value);
}
Vector GCRagdollMagnet::GetAxis() const {
    return GetSchemaValue<Vector>(m_ptr, "CRagdollMagnet", "m_axis");
}
void GCRagdollMagnet::SetAxis(Vector value) {
    SetSchemaValue(m_ptr, "CRagdollMagnet", "m_axis", false, value);
}
std::string GCRagdollMagnet::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCRagdollMagnet::IsValid() {
    return (m_ptr != nullptr);
}
GCPointEntity GCRagdollMagnet::GetParent() const {
    GCPointEntity value(m_ptr);
    return value;
}
void GCRagdollMagnet::SetParent(GCPointEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCRagdollMagnet(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCRagdollMagnet>("CRagdollMagnet")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Disabled", &GCRagdollMagnet::GetDisabled, &GCRagdollMagnet::SetDisabled)
        .addProperty("Radius", &GCRagdollMagnet::GetRadius, &GCRagdollMagnet::SetRadius)
        .addProperty("Force", &GCRagdollMagnet::GetForce, &GCRagdollMagnet::SetForce)
        .addProperty("Axis", &GCRagdollMagnet::GetAxis, &GCRagdollMagnet::SetAxis)
        .addProperty("Parent", &GCRagdollMagnet::GetParent, &GCRagdollMagnet::SetParent)
        .addFunction("ToPtr", &GCRagdollMagnet::ToPtr)
        .addFunction("IsValid", &GCRagdollMagnet::IsValid)
        .endClass();
}
GCFuncElectrifiedVolume::GCFuncElectrifiedVolume(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCFuncElectrifiedVolume::GCFuncElectrifiedVolume(void *ptr) {
    m_ptr = ptr;
}
std::string GCFuncElectrifiedVolume::GetEffectName() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CFuncElectrifiedVolume", "m_EffectName").String();
}
void GCFuncElectrifiedVolume::SetEffectName(std::string value) {
    SetSchemaValue(m_ptr, "CFuncElectrifiedVolume", "m_EffectName", false, CUtlSymbolLarge(value.c_str()));
}
std::string GCFuncElectrifiedVolume::GetEffectInterpenetrateName() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CFuncElectrifiedVolume", "m_EffectInterpenetrateName").String();
}
void GCFuncElectrifiedVolume::SetEffectInterpenetrateName(std::string value) {
    SetSchemaValue(m_ptr, "CFuncElectrifiedVolume", "m_EffectInterpenetrateName", false, CUtlSymbolLarge(value.c_str()));
}
std::string GCFuncElectrifiedVolume::GetEffectZapName() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CFuncElectrifiedVolume", "m_EffectZapName").String();
}
void GCFuncElectrifiedVolume::SetEffectZapName(std::string value) {
    SetSchemaValue(m_ptr, "CFuncElectrifiedVolume", "m_EffectZapName", false, CUtlSymbolLarge(value.c_str()));
}
std::string GCFuncElectrifiedVolume::GetEffectSource() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CFuncElectrifiedVolume", "m_iszEffectSource").String();
}
void GCFuncElectrifiedVolume::SetEffectSource(std::string value) {
    SetSchemaValue(m_ptr, "CFuncElectrifiedVolume", "m_iszEffectSource", false, CUtlSymbolLarge(value.c_str()));
}
std::string GCFuncElectrifiedVolume::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCFuncElectrifiedVolume::IsValid() {
    return (m_ptr != nullptr);
}
GCFuncBrush GCFuncElectrifiedVolume::GetParent() const {
    GCFuncBrush value(m_ptr);
    return value;
}
void GCFuncElectrifiedVolume::SetParent(GCFuncBrush value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCFuncElectrifiedVolume(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCFuncElectrifiedVolume>("CFuncElectrifiedVolume")
        .addConstructor<void (*)(std::string)>()
        .addProperty("EffectName", &GCFuncElectrifiedVolume::GetEffectName, &GCFuncElectrifiedVolume::SetEffectName)
        .addProperty("EffectInterpenetrateName", &GCFuncElectrifiedVolume::GetEffectInterpenetrateName, &GCFuncElectrifiedVolume::SetEffectInterpenetrateName)
        .addProperty("EffectZapName", &GCFuncElectrifiedVolume::GetEffectZapName, &GCFuncElectrifiedVolume::SetEffectZapName)
        .addProperty("EffectSource", &GCFuncElectrifiedVolume::GetEffectSource, &GCFuncElectrifiedVolume::SetEffectSource)
        .addProperty("Parent", &GCFuncElectrifiedVolume::GetParent, &GCFuncElectrifiedVolume::SetParent)
        .addFunction("ToPtr", &GCFuncElectrifiedVolume::ToPtr)
        .addFunction("IsValid", &GCFuncElectrifiedVolume::IsValid)
        .endClass();
}
GCPointProximitySensor::GCPointProximitySensor(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCPointProximitySensor::GCPointProximitySensor(void *ptr) {
    m_ptr = ptr;
}
bool GCPointProximitySensor::GetDisabled() const {
    return GetSchemaValue<bool>(m_ptr, "CPointProximitySensor", "m_bDisabled");
}
void GCPointProximitySensor::SetDisabled(bool value) {
    SetSchemaValue(m_ptr, "CPointProximitySensor", "m_bDisabled", false, value);
}
GCBaseEntity GCPointProximitySensor::GetTargetEntity() const {
    GCBaseEntity value(*GetSchemaValuePtr<void*>(m_ptr, "CPointProximitySensor", "m_hTargetEntity"));
    return value;
}
void GCPointProximitySensor::SetTargetEntity(GCBaseEntity* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'TargetEntity' is not possible.\n");
}
std::string GCPointProximitySensor::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCPointProximitySensor::IsValid() {
    return (m_ptr != nullptr);
}
GCPointEntity GCPointProximitySensor::GetParent() const {
    GCPointEntity value(m_ptr);
    return value;
}
void GCPointProximitySensor::SetParent(GCPointEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCPointProximitySensor(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCPointProximitySensor>("CPointProximitySensor")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Disabled", &GCPointProximitySensor::GetDisabled, &GCPointProximitySensor::SetDisabled)
        .addProperty("TargetEntity", &GCPointProximitySensor::GetTargetEntity, &GCPointProximitySensor::SetTargetEntity)
        .addProperty("Parent", &GCPointProximitySensor::GetParent, &GCPointProximitySensor::SetParent)
        .addFunction("ToPtr", &GCPointProximitySensor::ToPtr)
        .addFunction("IsValid", &GCPointProximitySensor::IsValid)
        .endClass();
}
GWeaponPurchaseTracker_t::GWeaponPurchaseTracker_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GWeaponPurchaseTracker_t::GWeaponPurchaseTracker_t(void *ptr) {
    m_ptr = ptr;
}
std::vector<GWeaponPurchaseCount_t> GWeaponPurchaseTracker_t::GetWeaponPurchases() const {
    CUtlVector<GWeaponPurchaseCount_t>* vec = GetSchemaValue<CUtlVector<GWeaponPurchaseCount_t>*>(m_ptr, "WeaponPurchaseTracker_t", "m_weaponPurchases"); std::vector<GWeaponPurchaseCount_t> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GWeaponPurchaseTracker_t::SetWeaponPurchases(std::vector<GWeaponPurchaseCount_t> value) {
    SetSchemaValueCUtlVector<GWeaponPurchaseCount_t>(m_ptr, "WeaponPurchaseTracker_t", "m_weaponPurchases", true, value);
}
std::string GWeaponPurchaseTracker_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GWeaponPurchaseTracker_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassWeaponPurchaseTracker_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GWeaponPurchaseTracker_t>("WeaponPurchaseTracker_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("WeaponPurchases", &GWeaponPurchaseTracker_t::GetWeaponPurchases, &GWeaponPurchaseTracker_t::SetWeaponPurchases)
        .addFunction("ToPtr", &GWeaponPurchaseTracker_t::ToPtr)
        .addFunction("IsValid", &GWeaponPurchaseTracker_t::IsValid)
        .endClass();
}
GCFilterClass::GCFilterClass(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCFilterClass::GCFilterClass(void *ptr) {
    m_ptr = ptr;
}
std::string GCFilterClass::GetFilterClass() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CFilterClass", "m_iFilterClass").String();
}
void GCFilterClass::SetFilterClass(std::string value) {
    SetSchemaValue(m_ptr, "CFilterClass", "m_iFilterClass", false, CUtlSymbolLarge(value.c_str()));
}
std::string GCFilterClass::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCFilterClass::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseFilter GCFilterClass::GetParent() const {
    GCBaseFilter value(m_ptr);
    return value;
}
void GCFilterClass::SetParent(GCBaseFilter value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCFilterClass(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCFilterClass>("CFilterClass")
        .addConstructor<void (*)(std::string)>()
        .addProperty("FilterClass", &GCFilterClass::GetFilterClass, &GCFilterClass::SetFilterClass)
        .addProperty("Parent", &GCFilterClass::GetParent, &GCFilterClass::SetParent)
        .addFunction("ToPtr", &GCFilterClass::ToPtr)
        .addFunction("IsValid", &GCFilterClass::IsValid)
        .endClass();
}
GCMelee::GCMelee(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCMelee::GCMelee(void *ptr) {
    m_ptr = ptr;
}
std::string GCMelee::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCMelee::IsValid() {
    return (m_ptr != nullptr);
}
GCCSWeaponBase GCMelee::GetParent() const {
    GCCSWeaponBase value(m_ptr);
    return value;
}
void GCMelee::SetParent(GCCSWeaponBase value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCMelee(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCMelee>("CMelee")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCMelee::GetParent, &GCMelee::SetParent)
        .addFunction("ToPtr", &GCMelee::ToPtr)
        .addFunction("IsValid", &GCMelee::IsValid)
        .endClass();
}
GCMultiplayRules::GCMultiplayRules(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCMultiplayRules::GCMultiplayRules(void *ptr) {
    m_ptr = ptr;
}
std::string GCMultiplayRules::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCMultiplayRules::IsValid() {
    return (m_ptr != nullptr);
}
GCGameRules GCMultiplayRules::GetParent() const {
    GCGameRules value(m_ptr);
    return value;
}
void GCMultiplayRules::SetParent(GCGameRules value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCMultiplayRules(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCMultiplayRules>("CMultiplayRules")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCMultiplayRules::GetParent, &GCMultiplayRules::SetParent)
        .addFunction("ToPtr", &GCMultiplayRules::ToPtr)
        .addFunction("IsValid", &GCMultiplayRules::IsValid)
        .endClass();
}
GCFilterLOS::GCFilterLOS(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCFilterLOS::GCFilterLOS(void *ptr) {
    m_ptr = ptr;
}
std::string GCFilterLOS::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCFilterLOS::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseFilter GCFilterLOS::GetParent() const {
    GCBaseFilter value(m_ptr);
    return value;
}
void GCFilterLOS::SetParent(GCBaseFilter value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCFilterLOS(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCFilterLOS>("CFilterLOS")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCFilterLOS::GetParent, &GCFilterLOS::SetParent)
        .addFunction("ToPtr", &GCFilterLOS::ToPtr)
        .addFunction("IsValid", &GCFilterLOS::IsValid)
        .endClass();
}
GEngineCountdownTimer::GEngineCountdownTimer(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GEngineCountdownTimer::GEngineCountdownTimer(void *ptr) {
    m_ptr = ptr;
}
float GEngineCountdownTimer::GetDuration() const {
    return GetSchemaValue<float>(m_ptr, "EngineCountdownTimer", "m_duration");
}
void GEngineCountdownTimer::SetDuration(float value) {
    SetSchemaValue(m_ptr, "EngineCountdownTimer", "m_duration", false, value);
}
float GEngineCountdownTimer::GetTimestamp() const {
    return GetSchemaValue<float>(m_ptr, "EngineCountdownTimer", "m_timestamp");
}
void GEngineCountdownTimer::SetTimestamp(float value) {
    SetSchemaValue(m_ptr, "EngineCountdownTimer", "m_timestamp", false, value);
}
float GEngineCountdownTimer::GetTimescale() const {
    return GetSchemaValue<float>(m_ptr, "EngineCountdownTimer", "m_timescale");
}
void GEngineCountdownTimer::SetTimescale(float value) {
    SetSchemaValue(m_ptr, "EngineCountdownTimer", "m_timescale", false, value);
}
std::string GEngineCountdownTimer::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GEngineCountdownTimer::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassEngineCountdownTimer(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GEngineCountdownTimer>("EngineCountdownTimer")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Duration", &GEngineCountdownTimer::GetDuration, &GEngineCountdownTimer::SetDuration)
        .addProperty("Timestamp", &GEngineCountdownTimer::GetTimestamp, &GEngineCountdownTimer::SetTimestamp)
        .addProperty("Timescale", &GEngineCountdownTimer::GetTimescale, &GEngineCountdownTimer::SetTimescale)
        .addFunction("ToPtr", &GEngineCountdownTimer::ToPtr)
        .addFunction("IsValid", &GEngineCountdownTimer::IsValid)
        .endClass();
}
GCPhysBox::GCPhysBox(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCPhysBox::GCPhysBox(void *ptr) {
    m_ptr = ptr;
}
int32_t GCPhysBox::GetDamageType() const {
    return GetSchemaValue<int32_t>(m_ptr, "CPhysBox", "m_damageType");
}
void GCPhysBox::SetDamageType(int32_t value) {
    SetSchemaValue(m_ptr, "CPhysBox", "m_damageType", false, value);
}
float GCPhysBox::GetMassScale() const {
    return GetSchemaValue<float>(m_ptr, "CPhysBox", "m_massScale");
}
void GCPhysBox::SetMassScale(float value) {
    SetSchemaValue(m_ptr, "CPhysBox", "m_massScale", false, value);
}
int32_t GCPhysBox::GetDamageToEnableMotion() const {
    return GetSchemaValue<int32_t>(m_ptr, "CPhysBox", "m_damageToEnableMotion");
}
void GCPhysBox::SetDamageToEnableMotion(int32_t value) {
    SetSchemaValue(m_ptr, "CPhysBox", "m_damageToEnableMotion", false, value);
}
float GCPhysBox::GetForceToEnableMotion() const {
    return GetSchemaValue<float>(m_ptr, "CPhysBox", "m_flForceToEnableMotion");
}
void GCPhysBox::SetForceToEnableMotion(float value) {
    SetSchemaValue(m_ptr, "CPhysBox", "m_flForceToEnableMotion", false, value);
}
QAngle GCPhysBox::GetPreferredCarryAngles() const {
    return GetSchemaValue<QAngle>(m_ptr, "CPhysBox", "m_angPreferredCarryAngles");
}
void GCPhysBox::SetPreferredCarryAngles(QAngle value) {
    SetSchemaValue(m_ptr, "CPhysBox", "m_angPreferredCarryAngles", false, value);
}
bool GCPhysBox::GetNotSolidToWorld() const {
    return GetSchemaValue<bool>(m_ptr, "CPhysBox", "m_bNotSolidToWorld");
}
void GCPhysBox::SetNotSolidToWorld(bool value) {
    SetSchemaValue(m_ptr, "CPhysBox", "m_bNotSolidToWorld", false, value);
}
bool GCPhysBox::GetEnableUseOutput() const {
    return GetSchemaValue<bool>(m_ptr, "CPhysBox", "m_bEnableUseOutput");
}
void GCPhysBox::SetEnableUseOutput(bool value) {
    SetSchemaValue(m_ptr, "CPhysBox", "m_bEnableUseOutput", false, value);
}
int32_t GCPhysBox::GetExploitableByPlayer() const {
    return GetSchemaValue<int32_t>(m_ptr, "CPhysBox", "m_iExploitableByPlayer");
}
void GCPhysBox::SetExploitableByPlayer(int32_t value) {
    SetSchemaValue(m_ptr, "CPhysBox", "m_iExploitableByPlayer", false, value);
}
float GCPhysBox::GetTouchOutputPerEntityDelay() const {
    return GetSchemaValue<float>(m_ptr, "CPhysBox", "m_flTouchOutputPerEntityDelay");
}
void GCPhysBox::SetTouchOutputPerEntityDelay(float value) {
    SetSchemaValue(m_ptr, "CPhysBox", "m_flTouchOutputPerEntityDelay", false, value);
}
GCEntityIOOutput GCPhysBox::GetOnDamaged() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CPhysBox", "m_OnDamaged"));
    return value;
}
void GCPhysBox::SetOnDamaged(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CPhysBox", "m_OnDamaged", false, value);
}
GCEntityIOOutput GCPhysBox::GetOnAwakened() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CPhysBox", "m_OnAwakened"));
    return value;
}
void GCPhysBox::SetOnAwakened(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CPhysBox", "m_OnAwakened", false, value);
}
GCEntityIOOutput GCPhysBox::GetOnMotionEnabled() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CPhysBox", "m_OnMotionEnabled"));
    return value;
}
void GCPhysBox::SetOnMotionEnabled(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CPhysBox", "m_OnMotionEnabled", false, value);
}
GCEntityIOOutput GCPhysBox::GetOnPlayerUse() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CPhysBox", "m_OnPlayerUse"));
    return value;
}
void GCPhysBox::SetOnPlayerUse(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CPhysBox", "m_OnPlayerUse", false, value);
}
GCEntityIOOutput GCPhysBox::GetOnStartTouch() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CPhysBox", "m_OnStartTouch"));
    return value;
}
void GCPhysBox::SetOnStartTouch(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CPhysBox", "m_OnStartTouch", false, value);
}
GCBasePlayerPawn GCPhysBox::GetCarryingPlayer() const {
    GCBasePlayerPawn value(*GetSchemaValuePtr<void*>(m_ptr, "CPhysBox", "m_hCarryingPlayer"));
    return value;
}
void GCPhysBox::SetCarryingPlayer(GCBasePlayerPawn* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'CarryingPlayer' is not possible.\n");
}
std::string GCPhysBox::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCPhysBox::IsValid() {
    return (m_ptr != nullptr);
}
GCBreakable GCPhysBox::GetParent() const {
    GCBreakable value(m_ptr);
    return value;
}
void GCPhysBox::SetParent(GCBreakable value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCPhysBox(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCPhysBox>("CPhysBox")
        .addConstructor<void (*)(std::string)>()
        .addProperty("DamageType", &GCPhysBox::GetDamageType, &GCPhysBox::SetDamageType)
        .addProperty("MassScale", &GCPhysBox::GetMassScale, &GCPhysBox::SetMassScale)
        .addProperty("DamageToEnableMotion", &GCPhysBox::GetDamageToEnableMotion, &GCPhysBox::SetDamageToEnableMotion)
        .addProperty("ForceToEnableMotion", &GCPhysBox::GetForceToEnableMotion, &GCPhysBox::SetForceToEnableMotion)
        .addProperty("PreferredCarryAngles", &GCPhysBox::GetPreferredCarryAngles, &GCPhysBox::SetPreferredCarryAngles)
        .addProperty("NotSolidToWorld", &GCPhysBox::GetNotSolidToWorld, &GCPhysBox::SetNotSolidToWorld)
        .addProperty("EnableUseOutput", &GCPhysBox::GetEnableUseOutput, &GCPhysBox::SetEnableUseOutput)
        .addProperty("ExploitableByPlayer", &GCPhysBox::GetExploitableByPlayer, &GCPhysBox::SetExploitableByPlayer)
        .addProperty("TouchOutputPerEntityDelay", &GCPhysBox::GetTouchOutputPerEntityDelay, &GCPhysBox::SetTouchOutputPerEntityDelay)
        .addProperty("OnDamaged", &GCPhysBox::GetOnDamaged, &GCPhysBox::SetOnDamaged)
        .addProperty("OnAwakened", &GCPhysBox::GetOnAwakened, &GCPhysBox::SetOnAwakened)
        .addProperty("OnMotionEnabled", &GCPhysBox::GetOnMotionEnabled, &GCPhysBox::SetOnMotionEnabled)
        .addProperty("OnPlayerUse", &GCPhysBox::GetOnPlayerUse, &GCPhysBox::SetOnPlayerUse)
        .addProperty("OnStartTouch", &GCPhysBox::GetOnStartTouch, &GCPhysBox::SetOnStartTouch)
        .addProperty("CarryingPlayer", &GCPhysBox::GetCarryingPlayer, &GCPhysBox::SetCarryingPlayer)
        .addProperty("Parent", &GCPhysBox::GetParent, &GCPhysBox::SetParent)
        .addFunction("ToPtr", &GCPhysBox::ToPtr)
        .addFunction("IsValid", &GCPhysBox::IsValid)
        .endClass();
}
GCSensorGrenadeProjectile::GCSensorGrenadeProjectile(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCSensorGrenadeProjectile::GCSensorGrenadeProjectile(void *ptr) {
    m_ptr = ptr;
}
float GCSensorGrenadeProjectile::GetExpireTime() const {
    return GetSchemaValue<float>(m_ptr, "CSensorGrenadeProjectile", "m_fExpireTime");
}
void GCSensorGrenadeProjectile::SetExpireTime(float value) {
    SetSchemaValue(m_ptr, "CSensorGrenadeProjectile", "m_fExpireTime", false, value);
}
float GCSensorGrenadeProjectile::GetNextDetectPlayerSound() const {
    return GetSchemaValue<float>(m_ptr, "CSensorGrenadeProjectile", "m_fNextDetectPlayerSound");
}
void GCSensorGrenadeProjectile::SetNextDetectPlayerSound(float value) {
    SetSchemaValue(m_ptr, "CSensorGrenadeProjectile", "m_fNextDetectPlayerSound", false, value);
}
GCBaseEntity GCSensorGrenadeProjectile::GetDisplayGrenade() const {
    GCBaseEntity value(*GetSchemaValuePtr<void*>(m_ptr, "CSensorGrenadeProjectile", "m_hDisplayGrenade"));
    return value;
}
void GCSensorGrenadeProjectile::SetDisplayGrenade(GCBaseEntity* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'DisplayGrenade' is not possible.\n");
}
std::string GCSensorGrenadeProjectile::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCSensorGrenadeProjectile::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseCSGrenadeProjectile GCSensorGrenadeProjectile::GetParent() const {
    GCBaseCSGrenadeProjectile value(m_ptr);
    return value;
}
void GCSensorGrenadeProjectile::SetParent(GCBaseCSGrenadeProjectile value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCSensorGrenadeProjectile(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCSensorGrenadeProjectile>("CSensorGrenadeProjectile")
        .addConstructor<void (*)(std::string)>()
        .addProperty("ExpireTime", &GCSensorGrenadeProjectile::GetExpireTime, &GCSensorGrenadeProjectile::SetExpireTime)
        .addProperty("NextDetectPlayerSound", &GCSensorGrenadeProjectile::GetNextDetectPlayerSound, &GCSensorGrenadeProjectile::SetNextDetectPlayerSound)
        .addProperty("DisplayGrenade", &GCSensorGrenadeProjectile::GetDisplayGrenade, &GCSensorGrenadeProjectile::SetDisplayGrenade)
        .addProperty("Parent", &GCSensorGrenadeProjectile::GetParent, &GCSensorGrenadeProjectile::SetParent)
        .addFunction("ToPtr", &GCSensorGrenadeProjectile::ToPtr)
        .addFunction("IsValid", &GCSensorGrenadeProjectile::IsValid)
        .endClass();
}
GCTimerEntity::GCTimerEntity(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCTimerEntity::GCTimerEntity(void *ptr) {
    m_ptr = ptr;
}
GCEntityIOOutput GCTimerEntity::GetOnTimer() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CTimerEntity", "m_OnTimer"));
    return value;
}
void GCTimerEntity::SetOnTimer(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CTimerEntity", "m_OnTimer", false, value);
}
GCEntityIOOutput GCTimerEntity::GetOnTimerHigh() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CTimerEntity", "m_OnTimerHigh"));
    return value;
}
void GCTimerEntity::SetOnTimerHigh(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CTimerEntity", "m_OnTimerHigh", false, value);
}
GCEntityIOOutput GCTimerEntity::GetOnTimerLow() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CTimerEntity", "m_OnTimerLow"));
    return value;
}
void GCTimerEntity::SetOnTimerLow(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CTimerEntity", "m_OnTimerLow", false, value);
}
int32_t GCTimerEntity::GetDisabled() const {
    return GetSchemaValue<int32_t>(m_ptr, "CTimerEntity", "m_iDisabled");
}
void GCTimerEntity::SetDisabled(int32_t value) {
    SetSchemaValue(m_ptr, "CTimerEntity", "m_iDisabled", false, value);
}
float GCTimerEntity::GetInitialDelay() const {
    return GetSchemaValue<float>(m_ptr, "CTimerEntity", "m_flInitialDelay");
}
void GCTimerEntity::SetInitialDelay(float value) {
    SetSchemaValue(m_ptr, "CTimerEntity", "m_flInitialDelay", false, value);
}
float GCTimerEntity::GetRefireTime() const {
    return GetSchemaValue<float>(m_ptr, "CTimerEntity", "m_flRefireTime");
}
void GCTimerEntity::SetRefireTime(float value) {
    SetSchemaValue(m_ptr, "CTimerEntity", "m_flRefireTime", false, value);
}
bool GCTimerEntity::GetUpDownState() const {
    return GetSchemaValue<bool>(m_ptr, "CTimerEntity", "m_bUpDownState");
}
void GCTimerEntity::SetUpDownState(bool value) {
    SetSchemaValue(m_ptr, "CTimerEntity", "m_bUpDownState", false, value);
}
int32_t GCTimerEntity::GetUseRandomTime() const {
    return GetSchemaValue<int32_t>(m_ptr, "CTimerEntity", "m_iUseRandomTime");
}
void GCTimerEntity::SetUseRandomTime(int32_t value) {
    SetSchemaValue(m_ptr, "CTimerEntity", "m_iUseRandomTime", false, value);
}
bool GCTimerEntity::GetPauseAfterFiring() const {
    return GetSchemaValue<bool>(m_ptr, "CTimerEntity", "m_bPauseAfterFiring");
}
void GCTimerEntity::SetPauseAfterFiring(bool value) {
    SetSchemaValue(m_ptr, "CTimerEntity", "m_bPauseAfterFiring", false, value);
}
float GCTimerEntity::GetLowerRandomBound() const {
    return GetSchemaValue<float>(m_ptr, "CTimerEntity", "m_flLowerRandomBound");
}
void GCTimerEntity::SetLowerRandomBound(float value) {
    SetSchemaValue(m_ptr, "CTimerEntity", "m_flLowerRandomBound", false, value);
}
float GCTimerEntity::GetUpperRandomBound() const {
    return GetSchemaValue<float>(m_ptr, "CTimerEntity", "m_flUpperRandomBound");
}
void GCTimerEntity::SetUpperRandomBound(float value) {
    SetSchemaValue(m_ptr, "CTimerEntity", "m_flUpperRandomBound", false, value);
}
float GCTimerEntity::GetRemainingTime() const {
    return GetSchemaValue<float>(m_ptr, "CTimerEntity", "m_flRemainingTime");
}
void GCTimerEntity::SetRemainingTime(float value) {
    SetSchemaValue(m_ptr, "CTimerEntity", "m_flRemainingTime", false, value);
}
bool GCTimerEntity::GetPaused() const {
    return GetSchemaValue<bool>(m_ptr, "CTimerEntity", "m_bPaused");
}
void GCTimerEntity::SetPaused(bool value) {
    SetSchemaValue(m_ptr, "CTimerEntity", "m_bPaused", false, value);
}
std::string GCTimerEntity::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCTimerEntity::IsValid() {
    return (m_ptr != nullptr);
}
GCLogicalEntity GCTimerEntity::GetParent() const {
    GCLogicalEntity value(m_ptr);
    return value;
}
void GCTimerEntity::SetParent(GCLogicalEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCTimerEntity(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCTimerEntity>("CTimerEntity")
        .addConstructor<void (*)(std::string)>()
        .addProperty("OnTimer", &GCTimerEntity::GetOnTimer, &GCTimerEntity::SetOnTimer)
        .addProperty("OnTimerHigh", &GCTimerEntity::GetOnTimerHigh, &GCTimerEntity::SetOnTimerHigh)
        .addProperty("OnTimerLow", &GCTimerEntity::GetOnTimerLow, &GCTimerEntity::SetOnTimerLow)
        .addProperty("Disabled", &GCTimerEntity::GetDisabled, &GCTimerEntity::SetDisabled)
        .addProperty("InitialDelay", &GCTimerEntity::GetInitialDelay, &GCTimerEntity::SetInitialDelay)
        .addProperty("RefireTime", &GCTimerEntity::GetRefireTime, &GCTimerEntity::SetRefireTime)
        .addProperty("UpDownState", &GCTimerEntity::GetUpDownState, &GCTimerEntity::SetUpDownState)
        .addProperty("UseRandomTime", &GCTimerEntity::GetUseRandomTime, &GCTimerEntity::SetUseRandomTime)
        .addProperty("PauseAfterFiring", &GCTimerEntity::GetPauseAfterFiring, &GCTimerEntity::SetPauseAfterFiring)
        .addProperty("LowerRandomBound", &GCTimerEntity::GetLowerRandomBound, &GCTimerEntity::SetLowerRandomBound)
        .addProperty("UpperRandomBound", &GCTimerEntity::GetUpperRandomBound, &GCTimerEntity::SetUpperRandomBound)
        .addProperty("RemainingTime", &GCTimerEntity::GetRemainingTime, &GCTimerEntity::SetRemainingTime)
        .addProperty("Paused", &GCTimerEntity::GetPaused, &GCTimerEntity::SetPaused)
        .addProperty("Parent", &GCTimerEntity::GetParent, &GCTimerEntity::SetParent)
        .addFunction("ToPtr", &GCTimerEntity::ToPtr)
        .addFunction("IsValid", &GCTimerEntity::IsValid)
        .endClass();
}
GCCSGO_TeamIntroCounterTerroristPosition::GCCSGO_TeamIntroCounterTerroristPosition(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCCSGO_TeamIntroCounterTerroristPosition::GCCSGO_TeamIntroCounterTerroristPosition(void *ptr) {
    m_ptr = ptr;
}
std::string GCCSGO_TeamIntroCounterTerroristPosition::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCCSGO_TeamIntroCounterTerroristPosition::IsValid() {
    return (m_ptr != nullptr);
}
GCCSGO_TeamIntroCharacterPosition GCCSGO_TeamIntroCounterTerroristPosition::GetParent() const {
    GCCSGO_TeamIntroCharacterPosition value(m_ptr);
    return value;
}
void GCCSGO_TeamIntroCounterTerroristPosition::SetParent(GCCSGO_TeamIntroCharacterPosition value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCCSGO_TeamIntroCounterTerroristPosition(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCCSGO_TeamIntroCounterTerroristPosition>("CCSGO_TeamIntroCounterTerroristPosition")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCCSGO_TeamIntroCounterTerroristPosition::GetParent, &GCCSGO_TeamIntroCounterTerroristPosition::SetParent)
        .addFunction("ToPtr", &GCCSGO_TeamIntroCounterTerroristPosition::ToPtr)
        .addFunction("IsValid", &GCCSGO_TeamIntroCounterTerroristPosition::IsValid)
        .endClass();
}
GCHEGrenadeProjectile::GCHEGrenadeProjectile(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCHEGrenadeProjectile::GCHEGrenadeProjectile(void *ptr) {
    m_ptr = ptr;
}
std::string GCHEGrenadeProjectile::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCHEGrenadeProjectile::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseCSGrenadeProjectile GCHEGrenadeProjectile::GetParent() const {
    GCBaseCSGrenadeProjectile value(m_ptr);
    return value;
}
void GCHEGrenadeProjectile::SetParent(GCBaseCSGrenadeProjectile value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCHEGrenadeProjectile(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCHEGrenadeProjectile>("CHEGrenadeProjectile")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCHEGrenadeProjectile::GetParent, &GCHEGrenadeProjectile::SetParent)
        .addFunction("ToPtr", &GCHEGrenadeProjectile::ToPtr)
        .addFunction("IsValid", &GCHEGrenadeProjectile::IsValid)
        .endClass();
}
GCEnvWind::GCEnvWind(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCEnvWind::GCEnvWind(void *ptr) {
    m_ptr = ptr;
}
GCEnvWindShared GCEnvWind::GetEnvWindShared() const {
    GCEnvWindShared value(GetSchemaPtr(m_ptr, "CEnvWind", "m_EnvWindShared"));
    return value;
}
void GCEnvWind::SetEnvWindShared(GCEnvWindShared value) {
    SetSchemaValue(m_ptr, "CEnvWind", "m_EnvWindShared", false, value);
}
std::string GCEnvWind::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCEnvWind::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseEntity GCEnvWind::GetParent() const {
    GCBaseEntity value(m_ptr);
    return value;
}
void GCEnvWind::SetParent(GCBaseEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCEnvWind(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCEnvWind>("CEnvWind")
        .addConstructor<void (*)(std::string)>()
        .addProperty("EnvWindShared", &GCEnvWind::GetEnvWindShared, &GCEnvWind::SetEnvWindShared)
        .addProperty("Parent", &GCEnvWind::GetParent, &GCEnvWind::SetParent)
        .addFunction("ToPtr", &GCEnvWind::ToPtr)
        .addFunction("IsValid", &GCEnvWind::IsValid)
        .endClass();
}
GCTimeline::GCTimeline(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCTimeline::GCTimeline(void *ptr) {
    m_ptr = ptr;
}
std::vector<float> GCTimeline::GetValues() const {
    float* outValue = GetSchemaValue<float*>(m_ptr, "CTimeline", "m_flValues"); std::vector<float> ret; for(int i = 0; i < 64; i++) { ret.push_back(outValue[i]); } return ret;
}
void GCTimeline::SetValues(std::vector<float> value) {
    float* outValue = GetSchemaValue<float*>(m_ptr, "CTimeline", "m_flValues"); for(int i = 0; i < 64; i++) { outValue[i] = value[i]; } SetSchemaValue(m_ptr, "CTimeline", "m_flValues", false, outValue);
}
std::vector<int32_t> GCTimeline::GetValueCounts() const {
    int32_t* outValue = GetSchemaValue<int32_t*>(m_ptr, "CTimeline", "m_nValueCounts"); std::vector<int32_t> ret; for(int i = 0; i < 64; i++) { ret.push_back(outValue[i]); } return ret;
}
void GCTimeline::SetValueCounts(std::vector<int32_t> value) {
    int32_t* outValue = GetSchemaValue<int32_t*>(m_ptr, "CTimeline", "m_nValueCounts"); for(int i = 0; i < 64; i++) { outValue[i] = value[i]; } SetSchemaValue(m_ptr, "CTimeline", "m_nValueCounts", false, outValue);
}
int32_t GCTimeline::GetBucketCount() const {
    return GetSchemaValue<int32_t>(m_ptr, "CTimeline", "m_nBucketCount");
}
void GCTimeline::SetBucketCount(int32_t value) {
    SetSchemaValue(m_ptr, "CTimeline", "m_nBucketCount", false, value);
}
float GCTimeline::GetInterval() const {
    return GetSchemaValue<float>(m_ptr, "CTimeline", "m_flInterval");
}
void GCTimeline::SetInterval(float value) {
    SetSchemaValue(m_ptr, "CTimeline", "m_flInterval", false, value);
}
float GCTimeline::GetFinalValue() const {
    return GetSchemaValue<float>(m_ptr, "CTimeline", "m_flFinalValue");
}
void GCTimeline::SetFinalValue(float value) {
    SetSchemaValue(m_ptr, "CTimeline", "m_flFinalValue", false, value);
}
uint64_t GCTimeline::GetCompressionType() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CTimeline", "m_nCompressionType");
}
void GCTimeline::SetCompressionType(uint64_t value) {
    SetSchemaValue(m_ptr, "CTimeline", "m_nCompressionType", false, value);
}
bool GCTimeline::GetStopped() const {
    return GetSchemaValue<bool>(m_ptr, "CTimeline", "m_bStopped");
}
void GCTimeline::SetStopped(bool value) {
    SetSchemaValue(m_ptr, "CTimeline", "m_bStopped", false, value);
}
std::string GCTimeline::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCTimeline::IsValid() {
    return (m_ptr != nullptr);
}
GIntervalTimer GCTimeline::GetParent() const {
    GIntervalTimer value(m_ptr);
    return value;
}
void GCTimeline::SetParent(GIntervalTimer value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCTimeline(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCTimeline>("CTimeline")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Values", &GCTimeline::GetValues, &GCTimeline::SetValues)
        .addProperty("ValueCounts", &GCTimeline::GetValueCounts, &GCTimeline::SetValueCounts)
        .addProperty("BucketCount", &GCTimeline::GetBucketCount, &GCTimeline::SetBucketCount)
        .addProperty("Interval", &GCTimeline::GetInterval, &GCTimeline::SetInterval)
        .addProperty("FinalValue", &GCTimeline::GetFinalValue, &GCTimeline::SetFinalValue)
        .addProperty("CompressionType", &GCTimeline::GetCompressionType, &GCTimeline::SetCompressionType)
        .addProperty("Stopped", &GCTimeline::GetStopped, &GCTimeline::SetStopped)
        .addProperty("Parent", &GCTimeline::GetParent, &GCTimeline::SetParent)
        .addFunction("ToPtr", &GCTimeline::ToPtr)
        .addFunction("IsValid", &GCTimeline::IsValid)
        .endClass();
}
GCFists::GCFists(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCFists::GCFists(void *ptr) {
    m_ptr = ptr;
}
bool GCFists::GetPlayingUninterruptableAct() const {
    return GetSchemaValue<bool>(m_ptr, "CFists", "m_bPlayingUninterruptableAct");
}
void GCFists::SetPlayingUninterruptableAct(bool value) {
    SetSchemaValue(m_ptr, "CFists", "m_bPlayingUninterruptableAct", false, value);
}
uint64_t GCFists::GetUninterruptableActivity() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CFists", "m_nUninterruptableActivity");
}
void GCFists::SetUninterruptableActivity(uint64_t value) {
    SetSchemaValue(m_ptr, "CFists", "m_nUninterruptableActivity", false, value);
}
bool GCFists::GetRestorePrevWep() const {
    return GetSchemaValue<bool>(m_ptr, "CFists", "m_bRestorePrevWep");
}
void GCFists::SetRestorePrevWep(bool value) {
    SetSchemaValue(m_ptr, "CFists", "m_bRestorePrevWep", false, value);
}
GCBasePlayerWeapon GCFists::GetWeaponBeforePrevious() const {
    GCBasePlayerWeapon value(*GetSchemaValuePtr<void*>(m_ptr, "CFists", "m_hWeaponBeforePrevious"));
    return value;
}
void GCFists::SetWeaponBeforePrevious(GCBasePlayerWeapon* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'WeaponBeforePrevious' is not possible.\n");
}
GCBasePlayerWeapon GCFists::GetWeaponPrevious() const {
    GCBasePlayerWeapon value(*GetSchemaValuePtr<void*>(m_ptr, "CFists", "m_hWeaponPrevious"));
    return value;
}
void GCFists::SetWeaponPrevious(GCBasePlayerWeapon* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'WeaponPrevious' is not possible.\n");
}
bool GCFists::GetDelayedHardPunchIncoming() const {
    return GetSchemaValue<bool>(m_ptr, "CFists", "m_bDelayedHardPunchIncoming");
}
void GCFists::SetDelayedHardPunchIncoming(bool value) {
    SetSchemaValue(m_ptr, "CFists", "m_bDelayedHardPunchIncoming", false, value);
}
bool GCFists::GetDestroyAfterTaunt() const {
    return GetSchemaValue<bool>(m_ptr, "CFists", "m_bDestroyAfterTaunt");
}
void GCFists::SetDestroyAfterTaunt(bool value) {
    SetSchemaValue(m_ptr, "CFists", "m_bDestroyAfterTaunt", false, value);
}
std::string GCFists::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCFists::IsValid() {
    return (m_ptr != nullptr);
}
GCCSWeaponBase GCFists::GetParent() const {
    GCCSWeaponBase value(m_ptr);
    return value;
}
void GCFists::SetParent(GCCSWeaponBase value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCFists(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCFists>("CFists")
        .addConstructor<void (*)(std::string)>()
        .addProperty("PlayingUninterruptableAct", &GCFists::GetPlayingUninterruptableAct, &GCFists::SetPlayingUninterruptableAct)
        .addProperty("UninterruptableActivity", &GCFists::GetUninterruptableActivity, &GCFists::SetUninterruptableActivity)
        .addProperty("RestorePrevWep", &GCFists::GetRestorePrevWep, &GCFists::SetRestorePrevWep)
        .addProperty("WeaponBeforePrevious", &GCFists::GetWeaponBeforePrevious, &GCFists::SetWeaponBeforePrevious)
        .addProperty("WeaponPrevious", &GCFists::GetWeaponPrevious, &GCFists::SetWeaponPrevious)
        .addProperty("DelayedHardPunchIncoming", &GCFists::GetDelayedHardPunchIncoming, &GCFists::SetDelayedHardPunchIncoming)
        .addProperty("DestroyAfterTaunt", &GCFists::GetDestroyAfterTaunt, &GCFists::SetDestroyAfterTaunt)
        .addProperty("Parent", &GCFists::GetParent, &GCFists::SetParent)
        .addFunction("ToPtr", &GCFists::ToPtr)
        .addFunction("IsValid", &GCFists::IsValid)
        .endClass();
}
GCHandleDummy::GCHandleDummy(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCHandleDummy::GCHandleDummy(void *ptr) {
    m_ptr = ptr;
}
std::string GCHandleDummy::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCHandleDummy::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseEntity GCHandleDummy::GetParent() const {
    GCBaseEntity value(m_ptr);
    return value;
}
void GCHandleDummy::SetParent(GCBaseEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCHandleDummy(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCHandleDummy>("CHandleDummy")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCHandleDummy::GetParent, &GCHandleDummy::SetParent)
        .addFunction("ToPtr", &GCHandleDummy::ToPtr)
        .addFunction("IsValid", &GCHandleDummy::IsValid)
        .endClass();
}
GCRagdollConstraint::GCRagdollConstraint(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCRagdollConstraint::GCRagdollConstraint(void *ptr) {
    m_ptr = ptr;
}
float GCRagdollConstraint::GetXmin() const {
    return GetSchemaValue<float>(m_ptr, "CRagdollConstraint", "m_xmin");
}
void GCRagdollConstraint::SetXmin(float value) {
    SetSchemaValue(m_ptr, "CRagdollConstraint", "m_xmin", false, value);
}
float GCRagdollConstraint::GetXmax() const {
    return GetSchemaValue<float>(m_ptr, "CRagdollConstraint", "m_xmax");
}
void GCRagdollConstraint::SetXmax(float value) {
    SetSchemaValue(m_ptr, "CRagdollConstraint", "m_xmax", false, value);
}
float GCRagdollConstraint::GetYmin() const {
    return GetSchemaValue<float>(m_ptr, "CRagdollConstraint", "m_ymin");
}
void GCRagdollConstraint::SetYmin(float value) {
    SetSchemaValue(m_ptr, "CRagdollConstraint", "m_ymin", false, value);
}
float GCRagdollConstraint::GetYmax() const {
    return GetSchemaValue<float>(m_ptr, "CRagdollConstraint", "m_ymax");
}
void GCRagdollConstraint::SetYmax(float value) {
    SetSchemaValue(m_ptr, "CRagdollConstraint", "m_ymax", false, value);
}
float GCRagdollConstraint::GetZmin() const {
    return GetSchemaValue<float>(m_ptr, "CRagdollConstraint", "m_zmin");
}
void GCRagdollConstraint::SetZmin(float value) {
    SetSchemaValue(m_ptr, "CRagdollConstraint", "m_zmin", false, value);
}
float GCRagdollConstraint::GetZmax() const {
    return GetSchemaValue<float>(m_ptr, "CRagdollConstraint", "m_zmax");
}
void GCRagdollConstraint::SetZmax(float value) {
    SetSchemaValue(m_ptr, "CRagdollConstraint", "m_zmax", false, value);
}
float GCRagdollConstraint::GetXfriction() const {
    return GetSchemaValue<float>(m_ptr, "CRagdollConstraint", "m_xfriction");
}
void GCRagdollConstraint::SetXfriction(float value) {
    SetSchemaValue(m_ptr, "CRagdollConstraint", "m_xfriction", false, value);
}
float GCRagdollConstraint::GetYfriction() const {
    return GetSchemaValue<float>(m_ptr, "CRagdollConstraint", "m_yfriction");
}
void GCRagdollConstraint::SetYfriction(float value) {
    SetSchemaValue(m_ptr, "CRagdollConstraint", "m_yfriction", false, value);
}
float GCRagdollConstraint::GetZfriction() const {
    return GetSchemaValue<float>(m_ptr, "CRagdollConstraint", "m_zfriction");
}
void GCRagdollConstraint::SetZfriction(float value) {
    SetSchemaValue(m_ptr, "CRagdollConstraint", "m_zfriction", false, value);
}
std::string GCRagdollConstraint::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCRagdollConstraint::IsValid() {
    return (m_ptr != nullptr);
}
GCPhysConstraint GCRagdollConstraint::GetParent() const {
    GCPhysConstraint value(m_ptr);
    return value;
}
void GCRagdollConstraint::SetParent(GCPhysConstraint value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCRagdollConstraint(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCRagdollConstraint>("CRagdollConstraint")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Xmin", &GCRagdollConstraint::GetXmin, &GCRagdollConstraint::SetXmin)
        .addProperty("Xmax", &GCRagdollConstraint::GetXmax, &GCRagdollConstraint::SetXmax)
        .addProperty("Ymin", &GCRagdollConstraint::GetYmin, &GCRagdollConstraint::SetYmin)
        .addProperty("Ymax", &GCRagdollConstraint::GetYmax, &GCRagdollConstraint::SetYmax)
        .addProperty("Zmin", &GCRagdollConstraint::GetZmin, &GCRagdollConstraint::SetZmin)
        .addProperty("Zmax", &GCRagdollConstraint::GetZmax, &GCRagdollConstraint::SetZmax)
        .addProperty("Xfriction", &GCRagdollConstraint::GetXfriction, &GCRagdollConstraint::SetXfriction)
        .addProperty("Yfriction", &GCRagdollConstraint::GetYfriction, &GCRagdollConstraint::SetYfriction)
        .addProperty("Zfriction", &GCRagdollConstraint::GetZfriction, &GCRagdollConstraint::SetZfriction)
        .addProperty("Parent", &GCRagdollConstraint::GetParent, &GCRagdollConstraint::SetParent)
        .addFunction("ToPtr", &GCRagdollConstraint::ToPtr)
        .addFunction("IsValid", &GCRagdollConstraint::IsValid)
        .endClass();
}
GCPhysExplosion::GCPhysExplosion(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCPhysExplosion::GCPhysExplosion(void *ptr) {
    m_ptr = ptr;
}
bool GCPhysExplosion::GetExplodeOnSpawn() const {
    return GetSchemaValue<bool>(m_ptr, "CPhysExplosion", "m_bExplodeOnSpawn");
}
void GCPhysExplosion::SetExplodeOnSpawn(bool value) {
    SetSchemaValue(m_ptr, "CPhysExplosion", "m_bExplodeOnSpawn", false, value);
}
float GCPhysExplosion::GetMagnitude() const {
    return GetSchemaValue<float>(m_ptr, "CPhysExplosion", "m_flMagnitude");
}
void GCPhysExplosion::SetMagnitude(float value) {
    SetSchemaValue(m_ptr, "CPhysExplosion", "m_flMagnitude", false, value);
}
float GCPhysExplosion::GetDamage() const {
    return GetSchemaValue<float>(m_ptr, "CPhysExplosion", "m_flDamage");
}
void GCPhysExplosion::SetDamage(float value) {
    SetSchemaValue(m_ptr, "CPhysExplosion", "m_flDamage", false, value);
}
float GCPhysExplosion::GetRadius() const {
    return GetSchemaValue<float>(m_ptr, "CPhysExplosion", "m_radius");
}
void GCPhysExplosion::SetRadius(float value) {
    SetSchemaValue(m_ptr, "CPhysExplosion", "m_radius", false, value);
}
std::string GCPhysExplosion::GetTargetEntityName() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CPhysExplosion", "m_targetEntityName").String();
}
void GCPhysExplosion::SetTargetEntityName(std::string value) {
    SetSchemaValue(m_ptr, "CPhysExplosion", "m_targetEntityName", false, CUtlSymbolLarge(value.c_str()));
}
float GCPhysExplosion::GetInnerRadius() const {
    return GetSchemaValue<float>(m_ptr, "CPhysExplosion", "m_flInnerRadius");
}
void GCPhysExplosion::SetInnerRadius(float value) {
    SetSchemaValue(m_ptr, "CPhysExplosion", "m_flInnerRadius", false, value);
}
float GCPhysExplosion::GetPushScale() const {
    return GetSchemaValue<float>(m_ptr, "CPhysExplosion", "m_flPushScale");
}
void GCPhysExplosion::SetPushScale(float value) {
    SetSchemaValue(m_ptr, "CPhysExplosion", "m_flPushScale", false, value);
}
bool GCPhysExplosion::GetConvertToDebrisWhenPossible() const {
    return GetSchemaValue<bool>(m_ptr, "CPhysExplosion", "m_bConvertToDebrisWhenPossible");
}
void GCPhysExplosion::SetConvertToDebrisWhenPossible(bool value) {
    SetSchemaValue(m_ptr, "CPhysExplosion", "m_bConvertToDebrisWhenPossible", false, value);
}
GCEntityIOOutput GCPhysExplosion::GetOnPushedPlayer() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CPhysExplosion", "m_OnPushedPlayer"));
    return value;
}
void GCPhysExplosion::SetOnPushedPlayer(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CPhysExplosion", "m_OnPushedPlayer", false, value);
}
std::string GCPhysExplosion::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCPhysExplosion::IsValid() {
    return (m_ptr != nullptr);
}
GCPointEntity GCPhysExplosion::GetParent() const {
    GCPointEntity value(m_ptr);
    return value;
}
void GCPhysExplosion::SetParent(GCPointEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCPhysExplosion(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCPhysExplosion>("CPhysExplosion")
        .addConstructor<void (*)(std::string)>()
        .addProperty("ExplodeOnSpawn", &GCPhysExplosion::GetExplodeOnSpawn, &GCPhysExplosion::SetExplodeOnSpawn)
        .addProperty("Magnitude", &GCPhysExplosion::GetMagnitude, &GCPhysExplosion::SetMagnitude)
        .addProperty("Damage", &GCPhysExplosion::GetDamage, &GCPhysExplosion::SetDamage)
        .addProperty("Radius", &GCPhysExplosion::GetRadius, &GCPhysExplosion::SetRadius)
        .addProperty("TargetEntityName", &GCPhysExplosion::GetTargetEntityName, &GCPhysExplosion::SetTargetEntityName)
        .addProperty("InnerRadius", &GCPhysExplosion::GetInnerRadius, &GCPhysExplosion::SetInnerRadius)
        .addProperty("PushScale", &GCPhysExplosion::GetPushScale, &GCPhysExplosion::SetPushScale)
        .addProperty("ConvertToDebrisWhenPossible", &GCPhysExplosion::GetConvertToDebrisWhenPossible, &GCPhysExplosion::SetConvertToDebrisWhenPossible)
        .addProperty("OnPushedPlayer", &GCPhysExplosion::GetOnPushedPlayer, &GCPhysExplosion::SetOnPushedPlayer)
        .addProperty("Parent", &GCPhysExplosion::GetParent, &GCPhysExplosion::SetParent)
        .addFunction("ToPtr", &GCPhysExplosion::ToPtr)
        .addFunction("IsValid", &GCPhysExplosion::IsValid)
        .endClass();
}
GCPointPush::GCPointPush(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCPointPush::GCPointPush(void *ptr) {
    m_ptr = ptr;
}
bool GCPointPush::GetEnabled() const {
    return GetSchemaValue<bool>(m_ptr, "CPointPush", "m_bEnabled");
}
void GCPointPush::SetEnabled(bool value) {
    SetSchemaValue(m_ptr, "CPointPush", "m_bEnabled", false, value);
}
float GCPointPush::GetMagnitude() const {
    return GetSchemaValue<float>(m_ptr, "CPointPush", "m_flMagnitude");
}
void GCPointPush::SetMagnitude(float value) {
    SetSchemaValue(m_ptr, "CPointPush", "m_flMagnitude", false, value);
}
float GCPointPush::GetRadius() const {
    return GetSchemaValue<float>(m_ptr, "CPointPush", "m_flRadius");
}
void GCPointPush::SetRadius(float value) {
    SetSchemaValue(m_ptr, "CPointPush", "m_flRadius", false, value);
}
float GCPointPush::GetInnerRadius() const {
    return GetSchemaValue<float>(m_ptr, "CPointPush", "m_flInnerRadius");
}
void GCPointPush::SetInnerRadius(float value) {
    SetSchemaValue(m_ptr, "CPointPush", "m_flInnerRadius", false, value);
}
float GCPointPush::GetConeOfInfluence() const {
    return GetSchemaValue<float>(m_ptr, "CPointPush", "m_flConeOfInfluence");
}
void GCPointPush::SetConeOfInfluence(float value) {
    SetSchemaValue(m_ptr, "CPointPush", "m_flConeOfInfluence", false, value);
}
std::string GCPointPush::GetFilterName() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CPointPush", "m_iszFilterName").String();
}
void GCPointPush::SetFilterName(std::string value) {
    SetSchemaValue(m_ptr, "CPointPush", "m_iszFilterName", false, CUtlSymbolLarge(value.c_str()));
}
GCBaseFilter GCPointPush::GetFilter() const {
    GCBaseFilter value(*GetSchemaValuePtr<void*>(m_ptr, "CPointPush", "m_hFilter"));
    return value;
}
void GCPointPush::SetFilter(GCBaseFilter* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Filter' is not possible.\n");
}
std::string GCPointPush::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCPointPush::IsValid() {
    return (m_ptr != nullptr);
}
GCPointEntity GCPointPush::GetParent() const {
    GCPointEntity value(m_ptr);
    return value;
}
void GCPointPush::SetParent(GCPointEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCPointPush(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCPointPush>("CPointPush")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Enabled", &GCPointPush::GetEnabled, &GCPointPush::SetEnabled)
        .addProperty("Magnitude", &GCPointPush::GetMagnitude, &GCPointPush::SetMagnitude)
        .addProperty("Radius", &GCPointPush::GetRadius, &GCPointPush::SetRadius)
        .addProperty("InnerRadius", &GCPointPush::GetInnerRadius, &GCPointPush::SetInnerRadius)
        .addProperty("ConeOfInfluence", &GCPointPush::GetConeOfInfluence, &GCPointPush::SetConeOfInfluence)
        .addProperty("FilterName", &GCPointPush::GetFilterName, &GCPointPush::SetFilterName)
        .addProperty("Filter", &GCPointPush::GetFilter, &GCPointPush::SetFilter)
        .addProperty("Parent", &GCPointPush::GetParent, &GCPointPush::SetParent)
        .addFunction("ToPtr", &GCPointPush::ToPtr)
        .addFunction("IsValid", &GCPointPush::IsValid)
        .endClass();
}
GCCredits::GCCredits(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCCredits::GCCredits(void *ptr) {
    m_ptr = ptr;
}
GCEntityIOOutput GCCredits::GetOnCreditsDone() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CCredits", "m_OnCreditsDone"));
    return value;
}
void GCCredits::SetOnCreditsDone(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CCredits", "m_OnCreditsDone", false, value);
}
bool GCCredits::GetRolledOutroCredits() const {
    return GetSchemaValue<bool>(m_ptr, "CCredits", "m_bRolledOutroCredits");
}
void GCCredits::SetRolledOutroCredits(bool value) {
    SetSchemaValue(m_ptr, "CCredits", "m_bRolledOutroCredits", false, value);
}
float GCCredits::GetLogoLength() const {
    return GetSchemaValue<float>(m_ptr, "CCredits", "m_flLogoLength");
}
void GCCredits::SetLogoLength(float value) {
    SetSchemaValue(m_ptr, "CCredits", "m_flLogoLength", false, value);
}
std::string GCCredits::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCCredits::IsValid() {
    return (m_ptr != nullptr);
}
GCPointEntity GCCredits::GetParent() const {
    GCPointEntity value(m_ptr);
    return value;
}
void GCCredits::SetParent(GCPointEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCCredits(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCCredits>("CCredits")
        .addConstructor<void (*)(std::string)>()
        .addProperty("OnCreditsDone", &GCCredits::GetOnCreditsDone, &GCCredits::SetOnCreditsDone)
        .addProperty("RolledOutroCredits", &GCCredits::GetRolledOutroCredits, &GCCredits::SetRolledOutroCredits)
        .addProperty("LogoLength", &GCCredits::GetLogoLength, &GCCredits::SetLogoLength)
        .addProperty("Parent", &GCCredits::GetParent, &GCCredits::SetParent)
        .addFunction("ToPtr", &GCCredits::ToPtr)
        .addFunction("IsValid", &GCCredits::IsValid)
        .endClass();
}
GCCSPlayerResource::GCCSPlayerResource(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCCSPlayerResource::GCCSPlayerResource(void *ptr) {
    m_ptr = ptr;
}
std::vector<bool> GCCSPlayerResource::GetHostageAlive() const {
    bool* outValue = GetSchemaValue<bool*>(m_ptr, "CCSPlayerResource", "m_bHostageAlive"); std::vector<bool> ret; for(int i = 0; i < 12; i++) { ret.push_back(outValue[i]); } return ret;
}
void GCCSPlayerResource::SetHostageAlive(std::vector<bool> value) {
    bool* outValue = GetSchemaValue<bool*>(m_ptr, "CCSPlayerResource", "m_bHostageAlive"); for(int i = 0; i < 12; i++) { outValue[i] = value[i]; } SetSchemaValue(m_ptr, "CCSPlayerResource", "m_bHostageAlive", false, outValue);
}
std::vector<bool> GCCSPlayerResource::GetIsHostageFollowingSomeone() const {
    bool* outValue = GetSchemaValue<bool*>(m_ptr, "CCSPlayerResource", "m_isHostageFollowingSomeone"); std::vector<bool> ret; for(int i = 0; i < 12; i++) { ret.push_back(outValue[i]); } return ret;
}
void GCCSPlayerResource::SetIsHostageFollowingSomeone(std::vector<bool> value) {
    bool* outValue = GetSchemaValue<bool*>(m_ptr, "CCSPlayerResource", "m_isHostageFollowingSomeone"); for(int i = 0; i < 12; i++) { outValue[i] = value[i]; } SetSchemaValue(m_ptr, "CCSPlayerResource", "m_isHostageFollowingSomeone", false, outValue);
}
std::vector<CEntityIndex> GCCSPlayerResource::GetHostageEntityIDs() const {
    CEntityIndex* outValue = GetSchemaValue<CEntityIndex*>(m_ptr, "CCSPlayerResource", "m_iHostageEntityIDs"); std::vector<CEntityIndex> ret; for(int i = 0; i < 12; i++) { ret.push_back(outValue[i]); } return ret;
}
void GCCSPlayerResource::SetHostageEntityIDs(std::vector<CEntityIndex> value) {
    CEntityIndex* outValue = GetSchemaValue<CEntityIndex*>(m_ptr, "CCSPlayerResource", "m_iHostageEntityIDs"); for(int i = 0; i < 12; i++) { outValue[i] = value[i]; } SetSchemaValue(m_ptr, "CCSPlayerResource", "m_iHostageEntityIDs", false, outValue);
}
Vector GCCSPlayerResource::GetBombsiteCenterA() const {
    return GetSchemaValue<Vector>(m_ptr, "CCSPlayerResource", "m_bombsiteCenterA");
}
void GCCSPlayerResource::SetBombsiteCenterA(Vector value) {
    SetSchemaValue(m_ptr, "CCSPlayerResource", "m_bombsiteCenterA", false, value);
}
Vector GCCSPlayerResource::GetBombsiteCenterB() const {
    return GetSchemaValue<Vector>(m_ptr, "CCSPlayerResource", "m_bombsiteCenterB");
}
void GCCSPlayerResource::SetBombsiteCenterB(Vector value) {
    SetSchemaValue(m_ptr, "CCSPlayerResource", "m_bombsiteCenterB", false, value);
}
std::vector<int32_t> GCCSPlayerResource::GetHostageRescueX() const {
    int32_t* outValue = GetSchemaValue<int32_t*>(m_ptr, "CCSPlayerResource", "m_hostageRescueX"); std::vector<int32_t> ret; for(int i = 0; i < 4; i++) { ret.push_back(outValue[i]); } return ret;
}
void GCCSPlayerResource::SetHostageRescueX(std::vector<int32_t> value) {
    int32_t* outValue = GetSchemaValue<int32_t*>(m_ptr, "CCSPlayerResource", "m_hostageRescueX"); for(int i = 0; i < 4; i++) { outValue[i] = value[i]; } SetSchemaValue(m_ptr, "CCSPlayerResource", "m_hostageRescueX", false, outValue);
}
std::vector<int32_t> GCCSPlayerResource::GetHostageRescueY() const {
    int32_t* outValue = GetSchemaValue<int32_t*>(m_ptr, "CCSPlayerResource", "m_hostageRescueY"); std::vector<int32_t> ret; for(int i = 0; i < 4; i++) { ret.push_back(outValue[i]); } return ret;
}
void GCCSPlayerResource::SetHostageRescueY(std::vector<int32_t> value) {
    int32_t* outValue = GetSchemaValue<int32_t*>(m_ptr, "CCSPlayerResource", "m_hostageRescueY"); for(int i = 0; i < 4; i++) { outValue[i] = value[i]; } SetSchemaValue(m_ptr, "CCSPlayerResource", "m_hostageRescueY", false, outValue);
}
std::vector<int32_t> GCCSPlayerResource::GetHostageRescueZ() const {
    int32_t* outValue = GetSchemaValue<int32_t*>(m_ptr, "CCSPlayerResource", "m_hostageRescueZ"); std::vector<int32_t> ret; for(int i = 0; i < 4; i++) { ret.push_back(outValue[i]); } return ret;
}
void GCCSPlayerResource::SetHostageRescueZ(std::vector<int32_t> value) {
    int32_t* outValue = GetSchemaValue<int32_t*>(m_ptr, "CCSPlayerResource", "m_hostageRescueZ"); for(int i = 0; i < 4; i++) { outValue[i] = value[i]; } SetSchemaValue(m_ptr, "CCSPlayerResource", "m_hostageRescueZ", false, outValue);
}
bool GCCSPlayerResource::GetEndMatchNextMapAllVoted() const {
    return GetSchemaValue<bool>(m_ptr, "CCSPlayerResource", "m_bEndMatchNextMapAllVoted");
}
void GCCSPlayerResource::SetEndMatchNextMapAllVoted(bool value) {
    SetSchemaValue(m_ptr, "CCSPlayerResource", "m_bEndMatchNextMapAllVoted", false, value);
}
bool GCCSPlayerResource::GetFoundGoalPositions() const {
    return GetSchemaValue<bool>(m_ptr, "CCSPlayerResource", "m_foundGoalPositions");
}
void GCCSPlayerResource::SetFoundGoalPositions(bool value) {
    SetSchemaValue(m_ptr, "CCSPlayerResource", "m_foundGoalPositions", false, value);
}
std::string GCCSPlayerResource::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCCSPlayerResource::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseEntity GCCSPlayerResource::GetParent() const {
    GCBaseEntity value(m_ptr);
    return value;
}
void GCCSPlayerResource::SetParent(GCBaseEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCCSPlayerResource(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCCSPlayerResource>("CCSPlayerResource")
        .addConstructor<void (*)(std::string)>()
        .addProperty("HostageAlive", &GCCSPlayerResource::GetHostageAlive, &GCCSPlayerResource::SetHostageAlive)
        .addProperty("IsHostageFollowingSomeone", &GCCSPlayerResource::GetIsHostageFollowingSomeone, &GCCSPlayerResource::SetIsHostageFollowingSomeone)
        .addProperty("HostageEntityIDs", &GCCSPlayerResource::GetHostageEntityIDs, &GCCSPlayerResource::SetHostageEntityIDs)
        .addProperty("BombsiteCenterA", &GCCSPlayerResource::GetBombsiteCenterA, &GCCSPlayerResource::SetBombsiteCenterA)
        .addProperty("BombsiteCenterB", &GCCSPlayerResource::GetBombsiteCenterB, &GCCSPlayerResource::SetBombsiteCenterB)
        .addProperty("HostageRescueX", &GCCSPlayerResource::GetHostageRescueX, &GCCSPlayerResource::SetHostageRescueX)
        .addProperty("HostageRescueY", &GCCSPlayerResource::GetHostageRescueY, &GCCSPlayerResource::SetHostageRescueY)
        .addProperty("HostageRescueZ", &GCCSPlayerResource::GetHostageRescueZ, &GCCSPlayerResource::SetHostageRescueZ)
        .addProperty("EndMatchNextMapAllVoted", &GCCSPlayerResource::GetEndMatchNextMapAllVoted, &GCCSPlayerResource::SetEndMatchNextMapAllVoted)
        .addProperty("FoundGoalPositions", &GCCSPlayerResource::GetFoundGoalPositions, &GCCSPlayerResource::SetFoundGoalPositions)
        .addProperty("Parent", &GCCSPlayerResource::GetParent, &GCCSPlayerResource::SetParent)
        .addFunction("ToPtr", &GCCSPlayerResource::ToPtr)
        .addFunction("IsValid", &GCCSPlayerResource::IsValid)
        .endClass();
}
GCPlayer_WeaponServices::GCPlayer_WeaponServices(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCPlayer_WeaponServices::GCPlayer_WeaponServices(void *ptr) {
    m_ptr = ptr;
}
std::vector<GCBasePlayerWeapon*> GCPlayer_WeaponServices::GetMyWeapons() const {
    CUtlVector<GCBasePlayerWeapon*>* vec = GetSchemaValue<CUtlVector<GCBasePlayerWeapon*>*>(m_ptr, "CPlayer_WeaponServices", "m_hMyWeapons"); std::vector<GCBasePlayerWeapon*> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCPlayer_WeaponServices::SetMyWeapons(std::vector<GCBasePlayerWeapon*> value) {
    SetSchemaValueCUtlVector<GCBasePlayerWeapon*>(m_ptr, "CPlayer_WeaponServices", "m_hMyWeapons", false, value);
}
GCBasePlayerWeapon GCPlayer_WeaponServices::GetActiveWeapon() const {
    GCBasePlayerWeapon value(*GetSchemaValuePtr<void*>(m_ptr, "CPlayer_WeaponServices", "m_hActiveWeapon"));
    return value;
}
void GCPlayer_WeaponServices::SetActiveWeapon(GCBasePlayerWeapon* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'ActiveWeapon' is not possible.\n");
}
GCBasePlayerWeapon GCPlayer_WeaponServices::GetLastWeapon() const {
    GCBasePlayerWeapon value(*GetSchemaValuePtr<void*>(m_ptr, "CPlayer_WeaponServices", "m_hLastWeapon"));
    return value;
}
void GCPlayer_WeaponServices::SetLastWeapon(GCBasePlayerWeapon* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'LastWeapon' is not possible.\n");
}
std::vector<uint16_t> GCPlayer_WeaponServices::GetAmmo() const {
    uint16_t* outValue = GetSchemaValue<uint16_t*>(m_ptr, "CPlayer_WeaponServices", "m_iAmmo"); std::vector<uint16_t> ret; for(int i = 0; i < 32; i++) { ret.push_back(outValue[i]); } return ret;
}
void GCPlayer_WeaponServices::SetAmmo(std::vector<uint16_t> value) {
    uint16_t* outValue = GetSchemaValue<uint16_t*>(m_ptr, "CPlayer_WeaponServices", "m_iAmmo"); for(int i = 0; i < 32; i++) { outValue[i] = value[i]; } SetSchemaValue(m_ptr, "CPlayer_WeaponServices", "m_iAmmo", false, outValue);
}
bool GCPlayer_WeaponServices::GetPreventWeaponPickup() const {
    return GetSchemaValue<bool>(m_ptr, "CPlayer_WeaponServices", "m_bPreventWeaponPickup");
}
void GCPlayer_WeaponServices::SetPreventWeaponPickup(bool value) {
    SetSchemaValue(m_ptr, "CPlayer_WeaponServices", "m_bPreventWeaponPickup", false, value);
}
std::string GCPlayer_WeaponServices::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCPlayer_WeaponServices::IsValid() {
    return (m_ptr != nullptr);
}
GCPlayerPawnComponent GCPlayer_WeaponServices::GetParent() const {
    GCPlayerPawnComponent value(m_ptr);
    return value;
}
void GCPlayer_WeaponServices::SetParent(GCPlayerPawnComponent value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCPlayer_WeaponServices(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCPlayer_WeaponServices>("CPlayer_WeaponServices")
        .addConstructor<void (*)(std::string)>()
        .addProperty("MyWeapons", &GCPlayer_WeaponServices::GetMyWeapons, &GCPlayer_WeaponServices::SetMyWeapons)
        .addProperty("ActiveWeapon", &GCPlayer_WeaponServices::GetActiveWeapon, &GCPlayer_WeaponServices::SetActiveWeapon)
        .addProperty("LastWeapon", &GCPlayer_WeaponServices::GetLastWeapon, &GCPlayer_WeaponServices::SetLastWeapon)
        .addProperty("Ammo", &GCPlayer_WeaponServices::GetAmmo, &GCPlayer_WeaponServices::SetAmmo)
        .addProperty("PreventWeaponPickup", &GCPlayer_WeaponServices::GetPreventWeaponPickup, &GCPlayer_WeaponServices::SetPreventWeaponPickup)
        .addProperty("Parent", &GCPlayer_WeaponServices::GetParent, &GCPlayer_WeaponServices::SetParent)
        .addFunction("ToPtr", &GCPlayer_WeaponServices::ToPtr)
        .addFunction("IsValid", &GCPlayer_WeaponServices::IsValid)
        .endClass();
}
GCAttributeManager__cached_attribute_float_t::GCAttributeManager__cached_attribute_float_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCAttributeManager__cached_attribute_float_t::GCAttributeManager__cached_attribute_float_t(void *ptr) {
    m_ptr = ptr;
}
float GCAttributeManager__cached_attribute_float_t::GetIn() const {
    return GetSchemaValue<float>(m_ptr, "CAttributeManager__cached_attribute_float_t", "flIn");
}
void GCAttributeManager__cached_attribute_float_t::SetIn(float value) {
    SetSchemaValue(m_ptr, "CAttributeManager__cached_attribute_float_t", "flIn", true, value);
}
std::string GCAttributeManager__cached_attribute_float_t::GetAttribHook() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CAttributeManager__cached_attribute_float_t", "iAttribHook").String();
}
void GCAttributeManager__cached_attribute_float_t::SetAttribHook(std::string value) {
    SetSchemaValue(m_ptr, "CAttributeManager__cached_attribute_float_t", "iAttribHook", true, CUtlSymbolLarge(value.c_str()));
}
float GCAttributeManager__cached_attribute_float_t::GetOut() const {
    return GetSchemaValue<float>(m_ptr, "CAttributeManager__cached_attribute_float_t", "flOut");
}
void GCAttributeManager__cached_attribute_float_t::SetOut(float value) {
    SetSchemaValue(m_ptr, "CAttributeManager__cached_attribute_float_t", "flOut", true, value);
}
std::string GCAttributeManager__cached_attribute_float_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCAttributeManager__cached_attribute_float_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCAttributeManager__cached_attribute_float_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCAttributeManager__cached_attribute_float_t>("CAttributeManager__cached_attribute_float_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("In", &GCAttributeManager__cached_attribute_float_t::GetIn, &GCAttributeManager__cached_attribute_float_t::SetIn)
        .addProperty("AttribHook", &GCAttributeManager__cached_attribute_float_t::GetAttribHook, &GCAttributeManager__cached_attribute_float_t::SetAttribHook)
        .addProperty("Out", &GCAttributeManager__cached_attribute_float_t::GetOut, &GCAttributeManager__cached_attribute_float_t::SetOut)
        .addFunction("ToPtr", &GCAttributeManager__cached_attribute_float_t::ToPtr)
        .addFunction("IsValid", &GCAttributeManager__cached_attribute_float_t::IsValid)
        .endClass();
}
GCTeam::GCTeam(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCTeam::GCTeam(void *ptr) {
    m_ptr = ptr;
}
std::vector<GCBasePlayerController*> GCTeam::GetPlayerControllers() const {
    CUtlVector<GCBasePlayerController*>* vec = GetSchemaValue<CUtlVector<GCBasePlayerController*>*>(m_ptr, "CTeam", "m_aPlayerControllers"); std::vector<GCBasePlayerController*> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCTeam::SetPlayerControllers(std::vector<GCBasePlayerController*> value) {
    SetSchemaValueCUtlVector<GCBasePlayerController*>(m_ptr, "CTeam", "m_aPlayerControllers", false, value);
}
std::vector<GCBasePlayerPawn*> GCTeam::GetPlayers() const {
    CUtlVector<GCBasePlayerPawn*>* vec = GetSchemaValue<CUtlVector<GCBasePlayerPawn*>*>(m_ptr, "CTeam", "m_aPlayers"); std::vector<GCBasePlayerPawn*> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCTeam::SetPlayers(std::vector<GCBasePlayerPawn*> value) {
    SetSchemaValueCUtlVector<GCBasePlayerPawn*>(m_ptr, "CTeam", "m_aPlayers", false, value);
}
int32_t GCTeam::GetScore() const {
    return GetSchemaValue<int32_t>(m_ptr, "CTeam", "m_iScore");
}
void GCTeam::SetScore(int32_t value) {
    SetSchemaValue(m_ptr, "CTeam", "m_iScore", false, value);
}
std::string GCTeam::GetTeamname() const {
    return GetSchemaValuePtr<char>(m_ptr, "CTeam", "m_szTeamname");
}
void GCTeam::SetTeamname(std::string value) {
    WriteSchemaPtrValue(m_ptr, "CTeam", "m_szTeamname", false, reinterpret_cast<byte*>(const_cast<char*>(value.c_str())), 129);
}
std::string GCTeam::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCTeam::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseEntity GCTeam::GetParent() const {
    GCBaseEntity value(m_ptr);
    return value;
}
void GCTeam::SetParent(GCBaseEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCTeam(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCTeam>("CTeam")
        .addConstructor<void (*)(std::string)>()
        .addProperty("PlayerControllers", &GCTeam::GetPlayerControllers, &GCTeam::SetPlayerControllers)
        .addProperty("Players", &GCTeam::GetPlayers, &GCTeam::SetPlayers)
        .addProperty("Score", &GCTeam::GetScore, &GCTeam::SetScore)
        .addProperty("Teamname", &GCTeam::GetTeamname, &GCTeam::SetTeamname)
        .addProperty("Parent", &GCTeam::GetParent, &GCTeam::SetParent)
        .addFunction("ToPtr", &GCTeam::ToPtr)
        .addFunction("IsValid", &GCTeam::IsValid)
        .endClass();
}
GCCSGameModeRules_Deathmatch::GCCSGameModeRules_Deathmatch(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCCSGameModeRules_Deathmatch::GCCSGameModeRules_Deathmatch(void *ptr) {
    m_ptr = ptr;
}
float GCCSGameModeRules_Deathmatch::GetDMBonusStartTime() const {
    return GetSchemaValue<float>(m_ptr, "CCSGameModeRules_Deathmatch", "m_flDMBonusStartTime");
}
void GCCSGameModeRules_Deathmatch::SetDMBonusStartTime(float value) {
    SetSchemaValue(m_ptr, "CCSGameModeRules_Deathmatch", "m_flDMBonusStartTime", false, value);
}
float GCCSGameModeRules_Deathmatch::GetDMBonusTimeLength() const {
    return GetSchemaValue<float>(m_ptr, "CCSGameModeRules_Deathmatch", "m_flDMBonusTimeLength");
}
void GCCSGameModeRules_Deathmatch::SetDMBonusTimeLength(float value) {
    SetSchemaValue(m_ptr, "CCSGameModeRules_Deathmatch", "m_flDMBonusTimeLength", false, value);
}
std::string GCCSGameModeRules_Deathmatch::GetDMBonusWeapon() const {
    return GetSchemaValue<CUtlString>(m_ptr, "CCSGameModeRules_Deathmatch", "m_sDMBonusWeapon").Get();
}
void GCCSGameModeRules_Deathmatch::SetDMBonusWeapon(std::string value) {
    SetSchemaValue(m_ptr, "CCSGameModeRules_Deathmatch", "m_sDMBonusWeapon", false, CUtlString(value.c_str()));
}
std::string GCCSGameModeRules_Deathmatch::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCCSGameModeRules_Deathmatch::IsValid() {
    return (m_ptr != nullptr);
}
GCCSGameModeRules GCCSGameModeRules_Deathmatch::GetParent() const {
    GCCSGameModeRules value(m_ptr);
    return value;
}
void GCCSGameModeRules_Deathmatch::SetParent(GCCSGameModeRules value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCCSGameModeRules_Deathmatch(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCCSGameModeRules_Deathmatch>("CCSGameModeRules_Deathmatch")
        .addConstructor<void (*)(std::string)>()
        .addProperty("DMBonusStartTime", &GCCSGameModeRules_Deathmatch::GetDMBonusStartTime, &GCCSGameModeRules_Deathmatch::SetDMBonusStartTime)
        .addProperty("DMBonusTimeLength", &GCCSGameModeRules_Deathmatch::GetDMBonusTimeLength, &GCCSGameModeRules_Deathmatch::SetDMBonusTimeLength)
        .addProperty("DMBonusWeapon", &GCCSGameModeRules_Deathmatch::GetDMBonusWeapon, &GCCSGameModeRules_Deathmatch::SetDMBonusWeapon)
        .addProperty("Parent", &GCCSGameModeRules_Deathmatch::GetParent, &GCCSGameModeRules_Deathmatch::SetParent)
        .addFunction("ToPtr", &GCCSGameModeRules_Deathmatch::ToPtr)
        .addFunction("IsValid", &GCCSGameModeRules_Deathmatch::IsValid)
        .endClass();
}
GCFuncNavObstruction::GCFuncNavObstruction(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCFuncNavObstruction::GCFuncNavObstruction(void *ptr) {
    m_ptr = ptr;
}
bool GCFuncNavObstruction::GetDisabled() const {
    return GetSchemaValue<bool>(m_ptr, "CFuncNavObstruction", "m_bDisabled");
}
void GCFuncNavObstruction::SetDisabled(bool value) {
    SetSchemaValue(m_ptr, "CFuncNavObstruction", "m_bDisabled", false, value);
}
std::string GCFuncNavObstruction::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCFuncNavObstruction::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseModelEntity GCFuncNavObstruction::GetParent() const {
    GCBaseModelEntity value(m_ptr);
    return value;
}
void GCFuncNavObstruction::SetParent(GCBaseModelEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCFuncNavObstruction(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCFuncNavObstruction>("CFuncNavObstruction")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Disabled", &GCFuncNavObstruction::GetDisabled, &GCFuncNavObstruction::SetDisabled)
        .addProperty("Parent", &GCFuncNavObstruction::GetParent, &GCFuncNavObstruction::SetParent)
        .addFunction("ToPtr", &GCFuncNavObstruction::ToPtr)
        .addFunction("IsValid", &GCFuncNavObstruction::IsValid)
        .endClass();
}
GCTriggerImpact::GCTriggerImpact(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCTriggerImpact::GCTriggerImpact(void *ptr) {
    m_ptr = ptr;
}
float GCTriggerImpact::GetMagnitude() const {
    return GetSchemaValue<float>(m_ptr, "CTriggerImpact", "m_flMagnitude");
}
void GCTriggerImpact::SetMagnitude(float value) {
    SetSchemaValue(m_ptr, "CTriggerImpact", "m_flMagnitude", false, value);
}
float GCTriggerImpact::GetNoise() const {
    return GetSchemaValue<float>(m_ptr, "CTriggerImpact", "m_flNoise");
}
void GCTriggerImpact::SetNoise(float value) {
    SetSchemaValue(m_ptr, "CTriggerImpact", "m_flNoise", false, value);
}
float GCTriggerImpact::GetViewkick() const {
    return GetSchemaValue<float>(m_ptr, "CTriggerImpact", "m_flViewkick");
}
void GCTriggerImpact::SetViewkick(float value) {
    SetSchemaValue(m_ptr, "CTriggerImpact", "m_flViewkick", false, value);
}
std::string GCTriggerImpact::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCTriggerImpact::IsValid() {
    return (m_ptr != nullptr);
}
GCTriggerMultiple GCTriggerImpact::GetParent() const {
    GCTriggerMultiple value(m_ptr);
    return value;
}
void GCTriggerImpact::SetParent(GCTriggerMultiple value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCTriggerImpact(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCTriggerImpact>("CTriggerImpact")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Magnitude", &GCTriggerImpact::GetMagnitude, &GCTriggerImpact::SetMagnitude)
        .addProperty("Noise", &GCTriggerImpact::GetNoise, &GCTriggerImpact::SetNoise)
        .addProperty("Viewkick", &GCTriggerImpact::GetViewkick, &GCTriggerImpact::SetViewkick)
        .addProperty("Parent", &GCTriggerImpact::GetParent, &GCTriggerImpact::SetParent)
        .addFunction("ToPtr", &GCTriggerImpact::ToPtr)
        .addFunction("IsValid", &GCTriggerImpact::IsValid)
        .endClass();
}
GCSun::GCSun(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCSun::GCSun(void *ptr) {
    m_ptr = ptr;
}
Vector GCSun::GetDirection() const {
    return GetSchemaValue<Vector>(m_ptr, "CSun", "m_vDirection");
}
void GCSun::SetDirection(Vector value) {
    SetSchemaValue(m_ptr, "CSun", "m_vDirection", false, value);
}
Color GCSun::GetOverlay() const {
    return GetSchemaValue<Color>(m_ptr, "CSun", "m_clrOverlay");
}
void GCSun::SetOverlay(Color value) {
    SetSchemaValue(m_ptr, "CSun", "m_clrOverlay", false, value);
}
std::string GCSun::GetEffectName() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CSun", "m_iszEffectName").String();
}
void GCSun::SetEffectName(std::string value) {
    SetSchemaValue(m_ptr, "CSun", "m_iszEffectName", false, CUtlSymbolLarge(value.c_str()));
}
std::string GCSun::GetSSEffectName() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CSun", "m_iszSSEffectName").String();
}
void GCSun::SetSSEffectName(std::string value) {
    SetSchemaValue(m_ptr, "CSun", "m_iszSSEffectName", false, CUtlSymbolLarge(value.c_str()));
}
bool GCSun::GetOn() const {
    return GetSchemaValue<bool>(m_ptr, "CSun", "m_bOn");
}
void GCSun::SetOn(bool value) {
    SetSchemaValue(m_ptr, "CSun", "m_bOn", false, value);
}
bool GCSun::GetBmaxColor() const {
    return GetSchemaValue<bool>(m_ptr, "CSun", "m_bmaxColor");
}
void GCSun::SetBmaxColor(bool value) {
    SetSchemaValue(m_ptr, "CSun", "m_bmaxColor", false, value);
}
float GCSun::GetSize() const {
    return GetSchemaValue<float>(m_ptr, "CSun", "m_flSize");
}
void GCSun::SetSize(float value) {
    SetSchemaValue(m_ptr, "CSun", "m_flSize", false, value);
}
float GCSun::GetRotation() const {
    return GetSchemaValue<float>(m_ptr, "CSun", "m_flRotation");
}
void GCSun::SetRotation(float value) {
    SetSchemaValue(m_ptr, "CSun", "m_flRotation", false, value);
}
float GCSun::GetHazeScale() const {
    return GetSchemaValue<float>(m_ptr, "CSun", "m_flHazeScale");
}
void GCSun::SetHazeScale(float value) {
    SetSchemaValue(m_ptr, "CSun", "m_flHazeScale", false, value);
}
float GCSun::GetAlphaHaze() const {
    return GetSchemaValue<float>(m_ptr, "CSun", "m_flAlphaHaze");
}
void GCSun::SetAlphaHaze(float value) {
    SetSchemaValue(m_ptr, "CSun", "m_flAlphaHaze", false, value);
}
float GCSun::GetAlphaHdr() const {
    return GetSchemaValue<float>(m_ptr, "CSun", "m_flAlphaHdr");
}
void GCSun::SetAlphaHdr(float value) {
    SetSchemaValue(m_ptr, "CSun", "m_flAlphaHdr", false, value);
}
float GCSun::GetAlphaScale() const {
    return GetSchemaValue<float>(m_ptr, "CSun", "m_flAlphaScale");
}
void GCSun::SetAlphaScale(float value) {
    SetSchemaValue(m_ptr, "CSun", "m_flAlphaScale", false, value);
}
float GCSun::GetHDRColorScale() const {
    return GetSchemaValue<float>(m_ptr, "CSun", "m_flHDRColorScale");
}
void GCSun::SetHDRColorScale(float value) {
    SetSchemaValue(m_ptr, "CSun", "m_flHDRColorScale", false, value);
}
float GCSun::GetFarZScale() const {
    return GetSchemaValue<float>(m_ptr, "CSun", "m_flFarZScale");
}
void GCSun::SetFarZScale(float value) {
    SetSchemaValue(m_ptr, "CSun", "m_flFarZScale", false, value);
}
std::string GCSun::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCSun::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseModelEntity GCSun::GetParent() const {
    GCBaseModelEntity value(m_ptr);
    return value;
}
void GCSun::SetParent(GCBaseModelEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCSun(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCSun>("CSun")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Direction", &GCSun::GetDirection, &GCSun::SetDirection)
        .addProperty("Overlay", &GCSun::GetOverlay, &GCSun::SetOverlay)
        .addProperty("EffectName", &GCSun::GetEffectName, &GCSun::SetEffectName)
        .addProperty("SSEffectName", &GCSun::GetSSEffectName, &GCSun::SetSSEffectName)
        .addProperty("On", &GCSun::GetOn, &GCSun::SetOn)
        .addProperty("BmaxColor", &GCSun::GetBmaxColor, &GCSun::SetBmaxColor)
        .addProperty("Size", &GCSun::GetSize, &GCSun::SetSize)
        .addProperty("Rotation", &GCSun::GetRotation, &GCSun::SetRotation)
        .addProperty("HazeScale", &GCSun::GetHazeScale, &GCSun::SetHazeScale)
        .addProperty("AlphaHaze", &GCSun::GetAlphaHaze, &GCSun::SetAlphaHaze)
        .addProperty("AlphaHdr", &GCSun::GetAlphaHdr, &GCSun::SetAlphaHdr)
        .addProperty("AlphaScale", &GCSun::GetAlphaScale, &GCSun::SetAlphaScale)
        .addProperty("HDRColorScale", &GCSun::GetHDRColorScale, &GCSun::SetHDRColorScale)
        .addProperty("FarZScale", &GCSun::GetFarZScale, &GCSun::SetFarZScale)
        .addProperty("Parent", &GCSun::GetParent, &GCSun::SetParent)
        .addFunction("ToPtr", &GCSun::ToPtr)
        .addFunction("IsValid", &GCSun::IsValid)
        .endClass();
}
GCTriggerDetectBulletFire::GCTriggerDetectBulletFire(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCTriggerDetectBulletFire::GCTriggerDetectBulletFire(void *ptr) {
    m_ptr = ptr;
}
bool GCTriggerDetectBulletFire::GetPlayerFireOnly() const {
    return GetSchemaValue<bool>(m_ptr, "CTriggerDetectBulletFire", "m_bPlayerFireOnly");
}
void GCTriggerDetectBulletFire::SetPlayerFireOnly(bool value) {
    SetSchemaValue(m_ptr, "CTriggerDetectBulletFire", "m_bPlayerFireOnly", false, value);
}
GCEntityIOOutput GCTriggerDetectBulletFire::GetOnDetectedBulletFire() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CTriggerDetectBulletFire", "m_OnDetectedBulletFire"));
    return value;
}
void GCTriggerDetectBulletFire::SetOnDetectedBulletFire(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CTriggerDetectBulletFire", "m_OnDetectedBulletFire", false, value);
}
std::string GCTriggerDetectBulletFire::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCTriggerDetectBulletFire::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseTrigger GCTriggerDetectBulletFire::GetParent() const {
    GCBaseTrigger value(m_ptr);
    return value;
}
void GCTriggerDetectBulletFire::SetParent(GCBaseTrigger value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCTriggerDetectBulletFire(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCTriggerDetectBulletFire>("CTriggerDetectBulletFire")
        .addConstructor<void (*)(std::string)>()
        .addProperty("PlayerFireOnly", &GCTriggerDetectBulletFire::GetPlayerFireOnly, &GCTriggerDetectBulletFire::SetPlayerFireOnly)
        .addProperty("OnDetectedBulletFire", &GCTriggerDetectBulletFire::GetOnDetectedBulletFire, &GCTriggerDetectBulletFire::SetOnDetectedBulletFire)
        .addProperty("Parent", &GCTriggerDetectBulletFire::GetParent, &GCTriggerDetectBulletFire::SetParent)
        .addFunction("ToPtr", &GCTriggerDetectBulletFire::ToPtr)
        .addFunction("IsValid", &GCTriggerDetectBulletFire::IsValid)
        .endClass();
}
GCWorld::GCWorld(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCWorld::GCWorld(void *ptr) {
    m_ptr = ptr;
}
std::string GCWorld::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCWorld::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseModelEntity GCWorld::GetParent() const {
    GCBaseModelEntity value(m_ptr);
    return value;
}
void GCWorld::SetParent(GCBaseModelEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCWorld(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCWorld>("CWorld")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCWorld::GetParent, &GCWorld::SetParent)
        .addFunction("ToPtr", &GCWorld::ToPtr)
        .addFunction("IsValid", &GCWorld::IsValid)
        .endClass();
}
GCPointGiveAmmo::GCPointGiveAmmo(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCPointGiveAmmo::GCPointGiveAmmo(void *ptr) {
    m_ptr = ptr;
}
GCBaseEntity GCPointGiveAmmo::GetActivator() const {
    GCBaseEntity value(*GetSchemaValuePtr<void*>(m_ptr, "CPointGiveAmmo", "m_pActivator"));
    return value;
}
void GCPointGiveAmmo::SetActivator(GCBaseEntity* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Activator' is not possible.\n");
}
std::string GCPointGiveAmmo::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCPointGiveAmmo::IsValid() {
    return (m_ptr != nullptr);
}
GCPointEntity GCPointGiveAmmo::GetParent() const {
    GCPointEntity value(m_ptr);
    return value;
}
void GCPointGiveAmmo::SetParent(GCPointEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCPointGiveAmmo(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCPointGiveAmmo>("CPointGiveAmmo")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Activator", &GCPointGiveAmmo::GetActivator, &GCPointGiveAmmo::SetActivator)
        .addProperty("Parent", &GCPointGiveAmmo::GetParent, &GCPointGiveAmmo::SetParent)
        .addFunction("ToPtr", &GCPointGiveAmmo::ToPtr)
        .addFunction("IsValid", &GCPointGiveAmmo::IsValid)
        .endClass();
}
GCFuncMoveLinear::GCFuncMoveLinear(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCFuncMoveLinear::GCFuncMoveLinear(void *ptr) {
    m_ptr = ptr;
}
uint64_t GCFuncMoveLinear::GetAuthoredPosition() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CFuncMoveLinear", "m_authoredPosition");
}
void GCFuncMoveLinear::SetAuthoredPosition(uint64_t value) {
    SetSchemaValue(m_ptr, "CFuncMoveLinear", "m_authoredPosition", false, value);
}
QAngle GCFuncMoveLinear::GetMoveEntitySpace() const {
    return GetSchemaValue<QAngle>(m_ptr, "CFuncMoveLinear", "m_angMoveEntitySpace");
}
void GCFuncMoveLinear::SetMoveEntitySpace(QAngle value) {
    SetSchemaValue(m_ptr, "CFuncMoveLinear", "m_angMoveEntitySpace", false, value);
}
Vector GCFuncMoveLinear::GetMoveDirParentSpace() const {
    return GetSchemaValue<Vector>(m_ptr, "CFuncMoveLinear", "m_vecMoveDirParentSpace");
}
void GCFuncMoveLinear::SetMoveDirParentSpace(Vector value) {
    SetSchemaValue(m_ptr, "CFuncMoveLinear", "m_vecMoveDirParentSpace", false, value);
}
std::string GCFuncMoveLinear::GetSoundStart() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CFuncMoveLinear", "m_soundStart").String();
}
void GCFuncMoveLinear::SetSoundStart(std::string value) {
    SetSchemaValue(m_ptr, "CFuncMoveLinear", "m_soundStart", false, CUtlSymbolLarge(value.c_str()));
}
std::string GCFuncMoveLinear::GetSoundStop() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CFuncMoveLinear", "m_soundStop").String();
}
void GCFuncMoveLinear::SetSoundStop(std::string value) {
    SetSchemaValue(m_ptr, "CFuncMoveLinear", "m_soundStop", false, CUtlSymbolLarge(value.c_str()));
}
std::string GCFuncMoveLinear::GetCurrentSound() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CFuncMoveLinear", "m_currentSound").String();
}
void GCFuncMoveLinear::SetCurrentSound(std::string value) {
    SetSchemaValue(m_ptr, "CFuncMoveLinear", "m_currentSound", false, CUtlSymbolLarge(value.c_str()));
}
float GCFuncMoveLinear::GetBlockDamage() const {
    return GetSchemaValue<float>(m_ptr, "CFuncMoveLinear", "m_flBlockDamage");
}
void GCFuncMoveLinear::SetBlockDamage(float value) {
    SetSchemaValue(m_ptr, "CFuncMoveLinear", "m_flBlockDamage", false, value);
}
float GCFuncMoveLinear::GetStartPosition() const {
    return GetSchemaValue<float>(m_ptr, "CFuncMoveLinear", "m_flStartPosition");
}
void GCFuncMoveLinear::SetStartPosition(float value) {
    SetSchemaValue(m_ptr, "CFuncMoveLinear", "m_flStartPosition", false, value);
}
GCEntityIOOutput GCFuncMoveLinear::GetOnFullyOpen() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CFuncMoveLinear", "m_OnFullyOpen"));
    return value;
}
void GCFuncMoveLinear::SetOnFullyOpen(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CFuncMoveLinear", "m_OnFullyOpen", false, value);
}
GCEntityIOOutput GCFuncMoveLinear::GetOnFullyClosed() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CFuncMoveLinear", "m_OnFullyClosed"));
    return value;
}
void GCFuncMoveLinear::SetOnFullyClosed(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CFuncMoveLinear", "m_OnFullyClosed", false, value);
}
bool GCFuncMoveLinear::GetCreateMovableNavMesh() const {
    return GetSchemaValue<bool>(m_ptr, "CFuncMoveLinear", "m_bCreateMovableNavMesh");
}
void GCFuncMoveLinear::SetCreateMovableNavMesh(bool value) {
    SetSchemaValue(m_ptr, "CFuncMoveLinear", "m_bCreateMovableNavMesh", false, value);
}
bool GCFuncMoveLinear::GetCreateNavObstacle() const {
    return GetSchemaValue<bool>(m_ptr, "CFuncMoveLinear", "m_bCreateNavObstacle");
}
void GCFuncMoveLinear::SetCreateNavObstacle(bool value) {
    SetSchemaValue(m_ptr, "CFuncMoveLinear", "m_bCreateNavObstacle", false, value);
}
std::string GCFuncMoveLinear::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCFuncMoveLinear::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseToggle GCFuncMoveLinear::GetParent() const {
    GCBaseToggle value(m_ptr);
    return value;
}
void GCFuncMoveLinear::SetParent(GCBaseToggle value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCFuncMoveLinear(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCFuncMoveLinear>("CFuncMoveLinear")
        .addConstructor<void (*)(std::string)>()
        .addProperty("AuthoredPosition", &GCFuncMoveLinear::GetAuthoredPosition, &GCFuncMoveLinear::SetAuthoredPosition)
        .addProperty("MoveEntitySpace", &GCFuncMoveLinear::GetMoveEntitySpace, &GCFuncMoveLinear::SetMoveEntitySpace)
        .addProperty("MoveDirParentSpace", &GCFuncMoveLinear::GetMoveDirParentSpace, &GCFuncMoveLinear::SetMoveDirParentSpace)
        .addProperty("SoundStart", &GCFuncMoveLinear::GetSoundStart, &GCFuncMoveLinear::SetSoundStart)
        .addProperty("SoundStop", &GCFuncMoveLinear::GetSoundStop, &GCFuncMoveLinear::SetSoundStop)
        .addProperty("CurrentSound", &GCFuncMoveLinear::GetCurrentSound, &GCFuncMoveLinear::SetCurrentSound)
        .addProperty("BlockDamage", &GCFuncMoveLinear::GetBlockDamage, &GCFuncMoveLinear::SetBlockDamage)
        .addProperty("StartPosition", &GCFuncMoveLinear::GetStartPosition, &GCFuncMoveLinear::SetStartPosition)
        .addProperty("OnFullyOpen", &GCFuncMoveLinear::GetOnFullyOpen, &GCFuncMoveLinear::SetOnFullyOpen)
        .addProperty("OnFullyClosed", &GCFuncMoveLinear::GetOnFullyClosed, &GCFuncMoveLinear::SetOnFullyClosed)
        .addProperty("CreateMovableNavMesh", &GCFuncMoveLinear::GetCreateMovableNavMesh, &GCFuncMoveLinear::SetCreateMovableNavMesh)
        .addProperty("CreateNavObstacle", &GCFuncMoveLinear::GetCreateNavObstacle, &GCFuncMoveLinear::SetCreateNavObstacle)
        .addProperty("Parent", &GCFuncMoveLinear::GetParent, &GCFuncMoveLinear::SetParent)
        .addFunction("ToPtr", &GCFuncMoveLinear::ToPtr)
        .addFunction("IsValid", &GCFuncMoveLinear::IsValid)
        .endClass();
}
GCPathParticleRope::GCPathParticleRope(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCPathParticleRope::GCPathParticleRope(void *ptr) {
    m_ptr = ptr;
}
bool GCPathParticleRope::GetStartActive() const {
    return GetSchemaValue<bool>(m_ptr, "CPathParticleRope", "m_bStartActive");
}
void GCPathParticleRope::SetStartActive(bool value) {
    SetSchemaValue(m_ptr, "CPathParticleRope", "m_bStartActive", false, value);
}
float GCPathParticleRope::GetMaxSimulationTime() const {
    return GetSchemaValue<float>(m_ptr, "CPathParticleRope", "m_flMaxSimulationTime");
}
void GCPathParticleRope::SetMaxSimulationTime(float value) {
    SetSchemaValue(m_ptr, "CPathParticleRope", "m_flMaxSimulationTime", false, value);
}
std::string GCPathParticleRope::GetEffectName() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CPathParticleRope", "m_iszEffectName").String();
}
void GCPathParticleRope::SetEffectName(std::string value) {
    SetSchemaValue(m_ptr, "CPathParticleRope", "m_iszEffectName", false, CUtlSymbolLarge(value.c_str()));
}
std::vector<CUtlSymbolLarge> GCPathParticleRope::GetPathNodes_Name() const {
    CUtlVector<CUtlSymbolLarge>* vec = GetSchemaValue<CUtlVector<CUtlSymbolLarge>*>(m_ptr, "CPathParticleRope", "m_PathNodes_Name"); std::vector<CUtlSymbolLarge> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCPathParticleRope::SetPathNodes_Name(std::vector<CUtlSymbolLarge> value) {
    SetSchemaValueCUtlVector<CUtlSymbolLarge>(m_ptr, "CPathParticleRope", "m_PathNodes_Name", false, value);
}
float GCPathParticleRope::GetParticleSpacing() const {
    return GetSchemaValue<float>(m_ptr, "CPathParticleRope", "m_flParticleSpacing");
}
void GCPathParticleRope::SetParticleSpacing(float value) {
    SetSchemaValue(m_ptr, "CPathParticleRope", "m_flParticleSpacing", false, value);
}
float GCPathParticleRope::GetSlack() const {
    return GetSchemaValue<float>(m_ptr, "CPathParticleRope", "m_flSlack");
}
void GCPathParticleRope::SetSlack(float value) {
    SetSchemaValue(m_ptr, "CPathParticleRope", "m_flSlack", false, value);
}
float GCPathParticleRope::GetRadius() const {
    return GetSchemaValue<float>(m_ptr, "CPathParticleRope", "m_flRadius");
}
void GCPathParticleRope::SetRadius(float value) {
    SetSchemaValue(m_ptr, "CPathParticleRope", "m_flRadius", false, value);
}
Color GCPathParticleRope::GetColorTint() const {
    return GetSchemaValue<Color>(m_ptr, "CPathParticleRope", "m_ColorTint");
}
void GCPathParticleRope::SetColorTint(Color value) {
    SetSchemaValue(m_ptr, "CPathParticleRope", "m_ColorTint", false, value);
}
int32_t GCPathParticleRope::GetEffectState() const {
    return GetSchemaValue<int32_t>(m_ptr, "CPathParticleRope", "m_nEffectState");
}
void GCPathParticleRope::SetEffectState(int32_t value) {
    SetSchemaValue(m_ptr, "CPathParticleRope", "m_nEffectState", false, value);
}
std::vector<Vector> GCPathParticleRope::GetPathNodes_Position() const {
    CUtlVector<Vector>* vec = GetSchemaValue<CUtlVector<Vector>*>(m_ptr, "CPathParticleRope", "m_PathNodes_Position"); std::vector<Vector> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCPathParticleRope::SetPathNodes_Position(std::vector<Vector> value) {
    SetSchemaValueCUtlVector<Vector>(m_ptr, "CPathParticleRope", "m_PathNodes_Position", false, value);
}
std::vector<Vector> GCPathParticleRope::GetPathNodes_TangentIn() const {
    CUtlVector<Vector>* vec = GetSchemaValue<CUtlVector<Vector>*>(m_ptr, "CPathParticleRope", "m_PathNodes_TangentIn"); std::vector<Vector> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCPathParticleRope::SetPathNodes_TangentIn(std::vector<Vector> value) {
    SetSchemaValueCUtlVector<Vector>(m_ptr, "CPathParticleRope", "m_PathNodes_TangentIn", false, value);
}
std::vector<Vector> GCPathParticleRope::GetPathNodes_TangentOut() const {
    CUtlVector<Vector>* vec = GetSchemaValue<CUtlVector<Vector>*>(m_ptr, "CPathParticleRope", "m_PathNodes_TangentOut"); std::vector<Vector> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCPathParticleRope::SetPathNodes_TangentOut(std::vector<Vector> value) {
    SetSchemaValueCUtlVector<Vector>(m_ptr, "CPathParticleRope", "m_PathNodes_TangentOut", false, value);
}
std::vector<Vector> GCPathParticleRope::GetPathNodes_Color() const {
    CUtlVector<Vector>* vec = GetSchemaValue<CUtlVector<Vector>*>(m_ptr, "CPathParticleRope", "m_PathNodes_Color"); std::vector<Vector> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCPathParticleRope::SetPathNodes_Color(std::vector<Vector> value) {
    SetSchemaValueCUtlVector<Vector>(m_ptr, "CPathParticleRope", "m_PathNodes_Color", false, value);
}
std::vector<bool> GCPathParticleRope::GetPathNodes_PinEnabled() const {
    CUtlVector<bool>* vec = GetSchemaValue<CUtlVector<bool>*>(m_ptr, "CPathParticleRope", "m_PathNodes_PinEnabled"); std::vector<bool> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCPathParticleRope::SetPathNodes_PinEnabled(std::vector<bool> value) {
    SetSchemaValueCUtlVector<bool>(m_ptr, "CPathParticleRope", "m_PathNodes_PinEnabled", false, value);
}
std::vector<float32> GCPathParticleRope::GetPathNodes_RadiusScale() const {
    CUtlVector<float32>* vec = GetSchemaValue<CUtlVector<float32>*>(m_ptr, "CPathParticleRope", "m_PathNodes_RadiusScale"); std::vector<float32> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCPathParticleRope::SetPathNodes_RadiusScale(std::vector<float32> value) {
    SetSchemaValueCUtlVector<float32>(m_ptr, "CPathParticleRope", "m_PathNodes_RadiusScale", false, value);
}
std::string GCPathParticleRope::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCPathParticleRope::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseEntity GCPathParticleRope::GetParent() const {
    GCBaseEntity value(m_ptr);
    return value;
}
void GCPathParticleRope::SetParent(GCBaseEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCPathParticleRope(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCPathParticleRope>("CPathParticleRope")
        .addConstructor<void (*)(std::string)>()
        .addProperty("StartActive", &GCPathParticleRope::GetStartActive, &GCPathParticleRope::SetStartActive)
        .addProperty("MaxSimulationTime", &GCPathParticleRope::GetMaxSimulationTime, &GCPathParticleRope::SetMaxSimulationTime)
        .addProperty("EffectName", &GCPathParticleRope::GetEffectName, &GCPathParticleRope::SetEffectName)
        .addProperty("PathNodes_Name", &GCPathParticleRope::GetPathNodes_Name, &GCPathParticleRope::SetPathNodes_Name)
        .addProperty("ParticleSpacing", &GCPathParticleRope::GetParticleSpacing, &GCPathParticleRope::SetParticleSpacing)
        .addProperty("Slack", &GCPathParticleRope::GetSlack, &GCPathParticleRope::SetSlack)
        .addProperty("Radius", &GCPathParticleRope::GetRadius, &GCPathParticleRope::SetRadius)
        .addProperty("ColorTint", &GCPathParticleRope::GetColorTint, &GCPathParticleRope::SetColorTint)
        .addProperty("EffectState", &GCPathParticleRope::GetEffectState, &GCPathParticleRope::SetEffectState)
        .addProperty("PathNodes_Position", &GCPathParticleRope::GetPathNodes_Position, &GCPathParticleRope::SetPathNodes_Position)
        .addProperty("PathNodes_TangentIn", &GCPathParticleRope::GetPathNodes_TangentIn, &GCPathParticleRope::SetPathNodes_TangentIn)
        .addProperty("PathNodes_TangentOut", &GCPathParticleRope::GetPathNodes_TangentOut, &GCPathParticleRope::SetPathNodes_TangentOut)
        .addProperty("PathNodes_Color", &GCPathParticleRope::GetPathNodes_Color, &GCPathParticleRope::SetPathNodes_Color)
        .addProperty("PathNodes_PinEnabled", &GCPathParticleRope::GetPathNodes_PinEnabled, &GCPathParticleRope::SetPathNodes_PinEnabled)
        .addProperty("PathNodes_RadiusScale", &GCPathParticleRope::GetPathNodes_RadiusScale, &GCPathParticleRope::SetPathNodes_RadiusScale)
        .addProperty("Parent", &GCPathParticleRope::GetParent, &GCPathParticleRope::SetParent)
        .addFunction("ToPtr", &GCPathParticleRope::ToPtr)
        .addFunction("IsValid", &GCPathParticleRope::IsValid)
        .endClass();
}
GCPlayerVisibility::GCPlayerVisibility(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCPlayerVisibility::GCPlayerVisibility(void *ptr) {
    m_ptr = ptr;
}
float GCPlayerVisibility::GetVisibilityStrength() const {
    return GetSchemaValue<float>(m_ptr, "CPlayerVisibility", "m_flVisibilityStrength");
}
void GCPlayerVisibility::SetVisibilityStrength(float value) {
    SetSchemaValue(m_ptr, "CPlayerVisibility", "m_flVisibilityStrength", false, value);
}
float GCPlayerVisibility::GetFogDistanceMultiplier() const {
    return GetSchemaValue<float>(m_ptr, "CPlayerVisibility", "m_flFogDistanceMultiplier");
}
void GCPlayerVisibility::SetFogDistanceMultiplier(float value) {
    SetSchemaValue(m_ptr, "CPlayerVisibility", "m_flFogDistanceMultiplier", false, value);
}
float GCPlayerVisibility::GetFogMaxDensityMultiplier() const {
    return GetSchemaValue<float>(m_ptr, "CPlayerVisibility", "m_flFogMaxDensityMultiplier");
}
void GCPlayerVisibility::SetFogMaxDensityMultiplier(float value) {
    SetSchemaValue(m_ptr, "CPlayerVisibility", "m_flFogMaxDensityMultiplier", false, value);
}
float GCPlayerVisibility::GetFadeTime() const {
    return GetSchemaValue<float>(m_ptr, "CPlayerVisibility", "m_flFadeTime");
}
void GCPlayerVisibility::SetFadeTime(float value) {
    SetSchemaValue(m_ptr, "CPlayerVisibility", "m_flFadeTime", false, value);
}
bool GCPlayerVisibility::GetStartDisabled() const {
    return GetSchemaValue<bool>(m_ptr, "CPlayerVisibility", "m_bStartDisabled");
}
void GCPlayerVisibility::SetStartDisabled(bool value) {
    SetSchemaValue(m_ptr, "CPlayerVisibility", "m_bStartDisabled", false, value);
}
bool GCPlayerVisibility::GetIsEnabled() const {
    return GetSchemaValue<bool>(m_ptr, "CPlayerVisibility", "m_bIsEnabled");
}
void GCPlayerVisibility::SetIsEnabled(bool value) {
    SetSchemaValue(m_ptr, "CPlayerVisibility", "m_bIsEnabled", false, value);
}
std::string GCPlayerVisibility::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCPlayerVisibility::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseEntity GCPlayerVisibility::GetParent() const {
    GCBaseEntity value(m_ptr);
    return value;
}
void GCPlayerVisibility::SetParent(GCBaseEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCPlayerVisibility(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCPlayerVisibility>("CPlayerVisibility")
        .addConstructor<void (*)(std::string)>()
        .addProperty("VisibilityStrength", &GCPlayerVisibility::GetVisibilityStrength, &GCPlayerVisibility::SetVisibilityStrength)
        .addProperty("FogDistanceMultiplier", &GCPlayerVisibility::GetFogDistanceMultiplier, &GCPlayerVisibility::SetFogDistanceMultiplier)
        .addProperty("FogMaxDensityMultiplier", &GCPlayerVisibility::GetFogMaxDensityMultiplier, &GCPlayerVisibility::SetFogMaxDensityMultiplier)
        .addProperty("FadeTime", &GCPlayerVisibility::GetFadeTime, &GCPlayerVisibility::SetFadeTime)
        .addProperty("StartDisabled", &GCPlayerVisibility::GetStartDisabled, &GCPlayerVisibility::SetStartDisabled)
        .addProperty("IsEnabled", &GCPlayerVisibility::GetIsEnabled, &GCPlayerVisibility::SetIsEnabled)
        .addProperty("Parent", &GCPlayerVisibility::GetParent, &GCPlayerVisibility::SetParent)
        .addFunction("ToPtr", &GCPlayerVisibility::ToPtr)
        .addFunction("IsValid", &GCPlayerVisibility::IsValid)
        .endClass();
}
GCPointTeleport::GCPointTeleport(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCPointTeleport::GCPointTeleport(void *ptr) {
    m_ptr = ptr;
}
Vector GCPointTeleport::GetSaveOrigin() const {
    return GetSchemaValue<Vector>(m_ptr, "CPointTeleport", "m_vSaveOrigin");
}
void GCPointTeleport::SetSaveOrigin(Vector value) {
    SetSchemaValue(m_ptr, "CPointTeleport", "m_vSaveOrigin", false, value);
}
QAngle GCPointTeleport::GetSaveAngles() const {
    return GetSchemaValue<QAngle>(m_ptr, "CPointTeleport", "m_vSaveAngles");
}
void GCPointTeleport::SetSaveAngles(QAngle value) {
    SetSchemaValue(m_ptr, "CPointTeleport", "m_vSaveAngles", false, value);
}
bool GCPointTeleport::GetTeleportParentedEntities() const {
    return GetSchemaValue<bool>(m_ptr, "CPointTeleport", "m_bTeleportParentedEntities");
}
void GCPointTeleport::SetTeleportParentedEntities(bool value) {
    SetSchemaValue(m_ptr, "CPointTeleport", "m_bTeleportParentedEntities", false, value);
}
bool GCPointTeleport::GetTeleportUseCurrentAngle() const {
    return GetSchemaValue<bool>(m_ptr, "CPointTeleport", "m_bTeleportUseCurrentAngle");
}
void GCPointTeleport::SetTeleportUseCurrentAngle(bool value) {
    SetSchemaValue(m_ptr, "CPointTeleport", "m_bTeleportUseCurrentAngle", false, value);
}
std::string GCPointTeleport::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCPointTeleport::IsValid() {
    return (m_ptr != nullptr);
}
GCServerOnlyPointEntity GCPointTeleport::GetParent() const {
    GCServerOnlyPointEntity value(m_ptr);
    return value;
}
void GCPointTeleport::SetParent(GCServerOnlyPointEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCPointTeleport(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCPointTeleport>("CPointTeleport")
        .addConstructor<void (*)(std::string)>()
        .addProperty("SaveOrigin", &GCPointTeleport::GetSaveOrigin, &GCPointTeleport::SetSaveOrigin)
        .addProperty("SaveAngles", &GCPointTeleport::GetSaveAngles, &GCPointTeleport::SetSaveAngles)
        .addProperty("TeleportParentedEntities", &GCPointTeleport::GetTeleportParentedEntities, &GCPointTeleport::SetTeleportParentedEntities)
        .addProperty("TeleportUseCurrentAngle", &GCPointTeleport::GetTeleportUseCurrentAngle, &GCPointTeleport::SetTeleportUseCurrentAngle)
        .addProperty("Parent", &GCPointTeleport::GetParent, &GCPointTeleport::SetParent)
        .addFunction("ToPtr", &GCPointTeleport::ToPtr)
        .addFunction("IsValid", &GCPointTeleport::IsValid)
        .endClass();
}
GCAK47::GCAK47(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCAK47::GCAK47(void *ptr) {
    m_ptr = ptr;
}
std::string GCAK47::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCAK47::IsValid() {
    return (m_ptr != nullptr);
}
GCCSWeaponBaseGun GCAK47::GetParent() const {
    GCCSWeaponBaseGun value(m_ptr);
    return value;
}
void GCAK47::SetParent(GCCSWeaponBaseGun value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCAK47(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCAK47>("CAK47")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCAK47::GetParent, &GCAK47::SetParent)
        .addFunction("ToPtr", &GCAK47::ToPtr)
        .addFunction("IsValid", &GCAK47::IsValid)
        .endClass();
}
GCTriggerTeleport::GCTriggerTeleport(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCTriggerTeleport::GCTriggerTeleport(void *ptr) {
    m_ptr = ptr;
}
std::string GCTriggerTeleport::GetLandmark() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CTriggerTeleport", "m_iLandmark").String();
}
void GCTriggerTeleport::SetLandmark(std::string value) {
    SetSchemaValue(m_ptr, "CTriggerTeleport", "m_iLandmark", false, CUtlSymbolLarge(value.c_str()));
}
bool GCTriggerTeleport::GetUseLandmarkAngles() const {
    return GetSchemaValue<bool>(m_ptr, "CTriggerTeleport", "m_bUseLandmarkAngles");
}
void GCTriggerTeleport::SetUseLandmarkAngles(bool value) {
    SetSchemaValue(m_ptr, "CTriggerTeleport", "m_bUseLandmarkAngles", false, value);
}
bool GCTriggerTeleport::GetMirrorPlayer() const {
    return GetSchemaValue<bool>(m_ptr, "CTriggerTeleport", "m_bMirrorPlayer");
}
void GCTriggerTeleport::SetMirrorPlayer(bool value) {
    SetSchemaValue(m_ptr, "CTriggerTeleport", "m_bMirrorPlayer", false, value);
}
std::string GCTriggerTeleport::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCTriggerTeleport::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseTrigger GCTriggerTeleport::GetParent() const {
    GCBaseTrigger value(m_ptr);
    return value;
}
void GCTriggerTeleport::SetParent(GCBaseTrigger value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCTriggerTeleport(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCTriggerTeleport>("CTriggerTeleport")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Landmark", &GCTriggerTeleport::GetLandmark, &GCTriggerTeleport::SetLandmark)
        .addProperty("UseLandmarkAngles", &GCTriggerTeleport::GetUseLandmarkAngles, &GCTriggerTeleport::SetUseLandmarkAngles)
        .addProperty("MirrorPlayer", &GCTriggerTeleport::GetMirrorPlayer, &GCTriggerTeleport::SetMirrorPlayer)
        .addProperty("Parent", &GCTriggerTeleport::GetParent, &GCTriggerTeleport::SetParent)
        .addFunction("ToPtr", &GCTriggerTeleport::ToPtr)
        .addFunction("IsValid", &GCTriggerTeleport::IsValid)
        .endClass();
}
GCCSObserver_CameraServices::GCCSObserver_CameraServices(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCCSObserver_CameraServices::GCCSObserver_CameraServices(void *ptr) {
    m_ptr = ptr;
}
std::string GCCSObserver_CameraServices::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCCSObserver_CameraServices::IsValid() {
    return (m_ptr != nullptr);
}
GCCSPlayerBase_CameraServices GCCSObserver_CameraServices::GetParent() const {
    GCCSPlayerBase_CameraServices value(m_ptr);
    return value;
}
void GCCSObserver_CameraServices::SetParent(GCCSPlayerBase_CameraServices value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCCSObserver_CameraServices(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCCSObserver_CameraServices>("CCSObserver_CameraServices")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCCSObserver_CameraServices::GetParent, &GCCSObserver_CameraServices::SetParent)
        .addFunction("ToPtr", &GCCSObserver_CameraServices::ToPtr)
        .addFunction("IsValid", &GCCSObserver_CameraServices::IsValid)
        .endClass();
}
GCCSGO_TeamIntroTerroristPosition::GCCSGO_TeamIntroTerroristPosition(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCCSGO_TeamIntroTerroristPosition::GCCSGO_TeamIntroTerroristPosition(void *ptr) {
    m_ptr = ptr;
}
std::string GCCSGO_TeamIntroTerroristPosition::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCCSGO_TeamIntroTerroristPosition::IsValid() {
    return (m_ptr != nullptr);
}
GCCSGO_TeamIntroCharacterPosition GCCSGO_TeamIntroTerroristPosition::GetParent() const {
    GCCSGO_TeamIntroCharacterPosition value(m_ptr);
    return value;
}
void GCCSGO_TeamIntroTerroristPosition::SetParent(GCCSGO_TeamIntroCharacterPosition value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCCSGO_TeamIntroTerroristPosition(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCCSGO_TeamIntroTerroristPosition>("CCSGO_TeamIntroTerroristPosition")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCCSGO_TeamIntroTerroristPosition::GetParent, &GCCSGO_TeamIntroTerroristPosition::SetParent)
        .addFunction("ToPtr", &GCCSGO_TeamIntroTerroristPosition::ToPtr)
        .addFunction("IsValid", &GCCSGO_TeamIntroTerroristPosition::IsValid)
        .endClass();
}
GCFuncMover::GCFuncMover(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCFuncMover::GCFuncMover(void *ptr) {
    m_ptr = ptr;
}
std::string GCFuncMover::GetPathName() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CFuncMover", "m_iszPathName").String();
}
void GCFuncMover::SetPathName(std::string value) {
    SetSchemaValue(m_ptr, "CFuncMover", "m_iszPathName", false, CUtlSymbolLarge(value.c_str()));
}
GCPathMover GCFuncMover::GetPathMover() const {
    GCPathMover value(*GetSchemaValuePtr<void*>(m_ptr, "CFuncMover", "m_hPathMover"));
    return value;
}
void GCFuncMover::SetPathMover(GCPathMover* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'PathMover' is not possible.\n");
}
std::string GCFuncMover::GetPathNodeStart() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CFuncMover", "m_iszPathNodeStart").String();
}
void GCFuncMover::SetPathNodeStart(std::string value) {
    SetSchemaValue(m_ptr, "CFuncMover", "m_iszPathNodeStart", false, CUtlSymbolLarge(value.c_str()));
}
GCFuncMover GCFuncMover::GetMoveType() const {
    GCFuncMover value(GetSchemaPtr(m_ptr, "CFuncMover", "m_eMoveType"));
    return value;
}
void GCFuncMover::SetMoveType(GCFuncMover value) {
    SetSchemaValue(m_ptr, "CFuncMover", "m_eMoveType", false, value);
}
bool GCFuncMover::GetIsReversing() const {
    return GetSchemaValue<bool>(m_ptr, "CFuncMover", "m_bIsReversing");
}
void GCFuncMover::SetIsReversing(bool value) {
    SetSchemaValue(m_ptr, "CFuncMover", "m_bIsReversing", false, value);
}
Vector GCFuncMover::GetTarget() const {
    return GetSchemaValue<Vector>(m_ptr, "CFuncMover", "m_vTarget");
}
void GCFuncMover::SetTarget(Vector value) {
    SetSchemaValue(m_ptr, "CFuncMover", "m_vTarget", false, value);
}
float GCFuncMover::GetStartSpeed() const {
    return GetSchemaValue<float>(m_ptr, "CFuncMover", "m_flStartSpeed");
}
void GCFuncMover::SetStartSpeed(float value) {
    SetSchemaValue(m_ptr, "CFuncMover", "m_flStartSpeed", false, value);
}
float GCFuncMover::GetPathLocation() const {
    return GetSchemaValue<float>(m_ptr, "CFuncMover", "m_flPathLocation");
}
void GCFuncMover::SetPathLocation(float value) {
    SetSchemaValue(m_ptr, "CFuncMover", "m_flPathLocation", false, value);
}
float GCFuncMover::GetT() const {
    return GetSchemaValue<float>(m_ptr, "CFuncMover", "m_flT");
}
void GCFuncMover::SetT(float value) {
    SetSchemaValue(m_ptr, "CFuncMover", "m_flT", false, value);
}
int32_t GCFuncMover::GetCurrentNodeIndex() const {
    return GetSchemaValue<int32_t>(m_ptr, "CFuncMover", "m_nCurrentNodeIndex");
}
void GCFuncMover::SetCurrentNodeIndex(int32_t value) {
    SetSchemaValue(m_ptr, "CFuncMover", "m_nCurrentNodeIndex", false, value);
}
int32_t GCFuncMover::GetPreviousNodeIndex() const {
    return GetSchemaValue<int32_t>(m_ptr, "CFuncMover", "m_nPreviousNodeIndex");
}
void GCFuncMover::SetPreviousNodeIndex(int32_t value) {
    SetSchemaValue(m_ptr, "CFuncMover", "m_nPreviousNodeIndex", false, value);
}
bool GCFuncMover::GetFixedOrientation() const {
    return GetSchemaValue<bool>(m_ptr, "CFuncMover", "m_bFixedOrientation");
}
void GCFuncMover::SetFixedOrientation(bool value) {
    SetSchemaValue(m_ptr, "CFuncMover", "m_bFixedOrientation", false, value);
}
bool GCFuncMover::GetFixedPitch() const {
    return GetSchemaValue<bool>(m_ptr, "CFuncMover", "m_bFixedPitch");
}
void GCFuncMover::SetFixedPitch(bool value) {
    SetSchemaValue(m_ptr, "CFuncMover", "m_bFixedPitch", false, value);
}
uint64_t GCFuncMover::GetSolidType() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CFuncMover", "m_eSolidType");
}
void GCFuncMover::SetSolidType(uint64_t value) {
    SetSchemaValue(m_ptr, "CFuncMover", "m_eSolidType", false, value);
}
bool GCFuncMover::GetIsMoving() const {
    return GetSchemaValue<bool>(m_ptr, "CFuncMover", "m_bIsMoving");
}
void GCFuncMover::SetIsMoving(bool value) {
    SetSchemaValue(m_ptr, "CFuncMover", "m_bIsMoving", false, value);
}
float GCFuncMover::GetTimeToReachMaxSpeed() const {
    return GetSchemaValue<float>(m_ptr, "CFuncMover", "m_flTimeToReachMaxSpeed");
}
void GCFuncMover::SetTimeToReachMaxSpeed(float value) {
    SetSchemaValue(m_ptr, "CFuncMover", "m_flTimeToReachMaxSpeed", false, value);
}
float GCFuncMover::GetTimeToReachZeroSpeed() const {
    return GetSchemaValue<float>(m_ptr, "CFuncMover", "m_flTimeToReachZeroSpeed");
}
void GCFuncMover::SetTimeToReachZeroSpeed(float value) {
    SetSchemaValue(m_ptr, "CFuncMover", "m_flTimeToReachZeroSpeed", false, value);
}
float GCFuncMover::GetTimeMovementStart() const {
    return GetSchemaValue<float>(m_ptr, "CFuncMover", "m_flTimeMovementStart");
}
void GCFuncMover::SetTimeMovementStart(float value) {
    SetSchemaValue(m_ptr, "CFuncMover", "m_flTimeMovementStart", false, value);
}
float GCFuncMover::GetTimeMovementStop() const {
    return GetSchemaValue<float>(m_ptr, "CFuncMover", "m_flTimeMovementStop");
}
void GCFuncMover::SetTimeMovementStop(float value) {
    SetSchemaValue(m_ptr, "CFuncMover", "m_flTimeMovementStop", false, value);
}
GCMoverPathNode GCFuncMover::GetStopAtNode() const {
    GCMoverPathNode value(*GetSchemaValuePtr<void*>(m_ptr, "CFuncMover", "m_hStopAtNode"));
    return value;
}
void GCFuncMover::SetStopAtNode(GCMoverPathNode* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'StopAtNode' is not possible.\n");
}
float GCFuncMover::GetPathLocationToBeginStop() const {
    return GetSchemaValue<float>(m_ptr, "CFuncMover", "m_flPathLocationToBeginStop");
}
void GCFuncMover::SetPathLocationToBeginStop(float value) {
    SetSchemaValue(m_ptr, "CFuncMover", "m_flPathLocationToBeginStop", false, value);
}
bool GCFuncMover::GetMatchPathNodeUp() const {
    return GetSchemaValue<bool>(m_ptr, "CFuncMover", "m_bMatchPathNodeUp");
}
void GCFuncMover::SetMatchPathNodeUp(bool value) {
    SetSchemaValue(m_ptr, "CFuncMover", "m_bMatchPathNodeUp", false, value);
}
bool GCFuncMover::GetFacePlayer() const {
    return GetSchemaValue<bool>(m_ptr, "CFuncMover", "m_bFacePlayer");
}
void GCFuncMover::SetFacePlayer(bool value) {
    SetSchemaValue(m_ptr, "CFuncMover", "m_bFacePlayer", false, value);
}
float GCFuncMover::GetTimeStartRoll() const {
    return GetSchemaValue<float>(m_ptr, "CFuncMover", "m_flTimeStartRoll");
}
void GCFuncMover::SetTimeStartRoll(float value) {
    SetSchemaValue(m_ptr, "CFuncMover", "m_flTimeStartRoll", false, value);
}
Vector GCFuncMover::GetOriginalUp() const {
    return GetSchemaValue<Vector>(m_ptr, "CFuncMover", "m_vOriginalUp");
}
void GCFuncMover::SetOriginalUp(Vector value) {
    SetSchemaValue(m_ptr, "CFuncMover", "m_vOriginalUp", false, value);
}
float GCFuncMover::GetTimeToRollToNewUp() const {
    return GetSchemaValue<float>(m_ptr, "CFuncMover", "m_flTimeToRollToNewUp");
}
void GCFuncMover::SetTimeToRollToNewUp(float value) {
    SetSchemaValue(m_ptr, "CFuncMover", "m_flTimeToRollToNewUp", false, value);
}
std::string GCFuncMover::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCFuncMover::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseModelEntity GCFuncMover::GetParent() const {
    GCBaseModelEntity value(m_ptr);
    return value;
}
void GCFuncMover::SetParent(GCBaseModelEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCFuncMover(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCFuncMover>("CFuncMover")
        .addConstructor<void (*)(std::string)>()
        .addProperty("PathName", &GCFuncMover::GetPathName, &GCFuncMover::SetPathName)
        .addProperty("PathMover", &GCFuncMover::GetPathMover, &GCFuncMover::SetPathMover)
        .addProperty("PathNodeStart", &GCFuncMover::GetPathNodeStart, &GCFuncMover::SetPathNodeStart)
        .addProperty("MoveType", &GCFuncMover::GetMoveType, &GCFuncMover::SetMoveType)
        .addProperty("IsReversing", &GCFuncMover::GetIsReversing, &GCFuncMover::SetIsReversing)
        .addProperty("Target", &GCFuncMover::GetTarget, &GCFuncMover::SetTarget)
        .addProperty("StartSpeed", &GCFuncMover::GetStartSpeed, &GCFuncMover::SetStartSpeed)
        .addProperty("PathLocation", &GCFuncMover::GetPathLocation, &GCFuncMover::SetPathLocation)
        .addProperty("T", &GCFuncMover::GetT, &GCFuncMover::SetT)
        .addProperty("CurrentNodeIndex", &GCFuncMover::GetCurrentNodeIndex, &GCFuncMover::SetCurrentNodeIndex)
        .addProperty("PreviousNodeIndex", &GCFuncMover::GetPreviousNodeIndex, &GCFuncMover::SetPreviousNodeIndex)
        .addProperty("FixedOrientation", &GCFuncMover::GetFixedOrientation, &GCFuncMover::SetFixedOrientation)
        .addProperty("FixedPitch", &GCFuncMover::GetFixedPitch, &GCFuncMover::SetFixedPitch)
        .addProperty("SolidType", &GCFuncMover::GetSolidType, &GCFuncMover::SetSolidType)
        .addProperty("IsMoving", &GCFuncMover::GetIsMoving, &GCFuncMover::SetIsMoving)
        .addProperty("TimeToReachMaxSpeed", &GCFuncMover::GetTimeToReachMaxSpeed, &GCFuncMover::SetTimeToReachMaxSpeed)
        .addProperty("TimeToReachZeroSpeed", &GCFuncMover::GetTimeToReachZeroSpeed, &GCFuncMover::SetTimeToReachZeroSpeed)
        .addProperty("TimeMovementStart", &GCFuncMover::GetTimeMovementStart, &GCFuncMover::SetTimeMovementStart)
        .addProperty("TimeMovementStop", &GCFuncMover::GetTimeMovementStop, &GCFuncMover::SetTimeMovementStop)
        .addProperty("StopAtNode", &GCFuncMover::GetStopAtNode, &GCFuncMover::SetStopAtNode)
        .addProperty("PathLocationToBeginStop", &GCFuncMover::GetPathLocationToBeginStop, &GCFuncMover::SetPathLocationToBeginStop)
        .addProperty("MatchPathNodeUp", &GCFuncMover::GetMatchPathNodeUp, &GCFuncMover::SetMatchPathNodeUp)
        .addProperty("FacePlayer", &GCFuncMover::GetFacePlayer, &GCFuncMover::SetFacePlayer)
        .addProperty("TimeStartRoll", &GCFuncMover::GetTimeStartRoll, &GCFuncMover::SetTimeStartRoll)
        .addProperty("OriginalUp", &GCFuncMover::GetOriginalUp, &GCFuncMover::SetOriginalUp)
        .addProperty("TimeToRollToNewUp", &GCFuncMover::GetTimeToRollToNewUp, &GCFuncMover::SetTimeToRollToNewUp)
        .addProperty("Parent", &GCFuncMover::GetParent, &GCFuncMover::SetParent)
        .addFunction("ToPtr", &GCFuncMover::ToPtr)
        .addFunction("IsValid", &GCFuncMover::IsValid)
        .endClass();
}
GCCSPlayer_CameraServices::GCCSPlayer_CameraServices(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCCSPlayer_CameraServices::GCCSPlayer_CameraServices(void *ptr) {
    m_ptr = ptr;
}
std::string GCCSPlayer_CameraServices::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCCSPlayer_CameraServices::IsValid() {
    return (m_ptr != nullptr);
}
GCCSPlayerBase_CameraServices GCCSPlayer_CameraServices::GetParent() const {
    GCCSPlayerBase_CameraServices value(m_ptr);
    return value;
}
void GCCSPlayer_CameraServices::SetParent(GCCSPlayerBase_CameraServices value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCCSPlayer_CameraServices(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCCSPlayer_CameraServices>("CCSPlayer_CameraServices")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCCSPlayer_CameraServices::GetParent, &GCCSPlayer_CameraServices::SetParent)
        .addFunction("ToPtr", &GCCSPlayer_CameraServices::ToPtr)
        .addFunction("IsValid", &GCCSPlayer_CameraServices::IsValid)
        .endClass();
}
GCHEGrenade::GCHEGrenade(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCHEGrenade::GCHEGrenade(void *ptr) {
    m_ptr = ptr;
}
std::string GCHEGrenade::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCHEGrenade::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseCSGrenade GCHEGrenade::GetParent() const {
    GCBaseCSGrenade value(m_ptr);
    return value;
}
void GCHEGrenade::SetParent(GCBaseCSGrenade value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCHEGrenade(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCHEGrenade>("CHEGrenade")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCHEGrenade::GetParent, &GCHEGrenade::SetParent)
        .addFunction("ToPtr", &GCHEGrenade::ToPtr)
        .addFunction("IsValid", &GCHEGrenade::IsValid)
        .endClass();
}
GCGameEnd::GCGameEnd(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCGameEnd::GCGameEnd(void *ptr) {
    m_ptr = ptr;
}
std::string GCGameEnd::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCGameEnd::IsValid() {
    return (m_ptr != nullptr);
}
GCRulePointEntity GCGameEnd::GetParent() const {
    GCRulePointEntity value(m_ptr);
    return value;
}
void GCGameEnd::SetParent(GCRulePointEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCGameEnd(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCGameEnd>("CGameEnd")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCGameEnd::GetParent, &GCGameEnd::SetParent)
        .addFunction("ToPtr", &GCGameEnd::ToPtr)
        .addFunction("IsValid", &GCGameEnd::IsValid)
        .endClass();
}
GCTriggerCallback::GCTriggerCallback(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCTriggerCallback::GCTriggerCallback(void *ptr) {
    m_ptr = ptr;
}
std::string GCTriggerCallback::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCTriggerCallback::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseTrigger GCTriggerCallback::GetParent() const {
    GCBaseTrigger value(m_ptr);
    return value;
}
void GCTriggerCallback::SetParent(GCBaseTrigger value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCTriggerCallback(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCTriggerCallback>("CTriggerCallback")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCTriggerCallback::GetParent, &GCTriggerCallback::SetParent)
        .addFunction("ToPtr", &GCTriggerCallback::ToPtr)
        .addFunction("IsValid", &GCTriggerCallback::IsValid)
        .endClass();
}
GCBubbling::GCBubbling(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCBubbling::GCBubbling(void *ptr) {
    m_ptr = ptr;
}
int32_t GCBubbling::GetDensity() const {
    return GetSchemaValue<int32_t>(m_ptr, "CBubbling", "m_density");
}
void GCBubbling::SetDensity(int32_t value) {
    SetSchemaValue(m_ptr, "CBubbling", "m_density", false, value);
}
int32_t GCBubbling::GetFrequency() const {
    return GetSchemaValue<int32_t>(m_ptr, "CBubbling", "m_frequency");
}
void GCBubbling::SetFrequency(int32_t value) {
    SetSchemaValue(m_ptr, "CBubbling", "m_frequency", false, value);
}
int32_t GCBubbling::GetState() const {
    return GetSchemaValue<int32_t>(m_ptr, "CBubbling", "m_state");
}
void GCBubbling::SetState(int32_t value) {
    SetSchemaValue(m_ptr, "CBubbling", "m_state", false, value);
}
std::string GCBubbling::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCBubbling::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseModelEntity GCBubbling::GetParent() const {
    GCBaseModelEntity value(m_ptr);
    return value;
}
void GCBubbling::SetParent(GCBaseModelEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCBubbling(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCBubbling>("CBubbling")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Density", &GCBubbling::GetDensity, &GCBubbling::SetDensity)
        .addProperty("Frequency", &GCBubbling::GetFrequency, &GCBubbling::SetFrequency)
        .addProperty("State", &GCBubbling::GetState, &GCBubbling::SetState)
        .addProperty("Parent", &GCBubbling::GetParent, &GCBubbling::SetParent)
        .addFunction("ToPtr", &GCBubbling::ToPtr)
        .addFunction("IsValid", &GCBubbling::IsValid)
        .endClass();
}
GCTeamplayRules::GCTeamplayRules(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCTeamplayRules::GCTeamplayRules(void *ptr) {
    m_ptr = ptr;
}
std::string GCTeamplayRules::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCTeamplayRules::IsValid() {
    return (m_ptr != nullptr);
}
GCMultiplayRules GCTeamplayRules::GetParent() const {
    GCMultiplayRules value(m_ptr);
    return value;
}
void GCTeamplayRules::SetParent(GCMultiplayRules value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCTeamplayRules(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCTeamplayRules>("CTeamplayRules")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCTeamplayRules::GetParent, &GCTeamplayRules::SetParent)
        .addFunction("ToPtr", &GCTeamplayRules::ToPtr)
        .addFunction("IsValid", &GCTeamplayRules::IsValid)
        .endClass();
}
GCPhysicsPropOverride::GCPhysicsPropOverride(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCPhysicsPropOverride::GCPhysicsPropOverride(void *ptr) {
    m_ptr = ptr;
}
std::string GCPhysicsPropOverride::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCPhysicsPropOverride::IsValid() {
    return (m_ptr != nullptr);
}
GCPhysicsProp GCPhysicsPropOverride::GetParent() const {
    GCPhysicsProp value(m_ptr);
    return value;
}
void GCPhysicsPropOverride::SetParent(GCPhysicsProp value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCPhysicsPropOverride(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCPhysicsPropOverride>("CPhysicsPropOverride")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCPhysicsPropOverride::GetParent, &GCPhysicsPropOverride::SetParent)
        .addFunction("ToPtr", &GCPhysicsPropOverride::ToPtr)
        .addFunction("IsValid", &GCPhysicsPropOverride::IsValid)
        .endClass();
}
GCAI_ChangeHintGroup::GCAI_ChangeHintGroup(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCAI_ChangeHintGroup::GCAI_ChangeHintGroup(void *ptr) {
    m_ptr = ptr;
}
int32_t GCAI_ChangeHintGroup::GetSearchType() const {
    return GetSchemaValue<int32_t>(m_ptr, "CAI_ChangeHintGroup", "m_iSearchType");
}
void GCAI_ChangeHintGroup::SetSearchType(int32_t value) {
    SetSchemaValue(m_ptr, "CAI_ChangeHintGroup", "m_iSearchType", false, value);
}
std::string GCAI_ChangeHintGroup::GetStrSearchName() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CAI_ChangeHintGroup", "m_strSearchName").String();
}
void GCAI_ChangeHintGroup::SetStrSearchName(std::string value) {
    SetSchemaValue(m_ptr, "CAI_ChangeHintGroup", "m_strSearchName", false, CUtlSymbolLarge(value.c_str()));
}
std::string GCAI_ChangeHintGroup::GetStrNewHintGroup() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CAI_ChangeHintGroup", "m_strNewHintGroup").String();
}
void GCAI_ChangeHintGroup::SetStrNewHintGroup(std::string value) {
    SetSchemaValue(m_ptr, "CAI_ChangeHintGroup", "m_strNewHintGroup", false, CUtlSymbolLarge(value.c_str()));
}
float GCAI_ChangeHintGroup::GetRadius() const {
    return GetSchemaValue<float>(m_ptr, "CAI_ChangeHintGroup", "m_flRadius");
}
void GCAI_ChangeHintGroup::SetRadius(float value) {
    SetSchemaValue(m_ptr, "CAI_ChangeHintGroup", "m_flRadius", false, value);
}
std::string GCAI_ChangeHintGroup::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCAI_ChangeHintGroup::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseEntity GCAI_ChangeHintGroup::GetParent() const {
    GCBaseEntity value(m_ptr);
    return value;
}
void GCAI_ChangeHintGroup::SetParent(GCBaseEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCAI_ChangeHintGroup(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCAI_ChangeHintGroup>("CAI_ChangeHintGroup")
        .addConstructor<void (*)(std::string)>()
        .addProperty("SearchType", &GCAI_ChangeHintGroup::GetSearchType, &GCAI_ChangeHintGroup::SetSearchType)
        .addProperty("StrSearchName", &GCAI_ChangeHintGroup::GetStrSearchName, &GCAI_ChangeHintGroup::SetStrSearchName)
        .addProperty("StrNewHintGroup", &GCAI_ChangeHintGroup::GetStrNewHintGroup, &GCAI_ChangeHintGroup::SetStrNewHintGroup)
        .addProperty("Radius", &GCAI_ChangeHintGroup::GetRadius, &GCAI_ChangeHintGroup::SetRadius)
        .addProperty("Parent", &GCAI_ChangeHintGroup::GetParent, &GCAI_ChangeHintGroup::SetParent)
        .addFunction("ToPtr", &GCAI_ChangeHintGroup::ToPtr)
        .addFunction("IsValid", &GCAI_ChangeHintGroup::IsValid)
        .endClass();
}
GCColorCorrectionVolume::GCColorCorrectionVolume(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCColorCorrectionVolume::GCColorCorrectionVolume(void *ptr) {
    m_ptr = ptr;
}
bool GCColorCorrectionVolume::GetEnabled() const {
    return GetSchemaValue<bool>(m_ptr, "CColorCorrectionVolume", "m_bEnabled");
}
void GCColorCorrectionVolume::SetEnabled(bool value) {
    SetSchemaValue(m_ptr, "CColorCorrectionVolume", "m_bEnabled", false, value);
}
float GCColorCorrectionVolume::GetMaxWeight() const {
    return GetSchemaValue<float>(m_ptr, "CColorCorrectionVolume", "m_MaxWeight");
}
void GCColorCorrectionVolume::SetMaxWeight(float value) {
    SetSchemaValue(m_ptr, "CColorCorrectionVolume", "m_MaxWeight", false, value);
}
float GCColorCorrectionVolume::GetFadeDuration() const {
    return GetSchemaValue<float>(m_ptr, "CColorCorrectionVolume", "m_FadeDuration");
}
void GCColorCorrectionVolume::SetFadeDuration(float value) {
    SetSchemaValue(m_ptr, "CColorCorrectionVolume", "m_FadeDuration", false, value);
}
bool GCColorCorrectionVolume::GetStartDisabled() const {
    return GetSchemaValue<bool>(m_ptr, "CColorCorrectionVolume", "m_bStartDisabled");
}
void GCColorCorrectionVolume::SetStartDisabled(bool value) {
    SetSchemaValue(m_ptr, "CColorCorrectionVolume", "m_bStartDisabled", false, value);
}
float GCColorCorrectionVolume::GetWeight() const {
    return GetSchemaValue<float>(m_ptr, "CColorCorrectionVolume", "m_Weight");
}
void GCColorCorrectionVolume::SetWeight(float value) {
    SetSchemaValue(m_ptr, "CColorCorrectionVolume", "m_Weight", false, value);
}
std::string GCColorCorrectionVolume::GetLookupFilename() const {
    return GetSchemaValuePtr<char>(m_ptr, "CColorCorrectionVolume", "m_lookupFilename");
}
void GCColorCorrectionVolume::SetLookupFilename(std::string value) {
    WriteSchemaPtrValue(m_ptr, "CColorCorrectionVolume", "m_lookupFilename", false, reinterpret_cast<byte*>(const_cast<char*>(value.c_str())), 512);
}
float GCColorCorrectionVolume::GetLastEnterWeight() const {
    return GetSchemaValue<float>(m_ptr, "CColorCorrectionVolume", "m_LastEnterWeight");
}
void GCColorCorrectionVolume::SetLastEnterWeight(float value) {
    SetSchemaValue(m_ptr, "CColorCorrectionVolume", "m_LastEnterWeight", false, value);
}
float GCColorCorrectionVolume::GetLastEnterTime() const {
    return GetSchemaValue<float>(m_ptr, "CColorCorrectionVolume", "m_LastEnterTime");
}
void GCColorCorrectionVolume::SetLastEnterTime(float value) {
    SetSchemaValue(m_ptr, "CColorCorrectionVolume", "m_LastEnterTime", false, value);
}
float GCColorCorrectionVolume::GetLastExitWeight() const {
    return GetSchemaValue<float>(m_ptr, "CColorCorrectionVolume", "m_LastExitWeight");
}
void GCColorCorrectionVolume::SetLastExitWeight(float value) {
    SetSchemaValue(m_ptr, "CColorCorrectionVolume", "m_LastExitWeight", false, value);
}
float GCColorCorrectionVolume::GetLastExitTime() const {
    return GetSchemaValue<float>(m_ptr, "CColorCorrectionVolume", "m_LastExitTime");
}
void GCColorCorrectionVolume::SetLastExitTime(float value) {
    SetSchemaValue(m_ptr, "CColorCorrectionVolume", "m_LastExitTime", false, value);
}
std::string GCColorCorrectionVolume::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCColorCorrectionVolume::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseTrigger GCColorCorrectionVolume::GetParent() const {
    GCBaseTrigger value(m_ptr);
    return value;
}
void GCColorCorrectionVolume::SetParent(GCBaseTrigger value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCColorCorrectionVolume(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCColorCorrectionVolume>("CColorCorrectionVolume")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Enabled", &GCColorCorrectionVolume::GetEnabled, &GCColorCorrectionVolume::SetEnabled)
        .addProperty("MaxWeight", &GCColorCorrectionVolume::GetMaxWeight, &GCColorCorrectionVolume::SetMaxWeight)
        .addProperty("FadeDuration", &GCColorCorrectionVolume::GetFadeDuration, &GCColorCorrectionVolume::SetFadeDuration)
        .addProperty("StartDisabled", &GCColorCorrectionVolume::GetStartDisabled, &GCColorCorrectionVolume::SetStartDisabled)
        .addProperty("Weight", &GCColorCorrectionVolume::GetWeight, &GCColorCorrectionVolume::SetWeight)
        .addProperty("LookupFilename", &GCColorCorrectionVolume::GetLookupFilename, &GCColorCorrectionVolume::SetLookupFilename)
        .addProperty("LastEnterWeight", &GCColorCorrectionVolume::GetLastEnterWeight, &GCColorCorrectionVolume::SetLastEnterWeight)
        .addProperty("LastEnterTime", &GCColorCorrectionVolume::GetLastEnterTime, &GCColorCorrectionVolume::SetLastEnterTime)
        .addProperty("LastExitWeight", &GCColorCorrectionVolume::GetLastExitWeight, &GCColorCorrectionVolume::SetLastExitWeight)
        .addProperty("LastExitTime", &GCColorCorrectionVolume::GetLastExitTime, &GCColorCorrectionVolume::SetLastExitTime)
        .addProperty("Parent", &GCColorCorrectionVolume::GetParent, &GCColorCorrectionVolume::SetParent)
        .addFunction("ToPtr", &GCColorCorrectionVolume::ToPtr)
        .addFunction("IsValid", &GCColorCorrectionVolume::IsValid)
        .endClass();
}
GCFilterEnemy::GCFilterEnemy(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCFilterEnemy::GCFilterEnemy(void *ptr) {
    m_ptr = ptr;
}
std::string GCFilterEnemy::GetEnemyName() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CFilterEnemy", "m_iszEnemyName").String();
}
void GCFilterEnemy::SetEnemyName(std::string value) {
    SetSchemaValue(m_ptr, "CFilterEnemy", "m_iszEnemyName", false, CUtlSymbolLarge(value.c_str()));
}
float GCFilterEnemy::GetRadius() const {
    return GetSchemaValue<float>(m_ptr, "CFilterEnemy", "m_flRadius");
}
void GCFilterEnemy::SetRadius(float value) {
    SetSchemaValue(m_ptr, "CFilterEnemy", "m_flRadius", false, value);
}
float GCFilterEnemy::GetOuterRadius() const {
    return GetSchemaValue<float>(m_ptr, "CFilterEnemy", "m_flOuterRadius");
}
void GCFilterEnemy::SetOuterRadius(float value) {
    SetSchemaValue(m_ptr, "CFilterEnemy", "m_flOuterRadius", false, value);
}
int32_t GCFilterEnemy::GetMaxSquadmatesPerEnemy() const {
    return GetSchemaValue<int32_t>(m_ptr, "CFilterEnemy", "m_nMaxSquadmatesPerEnemy");
}
void GCFilterEnemy::SetMaxSquadmatesPerEnemy(int32_t value) {
    SetSchemaValue(m_ptr, "CFilterEnemy", "m_nMaxSquadmatesPerEnemy", false, value);
}
std::string GCFilterEnemy::GetPlayerName() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CFilterEnemy", "m_iszPlayerName").String();
}
void GCFilterEnemy::SetPlayerName(std::string value) {
    SetSchemaValue(m_ptr, "CFilterEnemy", "m_iszPlayerName", false, CUtlSymbolLarge(value.c_str()));
}
std::string GCFilterEnemy::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCFilterEnemy::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseFilter GCFilterEnemy::GetParent() const {
    GCBaseFilter value(m_ptr);
    return value;
}
void GCFilterEnemy::SetParent(GCBaseFilter value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCFilterEnemy(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCFilterEnemy>("CFilterEnemy")
        .addConstructor<void (*)(std::string)>()
        .addProperty("EnemyName", &GCFilterEnemy::GetEnemyName, &GCFilterEnemy::SetEnemyName)
        .addProperty("Radius", &GCFilterEnemy::GetRadius, &GCFilterEnemy::SetRadius)
        .addProperty("OuterRadius", &GCFilterEnemy::GetOuterRadius, &GCFilterEnemy::SetOuterRadius)
        .addProperty("MaxSquadmatesPerEnemy", &GCFilterEnemy::GetMaxSquadmatesPerEnemy, &GCFilterEnemy::SetMaxSquadmatesPerEnemy)
        .addProperty("PlayerName", &GCFilterEnemy::GetPlayerName, &GCFilterEnemy::SetPlayerName)
        .addProperty("Parent", &GCFilterEnemy::GetParent, &GCFilterEnemy::SetParent)
        .addFunction("ToPtr", &GCFilterEnemy::ToPtr)
        .addFunction("IsValid", &GCFilterEnemy::IsValid)
        .endClass();
}
GCShower::GCShower(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCShower::GCShower(void *ptr) {
    m_ptr = ptr;
}
std::string GCShower::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCShower::IsValid() {
    return (m_ptr != nullptr);
}
GCModelPointEntity GCShower::GetParent() const {
    GCModelPointEntity value(m_ptr);
    return value;
}
void GCShower::SetParent(GCModelPointEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCShower(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCShower>("CShower")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCShower::GetParent, &GCShower::SetParent)
        .addFunction("ToPtr", &GCShower::ToPtr)
        .addFunction("IsValid", &GCShower::IsValid)
        .endClass();
}
GCEnvCubemapFog::GCEnvCubemapFog(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCEnvCubemapFog::GCEnvCubemapFog(void *ptr) {
    m_ptr = ptr;
}
float GCEnvCubemapFog::GetEndDistance() const {
    return GetSchemaValue<float>(m_ptr, "CEnvCubemapFog", "m_flEndDistance");
}
void GCEnvCubemapFog::SetEndDistance(float value) {
    SetSchemaValue(m_ptr, "CEnvCubemapFog", "m_flEndDistance", false, value);
}
float GCEnvCubemapFog::GetStartDistance() const {
    return GetSchemaValue<float>(m_ptr, "CEnvCubemapFog", "m_flStartDistance");
}
void GCEnvCubemapFog::SetStartDistance(float value) {
    SetSchemaValue(m_ptr, "CEnvCubemapFog", "m_flStartDistance", false, value);
}
float GCEnvCubemapFog::GetFogFalloffExponent() const {
    return GetSchemaValue<float>(m_ptr, "CEnvCubemapFog", "m_flFogFalloffExponent");
}
void GCEnvCubemapFog::SetFogFalloffExponent(float value) {
    SetSchemaValue(m_ptr, "CEnvCubemapFog", "m_flFogFalloffExponent", false, value);
}
bool GCEnvCubemapFog::GetHeightFogEnabled() const {
    return GetSchemaValue<bool>(m_ptr, "CEnvCubemapFog", "m_bHeightFogEnabled");
}
void GCEnvCubemapFog::SetHeightFogEnabled(bool value) {
    SetSchemaValue(m_ptr, "CEnvCubemapFog", "m_bHeightFogEnabled", false, value);
}
float GCEnvCubemapFog::GetFogHeightWidth() const {
    return GetSchemaValue<float>(m_ptr, "CEnvCubemapFog", "m_flFogHeightWidth");
}
void GCEnvCubemapFog::SetFogHeightWidth(float value) {
    SetSchemaValue(m_ptr, "CEnvCubemapFog", "m_flFogHeightWidth", false, value);
}
float GCEnvCubemapFog::GetFogHeightEnd() const {
    return GetSchemaValue<float>(m_ptr, "CEnvCubemapFog", "m_flFogHeightEnd");
}
void GCEnvCubemapFog::SetFogHeightEnd(float value) {
    SetSchemaValue(m_ptr, "CEnvCubemapFog", "m_flFogHeightEnd", false, value);
}
float GCEnvCubemapFog::GetFogHeightStart() const {
    return GetSchemaValue<float>(m_ptr, "CEnvCubemapFog", "m_flFogHeightStart");
}
void GCEnvCubemapFog::SetFogHeightStart(float value) {
    SetSchemaValue(m_ptr, "CEnvCubemapFog", "m_flFogHeightStart", false, value);
}
float GCEnvCubemapFog::GetFogHeightExponent() const {
    return GetSchemaValue<float>(m_ptr, "CEnvCubemapFog", "m_flFogHeightExponent");
}
void GCEnvCubemapFog::SetFogHeightExponent(float value) {
    SetSchemaValue(m_ptr, "CEnvCubemapFog", "m_flFogHeightExponent", false, value);
}
float GCEnvCubemapFog::GetLODBias() const {
    return GetSchemaValue<float>(m_ptr, "CEnvCubemapFog", "m_flLODBias");
}
void GCEnvCubemapFog::SetLODBias(float value) {
    SetSchemaValue(m_ptr, "CEnvCubemapFog", "m_flLODBias", false, value);
}
bool GCEnvCubemapFog::GetActive() const {
    return GetSchemaValue<bool>(m_ptr, "CEnvCubemapFog", "m_bActive");
}
void GCEnvCubemapFog::SetActive(bool value) {
    SetSchemaValue(m_ptr, "CEnvCubemapFog", "m_bActive", false, value);
}
bool GCEnvCubemapFog::GetStartDisabled() const {
    return GetSchemaValue<bool>(m_ptr, "CEnvCubemapFog", "m_bStartDisabled");
}
void GCEnvCubemapFog::SetStartDisabled(bool value) {
    SetSchemaValue(m_ptr, "CEnvCubemapFog", "m_bStartDisabled", false, value);
}
float GCEnvCubemapFog::GetFogMaxOpacity() const {
    return GetSchemaValue<float>(m_ptr, "CEnvCubemapFog", "m_flFogMaxOpacity");
}
void GCEnvCubemapFog::SetFogMaxOpacity(float value) {
    SetSchemaValue(m_ptr, "CEnvCubemapFog", "m_flFogMaxOpacity", false, value);
}
int32_t GCEnvCubemapFog::GetCubemapSourceType() const {
    return GetSchemaValue<int32_t>(m_ptr, "CEnvCubemapFog", "m_nCubemapSourceType");
}
void GCEnvCubemapFog::SetCubemapSourceType(int32_t value) {
    SetSchemaValue(m_ptr, "CEnvCubemapFog", "m_nCubemapSourceType", false, value);
}
std::string GCEnvCubemapFog::GetSkyEntity() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CEnvCubemapFog", "m_iszSkyEntity").String();
}
void GCEnvCubemapFog::SetSkyEntity(std::string value) {
    SetSchemaValue(m_ptr, "CEnvCubemapFog", "m_iszSkyEntity", false, CUtlSymbolLarge(value.c_str()));
}
bool GCEnvCubemapFog::GetHasHeightFogEnd() const {
    return GetSchemaValue<bool>(m_ptr, "CEnvCubemapFog", "m_bHasHeightFogEnd");
}
void GCEnvCubemapFog::SetHasHeightFogEnd(bool value) {
    SetSchemaValue(m_ptr, "CEnvCubemapFog", "m_bHasHeightFogEnd", false, value);
}
bool GCEnvCubemapFog::GetFirstTime() const {
    return GetSchemaValue<bool>(m_ptr, "CEnvCubemapFog", "m_bFirstTime");
}
void GCEnvCubemapFog::SetFirstTime(bool value) {
    SetSchemaValue(m_ptr, "CEnvCubemapFog", "m_bFirstTime", false, value);
}
std::string GCEnvCubemapFog::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCEnvCubemapFog::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseEntity GCEnvCubemapFog::GetParent() const {
    GCBaseEntity value(m_ptr);
    return value;
}
void GCEnvCubemapFog::SetParent(GCBaseEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCEnvCubemapFog(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCEnvCubemapFog>("CEnvCubemapFog")
        .addConstructor<void (*)(std::string)>()
        .addProperty("EndDistance", &GCEnvCubemapFog::GetEndDistance, &GCEnvCubemapFog::SetEndDistance)
        .addProperty("StartDistance", &GCEnvCubemapFog::GetStartDistance, &GCEnvCubemapFog::SetStartDistance)
        .addProperty("FogFalloffExponent", &GCEnvCubemapFog::GetFogFalloffExponent, &GCEnvCubemapFog::SetFogFalloffExponent)
        .addProperty("HeightFogEnabled", &GCEnvCubemapFog::GetHeightFogEnabled, &GCEnvCubemapFog::SetHeightFogEnabled)
        .addProperty("FogHeightWidth", &GCEnvCubemapFog::GetFogHeightWidth, &GCEnvCubemapFog::SetFogHeightWidth)
        .addProperty("FogHeightEnd", &GCEnvCubemapFog::GetFogHeightEnd, &GCEnvCubemapFog::SetFogHeightEnd)
        .addProperty("FogHeightStart", &GCEnvCubemapFog::GetFogHeightStart, &GCEnvCubemapFog::SetFogHeightStart)
        .addProperty("FogHeightExponent", &GCEnvCubemapFog::GetFogHeightExponent, &GCEnvCubemapFog::SetFogHeightExponent)
        .addProperty("LODBias", &GCEnvCubemapFog::GetLODBias, &GCEnvCubemapFog::SetLODBias)
        .addProperty("Active", &GCEnvCubemapFog::GetActive, &GCEnvCubemapFog::SetActive)
        .addProperty("StartDisabled", &GCEnvCubemapFog::GetStartDisabled, &GCEnvCubemapFog::SetStartDisabled)
        .addProperty("FogMaxOpacity", &GCEnvCubemapFog::GetFogMaxOpacity, &GCEnvCubemapFog::SetFogMaxOpacity)
        .addProperty("CubemapSourceType", &GCEnvCubemapFog::GetCubemapSourceType, &GCEnvCubemapFog::SetCubemapSourceType)
        .addProperty("SkyEntity", &GCEnvCubemapFog::GetSkyEntity, &GCEnvCubemapFog::SetSkyEntity)
        .addProperty("HasHeightFogEnd", &GCEnvCubemapFog::GetHasHeightFogEnd, &GCEnvCubemapFog::SetHasHeightFogEnd)
        .addProperty("FirstTime", &GCEnvCubemapFog::GetFirstTime, &GCEnvCubemapFog::SetFirstTime)
        .addProperty("Parent", &GCEnvCubemapFog::GetParent, &GCEnvCubemapFog::SetParent)
        .addFunction("ToPtr", &GCEnvCubemapFog::ToPtr)
        .addFunction("IsValid", &GCEnvCubemapFog::IsValid)
        .endClass();
}
GCBaseButton::GCBaseButton(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCBaseButton::GCBaseButton(void *ptr) {
    m_ptr = ptr;
}
QAngle GCBaseButton::GetMoveEntitySpace() const {
    return GetSchemaValue<QAngle>(m_ptr, "CBaseButton", "m_angMoveEntitySpace");
}
void GCBaseButton::SetMoveEntitySpace(QAngle value) {
    SetSchemaValue(m_ptr, "CBaseButton", "m_angMoveEntitySpace", false, value);
}
bool GCBaseButton::GetStayPushed() const {
    return GetSchemaValue<bool>(m_ptr, "CBaseButton", "m_fStayPushed");
}
void GCBaseButton::SetStayPushed(bool value) {
    SetSchemaValue(m_ptr, "CBaseButton", "m_fStayPushed", false, value);
}
bool GCBaseButton::GetRotating() const {
    return GetSchemaValue<bool>(m_ptr, "CBaseButton", "m_fRotating");
}
void GCBaseButton::SetRotating(bool value) {
    SetSchemaValue(m_ptr, "CBaseButton", "m_fRotating", false, value);
}
Glocksound_t GCBaseButton::GetLs() const {
    Glocksound_t value(GetSchemaPtr(m_ptr, "CBaseButton", "m_ls"));
    return value;
}
void GCBaseButton::SetLs(Glocksound_t value) {
    SetSchemaValue(m_ptr, "CBaseButton", "m_ls", false, value);
}
std::string GCBaseButton::GetUseSound() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CBaseButton", "m_sUseSound").String();
}
void GCBaseButton::SetUseSound(std::string value) {
    SetSchemaValue(m_ptr, "CBaseButton", "m_sUseSound", false, CUtlSymbolLarge(value.c_str()));
}
std::string GCBaseButton::GetLockedSound() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CBaseButton", "m_sLockedSound").String();
}
void GCBaseButton::SetLockedSound(std::string value) {
    SetSchemaValue(m_ptr, "CBaseButton", "m_sLockedSound", false, CUtlSymbolLarge(value.c_str()));
}
std::string GCBaseButton::GetUnlockedSound() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CBaseButton", "m_sUnlockedSound").String();
}
void GCBaseButton::SetUnlockedSound(std::string value) {
    SetSchemaValue(m_ptr, "CBaseButton", "m_sUnlockedSound", false, CUtlSymbolLarge(value.c_str()));
}
std::string GCBaseButton::GetOverrideAnticipationName() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CBaseButton", "m_sOverrideAnticipationName").String();
}
void GCBaseButton::SetOverrideAnticipationName(std::string value) {
    SetSchemaValue(m_ptr, "CBaseButton", "m_sOverrideAnticipationName", false, CUtlSymbolLarge(value.c_str()));
}
bool GCBaseButton::GetLocked() const {
    return GetSchemaValue<bool>(m_ptr, "CBaseButton", "m_bLocked");
}
void GCBaseButton::SetLocked(bool value) {
    SetSchemaValue(m_ptr, "CBaseButton", "m_bLocked", false, value);
}
bool GCBaseButton::GetDisabled() const {
    return GetSchemaValue<bool>(m_ptr, "CBaseButton", "m_bDisabled");
}
void GCBaseButton::SetDisabled(bool value) {
    SetSchemaValue(m_ptr, "CBaseButton", "m_bDisabled", false, value);
}
float GCBaseButton::GetUseLockedTime() const {
    return GetSchemaValue<float>(m_ptr, "CBaseButton", "m_flUseLockedTime");
}
void GCBaseButton::SetUseLockedTime(float value) {
    SetSchemaValue(m_ptr, "CBaseButton", "m_flUseLockedTime", false, value);
}
bool GCBaseButton::GetSolidBsp() const {
    return GetSchemaValue<bool>(m_ptr, "CBaseButton", "m_bSolidBsp");
}
void GCBaseButton::SetSolidBsp(bool value) {
    SetSchemaValue(m_ptr, "CBaseButton", "m_bSolidBsp", false, value);
}
GCEntityIOOutput GCBaseButton::GetOnDamaged() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CBaseButton", "m_OnDamaged"));
    return value;
}
void GCBaseButton::SetOnDamaged(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CBaseButton", "m_OnDamaged", false, value);
}
GCEntityIOOutput GCBaseButton::GetOnPressed() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CBaseButton", "m_OnPressed"));
    return value;
}
void GCBaseButton::SetOnPressed(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CBaseButton", "m_OnPressed", false, value);
}
GCEntityIOOutput GCBaseButton::GetOnUseLocked() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CBaseButton", "m_OnUseLocked"));
    return value;
}
void GCBaseButton::SetOnUseLocked(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CBaseButton", "m_OnUseLocked", false, value);
}
GCEntityIOOutput GCBaseButton::GetOnIn() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CBaseButton", "m_OnIn"));
    return value;
}
void GCBaseButton::SetOnIn(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CBaseButton", "m_OnIn", false, value);
}
GCEntityIOOutput GCBaseButton::GetOnOut() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CBaseButton", "m_OnOut"));
    return value;
}
void GCBaseButton::SetOnOut(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CBaseButton", "m_OnOut", false, value);
}
int32_t GCBaseButton::GetState() const {
    return GetSchemaValue<int32_t>(m_ptr, "CBaseButton", "m_nState");
}
void GCBaseButton::SetState(int32_t value) {
    SetSchemaValue(m_ptr, "CBaseButton", "m_nState", false, value);
}
GCEntityInstance GCBaseButton::GetConstraint() const {
    GCEntityInstance value(*GetSchemaValuePtr<void*>(m_ptr, "CBaseButton", "m_hConstraint"));
    return value;
}
void GCBaseButton::SetConstraint(GCEntityInstance* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Constraint' is not possible.\n");
}
GCEntityInstance GCBaseButton::GetConstraintParent() const {
    GCEntityInstance value(*GetSchemaValuePtr<void*>(m_ptr, "CBaseButton", "m_hConstraintParent"));
    return value;
}
void GCBaseButton::SetConstraintParent(GCEntityInstance* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'ConstraintParent' is not possible.\n");
}
bool GCBaseButton::GetForceNpcExclude() const {
    return GetSchemaValue<bool>(m_ptr, "CBaseButton", "m_bForceNpcExclude");
}
void GCBaseButton::SetForceNpcExclude(bool value) {
    SetSchemaValue(m_ptr, "CBaseButton", "m_bForceNpcExclude", false, value);
}
std::string GCBaseButton::GetGlowEntity() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CBaseButton", "m_sGlowEntity").String();
}
void GCBaseButton::SetGlowEntity(std::string value) {
    SetSchemaValue(m_ptr, "CBaseButton", "m_sGlowEntity", false, CUtlSymbolLarge(value.c_str()));
}
GCBaseModelEntity GCBaseButton::GetGlowEntity1() const {
    GCBaseModelEntity value(*GetSchemaValuePtr<void*>(m_ptr, "CBaseButton", "m_glowEntity"));
    return value;
}
void GCBaseButton::SetGlowEntity1(GCBaseModelEntity* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'GlowEntity1' is not possible.\n");
}
bool GCBaseButton::GetUsable() const {
    return GetSchemaValue<bool>(m_ptr, "CBaseButton", "m_usable");
}
void GCBaseButton::SetUsable(bool value) {
    SetSchemaValue(m_ptr, "CBaseButton", "m_usable", false, value);
}
std::string GCBaseButton::GetDisplayText() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CBaseButton", "m_szDisplayText").String();
}
void GCBaseButton::SetDisplayText(std::string value) {
    SetSchemaValue(m_ptr, "CBaseButton", "m_szDisplayText", false, CUtlSymbolLarge(value.c_str()));
}
std::string GCBaseButton::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCBaseButton::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseToggle GCBaseButton::GetParent() const {
    GCBaseToggle value(m_ptr);
    return value;
}
void GCBaseButton::SetParent(GCBaseToggle value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCBaseButton(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCBaseButton>("CBaseButton")
        .addConstructor<void (*)(std::string)>()
        .addProperty("MoveEntitySpace", &GCBaseButton::GetMoveEntitySpace, &GCBaseButton::SetMoveEntitySpace)
        .addProperty("StayPushed", &GCBaseButton::GetStayPushed, &GCBaseButton::SetStayPushed)
        .addProperty("Rotating", &GCBaseButton::GetRotating, &GCBaseButton::SetRotating)
        .addProperty("Ls", &GCBaseButton::GetLs, &GCBaseButton::SetLs)
        .addProperty("UseSound", &GCBaseButton::GetUseSound, &GCBaseButton::SetUseSound)
        .addProperty("LockedSound", &GCBaseButton::GetLockedSound, &GCBaseButton::SetLockedSound)
        .addProperty("UnlockedSound", &GCBaseButton::GetUnlockedSound, &GCBaseButton::SetUnlockedSound)
        .addProperty("OverrideAnticipationName", &GCBaseButton::GetOverrideAnticipationName, &GCBaseButton::SetOverrideAnticipationName)
        .addProperty("Locked", &GCBaseButton::GetLocked, &GCBaseButton::SetLocked)
        .addProperty("Disabled", &GCBaseButton::GetDisabled, &GCBaseButton::SetDisabled)
        .addProperty("UseLockedTime", &GCBaseButton::GetUseLockedTime, &GCBaseButton::SetUseLockedTime)
        .addProperty("SolidBsp", &GCBaseButton::GetSolidBsp, &GCBaseButton::SetSolidBsp)
        .addProperty("OnDamaged", &GCBaseButton::GetOnDamaged, &GCBaseButton::SetOnDamaged)
        .addProperty("OnPressed", &GCBaseButton::GetOnPressed, &GCBaseButton::SetOnPressed)
        .addProperty("OnUseLocked", &GCBaseButton::GetOnUseLocked, &GCBaseButton::SetOnUseLocked)
        .addProperty("OnIn", &GCBaseButton::GetOnIn, &GCBaseButton::SetOnIn)
        .addProperty("OnOut", &GCBaseButton::GetOnOut, &GCBaseButton::SetOnOut)
        .addProperty("State", &GCBaseButton::GetState, &GCBaseButton::SetState)
        .addProperty("Constraint", &GCBaseButton::GetConstraint, &GCBaseButton::SetConstraint)
        .addProperty("ConstraintParent", &GCBaseButton::GetConstraintParent, &GCBaseButton::SetConstraintParent)
        .addProperty("ForceNpcExclude", &GCBaseButton::GetForceNpcExclude, &GCBaseButton::SetForceNpcExclude)
        .addProperty("GlowEntity", &GCBaseButton::GetGlowEntity, &GCBaseButton::SetGlowEntity)
        .addProperty("GlowEntity1", &GCBaseButton::GetGlowEntity1, &GCBaseButton::SetGlowEntity1)
        .addProperty("Usable", &GCBaseButton::GetUsable, &GCBaseButton::SetUsable)
        .addProperty("DisplayText", &GCBaseButton::GetDisplayText, &GCBaseButton::SetDisplayText)
        .addProperty("Parent", &GCBaseButton::GetParent, &GCBaseButton::SetParent)
        .addFunction("ToPtr", &GCBaseButton::ToPtr)
        .addFunction("IsValid", &GCBaseButton::IsValid)
        .endClass();
}
GCEnvExplosion::GCEnvExplosion(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCEnvExplosion::GCEnvExplosion(void *ptr) {
    m_ptr = ptr;
}
int32_t GCEnvExplosion::GetMagnitude() const {
    return GetSchemaValue<int32_t>(m_ptr, "CEnvExplosion", "m_iMagnitude");
}
void GCEnvExplosion::SetMagnitude(int32_t value) {
    SetSchemaValue(m_ptr, "CEnvExplosion", "m_iMagnitude", false, value);
}
float GCEnvExplosion::GetPlayerDamage() const {
    return GetSchemaValue<float>(m_ptr, "CEnvExplosion", "m_flPlayerDamage");
}
void GCEnvExplosion::SetPlayerDamage(float value) {
    SetSchemaValue(m_ptr, "CEnvExplosion", "m_flPlayerDamage", false, value);
}
int32_t GCEnvExplosion::GetRadiusOverride() const {
    return GetSchemaValue<int32_t>(m_ptr, "CEnvExplosion", "m_iRadiusOverride");
}
void GCEnvExplosion::SetRadiusOverride(int32_t value) {
    SetSchemaValue(m_ptr, "CEnvExplosion", "m_iRadiusOverride", false, value);
}
float GCEnvExplosion::GetInnerRadius() const {
    return GetSchemaValue<float>(m_ptr, "CEnvExplosion", "m_flInnerRadius");
}
void GCEnvExplosion::SetInnerRadius(float value) {
    SetSchemaValue(m_ptr, "CEnvExplosion", "m_flInnerRadius", false, value);
}
int32_t GCEnvExplosion::GetSpriteScale() const {
    return GetSchemaValue<int32_t>(m_ptr, "CEnvExplosion", "m_spriteScale");
}
void GCEnvExplosion::SetSpriteScale(int32_t value) {
    SetSchemaValue(m_ptr, "CEnvExplosion", "m_spriteScale", false, value);
}
float GCEnvExplosion::GetDamageForce() const {
    return GetSchemaValue<float>(m_ptr, "CEnvExplosion", "m_flDamageForce");
}
void GCEnvExplosion::SetDamageForce(float value) {
    SetSchemaValue(m_ptr, "CEnvExplosion", "m_flDamageForce", false, value);
}
GCBaseEntity GCEnvExplosion::GetInflictor() const {
    GCBaseEntity value(*GetSchemaValuePtr<void*>(m_ptr, "CEnvExplosion", "m_hInflictor"));
    return value;
}
void GCEnvExplosion::SetInflictor(GCBaseEntity* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Inflictor' is not possible.\n");
}
int32_t GCEnvExplosion::GetCustomDamageType() const {
    return GetSchemaValue<int32_t>(m_ptr, "CEnvExplosion", "m_iCustomDamageType");
}
void GCEnvExplosion::SetCustomDamageType(int32_t value) {
    SetSchemaValue(m_ptr, "CEnvExplosion", "m_iCustomDamageType", false, value);
}
std::string GCEnvExplosion::GetExplosionType() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CEnvExplosion", "m_iszExplosionType").String();
}
void GCEnvExplosion::SetExplosionType(std::string value) {
    SetSchemaValue(m_ptr, "CEnvExplosion", "m_iszExplosionType", false, CUtlSymbolLarge(value.c_str()));
}
std::string GCEnvExplosion::GetCustomEffectName() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CEnvExplosion", "m_iszCustomEffectName").String();
}
void GCEnvExplosion::SetCustomEffectName(std::string value) {
    SetSchemaValue(m_ptr, "CEnvExplosion", "m_iszCustomEffectName", false, CUtlSymbolLarge(value.c_str()));
}
std::string GCEnvExplosion::GetCustomSoundName() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CEnvExplosion", "m_iszCustomSoundName").String();
}
void GCEnvExplosion::SetCustomSoundName(std::string value) {
    SetSchemaValue(m_ptr, "CEnvExplosion", "m_iszCustomSoundName", false, CUtlSymbolLarge(value.c_str()));
}
uint64_t GCEnvExplosion::GetClassIgnore() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CEnvExplosion", "m_iClassIgnore");
}
void GCEnvExplosion::SetClassIgnore(uint64_t value) {
    SetSchemaValue(m_ptr, "CEnvExplosion", "m_iClassIgnore", false, value);
}
uint64_t GCEnvExplosion::GetClassIgnore2() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CEnvExplosion", "m_iClassIgnore2");
}
void GCEnvExplosion::SetClassIgnore2(uint64_t value) {
    SetSchemaValue(m_ptr, "CEnvExplosion", "m_iClassIgnore2", false, value);
}
std::string GCEnvExplosion::GetEntityIgnoreName() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CEnvExplosion", "m_iszEntityIgnoreName").String();
}
void GCEnvExplosion::SetEntityIgnoreName(std::string value) {
    SetSchemaValue(m_ptr, "CEnvExplosion", "m_iszEntityIgnoreName", false, CUtlSymbolLarge(value.c_str()));
}
GCBaseEntity GCEnvExplosion::GetEntityIgnore() const {
    GCBaseEntity value(*GetSchemaValuePtr<void*>(m_ptr, "CEnvExplosion", "m_hEntityIgnore"));
    return value;
}
void GCEnvExplosion::SetEntityIgnore(GCBaseEntity* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'EntityIgnore' is not possible.\n");
}
std::string GCEnvExplosion::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCEnvExplosion::IsValid() {
    return (m_ptr != nullptr);
}
GCModelPointEntity GCEnvExplosion::GetParent() const {
    GCModelPointEntity value(m_ptr);
    return value;
}
void GCEnvExplosion::SetParent(GCModelPointEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCEnvExplosion(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCEnvExplosion>("CEnvExplosion")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Magnitude", &GCEnvExplosion::GetMagnitude, &GCEnvExplosion::SetMagnitude)
        .addProperty("PlayerDamage", &GCEnvExplosion::GetPlayerDamage, &GCEnvExplosion::SetPlayerDamage)
        .addProperty("RadiusOverride", &GCEnvExplosion::GetRadiusOverride, &GCEnvExplosion::SetRadiusOverride)
        .addProperty("InnerRadius", &GCEnvExplosion::GetInnerRadius, &GCEnvExplosion::SetInnerRadius)
        .addProperty("SpriteScale", &GCEnvExplosion::GetSpriteScale, &GCEnvExplosion::SetSpriteScale)
        .addProperty("DamageForce", &GCEnvExplosion::GetDamageForce, &GCEnvExplosion::SetDamageForce)
        .addProperty("Inflictor", &GCEnvExplosion::GetInflictor, &GCEnvExplosion::SetInflictor)
        .addProperty("CustomDamageType", &GCEnvExplosion::GetCustomDamageType, &GCEnvExplosion::SetCustomDamageType)
        .addProperty("ExplosionType", &GCEnvExplosion::GetExplosionType, &GCEnvExplosion::SetExplosionType)
        .addProperty("CustomEffectName", &GCEnvExplosion::GetCustomEffectName, &GCEnvExplosion::SetCustomEffectName)
        .addProperty("CustomSoundName", &GCEnvExplosion::GetCustomSoundName, &GCEnvExplosion::SetCustomSoundName)
        .addProperty("ClassIgnore", &GCEnvExplosion::GetClassIgnore, &GCEnvExplosion::SetClassIgnore)
        .addProperty("ClassIgnore2", &GCEnvExplosion::GetClassIgnore2, &GCEnvExplosion::SetClassIgnore2)
        .addProperty("EntityIgnoreName", &GCEnvExplosion::GetEntityIgnoreName, &GCEnvExplosion::SetEntityIgnoreName)
        .addProperty("EntityIgnore", &GCEnvExplosion::GetEntityIgnore, &GCEnvExplosion::SetEntityIgnore)
        .addProperty("Parent", &GCEnvExplosion::GetParent, &GCEnvExplosion::SetParent)
        .addFunction("ToPtr", &GCEnvExplosion::ToPtr)
        .addFunction("IsValid", &GCEnvExplosion::IsValid)
        .endClass();
}
GCSoundEventAABBEntity::GCSoundEventAABBEntity(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCSoundEventAABBEntity::GCSoundEventAABBEntity(void *ptr) {
    m_ptr = ptr;
}
Vector GCSoundEventAABBEntity::GetMins() const {
    return GetSchemaValue<Vector>(m_ptr, "CSoundEventAABBEntity", "m_vMins");
}
void GCSoundEventAABBEntity::SetMins(Vector value) {
    SetSchemaValue(m_ptr, "CSoundEventAABBEntity", "m_vMins", false, value);
}
Vector GCSoundEventAABBEntity::GetMaxs() const {
    return GetSchemaValue<Vector>(m_ptr, "CSoundEventAABBEntity", "m_vMaxs");
}
void GCSoundEventAABBEntity::SetMaxs(Vector value) {
    SetSchemaValue(m_ptr, "CSoundEventAABBEntity", "m_vMaxs", false, value);
}
std::string GCSoundEventAABBEntity::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCSoundEventAABBEntity::IsValid() {
    return (m_ptr != nullptr);
}
GCSoundEventEntity GCSoundEventAABBEntity::GetParent() const {
    GCSoundEventEntity value(m_ptr);
    return value;
}
void GCSoundEventAABBEntity::SetParent(GCSoundEventEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCSoundEventAABBEntity(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCSoundEventAABBEntity>("CSoundEventAABBEntity")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Mins", &GCSoundEventAABBEntity::GetMins, &GCSoundEventAABBEntity::SetMins)
        .addProperty("Maxs", &GCSoundEventAABBEntity::GetMaxs, &GCSoundEventAABBEntity::SetMaxs)
        .addProperty("Parent", &GCSoundEventAABBEntity::GetParent, &GCSoundEventAABBEntity::SetParent)
        .addFunction("ToPtr", &GCSoundEventAABBEntity::ToPtr)
        .addFunction("IsValid", &GCSoundEventAABBEntity::IsValid)
        .endClass();
}
GCTriggerLook::GCTriggerLook(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCTriggerLook::GCTriggerLook(void *ptr) {
    m_ptr = ptr;
}
GCBaseEntity GCTriggerLook::GetLookTarget() const {
    GCBaseEntity value(*GetSchemaValuePtr<void*>(m_ptr, "CTriggerLook", "m_hLookTarget"));
    return value;
}
void GCTriggerLook::SetLookTarget(GCBaseEntity* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'LookTarget' is not possible.\n");
}
float GCTriggerLook::GetFieldOfView() const {
    return GetSchemaValue<float>(m_ptr, "CTriggerLook", "m_flFieldOfView");
}
void GCTriggerLook::SetFieldOfView(float value) {
    SetSchemaValue(m_ptr, "CTriggerLook", "m_flFieldOfView", false, value);
}
float GCTriggerLook::GetLookTime() const {
    return GetSchemaValue<float>(m_ptr, "CTriggerLook", "m_flLookTime");
}
void GCTriggerLook::SetLookTime(float value) {
    SetSchemaValue(m_ptr, "CTriggerLook", "m_flLookTime", false, value);
}
float GCTriggerLook::GetLookTimeTotal() const {
    return GetSchemaValue<float>(m_ptr, "CTriggerLook", "m_flLookTimeTotal");
}
void GCTriggerLook::SetLookTimeTotal(float value) {
    SetSchemaValue(m_ptr, "CTriggerLook", "m_flLookTimeTotal", false, value);
}
float GCTriggerLook::GetLookTimeLast() const {
    return GetSchemaValue<float>(m_ptr, "CTriggerLook", "m_flLookTimeLast");
}
void GCTriggerLook::SetLookTimeLast(float value) {
    SetSchemaValue(m_ptr, "CTriggerLook", "m_flLookTimeLast", false, value);
}
float GCTriggerLook::GetTimeoutDuration() const {
    return GetSchemaValue<float>(m_ptr, "CTriggerLook", "m_flTimeoutDuration");
}
void GCTriggerLook::SetTimeoutDuration(float value) {
    SetSchemaValue(m_ptr, "CTriggerLook", "m_flTimeoutDuration", false, value);
}
bool GCTriggerLook::GetTimeoutFired() const {
    return GetSchemaValue<bool>(m_ptr, "CTriggerLook", "m_bTimeoutFired");
}
void GCTriggerLook::SetTimeoutFired(bool value) {
    SetSchemaValue(m_ptr, "CTriggerLook", "m_bTimeoutFired", false, value);
}
bool GCTriggerLook::GetIsLooking() const {
    return GetSchemaValue<bool>(m_ptr, "CTriggerLook", "m_bIsLooking");
}
void GCTriggerLook::SetIsLooking(bool value) {
    SetSchemaValue(m_ptr, "CTriggerLook", "m_bIsLooking", false, value);
}
bool GCTriggerLook::Get2DFOV() const {
    return GetSchemaValue<bool>(m_ptr, "CTriggerLook", "m_b2DFOV");
}
void GCTriggerLook::Set2DFOV(bool value) {
    SetSchemaValue(m_ptr, "CTriggerLook", "m_b2DFOV", false, value);
}
bool GCTriggerLook::GetUseVelocity() const {
    return GetSchemaValue<bool>(m_ptr, "CTriggerLook", "m_bUseVelocity");
}
void GCTriggerLook::SetUseVelocity(bool value) {
    SetSchemaValue(m_ptr, "CTriggerLook", "m_bUseVelocity", false, value);
}
bool GCTriggerLook::GetTestOcclusion() const {
    return GetSchemaValue<bool>(m_ptr, "CTriggerLook", "m_bTestOcclusion");
}
void GCTriggerLook::SetTestOcclusion(bool value) {
    SetSchemaValue(m_ptr, "CTriggerLook", "m_bTestOcclusion", false, value);
}
GCEntityIOOutput GCTriggerLook::GetOnTimeout() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CTriggerLook", "m_OnTimeout"));
    return value;
}
void GCTriggerLook::SetOnTimeout(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CTriggerLook", "m_OnTimeout", false, value);
}
GCEntityIOOutput GCTriggerLook::GetOnStartLook() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CTriggerLook", "m_OnStartLook"));
    return value;
}
void GCTriggerLook::SetOnStartLook(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CTriggerLook", "m_OnStartLook", false, value);
}
GCEntityIOOutput GCTriggerLook::GetOnEndLook() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CTriggerLook", "m_OnEndLook"));
    return value;
}
void GCTriggerLook::SetOnEndLook(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CTriggerLook", "m_OnEndLook", false, value);
}
std::string GCTriggerLook::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCTriggerLook::IsValid() {
    return (m_ptr != nullptr);
}
GCTriggerOnce GCTriggerLook::GetParent() const {
    GCTriggerOnce value(m_ptr);
    return value;
}
void GCTriggerLook::SetParent(GCTriggerOnce value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCTriggerLook(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCTriggerLook>("CTriggerLook")
        .addConstructor<void (*)(std::string)>()
        .addProperty("LookTarget", &GCTriggerLook::GetLookTarget, &GCTriggerLook::SetLookTarget)
        .addProperty("FieldOfView", &GCTriggerLook::GetFieldOfView, &GCTriggerLook::SetFieldOfView)
        .addProperty("LookTime", &GCTriggerLook::GetLookTime, &GCTriggerLook::SetLookTime)
        .addProperty("LookTimeTotal", &GCTriggerLook::GetLookTimeTotal, &GCTriggerLook::SetLookTimeTotal)
        .addProperty("LookTimeLast", &GCTriggerLook::GetLookTimeLast, &GCTriggerLook::SetLookTimeLast)
        .addProperty("TimeoutDuration", &GCTriggerLook::GetTimeoutDuration, &GCTriggerLook::SetTimeoutDuration)
        .addProperty("TimeoutFired", &GCTriggerLook::GetTimeoutFired, &GCTriggerLook::SetTimeoutFired)
        .addProperty("IsLooking", &GCTriggerLook::GetIsLooking, &GCTriggerLook::SetIsLooking)
        .addProperty("2DFOV", &GCTriggerLook::Get2DFOV, &GCTriggerLook::Set2DFOV)
        .addProperty("UseVelocity", &GCTriggerLook::GetUseVelocity, &GCTriggerLook::SetUseVelocity)
        .addProperty("TestOcclusion", &GCTriggerLook::GetTestOcclusion, &GCTriggerLook::SetTestOcclusion)
        .addProperty("OnTimeout", &GCTriggerLook::GetOnTimeout, &GCTriggerLook::SetOnTimeout)
        .addProperty("OnStartLook", &GCTriggerLook::GetOnStartLook, &GCTriggerLook::SetOnStartLook)
        .addProperty("OnEndLook", &GCTriggerLook::GetOnEndLook, &GCTriggerLook::SetOnEndLook)
        .addProperty("Parent", &GCTriggerLook::GetParent, &GCTriggerLook::SetParent)
        .addFunction("ToPtr", &GCTriggerLook::ToPtr)
        .addFunction("IsValid", &GCTriggerLook::IsValid)
        .endClass();
}
GCEntitySubclassVDataBase::GCEntitySubclassVDataBase(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCEntitySubclassVDataBase::GCEntitySubclassVDataBase(void *ptr) {
    m_ptr = ptr;
}
std::string GCEntitySubclassVDataBase::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCEntitySubclassVDataBase::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCEntitySubclassVDataBase(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCEntitySubclassVDataBase>("CEntitySubclassVDataBase")
        .addConstructor<void (*)(std::string)>()
        .addFunction("ToPtr", &GCEntitySubclassVDataBase::ToPtr)
        .addFunction("IsValid", &GCEntitySubclassVDataBase::IsValid)
        .endClass();
}
GCLogicProximity::GCLogicProximity(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCLogicProximity::GCLogicProximity(void *ptr) {
    m_ptr = ptr;
}
std::string GCLogicProximity::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCLogicProximity::IsValid() {
    return (m_ptr != nullptr);
}
GCPointEntity GCLogicProximity::GetParent() const {
    GCPointEntity value(m_ptr);
    return value;
}
void GCLogicProximity::SetParent(GCPointEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCLogicProximity(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCLogicProximity>("CLogicProximity")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCLogicProximity::GetParent, &GCLogicProximity::SetParent)
        .addFunction("ToPtr", &GCLogicProximity::ToPtr)
        .addFunction("IsValid", &GCLogicProximity::IsValid)
        .endClass();
}
GCPointClientUIWorldPanel::GCPointClientUIWorldPanel(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCPointClientUIWorldPanel::GCPointClientUIWorldPanel(void *ptr) {
    m_ptr = ptr;
}
bool GCPointClientUIWorldPanel::GetIgnoreInput() const {
    return GetSchemaValue<bool>(m_ptr, "CPointClientUIWorldPanel", "m_bIgnoreInput");
}
void GCPointClientUIWorldPanel::SetIgnoreInput(bool value) {
    SetSchemaValue(m_ptr, "CPointClientUIWorldPanel", "m_bIgnoreInput", false, value);
}
bool GCPointClientUIWorldPanel::GetLit() const {
    return GetSchemaValue<bool>(m_ptr, "CPointClientUIWorldPanel", "m_bLit");
}
void GCPointClientUIWorldPanel::SetLit(bool value) {
    SetSchemaValue(m_ptr, "CPointClientUIWorldPanel", "m_bLit", false, value);
}
bool GCPointClientUIWorldPanel::GetFollowPlayerAcrossTeleport() const {
    return GetSchemaValue<bool>(m_ptr, "CPointClientUIWorldPanel", "m_bFollowPlayerAcrossTeleport");
}
void GCPointClientUIWorldPanel::SetFollowPlayerAcrossTeleport(bool value) {
    SetSchemaValue(m_ptr, "CPointClientUIWorldPanel", "m_bFollowPlayerAcrossTeleport", false, value);
}
float GCPointClientUIWorldPanel::GetWidth() const {
    return GetSchemaValue<float>(m_ptr, "CPointClientUIWorldPanel", "m_flWidth");
}
void GCPointClientUIWorldPanel::SetWidth(float value) {
    SetSchemaValue(m_ptr, "CPointClientUIWorldPanel", "m_flWidth", false, value);
}
float GCPointClientUIWorldPanel::GetHeight() const {
    return GetSchemaValue<float>(m_ptr, "CPointClientUIWorldPanel", "m_flHeight");
}
void GCPointClientUIWorldPanel::SetHeight(float value) {
    SetSchemaValue(m_ptr, "CPointClientUIWorldPanel", "m_flHeight", false, value);
}
float GCPointClientUIWorldPanel::GetDPI() const {
    return GetSchemaValue<float>(m_ptr, "CPointClientUIWorldPanel", "m_flDPI");
}
void GCPointClientUIWorldPanel::SetDPI(float value) {
    SetSchemaValue(m_ptr, "CPointClientUIWorldPanel", "m_flDPI", false, value);
}
float GCPointClientUIWorldPanel::GetInteractDistance() const {
    return GetSchemaValue<float>(m_ptr, "CPointClientUIWorldPanel", "m_flInteractDistance");
}
void GCPointClientUIWorldPanel::SetInteractDistance(float value) {
    SetSchemaValue(m_ptr, "CPointClientUIWorldPanel", "m_flInteractDistance", false, value);
}
float GCPointClientUIWorldPanel::GetDepthOffset() const {
    return GetSchemaValue<float>(m_ptr, "CPointClientUIWorldPanel", "m_flDepthOffset");
}
void GCPointClientUIWorldPanel::SetDepthOffset(float value) {
    SetSchemaValue(m_ptr, "CPointClientUIWorldPanel", "m_flDepthOffset", false, value);
}
uint32_t GCPointClientUIWorldPanel::GetOwnerContext() const {
    return GetSchemaValue<uint32_t>(m_ptr, "CPointClientUIWorldPanel", "m_unOwnerContext");
}
void GCPointClientUIWorldPanel::SetOwnerContext(uint32_t value) {
    SetSchemaValue(m_ptr, "CPointClientUIWorldPanel", "m_unOwnerContext", false, value);
}
uint32_t GCPointClientUIWorldPanel::GetHorizontalAlign() const {
    return GetSchemaValue<uint32_t>(m_ptr, "CPointClientUIWorldPanel", "m_unHorizontalAlign");
}
void GCPointClientUIWorldPanel::SetHorizontalAlign(uint32_t value) {
    SetSchemaValue(m_ptr, "CPointClientUIWorldPanel", "m_unHorizontalAlign", false, value);
}
uint32_t GCPointClientUIWorldPanel::GetVerticalAlign() const {
    return GetSchemaValue<uint32_t>(m_ptr, "CPointClientUIWorldPanel", "m_unVerticalAlign");
}
void GCPointClientUIWorldPanel::SetVerticalAlign(uint32_t value) {
    SetSchemaValue(m_ptr, "CPointClientUIWorldPanel", "m_unVerticalAlign", false, value);
}
uint32_t GCPointClientUIWorldPanel::GetOrientation() const {
    return GetSchemaValue<uint32_t>(m_ptr, "CPointClientUIWorldPanel", "m_unOrientation");
}
void GCPointClientUIWorldPanel::SetOrientation(uint32_t value) {
    SetSchemaValue(m_ptr, "CPointClientUIWorldPanel", "m_unOrientation", false, value);
}
bool GCPointClientUIWorldPanel::GetAllowInteractionFromAllSceneWorlds() const {
    return GetSchemaValue<bool>(m_ptr, "CPointClientUIWorldPanel", "m_bAllowInteractionFromAllSceneWorlds");
}
void GCPointClientUIWorldPanel::SetAllowInteractionFromAllSceneWorlds(bool value) {
    SetSchemaValue(m_ptr, "CPointClientUIWorldPanel", "m_bAllowInteractionFromAllSceneWorlds", false, value);
}
std::vector<CUtlSymbolLarge> GCPointClientUIWorldPanel::GetCSSClasses() const {
    CUtlVector<CUtlSymbolLarge>* vec = GetSchemaValue<CUtlVector<CUtlSymbolLarge>*>(m_ptr, "CPointClientUIWorldPanel", "m_vecCSSClasses"); std::vector<CUtlSymbolLarge> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCPointClientUIWorldPanel::SetCSSClasses(std::vector<CUtlSymbolLarge> value) {
    SetSchemaValueCUtlVector<CUtlSymbolLarge>(m_ptr, "CPointClientUIWorldPanel", "m_vecCSSClasses", false, value);
}
bool GCPointClientUIWorldPanel::GetOpaque() const {
    return GetSchemaValue<bool>(m_ptr, "CPointClientUIWorldPanel", "m_bOpaque");
}
void GCPointClientUIWorldPanel::SetOpaque(bool value) {
    SetSchemaValue(m_ptr, "CPointClientUIWorldPanel", "m_bOpaque", false, value);
}
bool GCPointClientUIWorldPanel::GetNoDepth() const {
    return GetSchemaValue<bool>(m_ptr, "CPointClientUIWorldPanel", "m_bNoDepth");
}
void GCPointClientUIWorldPanel::SetNoDepth(bool value) {
    SetSchemaValue(m_ptr, "CPointClientUIWorldPanel", "m_bNoDepth", false, value);
}
bool GCPointClientUIWorldPanel::GetRenderBackface() const {
    return GetSchemaValue<bool>(m_ptr, "CPointClientUIWorldPanel", "m_bRenderBackface");
}
void GCPointClientUIWorldPanel::SetRenderBackface(bool value) {
    SetSchemaValue(m_ptr, "CPointClientUIWorldPanel", "m_bRenderBackface", false, value);
}
bool GCPointClientUIWorldPanel::GetUseOffScreenIndicator() const {
    return GetSchemaValue<bool>(m_ptr, "CPointClientUIWorldPanel", "m_bUseOffScreenIndicator");
}
void GCPointClientUIWorldPanel::SetUseOffScreenIndicator(bool value) {
    SetSchemaValue(m_ptr, "CPointClientUIWorldPanel", "m_bUseOffScreenIndicator", false, value);
}
bool GCPointClientUIWorldPanel::GetExcludeFromSaveGames() const {
    return GetSchemaValue<bool>(m_ptr, "CPointClientUIWorldPanel", "m_bExcludeFromSaveGames");
}
void GCPointClientUIWorldPanel::SetExcludeFromSaveGames(bool value) {
    SetSchemaValue(m_ptr, "CPointClientUIWorldPanel", "m_bExcludeFromSaveGames", false, value);
}
bool GCPointClientUIWorldPanel::GetGrabbable() const {
    return GetSchemaValue<bool>(m_ptr, "CPointClientUIWorldPanel", "m_bGrabbable");
}
void GCPointClientUIWorldPanel::SetGrabbable(bool value) {
    SetSchemaValue(m_ptr, "CPointClientUIWorldPanel", "m_bGrabbable", false, value);
}
bool GCPointClientUIWorldPanel::GetOnlyRenderToTexture() const {
    return GetSchemaValue<bool>(m_ptr, "CPointClientUIWorldPanel", "m_bOnlyRenderToTexture");
}
void GCPointClientUIWorldPanel::SetOnlyRenderToTexture(bool value) {
    SetSchemaValue(m_ptr, "CPointClientUIWorldPanel", "m_bOnlyRenderToTexture", false, value);
}
bool GCPointClientUIWorldPanel::GetDisableMipGen() const {
    return GetSchemaValue<bool>(m_ptr, "CPointClientUIWorldPanel", "m_bDisableMipGen");
}
void GCPointClientUIWorldPanel::SetDisableMipGen(bool value) {
    SetSchemaValue(m_ptr, "CPointClientUIWorldPanel", "m_bDisableMipGen", false, value);
}
int32_t GCPointClientUIWorldPanel::GetExplicitImageLayout() const {
    return GetSchemaValue<int32_t>(m_ptr, "CPointClientUIWorldPanel", "m_nExplicitImageLayout");
}
void GCPointClientUIWorldPanel::SetExplicitImageLayout(int32_t value) {
    SetSchemaValue(m_ptr, "CPointClientUIWorldPanel", "m_nExplicitImageLayout", false, value);
}
std::string GCPointClientUIWorldPanel::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCPointClientUIWorldPanel::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseClientUIEntity GCPointClientUIWorldPanel::GetParent() const {
    GCBaseClientUIEntity value(m_ptr);
    return value;
}
void GCPointClientUIWorldPanel::SetParent(GCBaseClientUIEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCPointClientUIWorldPanel(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCPointClientUIWorldPanel>("CPointClientUIWorldPanel")
        .addConstructor<void (*)(std::string)>()
        .addProperty("IgnoreInput", &GCPointClientUIWorldPanel::GetIgnoreInput, &GCPointClientUIWorldPanel::SetIgnoreInput)
        .addProperty("Lit", &GCPointClientUIWorldPanel::GetLit, &GCPointClientUIWorldPanel::SetLit)
        .addProperty("FollowPlayerAcrossTeleport", &GCPointClientUIWorldPanel::GetFollowPlayerAcrossTeleport, &GCPointClientUIWorldPanel::SetFollowPlayerAcrossTeleport)
        .addProperty("Width", &GCPointClientUIWorldPanel::GetWidth, &GCPointClientUIWorldPanel::SetWidth)
        .addProperty("Height", &GCPointClientUIWorldPanel::GetHeight, &GCPointClientUIWorldPanel::SetHeight)
        .addProperty("DPI", &GCPointClientUIWorldPanel::GetDPI, &GCPointClientUIWorldPanel::SetDPI)
        .addProperty("InteractDistance", &GCPointClientUIWorldPanel::GetInteractDistance, &GCPointClientUIWorldPanel::SetInteractDistance)
        .addProperty("DepthOffset", &GCPointClientUIWorldPanel::GetDepthOffset, &GCPointClientUIWorldPanel::SetDepthOffset)
        .addProperty("OwnerContext", &GCPointClientUIWorldPanel::GetOwnerContext, &GCPointClientUIWorldPanel::SetOwnerContext)
        .addProperty("HorizontalAlign", &GCPointClientUIWorldPanel::GetHorizontalAlign, &GCPointClientUIWorldPanel::SetHorizontalAlign)
        .addProperty("VerticalAlign", &GCPointClientUIWorldPanel::GetVerticalAlign, &GCPointClientUIWorldPanel::SetVerticalAlign)
        .addProperty("Orientation", &GCPointClientUIWorldPanel::GetOrientation, &GCPointClientUIWorldPanel::SetOrientation)
        .addProperty("AllowInteractionFromAllSceneWorlds", &GCPointClientUIWorldPanel::GetAllowInteractionFromAllSceneWorlds, &GCPointClientUIWorldPanel::SetAllowInteractionFromAllSceneWorlds)
        .addProperty("CSSClasses", &GCPointClientUIWorldPanel::GetCSSClasses, &GCPointClientUIWorldPanel::SetCSSClasses)
        .addProperty("Opaque", &GCPointClientUIWorldPanel::GetOpaque, &GCPointClientUIWorldPanel::SetOpaque)
        .addProperty("NoDepth", &GCPointClientUIWorldPanel::GetNoDepth, &GCPointClientUIWorldPanel::SetNoDepth)
        .addProperty("RenderBackface", &GCPointClientUIWorldPanel::GetRenderBackface, &GCPointClientUIWorldPanel::SetRenderBackface)
        .addProperty("UseOffScreenIndicator", &GCPointClientUIWorldPanel::GetUseOffScreenIndicator, &GCPointClientUIWorldPanel::SetUseOffScreenIndicator)
        .addProperty("ExcludeFromSaveGames", &GCPointClientUIWorldPanel::GetExcludeFromSaveGames, &GCPointClientUIWorldPanel::SetExcludeFromSaveGames)
        .addProperty("Grabbable", &GCPointClientUIWorldPanel::GetGrabbable, &GCPointClientUIWorldPanel::SetGrabbable)
        .addProperty("OnlyRenderToTexture", &GCPointClientUIWorldPanel::GetOnlyRenderToTexture, &GCPointClientUIWorldPanel::SetOnlyRenderToTexture)
        .addProperty("DisableMipGen", &GCPointClientUIWorldPanel::GetDisableMipGen, &GCPointClientUIWorldPanel::SetDisableMipGen)
        .addProperty("ExplicitImageLayout", &GCPointClientUIWorldPanel::GetExplicitImageLayout, &GCPointClientUIWorldPanel::SetExplicitImageLayout)
        .addProperty("Parent", &GCPointClientUIWorldPanel::GetParent, &GCPointClientUIWorldPanel::SetParent)
        .addFunction("ToPtr", &GCPointClientUIWorldPanel::ToPtr)
        .addFunction("IsValid", &GCPointClientUIWorldPanel::IsValid)
        .endClass();
}
GCFilterContext::GCFilterContext(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCFilterContext::GCFilterContext(void *ptr) {
    m_ptr = ptr;
}
std::string GCFilterContext::GetFilterContext() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CFilterContext", "m_iFilterContext").String();
}
void GCFilterContext::SetFilterContext(std::string value) {
    SetSchemaValue(m_ptr, "CFilterContext", "m_iFilterContext", false, CUtlSymbolLarge(value.c_str()));
}
std::string GCFilterContext::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCFilterContext::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseFilter GCFilterContext::GetParent() const {
    GCBaseFilter value(m_ptr);
    return value;
}
void GCFilterContext::SetParent(GCBaseFilter value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCFilterContext(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCFilterContext>("CFilterContext")
        .addConstructor<void (*)(std::string)>()
        .addProperty("FilterContext", &GCFilterContext::GetFilterContext, &GCFilterContext::SetFilterContext)
        .addProperty("Parent", &GCFilterContext::GetParent, &GCFilterContext::SetParent)
        .addFunction("ToPtr", &GCFilterContext::ToPtr)
        .addFunction("IsValid", &GCFilterContext::IsValid)
        .endClass();
}
GCPathParticleRopeAlias_path_particle_rope_clientside::GCPathParticleRopeAlias_path_particle_rope_clientside(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCPathParticleRopeAlias_path_particle_rope_clientside::GCPathParticleRopeAlias_path_particle_rope_clientside(void *ptr) {
    m_ptr = ptr;
}
std::string GCPathParticleRopeAlias_path_particle_rope_clientside::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCPathParticleRopeAlias_path_particle_rope_clientside::IsValid() {
    return (m_ptr != nullptr);
}
GCPathParticleRope GCPathParticleRopeAlias_path_particle_rope_clientside::GetParent() const {
    GCPathParticleRope value(m_ptr);
    return value;
}
void GCPathParticleRopeAlias_path_particle_rope_clientside::SetParent(GCPathParticleRope value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCPathParticleRopeAlias_path_particle_rope_clientside(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCPathParticleRopeAlias_path_particle_rope_clientside>("CPathParticleRopeAlias_path_particle_rope_clientside")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCPathParticleRopeAlias_path_particle_rope_clientside::GetParent, &GCPathParticleRopeAlias_path_particle_rope_clientside::SetParent)
        .addFunction("ToPtr", &GCPathParticleRopeAlias_path_particle_rope_clientside::ToPtr)
        .addFunction("IsValid", &GCPathParticleRopeAlias_path_particle_rope_clientside::IsValid)
        .endClass();
}
GCTriggerBuoyancy::GCTriggerBuoyancy(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCTriggerBuoyancy::GCTriggerBuoyancy(void *ptr) {
    m_ptr = ptr;
}
GCBuoyancyHelper GCTriggerBuoyancy::GetBuoyancyHelper() const {
    GCBuoyancyHelper value(GetSchemaPtr(m_ptr, "CTriggerBuoyancy", "m_BuoyancyHelper"));
    return value;
}
void GCTriggerBuoyancy::SetBuoyancyHelper(GCBuoyancyHelper value) {
    SetSchemaValue(m_ptr, "CTriggerBuoyancy", "m_BuoyancyHelper", false, value);
}
float GCTriggerBuoyancy::GetFluidDensity() const {
    return GetSchemaValue<float>(m_ptr, "CTriggerBuoyancy", "m_flFluidDensity");
}
void GCTriggerBuoyancy::SetFluidDensity(float value) {
    SetSchemaValue(m_ptr, "CTriggerBuoyancy", "m_flFluidDensity", false, value);
}
std::string GCTriggerBuoyancy::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCTriggerBuoyancy::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseTrigger GCTriggerBuoyancy::GetParent() const {
    GCBaseTrigger value(m_ptr);
    return value;
}
void GCTriggerBuoyancy::SetParent(GCBaseTrigger value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCTriggerBuoyancy(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCTriggerBuoyancy>("CTriggerBuoyancy")
        .addConstructor<void (*)(std::string)>()
        .addProperty("BuoyancyHelper", &GCTriggerBuoyancy::GetBuoyancyHelper, &GCTriggerBuoyancy::SetBuoyancyHelper)
        .addProperty("FluidDensity", &GCTriggerBuoyancy::GetFluidDensity, &GCTriggerBuoyancy::SetFluidDensity)
        .addProperty("Parent", &GCTriggerBuoyancy::GetParent, &GCTriggerBuoyancy::SetParent)
        .addFunction("ToPtr", &GCTriggerBuoyancy::ToPtr)
        .addFunction("IsValid", &GCTriggerBuoyancy::IsValid)
        .endClass();
}
GCFilterAttributeInt::GCFilterAttributeInt(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCFilterAttributeInt::GCFilterAttributeInt(void *ptr) {
    m_ptr = ptr;
}
CUtlStringToken GCFilterAttributeInt::GetAttributeName() const {
    return GetSchemaValue<CUtlStringToken>(m_ptr, "CFilterAttributeInt", "m_sAttributeName");
}
void GCFilterAttributeInt::SetAttributeName(CUtlStringToken value) {
    SetSchemaValue(m_ptr, "CFilterAttributeInt", "m_sAttributeName", false, value);
}
std::string GCFilterAttributeInt::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCFilterAttributeInt::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseFilter GCFilterAttributeInt::GetParent() const {
    GCBaseFilter value(m_ptr);
    return value;
}
void GCFilterAttributeInt::SetParent(GCBaseFilter value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCFilterAttributeInt(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCFilterAttributeInt>("CFilterAttributeInt")
        .addConstructor<void (*)(std::string)>()
        .addProperty("AttributeName", &GCFilterAttributeInt::GetAttributeName, &GCFilterAttributeInt::SetAttributeName)
        .addProperty("Parent", &GCFilterAttributeInt::GetParent, &GCFilterAttributeInt::SetParent)
        .addFunction("ToPtr", &GCFilterAttributeInt::ToPtr)
        .addFunction("IsValid", &GCFilterAttributeInt::IsValid)
        .endClass();
}
GCCSPlayer_ActionTrackingServices::GCCSPlayer_ActionTrackingServices(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCCSPlayer_ActionTrackingServices::GCCSPlayer_ActionTrackingServices(void *ptr) {
    m_ptr = ptr;
}
GCBasePlayerWeapon GCCSPlayer_ActionTrackingServices::GetLastWeaponBeforeC4AutoSwitch() const {
    GCBasePlayerWeapon value(*GetSchemaValuePtr<void*>(m_ptr, "CCSPlayer_ActionTrackingServices", "m_hLastWeaponBeforeC4AutoSwitch"));
    return value;
}
void GCCSPlayer_ActionTrackingServices::SetLastWeaponBeforeC4AutoSwitch(GCBasePlayerWeapon* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'LastWeaponBeforeC4AutoSwitch' is not possible.\n");
}
bool GCCSPlayer_ActionTrackingServices::GetIsRescuing() const {
    return GetSchemaValue<bool>(m_ptr, "CCSPlayer_ActionTrackingServices", "m_bIsRescuing");
}
void GCCSPlayer_ActionTrackingServices::SetIsRescuing(bool value) {
    SetSchemaValue(m_ptr, "CCSPlayer_ActionTrackingServices", "m_bIsRescuing", false, value);
}
GWeaponPurchaseTracker_t GCCSPlayer_ActionTrackingServices::GetWeaponPurchasesThisMatch() const {
    GWeaponPurchaseTracker_t value(GetSchemaPtr(m_ptr, "CCSPlayer_ActionTrackingServices", "m_weaponPurchasesThisMatch"));
    return value;
}
void GCCSPlayer_ActionTrackingServices::SetWeaponPurchasesThisMatch(GWeaponPurchaseTracker_t value) {
    SetSchemaValue(m_ptr, "CCSPlayer_ActionTrackingServices", "m_weaponPurchasesThisMatch", false, value);
}
GWeaponPurchaseTracker_t GCCSPlayer_ActionTrackingServices::GetWeaponPurchasesThisRound() const {
    GWeaponPurchaseTracker_t value(GetSchemaPtr(m_ptr, "CCSPlayer_ActionTrackingServices", "m_weaponPurchasesThisRound"));
    return value;
}
void GCCSPlayer_ActionTrackingServices::SetWeaponPurchasesThisRound(GWeaponPurchaseTracker_t value) {
    SetSchemaValue(m_ptr, "CCSPlayer_ActionTrackingServices", "m_weaponPurchasesThisRound", false, value);
}
std::string GCCSPlayer_ActionTrackingServices::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCCSPlayer_ActionTrackingServices::IsValid() {
    return (m_ptr != nullptr);
}
GCPlayerPawnComponent GCCSPlayer_ActionTrackingServices::GetParent() const {
    GCPlayerPawnComponent value(m_ptr);
    return value;
}
void GCCSPlayer_ActionTrackingServices::SetParent(GCPlayerPawnComponent value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCCSPlayer_ActionTrackingServices(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCCSPlayer_ActionTrackingServices>("CCSPlayer_ActionTrackingServices")
        .addConstructor<void (*)(std::string)>()
        .addProperty("LastWeaponBeforeC4AutoSwitch", &GCCSPlayer_ActionTrackingServices::GetLastWeaponBeforeC4AutoSwitch, &GCCSPlayer_ActionTrackingServices::SetLastWeaponBeforeC4AutoSwitch)
        .addProperty("IsRescuing", &GCCSPlayer_ActionTrackingServices::GetIsRescuing, &GCCSPlayer_ActionTrackingServices::SetIsRescuing)
        .addProperty("WeaponPurchasesThisMatch", &GCCSPlayer_ActionTrackingServices::GetWeaponPurchasesThisMatch, &GCCSPlayer_ActionTrackingServices::SetWeaponPurchasesThisMatch)
        .addProperty("WeaponPurchasesThisRound", &GCCSPlayer_ActionTrackingServices::GetWeaponPurchasesThisRound, &GCCSPlayer_ActionTrackingServices::SetWeaponPurchasesThisRound)
        .addProperty("Parent", &GCCSPlayer_ActionTrackingServices::GetParent, &GCCSPlayer_ActionTrackingServices::SetParent)
        .addFunction("ToPtr", &GCCSPlayer_ActionTrackingServices::ToPtr)
        .addFunction("IsValid", &GCCSPlayer_ActionTrackingServices::IsValid)
        .endClass();
}
GCAISound::GCAISound(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCAISound::GCAISound(void *ptr) {
    m_ptr = ptr;
}
uint64_t GCAISound::GetSoundType() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CAISound", "m_iSoundType");
}
void GCAISound::SetSoundType(uint64_t value) {
    SetSchemaValue(m_ptr, "CAISound", "m_iSoundType", false, value);
}
uint64_t GCAISound::GetSoundFlags() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CAISound", "m_iSoundFlags");
}
void GCAISound::SetSoundFlags(uint64_t value) {
    SetSchemaValue(m_ptr, "CAISound", "m_iSoundFlags", false, value);
}
int32_t GCAISound::GetVolume() const {
    return GetSchemaValue<int32_t>(m_ptr, "CAISound", "m_iVolume");
}
void GCAISound::SetVolume(int32_t value) {
    SetSchemaValue(m_ptr, "CAISound", "m_iVolume", false, value);
}
int32_t GCAISound::GetSoundIndex() const {
    return GetSchemaValue<int32_t>(m_ptr, "CAISound", "m_iSoundIndex");
}
void GCAISound::SetSoundIndex(int32_t value) {
    SetSchemaValue(m_ptr, "CAISound", "m_iSoundIndex", false, value);
}
float GCAISound::GetDuration() const {
    return GetSchemaValue<float>(m_ptr, "CAISound", "m_flDuration");
}
void GCAISound::SetDuration(float value) {
    SetSchemaValue(m_ptr, "CAISound", "m_flDuration", false, value);
}
std::string GCAISound::GetProxyEntityName() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CAISound", "m_iszProxyEntityName").String();
}
void GCAISound::SetProxyEntityName(std::string value) {
    SetSchemaValue(m_ptr, "CAISound", "m_iszProxyEntityName", false, CUtlSymbolLarge(value.c_str()));
}
std::string GCAISound::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCAISound::IsValid() {
    return (m_ptr != nullptr);
}
GCPointEntity GCAISound::GetParent() const {
    GCPointEntity value(m_ptr);
    return value;
}
void GCAISound::SetParent(GCPointEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCAISound(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCAISound>("CAISound")
        .addConstructor<void (*)(std::string)>()
        .addProperty("SoundType", &GCAISound::GetSoundType, &GCAISound::SetSoundType)
        .addProperty("SoundFlags", &GCAISound::GetSoundFlags, &GCAISound::SetSoundFlags)
        .addProperty("Volume", &GCAISound::GetVolume, &GCAISound::SetVolume)
        .addProperty("SoundIndex", &GCAISound::GetSoundIndex, &GCAISound::SetSoundIndex)
        .addProperty("Duration", &GCAISound::GetDuration, &GCAISound::SetDuration)
        .addProperty("ProxyEntityName", &GCAISound::GetProxyEntityName, &GCAISound::SetProxyEntityName)
        .addProperty("Parent", &GCAISound::GetParent, &GCAISound::SetParent)
        .addFunction("ToPtr", &GCAISound::ToPtr)
        .addFunction("IsValid", &GCAISound::IsValid)
        .endClass();
}
GCPointEntityFinder::GCPointEntityFinder(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCPointEntityFinder::GCPointEntityFinder(void *ptr) {
    m_ptr = ptr;
}
GCBaseEntity GCPointEntityFinder::GetEntity() const {
    GCBaseEntity value(*GetSchemaValuePtr<void*>(m_ptr, "CPointEntityFinder", "m_hEntity"));
    return value;
}
void GCPointEntityFinder::SetEntity(GCBaseEntity* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Entity' is not possible.\n");
}
std::string GCPointEntityFinder::GetFilterName() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CPointEntityFinder", "m_iFilterName").String();
}
void GCPointEntityFinder::SetFilterName(std::string value) {
    SetSchemaValue(m_ptr, "CPointEntityFinder", "m_iFilterName", false, CUtlSymbolLarge(value.c_str()));
}
GCBaseFilter GCPointEntityFinder::GetFilter() const {
    GCBaseFilter value(*GetSchemaValuePtr<void*>(m_ptr, "CPointEntityFinder", "m_hFilter"));
    return value;
}
void GCPointEntityFinder::SetFilter(GCBaseFilter* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Filter' is not possible.\n");
}
std::string GCPointEntityFinder::GetRefName() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CPointEntityFinder", "m_iRefName").String();
}
void GCPointEntityFinder::SetRefName(std::string value) {
    SetSchemaValue(m_ptr, "CPointEntityFinder", "m_iRefName", false, CUtlSymbolLarge(value.c_str()));
}
GCBaseEntity GCPointEntityFinder::GetReference() const {
    GCBaseEntity value(*GetSchemaValuePtr<void*>(m_ptr, "CPointEntityFinder", "m_hReference"));
    return value;
}
void GCPointEntityFinder::SetReference(GCBaseEntity* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Reference' is not possible.\n");
}
uint64_t GCPointEntityFinder::GetFindMethod() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CPointEntityFinder", "m_FindMethod");
}
void GCPointEntityFinder::SetFindMethod(uint64_t value) {
    SetSchemaValue(m_ptr, "CPointEntityFinder", "m_FindMethod", false, value);
}
GCEntityIOOutput GCPointEntityFinder::GetOnFoundEntity() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CPointEntityFinder", "m_OnFoundEntity"));
    return value;
}
void GCPointEntityFinder::SetOnFoundEntity(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CPointEntityFinder", "m_OnFoundEntity", false, value);
}
std::string GCPointEntityFinder::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCPointEntityFinder::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseEntity GCPointEntityFinder::GetParent() const {
    GCBaseEntity value(m_ptr);
    return value;
}
void GCPointEntityFinder::SetParent(GCBaseEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCPointEntityFinder(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCPointEntityFinder>("CPointEntityFinder")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Entity", &GCPointEntityFinder::GetEntity, &GCPointEntityFinder::SetEntity)
        .addProperty("FilterName", &GCPointEntityFinder::GetFilterName, &GCPointEntityFinder::SetFilterName)
        .addProperty("Filter", &GCPointEntityFinder::GetFilter, &GCPointEntityFinder::SetFilter)
        .addProperty("RefName", &GCPointEntityFinder::GetRefName, &GCPointEntityFinder::SetRefName)
        .addProperty("Reference", &GCPointEntityFinder::GetReference, &GCPointEntityFinder::SetReference)
        .addProperty("FindMethod", &GCPointEntityFinder::GetFindMethod, &GCPointEntityFinder::SetFindMethod)
        .addProperty("OnFoundEntity", &GCPointEntityFinder::GetOnFoundEntity, &GCPointEntityFinder::SetOnFoundEntity)
        .addProperty("Parent", &GCPointEntityFinder::GetParent, &GCPointEntityFinder::SetParent)
        .addFunction("ToPtr", &GCPointEntityFinder::ToPtr)
        .addFunction("IsValid", &GCPointEntityFinder::IsValid)
        .endClass();
}
Gshard_model_desc_t::Gshard_model_desc_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
Gshard_model_desc_t::Gshard_model_desc_t(void *ptr) {
    m_ptr = ptr;
}
int32_t Gshard_model_desc_t::GetModelID() const {
    return GetSchemaValue<int32_t>(m_ptr, "shard_model_desc_t", "m_nModelID");
}
void Gshard_model_desc_t::SetModelID(int32_t value) {
    SetSchemaValue(m_ptr, "shard_model_desc_t", "m_nModelID", true, value);
}
uint64_t Gshard_model_desc_t::GetSolid() const {
    return GetSchemaValue<uint64_t>(m_ptr, "shard_model_desc_t", "m_solid");
}
void Gshard_model_desc_t::SetSolid(uint64_t value) {
    SetSchemaValue(m_ptr, "shard_model_desc_t", "m_solid", true, value);
}
uint64_t Gshard_model_desc_t::GetShatterPanelMode() const {
    return GetSchemaValue<uint64_t>(m_ptr, "shard_model_desc_t", "m_ShatterPanelMode");
}
void Gshard_model_desc_t::SetShatterPanelMode(uint64_t value) {
    SetSchemaValue(m_ptr, "shard_model_desc_t", "m_ShatterPanelMode", true, value);
}
Vector2D Gshard_model_desc_t::GetPanelSize() const {
    return GetSchemaValue<Vector2D>(m_ptr, "shard_model_desc_t", "m_vecPanelSize");
}
void Gshard_model_desc_t::SetPanelSize(Vector2D value) {
    SetSchemaValue(m_ptr, "shard_model_desc_t", "m_vecPanelSize", true, value);
}
Vector2D Gshard_model_desc_t::GetStressPositionA() const {
    return GetSchemaValue<Vector2D>(m_ptr, "shard_model_desc_t", "m_vecStressPositionA");
}
void Gshard_model_desc_t::SetStressPositionA(Vector2D value) {
    SetSchemaValue(m_ptr, "shard_model_desc_t", "m_vecStressPositionA", true, value);
}
Vector2D Gshard_model_desc_t::GetStressPositionB() const {
    return GetSchemaValue<Vector2D>(m_ptr, "shard_model_desc_t", "m_vecStressPositionB");
}
void Gshard_model_desc_t::SetStressPositionB(Vector2D value) {
    SetSchemaValue(m_ptr, "shard_model_desc_t", "m_vecStressPositionB", true, value);
}
std::vector<Vector2D> Gshard_model_desc_t::GetPanelVertices() const {
    CUtlVector<Vector2D>* vec = GetSchemaValue<CUtlVector<Vector2D>*>(m_ptr, "shard_model_desc_t", "m_vecPanelVertices"); std::vector<Vector2D> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void Gshard_model_desc_t::SetPanelVertices(std::vector<Vector2D> value) {
    SetSchemaValueCUtlVector<Vector2D>(m_ptr, "shard_model_desc_t", "m_vecPanelVertices", true, value);
}
float Gshard_model_desc_t::GetGlassHalfThickness() const {
    return GetSchemaValue<float>(m_ptr, "shard_model_desc_t", "m_flGlassHalfThickness");
}
void Gshard_model_desc_t::SetGlassHalfThickness(float value) {
    SetSchemaValue(m_ptr, "shard_model_desc_t", "m_flGlassHalfThickness", true, value);
}
bool Gshard_model_desc_t::GetHasParent() const {
    return GetSchemaValue<bool>(m_ptr, "shard_model_desc_t", "m_bHasParent");
}
void Gshard_model_desc_t::SetHasParent(bool value) {
    SetSchemaValue(m_ptr, "shard_model_desc_t", "m_bHasParent", true, value);
}
bool Gshard_model_desc_t::GetParentFrozen() const {
    return GetSchemaValue<bool>(m_ptr, "shard_model_desc_t", "m_bParentFrozen");
}
void Gshard_model_desc_t::SetParentFrozen(bool value) {
    SetSchemaValue(m_ptr, "shard_model_desc_t", "m_bParentFrozen", true, value);
}
CUtlStringToken Gshard_model_desc_t::GetSurfacePropStringToken() const {
    return GetSchemaValue<CUtlStringToken>(m_ptr, "shard_model_desc_t", "m_SurfacePropStringToken");
}
void Gshard_model_desc_t::SetSurfacePropStringToken(CUtlStringToken value) {
    SetSchemaValue(m_ptr, "shard_model_desc_t", "m_SurfacePropStringToken", true, value);
}
std::string Gshard_model_desc_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool Gshard_model_desc_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassshard_model_desc_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<Gshard_model_desc_t>("shard_model_desc_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("ModelID", &Gshard_model_desc_t::GetModelID, &Gshard_model_desc_t::SetModelID)
        .addProperty("Solid", &Gshard_model_desc_t::GetSolid, &Gshard_model_desc_t::SetSolid)
        .addProperty("ShatterPanelMode", &Gshard_model_desc_t::GetShatterPanelMode, &Gshard_model_desc_t::SetShatterPanelMode)
        .addProperty("PanelSize", &Gshard_model_desc_t::GetPanelSize, &Gshard_model_desc_t::SetPanelSize)
        .addProperty("StressPositionA", &Gshard_model_desc_t::GetStressPositionA, &Gshard_model_desc_t::SetStressPositionA)
        .addProperty("StressPositionB", &Gshard_model_desc_t::GetStressPositionB, &Gshard_model_desc_t::SetStressPositionB)
        .addProperty("PanelVertices", &Gshard_model_desc_t::GetPanelVertices, &Gshard_model_desc_t::SetPanelVertices)
        .addProperty("GlassHalfThickness", &Gshard_model_desc_t::GetGlassHalfThickness, &Gshard_model_desc_t::SetGlassHalfThickness)
        .addProperty("HasParent", &Gshard_model_desc_t::GetHasParent, &Gshard_model_desc_t::SetHasParent)
        .addProperty("ParentFrozen", &Gshard_model_desc_t::GetParentFrozen, &Gshard_model_desc_t::SetParentFrozen)
        .addProperty("SurfacePropStringToken", &Gshard_model_desc_t::GetSurfacePropStringToken, &Gshard_model_desc_t::SetSurfacePropStringToken)
        .addFunction("ToPtr", &Gshard_model_desc_t::ToPtr)
        .addFunction("IsValid", &Gshard_model_desc_t::IsValid)
        .endClass();
}
GCPhysicsPropRespawnable::GCPhysicsPropRespawnable(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCPhysicsPropRespawnable::GCPhysicsPropRespawnable(void *ptr) {
    m_ptr = ptr;
}
Vector GCPhysicsPropRespawnable::GetOriginalSpawnOrigin() const {
    return GetSchemaValue<Vector>(m_ptr, "CPhysicsPropRespawnable", "m_vOriginalSpawnOrigin");
}
void GCPhysicsPropRespawnable::SetOriginalSpawnOrigin(Vector value) {
    SetSchemaValue(m_ptr, "CPhysicsPropRespawnable", "m_vOriginalSpawnOrigin", false, value);
}
QAngle GCPhysicsPropRespawnable::GetOriginalSpawnAngles() const {
    return GetSchemaValue<QAngle>(m_ptr, "CPhysicsPropRespawnable", "m_vOriginalSpawnAngles");
}
void GCPhysicsPropRespawnable::SetOriginalSpawnAngles(QAngle value) {
    SetSchemaValue(m_ptr, "CPhysicsPropRespawnable", "m_vOriginalSpawnAngles", false, value);
}
Vector GCPhysicsPropRespawnable::GetOriginalMins() const {
    return GetSchemaValue<Vector>(m_ptr, "CPhysicsPropRespawnable", "m_vOriginalMins");
}
void GCPhysicsPropRespawnable::SetOriginalMins(Vector value) {
    SetSchemaValue(m_ptr, "CPhysicsPropRespawnable", "m_vOriginalMins", false, value);
}
Vector GCPhysicsPropRespawnable::GetOriginalMaxs() const {
    return GetSchemaValue<Vector>(m_ptr, "CPhysicsPropRespawnable", "m_vOriginalMaxs");
}
void GCPhysicsPropRespawnable::SetOriginalMaxs(Vector value) {
    SetSchemaValue(m_ptr, "CPhysicsPropRespawnable", "m_vOriginalMaxs", false, value);
}
float GCPhysicsPropRespawnable::GetRespawnDuration() const {
    return GetSchemaValue<float>(m_ptr, "CPhysicsPropRespawnable", "m_flRespawnDuration");
}
void GCPhysicsPropRespawnable::SetRespawnDuration(float value) {
    SetSchemaValue(m_ptr, "CPhysicsPropRespawnable", "m_flRespawnDuration", false, value);
}
std::string GCPhysicsPropRespawnable::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCPhysicsPropRespawnable::IsValid() {
    return (m_ptr != nullptr);
}
GCPhysicsProp GCPhysicsPropRespawnable::GetParent() const {
    GCPhysicsProp value(m_ptr);
    return value;
}
void GCPhysicsPropRespawnable::SetParent(GCPhysicsProp value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCPhysicsPropRespawnable(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCPhysicsPropRespawnable>("CPhysicsPropRespawnable")
        .addConstructor<void (*)(std::string)>()
        .addProperty("OriginalSpawnOrigin", &GCPhysicsPropRespawnable::GetOriginalSpawnOrigin, &GCPhysicsPropRespawnable::SetOriginalSpawnOrigin)
        .addProperty("OriginalSpawnAngles", &GCPhysicsPropRespawnable::GetOriginalSpawnAngles, &GCPhysicsPropRespawnable::SetOriginalSpawnAngles)
        .addProperty("OriginalMins", &GCPhysicsPropRespawnable::GetOriginalMins, &GCPhysicsPropRespawnable::SetOriginalMins)
        .addProperty("OriginalMaxs", &GCPhysicsPropRespawnable::GetOriginalMaxs, &GCPhysicsPropRespawnable::SetOriginalMaxs)
        .addProperty("RespawnDuration", &GCPhysicsPropRespawnable::GetRespawnDuration, &GCPhysicsPropRespawnable::SetRespawnDuration)
        .addProperty("Parent", &GCPhysicsPropRespawnable::GetParent, &GCPhysicsPropRespawnable::SetParent)
        .addFunction("ToPtr", &GCPhysicsPropRespawnable::ToPtr)
        .addFunction("IsValid", &GCPhysicsPropRespawnable::IsValid)
        .endClass();
}
GCEnvSky::GCEnvSky(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCEnvSky::GCEnvSky(void *ptr) {
    m_ptr = ptr;
}
bool GCEnvSky::GetStartDisabled() const {
    return GetSchemaValue<bool>(m_ptr, "CEnvSky", "m_bStartDisabled");
}
void GCEnvSky::SetStartDisabled(bool value) {
    SetSchemaValue(m_ptr, "CEnvSky", "m_bStartDisabled", false, value);
}
Color GCEnvSky::GetTintColor() const {
    return GetSchemaValue<Color>(m_ptr, "CEnvSky", "m_vTintColor");
}
void GCEnvSky::SetTintColor(Color value) {
    SetSchemaValue(m_ptr, "CEnvSky", "m_vTintColor", false, value);
}
Color GCEnvSky::GetTintColorLightingOnly() const {
    return GetSchemaValue<Color>(m_ptr, "CEnvSky", "m_vTintColorLightingOnly");
}
void GCEnvSky::SetTintColorLightingOnly(Color value) {
    SetSchemaValue(m_ptr, "CEnvSky", "m_vTintColorLightingOnly", false, value);
}
float GCEnvSky::GetBrightnessScale() const {
    return GetSchemaValue<float>(m_ptr, "CEnvSky", "m_flBrightnessScale");
}
void GCEnvSky::SetBrightnessScale(float value) {
    SetSchemaValue(m_ptr, "CEnvSky", "m_flBrightnessScale", false, value);
}
int32_t GCEnvSky::GetFogType() const {
    return GetSchemaValue<int32_t>(m_ptr, "CEnvSky", "m_nFogType");
}
void GCEnvSky::SetFogType(int32_t value) {
    SetSchemaValue(m_ptr, "CEnvSky", "m_nFogType", false, value);
}
float GCEnvSky::GetFogMinStart() const {
    return GetSchemaValue<float>(m_ptr, "CEnvSky", "m_flFogMinStart");
}
void GCEnvSky::SetFogMinStart(float value) {
    SetSchemaValue(m_ptr, "CEnvSky", "m_flFogMinStart", false, value);
}
float GCEnvSky::GetFogMinEnd() const {
    return GetSchemaValue<float>(m_ptr, "CEnvSky", "m_flFogMinEnd");
}
void GCEnvSky::SetFogMinEnd(float value) {
    SetSchemaValue(m_ptr, "CEnvSky", "m_flFogMinEnd", false, value);
}
float GCEnvSky::GetFogMaxStart() const {
    return GetSchemaValue<float>(m_ptr, "CEnvSky", "m_flFogMaxStart");
}
void GCEnvSky::SetFogMaxStart(float value) {
    SetSchemaValue(m_ptr, "CEnvSky", "m_flFogMaxStart", false, value);
}
float GCEnvSky::GetFogMaxEnd() const {
    return GetSchemaValue<float>(m_ptr, "CEnvSky", "m_flFogMaxEnd");
}
void GCEnvSky::SetFogMaxEnd(float value) {
    SetSchemaValue(m_ptr, "CEnvSky", "m_flFogMaxEnd", false, value);
}
bool GCEnvSky::GetEnabled() const {
    return GetSchemaValue<bool>(m_ptr, "CEnvSky", "m_bEnabled");
}
void GCEnvSky::SetEnabled(bool value) {
    SetSchemaValue(m_ptr, "CEnvSky", "m_bEnabled", false, value);
}
std::string GCEnvSky::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCEnvSky::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseModelEntity GCEnvSky::GetParent() const {
    GCBaseModelEntity value(m_ptr);
    return value;
}
void GCEnvSky::SetParent(GCBaseModelEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCEnvSky(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCEnvSky>("CEnvSky")
        .addConstructor<void (*)(std::string)>()
        .addProperty("StartDisabled", &GCEnvSky::GetStartDisabled, &GCEnvSky::SetStartDisabled)
        .addProperty("TintColor", &GCEnvSky::GetTintColor, &GCEnvSky::SetTintColor)
        .addProperty("TintColorLightingOnly", &GCEnvSky::GetTintColorLightingOnly, &GCEnvSky::SetTintColorLightingOnly)
        .addProperty("BrightnessScale", &GCEnvSky::GetBrightnessScale, &GCEnvSky::SetBrightnessScale)
        .addProperty("FogType", &GCEnvSky::GetFogType, &GCEnvSky::SetFogType)
        .addProperty("FogMinStart", &GCEnvSky::GetFogMinStart, &GCEnvSky::SetFogMinStart)
        .addProperty("FogMinEnd", &GCEnvSky::GetFogMinEnd, &GCEnvSky::SetFogMinEnd)
        .addProperty("FogMaxStart", &GCEnvSky::GetFogMaxStart, &GCEnvSky::SetFogMaxStart)
        .addProperty("FogMaxEnd", &GCEnvSky::GetFogMaxEnd, &GCEnvSky::SetFogMaxEnd)
        .addProperty("Enabled", &GCEnvSky::GetEnabled, &GCEnvSky::SetEnabled)
        .addProperty("Parent", &GCEnvSky::GetParent, &GCEnvSky::SetParent)
        .addFunction("ToPtr", &GCEnvSky::ToPtr)
        .addFunction("IsValid", &GCEnvSky::IsValid)
        .endClass();
}
GCPointVelocitySensor::GCPointVelocitySensor(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCPointVelocitySensor::GCPointVelocitySensor(void *ptr) {
    m_ptr = ptr;
}
GCBaseEntity GCPointVelocitySensor::GetTargetEntity() const {
    GCBaseEntity value(*GetSchemaValuePtr<void*>(m_ptr, "CPointVelocitySensor", "m_hTargetEntity"));
    return value;
}
void GCPointVelocitySensor::SetTargetEntity(GCBaseEntity* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'TargetEntity' is not possible.\n");
}
Vector GCPointVelocitySensor::GetAxis() const {
    return GetSchemaValue<Vector>(m_ptr, "CPointVelocitySensor", "m_vecAxis");
}
void GCPointVelocitySensor::SetAxis(Vector value) {
    SetSchemaValue(m_ptr, "CPointVelocitySensor", "m_vecAxis", false, value);
}
bool GCPointVelocitySensor::GetEnabled() const {
    return GetSchemaValue<bool>(m_ptr, "CPointVelocitySensor", "m_bEnabled");
}
void GCPointVelocitySensor::SetEnabled(bool value) {
    SetSchemaValue(m_ptr, "CPointVelocitySensor", "m_bEnabled", false, value);
}
float GCPointVelocitySensor::GetPrevVelocity() const {
    return GetSchemaValue<float>(m_ptr, "CPointVelocitySensor", "m_fPrevVelocity");
}
void GCPointVelocitySensor::SetPrevVelocity(float value) {
    SetSchemaValue(m_ptr, "CPointVelocitySensor", "m_fPrevVelocity", false, value);
}
float GCPointVelocitySensor::GetAvgInterval() const {
    return GetSchemaValue<float>(m_ptr, "CPointVelocitySensor", "m_flAvgInterval");
}
void GCPointVelocitySensor::SetAvgInterval(float value) {
    SetSchemaValue(m_ptr, "CPointVelocitySensor", "m_flAvgInterval", false, value);
}
std::string GCPointVelocitySensor::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCPointVelocitySensor::IsValid() {
    return (m_ptr != nullptr);
}
GCPointEntity GCPointVelocitySensor::GetParent() const {
    GCPointEntity value(m_ptr);
    return value;
}
void GCPointVelocitySensor::SetParent(GCPointEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCPointVelocitySensor(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCPointVelocitySensor>("CPointVelocitySensor")
        .addConstructor<void (*)(std::string)>()
        .addProperty("TargetEntity", &GCPointVelocitySensor::GetTargetEntity, &GCPointVelocitySensor::SetTargetEntity)
        .addProperty("Axis", &GCPointVelocitySensor::GetAxis, &GCPointVelocitySensor::SetAxis)
        .addProperty("Enabled", &GCPointVelocitySensor::GetEnabled, &GCPointVelocitySensor::SetEnabled)
        .addProperty("PrevVelocity", &GCPointVelocitySensor::GetPrevVelocity, &GCPointVelocitySensor::SetPrevVelocity)
        .addProperty("AvgInterval", &GCPointVelocitySensor::GetAvgInterval, &GCPointVelocitySensor::SetAvgInterval)
        .addProperty("Parent", &GCPointVelocitySensor::GetParent, &GCPointVelocitySensor::SetParent)
        .addFunction("ToPtr", &GCPointVelocitySensor::ToPtr)
        .addFunction("IsValid", &GCPointVelocitySensor::IsValid)
        .endClass();
}
GCFilterMassGreater::GCFilterMassGreater(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCFilterMassGreater::GCFilterMassGreater(void *ptr) {
    m_ptr = ptr;
}
float GCFilterMassGreater::GetFilterMass() const {
    return GetSchemaValue<float>(m_ptr, "CFilterMassGreater", "m_fFilterMass");
}
void GCFilterMassGreater::SetFilterMass(float value) {
    SetSchemaValue(m_ptr, "CFilterMassGreater", "m_fFilterMass", false, value);
}
std::string GCFilterMassGreater::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCFilterMassGreater::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseFilter GCFilterMassGreater::GetParent() const {
    GCBaseFilter value(m_ptr);
    return value;
}
void GCFilterMassGreater::SetParent(GCBaseFilter value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCFilterMassGreater(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCFilterMassGreater>("CFilterMassGreater")
        .addConstructor<void (*)(std::string)>()
        .addProperty("FilterMass", &GCFilterMassGreater::GetFilterMass, &GCFilterMassGreater::SetFilterMass)
        .addProperty("Parent", &GCFilterMassGreater::GetParent, &GCFilterMassGreater::SetParent)
        .addFunction("ToPtr", &GCFilterMassGreater::ToPtr)
        .addFunction("IsValid", &GCFilterMassGreater::IsValid)
        .endClass();
}
GFilterTeam::GFilterTeam(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GFilterTeam::GFilterTeam(void *ptr) {
    m_ptr = ptr;
}
int32_t GFilterTeam::GetFilterTeam() const {
    return GetSchemaValue<int32_t>(m_ptr, "FilterTeam", "m_iFilterTeam");
}
void GFilterTeam::SetFilterTeam(int32_t value) {
    SetSchemaValue(m_ptr, "FilterTeam", "m_iFilterTeam", false, value);
}
std::string GFilterTeam::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GFilterTeam::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseFilter GFilterTeam::GetParent() const {
    GCBaseFilter value(m_ptr);
    return value;
}
void GFilterTeam::SetParent(GCBaseFilter value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassFilterTeam(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GFilterTeam>("FilterTeam")
        .addConstructor<void (*)(std::string)>()
        .addProperty("FilterTeam", &GFilterTeam::GetFilterTeam, &GFilterTeam::SetFilterTeam)
        .addProperty("Parent", &GFilterTeam::GetParent, &GFilterTeam::SetParent)
        .addFunction("ToPtr", &GFilterTeam::ToPtr)
        .addFunction("IsValid", &GFilterTeam::IsValid)
        .endClass();
}
GCFuncTankTrain::GCFuncTankTrain(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCFuncTankTrain::GCFuncTankTrain(void *ptr) {
    m_ptr = ptr;
}
GCEntityIOOutput GCFuncTankTrain::GetOnDeath() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CFuncTankTrain", "m_OnDeath"));
    return value;
}
void GCFuncTankTrain::SetOnDeath(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CFuncTankTrain", "m_OnDeath", false, value);
}
std::string GCFuncTankTrain::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCFuncTankTrain::IsValid() {
    return (m_ptr != nullptr);
}
GCFuncTrackTrain GCFuncTankTrain::GetParent() const {
    GCFuncTrackTrain value(m_ptr);
    return value;
}
void GCFuncTankTrain::SetParent(GCFuncTrackTrain value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCFuncTankTrain(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCFuncTankTrain>("CFuncTankTrain")
        .addConstructor<void (*)(std::string)>()
        .addProperty("OnDeath", &GCFuncTankTrain::GetOnDeath, &GCFuncTankTrain::SetOnDeath)
        .addProperty("Parent", &GCFuncTankTrain::GetParent, &GCFuncTankTrain::SetParent)
        .addFunction("ToPtr", &GCFuncTankTrain::ToPtr)
        .addFunction("IsValid", &GCFuncTankTrain::IsValid)
        .endClass();
}
GCNullEntity::GCNullEntity(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCNullEntity::GCNullEntity(void *ptr) {
    m_ptr = ptr;
}
std::string GCNullEntity::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCNullEntity::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseEntity GCNullEntity::GetParent() const {
    GCBaseEntity value(m_ptr);
    return value;
}
void GCNullEntity::SetParent(GCBaseEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCNullEntity(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCNullEntity>("CNullEntity")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCNullEntity::GetParent, &GCNullEntity::SetParent)
        .addFunction("ToPtr", &GCNullEntity::ToPtr)
        .addFunction("IsValid", &GCNullEntity::IsValid)
        .endClass();
}
GCCSPointScriptExtensions_observer::GCCSPointScriptExtensions_observer(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCCSPointScriptExtensions_observer::GCCSPointScriptExtensions_observer(void *ptr) {
    m_ptr = ptr;
}
std::string GCCSPointScriptExtensions_observer::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCCSPointScriptExtensions_observer::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCCSPointScriptExtensions_observer(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCCSPointScriptExtensions_observer>("CCSPointScriptExtensions_observer")
        .addConstructor<void (*)(std::string)>()
        .addFunction("ToPtr", &GCCSPointScriptExtensions_observer::ToPtr)
        .addFunction("IsValid", &GCCSPointScriptExtensions_observer::IsValid)
        .endClass();
}
GCMarkupVolumeTagged::GCMarkupVolumeTagged(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCMarkupVolumeTagged::GCMarkupVolumeTagged(void *ptr) {
    m_ptr = ptr;
}
bool GCMarkupVolumeTagged::GetIsGroup() const {
    return GetSchemaValue<bool>(m_ptr, "CMarkupVolumeTagged", "m_bIsGroup");
}
void GCMarkupVolumeTagged::SetIsGroup(bool value) {
    SetSchemaValue(m_ptr, "CMarkupVolumeTagged", "m_bIsGroup", false, value);
}
bool GCMarkupVolumeTagged::GetGroupByPrefab() const {
    return GetSchemaValue<bool>(m_ptr, "CMarkupVolumeTagged", "m_bGroupByPrefab");
}
void GCMarkupVolumeTagged::SetGroupByPrefab(bool value) {
    SetSchemaValue(m_ptr, "CMarkupVolumeTagged", "m_bGroupByPrefab", false, value);
}
bool GCMarkupVolumeTagged::GetGroupByVolume() const {
    return GetSchemaValue<bool>(m_ptr, "CMarkupVolumeTagged", "m_bGroupByVolume");
}
void GCMarkupVolumeTagged::SetGroupByVolume(bool value) {
    SetSchemaValue(m_ptr, "CMarkupVolumeTagged", "m_bGroupByVolume", false, value);
}
bool GCMarkupVolumeTagged::GetGroupOtherGroups() const {
    return GetSchemaValue<bool>(m_ptr, "CMarkupVolumeTagged", "m_bGroupOtherGroups");
}
void GCMarkupVolumeTagged::SetGroupOtherGroups(bool value) {
    SetSchemaValue(m_ptr, "CMarkupVolumeTagged", "m_bGroupOtherGroups", false, value);
}
bool GCMarkupVolumeTagged::GetIsInGroup() const {
    return GetSchemaValue<bool>(m_ptr, "CMarkupVolumeTagged", "m_bIsInGroup");
}
void GCMarkupVolumeTagged::SetIsInGroup(bool value) {
    SetSchemaValue(m_ptr, "CMarkupVolumeTagged", "m_bIsInGroup", false, value);
}
std::string GCMarkupVolumeTagged::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCMarkupVolumeTagged::IsValid() {
    return (m_ptr != nullptr);
}
GCMarkupVolume GCMarkupVolumeTagged::GetParent() const {
    GCMarkupVolume value(m_ptr);
    return value;
}
void GCMarkupVolumeTagged::SetParent(GCMarkupVolume value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCMarkupVolumeTagged(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCMarkupVolumeTagged>("CMarkupVolumeTagged")
        .addConstructor<void (*)(std::string)>()
        .addProperty("IsGroup", &GCMarkupVolumeTagged::GetIsGroup, &GCMarkupVolumeTagged::SetIsGroup)
        .addProperty("GroupByPrefab", &GCMarkupVolumeTagged::GetGroupByPrefab, &GCMarkupVolumeTagged::SetGroupByPrefab)
        .addProperty("GroupByVolume", &GCMarkupVolumeTagged::GetGroupByVolume, &GCMarkupVolumeTagged::SetGroupByVolume)
        .addProperty("GroupOtherGroups", &GCMarkupVolumeTagged::GetGroupOtherGroups, &GCMarkupVolumeTagged::SetGroupOtherGroups)
        .addProperty("IsInGroup", &GCMarkupVolumeTagged::GetIsInGroup, &GCMarkupVolumeTagged::SetIsInGroup)
        .addProperty("Parent", &GCMarkupVolumeTagged::GetParent, &GCMarkupVolumeTagged::SetParent)
        .addFunction("ToPtr", &GCMarkupVolumeTagged::ToPtr)
        .addFunction("IsValid", &GCMarkupVolumeTagged::IsValid)
        .endClass();
}
GCBuyZone::GCBuyZone(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCBuyZone::GCBuyZone(void *ptr) {
    m_ptr = ptr;
}
int32_t GCBuyZone::GetLegacyTeamNum() const {
    return GetSchemaValue<int32_t>(m_ptr, "CBuyZone", "m_LegacyTeamNum");
}
void GCBuyZone::SetLegacyTeamNum(int32_t value) {
    SetSchemaValue(m_ptr, "CBuyZone", "m_LegacyTeamNum", false, value);
}
std::string GCBuyZone::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCBuyZone::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseTrigger GCBuyZone::GetParent() const {
    GCBaseTrigger value(m_ptr);
    return value;
}
void GCBuyZone::SetParent(GCBaseTrigger value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCBuyZone(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCBuyZone>("CBuyZone")
        .addConstructor<void (*)(std::string)>()
        .addProperty("LegacyTeamNum", &GCBuyZone::GetLegacyTeamNum, &GCBuyZone::SetLegacyTeamNum)
        .addProperty("Parent", &GCBuyZone::GetParent, &GCBuyZone::SetParent)
        .addFunction("ToPtr", &GCBuyZone::ToPtr)
        .addFunction("IsValid", &GCBuyZone::IsValid)
        .endClass();
}
GCPointTemplate::GCPointTemplate(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCPointTemplate::GCPointTemplate(void *ptr) {
    m_ptr = ptr;
}
std::string GCPointTemplate::GetWorldName() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CPointTemplate", "m_iszWorldName").String();
}
void GCPointTemplate::SetWorldName(std::string value) {
    SetSchemaValue(m_ptr, "CPointTemplate", "m_iszWorldName", false, CUtlSymbolLarge(value.c_str()));
}
std::string GCPointTemplate::GetSource2EntityLumpName() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CPointTemplate", "m_iszSource2EntityLumpName").String();
}
void GCPointTemplate::SetSource2EntityLumpName(std::string value) {
    SetSchemaValue(m_ptr, "CPointTemplate", "m_iszSource2EntityLumpName", false, CUtlSymbolLarge(value.c_str()));
}
std::string GCPointTemplate::GetEntityFilterName() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CPointTemplate", "m_iszEntityFilterName").String();
}
void GCPointTemplate::SetEntityFilterName(std::string value) {
    SetSchemaValue(m_ptr, "CPointTemplate", "m_iszEntityFilterName", false, CUtlSymbolLarge(value.c_str()));
}
float GCPointTemplate::GetTimeoutInterval() const {
    return GetSchemaValue<float>(m_ptr, "CPointTemplate", "m_flTimeoutInterval");
}
void GCPointTemplate::SetTimeoutInterval(float value) {
    SetSchemaValue(m_ptr, "CPointTemplate", "m_flTimeoutInterval", false, value);
}
bool GCPointTemplate::GetAsynchronouslySpawnEntities() const {
    return GetSchemaValue<bool>(m_ptr, "CPointTemplate", "m_bAsynchronouslySpawnEntities");
}
void GCPointTemplate::SetAsynchronouslySpawnEntities(bool value) {
    SetSchemaValue(m_ptr, "CPointTemplate", "m_bAsynchronouslySpawnEntities", false, value);
}
GCEntityIOOutput GCPointTemplate::GetOutputOnSpawned() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CPointTemplate", "m_pOutputOnSpawned"));
    return value;
}
void GCPointTemplate::SetOutputOnSpawned(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CPointTemplate", "m_pOutputOnSpawned", false, value);
}
uint64_t GCPointTemplate::GetClientOnlyEntityBehavior() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CPointTemplate", "m_clientOnlyEntityBehavior");
}
void GCPointTemplate::SetClientOnlyEntityBehavior(uint64_t value) {
    SetSchemaValue(m_ptr, "CPointTemplate", "m_clientOnlyEntityBehavior", false, value);
}
uint64_t GCPointTemplate::GetOwnerSpawnGroupType() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CPointTemplate", "m_ownerSpawnGroupType");
}
void GCPointTemplate::SetOwnerSpawnGroupType(uint64_t value) {
    SetSchemaValue(m_ptr, "CPointTemplate", "m_ownerSpawnGroupType", false, value);
}
std::vector<uint32> GCPointTemplate::GetCreatedSpawnGroupHandles() const {
    CUtlVector<uint32>* vec = GetSchemaValue<CUtlVector<uint32>*>(m_ptr, "CPointTemplate", "m_createdSpawnGroupHandles"); std::vector<uint32> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCPointTemplate::SetCreatedSpawnGroupHandles(std::vector<uint32> value) {
    SetSchemaValueCUtlVector<uint32>(m_ptr, "CPointTemplate", "m_createdSpawnGroupHandles", false, value);
}
std::vector<GCEntityInstance*> GCPointTemplate::GetSpawnedEntityHandles() const {
    CUtlVector<GCEntityInstance*>* vec = GetSchemaValue<CUtlVector<GCEntityInstance*>*>(m_ptr, "CPointTemplate", "m_SpawnedEntityHandles"); std::vector<GCEntityInstance*> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCPointTemplate::SetSpawnedEntityHandles(std::vector<GCEntityInstance*> value) {
    SetSchemaValueCUtlVector<GCEntityInstance*>(m_ptr, "CPointTemplate", "m_SpawnedEntityHandles", false, value);
}
std::string GCPointTemplate::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCPointTemplate::IsValid() {
    return (m_ptr != nullptr);
}
GCLogicalEntity GCPointTemplate::GetParent() const {
    GCLogicalEntity value(m_ptr);
    return value;
}
void GCPointTemplate::SetParent(GCLogicalEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCPointTemplate(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCPointTemplate>("CPointTemplate")
        .addConstructor<void (*)(std::string)>()
        .addProperty("WorldName", &GCPointTemplate::GetWorldName, &GCPointTemplate::SetWorldName)
        .addProperty("Source2EntityLumpName", &GCPointTemplate::GetSource2EntityLumpName, &GCPointTemplate::SetSource2EntityLumpName)
        .addProperty("EntityFilterName", &GCPointTemplate::GetEntityFilterName, &GCPointTemplate::SetEntityFilterName)
        .addProperty("TimeoutInterval", &GCPointTemplate::GetTimeoutInterval, &GCPointTemplate::SetTimeoutInterval)
        .addProperty("AsynchronouslySpawnEntities", &GCPointTemplate::GetAsynchronouslySpawnEntities, &GCPointTemplate::SetAsynchronouslySpawnEntities)
        .addProperty("OutputOnSpawned", &GCPointTemplate::GetOutputOnSpawned, &GCPointTemplate::SetOutputOnSpawned)
        .addProperty("ClientOnlyEntityBehavior", &GCPointTemplate::GetClientOnlyEntityBehavior, &GCPointTemplate::SetClientOnlyEntityBehavior)
        .addProperty("OwnerSpawnGroupType", &GCPointTemplate::GetOwnerSpawnGroupType, &GCPointTemplate::SetOwnerSpawnGroupType)
        .addProperty("CreatedSpawnGroupHandles", &GCPointTemplate::GetCreatedSpawnGroupHandles, &GCPointTemplate::SetCreatedSpawnGroupHandles)
        .addProperty("SpawnedEntityHandles", &GCPointTemplate::GetSpawnedEntityHandles, &GCPointTemplate::SetSpawnedEntityHandles)
        .addProperty("Parent", &GCPointTemplate::GetParent, &GCPointTemplate::SetParent)
        .addFunction("ToPtr", &GCPointTemplate::ToPtr)
        .addFunction("IsValid", &GCPointTemplate::IsValid)
        .endClass();
}
GCTripWireFire::GCTripWireFire(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCTripWireFire::GCTripWireFire(void *ptr) {
    m_ptr = ptr;
}
std::string GCTripWireFire::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCTripWireFire::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseCSGrenade GCTripWireFire::GetParent() const {
    GCBaseCSGrenade value(m_ptr);
    return value;
}
void GCTripWireFire::SetParent(GCBaseCSGrenade value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCTripWireFire(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCTripWireFire>("CTripWireFire")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCTripWireFire::GetParent, &GCTripWireFire::SetParent)
        .addFunction("ToPtr", &GCTripWireFire::ToPtr)
        .addFunction("IsValid", &GCTripWireFire::IsValid)
        .endClass();
}
GCPhysForce::GCPhysForce(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCPhysForce::GCPhysForce(void *ptr) {
    m_ptr = ptr;
}
std::string GCPhysForce::GetNameAttach() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CPhysForce", "m_nameAttach").String();
}
void GCPhysForce::SetNameAttach(std::string value) {
    SetSchemaValue(m_ptr, "CPhysForce", "m_nameAttach", false, CUtlSymbolLarge(value.c_str()));
}
float GCPhysForce::GetForce() const {
    return GetSchemaValue<float>(m_ptr, "CPhysForce", "m_force");
}
void GCPhysForce::SetForce(float value) {
    SetSchemaValue(m_ptr, "CPhysForce", "m_force", false, value);
}
float GCPhysForce::GetForceTime() const {
    return GetSchemaValue<float>(m_ptr, "CPhysForce", "m_forceTime");
}
void GCPhysForce::SetForceTime(float value) {
    SetSchemaValue(m_ptr, "CPhysForce", "m_forceTime", false, value);
}
GCBaseEntity GCPhysForce::GetAttachedObject() const {
    GCBaseEntity value(*GetSchemaValuePtr<void*>(m_ptr, "CPhysForce", "m_attachedObject"));
    return value;
}
void GCPhysForce::SetAttachedObject(GCBaseEntity* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'AttachedObject' is not possible.\n");
}
bool GCPhysForce::GetWasRestored() const {
    return GetSchemaValue<bool>(m_ptr, "CPhysForce", "m_wasRestored");
}
void GCPhysForce::SetWasRestored(bool value) {
    SetSchemaValue(m_ptr, "CPhysForce", "m_wasRestored", false, value);
}
GCConstantForceController GCPhysForce::GetIntegrator() const {
    GCConstantForceController value(GetSchemaPtr(m_ptr, "CPhysForce", "m_integrator"));
    return value;
}
void GCPhysForce::SetIntegrator(GCConstantForceController value) {
    SetSchemaValue(m_ptr, "CPhysForce", "m_integrator", false, value);
}
std::string GCPhysForce::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCPhysForce::IsValid() {
    return (m_ptr != nullptr);
}
GCPointEntity GCPhysForce::GetParent() const {
    GCPointEntity value(m_ptr);
    return value;
}
void GCPhysForce::SetParent(GCPointEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCPhysForce(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCPhysForce>("CPhysForce")
        .addConstructor<void (*)(std::string)>()
        .addProperty("NameAttach", &GCPhysForce::GetNameAttach, &GCPhysForce::SetNameAttach)
        .addProperty("Force", &GCPhysForce::GetForce, &GCPhysForce::SetForce)
        .addProperty("ForceTime", &GCPhysForce::GetForceTime, &GCPhysForce::SetForceTime)
        .addProperty("AttachedObject", &GCPhysForce::GetAttachedObject, &GCPhysForce::SetAttachedObject)
        .addProperty("WasRestored", &GCPhysForce::GetWasRestored, &GCPhysForce::SetWasRestored)
        .addProperty("Integrator", &GCPhysForce::GetIntegrator, &GCPhysForce::SetIntegrator)
        .addProperty("Parent", &GCPhysForce::GetParent, &GCPhysForce::SetParent)
        .addFunction("ToPtr", &GCPhysForce::ToPtr)
        .addFunction("IsValid", &GCPhysForce::IsValid)
        .endClass();
}
GCLogicDistanceAutosave::GCLogicDistanceAutosave(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCLogicDistanceAutosave::GCLogicDistanceAutosave(void *ptr) {
    m_ptr = ptr;
}
std::string GCLogicDistanceAutosave::GetTargetEntity() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CLogicDistanceAutosave", "m_iszTargetEntity").String();
}
void GCLogicDistanceAutosave::SetTargetEntity(std::string value) {
    SetSchemaValue(m_ptr, "CLogicDistanceAutosave", "m_iszTargetEntity", false, CUtlSymbolLarge(value.c_str()));
}
float GCLogicDistanceAutosave::GetDistanceToPlayer() const {
    return GetSchemaValue<float>(m_ptr, "CLogicDistanceAutosave", "m_flDistanceToPlayer");
}
void GCLogicDistanceAutosave::SetDistanceToPlayer(float value) {
    SetSchemaValue(m_ptr, "CLogicDistanceAutosave", "m_flDistanceToPlayer", false, value);
}
bool GCLogicDistanceAutosave::GetForceNewLevelUnit() const {
    return GetSchemaValue<bool>(m_ptr, "CLogicDistanceAutosave", "m_bForceNewLevelUnit");
}
void GCLogicDistanceAutosave::SetForceNewLevelUnit(bool value) {
    SetSchemaValue(m_ptr, "CLogicDistanceAutosave", "m_bForceNewLevelUnit", false, value);
}
bool GCLogicDistanceAutosave::GetCheckCough() const {
    return GetSchemaValue<bool>(m_ptr, "CLogicDistanceAutosave", "m_bCheckCough");
}
void GCLogicDistanceAutosave::SetCheckCough(bool value) {
    SetSchemaValue(m_ptr, "CLogicDistanceAutosave", "m_bCheckCough", false, value);
}
bool GCLogicDistanceAutosave::GetThinkDangerous() const {
    return GetSchemaValue<bool>(m_ptr, "CLogicDistanceAutosave", "m_bThinkDangerous");
}
void GCLogicDistanceAutosave::SetThinkDangerous(bool value) {
    SetSchemaValue(m_ptr, "CLogicDistanceAutosave", "m_bThinkDangerous", false, value);
}
float GCLogicDistanceAutosave::GetDangerousTime() const {
    return GetSchemaValue<float>(m_ptr, "CLogicDistanceAutosave", "m_flDangerousTime");
}
void GCLogicDistanceAutosave::SetDangerousTime(float value) {
    SetSchemaValue(m_ptr, "CLogicDistanceAutosave", "m_flDangerousTime", false, value);
}
std::string GCLogicDistanceAutosave::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCLogicDistanceAutosave::IsValid() {
    return (m_ptr != nullptr);
}
GCLogicalEntity GCLogicDistanceAutosave::GetParent() const {
    GCLogicalEntity value(m_ptr);
    return value;
}
void GCLogicDistanceAutosave::SetParent(GCLogicalEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCLogicDistanceAutosave(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCLogicDistanceAutosave>("CLogicDistanceAutosave")
        .addConstructor<void (*)(std::string)>()
        .addProperty("TargetEntity", &GCLogicDistanceAutosave::GetTargetEntity, &GCLogicDistanceAutosave::SetTargetEntity)
        .addProperty("DistanceToPlayer", &GCLogicDistanceAutosave::GetDistanceToPlayer, &GCLogicDistanceAutosave::SetDistanceToPlayer)
        .addProperty("ForceNewLevelUnit", &GCLogicDistanceAutosave::GetForceNewLevelUnit, &GCLogicDistanceAutosave::SetForceNewLevelUnit)
        .addProperty("CheckCough", &GCLogicDistanceAutosave::GetCheckCough, &GCLogicDistanceAutosave::SetCheckCough)
        .addProperty("ThinkDangerous", &GCLogicDistanceAutosave::GetThinkDangerous, &GCLogicDistanceAutosave::SetThinkDangerous)
        .addProperty("DangerousTime", &GCLogicDistanceAutosave::GetDangerousTime, &GCLogicDistanceAutosave::SetDangerousTime)
        .addProperty("Parent", &GCLogicDistanceAutosave::GetParent, &GCLogicDistanceAutosave::SetParent)
        .addFunction("ToPtr", &GCLogicDistanceAutosave::ToPtr)
        .addFunction("IsValid", &GCLogicDistanceAutosave::IsValid)
        .endClass();
}
GCInfoDynamicShadowHint::GCInfoDynamicShadowHint(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCInfoDynamicShadowHint::GCInfoDynamicShadowHint(void *ptr) {
    m_ptr = ptr;
}
bool GCInfoDynamicShadowHint::GetDisabled() const {
    return GetSchemaValue<bool>(m_ptr, "CInfoDynamicShadowHint", "m_bDisabled");
}
void GCInfoDynamicShadowHint::SetDisabled(bool value) {
    SetSchemaValue(m_ptr, "CInfoDynamicShadowHint", "m_bDisabled", false, value);
}
float GCInfoDynamicShadowHint::GetRange() const {
    return GetSchemaValue<float>(m_ptr, "CInfoDynamicShadowHint", "m_flRange");
}
void GCInfoDynamicShadowHint::SetRange(float value) {
    SetSchemaValue(m_ptr, "CInfoDynamicShadowHint", "m_flRange", false, value);
}
int32_t GCInfoDynamicShadowHint::GetImportance() const {
    return GetSchemaValue<int32_t>(m_ptr, "CInfoDynamicShadowHint", "m_nImportance");
}
void GCInfoDynamicShadowHint::SetImportance(int32_t value) {
    SetSchemaValue(m_ptr, "CInfoDynamicShadowHint", "m_nImportance", false, value);
}
int32_t GCInfoDynamicShadowHint::GetLightChoice() const {
    return GetSchemaValue<int32_t>(m_ptr, "CInfoDynamicShadowHint", "m_nLightChoice");
}
void GCInfoDynamicShadowHint::SetLightChoice(int32_t value) {
    SetSchemaValue(m_ptr, "CInfoDynamicShadowHint", "m_nLightChoice", false, value);
}
GCBaseEntity GCInfoDynamicShadowHint::GetLight() const {
    GCBaseEntity value(*GetSchemaValuePtr<void*>(m_ptr, "CInfoDynamicShadowHint", "m_hLight"));
    return value;
}
void GCInfoDynamicShadowHint::SetLight(GCBaseEntity* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Light' is not possible.\n");
}
std::string GCInfoDynamicShadowHint::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCInfoDynamicShadowHint::IsValid() {
    return (m_ptr != nullptr);
}
GCPointEntity GCInfoDynamicShadowHint::GetParent() const {
    GCPointEntity value(m_ptr);
    return value;
}
void GCInfoDynamicShadowHint::SetParent(GCPointEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCInfoDynamicShadowHint(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCInfoDynamicShadowHint>("CInfoDynamicShadowHint")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Disabled", &GCInfoDynamicShadowHint::GetDisabled, &GCInfoDynamicShadowHint::SetDisabled)
        .addProperty("Range", &GCInfoDynamicShadowHint::GetRange, &GCInfoDynamicShadowHint::SetRange)
        .addProperty("Importance", &GCInfoDynamicShadowHint::GetImportance, &GCInfoDynamicShadowHint::SetImportance)
        .addProperty("LightChoice", &GCInfoDynamicShadowHint::GetLightChoice, &GCInfoDynamicShadowHint::SetLightChoice)
        .addProperty("Light", &GCInfoDynamicShadowHint::GetLight, &GCInfoDynamicShadowHint::SetLight)
        .addProperty("Parent", &GCInfoDynamicShadowHint::GetParent, &GCInfoDynamicShadowHint::SetParent)
        .addFunction("ToPtr", &GCInfoDynamicShadowHint::ToPtr)
        .addFunction("IsValid", &GCInfoDynamicShadowHint::IsValid)
        .endClass();
}
GCSoundOpvarSetOBBEntity::GCSoundOpvarSetOBBEntity(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCSoundOpvarSetOBBEntity::GCSoundOpvarSetOBBEntity(void *ptr) {
    m_ptr = ptr;
}
std::string GCSoundOpvarSetOBBEntity::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCSoundOpvarSetOBBEntity::IsValid() {
    return (m_ptr != nullptr);
}
GCSoundOpvarSetAABBEntity GCSoundOpvarSetOBBEntity::GetParent() const {
    GCSoundOpvarSetAABBEntity value(m_ptr);
    return value;
}
void GCSoundOpvarSetOBBEntity::SetParent(GCSoundOpvarSetAABBEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCSoundOpvarSetOBBEntity(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCSoundOpvarSetOBBEntity>("CSoundOpvarSetOBBEntity")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCSoundOpvarSetOBBEntity::GetParent, &GCSoundOpvarSetOBBEntity::SetParent)
        .addFunction("ToPtr", &GCSoundOpvarSetOBBEntity::ToPtr)
        .addFunction("IsValid", &GCSoundOpvarSetOBBEntity::IsValid)
        .endClass();
}
GCEnvWindShared__WindVariationEvent_t::GCEnvWindShared__WindVariationEvent_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCEnvWindShared__WindVariationEvent_t::GCEnvWindShared__WindVariationEvent_t(void *ptr) {
    m_ptr = ptr;
}
float GCEnvWindShared__WindVariationEvent_t::GetWindAngleVariation() const {
    return GetSchemaValue<float>(m_ptr, "CEnvWindShared__WindVariationEvent_t", "m_flWindAngleVariation");
}
void GCEnvWindShared__WindVariationEvent_t::SetWindAngleVariation(float value) {
    SetSchemaValue(m_ptr, "CEnvWindShared__WindVariationEvent_t", "m_flWindAngleVariation", true, value);
}
float GCEnvWindShared__WindVariationEvent_t::GetWindSpeedVariation() const {
    return GetSchemaValue<float>(m_ptr, "CEnvWindShared__WindVariationEvent_t", "m_flWindSpeedVariation");
}
void GCEnvWindShared__WindVariationEvent_t::SetWindSpeedVariation(float value) {
    SetSchemaValue(m_ptr, "CEnvWindShared__WindVariationEvent_t", "m_flWindSpeedVariation", true, value);
}
std::string GCEnvWindShared__WindVariationEvent_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCEnvWindShared__WindVariationEvent_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCEnvWindShared__WindVariationEvent_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCEnvWindShared__WindVariationEvent_t>("CEnvWindShared__WindVariationEvent_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("WindAngleVariation", &GCEnvWindShared__WindVariationEvent_t::GetWindAngleVariation, &GCEnvWindShared__WindVariationEvent_t::SetWindAngleVariation)
        .addProperty("WindSpeedVariation", &GCEnvWindShared__WindVariationEvent_t::GetWindSpeedVariation, &GCEnvWindShared__WindVariationEvent_t::SetWindSpeedVariation)
        .addFunction("ToPtr", &GCEnvWindShared__WindVariationEvent_t::ToPtr)
        .addFunction("IsValid", &GCEnvWindShared__WindVariationEvent_t::IsValid)
        .endClass();
}
GCTakeDamageInfoAPI::GCTakeDamageInfoAPI(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCTakeDamageInfoAPI::GCTakeDamageInfoAPI(void *ptr) {
    m_ptr = ptr;
}
std::string GCTakeDamageInfoAPI::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCTakeDamageInfoAPI::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCTakeDamageInfoAPI(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCTakeDamageInfoAPI>("CTakeDamageInfoAPI")
        .addConstructor<void (*)(std::string)>()
        .addFunction("ToPtr", &GCTakeDamageInfoAPI::ToPtr)
        .addFunction("IsValid", &GCTakeDamageInfoAPI::IsValid)
        .endClass();
}
GCScriptTriggerOnce::GCScriptTriggerOnce(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCScriptTriggerOnce::GCScriptTriggerOnce(void *ptr) {
    m_ptr = ptr;
}
Vector GCScriptTriggerOnce::GetExtent() const {
    return GetSchemaValue<Vector>(m_ptr, "CScriptTriggerOnce", "m_vExtent");
}
void GCScriptTriggerOnce::SetExtent(Vector value) {
    SetSchemaValue(m_ptr, "CScriptTriggerOnce", "m_vExtent", false, value);
}
std::string GCScriptTriggerOnce::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCScriptTriggerOnce::IsValid() {
    return (m_ptr != nullptr);
}
GCTriggerOnce GCScriptTriggerOnce::GetParent() const {
    GCTriggerOnce value(m_ptr);
    return value;
}
void GCScriptTriggerOnce::SetParent(GCTriggerOnce value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCScriptTriggerOnce(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCScriptTriggerOnce>("CScriptTriggerOnce")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Extent", &GCScriptTriggerOnce::GetExtent, &GCScriptTriggerOnce::SetExtent)
        .addProperty("Parent", &GCScriptTriggerOnce::GetParent, &GCScriptTriggerOnce::SetParent)
        .addFunction("ToPtr", &GCScriptTriggerOnce::ToPtr)
        .addFunction("IsValid", &GCScriptTriggerOnce::IsValid)
        .endClass();
}
GCNavWalkable::GCNavWalkable(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCNavWalkable::GCNavWalkable(void *ptr) {
    m_ptr = ptr;
}
std::string GCNavWalkable::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCNavWalkable::IsValid() {
    return (m_ptr != nullptr);
}
GCPointEntity GCNavWalkable::GetParent() const {
    GCPointEntity value(m_ptr);
    return value;
}
void GCNavWalkable::SetParent(GCPointEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCNavWalkable(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCNavWalkable>("CNavWalkable")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCNavWalkable::GetParent, &GCNavWalkable::SetParent)
        .addFunction("ToPtr", &GCNavWalkable::ToPtr)
        .addFunction("IsValid", &GCNavWalkable::IsValid)
        .endClass();
}
GCFuncMonitor::GCFuncMonitor(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCFuncMonitor::GCFuncMonitor(void *ptr) {
    m_ptr = ptr;
}
std::string GCFuncMonitor::GetTargetCamera() const {
    return GetSchemaValue<CUtlString>(m_ptr, "CFuncMonitor", "m_targetCamera").Get();
}
void GCFuncMonitor::SetTargetCamera(std::string value) {
    SetSchemaValue(m_ptr, "CFuncMonitor", "m_targetCamera", false, CUtlString(value.c_str()));
}
int32_t GCFuncMonitor::GetResolutionEnum() const {
    return GetSchemaValue<int32_t>(m_ptr, "CFuncMonitor", "m_nResolutionEnum");
}
void GCFuncMonitor::SetResolutionEnum(int32_t value) {
    SetSchemaValue(m_ptr, "CFuncMonitor", "m_nResolutionEnum", false, value);
}
bool GCFuncMonitor::GetRenderShadows() const {
    return GetSchemaValue<bool>(m_ptr, "CFuncMonitor", "m_bRenderShadows");
}
void GCFuncMonitor::SetRenderShadows(bool value) {
    SetSchemaValue(m_ptr, "CFuncMonitor", "m_bRenderShadows", false, value);
}
bool GCFuncMonitor::GetUseUniqueColorTarget() const {
    return GetSchemaValue<bool>(m_ptr, "CFuncMonitor", "m_bUseUniqueColorTarget");
}
void GCFuncMonitor::SetUseUniqueColorTarget(bool value) {
    SetSchemaValue(m_ptr, "CFuncMonitor", "m_bUseUniqueColorTarget", false, value);
}
std::string GCFuncMonitor::GetBrushModelName() const {
    return GetSchemaValue<CUtlString>(m_ptr, "CFuncMonitor", "m_brushModelName").Get();
}
void GCFuncMonitor::SetBrushModelName(std::string value) {
    SetSchemaValue(m_ptr, "CFuncMonitor", "m_brushModelName", false, CUtlString(value.c_str()));
}
GCBaseEntity GCFuncMonitor::GetTargetCamera1() const {
    GCBaseEntity value(*GetSchemaValuePtr<void*>(m_ptr, "CFuncMonitor", "m_hTargetCamera"));
    return value;
}
void GCFuncMonitor::SetTargetCamera1(GCBaseEntity* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'TargetCamera1' is not possible.\n");
}
bool GCFuncMonitor::GetEnabled() const {
    return GetSchemaValue<bool>(m_ptr, "CFuncMonitor", "m_bEnabled");
}
void GCFuncMonitor::SetEnabled(bool value) {
    SetSchemaValue(m_ptr, "CFuncMonitor", "m_bEnabled", false, value);
}
bool GCFuncMonitor::GetDraw3DSkybox() const {
    return GetSchemaValue<bool>(m_ptr, "CFuncMonitor", "m_bDraw3DSkybox");
}
void GCFuncMonitor::SetDraw3DSkybox(bool value) {
    SetSchemaValue(m_ptr, "CFuncMonitor", "m_bDraw3DSkybox", false, value);
}
bool GCFuncMonitor::GetStartEnabled() const {
    return GetSchemaValue<bool>(m_ptr, "CFuncMonitor", "m_bStartEnabled");
}
void GCFuncMonitor::SetStartEnabled(bool value) {
    SetSchemaValue(m_ptr, "CFuncMonitor", "m_bStartEnabled", false, value);
}
std::string GCFuncMonitor::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCFuncMonitor::IsValid() {
    return (m_ptr != nullptr);
}
GCFuncBrush GCFuncMonitor::GetParent() const {
    GCFuncBrush value(m_ptr);
    return value;
}
void GCFuncMonitor::SetParent(GCFuncBrush value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCFuncMonitor(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCFuncMonitor>("CFuncMonitor")
        .addConstructor<void (*)(std::string)>()
        .addProperty("TargetCamera", &GCFuncMonitor::GetTargetCamera, &GCFuncMonitor::SetTargetCamera)
        .addProperty("ResolutionEnum", &GCFuncMonitor::GetResolutionEnum, &GCFuncMonitor::SetResolutionEnum)
        .addProperty("RenderShadows", &GCFuncMonitor::GetRenderShadows, &GCFuncMonitor::SetRenderShadows)
        .addProperty("UseUniqueColorTarget", &GCFuncMonitor::GetUseUniqueColorTarget, &GCFuncMonitor::SetUseUniqueColorTarget)
        .addProperty("BrushModelName", &GCFuncMonitor::GetBrushModelName, &GCFuncMonitor::SetBrushModelName)
        .addProperty("TargetCamera1", &GCFuncMonitor::GetTargetCamera1, &GCFuncMonitor::SetTargetCamera1)
        .addProperty("Enabled", &GCFuncMonitor::GetEnabled, &GCFuncMonitor::SetEnabled)
        .addProperty("Draw3DSkybox", &GCFuncMonitor::GetDraw3DSkybox, &GCFuncMonitor::SetDraw3DSkybox)
        .addProperty("StartEnabled", &GCFuncMonitor::GetStartEnabled, &GCFuncMonitor::SetStartEnabled)
        .addProperty("Parent", &GCFuncMonitor::GetParent, &GCFuncMonitor::SetParent)
        .addFunction("ToPtr", &GCFuncMonitor::ToPtr)
        .addFunction("IsValid", &GCFuncMonitor::IsValid)
        .endClass();
}
GCFlashbangProjectile::GCFlashbangProjectile(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCFlashbangProjectile::GCFlashbangProjectile(void *ptr) {
    m_ptr = ptr;
}
float GCFlashbangProjectile::GetTimeToDetonate() const {
    return GetSchemaValue<float>(m_ptr, "CFlashbangProjectile", "m_flTimeToDetonate");
}
void GCFlashbangProjectile::SetTimeToDetonate(float value) {
    SetSchemaValue(m_ptr, "CFlashbangProjectile", "m_flTimeToDetonate", false, value);
}
uint8_t GCFlashbangProjectile::GetNumOpponentsHit() const {
    return GetSchemaValue<uint8_t>(m_ptr, "CFlashbangProjectile", "m_numOpponentsHit");
}
void GCFlashbangProjectile::SetNumOpponentsHit(uint8_t value) {
    SetSchemaValue(m_ptr, "CFlashbangProjectile", "m_numOpponentsHit", false, value);
}
uint8_t GCFlashbangProjectile::GetNumTeammatesHit() const {
    return GetSchemaValue<uint8_t>(m_ptr, "CFlashbangProjectile", "m_numTeammatesHit");
}
void GCFlashbangProjectile::SetNumTeammatesHit(uint8_t value) {
    SetSchemaValue(m_ptr, "CFlashbangProjectile", "m_numTeammatesHit", false, value);
}
std::string GCFlashbangProjectile::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCFlashbangProjectile::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseCSGrenadeProjectile GCFlashbangProjectile::GetParent() const {
    GCBaseCSGrenadeProjectile value(m_ptr);
    return value;
}
void GCFlashbangProjectile::SetParent(GCBaseCSGrenadeProjectile value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCFlashbangProjectile(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCFlashbangProjectile>("CFlashbangProjectile")
        .addConstructor<void (*)(std::string)>()
        .addProperty("TimeToDetonate", &GCFlashbangProjectile::GetTimeToDetonate, &GCFlashbangProjectile::SetTimeToDetonate)
        .addProperty("NumOpponentsHit", &GCFlashbangProjectile::GetNumOpponentsHit, &GCFlashbangProjectile::SetNumOpponentsHit)
        .addProperty("NumTeammatesHit", &GCFlashbangProjectile::GetNumTeammatesHit, &GCFlashbangProjectile::SetNumTeammatesHit)
        .addProperty("Parent", &GCFlashbangProjectile::GetParent, &GCFlashbangProjectile::SetParent)
        .addFunction("ToPtr", &GCFlashbangProjectile::ToPtr)
        .addFunction("IsValid", &GCFlashbangProjectile::IsValid)
        .endClass();
}
GCPointClientUIWorldTextPanel::GCPointClientUIWorldTextPanel(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCPointClientUIWorldTextPanel::GCPointClientUIWorldTextPanel(void *ptr) {
    m_ptr = ptr;
}
std::string GCPointClientUIWorldTextPanel::GetMessageText() const {
    return GetSchemaValuePtr<char>(m_ptr, "CPointClientUIWorldTextPanel", "m_messageText");
}
void GCPointClientUIWorldTextPanel::SetMessageText(std::string value) {
    WriteSchemaPtrValue(m_ptr, "CPointClientUIWorldTextPanel", "m_messageText", false, reinterpret_cast<byte*>(const_cast<char*>(value.c_str())), 512);
}
std::string GCPointClientUIWorldTextPanel::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCPointClientUIWorldTextPanel::IsValid() {
    return (m_ptr != nullptr);
}
GCPointClientUIWorldPanel GCPointClientUIWorldTextPanel::GetParent() const {
    GCPointClientUIWorldPanel value(m_ptr);
    return value;
}
void GCPointClientUIWorldTextPanel::SetParent(GCPointClientUIWorldPanel value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCPointClientUIWorldTextPanel(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCPointClientUIWorldTextPanel>("CPointClientUIWorldTextPanel")
        .addConstructor<void (*)(std::string)>()
        .addProperty("MessageText", &GCPointClientUIWorldTextPanel::GetMessageText, &GCPointClientUIWorldTextPanel::SetMessageText)
        .addProperty("Parent", &GCPointClientUIWorldTextPanel::GetParent, &GCPointClientUIWorldTextPanel::SetParent)
        .addFunction("ToPtr", &GCPointClientUIWorldTextPanel::ToPtr)
        .addFunction("IsValid", &GCPointClientUIWorldTextPanel::IsValid)
        .endClass();
}
GCInfoInstructorHintTarget::GCInfoInstructorHintTarget(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCInfoInstructorHintTarget::GCInfoInstructorHintTarget(void *ptr) {
    m_ptr = ptr;
}
std::string GCInfoInstructorHintTarget::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCInfoInstructorHintTarget::IsValid() {
    return (m_ptr != nullptr);
}
GCPointEntity GCInfoInstructorHintTarget::GetParent() const {
    GCPointEntity value(m_ptr);
    return value;
}
void GCInfoInstructorHintTarget::SetParent(GCPointEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCInfoInstructorHintTarget(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCInfoInstructorHintTarget>("CInfoInstructorHintTarget")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCInfoInstructorHintTarget::GetParent, &GCInfoInstructorHintTarget::SetParent)
        .addFunction("ToPtr", &GCInfoInstructorHintTarget::ToPtr)
        .addFunction("IsValid", &GCInfoInstructorHintTarget::IsValid)
        .endClass();
}
GCCSPlayer_HostageServices::GCCSPlayer_HostageServices(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCCSPlayer_HostageServices::GCCSPlayer_HostageServices(void *ptr) {
    m_ptr = ptr;
}
GCBaseEntity GCCSPlayer_HostageServices::GetCarriedHostage() const {
    GCBaseEntity value(*GetSchemaValuePtr<void*>(m_ptr, "CCSPlayer_HostageServices", "m_hCarriedHostage"));
    return value;
}
void GCCSPlayer_HostageServices::SetCarriedHostage(GCBaseEntity* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'CarriedHostage' is not possible.\n");
}
GCBaseEntity GCCSPlayer_HostageServices::GetCarriedHostageProp() const {
    GCBaseEntity value(*GetSchemaValuePtr<void*>(m_ptr, "CCSPlayer_HostageServices", "m_hCarriedHostageProp"));
    return value;
}
void GCCSPlayer_HostageServices::SetCarriedHostageProp(GCBaseEntity* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'CarriedHostageProp' is not possible.\n");
}
std::string GCCSPlayer_HostageServices::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCCSPlayer_HostageServices::IsValid() {
    return (m_ptr != nullptr);
}
GCPlayerPawnComponent GCCSPlayer_HostageServices::GetParent() const {
    GCPlayerPawnComponent value(m_ptr);
    return value;
}
void GCCSPlayer_HostageServices::SetParent(GCPlayerPawnComponent value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCCSPlayer_HostageServices(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCCSPlayer_HostageServices>("CCSPlayer_HostageServices")
        .addConstructor<void (*)(std::string)>()
        .addProperty("CarriedHostage", &GCCSPlayer_HostageServices::GetCarriedHostage, &GCCSPlayer_HostageServices::SetCarriedHostage)
        .addProperty("CarriedHostageProp", &GCCSPlayer_HostageServices::GetCarriedHostageProp, &GCCSPlayer_HostageServices::SetCarriedHostageProp)
        .addProperty("Parent", &GCCSPlayer_HostageServices::GetParent, &GCCSPlayer_HostageServices::SetParent)
        .addFunction("ToPtr", &GCCSPlayer_HostageServices::ToPtr)
        .addFunction("IsValid", &GCCSPlayer_HostageServices::IsValid)
        .endClass();
}
GCWeaponSSG08::GCWeaponSSG08(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCWeaponSSG08::GCWeaponSSG08(void *ptr) {
    m_ptr = ptr;
}
std::string GCWeaponSSG08::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCWeaponSSG08::IsValid() {
    return (m_ptr != nullptr);
}
GCCSWeaponBaseGun GCWeaponSSG08::GetParent() const {
    GCCSWeaponBaseGun value(m_ptr);
    return value;
}
void GCWeaponSSG08::SetParent(GCCSWeaponBaseGun value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCWeaponSSG08(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCWeaponSSG08>("CWeaponSSG08")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCWeaponSSG08::GetParent, &GCWeaponSSG08::SetParent)
        .addFunction("ToPtr", &GCWeaponSSG08::ToPtr)
        .addFunction("IsValid", &GCWeaponSSG08::IsValid)
        .endClass();
}
GCBreachCharge::GCBreachCharge(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCBreachCharge::GCBreachCharge(void *ptr) {
    m_ptr = ptr;
}
std::string GCBreachCharge::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCBreachCharge::IsValid() {
    return (m_ptr != nullptr);
}
GCCSWeaponBase GCBreachCharge::GetParent() const {
    GCCSWeaponBase value(m_ptr);
    return value;
}
void GCBreachCharge::SetParent(GCCSWeaponBase value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCBreachCharge(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCBreachCharge>("CBreachCharge")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCBreachCharge::GetParent, &GCBreachCharge::SetParent)
        .addFunction("ToPtr", &GCBreachCharge::ToPtr)
        .addFunction("IsValid", &GCBreachCharge::IsValid)
        .endClass();
}
GCLogicBranch::GCLogicBranch(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCLogicBranch::GCLogicBranch(void *ptr) {
    m_ptr = ptr;
}
bool GCLogicBranch::GetInValue() const {
    return GetSchemaValue<bool>(m_ptr, "CLogicBranch", "m_bInValue");
}
void GCLogicBranch::SetInValue(bool value) {
    SetSchemaValue(m_ptr, "CLogicBranch", "m_bInValue", false, value);
}
GCEntityIOOutput GCLogicBranch::GetOnTrue() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CLogicBranch", "m_OnTrue"));
    return value;
}
void GCLogicBranch::SetOnTrue(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CLogicBranch", "m_OnTrue", false, value);
}
GCEntityIOOutput GCLogicBranch::GetOnFalse() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CLogicBranch", "m_OnFalse"));
    return value;
}
void GCLogicBranch::SetOnFalse(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CLogicBranch", "m_OnFalse", false, value);
}
std::string GCLogicBranch::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCLogicBranch::IsValid() {
    return (m_ptr != nullptr);
}
GCLogicalEntity GCLogicBranch::GetParent() const {
    GCLogicalEntity value(m_ptr);
    return value;
}
void GCLogicBranch::SetParent(GCLogicalEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCLogicBranch(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCLogicBranch>("CLogicBranch")
        .addConstructor<void (*)(std::string)>()
        .addProperty("InValue", &GCLogicBranch::GetInValue, &GCLogicBranch::SetInValue)
        .addProperty("OnTrue", &GCLogicBranch::GetOnTrue, &GCLogicBranch::SetOnTrue)
        .addProperty("OnFalse", &GCLogicBranch::GetOnFalse, &GCLogicBranch::SetOnFalse)
        .addProperty("Parent", &GCLogicBranch::GetParent, &GCLogicBranch::SetParent)
        .addFunction("ToPtr", &GCLogicBranch::ToPtr)
        .addFunction("IsValid", &GCLogicBranch::IsValid)
        .endClass();
}
GCWeaponUMP45::GCWeaponUMP45(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCWeaponUMP45::GCWeaponUMP45(void *ptr) {
    m_ptr = ptr;
}
std::string GCWeaponUMP45::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCWeaponUMP45::IsValid() {
    return (m_ptr != nullptr);
}
GCCSWeaponBaseGun GCWeaponUMP45::GetParent() const {
    GCCSWeaponBaseGun value(m_ptr);
    return value;
}
void GCWeaponUMP45::SetParent(GCCSWeaponBaseGun value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCWeaponUMP45(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCWeaponUMP45>("CWeaponUMP45")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCWeaponUMP45::GetParent, &GCWeaponUMP45::SetParent)
        .addFunction("ToPtr", &GCWeaponUMP45::ToPtr)
        .addFunction("IsValid", &GCWeaponUMP45::IsValid)
        .endClass();
}
GCSpriteAlias_env_glow::GCSpriteAlias_env_glow(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCSpriteAlias_env_glow::GCSpriteAlias_env_glow(void *ptr) {
    m_ptr = ptr;
}
std::string GCSpriteAlias_env_glow::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCSpriteAlias_env_glow::IsValid() {
    return (m_ptr != nullptr);
}
GCSprite GCSpriteAlias_env_glow::GetParent() const {
    GCSprite value(m_ptr);
    return value;
}
void GCSpriteAlias_env_glow::SetParent(GCSprite value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCSpriteAlias_env_glow(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCSpriteAlias_env_glow>("CSpriteAlias_env_glow")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCSpriteAlias_env_glow::GetParent, &GCSpriteAlias_env_glow::SetParent)
        .addFunction("ToPtr", &GCSpriteAlias_env_glow::ToPtr)
        .addFunction("IsValid", &GCSpriteAlias_env_glow::IsValid)
        .endClass();
}
GCPhysicalButton::GCPhysicalButton(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCPhysicalButton::GCPhysicalButton(void *ptr) {
    m_ptr = ptr;
}
std::string GCPhysicalButton::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCPhysicalButton::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseButton GCPhysicalButton::GetParent() const {
    GCBaseButton value(m_ptr);
    return value;
}
void GCPhysicalButton::SetParent(GCBaseButton value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCPhysicalButton(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCPhysicalButton>("CPhysicalButton")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCPhysicalButton::GetParent, &GCPhysicalButton::SetParent)
        .addFunction("ToPtr", &GCPhysicalButton::ToPtr)
        .addFunction("IsValid", &GCPhysicalButton::IsValid)
        .endClass();
}
GCPhysLength::GCPhysLength(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCPhysLength::GCPhysLength(void *ptr) {
    m_ptr = ptr;
}
std::vector<Vector> GCPhysLength::GetOffset() const {
    Vector* outValue = GetSchemaValue<Vector*>(m_ptr, "CPhysLength", "m_offset"); std::vector<Vector> ret; for(int i = 0; i < 2; i++) { ret.push_back(outValue[i]); } return ret;
}
void GCPhysLength::SetOffset(std::vector<Vector> value) {
    Vector* outValue = GetSchemaValue<Vector*>(m_ptr, "CPhysLength", "m_offset"); for(int i = 0; i < 2; i++) { outValue[i] = value[i]; } SetSchemaValue(m_ptr, "CPhysLength", "m_offset", false, outValue);
}
Vector GCPhysLength::GetAttach() const {
    return GetSchemaValue<Vector>(m_ptr, "CPhysLength", "m_vecAttach");
}
void GCPhysLength::SetAttach(Vector value) {
    SetSchemaValue(m_ptr, "CPhysLength", "m_vecAttach", false, value);
}
float GCPhysLength::GetAddLength() const {
    return GetSchemaValue<float>(m_ptr, "CPhysLength", "m_addLength");
}
void GCPhysLength::SetAddLength(float value) {
    SetSchemaValue(m_ptr, "CPhysLength", "m_addLength", false, value);
}
float GCPhysLength::GetMinLength() const {
    return GetSchemaValue<float>(m_ptr, "CPhysLength", "m_minLength");
}
void GCPhysLength::SetMinLength(float value) {
    SetSchemaValue(m_ptr, "CPhysLength", "m_minLength", false, value);
}
float GCPhysLength::GetTotalLength() const {
    return GetSchemaValue<float>(m_ptr, "CPhysLength", "m_totalLength");
}
void GCPhysLength::SetTotalLength(float value) {
    SetSchemaValue(m_ptr, "CPhysLength", "m_totalLength", false, value);
}
bool GCPhysLength::GetEnableCollision() const {
    return GetSchemaValue<bool>(m_ptr, "CPhysLength", "m_bEnableCollision");
}
void GCPhysLength::SetEnableCollision(bool value) {
    SetSchemaValue(m_ptr, "CPhysLength", "m_bEnableCollision", false, value);
}
std::string GCPhysLength::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCPhysLength::IsValid() {
    return (m_ptr != nullptr);
}
GCPhysConstraint GCPhysLength::GetParent() const {
    GCPhysConstraint value(m_ptr);
    return value;
}
void GCPhysLength::SetParent(GCPhysConstraint value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCPhysLength(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCPhysLength>("CPhysLength")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Offset", &GCPhysLength::GetOffset, &GCPhysLength::SetOffset)
        .addProperty("Attach", &GCPhysLength::GetAttach, &GCPhysLength::SetAttach)
        .addProperty("AddLength", &GCPhysLength::GetAddLength, &GCPhysLength::SetAddLength)
        .addProperty("MinLength", &GCPhysLength::GetMinLength, &GCPhysLength::SetMinLength)
        .addProperty("TotalLength", &GCPhysLength::GetTotalLength, &GCPhysLength::SetTotalLength)
        .addProperty("EnableCollision", &GCPhysLength::GetEnableCollision, &GCPhysLength::SetEnableCollision)
        .addProperty("Parent", &GCPhysLength::GetParent, &GCPhysLength::SetParent)
        .addFunction("ToPtr", &GCPhysLength::ToPtr)
        .addFunction("IsValid", &GCPhysLength::IsValid)
        .endClass();
}
GCLogicNPCCounterOBB::GCLogicNPCCounterOBB(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCLogicNPCCounterOBB::GCLogicNPCCounterOBB(void *ptr) {
    m_ptr = ptr;
}
std::string GCLogicNPCCounterOBB::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCLogicNPCCounterOBB::IsValid() {
    return (m_ptr != nullptr);
}
GCLogicNPCCounterAABB GCLogicNPCCounterOBB::GetParent() const {
    GCLogicNPCCounterAABB value(m_ptr);
    return value;
}
void GCLogicNPCCounterOBB::SetParent(GCLogicNPCCounterAABB value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCLogicNPCCounterOBB(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCLogicNPCCounterOBB>("CLogicNPCCounterOBB")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCLogicNPCCounterOBB::GetParent, &GCLogicNPCCounterOBB::SetParent)
        .addFunction("ToPtr", &GCLogicNPCCounterOBB::ToPtr)
        .addFunction("IsValid", &GCLogicNPCCounterOBB::IsValid)
        .endClass();
}
GCCSGOViewModel::GCCSGOViewModel(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCCSGOViewModel::GCCSGOViewModel(void *ptr) {
    m_ptr = ptr;
}
bool GCCSGOViewModel::GetShouldIgnoreOffsetAndAccuracy() const {
    return GetSchemaValue<bool>(m_ptr, "CCSGOViewModel", "m_bShouldIgnoreOffsetAndAccuracy");
}
void GCCSGOViewModel::SetShouldIgnoreOffsetAndAccuracy(bool value) {
    SetSchemaValue(m_ptr, "CCSGOViewModel", "m_bShouldIgnoreOffsetAndAccuracy", false, value);
}
uint32_t GCCSGOViewModel::GetWeaponParity() const {
    return GetSchemaValue<uint32_t>(m_ptr, "CCSGOViewModel", "m_nWeaponParity");
}
void GCCSGOViewModel::SetWeaponParity(uint32_t value) {
    SetSchemaValue(m_ptr, "CCSGOViewModel", "m_nWeaponParity", false, value);
}
uint32_t GCCSGOViewModel::GetOldWeaponParity() const {
    return GetSchemaValue<uint32_t>(m_ptr, "CCSGOViewModel", "m_nOldWeaponParity");
}
void GCCSGOViewModel::SetOldWeaponParity(uint32_t value) {
    SetSchemaValue(m_ptr, "CCSGOViewModel", "m_nOldWeaponParity", false, value);
}
std::string GCCSGOViewModel::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCCSGOViewModel::IsValid() {
    return (m_ptr != nullptr);
}
GCPredictedViewModel GCCSGOViewModel::GetParent() const {
    GCPredictedViewModel value(m_ptr);
    return value;
}
void GCCSGOViewModel::SetParent(GCPredictedViewModel value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCCSGOViewModel(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCCSGOViewModel>("CCSGOViewModel")
        .addConstructor<void (*)(std::string)>()
        .addProperty("ShouldIgnoreOffsetAndAccuracy", &GCCSGOViewModel::GetShouldIgnoreOffsetAndAccuracy, &GCCSGOViewModel::SetShouldIgnoreOffsetAndAccuracy)
        .addProperty("WeaponParity", &GCCSGOViewModel::GetWeaponParity, &GCCSGOViewModel::SetWeaponParity)
        .addProperty("OldWeaponParity", &GCCSGOViewModel::GetOldWeaponParity, &GCCSGOViewModel::SetOldWeaponParity)
        .addProperty("Parent", &GCCSGOViewModel::GetParent, &GCCSGOViewModel::SetParent)
        .addFunction("ToPtr", &GCCSGOViewModel::ToPtr)
        .addFunction("IsValid", &GCCSGOViewModel::IsValid)
        .endClass();
}
GCWeaponShield::GCWeaponShield(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCWeaponShield::GCWeaponShield(void *ptr) {
    m_ptr = ptr;
}
float GCWeaponShield::GetBulletDamageAbsorbed() const {
    return GetSchemaValue<float>(m_ptr, "CWeaponShield", "m_flBulletDamageAbsorbed");
}
void GCWeaponShield::SetBulletDamageAbsorbed(float value) {
    SetSchemaValue(m_ptr, "CWeaponShield", "m_flBulletDamageAbsorbed", false, value);
}
float GCWeaponShield::GetLastBulletHitSoundTime() const {
    return GetSchemaValue<float>(m_ptr, "CWeaponShield", "m_flLastBulletHitSoundTime");
}
void GCWeaponShield::SetLastBulletHitSoundTime(float value) {
    SetSchemaValue(m_ptr, "CWeaponShield", "m_flLastBulletHitSoundTime", false, value);
}
float GCWeaponShield::GetDisplayHealth() const {
    return GetSchemaValue<float>(m_ptr, "CWeaponShield", "m_flDisplayHealth");
}
void GCWeaponShield::SetDisplayHealth(float value) {
    SetSchemaValue(m_ptr, "CWeaponShield", "m_flDisplayHealth", false, value);
}
std::string GCWeaponShield::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCWeaponShield::IsValid() {
    return (m_ptr != nullptr);
}
GCCSWeaponBaseGun GCWeaponShield::GetParent() const {
    GCCSWeaponBaseGun value(m_ptr);
    return value;
}
void GCWeaponShield::SetParent(GCCSWeaponBaseGun value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCWeaponShield(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCWeaponShield>("CWeaponShield")
        .addConstructor<void (*)(std::string)>()
        .addProperty("BulletDamageAbsorbed", &GCWeaponShield::GetBulletDamageAbsorbed, &GCWeaponShield::SetBulletDamageAbsorbed)
        .addProperty("LastBulletHitSoundTime", &GCWeaponShield::GetLastBulletHitSoundTime, &GCWeaponShield::SetLastBulletHitSoundTime)
        .addProperty("DisplayHealth", &GCWeaponShield::GetDisplayHealth, &GCWeaponShield::SetDisplayHealth)
        .addProperty("Parent", &GCWeaponShield::GetParent, &GCWeaponShield::SetParent)
        .addFunction("ToPtr", &GCWeaponShield::ToPtr)
        .addFunction("IsValid", &GCWeaponShield::IsValid)
        .endClass();
}
GCBlood::GCBlood(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCBlood::GCBlood(void *ptr) {
    m_ptr = ptr;
}
QAngle GCBlood::GetSprayAngles() const {
    return GetSchemaValue<QAngle>(m_ptr, "CBlood", "m_vecSprayAngles");
}
void GCBlood::SetSprayAngles(QAngle value) {
    SetSchemaValue(m_ptr, "CBlood", "m_vecSprayAngles", false, value);
}
Vector GCBlood::GetSprayDir() const {
    return GetSchemaValue<Vector>(m_ptr, "CBlood", "m_vecSprayDir");
}
void GCBlood::SetSprayDir(Vector value) {
    SetSchemaValue(m_ptr, "CBlood", "m_vecSprayDir", false, value);
}
float GCBlood::GetAmount() const {
    return GetSchemaValue<float>(m_ptr, "CBlood", "m_flAmount");
}
void GCBlood::SetAmount(float value) {
    SetSchemaValue(m_ptr, "CBlood", "m_flAmount", false, value);
}
uint64_t GCBlood::GetColor() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CBlood", "m_Color");
}
void GCBlood::SetColor(uint64_t value) {
    SetSchemaValue(m_ptr, "CBlood", "m_Color", false, value);
}
std::string GCBlood::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCBlood::IsValid() {
    return (m_ptr != nullptr);
}
GCPointEntity GCBlood::GetParent() const {
    GCPointEntity value(m_ptr);
    return value;
}
void GCBlood::SetParent(GCPointEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCBlood(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCBlood>("CBlood")
        .addConstructor<void (*)(std::string)>()
        .addProperty("SprayAngles", &GCBlood::GetSprayAngles, &GCBlood::SetSprayAngles)
        .addProperty("SprayDir", &GCBlood::GetSprayDir, &GCBlood::SetSprayDir)
        .addProperty("Amount", &GCBlood::GetAmount, &GCBlood::SetAmount)
        .addProperty("Color", &GCBlood::GetColor, &GCBlood::SetColor)
        .addProperty("Parent", &GCBlood::GetParent, &GCBlood::SetParent)
        .addFunction("ToPtr", &GCBlood::ToPtr)
        .addFunction("IsValid", &GCBlood::IsValid)
        .endClass();
}
GCEnvFade::GCEnvFade(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCEnvFade::GCEnvFade(void *ptr) {
    m_ptr = ptr;
}
Color GCEnvFade::GetFadeColor() const {
    return GetSchemaValue<Color>(m_ptr, "CEnvFade", "m_fadeColor");
}
void GCEnvFade::SetFadeColor(Color value) {
    SetSchemaValue(m_ptr, "CEnvFade", "m_fadeColor", false, value);
}
float GCEnvFade::GetDuration() const {
    return GetSchemaValue<float>(m_ptr, "CEnvFade", "m_Duration");
}
void GCEnvFade::SetDuration(float value) {
    SetSchemaValue(m_ptr, "CEnvFade", "m_Duration", false, value);
}
float GCEnvFade::GetHoldDuration() const {
    return GetSchemaValue<float>(m_ptr, "CEnvFade", "m_HoldDuration");
}
void GCEnvFade::SetHoldDuration(float value) {
    SetSchemaValue(m_ptr, "CEnvFade", "m_HoldDuration", false, value);
}
GCEntityIOOutput GCEnvFade::GetOnBeginFade() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CEnvFade", "m_OnBeginFade"));
    return value;
}
void GCEnvFade::SetOnBeginFade(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CEnvFade", "m_OnBeginFade", false, value);
}
std::string GCEnvFade::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCEnvFade::IsValid() {
    return (m_ptr != nullptr);
}
GCLogicalEntity GCEnvFade::GetParent() const {
    GCLogicalEntity value(m_ptr);
    return value;
}
void GCEnvFade::SetParent(GCLogicalEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCEnvFade(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCEnvFade>("CEnvFade")
        .addConstructor<void (*)(std::string)>()
        .addProperty("FadeColor", &GCEnvFade::GetFadeColor, &GCEnvFade::SetFadeColor)
        .addProperty("Duration", &GCEnvFade::GetDuration, &GCEnvFade::SetDuration)
        .addProperty("HoldDuration", &GCEnvFade::GetHoldDuration, &GCEnvFade::SetHoldDuration)
        .addProperty("OnBeginFade", &GCEnvFade::GetOnBeginFade, &GCEnvFade::SetOnBeginFade)
        .addProperty("Parent", &GCEnvFade::GetParent, &GCEnvFade::SetParent)
        .addFunction("ToPtr", &GCEnvFade::ToPtr)
        .addFunction("IsValid", &GCEnvFade::IsValid)
        .endClass();
}
GCDynamicPropAlias_cable_dynamic::GCDynamicPropAlias_cable_dynamic(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCDynamicPropAlias_cable_dynamic::GCDynamicPropAlias_cable_dynamic(void *ptr) {
    m_ptr = ptr;
}
std::string GCDynamicPropAlias_cable_dynamic::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCDynamicPropAlias_cable_dynamic::IsValid() {
    return (m_ptr != nullptr);
}
GCDynamicProp GCDynamicPropAlias_cable_dynamic::GetParent() const {
    GCDynamicProp value(m_ptr);
    return value;
}
void GCDynamicPropAlias_cable_dynamic::SetParent(GCDynamicProp value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCDynamicPropAlias_cable_dynamic(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCDynamicPropAlias_cable_dynamic>("CDynamicPropAlias_cable_dynamic")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCDynamicPropAlias_cable_dynamic::GetParent, &GCDynamicPropAlias_cable_dynamic::SetParent)
        .addFunction("ToPtr", &GCDynamicPropAlias_cable_dynamic::ToPtr)
        .addFunction("IsValid", &GCDynamicPropAlias_cable_dynamic::IsValid)
        .endClass();
}
GCCSPlayer_BuyServices::GCCSPlayer_BuyServices(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCCSPlayer_BuyServices::GCCSPlayer_BuyServices(void *ptr) {
    m_ptr = ptr;
}
std::vector<GSellbackPurchaseEntry_t> GCCSPlayer_BuyServices::GetSellbackPurchaseEntries() const {
    CUtlVector<GSellbackPurchaseEntry_t>* vec = GetSchemaValue<CUtlVector<GSellbackPurchaseEntry_t>*>(m_ptr, "CCSPlayer_BuyServices", "m_vecSellbackPurchaseEntries"); std::vector<GSellbackPurchaseEntry_t> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCCSPlayer_BuyServices::SetSellbackPurchaseEntries(std::vector<GSellbackPurchaseEntry_t> value) {
    SetSchemaValueCUtlVector<GSellbackPurchaseEntry_t>(m_ptr, "CCSPlayer_BuyServices", "m_vecSellbackPurchaseEntries", false, value);
}
std::string GCCSPlayer_BuyServices::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCCSPlayer_BuyServices::IsValid() {
    return (m_ptr != nullptr);
}
GCPlayerPawnComponent GCCSPlayer_BuyServices::GetParent() const {
    GCPlayerPawnComponent value(m_ptr);
    return value;
}
void GCCSPlayer_BuyServices::SetParent(GCPlayerPawnComponent value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCCSPlayer_BuyServices(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCCSPlayer_BuyServices>("CCSPlayer_BuyServices")
        .addConstructor<void (*)(std::string)>()
        .addProperty("SellbackPurchaseEntries", &GCCSPlayer_BuyServices::GetSellbackPurchaseEntries, &GCCSPlayer_BuyServices::SetSellbackPurchaseEntries)
        .addProperty("Parent", &GCCSPlayer_BuyServices::GetParent, &GCCSPlayer_BuyServices::SetParent)
        .addFunction("ToPtr", &GCCSPlayer_BuyServices::ToPtr)
        .addFunction("IsValid", &GCCSPlayer_BuyServices::IsValid)
        .endClass();
}
GCHostageExpresserShim::GCHostageExpresserShim(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCHostageExpresserShim::GCHostageExpresserShim(void *ptr) {
    m_ptr = ptr;
}
GCAI_Expresser GCHostageExpresserShim::GetExpresser() const {
    GCAI_Expresser value(*GetSchemaValuePtr<void*>(m_ptr, "CHostageExpresserShim", "m_pExpresser"));
    return value;
}
void GCHostageExpresserShim::SetExpresser(GCAI_Expresser* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Expresser' is not possible.\n");
}
std::string GCHostageExpresserShim::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCHostageExpresserShim::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseCombatCharacter GCHostageExpresserShim::GetParent() const {
    GCBaseCombatCharacter value(m_ptr);
    return value;
}
void GCHostageExpresserShim::SetParent(GCBaseCombatCharacter value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCHostageExpresserShim(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCHostageExpresserShim>("CHostageExpresserShim")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Expresser", &GCHostageExpresserShim::GetExpresser, &GCHostageExpresserShim::SetExpresser)
        .addProperty("Parent", &GCHostageExpresserShim::GetParent, &GCHostageExpresserShim::SetParent)
        .addFunction("ToPtr", &GCHostageExpresserShim::ToPtr)
        .addFunction("IsValid", &GCHostageExpresserShim::IsValid)
        .endClass();
}
GCInferno::GCInferno(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCInferno::GCInferno(void *ptr) {
    m_ptr = ptr;
}
std::vector<Vector> GCInferno::GetFirePositions() const {
    Vector* outValue = GetSchemaValue<Vector*>(m_ptr, "CInferno", "m_firePositions"); std::vector<Vector> ret; for(int i = 0; i < 64; i++) { ret.push_back(outValue[i]); } return ret;
}
void GCInferno::SetFirePositions(std::vector<Vector> value) {
    Vector* outValue = GetSchemaValue<Vector*>(m_ptr, "CInferno", "m_firePositions"); for(int i = 0; i < 64; i++) { outValue[i] = value[i]; } SetSchemaValue(m_ptr, "CInferno", "m_firePositions", false, outValue);
}
std::vector<Vector> GCInferno::GetFireParentPositions() const {
    Vector* outValue = GetSchemaValue<Vector*>(m_ptr, "CInferno", "m_fireParentPositions"); std::vector<Vector> ret; for(int i = 0; i < 64; i++) { ret.push_back(outValue[i]); } return ret;
}
void GCInferno::SetFireParentPositions(std::vector<Vector> value) {
    Vector* outValue = GetSchemaValue<Vector*>(m_ptr, "CInferno", "m_fireParentPositions"); for(int i = 0; i < 64; i++) { outValue[i] = value[i]; } SetSchemaValue(m_ptr, "CInferno", "m_fireParentPositions", false, outValue);
}
std::vector<bool> GCInferno::GetFireIsBurning() const {
    bool* outValue = GetSchemaValue<bool*>(m_ptr, "CInferno", "m_bFireIsBurning"); std::vector<bool> ret; for(int i = 0; i < 64; i++) { ret.push_back(outValue[i]); } return ret;
}
void GCInferno::SetFireIsBurning(std::vector<bool> value) {
    bool* outValue = GetSchemaValue<bool*>(m_ptr, "CInferno", "m_bFireIsBurning"); for(int i = 0; i < 64; i++) { outValue[i] = value[i]; } SetSchemaValue(m_ptr, "CInferno", "m_bFireIsBurning", false, outValue);
}
std::vector<Vector> GCInferno::GetBurnNormal() const {
    Vector* outValue = GetSchemaValue<Vector*>(m_ptr, "CInferno", "m_BurnNormal"); std::vector<Vector> ret; for(int i = 0; i < 64; i++) { ret.push_back(outValue[i]); } return ret;
}
void GCInferno::SetBurnNormal(std::vector<Vector> value) {
    Vector* outValue = GetSchemaValue<Vector*>(m_ptr, "CInferno", "m_BurnNormal"); for(int i = 0; i < 64; i++) { outValue[i] = value[i]; } SetSchemaValue(m_ptr, "CInferno", "m_BurnNormal", false, outValue);
}
int32_t GCInferno::GetFireCount() const {
    return GetSchemaValue<int32_t>(m_ptr, "CInferno", "m_fireCount");
}
void GCInferno::SetFireCount(int32_t value) {
    SetSchemaValue(m_ptr, "CInferno", "m_fireCount", false, value);
}
int32_t GCInferno::GetInfernoType() const {
    return GetSchemaValue<int32_t>(m_ptr, "CInferno", "m_nInfernoType");
}
void GCInferno::SetInfernoType(int32_t value) {
    SetSchemaValue(m_ptr, "CInferno", "m_nInfernoType", false, value);
}
int32_t GCInferno::GetFireEffectTickBegin() const {
    return GetSchemaValue<int32_t>(m_ptr, "CInferno", "m_nFireEffectTickBegin");
}
void GCInferno::SetFireEffectTickBegin(int32_t value) {
    SetSchemaValue(m_ptr, "CInferno", "m_nFireEffectTickBegin", false, value);
}
float GCInferno::GetFireLifetime() const {
    return GetSchemaValue<float>(m_ptr, "CInferno", "m_nFireLifetime");
}
void GCInferno::SetFireLifetime(float value) {
    SetSchemaValue(m_ptr, "CInferno", "m_nFireLifetime", false, value);
}
bool GCInferno::GetInPostEffectTime() const {
    return GetSchemaValue<bool>(m_ptr, "CInferno", "m_bInPostEffectTime");
}
void GCInferno::SetInPostEffectTime(bool value) {
    SetSchemaValue(m_ptr, "CInferno", "m_bInPostEffectTime", false, value);
}
int32_t GCInferno::GetFiresExtinguishCount() const {
    return GetSchemaValue<int32_t>(m_ptr, "CInferno", "m_nFiresExtinguishCount");
}
void GCInferno::SetFiresExtinguishCount(int32_t value) {
    SetSchemaValue(m_ptr, "CInferno", "m_nFiresExtinguishCount", false, value);
}
bool GCInferno::GetWasCreatedInSmoke() const {
    return GetSchemaValue<bool>(m_ptr, "CInferno", "m_bWasCreatedInSmoke");
}
void GCInferno::SetWasCreatedInSmoke(bool value) {
    SetSchemaValue(m_ptr, "CInferno", "m_bWasCreatedInSmoke", false, value);
}
GExtent GCInferno::GetExtent() const {
    GExtent value(GetSchemaPtr(m_ptr, "CInferno", "m_extent"));
    return value;
}
void GCInferno::SetExtent(GExtent value) {
    SetSchemaValue(m_ptr, "CInferno", "m_extent", false, value);
}
GCountdownTimer GCInferno::GetDamageTimer() const {
    GCountdownTimer value(GetSchemaPtr(m_ptr, "CInferno", "m_damageTimer"));
    return value;
}
void GCInferno::SetDamageTimer(GCountdownTimer value) {
    SetSchemaValue(m_ptr, "CInferno", "m_damageTimer", false, value);
}
GCountdownTimer GCInferno::GetDamageRampTimer() const {
    GCountdownTimer value(GetSchemaPtr(m_ptr, "CInferno", "m_damageRampTimer"));
    return value;
}
void GCInferno::SetDamageRampTimer(GCountdownTimer value) {
    SetSchemaValue(m_ptr, "CInferno", "m_damageRampTimer", false, value);
}
Vector GCInferno::GetSplashVelocity() const {
    return GetSchemaValue<Vector>(m_ptr, "CInferno", "m_splashVelocity");
}
void GCInferno::SetSplashVelocity(Vector value) {
    SetSchemaValue(m_ptr, "CInferno", "m_splashVelocity", false, value);
}
Vector GCInferno::GetInitialSplashVelocity() const {
    return GetSchemaValue<Vector>(m_ptr, "CInferno", "m_InitialSplashVelocity");
}
void GCInferno::SetInitialSplashVelocity(Vector value) {
    SetSchemaValue(m_ptr, "CInferno", "m_InitialSplashVelocity", false, value);
}
Vector GCInferno::GetStartPos() const {
    return GetSchemaValue<Vector>(m_ptr, "CInferno", "m_startPos");
}
void GCInferno::SetStartPos(Vector value) {
    SetSchemaValue(m_ptr, "CInferno", "m_startPos", false, value);
}
Vector GCInferno::GetOriginalSpawnLocation() const {
    return GetSchemaValue<Vector>(m_ptr, "CInferno", "m_vecOriginalSpawnLocation");
}
void GCInferno::SetOriginalSpawnLocation(Vector value) {
    SetSchemaValue(m_ptr, "CInferno", "m_vecOriginalSpawnLocation", false, value);
}
GIntervalTimer GCInferno::GetActiveTimer() const {
    GIntervalTimer value(GetSchemaPtr(m_ptr, "CInferno", "m_activeTimer"));
    return value;
}
void GCInferno::SetActiveTimer(GIntervalTimer value) {
    SetSchemaValue(m_ptr, "CInferno", "m_activeTimer", false, value);
}
int32_t GCInferno::GetFireSpawnOffset() const {
    return GetSchemaValue<int32_t>(m_ptr, "CInferno", "m_fireSpawnOffset");
}
void GCInferno::SetFireSpawnOffset(int32_t value) {
    SetSchemaValue(m_ptr, "CInferno", "m_fireSpawnOffset", false, value);
}
int32_t GCInferno::GetMaxFlames() const {
    return GetSchemaValue<int32_t>(m_ptr, "CInferno", "m_nMaxFlames");
}
void GCInferno::SetMaxFlames(int32_t value) {
    SetSchemaValue(m_ptr, "CInferno", "m_nMaxFlames", false, value);
}
int32_t GCInferno::GetSpreadCount() const {
    return GetSchemaValue<int32_t>(m_ptr, "CInferno", "m_nSpreadCount");
}
void GCInferno::SetSpreadCount(int32_t value) {
    SetSchemaValue(m_ptr, "CInferno", "m_nSpreadCount", false, value);
}
GCountdownTimer GCInferno::GetBookkeepingTimer() const {
    GCountdownTimer value(GetSchemaPtr(m_ptr, "CInferno", "m_BookkeepingTimer"));
    return value;
}
void GCInferno::SetBookkeepingTimer(GCountdownTimer value) {
    SetSchemaValue(m_ptr, "CInferno", "m_BookkeepingTimer", false, value);
}
GCountdownTimer GCInferno::GetNextSpreadTimer() const {
    GCountdownTimer value(GetSchemaPtr(m_ptr, "CInferno", "m_NextSpreadTimer"));
    return value;
}
void GCInferno::SetNextSpreadTimer(GCountdownTimer value) {
    SetSchemaValue(m_ptr, "CInferno", "m_NextSpreadTimer", false, value);
}
uint16_t GCInferno::GetSourceItemDefIndex() const {
    return GetSchemaValue<uint16_t>(m_ptr, "CInferno", "m_nSourceItemDefIndex");
}
void GCInferno::SetSourceItemDefIndex(uint16_t value) {
    SetSchemaValue(m_ptr, "CInferno", "m_nSourceItemDefIndex", false, value);
}
std::string GCInferno::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCInferno::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseModelEntity GCInferno::GetParent() const {
    GCBaseModelEntity value(m_ptr);
    return value;
}
void GCInferno::SetParent(GCBaseModelEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCInferno(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCInferno>("CInferno")
        .addConstructor<void (*)(std::string)>()
        .addProperty("FirePositions", &GCInferno::GetFirePositions, &GCInferno::SetFirePositions)
        .addProperty("FireParentPositions", &GCInferno::GetFireParentPositions, &GCInferno::SetFireParentPositions)
        .addProperty("FireIsBurning", &GCInferno::GetFireIsBurning, &GCInferno::SetFireIsBurning)
        .addProperty("BurnNormal", &GCInferno::GetBurnNormal, &GCInferno::SetBurnNormal)
        .addProperty("FireCount", &GCInferno::GetFireCount, &GCInferno::SetFireCount)
        .addProperty("InfernoType", &GCInferno::GetInfernoType, &GCInferno::SetInfernoType)
        .addProperty("FireEffectTickBegin", &GCInferno::GetFireEffectTickBegin, &GCInferno::SetFireEffectTickBegin)
        .addProperty("FireLifetime", &GCInferno::GetFireLifetime, &GCInferno::SetFireLifetime)
        .addProperty("InPostEffectTime", &GCInferno::GetInPostEffectTime, &GCInferno::SetInPostEffectTime)
        .addProperty("FiresExtinguishCount", &GCInferno::GetFiresExtinguishCount, &GCInferno::SetFiresExtinguishCount)
        .addProperty("WasCreatedInSmoke", &GCInferno::GetWasCreatedInSmoke, &GCInferno::SetWasCreatedInSmoke)
        .addProperty("Extent", &GCInferno::GetExtent, &GCInferno::SetExtent)
        .addProperty("DamageTimer", &GCInferno::GetDamageTimer, &GCInferno::SetDamageTimer)
        .addProperty("DamageRampTimer", &GCInferno::GetDamageRampTimer, &GCInferno::SetDamageRampTimer)
        .addProperty("SplashVelocity", &GCInferno::GetSplashVelocity, &GCInferno::SetSplashVelocity)
        .addProperty("InitialSplashVelocity", &GCInferno::GetInitialSplashVelocity, &GCInferno::SetInitialSplashVelocity)
        .addProperty("StartPos", &GCInferno::GetStartPos, &GCInferno::SetStartPos)
        .addProperty("OriginalSpawnLocation", &GCInferno::GetOriginalSpawnLocation, &GCInferno::SetOriginalSpawnLocation)
        .addProperty("ActiveTimer", &GCInferno::GetActiveTimer, &GCInferno::SetActiveTimer)
        .addProperty("FireSpawnOffset", &GCInferno::GetFireSpawnOffset, &GCInferno::SetFireSpawnOffset)
        .addProperty("MaxFlames", &GCInferno::GetMaxFlames, &GCInferno::SetMaxFlames)
        .addProperty("SpreadCount", &GCInferno::GetSpreadCount, &GCInferno::SetSpreadCount)
        .addProperty("BookkeepingTimer", &GCInferno::GetBookkeepingTimer, &GCInferno::SetBookkeepingTimer)
        .addProperty("NextSpreadTimer", &GCInferno::GetNextSpreadTimer, &GCInferno::SetNextSpreadTimer)
        .addProperty("SourceItemDefIndex", &GCInferno::GetSourceItemDefIndex, &GCInferno::SetSourceItemDefIndex)
        .addProperty("Parent", &GCInferno::GetParent, &GCInferno::SetParent)
        .addFunction("ToPtr", &GCInferno::ToPtr)
        .addFunction("IsValid", &GCInferno::IsValid)
        .endClass();
}
GCEnvGlobal::GCEnvGlobal(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCEnvGlobal::GCEnvGlobal(void *ptr) {
    m_ptr = ptr;
}
std::string GCEnvGlobal::GetGlobalstate() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CEnvGlobal", "m_globalstate").String();
}
void GCEnvGlobal::SetGlobalstate(std::string value) {
    SetSchemaValue(m_ptr, "CEnvGlobal", "m_globalstate", false, CUtlSymbolLarge(value.c_str()));
}
int32_t GCEnvGlobal::GetTriggermode() const {
    return GetSchemaValue<int32_t>(m_ptr, "CEnvGlobal", "m_triggermode");
}
void GCEnvGlobal::SetTriggermode(int32_t value) {
    SetSchemaValue(m_ptr, "CEnvGlobal", "m_triggermode", false, value);
}
int32_t GCEnvGlobal::GetInitialstate() const {
    return GetSchemaValue<int32_t>(m_ptr, "CEnvGlobal", "m_initialstate");
}
void GCEnvGlobal::SetInitialstate(int32_t value) {
    SetSchemaValue(m_ptr, "CEnvGlobal", "m_initialstate", false, value);
}
int32_t GCEnvGlobal::GetCounter() const {
    return GetSchemaValue<int32_t>(m_ptr, "CEnvGlobal", "m_counter");
}
void GCEnvGlobal::SetCounter(int32_t value) {
    SetSchemaValue(m_ptr, "CEnvGlobal", "m_counter", false, value);
}
std::string GCEnvGlobal::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCEnvGlobal::IsValid() {
    return (m_ptr != nullptr);
}
GCLogicalEntity GCEnvGlobal::GetParent() const {
    GCLogicalEntity value(m_ptr);
    return value;
}
void GCEnvGlobal::SetParent(GCLogicalEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCEnvGlobal(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCEnvGlobal>("CEnvGlobal")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Globalstate", &GCEnvGlobal::GetGlobalstate, &GCEnvGlobal::SetGlobalstate)
        .addProperty("Triggermode", &GCEnvGlobal::GetTriggermode, &GCEnvGlobal::SetTriggermode)
        .addProperty("Initialstate", &GCEnvGlobal::GetInitialstate, &GCEnvGlobal::SetInitialstate)
        .addProperty("Counter", &GCEnvGlobal::GetCounter, &GCEnvGlobal::SetCounter)
        .addProperty("Parent", &GCEnvGlobal::GetParent, &GCEnvGlobal::SetParent)
        .addFunction("ToPtr", &GCEnvGlobal::ToPtr)
        .addFunction("IsValid", &GCEnvGlobal::IsValid)
        .endClass();
}
GCFilterName::GCFilterName(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCFilterName::GCFilterName(void *ptr) {
    m_ptr = ptr;
}
std::string GCFilterName::GetFilterName() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CFilterName", "m_iFilterName").String();
}
void GCFilterName::SetFilterName(std::string value) {
    SetSchemaValue(m_ptr, "CFilterName", "m_iFilterName", false, CUtlSymbolLarge(value.c_str()));
}
std::string GCFilterName::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCFilterName::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseFilter GCFilterName::GetParent() const {
    GCBaseFilter value(m_ptr);
    return value;
}
void GCFilterName::SetParent(GCBaseFilter value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCFilterName(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCFilterName>("CFilterName")
        .addConstructor<void (*)(std::string)>()
        .addProperty("FilterName", &GCFilterName::GetFilterName, &GCFilterName::SetFilterName)
        .addProperty("Parent", &GCFilterName::GetParent, &GCFilterName::SetParent)
        .addFunction("ToPtr", &GCFilterName::ToPtr)
        .addFunction("IsValid", &GCFilterName::IsValid)
        .endClass();
}
GCCSTeam::GCCSTeam(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCCSTeam::GCCSTeam(void *ptr) {
    m_ptr = ptr;
}
int32_t GCCSTeam::GetLastRecievedShorthandedRoundBonus() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSTeam", "m_nLastRecievedShorthandedRoundBonus");
}
void GCCSTeam::SetLastRecievedShorthandedRoundBonus(int32_t value) {
    SetSchemaValue(m_ptr, "CCSTeam", "m_nLastRecievedShorthandedRoundBonus", false, value);
}
int32_t GCCSTeam::GetShorthandedRoundBonusStartRound() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSTeam", "m_nShorthandedRoundBonusStartRound");
}
void GCCSTeam::SetShorthandedRoundBonusStartRound(int32_t value) {
    SetSchemaValue(m_ptr, "CCSTeam", "m_nShorthandedRoundBonusStartRound", false, value);
}
bool GCCSTeam::GetSurrendered() const {
    return GetSchemaValue<bool>(m_ptr, "CCSTeam", "m_bSurrendered");
}
void GCCSTeam::SetSurrendered(bool value) {
    SetSchemaValue(m_ptr, "CCSTeam", "m_bSurrendered", false, value);
}
std::string GCCSTeam::GetTeamMatchStat() const {
    return GetSchemaValuePtr<char>(m_ptr, "CCSTeam", "m_szTeamMatchStat");
}
void GCCSTeam::SetTeamMatchStat(std::string value) {
    WriteSchemaPtrValue(m_ptr, "CCSTeam", "m_szTeamMatchStat", false, reinterpret_cast<byte*>(const_cast<char*>(value.c_str())), 512);
}
int32_t GCCSTeam::GetNumMapVictories() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSTeam", "m_numMapVictories");
}
void GCCSTeam::SetNumMapVictories(int32_t value) {
    SetSchemaValue(m_ptr, "CCSTeam", "m_numMapVictories", false, value);
}
int32_t GCCSTeam::GetScoreFirstHalf() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSTeam", "m_scoreFirstHalf");
}
void GCCSTeam::SetScoreFirstHalf(int32_t value) {
    SetSchemaValue(m_ptr, "CCSTeam", "m_scoreFirstHalf", false, value);
}
int32_t GCCSTeam::GetScoreSecondHalf() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSTeam", "m_scoreSecondHalf");
}
void GCCSTeam::SetScoreSecondHalf(int32_t value) {
    SetSchemaValue(m_ptr, "CCSTeam", "m_scoreSecondHalf", false, value);
}
int32_t GCCSTeam::GetScoreOvertime() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSTeam", "m_scoreOvertime");
}
void GCCSTeam::SetScoreOvertime(int32_t value) {
    SetSchemaValue(m_ptr, "CCSTeam", "m_scoreOvertime", false, value);
}
std::string GCCSTeam::GetClanTeamname() const {
    return GetSchemaValuePtr<char>(m_ptr, "CCSTeam", "m_szClanTeamname");
}
void GCCSTeam::SetClanTeamname(std::string value) {
    WriteSchemaPtrValue(m_ptr, "CCSTeam", "m_szClanTeamname", false, reinterpret_cast<byte*>(const_cast<char*>(value.c_str())), 129);
}
uint32_t GCCSTeam::GetClanID() const {
    return GetSchemaValue<uint32_t>(m_ptr, "CCSTeam", "m_iClanID");
}
void GCCSTeam::SetClanID(uint32_t value) {
    SetSchemaValue(m_ptr, "CCSTeam", "m_iClanID", false, value);
}
std::string GCCSTeam::GetTeamFlagImage() const {
    return GetSchemaValuePtr<char>(m_ptr, "CCSTeam", "m_szTeamFlagImage");
}
void GCCSTeam::SetTeamFlagImage(std::string value) {
    WriteSchemaPtrValue(m_ptr, "CCSTeam", "m_szTeamFlagImage", false, reinterpret_cast<byte*>(const_cast<char*>(value.c_str())), 8);
}
std::string GCCSTeam::GetTeamLogoImage() const {
    return GetSchemaValuePtr<char>(m_ptr, "CCSTeam", "m_szTeamLogoImage");
}
void GCCSTeam::SetTeamLogoImage(std::string value) {
    WriteSchemaPtrValue(m_ptr, "CCSTeam", "m_szTeamLogoImage", false, reinterpret_cast<byte*>(const_cast<char*>(value.c_str())), 8);
}
float GCCSTeam::GetNextResourceTime() const {
    return GetSchemaValue<float>(m_ptr, "CCSTeam", "m_flNextResourceTime");
}
void GCCSTeam::SetNextResourceTime(float value) {
    SetSchemaValue(m_ptr, "CCSTeam", "m_flNextResourceTime", false, value);
}
int32_t GCCSTeam::GetLastUpdateSentAt() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSTeam", "m_iLastUpdateSentAt");
}
void GCCSTeam::SetLastUpdateSentAt(int32_t value) {
    SetSchemaValue(m_ptr, "CCSTeam", "m_iLastUpdateSentAt", false, value);
}
std::string GCCSTeam::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCCSTeam::IsValid() {
    return (m_ptr != nullptr);
}
GCTeam GCCSTeam::GetParent() const {
    GCTeam value(m_ptr);
    return value;
}
void GCCSTeam::SetParent(GCTeam value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCCSTeam(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCCSTeam>("CCSTeam")
        .addConstructor<void (*)(std::string)>()
        .addProperty("LastRecievedShorthandedRoundBonus", &GCCSTeam::GetLastRecievedShorthandedRoundBonus, &GCCSTeam::SetLastRecievedShorthandedRoundBonus)
        .addProperty("ShorthandedRoundBonusStartRound", &GCCSTeam::GetShorthandedRoundBonusStartRound, &GCCSTeam::SetShorthandedRoundBonusStartRound)
        .addProperty("Surrendered", &GCCSTeam::GetSurrendered, &GCCSTeam::SetSurrendered)
        .addProperty("TeamMatchStat", &GCCSTeam::GetTeamMatchStat, &GCCSTeam::SetTeamMatchStat)
        .addProperty("NumMapVictories", &GCCSTeam::GetNumMapVictories, &GCCSTeam::SetNumMapVictories)
        .addProperty("ScoreFirstHalf", &GCCSTeam::GetScoreFirstHalf, &GCCSTeam::SetScoreFirstHalf)
        .addProperty("ScoreSecondHalf", &GCCSTeam::GetScoreSecondHalf, &GCCSTeam::SetScoreSecondHalf)
        .addProperty("ScoreOvertime", &GCCSTeam::GetScoreOvertime, &GCCSTeam::SetScoreOvertime)
        .addProperty("ClanTeamname", &GCCSTeam::GetClanTeamname, &GCCSTeam::SetClanTeamname)
        .addProperty("ClanID", &GCCSTeam::GetClanID, &GCCSTeam::SetClanID)
        .addProperty("TeamFlagImage", &GCCSTeam::GetTeamFlagImage, &GCCSTeam::SetTeamFlagImage)
        .addProperty("TeamLogoImage", &GCCSTeam::GetTeamLogoImage, &GCCSTeam::SetTeamLogoImage)
        .addProperty("NextResourceTime", &GCCSTeam::GetNextResourceTime, &GCCSTeam::SetNextResourceTime)
        .addProperty("LastUpdateSentAt", &GCCSTeam::GetLastUpdateSentAt, &GCCSTeam::SetLastUpdateSentAt)
        .addProperty("Parent", &GCCSTeam::GetParent, &GCCSTeam::SetParent)
        .addFunction("ToPtr", &GCCSTeam::ToPtr)
        .addFunction("IsValid", &GCCSTeam::IsValid)
        .endClass();
}
GCWeaponUSPSilencer::GCWeaponUSPSilencer(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCWeaponUSPSilencer::GCWeaponUSPSilencer(void *ptr) {
    m_ptr = ptr;
}
std::string GCWeaponUSPSilencer::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCWeaponUSPSilencer::IsValid() {
    return (m_ptr != nullptr);
}
GCCSWeaponBaseGun GCWeaponUSPSilencer::GetParent() const {
    GCCSWeaponBaseGun value(m_ptr);
    return value;
}
void GCWeaponUSPSilencer::SetParent(GCCSWeaponBaseGun value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCWeaponUSPSilencer(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCWeaponUSPSilencer>("CWeaponUSPSilencer")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCWeaponUSPSilencer::GetParent, &GCWeaponUSPSilencer::SetParent)
        .addFunction("ToPtr", &GCWeaponUSPSilencer::ToPtr)
        .addFunction("IsValid", &GCWeaponUSPSilencer::IsValid)
        .endClass();
}
GCSpriteOriented::GCSpriteOriented(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCSpriteOriented::GCSpriteOriented(void *ptr) {
    m_ptr = ptr;
}
std::string GCSpriteOriented::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCSpriteOriented::IsValid() {
    return (m_ptr != nullptr);
}
GCSprite GCSpriteOriented::GetParent() const {
    GCSprite value(m_ptr);
    return value;
}
void GCSpriteOriented::SetParent(GCSprite value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCSpriteOriented(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCSpriteOriented>("CSpriteOriented")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCSpriteOriented::GetParent, &GCSpriteOriented::SetParent)
        .addFunction("ToPtr", &GCSpriteOriented::ToPtr)
        .addFunction("IsValid", &GCSpriteOriented::IsValid)
        .endClass();
}
GCTriggerGravity::GCTriggerGravity(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCTriggerGravity::GCTriggerGravity(void *ptr) {
    m_ptr = ptr;
}
std::string GCTriggerGravity::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCTriggerGravity::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseTrigger GCTriggerGravity::GetParent() const {
    GCBaseTrigger value(m_ptr);
    return value;
}
void GCTriggerGravity::SetParent(GCBaseTrigger value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCTriggerGravity(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCTriggerGravity>("CTriggerGravity")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCTriggerGravity::GetParent, &GCTriggerGravity::SetParent)
        .addFunction("ToPtr", &GCTriggerGravity::ToPtr)
        .addFunction("IsValid", &GCTriggerGravity::IsValid)
        .endClass();
}
GCServerRagdollTrigger::GCServerRagdollTrigger(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCServerRagdollTrigger::GCServerRagdollTrigger(void *ptr) {
    m_ptr = ptr;
}
std::string GCServerRagdollTrigger::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCServerRagdollTrigger::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseTrigger GCServerRagdollTrigger::GetParent() const {
    GCBaseTrigger value(m_ptr);
    return value;
}
void GCServerRagdollTrigger::SetParent(GCBaseTrigger value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCServerRagdollTrigger(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCServerRagdollTrigger>("CServerRagdollTrigger")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCServerRagdollTrigger::GetParent, &GCServerRagdollTrigger::SetParent)
        .addFunction("ToPtr", &GCServerRagdollTrigger::ToPtr)
        .addFunction("IsValid", &GCServerRagdollTrigger::IsValid)
        .endClass();
}
GCInfoDynamicShadowHintBox::GCInfoDynamicShadowHintBox(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCInfoDynamicShadowHintBox::GCInfoDynamicShadowHintBox(void *ptr) {
    m_ptr = ptr;
}
Vector GCInfoDynamicShadowHintBox::GetBoxMins() const {
    return GetSchemaValue<Vector>(m_ptr, "CInfoDynamicShadowHintBox", "m_vBoxMins");
}
void GCInfoDynamicShadowHintBox::SetBoxMins(Vector value) {
    SetSchemaValue(m_ptr, "CInfoDynamicShadowHintBox", "m_vBoxMins", false, value);
}
Vector GCInfoDynamicShadowHintBox::GetBoxMaxs() const {
    return GetSchemaValue<Vector>(m_ptr, "CInfoDynamicShadowHintBox", "m_vBoxMaxs");
}
void GCInfoDynamicShadowHintBox::SetBoxMaxs(Vector value) {
    SetSchemaValue(m_ptr, "CInfoDynamicShadowHintBox", "m_vBoxMaxs", false, value);
}
std::string GCInfoDynamicShadowHintBox::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCInfoDynamicShadowHintBox::IsValid() {
    return (m_ptr != nullptr);
}
GCInfoDynamicShadowHint GCInfoDynamicShadowHintBox::GetParent() const {
    GCInfoDynamicShadowHint value(m_ptr);
    return value;
}
void GCInfoDynamicShadowHintBox::SetParent(GCInfoDynamicShadowHint value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCInfoDynamicShadowHintBox(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCInfoDynamicShadowHintBox>("CInfoDynamicShadowHintBox")
        .addConstructor<void (*)(std::string)>()
        .addProperty("BoxMins", &GCInfoDynamicShadowHintBox::GetBoxMins, &GCInfoDynamicShadowHintBox::SetBoxMins)
        .addProperty("BoxMaxs", &GCInfoDynamicShadowHintBox::GetBoxMaxs, &GCInfoDynamicShadowHintBox::SetBoxMaxs)
        .addProperty("Parent", &GCInfoDynamicShadowHintBox::GetParent, &GCInfoDynamicShadowHintBox::SetParent)
        .addFunction("ToPtr", &GCInfoDynamicShadowHintBox::ToPtr)
        .addFunction("IsValid", &GCInfoDynamicShadowHintBox::IsValid)
        .endClass();
}
GCPathMover::GCPathMover(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCPathMover::GCPathMover(void *ptr) {
    m_ptr = ptr;
}
float GCPathMover::GetPathLength() const {
    return GetSchemaValue<float>(m_ptr, "CPathMover", "m_flPathLength");
}
void GCPathMover::SetPathLength(float value) {
    SetSchemaValue(m_ptr, "CPathMover", "m_flPathLength", false, value);
}
bool GCPathMover::GetClosedLoop() const {
    return GetSchemaValue<bool>(m_ptr, "CPathMover", "m_bClosedLoop");
}
void GCPathMover::SetClosedLoop(bool value) {
    SetSchemaValue(m_ptr, "CPathMover", "m_bClosedLoop", false, value);
}
std::string GCPathMover::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCPathMover::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseEntity GCPathMover::GetParent() const {
    GCBaseEntity value(m_ptr);
    return value;
}
void GCPathMover::SetParent(GCBaseEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCPathMover(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCPathMover>("CPathMover")
        .addConstructor<void (*)(std::string)>()
        .addProperty("PathLength", &GCPathMover::GetPathLength, &GCPathMover::SetPathLength)
        .addProperty("ClosedLoop", &GCPathMover::GetClosedLoop, &GCPathMover::SetClosedLoop)
        .addProperty("Parent", &GCPathMover::GetParent, &GCPathMover::SetParent)
        .addFunction("ToPtr", &GCPathMover::ToPtr)
        .addFunction("IsValid", &GCPathMover::IsValid)
        .endClass();
}
GCFlashbang::GCFlashbang(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCFlashbang::GCFlashbang(void *ptr) {
    m_ptr = ptr;
}
std::string GCFlashbang::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCFlashbang::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseCSGrenade GCFlashbang::GetParent() const {
    GCBaseCSGrenade value(m_ptr);
    return value;
}
void GCFlashbang::SetParent(GCBaseCSGrenade value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCFlashbang(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCFlashbang>("CFlashbang")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCFlashbang::GetParent, &GCFlashbang::SetParent)
        .addFunction("ToPtr", &GCFlashbang::ToPtr)
        .addFunction("IsValid", &GCFlashbang::IsValid)
        .endClass();
}
GCWeaponAug::GCWeaponAug(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCWeaponAug::GCWeaponAug(void *ptr) {
    m_ptr = ptr;
}
std::string GCWeaponAug::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCWeaponAug::IsValid() {
    return (m_ptr != nullptr);
}
GCCSWeaponBaseGun GCWeaponAug::GetParent() const {
    GCCSWeaponBaseGun value(m_ptr);
    return value;
}
void GCWeaponAug::SetParent(GCCSWeaponBaseGun value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCWeaponAug(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCWeaponAug>("CWeaponAug")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCWeaponAug::GetParent, &GCWeaponAug::SetParent)
        .addFunction("ToPtr", &GCWeaponAug::ToPtr)
        .addFunction("IsValid", &GCWeaponAug::IsValid)
        .endClass();
}
GCIncendiaryGrenade::GCIncendiaryGrenade(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCIncendiaryGrenade::GCIncendiaryGrenade(void *ptr) {
    m_ptr = ptr;
}
std::string GCIncendiaryGrenade::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCIncendiaryGrenade::IsValid() {
    return (m_ptr != nullptr);
}
GCMolotovGrenade GCIncendiaryGrenade::GetParent() const {
    GCMolotovGrenade value(m_ptr);
    return value;
}
void GCIncendiaryGrenade::SetParent(GCMolotovGrenade value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCIncendiaryGrenade(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCIncendiaryGrenade>("CIncendiaryGrenade")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCIncendiaryGrenade::GetParent, &GCIncendiaryGrenade::SetParent)
        .addFunction("ToPtr", &GCIncendiaryGrenade::ToPtr)
        .addFunction("IsValid", &GCIncendiaryGrenade::IsValid)
        .endClass();
}
GCChangeLevel::GCChangeLevel(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCChangeLevel::GCChangeLevel(void *ptr) {
    m_ptr = ptr;
}
std::string GCChangeLevel::GetMapName() const {
    return GetSchemaValue<CUtlString>(m_ptr, "CChangeLevel", "m_sMapName").Get();
}
void GCChangeLevel::SetMapName(std::string value) {
    SetSchemaValue(m_ptr, "CChangeLevel", "m_sMapName", false, CUtlString(value.c_str()));
}
std::string GCChangeLevel::GetLandmarkName() const {
    return GetSchemaValue<CUtlString>(m_ptr, "CChangeLevel", "m_sLandmarkName").Get();
}
void GCChangeLevel::SetLandmarkName(std::string value) {
    SetSchemaValue(m_ptr, "CChangeLevel", "m_sLandmarkName", false, CUtlString(value.c_str()));
}
GCEntityIOOutput GCChangeLevel::GetOnChangeLevel() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CChangeLevel", "m_OnChangeLevel"));
    return value;
}
void GCChangeLevel::SetOnChangeLevel(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CChangeLevel", "m_OnChangeLevel", false, value);
}
bool GCChangeLevel::GetTouched() const {
    return GetSchemaValue<bool>(m_ptr, "CChangeLevel", "m_bTouched");
}
void GCChangeLevel::SetTouched(bool value) {
    SetSchemaValue(m_ptr, "CChangeLevel", "m_bTouched", false, value);
}
bool GCChangeLevel::GetNoTouch() const {
    return GetSchemaValue<bool>(m_ptr, "CChangeLevel", "m_bNoTouch");
}
void GCChangeLevel::SetNoTouch(bool value) {
    SetSchemaValue(m_ptr, "CChangeLevel", "m_bNoTouch", false, value);
}
bool GCChangeLevel::GetNewChapter() const {
    return GetSchemaValue<bool>(m_ptr, "CChangeLevel", "m_bNewChapter");
}
void GCChangeLevel::SetNewChapter(bool value) {
    SetSchemaValue(m_ptr, "CChangeLevel", "m_bNewChapter", false, value);
}
bool GCChangeLevel::GetOnChangeLevelFired() const {
    return GetSchemaValue<bool>(m_ptr, "CChangeLevel", "m_bOnChangeLevelFired");
}
void GCChangeLevel::SetOnChangeLevelFired(bool value) {
    SetSchemaValue(m_ptr, "CChangeLevel", "m_bOnChangeLevelFired", false, value);
}
std::string GCChangeLevel::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCChangeLevel::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseTrigger GCChangeLevel::GetParent() const {
    GCBaseTrigger value(m_ptr);
    return value;
}
void GCChangeLevel::SetParent(GCBaseTrigger value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCChangeLevel(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCChangeLevel>("CChangeLevel")
        .addConstructor<void (*)(std::string)>()
        .addProperty("MapName", &GCChangeLevel::GetMapName, &GCChangeLevel::SetMapName)
        .addProperty("LandmarkName", &GCChangeLevel::GetLandmarkName, &GCChangeLevel::SetLandmarkName)
        .addProperty("OnChangeLevel", &GCChangeLevel::GetOnChangeLevel, &GCChangeLevel::SetOnChangeLevel)
        .addProperty("Touched", &GCChangeLevel::GetTouched, &GCChangeLevel::SetTouched)
        .addProperty("NoTouch", &GCChangeLevel::GetNoTouch, &GCChangeLevel::SetNoTouch)
        .addProperty("NewChapter", &GCChangeLevel::GetNewChapter, &GCChangeLevel::SetNewChapter)
        .addProperty("OnChangeLevelFired", &GCChangeLevel::GetOnChangeLevelFired, &GCChangeLevel::SetOnChangeLevelFired)
        .addProperty("Parent", &GCChangeLevel::GetParent, &GCChangeLevel::SetParent)
        .addFunction("ToPtr", &GCChangeLevel::ToPtr)
        .addFunction("IsValid", &GCChangeLevel::IsValid)
        .endClass();
}
GCTriggerLerpObject::GCTriggerLerpObject(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCTriggerLerpObject::GCTriggerLerpObject(void *ptr) {
    m_ptr = ptr;
}
std::string GCTriggerLerpObject::GetLerpTarget() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CTriggerLerpObject", "m_iszLerpTarget").String();
}
void GCTriggerLerpObject::SetLerpTarget(std::string value) {
    SetSchemaValue(m_ptr, "CTriggerLerpObject", "m_iszLerpTarget", false, CUtlSymbolLarge(value.c_str()));
}
GCBaseEntity GCTriggerLerpObject::GetLerpTarget1() const {
    GCBaseEntity value(*GetSchemaValuePtr<void*>(m_ptr, "CTriggerLerpObject", "m_hLerpTarget"));
    return value;
}
void GCTriggerLerpObject::SetLerpTarget1(GCBaseEntity* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'LerpTarget1' is not possible.\n");
}
std::string GCTriggerLerpObject::GetLerpTargetAttachment() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CTriggerLerpObject", "m_iszLerpTargetAttachment").String();
}
void GCTriggerLerpObject::SetLerpTargetAttachment(std::string value) {
    SetSchemaValue(m_ptr, "CTriggerLerpObject", "m_iszLerpTargetAttachment", false, CUtlSymbolLarge(value.c_str()));
}
float GCTriggerLerpObject::GetLerpDuration() const {
    return GetSchemaValue<float>(m_ptr, "CTriggerLerpObject", "m_flLerpDuration");
}
void GCTriggerLerpObject::SetLerpDuration(float value) {
    SetSchemaValue(m_ptr, "CTriggerLerpObject", "m_flLerpDuration", false, value);
}
bool GCTriggerLerpObject::GetLerpRestoreMoveType() const {
    return GetSchemaValue<bool>(m_ptr, "CTriggerLerpObject", "m_bLerpRestoreMoveType");
}
void GCTriggerLerpObject::SetLerpRestoreMoveType(bool value) {
    SetSchemaValue(m_ptr, "CTriggerLerpObject", "m_bLerpRestoreMoveType", false, value);
}
bool GCTriggerLerpObject::GetSingleLerpObject() const {
    return GetSchemaValue<bool>(m_ptr, "CTriggerLerpObject", "m_bSingleLerpObject");
}
void GCTriggerLerpObject::SetSingleLerpObject(bool value) {
    SetSchemaValue(m_ptr, "CTriggerLerpObject", "m_bSingleLerpObject", false, value);
}
std::vector<Glerpdata_t> GCTriggerLerpObject::GetLerpingObjects() const {
    CUtlVector<Glerpdata_t>* vec = GetSchemaValue<CUtlVector<Glerpdata_t>*>(m_ptr, "CTriggerLerpObject", "m_vecLerpingObjects"); std::vector<Glerpdata_t> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCTriggerLerpObject::SetLerpingObjects(std::vector<Glerpdata_t> value) {
    SetSchemaValueCUtlVector<Glerpdata_t>(m_ptr, "CTriggerLerpObject", "m_vecLerpingObjects", false, value);
}
std::string GCTriggerLerpObject::GetLerpEffect() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CTriggerLerpObject", "m_iszLerpEffect").String();
}
void GCTriggerLerpObject::SetLerpEffect(std::string value) {
    SetSchemaValue(m_ptr, "CTriggerLerpObject", "m_iszLerpEffect", false, CUtlSymbolLarge(value.c_str()));
}
std::string GCTriggerLerpObject::GetLerpSound() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CTriggerLerpObject", "m_iszLerpSound").String();
}
void GCTriggerLerpObject::SetLerpSound(std::string value) {
    SetSchemaValue(m_ptr, "CTriggerLerpObject", "m_iszLerpSound", false, CUtlSymbolLarge(value.c_str()));
}
bool GCTriggerLerpObject::GetAttachTouchingObject() const {
    return GetSchemaValue<bool>(m_ptr, "CTriggerLerpObject", "m_bAttachTouchingObject");
}
void GCTriggerLerpObject::SetAttachTouchingObject(bool value) {
    SetSchemaValue(m_ptr, "CTriggerLerpObject", "m_bAttachTouchingObject", false, value);
}
GCBaseEntity GCTriggerLerpObject::GetEntityToWaitForDisconnect() const {
    GCBaseEntity value(*GetSchemaValuePtr<void*>(m_ptr, "CTriggerLerpObject", "m_hEntityToWaitForDisconnect"));
    return value;
}
void GCTriggerLerpObject::SetEntityToWaitForDisconnect(GCBaseEntity* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'EntityToWaitForDisconnect' is not possible.\n");
}
GCEntityIOOutput GCTriggerLerpObject::GetOnLerpStarted() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CTriggerLerpObject", "m_OnLerpStarted"));
    return value;
}
void GCTriggerLerpObject::SetOnLerpStarted(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CTriggerLerpObject", "m_OnLerpStarted", false, value);
}
GCEntityIOOutput GCTriggerLerpObject::GetOnLerpFinished() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CTriggerLerpObject", "m_OnLerpFinished"));
    return value;
}
void GCTriggerLerpObject::SetOnLerpFinished(GCEntityIOOutput value) {
    SetSchemaValue(m_ptr, "CTriggerLerpObject", "m_OnLerpFinished", false, value);
}
std::string GCTriggerLerpObject::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCTriggerLerpObject::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseTrigger GCTriggerLerpObject::GetParent() const {
    GCBaseTrigger value(m_ptr);
    return value;
}
void GCTriggerLerpObject::SetParent(GCBaseTrigger value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCTriggerLerpObject(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCTriggerLerpObject>("CTriggerLerpObject")
        .addConstructor<void (*)(std::string)>()
        .addProperty("LerpTarget", &GCTriggerLerpObject::GetLerpTarget, &GCTriggerLerpObject::SetLerpTarget)
        .addProperty("LerpTarget1", &GCTriggerLerpObject::GetLerpTarget1, &GCTriggerLerpObject::SetLerpTarget1)
        .addProperty("LerpTargetAttachment", &GCTriggerLerpObject::GetLerpTargetAttachment, &GCTriggerLerpObject::SetLerpTargetAttachment)
        .addProperty("LerpDuration", &GCTriggerLerpObject::GetLerpDuration, &GCTriggerLerpObject::SetLerpDuration)
        .addProperty("LerpRestoreMoveType", &GCTriggerLerpObject::GetLerpRestoreMoveType, &GCTriggerLerpObject::SetLerpRestoreMoveType)
        .addProperty("SingleLerpObject", &GCTriggerLerpObject::GetSingleLerpObject, &GCTriggerLerpObject::SetSingleLerpObject)
        .addProperty("LerpingObjects", &GCTriggerLerpObject::GetLerpingObjects, &GCTriggerLerpObject::SetLerpingObjects)
        .addProperty("LerpEffect", &GCTriggerLerpObject::GetLerpEffect, &GCTriggerLerpObject::SetLerpEffect)
        .addProperty("LerpSound", &GCTriggerLerpObject::GetLerpSound, &GCTriggerLerpObject::SetLerpSound)
        .addProperty("AttachTouchingObject", &GCTriggerLerpObject::GetAttachTouchingObject, &GCTriggerLerpObject::SetAttachTouchingObject)
        .addProperty("EntityToWaitForDisconnect", &GCTriggerLerpObject::GetEntityToWaitForDisconnect, &GCTriggerLerpObject::SetEntityToWaitForDisconnect)
        .addProperty("OnLerpStarted", &GCTriggerLerpObject::GetOnLerpStarted, &GCTriggerLerpObject::SetOnLerpStarted)
        .addProperty("OnLerpFinished", &GCTriggerLerpObject::GetOnLerpFinished, &GCTriggerLerpObject::SetOnLerpFinished)
        .addProperty("Parent", &GCTriggerLerpObject::GetParent, &GCTriggerLerpObject::SetParent)
        .addFunction("ToPtr", &GCTriggerLerpObject::ToPtr)
        .addFunction("IsValid", &GCTriggerLerpObject::IsValid)
        .endClass();
}
GCTriggerSoundscape::GCTriggerSoundscape(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCTriggerSoundscape::GCTriggerSoundscape(void *ptr) {
    m_ptr = ptr;
}
GCEnvSoundscapeTriggerable GCTriggerSoundscape::GetSoundscape() const {
    GCEnvSoundscapeTriggerable value(*GetSchemaValuePtr<void*>(m_ptr, "CTriggerSoundscape", "m_hSoundscape"));
    return value;
}
void GCTriggerSoundscape::SetSoundscape(GCEnvSoundscapeTriggerable* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Soundscape' is not possible.\n");
}
std::string GCTriggerSoundscape::GetSoundscapeName() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CTriggerSoundscape", "m_SoundscapeName").String();
}
void GCTriggerSoundscape::SetSoundscapeName(std::string value) {
    SetSchemaValue(m_ptr, "CTriggerSoundscape", "m_SoundscapeName", false, CUtlSymbolLarge(value.c_str()));
}
std::string GCTriggerSoundscape::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCTriggerSoundscape::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseTrigger GCTriggerSoundscape::GetParent() const {
    GCBaseTrigger value(m_ptr);
    return value;
}
void GCTriggerSoundscape::SetParent(GCBaseTrigger value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCTriggerSoundscape(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCTriggerSoundscape>("CTriggerSoundscape")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Soundscape", &GCTriggerSoundscape::GetSoundscape, &GCTriggerSoundscape::SetSoundscape)
        .addProperty("SoundscapeName", &GCTriggerSoundscape::GetSoundscapeName, &GCTriggerSoundscape::SetSoundscapeName)
        .addProperty("Parent", &GCTriggerSoundscape::GetParent, &GCTriggerSoundscape::SetParent)
        .addFunction("ToPtr", &GCTriggerSoundscape::ToPtr)
        .addFunction("IsValid", &GCTriggerSoundscape::IsValid)
        .endClass();
}
GCLogicScript::GCLogicScript(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCLogicScript::GCLogicScript(void *ptr) {
    m_ptr = ptr;
}
std::string GCLogicScript::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCLogicScript::IsValid() {
    return (m_ptr != nullptr);
}
GCPointEntity GCLogicScript::GetParent() const {
    GCPointEntity value(m_ptr);
    return value;
}
void GCLogicScript::SetParent(GCPointEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCLogicScript(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCLogicScript>("CLogicScript")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCLogicScript::GetParent, &GCLogicScript::SetParent)
        .addFunction("ToPtr", &GCLogicScript::ToPtr)
        .addFunction("IsValid", &GCLogicScript::IsValid)
        .endClass();
}
GCWeaponFiveSeven::GCWeaponFiveSeven(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCWeaponFiveSeven::GCWeaponFiveSeven(void *ptr) {
    m_ptr = ptr;
}
std::string GCWeaponFiveSeven::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCWeaponFiveSeven::IsValid() {
    return (m_ptr != nullptr);
}
GCCSWeaponBaseGun GCWeaponFiveSeven::GetParent() const {
    GCCSWeaponBaseGun value(m_ptr);
    return value;
}
void GCWeaponFiveSeven::SetParent(GCCSWeaponBaseGun value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCWeaponFiveSeven(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCWeaponFiveSeven>("CWeaponFiveSeven")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCWeaponFiveSeven::GetParent, &GCWeaponFiveSeven::SetParent)
        .addFunction("ToPtr", &GCWeaponFiveSeven::ToPtr)
        .addFunction("IsValid", &GCWeaponFiveSeven::IsValid)
        .endClass();
}