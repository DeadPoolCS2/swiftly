#include "classes.h"

#include "../../../../sdk/entity/CBaseEntity.h"
#include "../../../../sdk/entity/CBaseModelEntity.h"

GCAttachment::GCAttachment(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCAttachment::GCAttachment(void *ptr) {
    m_ptr = ptr;
}
std::string GCAttachment::GetName() const {
    return GetSchemaValue<CUtlString>(m_ptr, "CAttachment", "m_name").Get();
}
void GCAttachment::SetName(std::string value) {
    SetSchemaValue(m_ptr, "CAttachment", "m_name", false, CUtlString(value.c_str()));
}
std::vector<CUtlString> GCAttachment::GetInfluenceNames() const {
    CUtlString* outValue = GetSchemaValue<CUtlString*>(m_ptr, "CAttachment", "m_influenceNames"); std::vector<CUtlString> ret; for(int i = 0; i < 3; i++) { ret.push_back(outValue[i]); } return ret;
}
void GCAttachment::SetInfluenceNames(std::vector<CUtlString> value) {
    CUtlString* outValue = GetSchemaValue<CUtlString*>(m_ptr, "CAttachment", "m_influenceNames"); for(int i = 0; i < 3; i++) { outValue[i] = value[i]; } SetSchemaValue(m_ptr, "CAttachment", "m_influenceNames", false, outValue);
}
std::vector<Quaternion> GCAttachment::GetInfluenceRotations() const {
    Quaternion* outValue = GetSchemaValue<Quaternion*>(m_ptr, "CAttachment", "m_vInfluenceRotations"); std::vector<Quaternion> ret; for(int i = 0; i < 3; i++) { ret.push_back(outValue[i]); } return ret;
}
void GCAttachment::SetInfluenceRotations(std::vector<Quaternion> value) {
    Quaternion* outValue = GetSchemaValue<Quaternion*>(m_ptr, "CAttachment", "m_vInfluenceRotations"); for(int i = 0; i < 3; i++) { outValue[i] = value[i]; } SetSchemaValue(m_ptr, "CAttachment", "m_vInfluenceRotations", false, outValue);
}
std::vector<Vector> GCAttachment::GetInfluenceOffsets() const {
    Vector* outValue = GetSchemaValue<Vector*>(m_ptr, "CAttachment", "m_vInfluenceOffsets"); std::vector<Vector> ret; for(int i = 0; i < 3; i++) { ret.push_back(outValue[i]); } return ret;
}
void GCAttachment::SetInfluenceOffsets(std::vector<Vector> value) {
    Vector* outValue = GetSchemaValue<Vector*>(m_ptr, "CAttachment", "m_vInfluenceOffsets"); for(int i = 0; i < 3; i++) { outValue[i] = value[i]; } SetSchemaValue(m_ptr, "CAttachment", "m_vInfluenceOffsets", false, outValue);
}
std::vector<float> GCAttachment::GetInfluenceWeights() const {
    float* outValue = GetSchemaValue<float*>(m_ptr, "CAttachment", "m_influenceWeights"); std::vector<float> ret; for(int i = 0; i < 3; i++) { ret.push_back(outValue[i]); } return ret;
}
void GCAttachment::SetInfluenceWeights(std::vector<float> value) {
    float* outValue = GetSchemaValue<float*>(m_ptr, "CAttachment", "m_influenceWeights"); for(int i = 0; i < 3; i++) { outValue[i] = value[i]; } SetSchemaValue(m_ptr, "CAttachment", "m_influenceWeights", false, outValue);
}
std::vector<bool> GCAttachment::GetInfluenceRootTransform() const {
    bool* outValue = GetSchemaValue<bool*>(m_ptr, "CAttachment", "m_bInfluenceRootTransform"); std::vector<bool> ret; for(int i = 0; i < 3; i++) { ret.push_back(outValue[i]); } return ret;
}
void GCAttachment::SetInfluenceRootTransform(std::vector<bool> value) {
    bool* outValue = GetSchemaValue<bool*>(m_ptr, "CAttachment", "m_bInfluenceRootTransform"); for(int i = 0; i < 3; i++) { outValue[i] = value[i]; } SetSchemaValue(m_ptr, "CAttachment", "m_bInfluenceRootTransform", false, outValue);
}
uint8_t GCAttachment::GetInfluences() const {
    return GetSchemaValue<uint8_t>(m_ptr, "CAttachment", "m_nInfluences");
}
void GCAttachment::SetInfluences(uint8_t value) {
    SetSchemaValue(m_ptr, "CAttachment", "m_nInfluences", false, value);
}
bool GCAttachment::GetIgnoreRotation() const {
    return GetSchemaValue<bool>(m_ptr, "CAttachment", "m_bIgnoreRotation");
}
void GCAttachment::SetIgnoreRotation(bool value) {
    SetSchemaValue(m_ptr, "CAttachment", "m_bIgnoreRotation", false, value);
}
std::string GCAttachment::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCAttachment::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCAttachment(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCAttachment>("CAttachment")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Name", &GCAttachment::GetName, &GCAttachment::SetName)
        .addProperty("InfluenceNames", &GCAttachment::GetInfluenceNames, &GCAttachment::SetInfluenceNames)
        .addProperty("InfluenceRotations", &GCAttachment::GetInfluenceRotations, &GCAttachment::SetInfluenceRotations)
        .addProperty("InfluenceOffsets", &GCAttachment::GetInfluenceOffsets, &GCAttachment::SetInfluenceOffsets)
        .addProperty("InfluenceWeights", &GCAttachment::GetInfluenceWeights, &GCAttachment::SetInfluenceWeights)
        .addProperty("InfluenceRootTransform", &GCAttachment::GetInfluenceRootTransform, &GCAttachment::SetInfluenceRootTransform)
        .addProperty("Influences", &GCAttachment::GetInfluences, &GCAttachment::SetInfluences)
        .addProperty("IgnoreRotation", &GCAttachment::GetIgnoreRotation, &GCAttachment::SetIgnoreRotation)
        .addFunction("ToPtr", &GCAttachment::ToPtr)
        .addFunction("IsValid", &GCAttachment::IsValid)
        .endClass();
}
GCEmptyEntityInstance::GCEmptyEntityInstance(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCEmptyEntityInstance::GCEmptyEntityInstance(void *ptr) {
    m_ptr = ptr;
}
std::string GCEmptyEntityInstance::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCEmptyEntityInstance::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCEmptyEntityInstance(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCEmptyEntityInstance>("CEmptyEntityInstance")
        .addConstructor<void (*)(std::string)>()
        .addFunction("ToPtr", &GCEmptyEntityInstance::ToPtr)
        .addFunction("IsValid", &GCEmptyEntityInstance::IsValid)
        .endClass();
}
GCCompositeMaterialEditorDoc::GCCompositeMaterialEditorDoc(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCCompositeMaterialEditorDoc::GCCompositeMaterialEditorDoc(void *ptr) {
    m_ptr = ptr;
}
int32_t GCCompositeMaterialEditorDoc::GetVersion() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCompositeMaterialEditorDoc", "m_nVersion");
}
void GCCompositeMaterialEditorDoc::SetVersion(int32_t value) {
    SetSchemaValue(m_ptr, "CCompositeMaterialEditorDoc", "m_nVersion", false, value);
}
std::vector<GCompositeMaterialEditorPoint_t> GCCompositeMaterialEditorDoc::GetPoints() const {
    CUtlVector<GCompositeMaterialEditorPoint_t>* vec = GetSchemaValue<CUtlVector<GCompositeMaterialEditorPoint_t>*>(m_ptr, "CCompositeMaterialEditorDoc", "m_Points"); std::vector<GCompositeMaterialEditorPoint_t> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCCompositeMaterialEditorDoc::SetPoints(std::vector<GCompositeMaterialEditorPoint_t> value) {
    SetSchemaValueCUtlVector<GCompositeMaterialEditorPoint_t>(m_ptr, "CCompositeMaterialEditorDoc", "m_Points", false, value);
}
std::string GCCompositeMaterialEditorDoc::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCCompositeMaterialEditorDoc::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCCompositeMaterialEditorDoc(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCCompositeMaterialEditorDoc>("CCompositeMaterialEditorDoc")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Version", &GCCompositeMaterialEditorDoc::GetVersion, &GCCompositeMaterialEditorDoc::SetVersion)
        .addProperty("Points", &GCCompositeMaterialEditorDoc::GetPoints, &GCCompositeMaterialEditorDoc::SetPoints)
        .addFunction("ToPtr", &GCCompositeMaterialEditorDoc::ToPtr)
        .addFunction("IsValid", &GCCompositeMaterialEditorDoc::IsValid)
        .endClass();
}
GCPhysSurfacePropertiesPhysics::GCPhysSurfacePropertiesPhysics(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCPhysSurfacePropertiesPhysics::GCPhysSurfacePropertiesPhysics(void *ptr) {
    m_ptr = ptr;
}
float GCPhysSurfacePropertiesPhysics::GetFriction() const {
    return GetSchemaValue<float>(m_ptr, "CPhysSurfacePropertiesPhysics", "m_friction");
}
void GCPhysSurfacePropertiesPhysics::SetFriction(float value) {
    SetSchemaValue(m_ptr, "CPhysSurfacePropertiesPhysics", "m_friction", false, value);
}
float GCPhysSurfacePropertiesPhysics::GetElasticity() const {
    return GetSchemaValue<float>(m_ptr, "CPhysSurfacePropertiesPhysics", "m_elasticity");
}
void GCPhysSurfacePropertiesPhysics::SetElasticity(float value) {
    SetSchemaValue(m_ptr, "CPhysSurfacePropertiesPhysics", "m_elasticity", false, value);
}
float GCPhysSurfacePropertiesPhysics::GetDensity() const {
    return GetSchemaValue<float>(m_ptr, "CPhysSurfacePropertiesPhysics", "m_density");
}
void GCPhysSurfacePropertiesPhysics::SetDensity(float value) {
    SetSchemaValue(m_ptr, "CPhysSurfacePropertiesPhysics", "m_density", false, value);
}
float GCPhysSurfacePropertiesPhysics::GetThickness() const {
    return GetSchemaValue<float>(m_ptr, "CPhysSurfacePropertiesPhysics", "m_thickness");
}
void GCPhysSurfacePropertiesPhysics::SetThickness(float value) {
    SetSchemaValue(m_ptr, "CPhysSurfacePropertiesPhysics", "m_thickness", false, value);
}
float GCPhysSurfacePropertiesPhysics::GetSoftContactFrequency() const {
    return GetSchemaValue<float>(m_ptr, "CPhysSurfacePropertiesPhysics", "m_softContactFrequency");
}
void GCPhysSurfacePropertiesPhysics::SetSoftContactFrequency(float value) {
    SetSchemaValue(m_ptr, "CPhysSurfacePropertiesPhysics", "m_softContactFrequency", false, value);
}
float GCPhysSurfacePropertiesPhysics::GetSoftContactDampingRatio() const {
    return GetSchemaValue<float>(m_ptr, "CPhysSurfacePropertiesPhysics", "m_softContactDampingRatio");
}
void GCPhysSurfacePropertiesPhysics::SetSoftContactDampingRatio(float value) {
    SetSchemaValue(m_ptr, "CPhysSurfacePropertiesPhysics", "m_softContactDampingRatio", false, value);
}
float GCPhysSurfacePropertiesPhysics::GetWheelDrag() const {
    return GetSchemaValue<float>(m_ptr, "CPhysSurfacePropertiesPhysics", "m_wheelDrag");
}
void GCPhysSurfacePropertiesPhysics::SetWheelDrag(float value) {
    SetSchemaValue(m_ptr, "CPhysSurfacePropertiesPhysics", "m_wheelDrag", false, value);
}
std::string GCPhysSurfacePropertiesPhysics::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCPhysSurfacePropertiesPhysics::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCPhysSurfacePropertiesPhysics(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCPhysSurfacePropertiesPhysics>("CPhysSurfacePropertiesPhysics")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Friction", &GCPhysSurfacePropertiesPhysics::GetFriction, &GCPhysSurfacePropertiesPhysics::SetFriction)
        .addProperty("Elasticity", &GCPhysSurfacePropertiesPhysics::GetElasticity, &GCPhysSurfacePropertiesPhysics::SetElasticity)
        .addProperty("Density", &GCPhysSurfacePropertiesPhysics::GetDensity, &GCPhysSurfacePropertiesPhysics::SetDensity)
        .addProperty("Thickness", &GCPhysSurfacePropertiesPhysics::GetThickness, &GCPhysSurfacePropertiesPhysics::SetThickness)
        .addProperty("SoftContactFrequency", &GCPhysSurfacePropertiesPhysics::GetSoftContactFrequency, &GCPhysSurfacePropertiesPhysics::SetSoftContactFrequency)
        .addProperty("SoftContactDampingRatio", &GCPhysSurfacePropertiesPhysics::GetSoftContactDampingRatio, &GCPhysSurfacePropertiesPhysics::SetSoftContactDampingRatio)
        .addProperty("WheelDrag", &GCPhysSurfacePropertiesPhysics::GetWheelDrag, &GCPhysSurfacePropertiesPhysics::SetWheelDrag)
        .addFunction("ToPtr", &GCPhysSurfacePropertiesPhysics::ToPtr)
        .addFunction("IsValid", &GCPhysSurfacePropertiesPhysics::IsValid)
        .endClass();
}
GEventClientPostOutput_t::GEventClientPostOutput_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GEventClientPostOutput_t::GEventClientPostOutput_t(void *ptr) {
    m_ptr = ptr;
}
GEngineLoopState_t GEventClientPostOutput_t::GetLoopState() const {
    GEngineLoopState_t value(GetSchemaPtr(m_ptr, "EventClientPostOutput_t", "m_LoopState"));
    return value;
}
void GEventClientPostOutput_t::SetLoopState(GEngineLoopState_t value) {
    SetSchemaValue(m_ptr, "EventClientPostOutput_t", "m_LoopState", true, value);
}
double GEventClientPostOutput_t::GetRenderTime() const {
    return GetSchemaValue<double>(m_ptr, "EventClientPostOutput_t", "m_flRenderTime");
}
void GEventClientPostOutput_t::SetRenderTime(double value) {
    SetSchemaValue(m_ptr, "EventClientPostOutput_t", "m_flRenderTime", true, value);
}
float GEventClientPostOutput_t::GetRenderFrameTime() const {
    return GetSchemaValue<float>(m_ptr, "EventClientPostOutput_t", "m_flRenderFrameTime");
}
void GEventClientPostOutput_t::SetRenderFrameTime(float value) {
    SetSchemaValue(m_ptr, "EventClientPostOutput_t", "m_flRenderFrameTime", true, value);
}
float GEventClientPostOutput_t::GetRenderFrameTimeUnbounded() const {
    return GetSchemaValue<float>(m_ptr, "EventClientPostOutput_t", "m_flRenderFrameTimeUnbounded");
}
void GEventClientPostOutput_t::SetRenderFrameTimeUnbounded(float value) {
    SetSchemaValue(m_ptr, "EventClientPostOutput_t", "m_flRenderFrameTimeUnbounded", true, value);
}
bool GEventClientPostOutput_t::GetRenderOnly() const {
    return GetSchemaValue<bool>(m_ptr, "EventClientPostOutput_t", "m_bRenderOnly");
}
void GEventClientPostOutput_t::SetRenderOnly(bool value) {
    SetSchemaValue(m_ptr, "EventClientPostOutput_t", "m_bRenderOnly", true, value);
}
std::string GEventClientPostOutput_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GEventClientPostOutput_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassEventClientPostOutput_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GEventClientPostOutput_t>("EventClientPostOutput_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("LoopState", &GEventClientPostOutput_t::GetLoopState, &GEventClientPostOutput_t::SetLoopState)
        .addProperty("RenderTime", &GEventClientPostOutput_t::GetRenderTime, &GEventClientPostOutput_t::SetRenderTime)
        .addProperty("RenderFrameTime", &GEventClientPostOutput_t::GetRenderFrameTime, &GEventClientPostOutput_t::SetRenderFrameTime)
        .addProperty("RenderFrameTimeUnbounded", &GEventClientPostOutput_t::GetRenderFrameTimeUnbounded, &GEventClientPostOutput_t::SetRenderFrameTimeUnbounded)
        .addProperty("RenderOnly", &GEventClientPostOutput_t::GetRenderOnly, &GEventClientPostOutput_t::SetRenderOnly)
        .addFunction("ToPtr", &GEventClientPostOutput_t::ToPtr)
        .addFunction("IsValid", &GEventClientPostOutput_t::IsValid)
        .endClass();
}
GFeNodeIntegrator_t::GFeNodeIntegrator_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GFeNodeIntegrator_t::GFeNodeIntegrator_t(void *ptr) {
    m_ptr = ptr;
}
float GFeNodeIntegrator_t::GetPointDamping() const {
    return GetSchemaValue<float>(m_ptr, "FeNodeIntegrator_t", "flPointDamping");
}
void GFeNodeIntegrator_t::SetPointDamping(float value) {
    SetSchemaValue(m_ptr, "FeNodeIntegrator_t", "flPointDamping", true, value);
}
float GFeNodeIntegrator_t::GetAnimationForceAttraction() const {
    return GetSchemaValue<float>(m_ptr, "FeNodeIntegrator_t", "flAnimationForceAttraction");
}
void GFeNodeIntegrator_t::SetAnimationForceAttraction(float value) {
    SetSchemaValue(m_ptr, "FeNodeIntegrator_t", "flAnimationForceAttraction", true, value);
}
float GFeNodeIntegrator_t::GetAnimationVertexAttraction() const {
    return GetSchemaValue<float>(m_ptr, "FeNodeIntegrator_t", "flAnimationVertexAttraction");
}
void GFeNodeIntegrator_t::SetAnimationVertexAttraction(float value) {
    SetSchemaValue(m_ptr, "FeNodeIntegrator_t", "flAnimationVertexAttraction", true, value);
}
float GFeNodeIntegrator_t::GetGravity() const {
    return GetSchemaValue<float>(m_ptr, "FeNodeIntegrator_t", "flGravity");
}
void GFeNodeIntegrator_t::SetGravity(float value) {
    SetSchemaValue(m_ptr, "FeNodeIntegrator_t", "flGravity", true, value);
}
std::string GFeNodeIntegrator_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GFeNodeIntegrator_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassFeNodeIntegrator_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GFeNodeIntegrator_t>("FeNodeIntegrator_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("PointDamping", &GFeNodeIntegrator_t::GetPointDamping, &GFeNodeIntegrator_t::SetPointDamping)
        .addProperty("AnimationForceAttraction", &GFeNodeIntegrator_t::GetAnimationForceAttraction, &GFeNodeIntegrator_t::SetAnimationForceAttraction)
        .addProperty("AnimationVertexAttraction", &GFeNodeIntegrator_t::GetAnimationVertexAttraction, &GFeNodeIntegrator_t::SetAnimationVertexAttraction)
        .addProperty("Gravity", &GFeNodeIntegrator_t::GetGravity, &GFeNodeIntegrator_t::SetGravity)
        .addFunction("ToPtr", &GFeNodeIntegrator_t::ToPtr)
        .addFunction("IsValid", &GFeNodeIntegrator_t::IsValid)
        .endClass();
}
GRnMeshDesc_t::GRnMeshDesc_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GRnMeshDesc_t::GRnMeshDesc_t(void *ptr) {
    m_ptr = ptr;
}
GRnMesh_t GRnMeshDesc_t::GetMesh() const {
    GRnMesh_t value(GetSchemaPtr(m_ptr, "RnMeshDesc_t", "m_Mesh"));
    return value;
}
void GRnMeshDesc_t::SetMesh(GRnMesh_t value) {
    SetSchemaValue(m_ptr, "RnMeshDesc_t", "m_Mesh", true, value);
}
std::string GRnMeshDesc_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GRnMeshDesc_t::IsValid() {
    return (m_ptr != nullptr);
}
GRnShapeDesc_t GRnMeshDesc_t::GetParent() const {
    GRnShapeDesc_t value(m_ptr);
    return value;
}
void GRnMeshDesc_t::SetParent(GRnShapeDesc_t value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassRnMeshDesc_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GRnMeshDesc_t>("RnMeshDesc_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Mesh", &GRnMeshDesc_t::GetMesh, &GRnMeshDesc_t::SetMesh)
        .addProperty("Parent", &GRnMeshDesc_t::GetParent, &GRnMeshDesc_t::SetParent)
        .addFunction("ToPtr", &GRnMeshDesc_t::ToPtr)
        .addFunction("IsValid", &GRnMeshDesc_t::IsValid)
        .endClass();
}
GCAnimGraphNetworkSettings::GCAnimGraphNetworkSettings(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCAnimGraphNetworkSettings::GCAnimGraphNetworkSettings(void *ptr) {
    m_ptr = ptr;
}
bool GCAnimGraphNetworkSettings::GetNetworkingEnabled() const {
    return GetSchemaValue<bool>(m_ptr, "CAnimGraphNetworkSettings", "m_bNetworkingEnabled");
}
void GCAnimGraphNetworkSettings::SetNetworkingEnabled(bool value) {
    SetSchemaValue(m_ptr, "CAnimGraphNetworkSettings", "m_bNetworkingEnabled", false, value);
}
std::string GCAnimGraphNetworkSettings::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCAnimGraphNetworkSettings::IsValid() {
    return (m_ptr != nullptr);
}
GCAnimGraphSettingsGroup GCAnimGraphNetworkSettings::GetParent() const {
    GCAnimGraphSettingsGroup value(m_ptr);
    return value;
}
void GCAnimGraphNetworkSettings::SetParent(GCAnimGraphSettingsGroup value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCAnimGraphNetworkSettings(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCAnimGraphNetworkSettings>("CAnimGraphNetworkSettings")
        .addConstructor<void (*)(std::string)>()
        .addProperty("NetworkingEnabled", &GCAnimGraphNetworkSettings::GetNetworkingEnabled, &GCAnimGraphNetworkSettings::SetNetworkingEnabled)
        .addProperty("Parent", &GCAnimGraphNetworkSettings::GetParent, &GCAnimGraphNetworkSettings::SetParent)
        .addFunction("ToPtr", &GCAnimGraphNetworkSettings::ToPtr)
        .addFunction("IsValid", &GCAnimGraphNetworkSettings::IsValid)
        .endClass();
}
GCAimConstraint::GCAimConstraint(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCAimConstraint::GCAimConstraint(void *ptr) {
    m_ptr = ptr;
}
Quaternion GCAimConstraint::GetAimOffset() const {
    return GetSchemaValue<Quaternion>(m_ptr, "CAimConstraint", "m_qAimOffset");
}
void GCAimConstraint::SetAimOffset(Quaternion value) {
    SetSchemaValue(m_ptr, "CAimConstraint", "m_qAimOffset", false, value);
}
uint32_t GCAimConstraint::GetUpType() const {
    return GetSchemaValue<uint32_t>(m_ptr, "CAimConstraint", "m_nUpType");
}
void GCAimConstraint::SetUpType(uint32_t value) {
    SetSchemaValue(m_ptr, "CAimConstraint", "m_nUpType", false, value);
}
std::string GCAimConstraint::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCAimConstraint::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseConstraint GCAimConstraint::GetParent() const {
    GCBaseConstraint value(m_ptr);
    return value;
}
void GCAimConstraint::SetParent(GCBaseConstraint value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCAimConstraint(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCAimConstraint>("CAimConstraint")
        .addConstructor<void (*)(std::string)>()
        .addProperty("AimOffset", &GCAimConstraint::GetAimOffset, &GCAimConstraint::SetAimOffset)
        .addProperty("UpType", &GCAimConstraint::GetUpType, &GCAimConstraint::SetUpType)
        .addProperty("Parent", &GCAimConstraint::GetParent, &GCAimConstraint::SetParent)
        .addFunction("ToPtr", &GCAimConstraint::ToPtr)
        .addFunction("IsValid", &GCAimConstraint::IsValid)
        .endClass();
}
GCAnimActionUpdater::GCAnimActionUpdater(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCAnimActionUpdater::GCAnimActionUpdater(void *ptr) {
    m_ptr = ptr;
}
std::string GCAnimActionUpdater::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCAnimActionUpdater::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCAnimActionUpdater(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCAnimActionUpdater>("CAnimActionUpdater")
        .addConstructor<void (*)(std::string)>()
        .addFunction("ToPtr", &GCAnimActionUpdater::ToPtr)
        .addFunction("IsValid", &GCAnimActionUpdater::IsValid)
        .endClass();
}
GCParticleFunctionForce::GCParticleFunctionForce(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCParticleFunctionForce::GCParticleFunctionForce(void *ptr) {
    m_ptr = ptr;
}
std::string GCParticleFunctionForce::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCParticleFunctionForce::IsValid() {
    return (m_ptr != nullptr);
}
GCParticleFunction GCParticleFunctionForce::GetParent() const {
    GCParticleFunction value(m_ptr);
    return value;
}
void GCParticleFunctionForce::SetParent(GCParticleFunction value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCParticleFunctionForce(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCParticleFunctionForce>("CParticleFunctionForce")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCParticleFunctionForce::GetParent, &GCParticleFunctionForce::SetParent)
        .addFunction("ToPtr", &GCParticleFunctionForce::ToPtr)
        .addFunction("IsValid", &GCParticleFunctionForce::IsValid)
        .endClass();
}
GCSpinUpdateBase::GCSpinUpdateBase(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCSpinUpdateBase::GCSpinUpdateBase(void *ptr) {
    m_ptr = ptr;
}
std::string GCSpinUpdateBase::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCSpinUpdateBase::IsValid() {
    return (m_ptr != nullptr);
}
GCParticleFunctionOperator GCSpinUpdateBase::GetParent() const {
    GCParticleFunctionOperator value(m_ptr);
    return value;
}
void GCSpinUpdateBase::SetParent(GCParticleFunctionOperator value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCSpinUpdateBase(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCSpinUpdateBase>("CSpinUpdateBase")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCSpinUpdateBase::GetParent, &GCSpinUpdateBase::SetParent)
        .addFunction("ToPtr", &GCSpinUpdateBase::ToPtr)
        .addFunction("IsValid", &GCSpinUpdateBase::IsValid)
        .endClass();
}
GControlPointReference_t::GControlPointReference_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GControlPointReference_t::GControlPointReference_t(void *ptr) {
    m_ptr = ptr;
}
int32_t GControlPointReference_t::GetControlPointNameString() const {
    return GetSchemaValue<int32_t>(m_ptr, "ControlPointReference_t", "m_controlPointNameString");
}
void GControlPointReference_t::SetControlPointNameString(int32_t value) {
    SetSchemaValue(m_ptr, "ControlPointReference_t", "m_controlPointNameString", true, value);
}
Vector GControlPointReference_t::GetOffsetFromControlPoint() const {
    return GetSchemaValue<Vector>(m_ptr, "ControlPointReference_t", "m_vOffsetFromControlPoint");
}
void GControlPointReference_t::SetOffsetFromControlPoint(Vector value) {
    SetSchemaValue(m_ptr, "ControlPointReference_t", "m_vOffsetFromControlPoint", true, value);
}
bool GControlPointReference_t::GetOffsetInLocalSpace() const {
    return GetSchemaValue<bool>(m_ptr, "ControlPointReference_t", "m_bOffsetInLocalSpace");
}
void GControlPointReference_t::SetOffsetInLocalSpace(bool value) {
    SetSchemaValue(m_ptr, "ControlPointReference_t", "m_bOffsetInLocalSpace", true, value);
}
std::string GControlPointReference_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GControlPointReference_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassControlPointReference_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GControlPointReference_t>("ControlPointReference_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("ControlPointNameString", &GControlPointReference_t::GetControlPointNameString, &GControlPointReference_t::SetControlPointNameString)
        .addProperty("OffsetFromControlPoint", &GControlPointReference_t::GetOffsetFromControlPoint, &GControlPointReference_t::SetOffsetFromControlPoint)
        .addProperty("OffsetInLocalSpace", &GControlPointReference_t::GetOffsetInLocalSpace, &GControlPointReference_t::SetOffsetInLocalSpace)
        .addFunction("ToPtr", &GControlPointReference_t::ToPtr)
        .addFunction("IsValid", &GControlPointReference_t::IsValid)
        .endClass();
}
GCVoiceContainerRandomSampler::GCVoiceContainerRandomSampler(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCVoiceContainerRandomSampler::GCVoiceContainerRandomSampler(void *ptr) {
    m_ptr = ptr;
}
float GCVoiceContainerRandomSampler::GetAmplitude() const {
    return GetSchemaValue<float>(m_ptr, "CVoiceContainerRandomSampler", "m_flAmplitude");
}
void GCVoiceContainerRandomSampler::SetAmplitude(float value) {
    SetSchemaValue(m_ptr, "CVoiceContainerRandomSampler", "m_flAmplitude", false, value);
}
float GCVoiceContainerRandomSampler::GetAmplitudeJitter() const {
    return GetSchemaValue<float>(m_ptr, "CVoiceContainerRandomSampler", "m_flAmplitudeJitter");
}
void GCVoiceContainerRandomSampler::SetAmplitudeJitter(float value) {
    SetSchemaValue(m_ptr, "CVoiceContainerRandomSampler", "m_flAmplitudeJitter", false, value);
}
float GCVoiceContainerRandomSampler::GetTimeJitter() const {
    return GetSchemaValue<float>(m_ptr, "CVoiceContainerRandomSampler", "m_flTimeJitter");
}
void GCVoiceContainerRandomSampler::SetTimeJitter(float value) {
    SetSchemaValue(m_ptr, "CVoiceContainerRandomSampler", "m_flTimeJitter", false, value);
}
float GCVoiceContainerRandomSampler::GetMaxLength() const {
    return GetSchemaValue<float>(m_ptr, "CVoiceContainerRandomSampler", "m_flMaxLength");
}
void GCVoiceContainerRandomSampler::SetMaxLength(float value) {
    SetSchemaValue(m_ptr, "CVoiceContainerRandomSampler", "m_flMaxLength", false, value);
}
int32_t GCVoiceContainerRandomSampler::GetNumDelayVariations() const {
    return GetSchemaValue<int32_t>(m_ptr, "CVoiceContainerRandomSampler", "m_nNumDelayVariations");
}
void GCVoiceContainerRandomSampler::SetNumDelayVariations(int32_t value) {
    SetSchemaValue(m_ptr, "CVoiceContainerRandomSampler", "m_nNumDelayVariations", false, value);
}
std::string GCVoiceContainerRandomSampler::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCVoiceContainerRandomSampler::IsValid() {
    return (m_ptr != nullptr);
}
GCVoiceContainerBase GCVoiceContainerRandomSampler::GetParent() const {
    GCVoiceContainerBase value(m_ptr);
    return value;
}
void GCVoiceContainerRandomSampler::SetParent(GCVoiceContainerBase value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCVoiceContainerRandomSampler(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCVoiceContainerRandomSampler>("CVoiceContainerRandomSampler")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Amplitude", &GCVoiceContainerRandomSampler::GetAmplitude, &GCVoiceContainerRandomSampler::SetAmplitude)
        .addProperty("AmplitudeJitter", &GCVoiceContainerRandomSampler::GetAmplitudeJitter, &GCVoiceContainerRandomSampler::SetAmplitudeJitter)
        .addProperty("TimeJitter", &GCVoiceContainerRandomSampler::GetTimeJitter, &GCVoiceContainerRandomSampler::SetTimeJitter)
        .addProperty("MaxLength", &GCVoiceContainerRandomSampler::GetMaxLength, &GCVoiceContainerRandomSampler::SetMaxLength)
        .addProperty("NumDelayVariations", &GCVoiceContainerRandomSampler::GetNumDelayVariations, &GCVoiceContainerRandomSampler::SetNumDelayVariations)
        .addProperty("Parent", &GCVoiceContainerRandomSampler::GetParent, &GCVoiceContainerRandomSampler::SetParent)
        .addFunction("ToPtr", &GCVoiceContainerRandomSampler::ToPtr)
        .addFunction("IsValid", &GCVoiceContainerRandomSampler::IsValid)
        .endClass();
}
GFeFollowNode_t::GFeFollowNode_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GFeFollowNode_t::GFeFollowNode_t(void *ptr) {
    m_ptr = ptr;
}
uint16_t GFeFollowNode_t::GetParentNode() const {
    return GetSchemaValue<uint16_t>(m_ptr, "FeFollowNode_t", "nParentNode");
}
void GFeFollowNode_t::SetParentNode(uint16_t value) {
    SetSchemaValue(m_ptr, "FeFollowNode_t", "nParentNode", true, value);
}
uint16_t GFeFollowNode_t::GetChildNode() const {
    return GetSchemaValue<uint16_t>(m_ptr, "FeFollowNode_t", "nChildNode");
}
void GFeFollowNode_t::SetChildNode(uint16_t value) {
    SetSchemaValue(m_ptr, "FeFollowNode_t", "nChildNode", true, value);
}
float GFeFollowNode_t::GetWeight() const {
    return GetSchemaValue<float>(m_ptr, "FeFollowNode_t", "flWeight");
}
void GFeFollowNode_t::SetWeight(float value) {
    SetSchemaValue(m_ptr, "FeFollowNode_t", "flWeight", true, value);
}
std::string GFeFollowNode_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GFeFollowNode_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassFeFollowNode_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GFeFollowNode_t>("FeFollowNode_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("ParentNode", &GFeFollowNode_t::GetParentNode, &GFeFollowNode_t::SetParentNode)
        .addProperty("ChildNode", &GFeFollowNode_t::GetChildNode, &GFeFollowNode_t::SetChildNode)
        .addProperty("Weight", &GFeFollowNode_t::GetWeight, &GFeFollowNode_t::SetWeight)
        .addFunction("ToPtr", &GFeFollowNode_t::ToPtr)
        .addFunction("IsValid", &GFeFollowNode_t::IsValid)
        .endClass();
}
GCovMatrix3::GCovMatrix3(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCovMatrix3::GCovMatrix3(void *ptr) {
    m_ptr = ptr;
}
Vector GCovMatrix3::GetDiag() const {
    return GetSchemaValue<Vector>(m_ptr, "CovMatrix3", "m_vDiag");
}
void GCovMatrix3::SetDiag(Vector value) {
    SetSchemaValue(m_ptr, "CovMatrix3", "m_vDiag", false, value);
}
float GCovMatrix3::GetXY() const {
    return GetSchemaValue<float>(m_ptr, "CovMatrix3", "m_flXY");
}
void GCovMatrix3::SetXY(float value) {
    SetSchemaValue(m_ptr, "CovMatrix3", "m_flXY", false, value);
}
float GCovMatrix3::GetXZ() const {
    return GetSchemaValue<float>(m_ptr, "CovMatrix3", "m_flXZ");
}
void GCovMatrix3::SetXZ(float value) {
    SetSchemaValue(m_ptr, "CovMatrix3", "m_flXZ", false, value);
}
float GCovMatrix3::GetYZ() const {
    return GetSchemaValue<float>(m_ptr, "CovMatrix3", "m_flYZ");
}
void GCovMatrix3::SetYZ(float value) {
    SetSchemaValue(m_ptr, "CovMatrix3", "m_flYZ", false, value);
}
std::string GCovMatrix3::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCovMatrix3::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCovMatrix3(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCovMatrix3>("CovMatrix3")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Diag", &GCovMatrix3::GetDiag, &GCovMatrix3::SetDiag)
        .addProperty("XY", &GCovMatrix3::GetXY, &GCovMatrix3::SetXY)
        .addProperty("XZ", &GCovMatrix3::GetXZ, &GCovMatrix3::SetXZ)
        .addProperty("YZ", &GCovMatrix3::GetYZ, &GCovMatrix3::SetYZ)
        .addFunction("ToPtr", &GCovMatrix3::ToPtr)
        .addFunction("IsValid", &GCovMatrix3::IsValid)
        .endClass();
}
GAnimStateID::GAnimStateID(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GAnimStateID::GAnimStateID(void *ptr) {
    m_ptr = ptr;
}
uint32_t GAnimStateID::GetId() const {
    return GetSchemaValue<uint32_t>(m_ptr, "AnimStateID", "m_id");
}
void GAnimStateID::SetId(uint32_t value) {
    SetSchemaValue(m_ptr, "AnimStateID", "m_id", false, value);
}
std::string GAnimStateID::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GAnimStateID::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassAnimStateID(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GAnimStateID>("AnimStateID")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Id", &GAnimStateID::GetId, &GAnimStateID::SetId)
        .addFunction("ToPtr", &GAnimStateID::ToPtr)
        .addFunction("IsValid", &GAnimStateID::IsValid)
        .endClass();
}
GCVoiceContainerStaticAdditiveSynth::GCVoiceContainerStaticAdditiveSynth(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCVoiceContainerStaticAdditiveSynth::GCVoiceContainerStaticAdditiveSynth(void *ptr) {
    m_ptr = ptr;
}
float GCVoiceContainerStaticAdditiveSynth::GetMinVolume() const {
    return GetSchemaValue<float>(m_ptr, "CVoiceContainerStaticAdditiveSynth", "m_flMinVolume");
}
void GCVoiceContainerStaticAdditiveSynth::SetMinVolume(float value) {
    SetSchemaValue(m_ptr, "CVoiceContainerStaticAdditiveSynth", "m_flMinVolume", false, value);
}
int32_t GCVoiceContainerStaticAdditiveSynth::GetInstancesAtMinVolume() const {
    return GetSchemaValue<int32_t>(m_ptr, "CVoiceContainerStaticAdditiveSynth", "m_nInstancesAtMinVolume");
}
void GCVoiceContainerStaticAdditiveSynth::SetInstancesAtMinVolume(int32_t value) {
    SetSchemaValue(m_ptr, "CVoiceContainerStaticAdditiveSynth", "m_nInstancesAtMinVolume", false, value);
}
float GCVoiceContainerStaticAdditiveSynth::GetMaxVolume() const {
    return GetSchemaValue<float>(m_ptr, "CVoiceContainerStaticAdditiveSynth", "m_flMaxVolume");
}
void GCVoiceContainerStaticAdditiveSynth::SetMaxVolume(float value) {
    SetSchemaValue(m_ptr, "CVoiceContainerStaticAdditiveSynth", "m_flMaxVolume", false, value);
}
int32_t GCVoiceContainerStaticAdditiveSynth::GetInstancesAtMaxVolume() const {
    return GetSchemaValue<int32_t>(m_ptr, "CVoiceContainerStaticAdditiveSynth", "m_nInstancesAtMaxVolume");
}
void GCVoiceContainerStaticAdditiveSynth::SetInstancesAtMaxVolume(int32_t value) {
    SetSchemaValue(m_ptr, "CVoiceContainerStaticAdditiveSynth", "m_nInstancesAtMaxVolume", false, value);
}
std::string GCVoiceContainerStaticAdditiveSynth::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCVoiceContainerStaticAdditiveSynth::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCVoiceContainerStaticAdditiveSynth(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCVoiceContainerStaticAdditiveSynth>("CVoiceContainerStaticAdditiveSynth")
        .addConstructor<void (*)(std::string)>()
        .addProperty("MinVolume", &GCVoiceContainerStaticAdditiveSynth::GetMinVolume, &GCVoiceContainerStaticAdditiveSynth::SetMinVolume)
        .addProperty("InstancesAtMinVolume", &GCVoiceContainerStaticAdditiveSynth::GetInstancesAtMinVolume, &GCVoiceContainerStaticAdditiveSynth::SetInstancesAtMinVolume)
        .addProperty("MaxVolume", &GCVoiceContainerStaticAdditiveSynth::GetMaxVolume, &GCVoiceContainerStaticAdditiveSynth::SetMaxVolume)
        .addProperty("InstancesAtMaxVolume", &GCVoiceContainerStaticAdditiveSynth::GetInstancesAtMaxVolume, &GCVoiceContainerStaticAdditiveSynth::SetInstancesAtMaxVolume)
        .addFunction("ToPtr", &GCVoiceContainerStaticAdditiveSynth::ToPtr)
        .addFunction("IsValid", &GCVoiceContainerStaticAdditiveSynth::IsValid)
        .endClass();
}
GRnSoftbodyCapsule_t::GRnSoftbodyCapsule_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GRnSoftbodyCapsule_t::GRnSoftbodyCapsule_t(void *ptr) {
    m_ptr = ptr;
}
std::vector<Vector> GRnSoftbodyCapsule_t::GetCenter() const {
    Vector* outValue = GetSchemaValue<Vector*>(m_ptr, "RnSoftbodyCapsule_t", "m_vCenter"); std::vector<Vector> ret; for(int i = 0; i < 2; i++) { ret.push_back(outValue[i]); } return ret;
}
void GRnSoftbodyCapsule_t::SetCenter(std::vector<Vector> value) {
    Vector* outValue = GetSchemaValue<Vector*>(m_ptr, "RnSoftbodyCapsule_t", "m_vCenter"); for(int i = 0; i < 2; i++) { outValue[i] = value[i]; } SetSchemaValue(m_ptr, "RnSoftbodyCapsule_t", "m_vCenter", true, outValue);
}
float GRnSoftbodyCapsule_t::GetRadius() const {
    return GetSchemaValue<float>(m_ptr, "RnSoftbodyCapsule_t", "m_flRadius");
}
void GRnSoftbodyCapsule_t::SetRadius(float value) {
    SetSchemaValue(m_ptr, "RnSoftbodyCapsule_t", "m_flRadius", true, value);
}
std::vector<uint16_t> GRnSoftbodyCapsule_t::GetParticle() const {
    uint16_t* outValue = GetSchemaValue<uint16_t*>(m_ptr, "RnSoftbodyCapsule_t", "m_nParticle"); std::vector<uint16_t> ret; for(int i = 0; i < 2; i++) { ret.push_back(outValue[i]); } return ret;
}
void GRnSoftbodyCapsule_t::SetParticle(std::vector<uint16_t> value) {
    uint16_t* outValue = GetSchemaValue<uint16_t*>(m_ptr, "RnSoftbodyCapsule_t", "m_nParticle"); for(int i = 0; i < 2; i++) { outValue[i] = value[i]; } SetSchemaValue(m_ptr, "RnSoftbodyCapsule_t", "m_nParticle", true, outValue);
}
std::string GRnSoftbodyCapsule_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GRnSoftbodyCapsule_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassRnSoftbodyCapsule_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GRnSoftbodyCapsule_t>("RnSoftbodyCapsule_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Center", &GRnSoftbodyCapsule_t::GetCenter, &GRnSoftbodyCapsule_t::SetCenter)
        .addProperty("Radius", &GRnSoftbodyCapsule_t::GetRadius, &GRnSoftbodyCapsule_t::SetRadius)
        .addProperty("Particle", &GRnSoftbodyCapsule_t::GetParticle, &GRnSoftbodyCapsule_t::SetParticle)
        .addFunction("ToPtr", &GRnSoftbodyCapsule_t::ToPtr)
        .addFunction("IsValid", &GRnSoftbodyCapsule_t::IsValid)
        .endClass();
}
GCModelConfigElement_RandomPick::GCModelConfigElement_RandomPick(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCModelConfigElement_RandomPick::GCModelConfigElement_RandomPick(void *ptr) {
    m_ptr = ptr;
}
std::vector<CUtlString> GCModelConfigElement_RandomPick::GetChoices() const {
    CUtlVector<CUtlString>* vec = GetSchemaValue<CUtlVector<CUtlString>*>(m_ptr, "CModelConfigElement_RandomPick", "m_Choices"); std::vector<CUtlString> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCModelConfigElement_RandomPick::SetChoices(std::vector<CUtlString> value) {
    SetSchemaValueCUtlVector<CUtlString>(m_ptr, "CModelConfigElement_RandomPick", "m_Choices", false, value);
}
std::vector<float32> GCModelConfigElement_RandomPick::GetChoiceWeights() const {
    CUtlVector<float32>* vec = GetSchemaValue<CUtlVector<float32>*>(m_ptr, "CModelConfigElement_RandomPick", "m_ChoiceWeights"); std::vector<float32> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCModelConfigElement_RandomPick::SetChoiceWeights(std::vector<float32> value) {
    SetSchemaValueCUtlVector<float32>(m_ptr, "CModelConfigElement_RandomPick", "m_ChoiceWeights", false, value);
}
std::string GCModelConfigElement_RandomPick::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCModelConfigElement_RandomPick::IsValid() {
    return (m_ptr != nullptr);
}
GCModelConfigElement GCModelConfigElement_RandomPick::GetParent() const {
    GCModelConfigElement value(m_ptr);
    return value;
}
void GCModelConfigElement_RandomPick::SetParent(GCModelConfigElement value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCModelConfigElement_RandomPick(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCModelConfigElement_RandomPick>("CModelConfigElement_RandomPick")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Choices", &GCModelConfigElement_RandomPick::GetChoices, &GCModelConfigElement_RandomPick::SetChoices)
        .addProperty("ChoiceWeights", &GCModelConfigElement_RandomPick::GetChoiceWeights, &GCModelConfigElement_RandomPick::SetChoiceWeights)
        .addProperty("Parent", &GCModelConfigElement_RandomPick::GetParent, &GCModelConfigElement_RandomPick::SetParent)
        .addFunction("ToPtr", &GCModelConfigElement_RandomPick::ToPtr)
        .addFunction("IsValid", &GCModelConfigElement_RandomPick::IsValid)
        .endClass();
}
GNmSyncTrackTime_t::GNmSyncTrackTime_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GNmSyncTrackTime_t::GNmSyncTrackTime_t(void *ptr) {
    m_ptr = ptr;
}
int32_t GNmSyncTrackTime_t::GetEventIdx() const {
    return GetSchemaValue<int32_t>(m_ptr, "NmSyncTrackTime_t", "m_nEventIdx");
}
void GNmSyncTrackTime_t::SetEventIdx(int32_t value) {
    SetSchemaValue(m_ptr, "NmSyncTrackTime_t", "m_nEventIdx", true, value);
}
GNmPercent_t GNmSyncTrackTime_t::GetPercentageThrough() const {
    GNmPercent_t value(GetSchemaPtr(m_ptr, "NmSyncTrackTime_t", "m_percentageThrough"));
    return value;
}
void GNmSyncTrackTime_t::SetPercentageThrough(GNmPercent_t value) {
    SetSchemaValue(m_ptr, "NmSyncTrackTime_t", "m_percentageThrough", true, value);
}
std::string GNmSyncTrackTime_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GNmSyncTrackTime_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassNmSyncTrackTime_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GNmSyncTrackTime_t>("NmSyncTrackTime_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("EventIdx", &GNmSyncTrackTime_t::GetEventIdx, &GNmSyncTrackTime_t::SetEventIdx)
        .addProperty("PercentageThrough", &GNmSyncTrackTime_t::GetPercentageThrough, &GNmSyncTrackTime_t::SetPercentageThrough)
        .addFunction("ToPtr", &GNmSyncTrackTime_t::ToPtr)
        .addFunction("IsValid", &GNmSyncTrackTime_t::IsValid)
        .endClass();
}
GCGeneralRandomRotation::GCGeneralRandomRotation(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCGeneralRandomRotation::GCGeneralRandomRotation(void *ptr) {
    m_ptr = ptr;
}
GParticleAttributeIndex_t GCGeneralRandomRotation::GetFieldOutput() const {
    GParticleAttributeIndex_t value(GetSchemaPtr(m_ptr, "CGeneralRandomRotation", "m_nFieldOutput"));
    return value;
}
void GCGeneralRandomRotation::SetFieldOutput(GParticleAttributeIndex_t value) {
    SetSchemaValue(m_ptr, "CGeneralRandomRotation", "m_nFieldOutput", false, value);
}
float GCGeneralRandomRotation::GetDegrees() const {
    return GetSchemaValue<float>(m_ptr, "CGeneralRandomRotation", "m_flDegrees");
}
void GCGeneralRandomRotation::SetDegrees(float value) {
    SetSchemaValue(m_ptr, "CGeneralRandomRotation", "m_flDegrees", false, value);
}
float GCGeneralRandomRotation::GetDegreesMin() const {
    return GetSchemaValue<float>(m_ptr, "CGeneralRandomRotation", "m_flDegreesMin");
}
void GCGeneralRandomRotation::SetDegreesMin(float value) {
    SetSchemaValue(m_ptr, "CGeneralRandomRotation", "m_flDegreesMin", false, value);
}
float GCGeneralRandomRotation::GetDegreesMax() const {
    return GetSchemaValue<float>(m_ptr, "CGeneralRandomRotation", "m_flDegreesMax");
}
void GCGeneralRandomRotation::SetDegreesMax(float value) {
    SetSchemaValue(m_ptr, "CGeneralRandomRotation", "m_flDegreesMax", false, value);
}
float GCGeneralRandomRotation::GetRotationRandExponent() const {
    return GetSchemaValue<float>(m_ptr, "CGeneralRandomRotation", "m_flRotationRandExponent");
}
void GCGeneralRandomRotation::SetRotationRandExponent(float value) {
    SetSchemaValue(m_ptr, "CGeneralRandomRotation", "m_flRotationRandExponent", false, value);
}
bool GCGeneralRandomRotation::GetRandomlyFlipDirection() const {
    return GetSchemaValue<bool>(m_ptr, "CGeneralRandomRotation", "m_bRandomlyFlipDirection");
}
void GCGeneralRandomRotation::SetRandomlyFlipDirection(bool value) {
    SetSchemaValue(m_ptr, "CGeneralRandomRotation", "m_bRandomlyFlipDirection", false, value);
}
std::string GCGeneralRandomRotation::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCGeneralRandomRotation::IsValid() {
    return (m_ptr != nullptr);
}
GCParticleFunctionInitializer GCGeneralRandomRotation::GetParent() const {
    GCParticleFunctionInitializer value(m_ptr);
    return value;
}
void GCGeneralRandomRotation::SetParent(GCParticleFunctionInitializer value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCGeneralRandomRotation(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCGeneralRandomRotation>("CGeneralRandomRotation")
        .addConstructor<void (*)(std::string)>()
        .addProperty("FieldOutput", &GCGeneralRandomRotation::GetFieldOutput, &GCGeneralRandomRotation::SetFieldOutput)
        .addProperty("Degrees", &GCGeneralRandomRotation::GetDegrees, &GCGeneralRandomRotation::SetDegrees)
        .addProperty("DegreesMin", &GCGeneralRandomRotation::GetDegreesMin, &GCGeneralRandomRotation::SetDegreesMin)
        .addProperty("DegreesMax", &GCGeneralRandomRotation::GetDegreesMax, &GCGeneralRandomRotation::SetDegreesMax)
        .addProperty("RotationRandExponent", &GCGeneralRandomRotation::GetRotationRandExponent, &GCGeneralRandomRotation::SetRotationRandExponent)
        .addProperty("RandomlyFlipDirection", &GCGeneralRandomRotation::GetRandomlyFlipDirection, &GCGeneralRandomRotation::SetRandomlyFlipDirection)
        .addProperty("Parent", &GCGeneralRandomRotation::GetParent, &GCGeneralRandomRotation::SetParent)
        .addFunction("ToPtr", &GCGeneralRandomRotation::ToPtr)
        .addFunction("IsValid", &GCGeneralRandomRotation::IsValid)
        .endClass();
}
GRnPlane_t::GRnPlane_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GRnPlane_t::GRnPlane_t(void *ptr) {
    m_ptr = ptr;
}
Vector GRnPlane_t::GetNormal() const {
    return GetSchemaValue<Vector>(m_ptr, "RnPlane_t", "m_vNormal");
}
void GRnPlane_t::SetNormal(Vector value) {
    SetSchemaValue(m_ptr, "RnPlane_t", "m_vNormal", true, value);
}
float GRnPlane_t::GetOffset() const {
    return GetSchemaValue<float>(m_ptr, "RnPlane_t", "m_flOffset");
}
void GRnPlane_t::SetOffset(float value) {
    SetSchemaValue(m_ptr, "RnPlane_t", "m_flOffset", true, value);
}
std::string GRnPlane_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GRnPlane_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassRnPlane_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GRnPlane_t>("RnPlane_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Normal", &GRnPlane_t::GetNormal, &GRnPlane_t::SetNormal)
        .addProperty("Offset", &GRnPlane_t::GetOffset, &GRnPlane_t::SetOffset)
        .addFunction("ToPtr", &GRnPlane_t::ToPtr)
        .addFunction("IsValid", &GRnPlane_t::IsValid)
        .endClass();
}
GFeNodeWindBase_t::GFeNodeWindBase_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GFeNodeWindBase_t::GFeNodeWindBase_t(void *ptr) {
    m_ptr = ptr;
}
uint16_t GFeNodeWindBase_t::GetNodeX0() const {
    return GetSchemaValue<uint16_t>(m_ptr, "FeNodeWindBase_t", "nNodeX0");
}
void GFeNodeWindBase_t::SetNodeX0(uint16_t value) {
    SetSchemaValue(m_ptr, "FeNodeWindBase_t", "nNodeX0", true, value);
}
uint16_t GFeNodeWindBase_t::GetNodeX1() const {
    return GetSchemaValue<uint16_t>(m_ptr, "FeNodeWindBase_t", "nNodeX1");
}
void GFeNodeWindBase_t::SetNodeX1(uint16_t value) {
    SetSchemaValue(m_ptr, "FeNodeWindBase_t", "nNodeX1", true, value);
}
uint16_t GFeNodeWindBase_t::GetNodeY0() const {
    return GetSchemaValue<uint16_t>(m_ptr, "FeNodeWindBase_t", "nNodeY0");
}
void GFeNodeWindBase_t::SetNodeY0(uint16_t value) {
    SetSchemaValue(m_ptr, "FeNodeWindBase_t", "nNodeY0", true, value);
}
uint16_t GFeNodeWindBase_t::GetNodeY1() const {
    return GetSchemaValue<uint16_t>(m_ptr, "FeNodeWindBase_t", "nNodeY1");
}
void GFeNodeWindBase_t::SetNodeY1(uint16_t value) {
    SetSchemaValue(m_ptr, "FeNodeWindBase_t", "nNodeY1", true, value);
}
std::string GFeNodeWindBase_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GFeNodeWindBase_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassFeNodeWindBase_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GFeNodeWindBase_t>("FeNodeWindBase_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("NodeX0", &GFeNodeWindBase_t::GetNodeX0, &GFeNodeWindBase_t::SetNodeX0)
        .addProperty("NodeX1", &GFeNodeWindBase_t::GetNodeX1, &GFeNodeWindBase_t::SetNodeX1)
        .addProperty("NodeY0", &GFeNodeWindBase_t::GetNodeY0, &GFeNodeWindBase_t::SetNodeY0)
        .addProperty("NodeY1", &GFeNodeWindBase_t::GetNodeY1, &GFeNodeWindBase_t::SetNodeY1)
        .addFunction("ToPtr", &GFeNodeWindBase_t::ToPtr)
        .addFunction("IsValid", &GFeNodeWindBase_t::IsValid)
        .endClass();
}
GCQuaternionAnimParameter::GCQuaternionAnimParameter(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCQuaternionAnimParameter::GCQuaternionAnimParameter(void *ptr) {
    m_ptr = ptr;
}
Quaternion GCQuaternionAnimParameter::GetDefaultValue() const {
    return GetSchemaValue<Quaternion>(m_ptr, "CQuaternionAnimParameter", "m_defaultValue");
}
void GCQuaternionAnimParameter::SetDefaultValue(Quaternion value) {
    SetSchemaValue(m_ptr, "CQuaternionAnimParameter", "m_defaultValue", false, value);
}
bool GCQuaternionAnimParameter::GetInterpolate() const {
    return GetSchemaValue<bool>(m_ptr, "CQuaternionAnimParameter", "m_bInterpolate");
}
void GCQuaternionAnimParameter::SetInterpolate(bool value) {
    SetSchemaValue(m_ptr, "CQuaternionAnimParameter", "m_bInterpolate", false, value);
}
std::string GCQuaternionAnimParameter::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCQuaternionAnimParameter::IsValid() {
    return (m_ptr != nullptr);
}
GCConcreteAnimParameter GCQuaternionAnimParameter::GetParent() const {
    GCConcreteAnimParameter value(m_ptr);
    return value;
}
void GCQuaternionAnimParameter::SetParent(GCConcreteAnimParameter value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCQuaternionAnimParameter(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCQuaternionAnimParameter>("CQuaternionAnimParameter")
        .addConstructor<void (*)(std::string)>()
        .addProperty("DefaultValue", &GCQuaternionAnimParameter::GetDefaultValue, &GCQuaternionAnimParameter::SetDefaultValue)
        .addProperty("Interpolate", &GCQuaternionAnimParameter::GetInterpolate, &GCQuaternionAnimParameter::SetInterpolate)
        .addProperty("Parent", &GCQuaternionAnimParameter::GetParent, &GCQuaternionAnimParameter::SetParent)
        .addFunction("ToPtr", &GCQuaternionAnimParameter::ToPtr)
        .addFunction("IsValid", &GCQuaternionAnimParameter::IsValid)
        .endClass();
}
GSkeletonAnimCapture_t__Camera_t::GSkeletonAnimCapture_t__Camera_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GSkeletonAnimCapture_t__Camera_t::GSkeletonAnimCapture_t__Camera_t(void *ptr) {
    m_ptr = ptr;
}
float GSkeletonAnimCapture_t__Camera_t::GetTime() const {
    return GetSchemaValue<float>(m_ptr, "SkeletonAnimCapture_t__Camera_t", "m_flTime");
}
void GSkeletonAnimCapture_t__Camera_t::SetTime(float value) {
    SetSchemaValue(m_ptr, "SkeletonAnimCapture_t__Camera_t", "m_flTime", true, value);
}
std::string GSkeletonAnimCapture_t__Camera_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GSkeletonAnimCapture_t__Camera_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassSkeletonAnimCapture_t__Camera_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GSkeletonAnimCapture_t__Camera_t>("SkeletonAnimCapture_t__Camera_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Time", &GSkeletonAnimCapture_t__Camera_t::GetTime, &GSkeletonAnimCapture_t__Camera_t::SetTime)
        .addFunction("ToPtr", &GSkeletonAnimCapture_t__Camera_t::ToPtr)
        .addFunction("IsValid", &GSkeletonAnimCapture_t__Camera_t::IsValid)
        .endClass();
}
GCAnimEncodeDifference::GCAnimEncodeDifference(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCAnimEncodeDifference::GCAnimEncodeDifference(void *ptr) {
    m_ptr = ptr;
}
std::vector<GCAnimBoneDifference> GCAnimEncodeDifference::GetBoneArray() const {
    CUtlVector<GCAnimBoneDifference>* vec = GetSchemaValue<CUtlVector<GCAnimBoneDifference>*>(m_ptr, "CAnimEncodeDifference", "m_boneArray"); std::vector<GCAnimBoneDifference> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCAnimEncodeDifference::SetBoneArray(std::vector<GCAnimBoneDifference> value) {
    SetSchemaValueCUtlVector<GCAnimBoneDifference>(m_ptr, "CAnimEncodeDifference", "m_boneArray", false, value);
}
std::vector<GCAnimMorphDifference> GCAnimEncodeDifference::GetMorphArray() const {
    CUtlVector<GCAnimMorphDifference>* vec = GetSchemaValue<CUtlVector<GCAnimMorphDifference>*>(m_ptr, "CAnimEncodeDifference", "m_morphArray"); std::vector<GCAnimMorphDifference> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCAnimEncodeDifference::SetMorphArray(std::vector<GCAnimMorphDifference> value) {
    SetSchemaValueCUtlVector<GCAnimMorphDifference>(m_ptr, "CAnimEncodeDifference", "m_morphArray", false, value);
}
std::vector<GCAnimUserDifference> GCAnimEncodeDifference::GetUserArray() const {
    CUtlVector<GCAnimUserDifference>* vec = GetSchemaValue<CUtlVector<GCAnimUserDifference>*>(m_ptr, "CAnimEncodeDifference", "m_userArray"); std::vector<GCAnimUserDifference> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCAnimEncodeDifference::SetUserArray(std::vector<GCAnimUserDifference> value) {
    SetSchemaValueCUtlVector<GCAnimUserDifference>(m_ptr, "CAnimEncodeDifference", "m_userArray", false, value);
}
std::vector<uint8> GCAnimEncodeDifference::GetHasRotationBitArray() const {
    CUtlVector<uint8>* vec = GetSchemaValue<CUtlVector<uint8>*>(m_ptr, "CAnimEncodeDifference", "m_bHasRotationBitArray"); std::vector<uint8> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCAnimEncodeDifference::SetHasRotationBitArray(std::vector<uint8> value) {
    SetSchemaValueCUtlVector<uint8>(m_ptr, "CAnimEncodeDifference", "m_bHasRotationBitArray", false, value);
}
std::vector<uint8> GCAnimEncodeDifference::GetHasMovementBitArray() const {
    CUtlVector<uint8>* vec = GetSchemaValue<CUtlVector<uint8>*>(m_ptr, "CAnimEncodeDifference", "m_bHasMovementBitArray"); std::vector<uint8> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCAnimEncodeDifference::SetHasMovementBitArray(std::vector<uint8> value) {
    SetSchemaValueCUtlVector<uint8>(m_ptr, "CAnimEncodeDifference", "m_bHasMovementBitArray", false, value);
}
std::vector<uint8> GCAnimEncodeDifference::GetHasMorphBitArray() const {
    CUtlVector<uint8>* vec = GetSchemaValue<CUtlVector<uint8>*>(m_ptr, "CAnimEncodeDifference", "m_bHasMorphBitArray"); std::vector<uint8> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCAnimEncodeDifference::SetHasMorphBitArray(std::vector<uint8> value) {
    SetSchemaValueCUtlVector<uint8>(m_ptr, "CAnimEncodeDifference", "m_bHasMorphBitArray", false, value);
}
std::vector<uint8> GCAnimEncodeDifference::GetHasUserBitArray() const {
    CUtlVector<uint8>* vec = GetSchemaValue<CUtlVector<uint8>*>(m_ptr, "CAnimEncodeDifference", "m_bHasUserBitArray"); std::vector<uint8> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCAnimEncodeDifference::SetHasUserBitArray(std::vector<uint8> value) {
    SetSchemaValueCUtlVector<uint8>(m_ptr, "CAnimEncodeDifference", "m_bHasUserBitArray", false, value);
}
std::string GCAnimEncodeDifference::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCAnimEncodeDifference::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCAnimEncodeDifference(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCAnimEncodeDifference>("CAnimEncodeDifference")
        .addConstructor<void (*)(std::string)>()
        .addProperty("BoneArray", &GCAnimEncodeDifference::GetBoneArray, &GCAnimEncodeDifference::SetBoneArray)
        .addProperty("MorphArray", &GCAnimEncodeDifference::GetMorphArray, &GCAnimEncodeDifference::SetMorphArray)
        .addProperty("UserArray", &GCAnimEncodeDifference::GetUserArray, &GCAnimEncodeDifference::SetUserArray)
        .addProperty("HasRotationBitArray", &GCAnimEncodeDifference::GetHasRotationBitArray, &GCAnimEncodeDifference::SetHasRotationBitArray)
        .addProperty("HasMovementBitArray", &GCAnimEncodeDifference::GetHasMovementBitArray, &GCAnimEncodeDifference::SetHasMovementBitArray)
        .addProperty("HasMorphBitArray", &GCAnimEncodeDifference::GetHasMorphBitArray, &GCAnimEncodeDifference::SetHasMorphBitArray)
        .addProperty("HasUserBitArray", &GCAnimEncodeDifference::GetHasUserBitArray, &GCAnimEncodeDifference::SetHasUserBitArray)
        .addFunction("ToPtr", &GCAnimEncodeDifference::ToPtr)
        .addFunction("IsValid", &GCAnimEncodeDifference::IsValid)
        .endClass();
}
GAggregateSceneObject_t::GAggregateSceneObject_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GAggregateSceneObject_t::GAggregateSceneObject_t(void *ptr) {
    m_ptr = ptr;
}
uint64_t GAggregateSceneObject_t::GetAllFlags() const {
    return GetSchemaValue<uint64_t>(m_ptr, "AggregateSceneObject_t", "m_allFlags");
}
void GAggregateSceneObject_t::SetAllFlags(uint64_t value) {
    SetSchemaValue(m_ptr, "AggregateSceneObject_t", "m_allFlags", true, value);
}
uint64_t GAggregateSceneObject_t::GetAnyFlags() const {
    return GetSchemaValue<uint64_t>(m_ptr, "AggregateSceneObject_t", "m_anyFlags");
}
void GAggregateSceneObject_t::SetAnyFlags(uint64_t value) {
    SetSchemaValue(m_ptr, "AggregateSceneObject_t", "m_anyFlags", true, value);
}
int16_t GAggregateSceneObject_t::GetLayer() const {
    return GetSchemaValue<int16_t>(m_ptr, "AggregateSceneObject_t", "m_nLayer");
}
void GAggregateSceneObject_t::SetLayer(int16_t value) {
    SetSchemaValue(m_ptr, "AggregateSceneObject_t", "m_nLayer", true, value);
}
std::vector<GAggregateMeshInfo_t> GAggregateSceneObject_t::GetAggregateMeshes() const {
    CUtlVector<GAggregateMeshInfo_t>* vec = GetSchemaValue<CUtlVector<GAggregateMeshInfo_t>*>(m_ptr, "AggregateSceneObject_t", "m_aggregateMeshes"); std::vector<GAggregateMeshInfo_t> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GAggregateSceneObject_t::SetAggregateMeshes(std::vector<GAggregateMeshInfo_t> value) {
    SetSchemaValueCUtlVector<GAggregateMeshInfo_t>(m_ptr, "AggregateSceneObject_t", "m_aggregateMeshes", true, value);
}
std::vector<GAggregateLODSetup_t> GAggregateSceneObject_t::GetLodSetups() const {
    CUtlVector<GAggregateLODSetup_t>* vec = GetSchemaValue<CUtlVector<GAggregateLODSetup_t>*>(m_ptr, "AggregateSceneObject_t", "m_lodSetups"); std::vector<GAggregateLODSetup_t> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GAggregateSceneObject_t::SetLodSetups(std::vector<GAggregateLODSetup_t> value) {
    SetSchemaValueCUtlVector<GAggregateLODSetup_t>(m_ptr, "AggregateSceneObject_t", "m_lodSetups", true, value);
}
std::vector<uint16> GAggregateSceneObject_t::GetVisClusterMembership() const {
    CUtlVector<uint16>* vec = GetSchemaValue<CUtlVector<uint16>*>(m_ptr, "AggregateSceneObject_t", "m_visClusterMembership"); std::vector<uint16> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GAggregateSceneObject_t::SetVisClusterMembership(std::vector<uint16> value) {
    SetSchemaValueCUtlVector<uint16>(m_ptr, "AggregateSceneObject_t", "m_visClusterMembership", true, value);
}
std::vector<matrix3x4_t> GAggregateSceneObject_t::GetFragmentTransforms() const {
    CUtlVector<matrix3x4_t>* vec = GetSchemaValue<CUtlVector<matrix3x4_t>*>(m_ptr, "AggregateSceneObject_t", "m_fragmentTransforms"); std::vector<matrix3x4_t> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GAggregateSceneObject_t::SetFragmentTransforms(std::vector<matrix3x4_t> value) {
    SetSchemaValueCUtlVector<matrix3x4_t>(m_ptr, "AggregateSceneObject_t", "m_fragmentTransforms", true, value);
}
std::string GAggregateSceneObject_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GAggregateSceneObject_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassAggregateSceneObject_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GAggregateSceneObject_t>("AggregateSceneObject_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("AllFlags", &GAggregateSceneObject_t::GetAllFlags, &GAggregateSceneObject_t::SetAllFlags)
        .addProperty("AnyFlags", &GAggregateSceneObject_t::GetAnyFlags, &GAggregateSceneObject_t::SetAnyFlags)
        .addProperty("Layer", &GAggregateSceneObject_t::GetLayer, &GAggregateSceneObject_t::SetLayer)
        .addProperty("AggregateMeshes", &GAggregateSceneObject_t::GetAggregateMeshes, &GAggregateSceneObject_t::SetAggregateMeshes)
        .addProperty("LodSetups", &GAggregateSceneObject_t::GetLodSetups, &GAggregateSceneObject_t::SetLodSetups)
        .addProperty("VisClusterMembership", &GAggregateSceneObject_t::GetVisClusterMembership, &GAggregateSceneObject_t::SetVisClusterMembership)
        .addProperty("FragmentTransforms", &GAggregateSceneObject_t::GetFragmentTransforms, &GAggregateSceneObject_t::SetFragmentTransforms)
        .addFunction("ToPtr", &GAggregateSceneObject_t::ToPtr)
        .addFunction("IsValid", &GAggregateSceneObject_t::IsValid)
        .endClass();
}
GIKDemoCaptureSettings_t::GIKDemoCaptureSettings_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GIKDemoCaptureSettings_t::GIKDemoCaptureSettings_t(void *ptr) {
    m_ptr = ptr;
}
std::string GIKDemoCaptureSettings_t::GetParentBoneName() const {
    return GetSchemaValue<CUtlString>(m_ptr, "IKDemoCaptureSettings_t", "m_parentBoneName").Get();
}
void GIKDemoCaptureSettings_t::SetParentBoneName(std::string value) {
    SetSchemaValue(m_ptr, "IKDemoCaptureSettings_t", "m_parentBoneName", true, CUtlString(value.c_str()));
}
uint64_t GIKDemoCaptureSettings_t::GetMode() const {
    return GetSchemaValue<uint64_t>(m_ptr, "IKDemoCaptureSettings_t", "m_eMode");
}
void GIKDemoCaptureSettings_t::SetMode(uint64_t value) {
    SetSchemaValue(m_ptr, "IKDemoCaptureSettings_t", "m_eMode", true, value);
}
std::string GIKDemoCaptureSettings_t::GetIkChainName() const {
    return GetSchemaValue<CUtlString>(m_ptr, "IKDemoCaptureSettings_t", "m_ikChainName").Get();
}
void GIKDemoCaptureSettings_t::SetIkChainName(std::string value) {
    SetSchemaValue(m_ptr, "IKDemoCaptureSettings_t", "m_ikChainName", true, CUtlString(value.c_str()));
}
std::string GIKDemoCaptureSettings_t::GetOneBoneStart() const {
    return GetSchemaValue<CUtlString>(m_ptr, "IKDemoCaptureSettings_t", "m_oneBoneStart").Get();
}
void GIKDemoCaptureSettings_t::SetOneBoneStart(std::string value) {
    SetSchemaValue(m_ptr, "IKDemoCaptureSettings_t", "m_oneBoneStart", true, CUtlString(value.c_str()));
}
std::string GIKDemoCaptureSettings_t::GetOneBoneEnd() const {
    return GetSchemaValue<CUtlString>(m_ptr, "IKDemoCaptureSettings_t", "m_oneBoneEnd").Get();
}
void GIKDemoCaptureSettings_t::SetOneBoneEnd(std::string value) {
    SetSchemaValue(m_ptr, "IKDemoCaptureSettings_t", "m_oneBoneEnd", true, CUtlString(value.c_str()));
}
std::string GIKDemoCaptureSettings_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GIKDemoCaptureSettings_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassIKDemoCaptureSettings_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GIKDemoCaptureSettings_t>("IKDemoCaptureSettings_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("ParentBoneName", &GIKDemoCaptureSettings_t::GetParentBoneName, &GIKDemoCaptureSettings_t::SetParentBoneName)
        .addProperty("Mode", &GIKDemoCaptureSettings_t::GetMode, &GIKDemoCaptureSettings_t::SetMode)
        .addProperty("IkChainName", &GIKDemoCaptureSettings_t::GetIkChainName, &GIKDemoCaptureSettings_t::SetIkChainName)
        .addProperty("OneBoneStart", &GIKDemoCaptureSettings_t::GetOneBoneStart, &GIKDemoCaptureSettings_t::SetOneBoneStart)
        .addProperty("OneBoneEnd", &GIKDemoCaptureSettings_t::GetOneBoneEnd, &GIKDemoCaptureSettings_t::SetOneBoneEnd)
        .addFunction("ToPtr", &GIKDemoCaptureSettings_t::ToPtr)
        .addFunction("IsValid", &GIKDemoCaptureSettings_t::IsValid)
        .endClass();
}
GCParticleCollectionBindingInstance::GCParticleCollectionBindingInstance(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCParticleCollectionBindingInstance::GCParticleCollectionBindingInstance(void *ptr) {
    m_ptr = ptr;
}
std::string GCParticleCollectionBindingInstance::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCParticleCollectionBindingInstance::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCParticleCollectionBindingInstance(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCParticleCollectionBindingInstance>("CParticleCollectionBindingInstance")
        .addConstructor<void (*)(std::string)>()
        .addFunction("ToPtr", &GCParticleCollectionBindingInstance::ToPtr)
        .addFunction("IsValid", &GCParticleCollectionBindingInstance::IsValid)
        .endClass();
}
GCVoiceContainerDefault::GCVoiceContainerDefault(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCVoiceContainerDefault::GCVoiceContainerDefault(void *ptr) {
    m_ptr = ptr;
}
std::string GCVoiceContainerDefault::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCVoiceContainerDefault::IsValid() {
    return (m_ptr != nullptr);
}
GCVoiceContainerBase GCVoiceContainerDefault::GetParent() const {
    GCVoiceContainerBase value(m_ptr);
    return value;
}
void GCVoiceContainerDefault::SetParent(GCVoiceContainerBase value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCVoiceContainerDefault(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCVoiceContainerDefault>("CVoiceContainerDefault")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCVoiceContainerDefault::GetParent, &GCVoiceContainerDefault::SetParent)
        .addFunction("ToPtr", &GCVoiceContainerDefault::ToPtr)
        .addFunction("IsValid", &GCVoiceContainerDefault::IsValid)
        .endClass();
}
GCSoundEventMetaData::GCSoundEventMetaData(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCSoundEventMetaData::GCSoundEventMetaData(void *ptr) {
    m_ptr = ptr;
}
std::string GCSoundEventMetaData::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCSoundEventMetaData::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCSoundEventMetaData(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCSoundEventMetaData>("CSoundEventMetaData")
        .addConstructor<void (*)(std::string)>()
        .addFunction("ToPtr", &GCSoundEventMetaData::ToPtr)
        .addFunction("IsValid", &GCSoundEventMetaData::IsValid)
        .endClass();
}
GCMorphConstraint::GCMorphConstraint(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCMorphConstraint::GCMorphConstraint(void *ptr) {
    m_ptr = ptr;
}
std::string GCMorphConstraint::GetTargetMorph() const {
    return GetSchemaValue<CUtlString>(m_ptr, "CMorphConstraint", "m_sTargetMorph").Get();
}
void GCMorphConstraint::SetTargetMorph(std::string value) {
    SetSchemaValue(m_ptr, "CMorphConstraint", "m_sTargetMorph", false, CUtlString(value.c_str()));
}
int32_t GCMorphConstraint::GetSlaveChannel() const {
    return GetSchemaValue<int32_t>(m_ptr, "CMorphConstraint", "m_nSlaveChannel");
}
void GCMorphConstraint::SetSlaveChannel(int32_t value) {
    SetSchemaValue(m_ptr, "CMorphConstraint", "m_nSlaveChannel", false, value);
}
float GCMorphConstraint::GetMin() const {
    return GetSchemaValue<float>(m_ptr, "CMorphConstraint", "m_flMin");
}
void GCMorphConstraint::SetMin(float value) {
    SetSchemaValue(m_ptr, "CMorphConstraint", "m_flMin", false, value);
}
float GCMorphConstraint::GetMax() const {
    return GetSchemaValue<float>(m_ptr, "CMorphConstraint", "m_flMax");
}
void GCMorphConstraint::SetMax(float value) {
    SetSchemaValue(m_ptr, "CMorphConstraint", "m_flMax", false, value);
}
std::string GCMorphConstraint::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCMorphConstraint::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseConstraint GCMorphConstraint::GetParent() const {
    GCBaseConstraint value(m_ptr);
    return value;
}
void GCMorphConstraint::SetParent(GCBaseConstraint value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCMorphConstraint(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCMorphConstraint>("CMorphConstraint")
        .addConstructor<void (*)(std::string)>()
        .addProperty("TargetMorph", &GCMorphConstraint::GetTargetMorph, &GCMorphConstraint::SetTargetMorph)
        .addProperty("SlaveChannel", &GCMorphConstraint::GetSlaveChannel, &GCMorphConstraint::SetSlaveChannel)
        .addProperty("Min", &GCMorphConstraint::GetMin, &GCMorphConstraint::SetMin)
        .addProperty("Max", &GCMorphConstraint::GetMax, &GCMorphConstraint::SetMax)
        .addProperty("Parent", &GCMorphConstraint::GetParent, &GCMorphConstraint::SetParent)
        .addFunction("ToPtr", &GCMorphConstraint::ToPtr)
        .addFunction("IsValid", &GCMorphConstraint::IsValid)
        .endClass();
}
GDop26_t::GDop26_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GDop26_t::GDop26_t(void *ptr) {
    m_ptr = ptr;
}
std::vector<float> GDop26_t::GetSupport() const {
    float* outValue = GetSchemaValue<float*>(m_ptr, "Dop26_t", "m_flSupport"); std::vector<float> ret; for(int i = 0; i < 26; i++) { ret.push_back(outValue[i]); } return ret;
}
void GDop26_t::SetSupport(std::vector<float> value) {
    float* outValue = GetSchemaValue<float*>(m_ptr, "Dop26_t", "m_flSupport"); for(int i = 0; i < 26; i++) { outValue[i] = value[i]; } SetSchemaValue(m_ptr, "Dop26_t", "m_flSupport", true, outValue);
}
std::string GDop26_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GDop26_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassDop26_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GDop26_t>("Dop26_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Support", &GDop26_t::GetSupport, &GDop26_t::SetSupport)
        .addFunction("ToPtr", &GDop26_t::ToPtr)
        .addFunction("IsValid", &GDop26_t::IsValid)
        .endClass();
}
GCAnimGraphModelBinding::GCAnimGraphModelBinding(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCAnimGraphModelBinding::GCAnimGraphModelBinding(void *ptr) {
    m_ptr = ptr;
}
std::string GCAnimGraphModelBinding::GetModelName() const {
    return GetSchemaValue<CUtlString>(m_ptr, "CAnimGraphModelBinding", "m_modelName").Get();
}
void GCAnimGraphModelBinding::SetModelName(std::string value) {
    SetSchemaValue(m_ptr, "CAnimGraphModelBinding", "m_modelName", false, CUtlString(value.c_str()));
}
std::string GCAnimGraphModelBinding::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCAnimGraphModelBinding::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCAnimGraphModelBinding(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCAnimGraphModelBinding>("CAnimGraphModelBinding")
        .addConstructor<void (*)(std::string)>()
        .addProperty("ModelName", &GCAnimGraphModelBinding::GetModelName, &GCAnimGraphModelBinding::SetModelName)
        .addFunction("ToPtr", &GCAnimGraphModelBinding::ToPtr)
        .addFunction("IsValid", &GCAnimGraphModelBinding::IsValid)
        .endClass();
}
GFakeEntityDerivedA_tAPI::GFakeEntityDerivedA_tAPI(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GFakeEntityDerivedA_tAPI::GFakeEntityDerivedA_tAPI(void *ptr) {
    m_ptr = ptr;
}
std::string GFakeEntityDerivedA_tAPI::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GFakeEntityDerivedA_tAPI::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassFakeEntityDerivedA_tAPI(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GFakeEntityDerivedA_tAPI>("FakeEntityDerivedA_tAPI")
        .addConstructor<void (*)(std::string)>()
        .addFunction("ToPtr", &GFakeEntityDerivedA_tAPI::ToPtr)
        .addFunction("IsValid", &GFakeEntityDerivedA_tAPI::IsValid)
        .endClass();
}
GCAnimParamHandleMap::GCAnimParamHandleMap(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCAnimParamHandleMap::GCAnimParamHandleMap(void *ptr) {
    m_ptr = ptr;
}
std::string GCAnimParamHandleMap::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCAnimParamHandleMap::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCAnimParamHandleMap(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCAnimParamHandleMap>("CAnimParamHandleMap")
        .addConstructor<void (*)(std::string)>()
        .addFunction("ToPtr", &GCAnimParamHandleMap::ToPtr)
        .addFunction("IsValid", &GCAnimParamHandleMap::IsValid)
        .endClass();
}
GFeMorphLayerDepr_t::GFeMorphLayerDepr_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GFeMorphLayerDepr_t::GFeMorphLayerDepr_t(void *ptr) {
    m_ptr = ptr;
}
std::string GFeMorphLayerDepr_t::GetName() const {
    return GetSchemaValue<CUtlString>(m_ptr, "FeMorphLayerDepr_t", "m_Name").Get();
}
void GFeMorphLayerDepr_t::SetName(std::string value) {
    SetSchemaValue(m_ptr, "FeMorphLayerDepr_t", "m_Name", true, CUtlString(value.c_str()));
}
uint32_t GFeMorphLayerDepr_t::GetNameHash() const {
    return GetSchemaValue<uint32_t>(m_ptr, "FeMorphLayerDepr_t", "m_nNameHash");
}
void GFeMorphLayerDepr_t::SetNameHash(uint32_t value) {
    SetSchemaValue(m_ptr, "FeMorphLayerDepr_t", "m_nNameHash", true, value);
}
std::vector<uint16> GFeMorphLayerDepr_t::GetNodes() const {
    CUtlVector<uint16>* vec = GetSchemaValue<CUtlVector<uint16>*>(m_ptr, "FeMorphLayerDepr_t", "m_Nodes"); std::vector<uint16> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GFeMorphLayerDepr_t::SetNodes(std::vector<uint16> value) {
    SetSchemaValueCUtlVector<uint16>(m_ptr, "FeMorphLayerDepr_t", "m_Nodes", true, value);
}
std::vector<Vector> GFeMorphLayerDepr_t::GetInitPos() const {
    CUtlVector<Vector>* vec = GetSchemaValue<CUtlVector<Vector>*>(m_ptr, "FeMorphLayerDepr_t", "m_InitPos"); std::vector<Vector> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GFeMorphLayerDepr_t::SetInitPos(std::vector<Vector> value) {
    SetSchemaValueCUtlVector<Vector>(m_ptr, "FeMorphLayerDepr_t", "m_InitPos", true, value);
}
std::vector<float32> GFeMorphLayerDepr_t::GetGravity() const {
    CUtlVector<float32>* vec = GetSchemaValue<CUtlVector<float32>*>(m_ptr, "FeMorphLayerDepr_t", "m_Gravity"); std::vector<float32> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GFeMorphLayerDepr_t::SetGravity(std::vector<float32> value) {
    SetSchemaValueCUtlVector<float32>(m_ptr, "FeMorphLayerDepr_t", "m_Gravity", true, value);
}
std::vector<float32> GFeMorphLayerDepr_t::GetGoalStrength() const {
    CUtlVector<float32>* vec = GetSchemaValue<CUtlVector<float32>*>(m_ptr, "FeMorphLayerDepr_t", "m_GoalStrength"); std::vector<float32> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GFeMorphLayerDepr_t::SetGoalStrength(std::vector<float32> value) {
    SetSchemaValueCUtlVector<float32>(m_ptr, "FeMorphLayerDepr_t", "m_GoalStrength", true, value);
}
std::vector<float32> GFeMorphLayerDepr_t::GetGoalDamping() const {
    CUtlVector<float32>* vec = GetSchemaValue<CUtlVector<float32>*>(m_ptr, "FeMorphLayerDepr_t", "m_GoalDamping"); std::vector<float32> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GFeMorphLayerDepr_t::SetGoalDamping(std::vector<float32> value) {
    SetSchemaValueCUtlVector<float32>(m_ptr, "FeMorphLayerDepr_t", "m_GoalDamping", true, value);
}
uint32_t GFeMorphLayerDepr_t::GetFlags() const {
    return GetSchemaValue<uint32_t>(m_ptr, "FeMorphLayerDepr_t", "m_nFlags");
}
void GFeMorphLayerDepr_t::SetFlags(uint32_t value) {
    SetSchemaValue(m_ptr, "FeMorphLayerDepr_t", "m_nFlags", true, value);
}
std::string GFeMorphLayerDepr_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GFeMorphLayerDepr_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassFeMorphLayerDepr_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GFeMorphLayerDepr_t>("FeMorphLayerDepr_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Name", &GFeMorphLayerDepr_t::GetName, &GFeMorphLayerDepr_t::SetName)
        .addProperty("NameHash", &GFeMorphLayerDepr_t::GetNameHash, &GFeMorphLayerDepr_t::SetNameHash)
        .addProperty("Nodes", &GFeMorphLayerDepr_t::GetNodes, &GFeMorphLayerDepr_t::SetNodes)
        .addProperty("InitPos", &GFeMorphLayerDepr_t::GetInitPos, &GFeMorphLayerDepr_t::SetInitPos)
        .addProperty("Gravity", &GFeMorphLayerDepr_t::GetGravity, &GFeMorphLayerDepr_t::SetGravity)
        .addProperty("GoalStrength", &GFeMorphLayerDepr_t::GetGoalStrength, &GFeMorphLayerDepr_t::SetGoalStrength)
        .addProperty("GoalDamping", &GFeMorphLayerDepr_t::GetGoalDamping, &GFeMorphLayerDepr_t::SetGoalDamping)
        .addProperty("Flags", &GFeMorphLayerDepr_t::GetFlags, &GFeMorphLayerDepr_t::SetFlags)
        .addFunction("ToPtr", &GFeMorphLayerDepr_t::ToPtr)
        .addFunction("IsValid", &GFeMorphLayerDepr_t::IsValid)
        .endClass();
}
GFourCovMatrices3::GFourCovMatrices3(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GFourCovMatrices3::GFourCovMatrices3(void *ptr) {
    m_ptr = ptr;
}
float GFourCovMatrices3::GetXY() const {
    return GetSchemaValue<float>(m_ptr, "FourCovMatrices3", "m_flXY");
}
void GFourCovMatrices3::SetXY(float value) {
    SetSchemaValue(m_ptr, "FourCovMatrices3", "m_flXY", false, value);
}
float GFourCovMatrices3::GetXZ() const {
    return GetSchemaValue<float>(m_ptr, "FourCovMatrices3", "m_flXZ");
}
void GFourCovMatrices3::SetXZ(float value) {
    SetSchemaValue(m_ptr, "FourCovMatrices3", "m_flXZ", false, value);
}
float GFourCovMatrices3::GetYZ() const {
    return GetSchemaValue<float>(m_ptr, "FourCovMatrices3", "m_flYZ");
}
void GFourCovMatrices3::SetYZ(float value) {
    SetSchemaValue(m_ptr, "FourCovMatrices3", "m_flYZ", false, value);
}
std::string GFourCovMatrices3::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GFourCovMatrices3::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassFourCovMatrices3(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GFourCovMatrices3>("FourCovMatrices3")
        .addConstructor<void (*)(std::string)>()
        .addProperty("XY", &GFourCovMatrices3::GetXY, &GFourCovMatrices3::SetXY)
        .addProperty("XZ", &GFourCovMatrices3::GetXZ, &GFourCovMatrices3::SetXZ)
        .addProperty("YZ", &GFourCovMatrices3::GetYZ, &GFourCovMatrices3::SetYZ)
        .addFunction("ToPtr", &GFourCovMatrices3::ToPtr)
        .addFunction("IsValid", &GFourCovMatrices3::IsValid)
        .endClass();
}
GFeFitMatrix_t::GFeFitMatrix_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GFeFitMatrix_t::GFeFitMatrix_t(void *ptr) {
    m_ptr = ptr;
}
Vector GFeFitMatrix_t::GetCenter() const {
    return GetSchemaValue<Vector>(m_ptr, "FeFitMatrix_t", "vCenter");
}
void GFeFitMatrix_t::SetCenter(Vector value) {
    SetSchemaValue(m_ptr, "FeFitMatrix_t", "vCenter", true, value);
}
uint16_t GFeFitMatrix_t::GetEnd() const {
    return GetSchemaValue<uint16_t>(m_ptr, "FeFitMatrix_t", "nEnd");
}
void GFeFitMatrix_t::SetEnd(uint16_t value) {
    SetSchemaValue(m_ptr, "FeFitMatrix_t", "nEnd", true, value);
}
uint16_t GFeFitMatrix_t::GetNode() const {
    return GetSchemaValue<uint16_t>(m_ptr, "FeFitMatrix_t", "nNode");
}
void GFeFitMatrix_t::SetNode(uint16_t value) {
    SetSchemaValue(m_ptr, "FeFitMatrix_t", "nNode", true, value);
}
uint16_t GFeFitMatrix_t::GetBeginDynamic() const {
    return GetSchemaValue<uint16_t>(m_ptr, "FeFitMatrix_t", "nBeginDynamic");
}
void GFeFitMatrix_t::SetBeginDynamic(uint16_t value) {
    SetSchemaValue(m_ptr, "FeFitMatrix_t", "nBeginDynamic", true, value);
}
std::string GFeFitMatrix_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GFeFitMatrix_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassFeFitMatrix_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GFeFitMatrix_t>("FeFitMatrix_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Center", &GFeFitMatrix_t::GetCenter, &GFeFitMatrix_t::SetCenter)
        .addProperty("End", &GFeFitMatrix_t::GetEnd, &GFeFitMatrix_t::SetEnd)
        .addProperty("Node", &GFeFitMatrix_t::GetNode, &GFeFitMatrix_t::SetNode)
        .addProperty("BeginDynamic", &GFeFitMatrix_t::GetBeginDynamic, &GFeFitMatrix_t::SetBeginDynamic)
        .addFunction("ToPtr", &GFeFitMatrix_t::ToPtr)
        .addFunction("IsValid", &GFeFitMatrix_t::IsValid)
        .endClass();
}
GRnVertex_t::GRnVertex_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GRnVertex_t::GRnVertex_t(void *ptr) {
    m_ptr = ptr;
}
uint8_t GRnVertex_t::GetEdge() const {
    return GetSchemaValue<uint8_t>(m_ptr, "RnVertex_t", "m_nEdge");
}
void GRnVertex_t::SetEdge(uint8_t value) {
    SetSchemaValue(m_ptr, "RnVertex_t", "m_nEdge", true, value);
}
std::string GRnVertex_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GRnVertex_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassRnVertex_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GRnVertex_t>("RnVertex_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Edge", &GRnVertex_t::GetEdge, &GRnVertex_t::SetEdge)
        .addFunction("ToPtr", &GRnVertex_t::ToPtr)
        .addFunction("IsValid", &GRnVertex_t::IsValid)
        .endClass();
}
GTraceSettings_t::GTraceSettings_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GTraceSettings_t::GTraceSettings_t(void *ptr) {
    m_ptr = ptr;
}
float GTraceSettings_t::GetTraceHeight() const {
    return GetSchemaValue<float>(m_ptr, "TraceSettings_t", "m_flTraceHeight");
}
void GTraceSettings_t::SetTraceHeight(float value) {
    SetSchemaValue(m_ptr, "TraceSettings_t", "m_flTraceHeight", true, value);
}
float GTraceSettings_t::GetTraceRadius() const {
    return GetSchemaValue<float>(m_ptr, "TraceSettings_t", "m_flTraceRadius");
}
void GTraceSettings_t::SetTraceRadius(float value) {
    SetSchemaValue(m_ptr, "TraceSettings_t", "m_flTraceRadius", true, value);
}
std::string GTraceSettings_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GTraceSettings_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassTraceSettings_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GTraceSettings_t>("TraceSettings_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("TraceHeight", &GTraceSettings_t::GetTraceHeight, &GTraceSettings_t::SetTraceHeight)
        .addProperty("TraceRadius", &GTraceSettings_t::GetTraceRadius, &GTraceSettings_t::SetTraceRadius)
        .addFunction("ToPtr", &GTraceSettings_t::ToPtr)
        .addFunction("IsValid", &GTraceSettings_t::IsValid)
        .endClass();
}
GCConstraintTarget::GCConstraintTarget(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCConstraintTarget::GCConstraintTarget(void *ptr) {
    m_ptr = ptr;
}
Quaternion GCConstraintTarget::GetOffset() const {
    return GetSchemaValue<Quaternion>(m_ptr, "CConstraintTarget", "m_qOffset");
}
void GCConstraintTarget::SetOffset(Quaternion value) {
    SetSchemaValue(m_ptr, "CConstraintTarget", "m_qOffset", false, value);
}
Vector GCConstraintTarget::GetOffset1() const {
    return GetSchemaValue<Vector>(m_ptr, "CConstraintTarget", "m_vOffset");
}
void GCConstraintTarget::SetOffset1(Vector value) {
    SetSchemaValue(m_ptr, "CConstraintTarget", "m_vOffset", false, value);
}
uint32_t GCConstraintTarget::GetBoneHash() const {
    return GetSchemaValue<uint32_t>(m_ptr, "CConstraintTarget", "m_nBoneHash");
}
void GCConstraintTarget::SetBoneHash(uint32_t value) {
    SetSchemaValue(m_ptr, "CConstraintTarget", "m_nBoneHash", false, value);
}
std::string GCConstraintTarget::GetName() const {
    return GetSchemaValue<CUtlString>(m_ptr, "CConstraintTarget", "m_sName").Get();
}
void GCConstraintTarget::SetName(std::string value) {
    SetSchemaValue(m_ptr, "CConstraintTarget", "m_sName", false, CUtlString(value.c_str()));
}
float GCConstraintTarget::GetWeight() const {
    return GetSchemaValue<float>(m_ptr, "CConstraintTarget", "m_flWeight");
}
void GCConstraintTarget::SetWeight(float value) {
    SetSchemaValue(m_ptr, "CConstraintTarget", "m_flWeight", false, value);
}
bool GCConstraintTarget::GetIsAttachment() const {
    return GetSchemaValue<bool>(m_ptr, "CConstraintTarget", "m_bIsAttachment");
}
void GCConstraintTarget::SetIsAttachment(bool value) {
    SetSchemaValue(m_ptr, "CConstraintTarget", "m_bIsAttachment", false, value);
}
std::string GCConstraintTarget::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCConstraintTarget::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCConstraintTarget(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCConstraintTarget>("CConstraintTarget")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Offset", &GCConstraintTarget::GetOffset, &GCConstraintTarget::SetOffset)
        .addProperty("Offset1", &GCConstraintTarget::GetOffset1, &GCConstraintTarget::SetOffset1)
        .addProperty("BoneHash", &GCConstraintTarget::GetBoneHash, &GCConstraintTarget::SetBoneHash)
        .addProperty("Name", &GCConstraintTarget::GetName, &GCConstraintTarget::SetName)
        .addProperty("Weight", &GCConstraintTarget::GetWeight, &GCConstraintTarget::SetWeight)
        .addProperty("IsAttachment", &GCConstraintTarget::GetIsAttachment, &GCConstraintTarget::SetIsAttachment)
        .addFunction("ToPtr", &GCConstraintTarget::ToPtr)
        .addFunction("IsValid", &GCConstraintTarget::IsValid)
        .endClass();
}
GCompMatPropertyMutator_t::GCompMatPropertyMutator_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCompMatPropertyMutator_t::GCompMatPropertyMutator_t(void *ptr) {
    m_ptr = ptr;
}
bool GCompMatPropertyMutator_t::GetEnabled() const {
    return GetSchemaValue<bool>(m_ptr, "CompMatPropertyMutator_t", "m_bEnabled");
}
void GCompMatPropertyMutator_t::SetEnabled(bool value) {
    SetSchemaValue(m_ptr, "CompMatPropertyMutator_t", "m_bEnabled", true, value);
}
uint64_t GCompMatPropertyMutator_t::GetMutatorCommandType() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CompMatPropertyMutator_t", "m_nMutatorCommandType");
}
void GCompMatPropertyMutator_t::SetMutatorCommandType(uint64_t value) {
    SetSchemaValue(m_ptr, "CompMatPropertyMutator_t", "m_nMutatorCommandType", true, value);
}
std::string GCompMatPropertyMutator_t::GetStrInitWith_Container() const {
    return GetSchemaValue<CUtlString>(m_ptr, "CompMatPropertyMutator_t", "m_strInitWith_Container").Get();
}
void GCompMatPropertyMutator_t::SetStrInitWith_Container(std::string value) {
    SetSchemaValue(m_ptr, "CompMatPropertyMutator_t", "m_strInitWith_Container", true, CUtlString(value.c_str()));
}
std::string GCompMatPropertyMutator_t::GetStrCopyProperty_InputContainerSrc() const {
    return GetSchemaValue<CUtlString>(m_ptr, "CompMatPropertyMutator_t", "m_strCopyProperty_InputContainerSrc").Get();
}
void GCompMatPropertyMutator_t::SetStrCopyProperty_InputContainerSrc(std::string value) {
    SetSchemaValue(m_ptr, "CompMatPropertyMutator_t", "m_strCopyProperty_InputContainerSrc", true, CUtlString(value.c_str()));
}
std::string GCompMatPropertyMutator_t::GetStrCopyProperty_InputContainerProperty() const {
    return GetSchemaValue<CUtlString>(m_ptr, "CompMatPropertyMutator_t", "m_strCopyProperty_InputContainerProperty").Get();
}
void GCompMatPropertyMutator_t::SetStrCopyProperty_InputContainerProperty(std::string value) {
    SetSchemaValue(m_ptr, "CompMatPropertyMutator_t", "m_strCopyProperty_InputContainerProperty", true, CUtlString(value.c_str()));
}
std::string GCompMatPropertyMutator_t::GetStrCopyProperty_TargetProperty() const {
    return GetSchemaValue<CUtlString>(m_ptr, "CompMatPropertyMutator_t", "m_strCopyProperty_TargetProperty").Get();
}
void GCompMatPropertyMutator_t::SetStrCopyProperty_TargetProperty(std::string value) {
    SetSchemaValue(m_ptr, "CompMatPropertyMutator_t", "m_strCopyProperty_TargetProperty", true, CUtlString(value.c_str()));
}
std::string GCompMatPropertyMutator_t::GetStrRandomRollInputVars_SeedInputVar() const {
    return GetSchemaValue<CUtlString>(m_ptr, "CompMatPropertyMutator_t", "m_strRandomRollInputVars_SeedInputVar").Get();
}
void GCompMatPropertyMutator_t::SetStrRandomRollInputVars_SeedInputVar(std::string value) {
    SetSchemaValue(m_ptr, "CompMatPropertyMutator_t", "m_strRandomRollInputVars_SeedInputVar", true, CUtlString(value.c_str()));
}
std::vector<CUtlString> GCompMatPropertyMutator_t::GetRandomRollInputVars_InputVarsToRoll() const {
    CUtlVector<CUtlString>* vec = GetSchemaValue<CUtlVector<CUtlString>*>(m_ptr, "CompMatPropertyMutator_t", "m_vecRandomRollInputVars_InputVarsToRoll"); std::vector<CUtlString> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCompMatPropertyMutator_t::SetRandomRollInputVars_InputVarsToRoll(std::vector<CUtlString> value) {
    SetSchemaValueCUtlVector<CUtlString>(m_ptr, "CompMatPropertyMutator_t", "m_vecRandomRollInputVars_InputVarsToRoll", true, value);
}
std::string GCompMatPropertyMutator_t::GetStrCopyMatchingKeys_InputContainerSrc() const {
    return GetSchemaValue<CUtlString>(m_ptr, "CompMatPropertyMutator_t", "m_strCopyMatchingKeys_InputContainerSrc").Get();
}
void GCompMatPropertyMutator_t::SetStrCopyMatchingKeys_InputContainerSrc(std::string value) {
    SetSchemaValue(m_ptr, "CompMatPropertyMutator_t", "m_strCopyMatchingKeys_InputContainerSrc", true, CUtlString(value.c_str()));
}
std::string GCompMatPropertyMutator_t::GetStrCopyKeysWithSuffix_InputContainerSrc() const {
    return GetSchemaValue<CUtlString>(m_ptr, "CompMatPropertyMutator_t", "m_strCopyKeysWithSuffix_InputContainerSrc").Get();
}
void GCompMatPropertyMutator_t::SetStrCopyKeysWithSuffix_InputContainerSrc(std::string value) {
    SetSchemaValue(m_ptr, "CompMatPropertyMutator_t", "m_strCopyKeysWithSuffix_InputContainerSrc", true, CUtlString(value.c_str()));
}
std::string GCompMatPropertyMutator_t::GetStrCopyKeysWithSuffix_FindSuffix() const {
    return GetSchemaValue<CUtlString>(m_ptr, "CompMatPropertyMutator_t", "m_strCopyKeysWithSuffix_FindSuffix").Get();
}
void GCompMatPropertyMutator_t::SetStrCopyKeysWithSuffix_FindSuffix(std::string value) {
    SetSchemaValue(m_ptr, "CompMatPropertyMutator_t", "m_strCopyKeysWithSuffix_FindSuffix", true, CUtlString(value.c_str()));
}
std::string GCompMatPropertyMutator_t::GetStrCopyKeysWithSuffix_ReplaceSuffix() const {
    return GetSchemaValue<CUtlString>(m_ptr, "CompMatPropertyMutator_t", "m_strCopyKeysWithSuffix_ReplaceSuffix").Get();
}
void GCompMatPropertyMutator_t::SetStrCopyKeysWithSuffix_ReplaceSuffix(std::string value) {
    SetSchemaValue(m_ptr, "CompMatPropertyMutator_t", "m_strCopyKeysWithSuffix_ReplaceSuffix", true, CUtlString(value.c_str()));
}
GCompositeMaterialInputLooseVariable_t GCompMatPropertyMutator_t::GetSetValue_Value() const {
    GCompositeMaterialInputLooseVariable_t value(GetSchemaPtr(m_ptr, "CompMatPropertyMutator_t", "m_nSetValue_Value"));
    return value;
}
void GCompMatPropertyMutator_t::SetSetValue_Value(GCompositeMaterialInputLooseVariable_t value) {
    SetSchemaValue(m_ptr, "CompMatPropertyMutator_t", "m_nSetValue_Value", true, value);
}
std::string GCompMatPropertyMutator_t::GetStrGenerateTexture_TargetParam() const {
    return GetSchemaValue<CUtlString>(m_ptr, "CompMatPropertyMutator_t", "m_strGenerateTexture_TargetParam").Get();
}
void GCompMatPropertyMutator_t::SetStrGenerateTexture_TargetParam(std::string value) {
    SetSchemaValue(m_ptr, "CompMatPropertyMutator_t", "m_strGenerateTexture_TargetParam", true, CUtlString(value.c_str()));
}
std::string GCompMatPropertyMutator_t::GetStrGenerateTexture_InitialContainer() const {
    return GetSchemaValue<CUtlString>(m_ptr, "CompMatPropertyMutator_t", "m_strGenerateTexture_InitialContainer").Get();
}
void GCompMatPropertyMutator_t::SetStrGenerateTexture_InitialContainer(std::string value) {
    SetSchemaValue(m_ptr, "CompMatPropertyMutator_t", "m_strGenerateTexture_InitialContainer", true, CUtlString(value.c_str()));
}
int32_t GCompMatPropertyMutator_t::GetResolution() const {
    return GetSchemaValue<int32_t>(m_ptr, "CompMatPropertyMutator_t", "m_nResolution");
}
void GCompMatPropertyMutator_t::SetResolution(int32_t value) {
    SetSchemaValue(m_ptr, "CompMatPropertyMutator_t", "m_nResolution", true, value);
}
bool GCompMatPropertyMutator_t::GetIsScratchTarget() const {
    return GetSchemaValue<bool>(m_ptr, "CompMatPropertyMutator_t", "m_bIsScratchTarget");
}
void GCompMatPropertyMutator_t::SetIsScratchTarget(bool value) {
    SetSchemaValue(m_ptr, "CompMatPropertyMutator_t", "m_bIsScratchTarget", true, value);
}
bool GCompMatPropertyMutator_t::GetSplatDebugInfo() const {
    return GetSchemaValue<bool>(m_ptr, "CompMatPropertyMutator_t", "m_bSplatDebugInfo");
}
void GCompMatPropertyMutator_t::SetSplatDebugInfo(bool value) {
    SetSchemaValue(m_ptr, "CompMatPropertyMutator_t", "m_bSplatDebugInfo", true, value);
}
bool GCompMatPropertyMutator_t::GetCaptureInRenderDoc() const {
    return GetSchemaValue<bool>(m_ptr, "CompMatPropertyMutator_t", "m_bCaptureInRenderDoc");
}
void GCompMatPropertyMutator_t::SetCaptureInRenderDoc(bool value) {
    SetSchemaValue(m_ptr, "CompMatPropertyMutator_t", "m_bCaptureInRenderDoc", true, value);
}
std::vector<GCompMatPropertyMutator_t> GCompMatPropertyMutator_t::GetTexGenInstructions() const {
    CUtlVector<GCompMatPropertyMutator_t>* vec = GetSchemaValue<CUtlVector<GCompMatPropertyMutator_t>*>(m_ptr, "CompMatPropertyMutator_t", "m_vecTexGenInstructions"); std::vector<GCompMatPropertyMutator_t> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCompMatPropertyMutator_t::SetTexGenInstructions(std::vector<GCompMatPropertyMutator_t> value) {
    SetSchemaValueCUtlVector<GCompMatPropertyMutator_t>(m_ptr, "CompMatPropertyMutator_t", "m_vecTexGenInstructions", true, value);
}
std::vector<GCompMatPropertyMutator_t> GCompMatPropertyMutator_t::GetConditionalMutators() const {
    CUtlVector<GCompMatPropertyMutator_t>* vec = GetSchemaValue<CUtlVector<GCompMatPropertyMutator_t>*>(m_ptr, "CompMatPropertyMutator_t", "m_vecConditionalMutators"); std::vector<GCompMatPropertyMutator_t> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCompMatPropertyMutator_t::SetConditionalMutators(std::vector<GCompMatPropertyMutator_t> value) {
    SetSchemaValueCUtlVector<GCompMatPropertyMutator_t>(m_ptr, "CompMatPropertyMutator_t", "m_vecConditionalMutators", true, value);
}
std::string GCompMatPropertyMutator_t::GetStrPopInputQueue_Container() const {
    return GetSchemaValue<CUtlString>(m_ptr, "CompMatPropertyMutator_t", "m_strPopInputQueue_Container").Get();
}
void GCompMatPropertyMutator_t::SetStrPopInputQueue_Container(std::string value) {
    SetSchemaValue(m_ptr, "CompMatPropertyMutator_t", "m_strPopInputQueue_Container", true, CUtlString(value.c_str()));
}
std::string GCompMatPropertyMutator_t::GetStrDrawText_InputContainerSrc() const {
    return GetSchemaValue<CUtlString>(m_ptr, "CompMatPropertyMutator_t", "m_strDrawText_InputContainerSrc").Get();
}
void GCompMatPropertyMutator_t::SetStrDrawText_InputContainerSrc(std::string value) {
    SetSchemaValue(m_ptr, "CompMatPropertyMutator_t", "m_strDrawText_InputContainerSrc", true, CUtlString(value.c_str()));
}
std::string GCompMatPropertyMutator_t::GetStrDrawText_InputContainerProperty() const {
    return GetSchemaValue<CUtlString>(m_ptr, "CompMatPropertyMutator_t", "m_strDrawText_InputContainerProperty").Get();
}
void GCompMatPropertyMutator_t::SetStrDrawText_InputContainerProperty(std::string value) {
    SetSchemaValue(m_ptr, "CompMatPropertyMutator_t", "m_strDrawText_InputContainerProperty", true, CUtlString(value.c_str()));
}
Vector2D GCompMatPropertyMutator_t::GetDrawText_Position() const {
    return GetSchemaValue<Vector2D>(m_ptr, "CompMatPropertyMutator_t", "m_vecDrawText_Position");
}
void GCompMatPropertyMutator_t::SetDrawText_Position(Vector2D value) {
    SetSchemaValue(m_ptr, "CompMatPropertyMutator_t", "m_vecDrawText_Position", true, value);
}
Color GCompMatPropertyMutator_t::GetColDrawText_Color() const {
    return GetSchemaValue<Color>(m_ptr, "CompMatPropertyMutator_t", "m_colDrawText_Color");
}
void GCompMatPropertyMutator_t::SetColDrawText_Color(Color value) {
    SetSchemaValue(m_ptr, "CompMatPropertyMutator_t", "m_colDrawText_Color", true, value);
}
std::string GCompMatPropertyMutator_t::GetStrDrawText_Font() const {
    return GetSchemaValue<CUtlString>(m_ptr, "CompMatPropertyMutator_t", "m_strDrawText_Font").Get();
}
void GCompMatPropertyMutator_t::SetStrDrawText_Font(std::string value) {
    SetSchemaValue(m_ptr, "CompMatPropertyMutator_t", "m_strDrawText_Font", true, CUtlString(value.c_str()));
}
std::vector<GCompMatMutatorCondition_t> GCompMatPropertyMutator_t::GetConditions() const {
    CUtlVector<GCompMatMutatorCondition_t>* vec = GetSchemaValue<CUtlVector<GCompMatMutatorCondition_t>*>(m_ptr, "CompMatPropertyMutator_t", "m_vecConditions"); std::vector<GCompMatMutatorCondition_t> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCompMatPropertyMutator_t::SetConditions(std::vector<GCompMatMutatorCondition_t> value) {
    SetSchemaValueCUtlVector<GCompMatMutatorCondition_t>(m_ptr, "CompMatPropertyMutator_t", "m_vecConditions", true, value);
}
std::string GCompMatPropertyMutator_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCompMatPropertyMutator_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCompMatPropertyMutator_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCompMatPropertyMutator_t>("CompMatPropertyMutator_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Enabled", &GCompMatPropertyMutator_t::GetEnabled, &GCompMatPropertyMutator_t::SetEnabled)
        .addProperty("MutatorCommandType", &GCompMatPropertyMutator_t::GetMutatorCommandType, &GCompMatPropertyMutator_t::SetMutatorCommandType)
        .addProperty("StrInitWith_Container", &GCompMatPropertyMutator_t::GetStrInitWith_Container, &GCompMatPropertyMutator_t::SetStrInitWith_Container)
        .addProperty("StrCopyProperty_InputContainerSrc", &GCompMatPropertyMutator_t::GetStrCopyProperty_InputContainerSrc, &GCompMatPropertyMutator_t::SetStrCopyProperty_InputContainerSrc)
        .addProperty("StrCopyProperty_InputContainerProperty", &GCompMatPropertyMutator_t::GetStrCopyProperty_InputContainerProperty, &GCompMatPropertyMutator_t::SetStrCopyProperty_InputContainerProperty)
        .addProperty("StrCopyProperty_TargetProperty", &GCompMatPropertyMutator_t::GetStrCopyProperty_TargetProperty, &GCompMatPropertyMutator_t::SetStrCopyProperty_TargetProperty)
        .addProperty("StrRandomRollInputVars_SeedInputVar", &GCompMatPropertyMutator_t::GetStrRandomRollInputVars_SeedInputVar, &GCompMatPropertyMutator_t::SetStrRandomRollInputVars_SeedInputVar)
        .addProperty("RandomRollInputVars_InputVarsToRoll", &GCompMatPropertyMutator_t::GetRandomRollInputVars_InputVarsToRoll, &GCompMatPropertyMutator_t::SetRandomRollInputVars_InputVarsToRoll)
        .addProperty("StrCopyMatchingKeys_InputContainerSrc", &GCompMatPropertyMutator_t::GetStrCopyMatchingKeys_InputContainerSrc, &GCompMatPropertyMutator_t::SetStrCopyMatchingKeys_InputContainerSrc)
        .addProperty("StrCopyKeysWithSuffix_InputContainerSrc", &GCompMatPropertyMutator_t::GetStrCopyKeysWithSuffix_InputContainerSrc, &GCompMatPropertyMutator_t::SetStrCopyKeysWithSuffix_InputContainerSrc)
        .addProperty("StrCopyKeysWithSuffix_FindSuffix", &GCompMatPropertyMutator_t::GetStrCopyKeysWithSuffix_FindSuffix, &GCompMatPropertyMutator_t::SetStrCopyKeysWithSuffix_FindSuffix)
        .addProperty("StrCopyKeysWithSuffix_ReplaceSuffix", &GCompMatPropertyMutator_t::GetStrCopyKeysWithSuffix_ReplaceSuffix, &GCompMatPropertyMutator_t::SetStrCopyKeysWithSuffix_ReplaceSuffix)
        .addProperty("SetValue_Value", &GCompMatPropertyMutator_t::GetSetValue_Value, &GCompMatPropertyMutator_t::SetSetValue_Value)
        .addProperty("StrGenerateTexture_TargetParam", &GCompMatPropertyMutator_t::GetStrGenerateTexture_TargetParam, &GCompMatPropertyMutator_t::SetStrGenerateTexture_TargetParam)
        .addProperty("StrGenerateTexture_InitialContainer", &GCompMatPropertyMutator_t::GetStrGenerateTexture_InitialContainer, &GCompMatPropertyMutator_t::SetStrGenerateTexture_InitialContainer)
        .addProperty("Resolution", &GCompMatPropertyMutator_t::GetResolution, &GCompMatPropertyMutator_t::SetResolution)
        .addProperty("IsScratchTarget", &GCompMatPropertyMutator_t::GetIsScratchTarget, &GCompMatPropertyMutator_t::SetIsScratchTarget)
        .addProperty("SplatDebugInfo", &GCompMatPropertyMutator_t::GetSplatDebugInfo, &GCompMatPropertyMutator_t::SetSplatDebugInfo)
        .addProperty("CaptureInRenderDoc", &GCompMatPropertyMutator_t::GetCaptureInRenderDoc, &GCompMatPropertyMutator_t::SetCaptureInRenderDoc)
        .addProperty("TexGenInstructions", &GCompMatPropertyMutator_t::GetTexGenInstructions, &GCompMatPropertyMutator_t::SetTexGenInstructions)
        .addProperty("ConditionalMutators", &GCompMatPropertyMutator_t::GetConditionalMutators, &GCompMatPropertyMutator_t::SetConditionalMutators)
        .addProperty("StrPopInputQueue_Container", &GCompMatPropertyMutator_t::GetStrPopInputQueue_Container, &GCompMatPropertyMutator_t::SetStrPopInputQueue_Container)
        .addProperty("StrDrawText_InputContainerSrc", &GCompMatPropertyMutator_t::GetStrDrawText_InputContainerSrc, &GCompMatPropertyMutator_t::SetStrDrawText_InputContainerSrc)
        .addProperty("StrDrawText_InputContainerProperty", &GCompMatPropertyMutator_t::GetStrDrawText_InputContainerProperty, &GCompMatPropertyMutator_t::SetStrDrawText_InputContainerProperty)
        .addProperty("DrawText_Position", &GCompMatPropertyMutator_t::GetDrawText_Position, &GCompMatPropertyMutator_t::SetDrawText_Position)
        .addProperty("ColDrawText_Color", &GCompMatPropertyMutator_t::GetColDrawText_Color, &GCompMatPropertyMutator_t::SetColDrawText_Color)
        .addProperty("StrDrawText_Font", &GCompMatPropertyMutator_t::GetStrDrawText_Font, &GCompMatPropertyMutator_t::SetStrDrawText_Font)
        .addProperty("Conditions", &GCompMatPropertyMutator_t::GetConditions, &GCompMatPropertyMutator_t::SetConditions)
        .addFunction("ToPtr", &GCompMatPropertyMutator_t::ToPtr)
        .addFunction("IsValid", &GCompMatPropertyMutator_t::IsValid)
        .endClass();
}
GIKBoneNameAndIndex_t::GIKBoneNameAndIndex_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GIKBoneNameAndIndex_t::GIKBoneNameAndIndex_t(void *ptr) {
    m_ptr = ptr;
}
std::string GIKBoneNameAndIndex_t::GetName() const {
    return GetSchemaValue<CUtlString>(m_ptr, "IKBoneNameAndIndex_t", "m_Name").Get();
}
void GIKBoneNameAndIndex_t::SetName(std::string value) {
    SetSchemaValue(m_ptr, "IKBoneNameAndIndex_t", "m_Name", true, CUtlString(value.c_str()));
}
std::string GIKBoneNameAndIndex_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GIKBoneNameAndIndex_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassIKBoneNameAndIndex_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GIKBoneNameAndIndex_t>("IKBoneNameAndIndex_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Name", &GIKBoneNameAndIndex_t::GetName, &GIKBoneNameAndIndex_t::SetName)
        .addFunction("ToPtr", &GIKBoneNameAndIndex_t::ToPtr)
        .addFunction("IsValid", &GIKBoneNameAndIndex_t::IsValid)
        .endClass();
}
GPermEntityLumpData_t::GPermEntityLumpData_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GPermEntityLumpData_t::GPermEntityLumpData_t(void *ptr) {
    m_ptr = ptr;
}
std::string GPermEntityLumpData_t::GetName() const {
    return GetSchemaValue<CUtlString>(m_ptr, "PermEntityLumpData_t", "m_name").Get();
}
void GPermEntityLumpData_t::SetName(std::string value) {
    SetSchemaValue(m_ptr, "PermEntityLumpData_t", "m_name", true, CUtlString(value.c_str()));
}
std::string GPermEntityLumpData_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GPermEntityLumpData_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassPermEntityLumpData_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GPermEntityLumpData_t>("PermEntityLumpData_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Name", &GPermEntityLumpData_t::GetName, &GPermEntityLumpData_t::SetName)
        .addFunction("ToPtr", &GPermEntityLumpData_t::ToPtr)
        .addFunction("IsValid", &GPermEntityLumpData_t::IsValid)
        .endClass();
}
GVMixDelayDesc_t::GVMixDelayDesc_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GVMixDelayDesc_t::GVMixDelayDesc_t(void *ptr) {
    m_ptr = ptr;
}
GVMixFilterDesc_t GVMixDelayDesc_t::GetFeedbackFilter() const {
    GVMixFilterDesc_t value(GetSchemaPtr(m_ptr, "VMixDelayDesc_t", "m_feedbackFilter"));
    return value;
}
void GVMixDelayDesc_t::SetFeedbackFilter(GVMixFilterDesc_t value) {
    SetSchemaValue(m_ptr, "VMixDelayDesc_t", "m_feedbackFilter", true, value);
}
bool GVMixDelayDesc_t::GetEnableFilter() const {
    return GetSchemaValue<bool>(m_ptr, "VMixDelayDesc_t", "m_bEnableFilter");
}
void GVMixDelayDesc_t::SetEnableFilter(bool value) {
    SetSchemaValue(m_ptr, "VMixDelayDesc_t", "m_bEnableFilter", true, value);
}
float GVMixDelayDesc_t::GetDelay() const {
    return GetSchemaValue<float>(m_ptr, "VMixDelayDesc_t", "m_flDelay");
}
void GVMixDelayDesc_t::SetDelay(float value) {
    SetSchemaValue(m_ptr, "VMixDelayDesc_t", "m_flDelay", true, value);
}
float GVMixDelayDesc_t::GetDirectGain() const {
    return GetSchemaValue<float>(m_ptr, "VMixDelayDesc_t", "m_flDirectGain");
}
void GVMixDelayDesc_t::SetDirectGain(float value) {
    SetSchemaValue(m_ptr, "VMixDelayDesc_t", "m_flDirectGain", true, value);
}
float GVMixDelayDesc_t::GetDelayGain() const {
    return GetSchemaValue<float>(m_ptr, "VMixDelayDesc_t", "m_flDelayGain");
}
void GVMixDelayDesc_t::SetDelayGain(float value) {
    SetSchemaValue(m_ptr, "VMixDelayDesc_t", "m_flDelayGain", true, value);
}
float GVMixDelayDesc_t::GetFeedbackGain() const {
    return GetSchemaValue<float>(m_ptr, "VMixDelayDesc_t", "m_flFeedbackGain");
}
void GVMixDelayDesc_t::SetFeedbackGain(float value) {
    SetSchemaValue(m_ptr, "VMixDelayDesc_t", "m_flFeedbackGain", true, value);
}
float GVMixDelayDesc_t::GetWidth() const {
    return GetSchemaValue<float>(m_ptr, "VMixDelayDesc_t", "m_flWidth");
}
void GVMixDelayDesc_t::SetWidth(float value) {
    SetSchemaValue(m_ptr, "VMixDelayDesc_t", "m_flWidth", true, value);
}
std::string GVMixDelayDesc_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GVMixDelayDesc_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassVMixDelayDesc_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GVMixDelayDesc_t>("VMixDelayDesc_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("FeedbackFilter", &GVMixDelayDesc_t::GetFeedbackFilter, &GVMixDelayDesc_t::SetFeedbackFilter)
        .addProperty("EnableFilter", &GVMixDelayDesc_t::GetEnableFilter, &GVMixDelayDesc_t::SetEnableFilter)
        .addProperty("Delay", &GVMixDelayDesc_t::GetDelay, &GVMixDelayDesc_t::SetDelay)
        .addProperty("DirectGain", &GVMixDelayDesc_t::GetDirectGain, &GVMixDelayDesc_t::SetDirectGain)
        .addProperty("DelayGain", &GVMixDelayDesc_t::GetDelayGain, &GVMixDelayDesc_t::SetDelayGain)
        .addProperty("FeedbackGain", &GVMixDelayDesc_t::GetFeedbackGain, &GVMixDelayDesc_t::SetFeedbackGain)
        .addProperty("Width", &GVMixDelayDesc_t::GetWidth, &GVMixDelayDesc_t::SetWidth)
        .addFunction("ToPtr", &GVMixDelayDesc_t::ToPtr)
        .addFunction("IsValid", &GVMixDelayDesc_t::IsValid)
        .endClass();
}
GCBoneConstraintDotToMorph::GCBoneConstraintDotToMorph(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCBoneConstraintDotToMorph::GCBoneConstraintDotToMorph(void *ptr) {
    m_ptr = ptr;
}
std::string GCBoneConstraintDotToMorph::GetBoneName() const {
    return GetSchemaValue<CUtlString>(m_ptr, "CBoneConstraintDotToMorph", "m_sBoneName").Get();
}
void GCBoneConstraintDotToMorph::SetBoneName(std::string value) {
    SetSchemaValue(m_ptr, "CBoneConstraintDotToMorph", "m_sBoneName", false, CUtlString(value.c_str()));
}
std::string GCBoneConstraintDotToMorph::GetTargetBoneName() const {
    return GetSchemaValue<CUtlString>(m_ptr, "CBoneConstraintDotToMorph", "m_sTargetBoneName").Get();
}
void GCBoneConstraintDotToMorph::SetTargetBoneName(std::string value) {
    SetSchemaValue(m_ptr, "CBoneConstraintDotToMorph", "m_sTargetBoneName", false, CUtlString(value.c_str()));
}
std::string GCBoneConstraintDotToMorph::GetMorphChannelName() const {
    return GetSchemaValue<CUtlString>(m_ptr, "CBoneConstraintDotToMorph", "m_sMorphChannelName").Get();
}
void GCBoneConstraintDotToMorph::SetMorphChannelName(std::string value) {
    SetSchemaValue(m_ptr, "CBoneConstraintDotToMorph", "m_sMorphChannelName", false, CUtlString(value.c_str()));
}
std::vector<float> GCBoneConstraintDotToMorph::GetRemap() const {
    float* outValue = GetSchemaValue<float*>(m_ptr, "CBoneConstraintDotToMorph", "m_flRemap"); std::vector<float> ret; for(int i = 0; i < 4; i++) { ret.push_back(outValue[i]); } return ret;
}
void GCBoneConstraintDotToMorph::SetRemap(std::vector<float> value) {
    float* outValue = GetSchemaValue<float*>(m_ptr, "CBoneConstraintDotToMorph", "m_flRemap"); for(int i = 0; i < 4; i++) { outValue[i] = value[i]; } SetSchemaValue(m_ptr, "CBoneConstraintDotToMorph", "m_flRemap", false, outValue);
}
std::string GCBoneConstraintDotToMorph::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCBoneConstraintDotToMorph::IsValid() {
    return (m_ptr != nullptr);
}
GCBoneConstraintBase GCBoneConstraintDotToMorph::GetParent() const {
    GCBoneConstraintBase value(m_ptr);
    return value;
}
void GCBoneConstraintDotToMorph::SetParent(GCBoneConstraintBase value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCBoneConstraintDotToMorph(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCBoneConstraintDotToMorph>("CBoneConstraintDotToMorph")
        .addConstructor<void (*)(std::string)>()
        .addProperty("BoneName", &GCBoneConstraintDotToMorph::GetBoneName, &GCBoneConstraintDotToMorph::SetBoneName)
        .addProperty("TargetBoneName", &GCBoneConstraintDotToMorph::GetTargetBoneName, &GCBoneConstraintDotToMorph::SetTargetBoneName)
        .addProperty("MorphChannelName", &GCBoneConstraintDotToMorph::GetMorphChannelName, &GCBoneConstraintDotToMorph::SetMorphChannelName)
        .addProperty("Remap", &GCBoneConstraintDotToMorph::GetRemap, &GCBoneConstraintDotToMorph::SetRemap)
        .addProperty("Parent", &GCBoneConstraintDotToMorph::GetParent, &GCBoneConstraintDotToMorph::SetParent)
        .addFunction("ToPtr", &GCBoneConstraintDotToMorph::ToPtr)
        .addFunction("IsValid", &GCBoneConstraintDotToMorph::IsValid)
        .endClass();
}
GPostProcessingBloomParameters_t::GPostProcessingBloomParameters_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GPostProcessingBloomParameters_t::GPostProcessingBloomParameters_t(void *ptr) {
    m_ptr = ptr;
}
uint64_t GPostProcessingBloomParameters_t::GetBlendMode() const {
    return GetSchemaValue<uint64_t>(m_ptr, "PostProcessingBloomParameters_t", "m_blendMode");
}
void GPostProcessingBloomParameters_t::SetBlendMode(uint64_t value) {
    SetSchemaValue(m_ptr, "PostProcessingBloomParameters_t", "m_blendMode", true, value);
}
float GPostProcessingBloomParameters_t::GetBloomStrength() const {
    return GetSchemaValue<float>(m_ptr, "PostProcessingBloomParameters_t", "m_flBloomStrength");
}
void GPostProcessingBloomParameters_t::SetBloomStrength(float value) {
    SetSchemaValue(m_ptr, "PostProcessingBloomParameters_t", "m_flBloomStrength", true, value);
}
float GPostProcessingBloomParameters_t::GetScreenBloomStrength() const {
    return GetSchemaValue<float>(m_ptr, "PostProcessingBloomParameters_t", "m_flScreenBloomStrength");
}
void GPostProcessingBloomParameters_t::SetScreenBloomStrength(float value) {
    SetSchemaValue(m_ptr, "PostProcessingBloomParameters_t", "m_flScreenBloomStrength", true, value);
}
float GPostProcessingBloomParameters_t::GetBlurBloomStrength() const {
    return GetSchemaValue<float>(m_ptr, "PostProcessingBloomParameters_t", "m_flBlurBloomStrength");
}
void GPostProcessingBloomParameters_t::SetBlurBloomStrength(float value) {
    SetSchemaValue(m_ptr, "PostProcessingBloomParameters_t", "m_flBlurBloomStrength", true, value);
}
float GPostProcessingBloomParameters_t::GetBloomThreshold() const {
    return GetSchemaValue<float>(m_ptr, "PostProcessingBloomParameters_t", "m_flBloomThreshold");
}
void GPostProcessingBloomParameters_t::SetBloomThreshold(float value) {
    SetSchemaValue(m_ptr, "PostProcessingBloomParameters_t", "m_flBloomThreshold", true, value);
}
float GPostProcessingBloomParameters_t::GetBloomThresholdWidth() const {
    return GetSchemaValue<float>(m_ptr, "PostProcessingBloomParameters_t", "m_flBloomThresholdWidth");
}
void GPostProcessingBloomParameters_t::SetBloomThresholdWidth(float value) {
    SetSchemaValue(m_ptr, "PostProcessingBloomParameters_t", "m_flBloomThresholdWidth", true, value);
}
float GPostProcessingBloomParameters_t::GetSkyboxBloomStrength() const {
    return GetSchemaValue<float>(m_ptr, "PostProcessingBloomParameters_t", "m_flSkyboxBloomStrength");
}
void GPostProcessingBloomParameters_t::SetSkyboxBloomStrength(float value) {
    SetSchemaValue(m_ptr, "PostProcessingBloomParameters_t", "m_flSkyboxBloomStrength", true, value);
}
float GPostProcessingBloomParameters_t::GetBloomStartValue() const {
    return GetSchemaValue<float>(m_ptr, "PostProcessingBloomParameters_t", "m_flBloomStartValue");
}
void GPostProcessingBloomParameters_t::SetBloomStartValue(float value) {
    SetSchemaValue(m_ptr, "PostProcessingBloomParameters_t", "m_flBloomStartValue", true, value);
}
std::vector<float> GPostProcessingBloomParameters_t::GetBlurWeight() const {
    float* outValue = GetSchemaValue<float*>(m_ptr, "PostProcessingBloomParameters_t", "m_flBlurWeight"); std::vector<float> ret; for(int i = 0; i < 5; i++) { ret.push_back(outValue[i]); } return ret;
}
void GPostProcessingBloomParameters_t::SetBlurWeight(std::vector<float> value) {
    float* outValue = GetSchemaValue<float*>(m_ptr, "PostProcessingBloomParameters_t", "m_flBlurWeight"); for(int i = 0; i < 5; i++) { outValue[i] = value[i]; } SetSchemaValue(m_ptr, "PostProcessingBloomParameters_t", "m_flBlurWeight", true, outValue);
}
std::vector<Vector> GPostProcessingBloomParameters_t::GetBlurTint() const {
    Vector* outValue = GetSchemaValue<Vector*>(m_ptr, "PostProcessingBloomParameters_t", "m_vBlurTint"); std::vector<Vector> ret; for(int i = 0; i < 5; i++) { ret.push_back(outValue[i]); } return ret;
}
void GPostProcessingBloomParameters_t::SetBlurTint(std::vector<Vector> value) {
    Vector* outValue = GetSchemaValue<Vector*>(m_ptr, "PostProcessingBloomParameters_t", "m_vBlurTint"); for(int i = 0; i < 5; i++) { outValue[i] = value[i]; } SetSchemaValue(m_ptr, "PostProcessingBloomParameters_t", "m_vBlurTint", true, outValue);
}
std::string GPostProcessingBloomParameters_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GPostProcessingBloomParameters_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassPostProcessingBloomParameters_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GPostProcessingBloomParameters_t>("PostProcessingBloomParameters_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("BlendMode", &GPostProcessingBloomParameters_t::GetBlendMode, &GPostProcessingBloomParameters_t::SetBlendMode)
        .addProperty("BloomStrength", &GPostProcessingBloomParameters_t::GetBloomStrength, &GPostProcessingBloomParameters_t::SetBloomStrength)
        .addProperty("ScreenBloomStrength", &GPostProcessingBloomParameters_t::GetScreenBloomStrength, &GPostProcessingBloomParameters_t::SetScreenBloomStrength)
        .addProperty("BlurBloomStrength", &GPostProcessingBloomParameters_t::GetBlurBloomStrength, &GPostProcessingBloomParameters_t::SetBlurBloomStrength)
        .addProperty("BloomThreshold", &GPostProcessingBloomParameters_t::GetBloomThreshold, &GPostProcessingBloomParameters_t::SetBloomThreshold)
        .addProperty("BloomThresholdWidth", &GPostProcessingBloomParameters_t::GetBloomThresholdWidth, &GPostProcessingBloomParameters_t::SetBloomThresholdWidth)
        .addProperty("SkyboxBloomStrength", &GPostProcessingBloomParameters_t::GetSkyboxBloomStrength, &GPostProcessingBloomParameters_t::SetSkyboxBloomStrength)
        .addProperty("BloomStartValue", &GPostProcessingBloomParameters_t::GetBloomStartValue, &GPostProcessingBloomParameters_t::SetBloomStartValue)
        .addProperty("BlurWeight", &GPostProcessingBloomParameters_t::GetBlurWeight, &GPostProcessingBloomParameters_t::SetBlurWeight)
        .addProperty("BlurTint", &GPostProcessingBloomParameters_t::GetBlurTint, &GPostProcessingBloomParameters_t::SetBlurTint)
        .addFunction("ToPtr", &GPostProcessingBloomParameters_t::ToPtr)
        .addFunction("IsValid", &GPostProcessingBloomParameters_t::IsValid)
        .endClass();
}
GEntOutput_t::GEntOutput_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GEntOutput_t::GEntOutput_t(void *ptr) {
    m_ptr = ptr;
}
std::string GEntOutput_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GEntOutput_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassEntOutput_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GEntOutput_t>("EntOutput_t")
        .addConstructor<void (*)(std::string)>()
        .addFunction("ToPtr", &GEntOutput_t::ToPtr)
        .addFunction("IsValid", &GEntOutput_t::IsValid)
        .endClass();
}
GFakeEntityDerivedB_tAPI::GFakeEntityDerivedB_tAPI(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GFakeEntityDerivedB_tAPI::GFakeEntityDerivedB_tAPI(void *ptr) {
    m_ptr = ptr;
}
std::string GFakeEntityDerivedB_tAPI::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GFakeEntityDerivedB_tAPI::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassFakeEntityDerivedB_tAPI(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GFakeEntityDerivedB_tAPI>("FakeEntityDerivedB_tAPI")
        .addConstructor<void (*)(std::string)>()
        .addFunction("ToPtr", &GFakeEntityDerivedB_tAPI::ToPtr)
        .addFunction("IsValid", &GFakeEntityDerivedB_tAPI::IsValid)
        .endClass();
}
GCSlopeComponentUpdater::GCSlopeComponentUpdater(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCSlopeComponentUpdater::GCSlopeComponentUpdater(void *ptr) {
    m_ptr = ptr;
}
float GCSlopeComponentUpdater::GetTraceDistance() const {
    return GetSchemaValue<float>(m_ptr, "CSlopeComponentUpdater", "m_flTraceDistance");
}
void GCSlopeComponentUpdater::SetTraceDistance(float value) {
    SetSchemaValue(m_ptr, "CSlopeComponentUpdater", "m_flTraceDistance", false, value);
}
GCAnimParamHandle GCSlopeComponentUpdater::GetSlopeAngle() const {
    GCAnimParamHandle value(GetSchemaPtr(m_ptr, "CSlopeComponentUpdater", "m_hSlopeAngle"));
    return value;
}
void GCSlopeComponentUpdater::SetSlopeAngle(GCAnimParamHandle value) {
    SetSchemaValue(m_ptr, "CSlopeComponentUpdater", "m_hSlopeAngle", false, value);
}
GCAnimParamHandle GCSlopeComponentUpdater::GetSlopeAngleFront() const {
    GCAnimParamHandle value(GetSchemaPtr(m_ptr, "CSlopeComponentUpdater", "m_hSlopeAngleFront"));
    return value;
}
void GCSlopeComponentUpdater::SetSlopeAngleFront(GCAnimParamHandle value) {
    SetSchemaValue(m_ptr, "CSlopeComponentUpdater", "m_hSlopeAngleFront", false, value);
}
GCAnimParamHandle GCSlopeComponentUpdater::GetSlopeAngleSide() const {
    GCAnimParamHandle value(GetSchemaPtr(m_ptr, "CSlopeComponentUpdater", "m_hSlopeAngleSide"));
    return value;
}
void GCSlopeComponentUpdater::SetSlopeAngleSide(GCAnimParamHandle value) {
    SetSchemaValue(m_ptr, "CSlopeComponentUpdater", "m_hSlopeAngleSide", false, value);
}
GCAnimParamHandle GCSlopeComponentUpdater::GetSlopeHeading() const {
    GCAnimParamHandle value(GetSchemaPtr(m_ptr, "CSlopeComponentUpdater", "m_hSlopeHeading"));
    return value;
}
void GCSlopeComponentUpdater::SetSlopeHeading(GCAnimParamHandle value) {
    SetSchemaValue(m_ptr, "CSlopeComponentUpdater", "m_hSlopeHeading", false, value);
}
GCAnimParamHandle GCSlopeComponentUpdater::GetSlopeNormal() const {
    GCAnimParamHandle value(GetSchemaPtr(m_ptr, "CSlopeComponentUpdater", "m_hSlopeNormal"));
    return value;
}
void GCSlopeComponentUpdater::SetSlopeNormal(GCAnimParamHandle value) {
    SetSchemaValue(m_ptr, "CSlopeComponentUpdater", "m_hSlopeNormal", false, value);
}
GCAnimParamHandle GCSlopeComponentUpdater::GetSlopeNormal_WorldSpace() const {
    GCAnimParamHandle value(GetSchemaPtr(m_ptr, "CSlopeComponentUpdater", "m_hSlopeNormal_WorldSpace"));
    return value;
}
void GCSlopeComponentUpdater::SetSlopeNormal_WorldSpace(GCAnimParamHandle value) {
    SetSchemaValue(m_ptr, "CSlopeComponentUpdater", "m_hSlopeNormal_WorldSpace", false, value);
}
std::string GCSlopeComponentUpdater::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCSlopeComponentUpdater::IsValid() {
    return (m_ptr != nullptr);
}
GCAnimComponentUpdater GCSlopeComponentUpdater::GetParent() const {
    GCAnimComponentUpdater value(m_ptr);
    return value;
}
void GCSlopeComponentUpdater::SetParent(GCAnimComponentUpdater value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCSlopeComponentUpdater(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCSlopeComponentUpdater>("CSlopeComponentUpdater")
        .addConstructor<void (*)(std::string)>()
        .addProperty("TraceDistance", &GCSlopeComponentUpdater::GetTraceDistance, &GCSlopeComponentUpdater::SetTraceDistance)
        .addProperty("SlopeAngle", &GCSlopeComponentUpdater::GetSlopeAngle, &GCSlopeComponentUpdater::SetSlopeAngle)
        .addProperty("SlopeAngleFront", &GCSlopeComponentUpdater::GetSlopeAngleFront, &GCSlopeComponentUpdater::SetSlopeAngleFront)
        .addProperty("SlopeAngleSide", &GCSlopeComponentUpdater::GetSlopeAngleSide, &GCSlopeComponentUpdater::SetSlopeAngleSide)
        .addProperty("SlopeHeading", &GCSlopeComponentUpdater::GetSlopeHeading, &GCSlopeComponentUpdater::SetSlopeHeading)
        .addProperty("SlopeNormal", &GCSlopeComponentUpdater::GetSlopeNormal, &GCSlopeComponentUpdater::SetSlopeNormal)
        .addProperty("SlopeNormal_WorldSpace", &GCSlopeComponentUpdater::GetSlopeNormal_WorldSpace, &GCSlopeComponentUpdater::SetSlopeNormal_WorldSpace)
        .addProperty("Parent", &GCSlopeComponentUpdater::GetParent, &GCSlopeComponentUpdater::SetParent)
        .addFunction("ToPtr", &GCSlopeComponentUpdater::ToPtr)
        .addFunction("IsValid", &GCSlopeComponentUpdater::IsValid)
        .endClass();
}
GRnNode_t::GRnNode_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GRnNode_t::GRnNode_t(void *ptr) {
    m_ptr = ptr;
}
Vector GRnNode_t::GetMin() const {
    return GetSchemaValue<Vector>(m_ptr, "RnNode_t", "m_vMin");
}
void GRnNode_t::SetMin(Vector value) {
    SetSchemaValue(m_ptr, "RnNode_t", "m_vMin", true, value);
}
uint32_t GRnNode_t::GetChildren() const {
    return GetSchemaValue<uint32_t>(m_ptr, "RnNode_t", "m_nChildren");
}
void GRnNode_t::SetChildren(uint32_t value) {
    SetSchemaValue(m_ptr, "RnNode_t", "m_nChildren", true, value);
}
Vector GRnNode_t::GetMax() const {
    return GetSchemaValue<Vector>(m_ptr, "RnNode_t", "m_vMax");
}
void GRnNode_t::SetMax(Vector value) {
    SetSchemaValue(m_ptr, "RnNode_t", "m_vMax", true, value);
}
uint32_t GRnNode_t::GetTriangleOffset() const {
    return GetSchemaValue<uint32_t>(m_ptr, "RnNode_t", "m_nTriangleOffset");
}
void GRnNode_t::SetTriangleOffset(uint32_t value) {
    SetSchemaValue(m_ptr, "RnNode_t", "m_nTriangleOffset", true, value);
}
std::string GRnNode_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GRnNode_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassRnNode_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GRnNode_t>("RnNode_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Min", &GRnNode_t::GetMin, &GRnNode_t::SetMin)
        .addProperty("Children", &GRnNode_t::GetChildren, &GRnNode_t::SetChildren)
        .addProperty("Max", &GRnNode_t::GetMax, &GRnNode_t::SetMax)
        .addProperty("TriangleOffset", &GRnNode_t::GetTriangleOffset, &GRnNode_t::SetTriangleOffset)
        .addFunction("ToPtr", &GRnNode_t::ToPtr)
        .addFunction("IsValid", &GRnNode_t::IsValid)
        .endClass();
}
GCSeqCmdSeqDesc::GCSeqCmdSeqDesc(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCSeqCmdSeqDesc::GCSeqCmdSeqDesc(void *ptr) {
    m_ptr = ptr;
}
CBufferString GCSeqCmdSeqDesc::GetName() const {
    return GetSchemaValue<CBufferString>(m_ptr, "CSeqCmdSeqDesc", "m_sName");
}
void GCSeqCmdSeqDesc::SetName(CBufferString value) {
    SetSchemaValue(m_ptr, "CSeqCmdSeqDesc", "m_sName", false, value);
}
GCSeqSeqDescFlag GCSeqCmdSeqDesc::GetFlags() const {
    GCSeqSeqDescFlag value(GetSchemaPtr(m_ptr, "CSeqCmdSeqDesc", "m_flags"));
    return value;
}
void GCSeqCmdSeqDesc::SetFlags(GCSeqSeqDescFlag value) {
    SetSchemaValue(m_ptr, "CSeqCmdSeqDesc", "m_flags", false, value);
}
GCSeqTransition GCSeqCmdSeqDesc::GetTransition() const {
    GCSeqTransition value(GetSchemaPtr(m_ptr, "CSeqCmdSeqDesc", "m_transition"));
    return value;
}
void GCSeqCmdSeqDesc::SetTransition(GCSeqTransition value) {
    SetSchemaValue(m_ptr, "CSeqCmdSeqDesc", "m_transition", false, value);
}
int16_t GCSeqCmdSeqDesc::GetFrameRangeSequence() const {
    return GetSchemaValue<int16_t>(m_ptr, "CSeqCmdSeqDesc", "m_nFrameRangeSequence");
}
void GCSeqCmdSeqDesc::SetFrameRangeSequence(int16_t value) {
    SetSchemaValue(m_ptr, "CSeqCmdSeqDesc", "m_nFrameRangeSequence", false, value);
}
int16_t GCSeqCmdSeqDesc::GetFrameCount() const {
    return GetSchemaValue<int16_t>(m_ptr, "CSeqCmdSeqDesc", "m_nFrameCount");
}
void GCSeqCmdSeqDesc::SetFrameCount(int16_t value) {
    SetSchemaValue(m_ptr, "CSeqCmdSeqDesc", "m_nFrameCount", false, value);
}
float GCSeqCmdSeqDesc::GetFPS() const {
    return GetSchemaValue<float>(m_ptr, "CSeqCmdSeqDesc", "m_flFPS");
}
void GCSeqCmdSeqDesc::SetFPS(float value) {
    SetSchemaValue(m_ptr, "CSeqCmdSeqDesc", "m_flFPS", false, value);
}
int16_t GCSeqCmdSeqDesc::GetSubCycles() const {
    return GetSchemaValue<int16_t>(m_ptr, "CSeqCmdSeqDesc", "m_nSubCycles");
}
void GCSeqCmdSeqDesc::SetSubCycles(int16_t value) {
    SetSchemaValue(m_ptr, "CSeqCmdSeqDesc", "m_nSubCycles", false, value);
}
int16_t GCSeqCmdSeqDesc::GetNumLocalResults() const {
    return GetSchemaValue<int16_t>(m_ptr, "CSeqCmdSeqDesc", "m_numLocalResults");
}
void GCSeqCmdSeqDesc::SetNumLocalResults(int16_t value) {
    SetSchemaValue(m_ptr, "CSeqCmdSeqDesc", "m_numLocalResults", false, value);
}
std::vector<GCSeqCmdLayer> GCSeqCmdSeqDesc::GetCmdLayerArray() const {
    CUtlVector<GCSeqCmdLayer>* vec = GetSchemaValue<CUtlVector<GCSeqCmdLayer>*>(m_ptr, "CSeqCmdSeqDesc", "m_cmdLayerArray"); std::vector<GCSeqCmdLayer> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCSeqCmdSeqDesc::SetCmdLayerArray(std::vector<GCSeqCmdLayer> value) {
    SetSchemaValueCUtlVector<GCSeqCmdLayer>(m_ptr, "CSeqCmdSeqDesc", "m_cmdLayerArray", false, value);
}
std::vector<GCAnimEventDefinition> GCSeqCmdSeqDesc::GetEventArray() const {
    CUtlVector<GCAnimEventDefinition>* vec = GetSchemaValue<CUtlVector<GCAnimEventDefinition>*>(m_ptr, "CSeqCmdSeqDesc", "m_eventArray"); std::vector<GCAnimEventDefinition> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCSeqCmdSeqDesc::SetEventArray(std::vector<GCAnimEventDefinition> value) {
    SetSchemaValueCUtlVector<GCAnimEventDefinition>(m_ptr, "CSeqCmdSeqDesc", "m_eventArray", false, value);
}
std::vector<GCAnimActivity> GCSeqCmdSeqDesc::GetActivityArray() const {
    CUtlVector<GCAnimActivity>* vec = GetSchemaValue<CUtlVector<GCAnimActivity>*>(m_ptr, "CSeqCmdSeqDesc", "m_activityArray"); std::vector<GCAnimActivity> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCSeqCmdSeqDesc::SetActivityArray(std::vector<GCAnimActivity> value) {
    SetSchemaValueCUtlVector<GCAnimActivity>(m_ptr, "CSeqCmdSeqDesc", "m_activityArray", false, value);
}
std::vector<GCSeqPoseSetting> GCSeqCmdSeqDesc::GetPoseSettingArray() const {
    CUtlVector<GCSeqPoseSetting>* vec = GetSchemaValue<CUtlVector<GCSeqPoseSetting>*>(m_ptr, "CSeqCmdSeqDesc", "m_poseSettingArray"); std::vector<GCSeqPoseSetting> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCSeqCmdSeqDesc::SetPoseSettingArray(std::vector<GCSeqPoseSetting> value) {
    SetSchemaValueCUtlVector<GCSeqPoseSetting>(m_ptr, "CSeqCmdSeqDesc", "m_poseSettingArray", false, value);
}
std::string GCSeqCmdSeqDesc::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCSeqCmdSeqDesc::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCSeqCmdSeqDesc(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCSeqCmdSeqDesc>("CSeqCmdSeqDesc")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Name", &GCSeqCmdSeqDesc::GetName, &GCSeqCmdSeqDesc::SetName)
        .addProperty("Flags", &GCSeqCmdSeqDesc::GetFlags, &GCSeqCmdSeqDesc::SetFlags)
        .addProperty("Transition", &GCSeqCmdSeqDesc::GetTransition, &GCSeqCmdSeqDesc::SetTransition)
        .addProperty("FrameRangeSequence", &GCSeqCmdSeqDesc::GetFrameRangeSequence, &GCSeqCmdSeqDesc::SetFrameRangeSequence)
        .addProperty("FrameCount", &GCSeqCmdSeqDesc::GetFrameCount, &GCSeqCmdSeqDesc::SetFrameCount)
        .addProperty("FPS", &GCSeqCmdSeqDesc::GetFPS, &GCSeqCmdSeqDesc::SetFPS)
        .addProperty("SubCycles", &GCSeqCmdSeqDesc::GetSubCycles, &GCSeqCmdSeqDesc::SetSubCycles)
        .addProperty("NumLocalResults", &GCSeqCmdSeqDesc::GetNumLocalResults, &GCSeqCmdSeqDesc::SetNumLocalResults)
        .addProperty("CmdLayerArray", &GCSeqCmdSeqDesc::GetCmdLayerArray, &GCSeqCmdSeqDesc::SetCmdLayerArray)
        .addProperty("EventArray", &GCSeqCmdSeqDesc::GetEventArray, &GCSeqCmdSeqDesc::SetEventArray)
        .addProperty("ActivityArray", &GCSeqCmdSeqDesc::GetActivityArray, &GCSeqCmdSeqDesc::SetActivityArray)
        .addProperty("PoseSettingArray", &GCSeqCmdSeqDesc::GetPoseSettingArray, &GCSeqCmdSeqDesc::SetPoseSettingArray)
        .addFunction("ToPtr", &GCSeqCmdSeqDesc::ToPtr)
        .addFunction("IsValid", &GCSeqCmdSeqDesc::IsValid)
        .endClass();
}
GCPathAnimMotorUpdaterBase::GCPathAnimMotorUpdaterBase(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCPathAnimMotorUpdaterBase::GCPathAnimMotorUpdaterBase(void *ptr) {
    m_ptr = ptr;
}
bool GCPathAnimMotorUpdaterBase::GetLockToPath() const {
    return GetSchemaValue<bool>(m_ptr, "CPathAnimMotorUpdaterBase", "m_bLockToPath");
}
void GCPathAnimMotorUpdaterBase::SetLockToPath(bool value) {
    SetSchemaValue(m_ptr, "CPathAnimMotorUpdaterBase", "m_bLockToPath", false, value);
}
std::string GCPathAnimMotorUpdaterBase::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCPathAnimMotorUpdaterBase::IsValid() {
    return (m_ptr != nullptr);
}
GCAnimMotorUpdaterBase GCPathAnimMotorUpdaterBase::GetParent() const {
    GCAnimMotorUpdaterBase value(m_ptr);
    return value;
}
void GCPathAnimMotorUpdaterBase::SetParent(GCAnimMotorUpdaterBase value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCPathAnimMotorUpdaterBase(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCPathAnimMotorUpdaterBase>("CPathAnimMotorUpdaterBase")
        .addConstructor<void (*)(std::string)>()
        .addProperty("LockToPath", &GCPathAnimMotorUpdaterBase::GetLockToPath, &GCPathAnimMotorUpdaterBase::SetLockToPath)
        .addProperty("Parent", &GCPathAnimMotorUpdaterBase::GetParent, &GCPathAnimMotorUpdaterBase::SetParent)
        .addFunction("ToPtr", &GCPathAnimMotorUpdaterBase::ToPtr)
        .addFunction("IsValid", &GCPathAnimMotorUpdaterBase::IsValid)
        .endClass();
}
GCVariantDefaultAllocator::GCVariantDefaultAllocator(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCVariantDefaultAllocator::GCVariantDefaultAllocator(void *ptr) {
    m_ptr = ptr;
}
std::string GCVariantDefaultAllocator::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCVariantDefaultAllocator::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCVariantDefaultAllocator(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCVariantDefaultAllocator>("CVariantDefaultAllocator")
        .addConstructor<void (*)(std::string)>()
        .addFunction("ToPtr", &GCVariantDefaultAllocator::ToPtr)
        .addFunction("IsValid", &GCVariantDefaultAllocator::IsValid)
        .endClass();
}
GVMixOscDesc_t::GVMixOscDesc_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GVMixOscDesc_t::GVMixOscDesc_t(void *ptr) {
    m_ptr = ptr;
}
uint64_t GVMixOscDesc_t::GetOscType() const {
    return GetSchemaValue<uint64_t>(m_ptr, "VMixOscDesc_t", "oscType");
}
void GVMixOscDesc_t::SetOscType(uint64_t value) {
    SetSchemaValue(m_ptr, "VMixOscDesc_t", "oscType", true, value);
}
float GVMixOscDesc_t::GetFreq() const {
    return GetSchemaValue<float>(m_ptr, "VMixOscDesc_t", "m_freq");
}
void GVMixOscDesc_t::SetFreq(float value) {
    SetSchemaValue(m_ptr, "VMixOscDesc_t", "m_freq", true, value);
}
float GVMixOscDesc_t::GetPhase() const {
    return GetSchemaValue<float>(m_ptr, "VMixOscDesc_t", "m_flPhase");
}
void GVMixOscDesc_t::SetPhase(float value) {
    SetSchemaValue(m_ptr, "VMixOscDesc_t", "m_flPhase", true, value);
}
std::string GVMixOscDesc_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GVMixOscDesc_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassVMixOscDesc_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GVMixOscDesc_t>("VMixOscDesc_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("OscType", &GVMixOscDesc_t::GetOscType, &GVMixOscDesc_t::SetOscType)
        .addProperty("Freq", &GVMixOscDesc_t::GetFreq, &GVMixOscDesc_t::SetFreq)
        .addProperty("Phase", &GVMixOscDesc_t::GetPhase, &GVMixOscDesc_t::SetPhase)
        .addFunction("ToPtr", &GVMixOscDesc_t::ToPtr)
        .addFunction("IsValid", &GVMixOscDesc_t::IsValid)
        .endClass();
}
GFeEdgeDesc_t::GFeEdgeDesc_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GFeEdgeDesc_t::GFeEdgeDesc_t(void *ptr) {
    m_ptr = ptr;
}
std::vector<uint16_t> GFeEdgeDesc_t::GetEdge() const {
    uint16_t* outValue = GetSchemaValue<uint16_t*>(m_ptr, "FeEdgeDesc_t", "nEdge"); std::vector<uint16_t> ret; for(int i = 0; i < 2; i++) { ret.push_back(outValue[i]); } return ret;
}
void GFeEdgeDesc_t::SetEdge(std::vector<uint16_t> value) {
    uint16_t* outValue = GetSchemaValue<uint16_t*>(m_ptr, "FeEdgeDesc_t", "nEdge"); for(int i = 0; i < 2; i++) { outValue[i] = value[i]; } SetSchemaValue(m_ptr, "FeEdgeDesc_t", "nEdge", true, outValue);
}
std::vector<uint16_t> GFeEdgeDesc_t::GetVirtElem() const {
    uint16_t* outValue = GetSchemaValue<uint16_t*>(m_ptr, "FeEdgeDesc_t", "nVirtElem"); std::vector<uint16_t> ret; for(int i = 0; i < 2; i++) { ret.push_back(outValue[i]); } return ret;
}
void GFeEdgeDesc_t::SetVirtElem(std::vector<uint16_t> value) {
    uint16_t* outValue = GetSchemaValue<uint16_t*>(m_ptr, "FeEdgeDesc_t", "nVirtElem"); for(int i = 0; i < 2; i++) { outValue[i] = value[i]; } SetSchemaValue(m_ptr, "FeEdgeDesc_t", "nVirtElem", true, outValue);
}
std::string GFeEdgeDesc_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GFeEdgeDesc_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassFeEdgeDesc_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GFeEdgeDesc_t>("FeEdgeDesc_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Edge", &GFeEdgeDesc_t::GetEdge, &GFeEdgeDesc_t::SetEdge)
        .addProperty("VirtElem", &GFeEdgeDesc_t::GetVirtElem, &GFeEdgeDesc_t::SetVirtElem)
        .addFunction("ToPtr", &GFeEdgeDesc_t::ToPtr)
        .addFunction("IsValid", &GFeEdgeDesc_t::IsValid)
        .endClass();
}
GCPathAnimMotorUpdater::GCPathAnimMotorUpdater(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCPathAnimMotorUpdater::GCPathAnimMotorUpdater(void *ptr) {
    m_ptr = ptr;
}
std::string GCPathAnimMotorUpdater::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCPathAnimMotorUpdater::IsValid() {
    return (m_ptr != nullptr);
}
GCPathAnimMotorUpdaterBase GCPathAnimMotorUpdater::GetParent() const {
    GCPathAnimMotorUpdaterBase value(m_ptr);
    return value;
}
void GCPathAnimMotorUpdater::SetParent(GCPathAnimMotorUpdaterBase value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCPathAnimMotorUpdater(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCPathAnimMotorUpdater>("CPathAnimMotorUpdater")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCPathAnimMotorUpdater::GetParent, &GCPathAnimMotorUpdater::SetParent)
        .addFunction("ToPtr", &GCPathAnimMotorUpdater::ToPtr)
        .addFunction("IsValid", &GCPathAnimMotorUpdater::IsValid)
        .endClass();
}
GCWayPointHelperUpdateNode::GCWayPointHelperUpdateNode(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCWayPointHelperUpdateNode::GCWayPointHelperUpdateNode(void *ptr) {
    m_ptr = ptr;
}
float GCWayPointHelperUpdateNode::GetStartCycle() const {
    return GetSchemaValue<float>(m_ptr, "CWayPointHelperUpdateNode", "m_flStartCycle");
}
void GCWayPointHelperUpdateNode::SetStartCycle(float value) {
    SetSchemaValue(m_ptr, "CWayPointHelperUpdateNode", "m_flStartCycle", false, value);
}
float GCWayPointHelperUpdateNode::GetEndCycle() const {
    return GetSchemaValue<float>(m_ptr, "CWayPointHelperUpdateNode", "m_flEndCycle");
}
void GCWayPointHelperUpdateNode::SetEndCycle(float value) {
    SetSchemaValue(m_ptr, "CWayPointHelperUpdateNode", "m_flEndCycle", false, value);
}
bool GCWayPointHelperUpdateNode::GetOnlyGoals() const {
    return GetSchemaValue<bool>(m_ptr, "CWayPointHelperUpdateNode", "m_bOnlyGoals");
}
void GCWayPointHelperUpdateNode::SetOnlyGoals(bool value) {
    SetSchemaValue(m_ptr, "CWayPointHelperUpdateNode", "m_bOnlyGoals", false, value);
}
bool GCWayPointHelperUpdateNode::GetPreventOvershoot() const {
    return GetSchemaValue<bool>(m_ptr, "CWayPointHelperUpdateNode", "m_bPreventOvershoot");
}
void GCWayPointHelperUpdateNode::SetPreventOvershoot(bool value) {
    SetSchemaValue(m_ptr, "CWayPointHelperUpdateNode", "m_bPreventOvershoot", false, value);
}
bool GCWayPointHelperUpdateNode::GetPreventUndershoot() const {
    return GetSchemaValue<bool>(m_ptr, "CWayPointHelperUpdateNode", "m_bPreventUndershoot");
}
void GCWayPointHelperUpdateNode::SetPreventUndershoot(bool value) {
    SetSchemaValue(m_ptr, "CWayPointHelperUpdateNode", "m_bPreventUndershoot", false, value);
}
std::string GCWayPointHelperUpdateNode::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCWayPointHelperUpdateNode::IsValid() {
    return (m_ptr != nullptr);
}
GCUnaryUpdateNode GCWayPointHelperUpdateNode::GetParent() const {
    GCUnaryUpdateNode value(m_ptr);
    return value;
}
void GCWayPointHelperUpdateNode::SetParent(GCUnaryUpdateNode value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCWayPointHelperUpdateNode(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCWayPointHelperUpdateNode>("CWayPointHelperUpdateNode")
        .addConstructor<void (*)(std::string)>()
        .addProperty("StartCycle", &GCWayPointHelperUpdateNode::GetStartCycle, &GCWayPointHelperUpdateNode::SetStartCycle)
        .addProperty("EndCycle", &GCWayPointHelperUpdateNode::GetEndCycle, &GCWayPointHelperUpdateNode::SetEndCycle)
        .addProperty("OnlyGoals", &GCWayPointHelperUpdateNode::GetOnlyGoals, &GCWayPointHelperUpdateNode::SetOnlyGoals)
        .addProperty("PreventOvershoot", &GCWayPointHelperUpdateNode::GetPreventOvershoot, &GCWayPointHelperUpdateNode::SetPreventOvershoot)
        .addProperty("PreventUndershoot", &GCWayPointHelperUpdateNode::GetPreventUndershoot, &GCWayPointHelperUpdateNode::SetPreventUndershoot)
        .addProperty("Parent", &GCWayPointHelperUpdateNode::GetParent, &GCWayPointHelperUpdateNode::SetParent)
        .addFunction("ToPtr", &GCWayPointHelperUpdateNode::ToPtr)
        .addFunction("IsValid", &GCWayPointHelperUpdateNode::IsValid)
        .endClass();
}
GMaterialParamInt_t::GMaterialParamInt_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GMaterialParamInt_t::GMaterialParamInt_t(void *ptr) {
    m_ptr = ptr;
}
int32_t GMaterialParamInt_t::GetValue() const {
    return GetSchemaValue<int32_t>(m_ptr, "MaterialParamInt_t", "m_nValue");
}
void GMaterialParamInt_t::SetValue(int32_t value) {
    SetSchemaValue(m_ptr, "MaterialParamInt_t", "m_nValue", true, value);
}
std::string GMaterialParamInt_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GMaterialParamInt_t::IsValid() {
    return (m_ptr != nullptr);
}
GMaterialParam_t GMaterialParamInt_t::GetParent() const {
    GMaterialParam_t value(m_ptr);
    return value;
}
void GMaterialParamInt_t::SetParent(GMaterialParam_t value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassMaterialParamInt_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GMaterialParamInt_t>("MaterialParamInt_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Value", &GMaterialParamInt_t::GetValue, &GMaterialParamInt_t::SetValue)
        .addProperty("Parent", &GMaterialParamInt_t::GetParent, &GMaterialParamInt_t::SetParent)
        .addFunction("ToPtr", &GMaterialParamInt_t::ToPtr)
        .addFunction("IsValid", &GMaterialParamInt_t::IsValid)
        .endClass();
}
GPermModelInfo_t::GPermModelInfo_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GPermModelInfo_t::GPermModelInfo_t(void *ptr) {
    m_ptr = ptr;
}
uint32_t GPermModelInfo_t::GetFlags() const {
    return GetSchemaValue<uint32_t>(m_ptr, "PermModelInfo_t", "m_nFlags");
}
void GPermModelInfo_t::SetFlags(uint32_t value) {
    SetSchemaValue(m_ptr, "PermModelInfo_t", "m_nFlags", true, value);
}
Vector GPermModelInfo_t::GetHullMin() const {
    return GetSchemaValue<Vector>(m_ptr, "PermModelInfo_t", "m_vHullMin");
}
void GPermModelInfo_t::SetHullMin(Vector value) {
    SetSchemaValue(m_ptr, "PermModelInfo_t", "m_vHullMin", true, value);
}
Vector GPermModelInfo_t::GetHullMax() const {
    return GetSchemaValue<Vector>(m_ptr, "PermModelInfo_t", "m_vHullMax");
}
void GPermModelInfo_t::SetHullMax(Vector value) {
    SetSchemaValue(m_ptr, "PermModelInfo_t", "m_vHullMax", true, value);
}
Vector GPermModelInfo_t::GetViewMin() const {
    return GetSchemaValue<Vector>(m_ptr, "PermModelInfo_t", "m_vViewMin");
}
void GPermModelInfo_t::SetViewMin(Vector value) {
    SetSchemaValue(m_ptr, "PermModelInfo_t", "m_vViewMin", true, value);
}
Vector GPermModelInfo_t::GetViewMax() const {
    return GetSchemaValue<Vector>(m_ptr, "PermModelInfo_t", "m_vViewMax");
}
void GPermModelInfo_t::SetViewMax(Vector value) {
    SetSchemaValue(m_ptr, "PermModelInfo_t", "m_vViewMax", true, value);
}
float GPermModelInfo_t::GetMass() const {
    return GetSchemaValue<float>(m_ptr, "PermModelInfo_t", "m_flMass");
}
void GPermModelInfo_t::SetMass(float value) {
    SetSchemaValue(m_ptr, "PermModelInfo_t", "m_flMass", true, value);
}
Vector GPermModelInfo_t::GetEyePosition() const {
    return GetSchemaValue<Vector>(m_ptr, "PermModelInfo_t", "m_vEyePosition");
}
void GPermModelInfo_t::SetEyePosition(Vector value) {
    SetSchemaValue(m_ptr, "PermModelInfo_t", "m_vEyePosition", true, value);
}
float GPermModelInfo_t::GetMaxEyeDeflection() const {
    return GetSchemaValue<float>(m_ptr, "PermModelInfo_t", "m_flMaxEyeDeflection");
}
void GPermModelInfo_t::SetMaxEyeDeflection(float value) {
    SetSchemaValue(m_ptr, "PermModelInfo_t", "m_flMaxEyeDeflection", true, value);
}
std::string GPermModelInfo_t::GetSurfaceProperty() const {
    return GetSchemaValue<CUtlString>(m_ptr, "PermModelInfo_t", "m_sSurfaceProperty").Get();
}
void GPermModelInfo_t::SetSurfaceProperty(std::string value) {
    SetSchemaValue(m_ptr, "PermModelInfo_t", "m_sSurfaceProperty", true, CUtlString(value.c_str()));
}
std::string GPermModelInfo_t::GetKeyValueText() const {
    return GetSchemaValue<CUtlString>(m_ptr, "PermModelInfo_t", "m_keyValueText").Get();
}
void GPermModelInfo_t::SetKeyValueText(std::string value) {
    SetSchemaValue(m_ptr, "PermModelInfo_t", "m_keyValueText", true, CUtlString(value.c_str()));
}
std::string GPermModelInfo_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GPermModelInfo_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassPermModelInfo_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GPermModelInfo_t>("PermModelInfo_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Flags", &GPermModelInfo_t::GetFlags, &GPermModelInfo_t::SetFlags)
        .addProperty("HullMin", &GPermModelInfo_t::GetHullMin, &GPermModelInfo_t::SetHullMin)
        .addProperty("HullMax", &GPermModelInfo_t::GetHullMax, &GPermModelInfo_t::SetHullMax)
        .addProperty("ViewMin", &GPermModelInfo_t::GetViewMin, &GPermModelInfo_t::SetViewMin)
        .addProperty("ViewMax", &GPermModelInfo_t::GetViewMax, &GPermModelInfo_t::SetViewMax)
        .addProperty("Mass", &GPermModelInfo_t::GetMass, &GPermModelInfo_t::SetMass)
        .addProperty("EyePosition", &GPermModelInfo_t::GetEyePosition, &GPermModelInfo_t::SetEyePosition)
        .addProperty("MaxEyeDeflection", &GPermModelInfo_t::GetMaxEyeDeflection, &GPermModelInfo_t::SetMaxEyeDeflection)
        .addProperty("SurfaceProperty", &GPermModelInfo_t::GetSurfaceProperty, &GPermModelInfo_t::SetSurfaceProperty)
        .addProperty("KeyValueText", &GPermModelInfo_t::GetKeyValueText, &GPermModelInfo_t::SetKeyValueText)
        .addFunction("ToPtr", &GPermModelInfo_t::ToPtr)
        .addFunction("IsValid", &GPermModelInfo_t::IsValid)
        .endClass();
}
GAnimScriptHandle::GAnimScriptHandle(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GAnimScriptHandle::GAnimScriptHandle(void *ptr) {
    m_ptr = ptr;
}
uint32_t GAnimScriptHandle::GetId() const {
    return GetSchemaValue<uint32_t>(m_ptr, "AnimScriptHandle", "m_id");
}
void GAnimScriptHandle::SetId(uint32_t value) {
    SetSchemaValue(m_ptr, "AnimScriptHandle", "m_id", false, value);
}
std::string GAnimScriptHandle::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GAnimScriptHandle::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassAnimScriptHandle(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GAnimScriptHandle>("AnimScriptHandle")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Id", &GAnimScriptHandle::GetId, &GAnimScriptHandle::SetId)
        .addFunction("ToPtr", &GAnimScriptHandle::ToPtr)
        .addFunction("IsValid", &GAnimScriptHandle::IsValid)
        .endClass();
}
GFeCtrlOffset_t::GFeCtrlOffset_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GFeCtrlOffset_t::GFeCtrlOffset_t(void *ptr) {
    m_ptr = ptr;
}
Vector GFeCtrlOffset_t::GetOffset() const {
    return GetSchemaValue<Vector>(m_ptr, "FeCtrlOffset_t", "vOffset");
}
void GFeCtrlOffset_t::SetOffset(Vector value) {
    SetSchemaValue(m_ptr, "FeCtrlOffset_t", "vOffset", true, value);
}
uint16_t GFeCtrlOffset_t::GetCtrlParent() const {
    return GetSchemaValue<uint16_t>(m_ptr, "FeCtrlOffset_t", "nCtrlParent");
}
void GFeCtrlOffset_t::SetCtrlParent(uint16_t value) {
    SetSchemaValue(m_ptr, "FeCtrlOffset_t", "nCtrlParent", true, value);
}
uint16_t GFeCtrlOffset_t::GetCtrlChild() const {
    return GetSchemaValue<uint16_t>(m_ptr, "FeCtrlOffset_t", "nCtrlChild");
}
void GFeCtrlOffset_t::SetCtrlChild(uint16_t value) {
    SetSchemaValue(m_ptr, "FeCtrlOffset_t", "nCtrlChild", true, value);
}
std::string GFeCtrlOffset_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GFeCtrlOffset_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassFeCtrlOffset_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GFeCtrlOffset_t>("FeCtrlOffset_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Offset", &GFeCtrlOffset_t::GetOffset, &GFeCtrlOffset_t::SetOffset)
        .addProperty("CtrlParent", &GFeCtrlOffset_t::GetCtrlParent, &GFeCtrlOffset_t::SetCtrlParent)
        .addProperty("CtrlChild", &GFeCtrlOffset_t::GetCtrlChild, &GFeCtrlOffset_t::SetCtrlChild)
        .addFunction("ToPtr", &GFeCtrlOffset_t::ToPtr)
        .addFunction("IsValid", &GFeCtrlOffset_t::IsValid)
        .endClass();
}
GFeTri_t::GFeTri_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GFeTri_t::GFeTri_t(void *ptr) {
    m_ptr = ptr;
}
std::vector<uint16_t> GFeTri_t::GetNode() const {
    uint16_t* outValue = GetSchemaValue<uint16_t*>(m_ptr, "FeTri_t", "nNode"); std::vector<uint16_t> ret; for(int i = 0; i < 3; i++) { ret.push_back(outValue[i]); } return ret;
}
void GFeTri_t::SetNode(std::vector<uint16_t> value) {
    uint16_t* outValue = GetSchemaValue<uint16_t*>(m_ptr, "FeTri_t", "nNode"); for(int i = 0; i < 3; i++) { outValue[i] = value[i]; } SetSchemaValue(m_ptr, "FeTri_t", "nNode", true, outValue);
}
float GFeTri_t::GetW1() const {
    return GetSchemaValue<float>(m_ptr, "FeTri_t", "w1");
}
void GFeTri_t::SetW1(float value) {
    SetSchemaValue(m_ptr, "FeTri_t", "w1", true, value);
}
float GFeTri_t::GetW2() const {
    return GetSchemaValue<float>(m_ptr, "FeTri_t", "w2");
}
void GFeTri_t::SetW2(float value) {
    SetSchemaValue(m_ptr, "FeTri_t", "w2", true, value);
}
float GFeTri_t::Get1x() const {
    return GetSchemaValue<float>(m_ptr, "FeTri_t", "v1x");
}
void GFeTri_t::Set1x(float value) {
    SetSchemaValue(m_ptr, "FeTri_t", "v1x", true, value);
}
Vector2D GFeTri_t::Get2() const {
    return GetSchemaValue<Vector2D>(m_ptr, "FeTri_t", "v2");
}
void GFeTri_t::Set2(Vector2D value) {
    SetSchemaValue(m_ptr, "FeTri_t", "v2", true, value);
}
std::string GFeTri_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GFeTri_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassFeTri_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GFeTri_t>("FeTri_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Node", &GFeTri_t::GetNode, &GFeTri_t::SetNode)
        .addProperty("W1", &GFeTri_t::GetW1, &GFeTri_t::SetW1)
        .addProperty("W2", &GFeTri_t::GetW2, &GFeTri_t::SetW2)
        .addProperty("1x", &GFeTri_t::Get1x, &GFeTri_t::Set1x)
        .addProperty("2", &GFeTri_t::Get2, &GFeTri_t::Set2)
        .addFunction("ToPtr", &GFeTri_t::ToPtr)
        .addFunction("IsValid", &GFeTri_t::IsValid)
        .endClass();
}
GCLeanMatrixUpdateNode::GCLeanMatrixUpdateNode(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCLeanMatrixUpdateNode::GCLeanMatrixUpdateNode(void *ptr) {
    m_ptr = ptr;
}
std::vector<GCPoseHandle> GCLeanMatrixUpdateNode::GetPoses() const {
    GCPoseHandle* outValue = GetSchemaValue<GCPoseHandle*>(m_ptr, "CLeanMatrixUpdateNode", "m_poses"); std::vector<GCPoseHandle> ret; for(int i = 0; i < 9; i++) { ret.push_back(outValue[i]); } return ret;
}
void GCLeanMatrixUpdateNode::SetPoses(std::vector<GCPoseHandle> value) {
    GCPoseHandle* outValue = GetSchemaValue<GCPoseHandle*>(m_ptr, "CLeanMatrixUpdateNode", "m_poses"); for(int i = 0; i < 9; i++) { outValue[i] = value[i]; } SetSchemaValue(m_ptr, "CLeanMatrixUpdateNode", "m_poses", false, outValue);
}
GCAnimInputDamping GCLeanMatrixUpdateNode::GetDamping() const {
    GCAnimInputDamping value(GetSchemaPtr(m_ptr, "CLeanMatrixUpdateNode", "m_damping"));
    return value;
}
void GCLeanMatrixUpdateNode::SetDamping(GCAnimInputDamping value) {
    SetSchemaValue(m_ptr, "CLeanMatrixUpdateNode", "m_damping", false, value);
}
uint64_t GCLeanMatrixUpdateNode::GetBlendSource() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CLeanMatrixUpdateNode", "m_blendSource");
}
void GCLeanMatrixUpdateNode::SetBlendSource(uint64_t value) {
    SetSchemaValue(m_ptr, "CLeanMatrixUpdateNode", "m_blendSource", false, value);
}
GCAnimParamHandle GCLeanMatrixUpdateNode::GetParamIndex() const {
    GCAnimParamHandle value(GetSchemaPtr(m_ptr, "CLeanMatrixUpdateNode", "m_paramIndex"));
    return value;
}
void GCLeanMatrixUpdateNode::SetParamIndex(GCAnimParamHandle value) {
    SetSchemaValue(m_ptr, "CLeanMatrixUpdateNode", "m_paramIndex", false, value);
}
Vector GCLeanMatrixUpdateNode::GetVerticalAxis() const {
    return GetSchemaValue<Vector>(m_ptr, "CLeanMatrixUpdateNode", "m_verticalAxis");
}
void GCLeanMatrixUpdateNode::SetVerticalAxis(Vector value) {
    SetSchemaValue(m_ptr, "CLeanMatrixUpdateNode", "m_verticalAxis", false, value);
}
Vector GCLeanMatrixUpdateNode::GetHorizontalAxis() const {
    return GetSchemaValue<Vector>(m_ptr, "CLeanMatrixUpdateNode", "m_horizontalAxis");
}
void GCLeanMatrixUpdateNode::SetHorizontalAxis(Vector value) {
    SetSchemaValue(m_ptr, "CLeanMatrixUpdateNode", "m_horizontalAxis", false, value);
}
float GCLeanMatrixUpdateNode::GetMaxValue() const {
    return GetSchemaValue<float>(m_ptr, "CLeanMatrixUpdateNode", "m_flMaxValue");
}
void GCLeanMatrixUpdateNode::SetMaxValue(float value) {
    SetSchemaValue(m_ptr, "CLeanMatrixUpdateNode", "m_flMaxValue", false, value);
}
int32_t GCLeanMatrixUpdateNode::GetSequenceMaxFrame() const {
    return GetSchemaValue<int32_t>(m_ptr, "CLeanMatrixUpdateNode", "m_nSequenceMaxFrame");
}
void GCLeanMatrixUpdateNode::SetSequenceMaxFrame(int32_t value) {
    SetSchemaValue(m_ptr, "CLeanMatrixUpdateNode", "m_nSequenceMaxFrame", false, value);
}
std::string GCLeanMatrixUpdateNode::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCLeanMatrixUpdateNode::IsValid() {
    return (m_ptr != nullptr);
}
GCLeafUpdateNode GCLeanMatrixUpdateNode::GetParent() const {
    GCLeafUpdateNode value(m_ptr);
    return value;
}
void GCLeanMatrixUpdateNode::SetParent(GCLeafUpdateNode value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCLeanMatrixUpdateNode(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCLeanMatrixUpdateNode>("CLeanMatrixUpdateNode")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Poses", &GCLeanMatrixUpdateNode::GetPoses, &GCLeanMatrixUpdateNode::SetPoses)
        .addProperty("Damping", &GCLeanMatrixUpdateNode::GetDamping, &GCLeanMatrixUpdateNode::SetDamping)
        .addProperty("BlendSource", &GCLeanMatrixUpdateNode::GetBlendSource, &GCLeanMatrixUpdateNode::SetBlendSource)
        .addProperty("ParamIndex", &GCLeanMatrixUpdateNode::GetParamIndex, &GCLeanMatrixUpdateNode::SetParamIndex)
        .addProperty("VerticalAxis", &GCLeanMatrixUpdateNode::GetVerticalAxis, &GCLeanMatrixUpdateNode::SetVerticalAxis)
        .addProperty("HorizontalAxis", &GCLeanMatrixUpdateNode::GetHorizontalAxis, &GCLeanMatrixUpdateNode::SetHorizontalAxis)
        .addProperty("MaxValue", &GCLeanMatrixUpdateNode::GetMaxValue, &GCLeanMatrixUpdateNode::SetMaxValue)
        .addProperty("SequenceMaxFrame", &GCLeanMatrixUpdateNode::GetSequenceMaxFrame, &GCLeanMatrixUpdateNode::SetSequenceMaxFrame)
        .addProperty("Parent", &GCLeanMatrixUpdateNode::GetParent, &GCLeanMatrixUpdateNode::SetParent)
        .addFunction("ToPtr", &GCLeanMatrixUpdateNode::ToPtr)
        .addFunction("IsValid", &GCLeanMatrixUpdateNode::IsValid)
        .endClass();
}
GCStanceScaleUpdateNode::GCStanceScaleUpdateNode(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCStanceScaleUpdateNode::GCStanceScaleUpdateNode(void *ptr) {
    m_ptr = ptr;
}
GCAnimParamHandle GCStanceScaleUpdateNode::GetParam() const {
    GCAnimParamHandle value(GetSchemaPtr(m_ptr, "CStanceScaleUpdateNode", "m_hParam"));
    return value;
}
void GCStanceScaleUpdateNode::SetParam(GCAnimParamHandle value) {
    SetSchemaValue(m_ptr, "CStanceScaleUpdateNode", "m_hParam", false, value);
}
std::string GCStanceScaleUpdateNode::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCStanceScaleUpdateNode::IsValid() {
    return (m_ptr != nullptr);
}
GCUnaryUpdateNode GCStanceScaleUpdateNode::GetParent() const {
    GCUnaryUpdateNode value(m_ptr);
    return value;
}
void GCStanceScaleUpdateNode::SetParent(GCUnaryUpdateNode value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCStanceScaleUpdateNode(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCStanceScaleUpdateNode>("CStanceScaleUpdateNode")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Param", &GCStanceScaleUpdateNode::GetParam, &GCStanceScaleUpdateNode::SetParam)
        .addProperty("Parent", &GCStanceScaleUpdateNode::GetParent, &GCStanceScaleUpdateNode::SetParent)
        .addFunction("ToPtr", &GCStanceScaleUpdateNode::ToPtr)
        .addFunction("IsValid", &GCStanceScaleUpdateNode::IsValid)
        .endClass();
}
GIKTargetSettings_t::GIKTargetSettings_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GIKTargetSettings_t::GIKTargetSettings_t(void *ptr) {
    m_ptr = ptr;
}
uint64_t GIKTargetSettings_t::GetTargetSource() const {
    return GetSchemaValue<uint64_t>(m_ptr, "IKTargetSettings_t", "m_TargetSource");
}
void GIKTargetSettings_t::SetTargetSource(uint64_t value) {
    SetSchemaValue(m_ptr, "IKTargetSettings_t", "m_TargetSource", true, value);
}
GIKBoneNameAndIndex_t GIKTargetSettings_t::GetBone() const {
    GIKBoneNameAndIndex_t value(GetSchemaPtr(m_ptr, "IKTargetSettings_t", "m_Bone"));
    return value;
}
void GIKTargetSettings_t::SetBone(GIKBoneNameAndIndex_t value) {
    SetSchemaValue(m_ptr, "IKTargetSettings_t", "m_Bone", true, value);
}
GAnimParamID GIKTargetSettings_t::GetAnimgraphParameterNamePosition() const {
    GAnimParamID value(GetSchemaPtr(m_ptr, "IKTargetSettings_t", "m_AnimgraphParameterNamePosition"));
    return value;
}
void GIKTargetSettings_t::SetAnimgraphParameterNamePosition(GAnimParamID value) {
    SetSchemaValue(m_ptr, "IKTargetSettings_t", "m_AnimgraphParameterNamePosition", true, value);
}
GAnimParamID GIKTargetSettings_t::GetAnimgraphParameterNameOrientation() const {
    GAnimParamID value(GetSchemaPtr(m_ptr, "IKTargetSettings_t", "m_AnimgraphParameterNameOrientation"));
    return value;
}
void GIKTargetSettings_t::SetAnimgraphParameterNameOrientation(GAnimParamID value) {
    SetSchemaValue(m_ptr, "IKTargetSettings_t", "m_AnimgraphParameterNameOrientation", true, value);
}
uint64_t GIKTargetSettings_t::GetTargetCoordSystem() const {
    return GetSchemaValue<uint64_t>(m_ptr, "IKTargetSettings_t", "m_TargetCoordSystem");
}
void GIKTargetSettings_t::SetTargetCoordSystem(uint64_t value) {
    SetSchemaValue(m_ptr, "IKTargetSettings_t", "m_TargetCoordSystem", true, value);
}
std::string GIKTargetSettings_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GIKTargetSettings_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassIKTargetSettings_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GIKTargetSettings_t>("IKTargetSettings_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("TargetSource", &GIKTargetSettings_t::GetTargetSource, &GIKTargetSettings_t::SetTargetSource)
        .addProperty("Bone", &GIKTargetSettings_t::GetBone, &GIKTargetSettings_t::SetBone)
        .addProperty("AnimgraphParameterNamePosition", &GIKTargetSettings_t::GetAnimgraphParameterNamePosition, &GIKTargetSettings_t::SetAnimgraphParameterNamePosition)
        .addProperty("AnimgraphParameterNameOrientation", &GIKTargetSettings_t::GetAnimgraphParameterNameOrientation, &GIKTargetSettings_t::SetAnimgraphParameterNameOrientation)
        .addProperty("TargetCoordSystem", &GIKTargetSettings_t::GetTargetCoordSystem, &GIKTargetSettings_t::SetTargetCoordSystem)
        .addFunction("ToPtr", &GIKTargetSettings_t::ToPtr)
        .addFunction("IsValid", &GIKTargetSettings_t::IsValid)
        .endClass();
}
GTestResource_t::GTestResource_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GTestResource_t::GTestResource_t(void *ptr) {
    m_ptr = ptr;
}
std::string GTestResource_t::GetName() const {
    return GetSchemaValue<CUtlString>(m_ptr, "TestResource_t", "m_name").Get();
}
void GTestResource_t::SetName(std::string value) {
    SetSchemaValue(m_ptr, "TestResource_t", "m_name", true, CUtlString(value.c_str()));
}
std::string GTestResource_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GTestResource_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassTestResource_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GTestResource_t>("TestResource_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Name", &GTestResource_t::GetName, &GTestResource_t::SetName)
        .addFunction("ToPtr", &GTestResource_t::ToPtr)
        .addFunction("IsValid", &GTestResource_t::IsValid)
        .endClass();
}
GCBaseRendererSource2::GCBaseRendererSource2(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCBaseRendererSource2::GCBaseRendererSource2(void *ptr) {
    m_ptr = ptr;
}
GCParticleCollectionRendererFloatInput GCBaseRendererSource2::GetRadiusScale() const {
    GCParticleCollectionRendererFloatInput value(GetSchemaPtr(m_ptr, "CBaseRendererSource2", "m_flRadiusScale"));
    return value;
}
void GCBaseRendererSource2::SetRadiusScale(GCParticleCollectionRendererFloatInput value) {
    SetSchemaValue(m_ptr, "CBaseRendererSource2", "m_flRadiusScale", false, value);
}
GCParticleCollectionRendererFloatInput GCBaseRendererSource2::GetAlphaScale() const {
    GCParticleCollectionRendererFloatInput value(GetSchemaPtr(m_ptr, "CBaseRendererSource2", "m_flAlphaScale"));
    return value;
}
void GCBaseRendererSource2::SetAlphaScale(GCParticleCollectionRendererFloatInput value) {
    SetSchemaValue(m_ptr, "CBaseRendererSource2", "m_flAlphaScale", false, value);
}
GCParticleCollectionRendererFloatInput GCBaseRendererSource2::GetRollScale() const {
    GCParticleCollectionRendererFloatInput value(GetSchemaPtr(m_ptr, "CBaseRendererSource2", "m_flRollScale"));
    return value;
}
void GCBaseRendererSource2::SetRollScale(GCParticleCollectionRendererFloatInput value) {
    SetSchemaValue(m_ptr, "CBaseRendererSource2", "m_flRollScale", false, value);
}
GParticleAttributeIndex_t GCBaseRendererSource2::GetAlpha2Field() const {
    GParticleAttributeIndex_t value(GetSchemaPtr(m_ptr, "CBaseRendererSource2", "m_nAlpha2Field"));
    return value;
}
void GCBaseRendererSource2::SetAlpha2Field(GParticleAttributeIndex_t value) {
    SetSchemaValue(m_ptr, "CBaseRendererSource2", "m_nAlpha2Field", false, value);
}
GCParticleCollectionRendererVecInput GCBaseRendererSource2::GetColorScale() const {
    GCParticleCollectionRendererVecInput value(GetSchemaPtr(m_ptr, "CBaseRendererSource2", "m_vecColorScale"));
    return value;
}
void GCBaseRendererSource2::SetColorScale(GCParticleCollectionRendererVecInput value) {
    SetSchemaValue(m_ptr, "CBaseRendererSource2", "m_vecColorScale", false, value);
}
uint64_t GCBaseRendererSource2::GetColorBlendType() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CBaseRendererSource2", "m_nColorBlendType");
}
void GCBaseRendererSource2::SetColorBlendType(uint64_t value) {
    SetSchemaValue(m_ptr, "CBaseRendererSource2", "m_nColorBlendType", false, value);
}
uint64_t GCBaseRendererSource2::GetShaderType() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CBaseRendererSource2", "m_nShaderType");
}
void GCBaseRendererSource2::SetShaderType(uint64_t value) {
    SetSchemaValue(m_ptr, "CBaseRendererSource2", "m_nShaderType", false, value);
}
std::string GCBaseRendererSource2::GetStrShaderOverride() const {
    return GetSchemaValue<CUtlString>(m_ptr, "CBaseRendererSource2", "m_strShaderOverride").Get();
}
void GCBaseRendererSource2::SetStrShaderOverride(std::string value) {
    SetSchemaValue(m_ptr, "CBaseRendererSource2", "m_strShaderOverride", false, CUtlString(value.c_str()));
}
GCParticleCollectionRendererFloatInput GCBaseRendererSource2::GetCenterXOffset() const {
    GCParticleCollectionRendererFloatInput value(GetSchemaPtr(m_ptr, "CBaseRendererSource2", "m_flCenterXOffset"));
    return value;
}
void GCBaseRendererSource2::SetCenterXOffset(GCParticleCollectionRendererFloatInput value) {
    SetSchemaValue(m_ptr, "CBaseRendererSource2", "m_flCenterXOffset", false, value);
}
GCParticleCollectionRendererFloatInput GCBaseRendererSource2::GetCenterYOffset() const {
    GCParticleCollectionRendererFloatInput value(GetSchemaPtr(m_ptr, "CBaseRendererSource2", "m_flCenterYOffset"));
    return value;
}
void GCBaseRendererSource2::SetCenterYOffset(GCParticleCollectionRendererFloatInput value) {
    SetSchemaValue(m_ptr, "CBaseRendererSource2", "m_flCenterYOffset", false, value);
}
float GCBaseRendererSource2::GetBumpStrength() const {
    return GetSchemaValue<float>(m_ptr, "CBaseRendererSource2", "m_flBumpStrength");
}
void GCBaseRendererSource2::SetBumpStrength(float value) {
    SetSchemaValue(m_ptr, "CBaseRendererSource2", "m_flBumpStrength", false, value);
}
uint64_t GCBaseRendererSource2::GetCropTextureOverride() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CBaseRendererSource2", "m_nCropTextureOverride");
}
void GCBaseRendererSource2::SetCropTextureOverride(uint64_t value) {
    SetSchemaValue(m_ptr, "CBaseRendererSource2", "m_nCropTextureOverride", false, value);
}
std::vector<GTextureGroup_t> GCBaseRendererSource2::GetTexturesInput() const {
    CUtlVector<GTextureGroup_t>* vec = GetSchemaValue<CUtlVector<GTextureGroup_t>*>(m_ptr, "CBaseRendererSource2", "m_vecTexturesInput"); std::vector<GTextureGroup_t> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCBaseRendererSource2::SetTexturesInput(std::vector<GTextureGroup_t> value) {
    SetSchemaValueCUtlVector<GTextureGroup_t>(m_ptr, "CBaseRendererSource2", "m_vecTexturesInput", false, value);
}
float GCBaseRendererSource2::GetAnimationRate() const {
    return GetSchemaValue<float>(m_ptr, "CBaseRendererSource2", "m_flAnimationRate");
}
void GCBaseRendererSource2::SetAnimationRate(float value) {
    SetSchemaValue(m_ptr, "CBaseRendererSource2", "m_flAnimationRate", false, value);
}
uint64_t GCBaseRendererSource2::GetAnimationType() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CBaseRendererSource2", "m_nAnimationType");
}
void GCBaseRendererSource2::SetAnimationType(uint64_t value) {
    SetSchemaValue(m_ptr, "CBaseRendererSource2", "m_nAnimationType", false, value);
}
bool GCBaseRendererSource2::GetAnimateInFPS() const {
    return GetSchemaValue<bool>(m_ptr, "CBaseRendererSource2", "m_bAnimateInFPS");
}
void GCBaseRendererSource2::SetAnimateInFPS(bool value) {
    SetSchemaValue(m_ptr, "CBaseRendererSource2", "m_bAnimateInFPS", false, value);
}
GCParticleCollectionRendererFloatInput GCBaseRendererSource2::GetSelfIllumAmount() const {
    GCParticleCollectionRendererFloatInput value(GetSchemaPtr(m_ptr, "CBaseRendererSource2", "m_flSelfIllumAmount"));
    return value;
}
void GCBaseRendererSource2::SetSelfIllumAmount(GCParticleCollectionRendererFloatInput value) {
    SetSchemaValue(m_ptr, "CBaseRendererSource2", "m_flSelfIllumAmount", false, value);
}
GCParticleCollectionRendererFloatInput GCBaseRendererSource2::GetDiffuseAmount() const {
    GCParticleCollectionRendererFloatInput value(GetSchemaPtr(m_ptr, "CBaseRendererSource2", "m_flDiffuseAmount"));
    return value;
}
void GCBaseRendererSource2::SetDiffuseAmount(GCParticleCollectionRendererFloatInput value) {
    SetSchemaValue(m_ptr, "CBaseRendererSource2", "m_flDiffuseAmount", false, value);
}
GCParticleCollectionRendererFloatInput GCBaseRendererSource2::GetDiffuseClamp() const {
    GCParticleCollectionRendererFloatInput value(GetSchemaPtr(m_ptr, "CBaseRendererSource2", "m_flDiffuseClamp"));
    return value;
}
void GCBaseRendererSource2::SetDiffuseClamp(GCParticleCollectionRendererFloatInput value) {
    SetSchemaValue(m_ptr, "CBaseRendererSource2", "m_flDiffuseClamp", false, value);
}
int32_t GCBaseRendererSource2::GetLightingControlPoint() const {
    return GetSchemaValue<int32_t>(m_ptr, "CBaseRendererSource2", "m_nLightingControlPoint");
}
void GCBaseRendererSource2::SetLightingControlPoint(int32_t value) {
    SetSchemaValue(m_ptr, "CBaseRendererSource2", "m_nLightingControlPoint", false, value);
}
GParticleAttributeIndex_t GCBaseRendererSource2::GetSelfIllumPerParticle() const {
    GParticleAttributeIndex_t value(GetSchemaPtr(m_ptr, "CBaseRendererSource2", "m_nSelfIllumPerParticle"));
    return value;
}
void GCBaseRendererSource2::SetSelfIllumPerParticle(GParticleAttributeIndex_t value) {
    SetSchemaValue(m_ptr, "CBaseRendererSource2", "m_nSelfIllumPerParticle", false, value);
}
uint64_t GCBaseRendererSource2::GetOutputBlendMode() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CBaseRendererSource2", "m_nOutputBlendMode");
}
void GCBaseRendererSource2::SetOutputBlendMode(uint64_t value) {
    SetSchemaValue(m_ptr, "CBaseRendererSource2", "m_nOutputBlendMode", false, value);
}
bool GCBaseRendererSource2::GetGammaCorrectVertexColors() const {
    return GetSchemaValue<bool>(m_ptr, "CBaseRendererSource2", "m_bGammaCorrectVertexColors");
}
void GCBaseRendererSource2::SetGammaCorrectVertexColors(bool value) {
    SetSchemaValue(m_ptr, "CBaseRendererSource2", "m_bGammaCorrectVertexColors", false, value);
}
bool GCBaseRendererSource2::GetSaturateColorPreAlphaBlend() const {
    return GetSchemaValue<bool>(m_ptr, "CBaseRendererSource2", "m_bSaturateColorPreAlphaBlend");
}
void GCBaseRendererSource2::SetSaturateColorPreAlphaBlend(bool value) {
    SetSchemaValue(m_ptr, "CBaseRendererSource2", "m_bSaturateColorPreAlphaBlend", false, value);
}
GCParticleCollectionRendererFloatInput GCBaseRendererSource2::GetAddSelfAmount() const {
    GCParticleCollectionRendererFloatInput value(GetSchemaPtr(m_ptr, "CBaseRendererSource2", "m_flAddSelfAmount"));
    return value;
}
void GCBaseRendererSource2::SetAddSelfAmount(GCParticleCollectionRendererFloatInput value) {
    SetSchemaValue(m_ptr, "CBaseRendererSource2", "m_flAddSelfAmount", false, value);
}
GCParticleCollectionRendererFloatInput GCBaseRendererSource2::GetDesaturation() const {
    GCParticleCollectionRendererFloatInput value(GetSchemaPtr(m_ptr, "CBaseRendererSource2", "m_flDesaturation"));
    return value;
}
void GCBaseRendererSource2::SetDesaturation(GCParticleCollectionRendererFloatInput value) {
    SetSchemaValue(m_ptr, "CBaseRendererSource2", "m_flDesaturation", false, value);
}
GCParticleCollectionRendererFloatInput GCBaseRendererSource2::GetOverbrightFactor() const {
    GCParticleCollectionRendererFloatInput value(GetSchemaPtr(m_ptr, "CBaseRendererSource2", "m_flOverbrightFactor"));
    return value;
}
void GCBaseRendererSource2::SetOverbrightFactor(GCParticleCollectionRendererFloatInput value) {
    SetSchemaValue(m_ptr, "CBaseRendererSource2", "m_flOverbrightFactor", false, value);
}
int32_t GCBaseRendererSource2::GetHSVShiftControlPoint() const {
    return GetSchemaValue<int32_t>(m_ptr, "CBaseRendererSource2", "m_nHSVShiftControlPoint");
}
void GCBaseRendererSource2::SetHSVShiftControlPoint(int32_t value) {
    SetSchemaValue(m_ptr, "CBaseRendererSource2", "m_nHSVShiftControlPoint", false, value);
}
uint64_t GCBaseRendererSource2::GetFogType() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CBaseRendererSource2", "m_nFogType");
}
void GCBaseRendererSource2::SetFogType(uint64_t value) {
    SetSchemaValue(m_ptr, "CBaseRendererSource2", "m_nFogType", false, value);
}
GCParticleCollectionRendererFloatInput GCBaseRendererSource2::GetFogAmount() const {
    GCParticleCollectionRendererFloatInput value(GetSchemaPtr(m_ptr, "CBaseRendererSource2", "m_flFogAmount"));
    return value;
}
void GCBaseRendererSource2::SetFogAmount(GCParticleCollectionRendererFloatInput value) {
    SetSchemaValue(m_ptr, "CBaseRendererSource2", "m_flFogAmount", false, value);
}
bool GCBaseRendererSource2::GetTintByFOW() const {
    return GetSchemaValue<bool>(m_ptr, "CBaseRendererSource2", "m_bTintByFOW");
}
void GCBaseRendererSource2::SetTintByFOW(bool value) {
    SetSchemaValue(m_ptr, "CBaseRendererSource2", "m_bTintByFOW", false, value);
}
bool GCBaseRendererSource2::GetTintByGlobalLight() const {
    return GetSchemaValue<bool>(m_ptr, "CBaseRendererSource2", "m_bTintByGlobalLight");
}
void GCBaseRendererSource2::SetTintByGlobalLight(bool value) {
    SetSchemaValue(m_ptr, "CBaseRendererSource2", "m_bTintByGlobalLight", false, value);
}
uint64_t GCBaseRendererSource2::GetPerParticleAlphaReference() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CBaseRendererSource2", "m_nPerParticleAlphaReference");
}
void GCBaseRendererSource2::SetPerParticleAlphaReference(uint64_t value) {
    SetSchemaValue(m_ptr, "CBaseRendererSource2", "m_nPerParticleAlphaReference", false, value);
}
uint64_t GCBaseRendererSource2::GetPerParticleAlphaRefWindow() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CBaseRendererSource2", "m_nPerParticleAlphaRefWindow");
}
void GCBaseRendererSource2::SetPerParticleAlphaRefWindow(uint64_t value) {
    SetSchemaValue(m_ptr, "CBaseRendererSource2", "m_nPerParticleAlphaRefWindow", false, value);
}
uint64_t GCBaseRendererSource2::GetAlphaReferenceType() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CBaseRendererSource2", "m_nAlphaReferenceType");
}
void GCBaseRendererSource2::SetAlphaReferenceType(uint64_t value) {
    SetSchemaValue(m_ptr, "CBaseRendererSource2", "m_nAlphaReferenceType", false, value);
}
GCParticleCollectionRendererFloatInput GCBaseRendererSource2::GetAlphaReferenceSoftness() const {
    GCParticleCollectionRendererFloatInput value(GetSchemaPtr(m_ptr, "CBaseRendererSource2", "m_flAlphaReferenceSoftness"));
    return value;
}
void GCBaseRendererSource2::SetAlphaReferenceSoftness(GCParticleCollectionRendererFloatInput value) {
    SetSchemaValue(m_ptr, "CBaseRendererSource2", "m_flAlphaReferenceSoftness", false, value);
}
GCParticleCollectionRendererFloatInput GCBaseRendererSource2::GetSourceAlphaValueToMapToZero() const {
    GCParticleCollectionRendererFloatInput value(GetSchemaPtr(m_ptr, "CBaseRendererSource2", "m_flSourceAlphaValueToMapToZero"));
    return value;
}
void GCBaseRendererSource2::SetSourceAlphaValueToMapToZero(GCParticleCollectionRendererFloatInput value) {
    SetSchemaValue(m_ptr, "CBaseRendererSource2", "m_flSourceAlphaValueToMapToZero", false, value);
}
GCParticleCollectionRendererFloatInput GCBaseRendererSource2::GetSourceAlphaValueToMapToOne() const {
    GCParticleCollectionRendererFloatInput value(GetSchemaPtr(m_ptr, "CBaseRendererSource2", "m_flSourceAlphaValueToMapToOne"));
    return value;
}
void GCBaseRendererSource2::SetSourceAlphaValueToMapToOne(GCParticleCollectionRendererFloatInput value) {
    SetSchemaValue(m_ptr, "CBaseRendererSource2", "m_flSourceAlphaValueToMapToOne", false, value);
}
bool GCBaseRendererSource2::GetRefract() const {
    return GetSchemaValue<bool>(m_ptr, "CBaseRendererSource2", "m_bRefract");
}
void GCBaseRendererSource2::SetRefract(bool value) {
    SetSchemaValue(m_ptr, "CBaseRendererSource2", "m_bRefract", false, value);
}
bool GCBaseRendererSource2::GetRefractSolid() const {
    return GetSchemaValue<bool>(m_ptr, "CBaseRendererSource2", "m_bRefractSolid");
}
void GCBaseRendererSource2::SetRefractSolid(bool value) {
    SetSchemaValue(m_ptr, "CBaseRendererSource2", "m_bRefractSolid", false, value);
}
GCParticleCollectionRendererFloatInput GCBaseRendererSource2::GetRefractAmount() const {
    GCParticleCollectionRendererFloatInput value(GetSchemaPtr(m_ptr, "CBaseRendererSource2", "m_flRefractAmount"));
    return value;
}
void GCBaseRendererSource2::SetRefractAmount(GCParticleCollectionRendererFloatInput value) {
    SetSchemaValue(m_ptr, "CBaseRendererSource2", "m_flRefractAmount", false, value);
}
int32_t GCBaseRendererSource2::GetRefractBlurRadius() const {
    return GetSchemaValue<int32_t>(m_ptr, "CBaseRendererSource2", "m_nRefractBlurRadius");
}
void GCBaseRendererSource2::SetRefractBlurRadius(int32_t value) {
    SetSchemaValue(m_ptr, "CBaseRendererSource2", "m_nRefractBlurRadius", false, value);
}
uint64_t GCBaseRendererSource2::GetRefractBlurType() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CBaseRendererSource2", "m_nRefractBlurType");
}
void GCBaseRendererSource2::SetRefractBlurType(uint64_t value) {
    SetSchemaValue(m_ptr, "CBaseRendererSource2", "m_nRefractBlurType", false, value);
}
bool GCBaseRendererSource2::GetOnlyRenderInEffectsBloomPass() const {
    return GetSchemaValue<bool>(m_ptr, "CBaseRendererSource2", "m_bOnlyRenderInEffectsBloomPass");
}
void GCBaseRendererSource2::SetOnlyRenderInEffectsBloomPass(bool value) {
    SetSchemaValue(m_ptr, "CBaseRendererSource2", "m_bOnlyRenderInEffectsBloomPass", false, value);
}
bool GCBaseRendererSource2::GetOnlyRenderInEffectsWaterPass() const {
    return GetSchemaValue<bool>(m_ptr, "CBaseRendererSource2", "m_bOnlyRenderInEffectsWaterPass");
}
void GCBaseRendererSource2::SetOnlyRenderInEffectsWaterPass(bool value) {
    SetSchemaValue(m_ptr, "CBaseRendererSource2", "m_bOnlyRenderInEffectsWaterPass", false, value);
}
bool GCBaseRendererSource2::GetUseMixedResolutionRendering() const {
    return GetSchemaValue<bool>(m_ptr, "CBaseRendererSource2", "m_bUseMixedResolutionRendering");
}
void GCBaseRendererSource2::SetUseMixedResolutionRendering(bool value) {
    SetSchemaValue(m_ptr, "CBaseRendererSource2", "m_bUseMixedResolutionRendering", false, value);
}
bool GCBaseRendererSource2::GetOnlyRenderInEffecsGameOverlay() const {
    return GetSchemaValue<bool>(m_ptr, "CBaseRendererSource2", "m_bOnlyRenderInEffecsGameOverlay");
}
void GCBaseRendererSource2::SetOnlyRenderInEffecsGameOverlay(bool value) {
    SetSchemaValue(m_ptr, "CBaseRendererSource2", "m_bOnlyRenderInEffecsGameOverlay", false, value);
}
std::string GCBaseRendererSource2::GetStencilTestID() const {
    return GetSchemaValuePtr<char>(m_ptr, "CBaseRendererSource2", "m_stencilTestID");
}
void GCBaseRendererSource2::SetStencilTestID(std::string value) {
    WriteSchemaPtrValue(m_ptr, "CBaseRendererSource2", "m_stencilTestID", false, reinterpret_cast<byte*>(const_cast<char*>(value.c_str())), 128);
}
bool GCBaseRendererSource2::GetStencilTestExclude() const {
    return GetSchemaValue<bool>(m_ptr, "CBaseRendererSource2", "m_bStencilTestExclude");
}
void GCBaseRendererSource2::SetStencilTestExclude(bool value) {
    SetSchemaValue(m_ptr, "CBaseRendererSource2", "m_bStencilTestExclude", false, value);
}
std::string GCBaseRendererSource2::GetStencilWriteID() const {
    return GetSchemaValuePtr<char>(m_ptr, "CBaseRendererSource2", "m_stencilWriteID");
}
void GCBaseRendererSource2::SetStencilWriteID(std::string value) {
    WriteSchemaPtrValue(m_ptr, "CBaseRendererSource2", "m_stencilWriteID", false, reinterpret_cast<byte*>(const_cast<char*>(value.c_str())), 128);
}
bool GCBaseRendererSource2::GetWriteStencilOnDepthPass() const {
    return GetSchemaValue<bool>(m_ptr, "CBaseRendererSource2", "m_bWriteStencilOnDepthPass");
}
void GCBaseRendererSource2::SetWriteStencilOnDepthPass(bool value) {
    SetSchemaValue(m_ptr, "CBaseRendererSource2", "m_bWriteStencilOnDepthPass", false, value);
}
bool GCBaseRendererSource2::GetWriteStencilOnDepthFail() const {
    return GetSchemaValue<bool>(m_ptr, "CBaseRendererSource2", "m_bWriteStencilOnDepthFail");
}
void GCBaseRendererSource2::SetWriteStencilOnDepthFail(bool value) {
    SetSchemaValue(m_ptr, "CBaseRendererSource2", "m_bWriteStencilOnDepthFail", false, value);
}
bool GCBaseRendererSource2::GetReverseZBuffering() const {
    return GetSchemaValue<bool>(m_ptr, "CBaseRendererSource2", "m_bReverseZBuffering");
}
void GCBaseRendererSource2::SetReverseZBuffering(bool value) {
    SetSchemaValue(m_ptr, "CBaseRendererSource2", "m_bReverseZBuffering", false, value);
}
bool GCBaseRendererSource2::GetDisableZBuffering() const {
    return GetSchemaValue<bool>(m_ptr, "CBaseRendererSource2", "m_bDisableZBuffering");
}
void GCBaseRendererSource2::SetDisableZBuffering(bool value) {
    SetSchemaValue(m_ptr, "CBaseRendererSource2", "m_bDisableZBuffering", false, value);
}
uint64_t GCBaseRendererSource2::GetFeatheringMode() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CBaseRendererSource2", "m_nFeatheringMode");
}
void GCBaseRendererSource2::SetFeatheringMode(uint64_t value) {
    SetSchemaValue(m_ptr, "CBaseRendererSource2", "m_nFeatheringMode", false, value);
}
GCParticleCollectionRendererFloatInput GCBaseRendererSource2::GetFeatheringMinDist() const {
    GCParticleCollectionRendererFloatInput value(GetSchemaPtr(m_ptr, "CBaseRendererSource2", "m_flFeatheringMinDist"));
    return value;
}
void GCBaseRendererSource2::SetFeatheringMinDist(GCParticleCollectionRendererFloatInput value) {
    SetSchemaValue(m_ptr, "CBaseRendererSource2", "m_flFeatheringMinDist", false, value);
}
GCParticleCollectionRendererFloatInput GCBaseRendererSource2::GetFeatheringMaxDist() const {
    GCParticleCollectionRendererFloatInput value(GetSchemaPtr(m_ptr, "CBaseRendererSource2", "m_flFeatheringMaxDist"));
    return value;
}
void GCBaseRendererSource2::SetFeatheringMaxDist(GCParticleCollectionRendererFloatInput value) {
    SetSchemaValue(m_ptr, "CBaseRendererSource2", "m_flFeatheringMaxDist", false, value);
}
GCParticleCollectionRendererFloatInput GCBaseRendererSource2::GetFeatheringFilter() const {
    GCParticleCollectionRendererFloatInput value(GetSchemaPtr(m_ptr, "CBaseRendererSource2", "m_flFeatheringFilter"));
    return value;
}
void GCBaseRendererSource2::SetFeatheringFilter(GCParticleCollectionRendererFloatInput value) {
    SetSchemaValue(m_ptr, "CBaseRendererSource2", "m_flFeatheringFilter", false, value);
}
GCParticleCollectionRendererFloatInput GCBaseRendererSource2::GetDepthBias() const {
    GCParticleCollectionRendererFloatInput value(GetSchemaPtr(m_ptr, "CBaseRendererSource2", "m_flDepthBias"));
    return value;
}
void GCBaseRendererSource2::SetDepthBias(GCParticleCollectionRendererFloatInput value) {
    SetSchemaValue(m_ptr, "CBaseRendererSource2", "m_flDepthBias", false, value);
}
uint64_t GCBaseRendererSource2::GetSortMethod() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CBaseRendererSource2", "m_nSortMethod");
}
void GCBaseRendererSource2::SetSortMethod(uint64_t value) {
    SetSchemaValue(m_ptr, "CBaseRendererSource2", "m_nSortMethod", false, value);
}
bool GCBaseRendererSource2::GetBlendFramesSeq0() const {
    return GetSchemaValue<bool>(m_ptr, "CBaseRendererSource2", "m_bBlendFramesSeq0");
}
void GCBaseRendererSource2::SetBlendFramesSeq0(bool value) {
    SetSchemaValue(m_ptr, "CBaseRendererSource2", "m_bBlendFramesSeq0", false, value);
}
bool GCBaseRendererSource2::GetMaxLuminanceBlendingSequence0() const {
    return GetSchemaValue<bool>(m_ptr, "CBaseRendererSource2", "m_bMaxLuminanceBlendingSequence0");
}
void GCBaseRendererSource2::SetMaxLuminanceBlendingSequence0(bool value) {
    SetSchemaValue(m_ptr, "CBaseRendererSource2", "m_bMaxLuminanceBlendingSequence0", false, value);
}
std::string GCBaseRendererSource2::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCBaseRendererSource2::IsValid() {
    return (m_ptr != nullptr);
}
GCParticleFunctionRenderer GCBaseRendererSource2::GetParent() const {
    GCParticleFunctionRenderer value(m_ptr);
    return value;
}
void GCBaseRendererSource2::SetParent(GCParticleFunctionRenderer value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCBaseRendererSource2(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCBaseRendererSource2>("CBaseRendererSource2")
        .addConstructor<void (*)(std::string)>()
        .addProperty("RadiusScale", &GCBaseRendererSource2::GetRadiusScale, &GCBaseRendererSource2::SetRadiusScale)
        .addProperty("AlphaScale", &GCBaseRendererSource2::GetAlphaScale, &GCBaseRendererSource2::SetAlphaScale)
        .addProperty("RollScale", &GCBaseRendererSource2::GetRollScale, &GCBaseRendererSource2::SetRollScale)
        .addProperty("Alpha2Field", &GCBaseRendererSource2::GetAlpha2Field, &GCBaseRendererSource2::SetAlpha2Field)
        .addProperty("ColorScale", &GCBaseRendererSource2::GetColorScale, &GCBaseRendererSource2::SetColorScale)
        .addProperty("ColorBlendType", &GCBaseRendererSource2::GetColorBlendType, &GCBaseRendererSource2::SetColorBlendType)
        .addProperty("ShaderType", &GCBaseRendererSource2::GetShaderType, &GCBaseRendererSource2::SetShaderType)
        .addProperty("StrShaderOverride", &GCBaseRendererSource2::GetStrShaderOverride, &GCBaseRendererSource2::SetStrShaderOverride)
        .addProperty("CenterXOffset", &GCBaseRendererSource2::GetCenterXOffset, &GCBaseRendererSource2::SetCenterXOffset)
        .addProperty("CenterYOffset", &GCBaseRendererSource2::GetCenterYOffset, &GCBaseRendererSource2::SetCenterYOffset)
        .addProperty("BumpStrength", &GCBaseRendererSource2::GetBumpStrength, &GCBaseRendererSource2::SetBumpStrength)
        .addProperty("CropTextureOverride", &GCBaseRendererSource2::GetCropTextureOverride, &GCBaseRendererSource2::SetCropTextureOverride)
        .addProperty("TexturesInput", &GCBaseRendererSource2::GetTexturesInput, &GCBaseRendererSource2::SetTexturesInput)
        .addProperty("AnimationRate", &GCBaseRendererSource2::GetAnimationRate, &GCBaseRendererSource2::SetAnimationRate)
        .addProperty("AnimationType", &GCBaseRendererSource2::GetAnimationType, &GCBaseRendererSource2::SetAnimationType)
        .addProperty("AnimateInFPS", &GCBaseRendererSource2::GetAnimateInFPS, &GCBaseRendererSource2::SetAnimateInFPS)
        .addProperty("SelfIllumAmount", &GCBaseRendererSource2::GetSelfIllumAmount, &GCBaseRendererSource2::SetSelfIllumAmount)
        .addProperty("DiffuseAmount", &GCBaseRendererSource2::GetDiffuseAmount, &GCBaseRendererSource2::SetDiffuseAmount)
        .addProperty("DiffuseClamp", &GCBaseRendererSource2::GetDiffuseClamp, &GCBaseRendererSource2::SetDiffuseClamp)
        .addProperty("LightingControlPoint", &GCBaseRendererSource2::GetLightingControlPoint, &GCBaseRendererSource2::SetLightingControlPoint)
        .addProperty("SelfIllumPerParticle", &GCBaseRendererSource2::GetSelfIllumPerParticle, &GCBaseRendererSource2::SetSelfIllumPerParticle)
        .addProperty("OutputBlendMode", &GCBaseRendererSource2::GetOutputBlendMode, &GCBaseRendererSource2::SetOutputBlendMode)
        .addProperty("GammaCorrectVertexColors", &GCBaseRendererSource2::GetGammaCorrectVertexColors, &GCBaseRendererSource2::SetGammaCorrectVertexColors)
        .addProperty("SaturateColorPreAlphaBlend", &GCBaseRendererSource2::GetSaturateColorPreAlphaBlend, &GCBaseRendererSource2::SetSaturateColorPreAlphaBlend)
        .addProperty("AddSelfAmount", &GCBaseRendererSource2::GetAddSelfAmount, &GCBaseRendererSource2::SetAddSelfAmount)
        .addProperty("Desaturation", &GCBaseRendererSource2::GetDesaturation, &GCBaseRendererSource2::SetDesaturation)
        .addProperty("OverbrightFactor", &GCBaseRendererSource2::GetOverbrightFactor, &GCBaseRendererSource2::SetOverbrightFactor)
        .addProperty("HSVShiftControlPoint", &GCBaseRendererSource2::GetHSVShiftControlPoint, &GCBaseRendererSource2::SetHSVShiftControlPoint)
        .addProperty("FogType", &GCBaseRendererSource2::GetFogType, &GCBaseRendererSource2::SetFogType)
        .addProperty("FogAmount", &GCBaseRendererSource2::GetFogAmount, &GCBaseRendererSource2::SetFogAmount)
        .addProperty("TintByFOW", &GCBaseRendererSource2::GetTintByFOW, &GCBaseRendererSource2::SetTintByFOW)
        .addProperty("TintByGlobalLight", &GCBaseRendererSource2::GetTintByGlobalLight, &GCBaseRendererSource2::SetTintByGlobalLight)
        .addProperty("PerParticleAlphaReference", &GCBaseRendererSource2::GetPerParticleAlphaReference, &GCBaseRendererSource2::SetPerParticleAlphaReference)
        .addProperty("PerParticleAlphaRefWindow", &GCBaseRendererSource2::GetPerParticleAlphaRefWindow, &GCBaseRendererSource2::SetPerParticleAlphaRefWindow)
        .addProperty("AlphaReferenceType", &GCBaseRendererSource2::GetAlphaReferenceType, &GCBaseRendererSource2::SetAlphaReferenceType)
        .addProperty("AlphaReferenceSoftness", &GCBaseRendererSource2::GetAlphaReferenceSoftness, &GCBaseRendererSource2::SetAlphaReferenceSoftness)
        .addProperty("SourceAlphaValueToMapToZero", &GCBaseRendererSource2::GetSourceAlphaValueToMapToZero, &GCBaseRendererSource2::SetSourceAlphaValueToMapToZero)
        .addProperty("SourceAlphaValueToMapToOne", &GCBaseRendererSource2::GetSourceAlphaValueToMapToOne, &GCBaseRendererSource2::SetSourceAlphaValueToMapToOne)
        .addProperty("Refract", &GCBaseRendererSource2::GetRefract, &GCBaseRendererSource2::SetRefract)
        .addProperty("RefractSolid", &GCBaseRendererSource2::GetRefractSolid, &GCBaseRendererSource2::SetRefractSolid)
        .addProperty("RefractAmount", &GCBaseRendererSource2::GetRefractAmount, &GCBaseRendererSource2::SetRefractAmount)
        .addProperty("RefractBlurRadius", &GCBaseRendererSource2::GetRefractBlurRadius, &GCBaseRendererSource2::SetRefractBlurRadius)
        .addProperty("RefractBlurType", &GCBaseRendererSource2::GetRefractBlurType, &GCBaseRendererSource2::SetRefractBlurType)
        .addProperty("OnlyRenderInEffectsBloomPass", &GCBaseRendererSource2::GetOnlyRenderInEffectsBloomPass, &GCBaseRendererSource2::SetOnlyRenderInEffectsBloomPass)
        .addProperty("OnlyRenderInEffectsWaterPass", &GCBaseRendererSource2::GetOnlyRenderInEffectsWaterPass, &GCBaseRendererSource2::SetOnlyRenderInEffectsWaterPass)
        .addProperty("UseMixedResolutionRendering", &GCBaseRendererSource2::GetUseMixedResolutionRendering, &GCBaseRendererSource2::SetUseMixedResolutionRendering)
        .addProperty("OnlyRenderInEffecsGameOverlay", &GCBaseRendererSource2::GetOnlyRenderInEffecsGameOverlay, &GCBaseRendererSource2::SetOnlyRenderInEffecsGameOverlay)
        .addProperty("StencilTestID", &GCBaseRendererSource2::GetStencilTestID, &GCBaseRendererSource2::SetStencilTestID)
        .addProperty("StencilTestExclude", &GCBaseRendererSource2::GetStencilTestExclude, &GCBaseRendererSource2::SetStencilTestExclude)
        .addProperty("StencilWriteID", &GCBaseRendererSource2::GetStencilWriteID, &GCBaseRendererSource2::SetStencilWriteID)
        .addProperty("WriteStencilOnDepthPass", &GCBaseRendererSource2::GetWriteStencilOnDepthPass, &GCBaseRendererSource2::SetWriteStencilOnDepthPass)
        .addProperty("WriteStencilOnDepthFail", &GCBaseRendererSource2::GetWriteStencilOnDepthFail, &GCBaseRendererSource2::SetWriteStencilOnDepthFail)
        .addProperty("ReverseZBuffering", &GCBaseRendererSource2::GetReverseZBuffering, &GCBaseRendererSource2::SetReverseZBuffering)
        .addProperty("DisableZBuffering", &GCBaseRendererSource2::GetDisableZBuffering, &GCBaseRendererSource2::SetDisableZBuffering)
        .addProperty("FeatheringMode", &GCBaseRendererSource2::GetFeatheringMode, &GCBaseRendererSource2::SetFeatheringMode)
        .addProperty("FeatheringMinDist", &GCBaseRendererSource2::GetFeatheringMinDist, &GCBaseRendererSource2::SetFeatheringMinDist)
        .addProperty("FeatheringMaxDist", &GCBaseRendererSource2::GetFeatheringMaxDist, &GCBaseRendererSource2::SetFeatheringMaxDist)
        .addProperty("FeatheringFilter", &GCBaseRendererSource2::GetFeatheringFilter, &GCBaseRendererSource2::SetFeatheringFilter)
        .addProperty("DepthBias", &GCBaseRendererSource2::GetDepthBias, &GCBaseRendererSource2::SetDepthBias)
        .addProperty("SortMethod", &GCBaseRendererSource2::GetSortMethod, &GCBaseRendererSource2::SetSortMethod)
        .addProperty("BlendFramesSeq0", &GCBaseRendererSource2::GetBlendFramesSeq0, &GCBaseRendererSource2::SetBlendFramesSeq0)
        .addProperty("MaxLuminanceBlendingSequence0", &GCBaseRendererSource2::GetMaxLuminanceBlendingSequence0, &GCBaseRendererSource2::SetMaxLuminanceBlendingSequence0)
        .addProperty("Parent", &GCBaseRendererSource2::GetParent, &GCBaseRendererSource2::SetParent)
        .addFunction("ToPtr", &GCBaseRendererSource2::ToPtr)
        .addFunction("IsValid", &GCBaseRendererSource2::IsValid)
        .endClass();
}
GCSSDSMsg_ViewRender::GCSSDSMsg_ViewRender(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCSSDSMsg_ViewRender::GCSSDSMsg_ViewRender(void *ptr) {
    m_ptr = ptr;
}
GSceneViewId_t GCSSDSMsg_ViewRender::GetViewId() const {
    GSceneViewId_t value(GetSchemaPtr(m_ptr, "CSSDSMsg_ViewRender", "m_viewId"));
    return value;
}
void GCSSDSMsg_ViewRender::SetViewId(GSceneViewId_t value) {
    SetSchemaValue(m_ptr, "CSSDSMsg_ViewRender", "m_viewId", false, value);
}
std::string GCSSDSMsg_ViewRender::GetViewName() const {
    return GetSchemaValue<CUtlString>(m_ptr, "CSSDSMsg_ViewRender", "m_ViewName").Get();
}
void GCSSDSMsg_ViewRender::SetViewName(std::string value) {
    SetSchemaValue(m_ptr, "CSSDSMsg_ViewRender", "m_ViewName", false, CUtlString(value.c_str()));
}
std::string GCSSDSMsg_ViewRender::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCSSDSMsg_ViewRender::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCSSDSMsg_ViewRender(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCSSDSMsg_ViewRender>("CSSDSMsg_ViewRender")
        .addConstructor<void (*)(std::string)>()
        .addProperty("ViewId", &GCSSDSMsg_ViewRender::GetViewId, &GCSSDSMsg_ViewRender::SetViewId)
        .addProperty("ViewName", &GCSSDSMsg_ViewRender::GetViewName, &GCSSDSMsg_ViewRender::SetViewName)
        .addFunction("ToPtr", &GCSSDSMsg_ViewRender::ToPtr)
        .addFunction("IsValid", &GCSSDSMsg_ViewRender::IsValid)
        .endClass();
}
GCZeroPoseUpdateNode::GCZeroPoseUpdateNode(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCZeroPoseUpdateNode::GCZeroPoseUpdateNode(void *ptr) {
    m_ptr = ptr;
}
std::string GCZeroPoseUpdateNode::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCZeroPoseUpdateNode::IsValid() {
    return (m_ptr != nullptr);
}
GCLeafUpdateNode GCZeroPoseUpdateNode::GetParent() const {
    GCLeafUpdateNode value(m_ptr);
    return value;
}
void GCZeroPoseUpdateNode::SetParent(GCLeafUpdateNode value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCZeroPoseUpdateNode(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCZeroPoseUpdateNode>("CZeroPoseUpdateNode")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCZeroPoseUpdateNode::GetParent, &GCZeroPoseUpdateNode::SetParent)
        .addFunction("ToPtr", &GCZeroPoseUpdateNode::ToPtr)
        .addFunction("IsValid", &GCZeroPoseUpdateNode::IsValid)
        .endClass();
}
GFeFitWeight_t::GFeFitWeight_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GFeFitWeight_t::GFeFitWeight_t(void *ptr) {
    m_ptr = ptr;
}
float GFeFitWeight_t::GetWeight() const {
    return GetSchemaValue<float>(m_ptr, "FeFitWeight_t", "flWeight");
}
void GFeFitWeight_t::SetWeight(float value) {
    SetSchemaValue(m_ptr, "FeFitWeight_t", "flWeight", true, value);
}
uint16_t GFeFitWeight_t::GetNode() const {
    return GetSchemaValue<uint16_t>(m_ptr, "FeFitWeight_t", "nNode");
}
void GFeFitWeight_t::SetNode(uint16_t value) {
    SetSchemaValue(m_ptr, "FeFitWeight_t", "nNode", true, value);
}
uint16_t GFeFitWeight_t::GetDummy() const {
    return GetSchemaValue<uint16_t>(m_ptr, "FeFitWeight_t", "nDummy");
}
void GFeFitWeight_t::SetDummy(uint16_t value) {
    SetSchemaValue(m_ptr, "FeFitWeight_t", "nDummy", true, value);
}
std::string GFeFitWeight_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GFeFitWeight_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassFeFitWeight_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GFeFitWeight_t>("FeFitWeight_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Weight", &GFeFitWeight_t::GetWeight, &GFeFitWeight_t::SetWeight)
        .addProperty("Node", &GFeFitWeight_t::GetNode, &GFeFitWeight_t::SetNode)
        .addProperty("Dummy", &GFeFitWeight_t::GetDummy, &GFeFitWeight_t::SetDummy)
        .addFunction("ToPtr", &GFeFitWeight_t::ToPtr)
        .addFunction("IsValid", &GFeFitWeight_t::IsValid)
        .endClass();
}
GCFootCycleMetricEvaluator::GCFootCycleMetricEvaluator(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCFootCycleMetricEvaluator::GCFootCycleMetricEvaluator(void *ptr) {
    m_ptr = ptr;
}
std::vector<int32> GCFootCycleMetricEvaluator::GetFootIndices() const {
    CUtlVector<int32>* vec = GetSchemaValue<CUtlVector<int32>*>(m_ptr, "CFootCycleMetricEvaluator", "m_footIndices"); std::vector<int32> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCFootCycleMetricEvaluator::SetFootIndices(std::vector<int32> value) {
    SetSchemaValueCUtlVector<int32>(m_ptr, "CFootCycleMetricEvaluator", "m_footIndices", false, value);
}
std::string GCFootCycleMetricEvaluator::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCFootCycleMetricEvaluator::IsValid() {
    return (m_ptr != nullptr);
}
GCMotionMetricEvaluator GCFootCycleMetricEvaluator::GetParent() const {
    GCMotionMetricEvaluator value(m_ptr);
    return value;
}
void GCFootCycleMetricEvaluator::SetParent(GCMotionMetricEvaluator value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCFootCycleMetricEvaluator(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCFootCycleMetricEvaluator>("CFootCycleMetricEvaluator")
        .addConstructor<void (*)(std::string)>()
        .addProperty("FootIndices", &GCFootCycleMetricEvaluator::GetFootIndices, &GCFootCycleMetricEvaluator::SetFootIndices)
        .addProperty("Parent", &GCFootCycleMetricEvaluator::GetParent, &GCFootCycleMetricEvaluator::SetParent)
        .addFunction("ToPtr", &GCFootCycleMetricEvaluator::ToPtr)
        .addFunction("IsValid", &GCFootCycleMetricEvaluator::IsValid)
        .endClass();
}
GCFootPositionMetricEvaluator::GCFootPositionMetricEvaluator(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCFootPositionMetricEvaluator::GCFootPositionMetricEvaluator(void *ptr) {
    m_ptr = ptr;
}
std::vector<int32> GCFootPositionMetricEvaluator::GetFootIndices() const {
    CUtlVector<int32>* vec = GetSchemaValue<CUtlVector<int32>*>(m_ptr, "CFootPositionMetricEvaluator", "m_footIndices"); std::vector<int32> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCFootPositionMetricEvaluator::SetFootIndices(std::vector<int32> value) {
    SetSchemaValueCUtlVector<int32>(m_ptr, "CFootPositionMetricEvaluator", "m_footIndices", false, value);
}
bool GCFootPositionMetricEvaluator::GetIgnoreSlope() const {
    return GetSchemaValue<bool>(m_ptr, "CFootPositionMetricEvaluator", "m_bIgnoreSlope");
}
void GCFootPositionMetricEvaluator::SetIgnoreSlope(bool value) {
    SetSchemaValue(m_ptr, "CFootPositionMetricEvaluator", "m_bIgnoreSlope", false, value);
}
std::string GCFootPositionMetricEvaluator::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCFootPositionMetricEvaluator::IsValid() {
    return (m_ptr != nullptr);
}
GCMotionMetricEvaluator GCFootPositionMetricEvaluator::GetParent() const {
    GCMotionMetricEvaluator value(m_ptr);
    return value;
}
void GCFootPositionMetricEvaluator::SetParent(GCMotionMetricEvaluator value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCFootPositionMetricEvaluator(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCFootPositionMetricEvaluator>("CFootPositionMetricEvaluator")
        .addConstructor<void (*)(std::string)>()
        .addProperty("FootIndices", &GCFootPositionMetricEvaluator::GetFootIndices, &GCFootPositionMetricEvaluator::SetFootIndices)
        .addProperty("IgnoreSlope", &GCFootPositionMetricEvaluator::GetIgnoreSlope, &GCFootPositionMetricEvaluator::SetIgnoreSlope)
        .addProperty("Parent", &GCFootPositionMetricEvaluator::GetParent, &GCFootPositionMetricEvaluator::SetParent)
        .addFunction("ToPtr", &GCFootPositionMetricEvaluator::ToPtr)
        .addFunction("IsValid", &GCFootPositionMetricEvaluator::IsValid)
        .endClass();
}
GCFlexOp::GCFlexOp(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCFlexOp::GCFlexOp(void *ptr) {
    m_ptr = ptr;
}
uint64_t GCFlexOp::GetOpCode() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CFlexOp", "m_OpCode");
}
void GCFlexOp::SetOpCode(uint64_t value) {
    SetSchemaValue(m_ptr, "CFlexOp", "m_OpCode", false, value);
}
int32_t GCFlexOp::GetData() const {
    return GetSchemaValue<int32_t>(m_ptr, "CFlexOp", "m_Data");
}
void GCFlexOp::SetData(int32_t value) {
    SetSchemaValue(m_ptr, "CFlexOp", "m_Data", false, value);
}
std::string GCFlexOp::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCFlexOp::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCFlexOp(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCFlexOp>("CFlexOp")
        .addConstructor<void (*)(std::string)>()
        .addProperty("OpCode", &GCFlexOp::GetOpCode, &GCFlexOp::SetOpCode)
        .addProperty("Data", &GCFlexOp::GetData, &GCFlexOp::SetData)
        .addFunction("ToPtr", &GCFlexOp::ToPtr)
        .addFunction("IsValid", &GCFlexOp::IsValid)
        .endClass();
}
GCPointConstraint::GCPointConstraint(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCPointConstraint::GCPointConstraint(void *ptr) {
    m_ptr = ptr;
}
std::string GCPointConstraint::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCPointConstraint::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseConstraint GCPointConstraint::GetParent() const {
    GCBaseConstraint value(m_ptr);
    return value;
}
void GCPointConstraint::SetParent(GCBaseConstraint value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCPointConstraint(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCPointConstraint>("CPointConstraint")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCPointConstraint::GetParent, &GCPointConstraint::SetParent)
        .addFunction("ToPtr", &GCPointConstraint::ToPtr)
        .addFunction("IsValid", &GCPointConstraint::IsValid)
        .endClass();
}
GMotionBlendItem::GMotionBlendItem(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GMotionBlendItem::GMotionBlendItem(void *ptr) {
    m_ptr = ptr;
}
float GMotionBlendItem::GetKeyValue() const {
    return GetSchemaValue<float>(m_ptr, "MotionBlendItem", "m_flKeyValue");
}
void GMotionBlendItem::SetKeyValue(float value) {
    SetSchemaValue(m_ptr, "MotionBlendItem", "m_flKeyValue", false, value);
}
std::string GMotionBlendItem::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GMotionBlendItem::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassMotionBlendItem(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GMotionBlendItem>("MotionBlendItem")
        .addConstructor<void (*)(std::string)>()
        .addProperty("KeyValue", &GMotionBlendItem::GetKeyValue, &GMotionBlendItem::SetKeyValue)
        .addFunction("ToPtr", &GMotionBlendItem::ToPtr)
        .addFunction("IsValid", &GMotionBlendItem::IsValid)
        .endClass();
}
GCVectorQuantizer::GCVectorQuantizer(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCVectorQuantizer::GCVectorQuantizer(void *ptr) {
    m_ptr = ptr;
}
std::vector<float32> GCVectorQuantizer::GetCentroidVectors() const {
    CUtlVector<float32>* vec = GetSchemaValue<CUtlVector<float32>*>(m_ptr, "CVectorQuantizer", "m_centroidVectors"); std::vector<float32> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCVectorQuantizer::SetCentroidVectors(std::vector<float32> value) {
    SetSchemaValueCUtlVector<float32>(m_ptr, "CVectorQuantizer", "m_centroidVectors", false, value);
}
int32_t GCVectorQuantizer::GetCentroids() const {
    return GetSchemaValue<int32_t>(m_ptr, "CVectorQuantizer", "m_nCentroids");
}
void GCVectorQuantizer::SetCentroids(int32_t value) {
    SetSchemaValue(m_ptr, "CVectorQuantizer", "m_nCentroids", false, value);
}
int32_t GCVectorQuantizer::GetDimensions() const {
    return GetSchemaValue<int32_t>(m_ptr, "CVectorQuantizer", "m_nDimensions");
}
void GCVectorQuantizer::SetDimensions(int32_t value) {
    SetSchemaValue(m_ptr, "CVectorQuantizer", "m_nDimensions", false, value);
}
std::string GCVectorQuantizer::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCVectorQuantizer::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCVectorQuantizer(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCVectorQuantizer>("CVectorQuantizer")
        .addConstructor<void (*)(std::string)>()
        .addProperty("CentroidVectors", &GCVectorQuantizer::GetCentroidVectors, &GCVectorQuantizer::SetCentroidVectors)
        .addProperty("Centroids", &GCVectorQuantizer::GetCentroids, &GCVectorQuantizer::SetCentroids)
        .addProperty("Dimensions", &GCVectorQuantizer::GetDimensions, &GCVectorQuantizer::SetDimensions)
        .addFunction("ToPtr", &GCVectorQuantizer::ToPtr)
        .addFunction("IsValid", &GCVectorQuantizer::IsValid)
        .endClass();
}
GSignatureOutflow_Resume::GSignatureOutflow_Resume(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GSignatureOutflow_Resume::GSignatureOutflow_Resume(void *ptr) {
    m_ptr = ptr;
}
std::string GSignatureOutflow_Resume::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GSignatureOutflow_Resume::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassSignatureOutflow_Resume(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GSignatureOutflow_Resume>("SignatureOutflow_Resume")
        .addConstructor<void (*)(std::string)>()
        .addFunction("ToPtr", &GSignatureOutflow_Resume::ToPtr)
        .addFunction("IsValid", &GSignatureOutflow_Resume::IsValid)
        .endClass();
}
GFeBoxRigid_t::GFeBoxRigid_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GFeBoxRigid_t::GFeBoxRigid_t(void *ptr) {
    m_ptr = ptr;
}
uint16_t GFeBoxRigid_t::GetNode() const {
    return GetSchemaValue<uint16_t>(m_ptr, "FeBoxRigid_t", "nNode");
}
void GFeBoxRigid_t::SetNode(uint16_t value) {
    SetSchemaValue(m_ptr, "FeBoxRigid_t", "nNode", true, value);
}
uint16_t GFeBoxRigid_t::GetCollisionMask() const {
    return GetSchemaValue<uint16_t>(m_ptr, "FeBoxRigid_t", "nCollisionMask");
}
void GFeBoxRigid_t::SetCollisionMask(uint16_t value) {
    SetSchemaValue(m_ptr, "FeBoxRigid_t", "nCollisionMask", true, value);
}
Vector GFeBoxRigid_t::GetSize() const {
    return GetSchemaValue<Vector>(m_ptr, "FeBoxRigid_t", "vSize");
}
void GFeBoxRigid_t::SetSize(Vector value) {
    SetSchemaValue(m_ptr, "FeBoxRigid_t", "vSize", true, value);
}
uint16_t GFeBoxRigid_t::GetVertexMapIndex() const {
    return GetSchemaValue<uint16_t>(m_ptr, "FeBoxRigid_t", "nVertexMapIndex");
}
void GFeBoxRigid_t::SetVertexMapIndex(uint16_t value) {
    SetSchemaValue(m_ptr, "FeBoxRigid_t", "nVertexMapIndex", true, value);
}
uint16_t GFeBoxRigid_t::GetFlags() const {
    return GetSchemaValue<uint16_t>(m_ptr, "FeBoxRigid_t", "nFlags");
}
void GFeBoxRigid_t::SetFlags(uint16_t value) {
    SetSchemaValue(m_ptr, "FeBoxRigid_t", "nFlags", true, value);
}
std::string GFeBoxRigid_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GFeBoxRigid_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassFeBoxRigid_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GFeBoxRigid_t>("FeBoxRigid_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Node", &GFeBoxRigid_t::GetNode, &GFeBoxRigid_t::SetNode)
        .addProperty("CollisionMask", &GFeBoxRigid_t::GetCollisionMask, &GFeBoxRigid_t::SetCollisionMask)
        .addProperty("Size", &GFeBoxRigid_t::GetSize, &GFeBoxRigid_t::SetSize)
        .addProperty("VertexMapIndex", &GFeBoxRigid_t::GetVertexMapIndex, &GFeBoxRigid_t::SetVertexMapIndex)
        .addProperty("Flags", &GFeBoxRigid_t::GetFlags, &GFeBoxRigid_t::SetFlags)
        .addFunction("ToPtr", &GFeBoxRigid_t::ToPtr)
        .addFunction("IsValid", &GFeBoxRigid_t::IsValid)
        .endClass();
}
GCIntAnimParameter::GCIntAnimParameter(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCIntAnimParameter::GCIntAnimParameter(void *ptr) {
    m_ptr = ptr;
}
int32_t GCIntAnimParameter::GetDefaultValue() const {
    return GetSchemaValue<int32_t>(m_ptr, "CIntAnimParameter", "m_defaultValue");
}
void GCIntAnimParameter::SetDefaultValue(int32_t value) {
    SetSchemaValue(m_ptr, "CIntAnimParameter", "m_defaultValue", false, value);
}
int32_t GCIntAnimParameter::GetMinValue() const {
    return GetSchemaValue<int32_t>(m_ptr, "CIntAnimParameter", "m_minValue");
}
void GCIntAnimParameter::SetMinValue(int32_t value) {
    SetSchemaValue(m_ptr, "CIntAnimParameter", "m_minValue", false, value);
}
int32_t GCIntAnimParameter::GetMaxValue() const {
    return GetSchemaValue<int32_t>(m_ptr, "CIntAnimParameter", "m_maxValue");
}
void GCIntAnimParameter::SetMaxValue(int32_t value) {
    SetSchemaValue(m_ptr, "CIntAnimParameter", "m_maxValue", false, value);
}
std::string GCIntAnimParameter::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCIntAnimParameter::IsValid() {
    return (m_ptr != nullptr);
}
GCConcreteAnimParameter GCIntAnimParameter::GetParent() const {
    GCConcreteAnimParameter value(m_ptr);
    return value;
}
void GCIntAnimParameter::SetParent(GCConcreteAnimParameter value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCIntAnimParameter(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCIntAnimParameter>("CIntAnimParameter")
        .addConstructor<void (*)(std::string)>()
        .addProperty("DefaultValue", &GCIntAnimParameter::GetDefaultValue, &GCIntAnimParameter::SetDefaultValue)
        .addProperty("MinValue", &GCIntAnimParameter::GetMinValue, &GCIntAnimParameter::SetMinValue)
        .addProperty("MaxValue", &GCIntAnimParameter::GetMaxValue, &GCIntAnimParameter::SetMaxValue)
        .addProperty("Parent", &GCIntAnimParameter::GetParent, &GCIntAnimParameter::SetParent)
        .addFunction("ToPtr", &GCIntAnimParameter::ToPtr)
        .addFunction("IsValid", &GCIntAnimParameter::IsValid)
        .endClass();
}
GCNmTargetValueNode::GCNmTargetValueNode(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCNmTargetValueNode::GCNmTargetValueNode(void *ptr) {
    m_ptr = ptr;
}
std::string GCNmTargetValueNode::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCNmTargetValueNode::IsValid() {
    return (m_ptr != nullptr);
}
GCNmValueNode GCNmTargetValueNode::GetParent() const {
    GCNmValueNode value(m_ptr);
    return value;
}
void GCNmTargetValueNode::SetParent(GCNmValueNode value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCNmTargetValueNode(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCNmTargetValueNode>("CNmTargetValueNode")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCNmTargetValueNode::GetParent, &GCNmTargetValueNode::SetParent)
        .addFunction("ToPtr", &GCNmTargetValueNode::ToPtr)
        .addFunction("IsValid", &GCNmTargetValueNode::IsValid)
        .endClass();
}
GEventSimpleLoopFrameUpdate_t::GEventSimpleLoopFrameUpdate_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GEventSimpleLoopFrameUpdate_t::GEventSimpleLoopFrameUpdate_t(void *ptr) {
    m_ptr = ptr;
}
GEngineLoopState_t GEventSimpleLoopFrameUpdate_t::GetLoopState() const {
    GEngineLoopState_t value(GetSchemaPtr(m_ptr, "EventSimpleLoopFrameUpdate_t", "m_LoopState"));
    return value;
}
void GEventSimpleLoopFrameUpdate_t::SetLoopState(GEngineLoopState_t value) {
    SetSchemaValue(m_ptr, "EventSimpleLoopFrameUpdate_t", "m_LoopState", true, value);
}
float GEventSimpleLoopFrameUpdate_t::GetRealTime() const {
    return GetSchemaValue<float>(m_ptr, "EventSimpleLoopFrameUpdate_t", "m_flRealTime");
}
void GEventSimpleLoopFrameUpdate_t::SetRealTime(float value) {
    SetSchemaValue(m_ptr, "EventSimpleLoopFrameUpdate_t", "m_flRealTime", true, value);
}
float GEventSimpleLoopFrameUpdate_t::GetFrameTime() const {
    return GetSchemaValue<float>(m_ptr, "EventSimpleLoopFrameUpdate_t", "m_flFrameTime");
}
void GEventSimpleLoopFrameUpdate_t::SetFrameTime(float value) {
    SetSchemaValue(m_ptr, "EventSimpleLoopFrameUpdate_t", "m_flFrameTime", true, value);
}
std::string GEventSimpleLoopFrameUpdate_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GEventSimpleLoopFrameUpdate_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassEventSimpleLoopFrameUpdate_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GEventSimpleLoopFrameUpdate_t>("EventSimpleLoopFrameUpdate_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("LoopState", &GEventSimpleLoopFrameUpdate_t::GetLoopState, &GEventSimpleLoopFrameUpdate_t::SetLoopState)
        .addProperty("RealTime", &GEventSimpleLoopFrameUpdate_t::GetRealTime, &GEventSimpleLoopFrameUpdate_t::SetRealTime)
        .addProperty("FrameTime", &GEventSimpleLoopFrameUpdate_t::GetFrameTime, &GEventSimpleLoopFrameUpdate_t::SetFrameTime)
        .addFunction("ToPtr", &GEventSimpleLoopFrameUpdate_t::ToPtr)
        .addFunction("IsValid", &GEventSimpleLoopFrameUpdate_t::IsValid)
        .endClass();
}
GEventServerAdvanceTick_t::GEventServerAdvanceTick_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GEventServerAdvanceTick_t::GEventServerAdvanceTick_t(void *ptr) {
    m_ptr = ptr;
}
std::string GEventServerAdvanceTick_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GEventServerAdvanceTick_t::IsValid() {
    return (m_ptr != nullptr);
}
GEventAdvanceTick_t GEventServerAdvanceTick_t::GetParent() const {
    GEventAdvanceTick_t value(m_ptr);
    return value;
}
void GEventServerAdvanceTick_t::SetParent(GEventAdvanceTick_t value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassEventServerAdvanceTick_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GEventServerAdvanceTick_t>("EventServerAdvanceTick_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GEventServerAdvanceTick_t::GetParent, &GEventServerAdvanceTick_t::SetParent)
        .addFunction("ToPtr", &GEventServerAdvanceTick_t::ToPtr)
        .addFunction("IsValid", &GEventServerAdvanceTick_t::IsValid)
        .endClass();
}
GTimedEvent::GTimedEvent(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GTimedEvent::GTimedEvent(void *ptr) {
    m_ptr = ptr;
}
float GTimedEvent::GetTimeBetweenEvents() const {
    return GetSchemaValue<float>(m_ptr, "TimedEvent", "m_TimeBetweenEvents");
}
void GTimedEvent::SetTimeBetweenEvents(float value) {
    SetSchemaValue(m_ptr, "TimedEvent", "m_TimeBetweenEvents", false, value);
}
float GTimedEvent::GetNextEvent() const {
    return GetSchemaValue<float>(m_ptr, "TimedEvent", "m_fNextEvent");
}
void GTimedEvent::SetNextEvent(float value) {
    SetSchemaValue(m_ptr, "TimedEvent", "m_fNextEvent", false, value);
}
std::string GTimedEvent::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GTimedEvent::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassTimedEvent(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GTimedEvent>("TimedEvent")
        .addConstructor<void (*)(std::string)>()
        .addProperty("TimeBetweenEvents", &GTimedEvent::GetTimeBetweenEvents, &GTimedEvent::SetTimeBetweenEvents)
        .addProperty("NextEvent", &GTimedEvent::GetNextEvent, &GTimedEvent::SetNextEvent)
        .addFunction("ToPtr", &GTimedEvent::ToPtr)
        .addFunction("IsValid", &GTimedEvent::IsValid)
        .endClass();
}
GTextureGroup_t::GTextureGroup_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GTextureGroup_t::GTextureGroup_t(void *ptr) {
    m_ptr = ptr;
}
bool GTextureGroup_t::GetEnabled() const {
    return GetSchemaValue<bool>(m_ptr, "TextureGroup_t", "m_bEnabled");
}
void GTextureGroup_t::SetEnabled(bool value) {
    SetSchemaValue(m_ptr, "TextureGroup_t", "m_bEnabled", true, value);
}
bool GTextureGroup_t::GetReplaceTextureWithGradient() const {
    return GetSchemaValue<bool>(m_ptr, "TextureGroup_t", "m_bReplaceTextureWithGradient");
}
void GTextureGroup_t::SetReplaceTextureWithGradient(bool value) {
    SetSchemaValue(m_ptr, "TextureGroup_t", "m_bReplaceTextureWithGradient", true, value);
}
uint64_t GTextureGroup_t::GetTextureType() const {
    return GetSchemaValue<uint64_t>(m_ptr, "TextureGroup_t", "m_nTextureType");
}
void GTextureGroup_t::SetTextureType(uint64_t value) {
    SetSchemaValue(m_ptr, "TextureGroup_t", "m_nTextureType", true, value);
}
uint64_t GTextureGroup_t::GetTextureChannels() const {
    return GetSchemaValue<uint64_t>(m_ptr, "TextureGroup_t", "m_nTextureChannels");
}
void GTextureGroup_t::SetTextureChannels(uint64_t value) {
    SetSchemaValue(m_ptr, "TextureGroup_t", "m_nTextureChannels", true, value);
}
uint64_t GTextureGroup_t::GetTextureBlendMode() const {
    return GetSchemaValue<uint64_t>(m_ptr, "TextureGroup_t", "m_nTextureBlendMode");
}
void GTextureGroup_t::SetTextureBlendMode(uint64_t value) {
    SetSchemaValue(m_ptr, "TextureGroup_t", "m_nTextureBlendMode", true, value);
}
GCParticleCollectionRendererFloatInput GTextureGroup_t::GetTextureBlend() const {
    GCParticleCollectionRendererFloatInput value(GetSchemaPtr(m_ptr, "TextureGroup_t", "m_flTextureBlend"));
    return value;
}
void GTextureGroup_t::SetTextureBlend(GCParticleCollectionRendererFloatInput value) {
    SetSchemaValue(m_ptr, "TextureGroup_t", "m_flTextureBlend", true, value);
}
GTextureControls_t GTextureGroup_t::GetTextureControls() const {
    GTextureControls_t value(GetSchemaPtr(m_ptr, "TextureGroup_t", "m_TextureControls"));
    return value;
}
void GTextureGroup_t::SetTextureControls(GTextureControls_t value) {
    SetSchemaValue(m_ptr, "TextureGroup_t", "m_TextureControls", true, value);
}
std::string GTextureGroup_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GTextureGroup_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassTextureGroup_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GTextureGroup_t>("TextureGroup_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Enabled", &GTextureGroup_t::GetEnabled, &GTextureGroup_t::SetEnabled)
        .addProperty("ReplaceTextureWithGradient", &GTextureGroup_t::GetReplaceTextureWithGradient, &GTextureGroup_t::SetReplaceTextureWithGradient)
        .addProperty("TextureType", &GTextureGroup_t::GetTextureType, &GTextureGroup_t::SetTextureType)
        .addProperty("TextureChannels", &GTextureGroup_t::GetTextureChannels, &GTextureGroup_t::SetTextureChannels)
        .addProperty("TextureBlendMode", &GTextureGroup_t::GetTextureBlendMode, &GTextureGroup_t::SetTextureBlendMode)
        .addProperty("TextureBlend", &GTextureGroup_t::GetTextureBlend, &GTextureGroup_t::SetTextureBlend)
        .addProperty("TextureControls", &GTextureGroup_t::GetTextureControls, &GTextureGroup_t::SetTextureControls)
        .addFunction("ToPtr", &GTextureGroup_t::ToPtr)
        .addFunction("IsValid", &GTextureGroup_t::IsValid)
        .endClass();
}
GCSosGroupActionSoundeventPrioritySchema::GCSosGroupActionSoundeventPrioritySchema(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCSosGroupActionSoundeventPrioritySchema::GCSosGroupActionSoundeventPrioritySchema(void *ptr) {
    m_ptr = ptr;
}
std::string GCSosGroupActionSoundeventPrioritySchema::GetPriorityValue() const {
    return GetSchemaValue<CUtlString>(m_ptr, "CSosGroupActionSoundeventPrioritySchema", "m_priorityValue").Get();
}
void GCSosGroupActionSoundeventPrioritySchema::SetPriorityValue(std::string value) {
    SetSchemaValue(m_ptr, "CSosGroupActionSoundeventPrioritySchema", "m_priorityValue", false, CUtlString(value.c_str()));
}
std::string GCSosGroupActionSoundeventPrioritySchema::GetPriorityVolumeScalar() const {
    return GetSchemaValue<CUtlString>(m_ptr, "CSosGroupActionSoundeventPrioritySchema", "m_priorityVolumeScalar").Get();
}
void GCSosGroupActionSoundeventPrioritySchema::SetPriorityVolumeScalar(std::string value) {
    SetSchemaValue(m_ptr, "CSosGroupActionSoundeventPrioritySchema", "m_priorityVolumeScalar", false, CUtlString(value.c_str()));
}
std::string GCSosGroupActionSoundeventPrioritySchema::GetPriorityContributeButDontRead() const {
    return GetSchemaValue<CUtlString>(m_ptr, "CSosGroupActionSoundeventPrioritySchema", "m_priorityContributeButDontRead").Get();
}
void GCSosGroupActionSoundeventPrioritySchema::SetPriorityContributeButDontRead(std::string value) {
    SetSchemaValue(m_ptr, "CSosGroupActionSoundeventPrioritySchema", "m_priorityContributeButDontRead", false, CUtlString(value.c_str()));
}
std::string GCSosGroupActionSoundeventPrioritySchema::GetPriorityReadButDontContribute() const {
    return GetSchemaValue<CUtlString>(m_ptr, "CSosGroupActionSoundeventPrioritySchema", "m_bPriorityReadButDontContribute").Get();
}
void GCSosGroupActionSoundeventPrioritySchema::SetPriorityReadButDontContribute(std::string value) {
    SetSchemaValue(m_ptr, "CSosGroupActionSoundeventPrioritySchema", "m_bPriorityReadButDontContribute", false, CUtlString(value.c_str()));
}
std::string GCSosGroupActionSoundeventPrioritySchema::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCSosGroupActionSoundeventPrioritySchema::IsValid() {
    return (m_ptr != nullptr);
}
GCSosGroupActionSchema GCSosGroupActionSoundeventPrioritySchema::GetParent() const {
    GCSosGroupActionSchema value(m_ptr);
    return value;
}
void GCSosGroupActionSoundeventPrioritySchema::SetParent(GCSosGroupActionSchema value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCSosGroupActionSoundeventPrioritySchema(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCSosGroupActionSoundeventPrioritySchema>("CSosGroupActionSoundeventPrioritySchema")
        .addConstructor<void (*)(std::string)>()
        .addProperty("PriorityValue", &GCSosGroupActionSoundeventPrioritySchema::GetPriorityValue, &GCSosGroupActionSoundeventPrioritySchema::SetPriorityValue)
        .addProperty("PriorityVolumeScalar", &GCSosGroupActionSoundeventPrioritySchema::GetPriorityVolumeScalar, &GCSosGroupActionSoundeventPrioritySchema::SetPriorityVolumeScalar)
        .addProperty("PriorityContributeButDontRead", &GCSosGroupActionSoundeventPrioritySchema::GetPriorityContributeButDontRead, &GCSosGroupActionSoundeventPrioritySchema::SetPriorityContributeButDontRead)
        .addProperty("PriorityReadButDontContribute", &GCSosGroupActionSoundeventPrioritySchema::GetPriorityReadButDontContribute, &GCSosGroupActionSoundeventPrioritySchema::SetPriorityReadButDontContribute)
        .addProperty("Parent", &GCSosGroupActionSoundeventPrioritySchema::GetParent, &GCSosGroupActionSoundeventPrioritySchema::SetParent)
        .addFunction("ToPtr", &GCSosGroupActionSoundeventPrioritySchema::ToPtr)
        .addFunction("IsValid", &GCSosGroupActionSoundeventPrioritySchema::IsValid)
        .endClass();
}
GCBonePositionMetricEvaluator::GCBonePositionMetricEvaluator(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCBonePositionMetricEvaluator::GCBonePositionMetricEvaluator(void *ptr) {
    m_ptr = ptr;
}
int32_t GCBonePositionMetricEvaluator::GetBoneIndex() const {
    return GetSchemaValue<int32_t>(m_ptr, "CBonePositionMetricEvaluator", "m_nBoneIndex");
}
void GCBonePositionMetricEvaluator::SetBoneIndex(int32_t value) {
    SetSchemaValue(m_ptr, "CBonePositionMetricEvaluator", "m_nBoneIndex", false, value);
}
std::string GCBonePositionMetricEvaluator::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCBonePositionMetricEvaluator::IsValid() {
    return (m_ptr != nullptr);
}
GCMotionMetricEvaluator GCBonePositionMetricEvaluator::GetParent() const {
    GCMotionMetricEvaluator value(m_ptr);
    return value;
}
void GCBonePositionMetricEvaluator::SetParent(GCMotionMetricEvaluator value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCBonePositionMetricEvaluator(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCBonePositionMetricEvaluator>("CBonePositionMetricEvaluator")
        .addConstructor<void (*)(std::string)>()
        .addProperty("BoneIndex", &GCBonePositionMetricEvaluator::GetBoneIndex, &GCBonePositionMetricEvaluator::SetBoneIndex)
        .addProperty("Parent", &GCBonePositionMetricEvaluator::GetParent, &GCBonePositionMetricEvaluator::SetParent)
        .addFunction("ToPtr", &GCBonePositionMetricEvaluator::ToPtr)
        .addFunction("IsValid", &GCBonePositionMetricEvaluator::IsValid)
        .endClass();
}
GCPhysSurfacePropertiesAudio::GCPhysSurfacePropertiesAudio(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCPhysSurfacePropertiesAudio::GCPhysSurfacePropertiesAudio(void *ptr) {
    m_ptr = ptr;
}
float GCPhysSurfacePropertiesAudio::GetReflectivity() const {
    return GetSchemaValue<float>(m_ptr, "CPhysSurfacePropertiesAudio", "m_reflectivity");
}
void GCPhysSurfacePropertiesAudio::SetReflectivity(float value) {
    SetSchemaValue(m_ptr, "CPhysSurfacePropertiesAudio", "m_reflectivity", false, value);
}
float GCPhysSurfacePropertiesAudio::GetHardnessFactor() const {
    return GetSchemaValue<float>(m_ptr, "CPhysSurfacePropertiesAudio", "m_hardnessFactor");
}
void GCPhysSurfacePropertiesAudio::SetHardnessFactor(float value) {
    SetSchemaValue(m_ptr, "CPhysSurfacePropertiesAudio", "m_hardnessFactor", false, value);
}
float GCPhysSurfacePropertiesAudio::GetRoughnessFactor() const {
    return GetSchemaValue<float>(m_ptr, "CPhysSurfacePropertiesAudio", "m_roughnessFactor");
}
void GCPhysSurfacePropertiesAudio::SetRoughnessFactor(float value) {
    SetSchemaValue(m_ptr, "CPhysSurfacePropertiesAudio", "m_roughnessFactor", false, value);
}
float GCPhysSurfacePropertiesAudio::GetRoughThreshold() const {
    return GetSchemaValue<float>(m_ptr, "CPhysSurfacePropertiesAudio", "m_roughThreshold");
}
void GCPhysSurfacePropertiesAudio::SetRoughThreshold(float value) {
    SetSchemaValue(m_ptr, "CPhysSurfacePropertiesAudio", "m_roughThreshold", false, value);
}
float GCPhysSurfacePropertiesAudio::GetHardThreshold() const {
    return GetSchemaValue<float>(m_ptr, "CPhysSurfacePropertiesAudio", "m_hardThreshold");
}
void GCPhysSurfacePropertiesAudio::SetHardThreshold(float value) {
    SetSchemaValue(m_ptr, "CPhysSurfacePropertiesAudio", "m_hardThreshold", false, value);
}
float GCPhysSurfacePropertiesAudio::GetHardVelocityThreshold() const {
    return GetSchemaValue<float>(m_ptr, "CPhysSurfacePropertiesAudio", "m_hardVelocityThreshold");
}
void GCPhysSurfacePropertiesAudio::SetHardVelocityThreshold(float value) {
    SetSchemaValue(m_ptr, "CPhysSurfacePropertiesAudio", "m_hardVelocityThreshold", false, value);
}
float GCPhysSurfacePropertiesAudio::GetStaticImpactVolume() const {
    return GetSchemaValue<float>(m_ptr, "CPhysSurfacePropertiesAudio", "m_flStaticImpactVolume");
}
void GCPhysSurfacePropertiesAudio::SetStaticImpactVolume(float value) {
    SetSchemaValue(m_ptr, "CPhysSurfacePropertiesAudio", "m_flStaticImpactVolume", false, value);
}
float GCPhysSurfacePropertiesAudio::GetOcclusionFactor() const {
    return GetSchemaValue<float>(m_ptr, "CPhysSurfacePropertiesAudio", "m_flOcclusionFactor");
}
void GCPhysSurfacePropertiesAudio::SetOcclusionFactor(float value) {
    SetSchemaValue(m_ptr, "CPhysSurfacePropertiesAudio", "m_flOcclusionFactor", false, value);
}
std::string GCPhysSurfacePropertiesAudio::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCPhysSurfacePropertiesAudio::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCPhysSurfacePropertiesAudio(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCPhysSurfacePropertiesAudio>("CPhysSurfacePropertiesAudio")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Reflectivity", &GCPhysSurfacePropertiesAudio::GetReflectivity, &GCPhysSurfacePropertiesAudio::SetReflectivity)
        .addProperty("HardnessFactor", &GCPhysSurfacePropertiesAudio::GetHardnessFactor, &GCPhysSurfacePropertiesAudio::SetHardnessFactor)
        .addProperty("RoughnessFactor", &GCPhysSurfacePropertiesAudio::GetRoughnessFactor, &GCPhysSurfacePropertiesAudio::SetRoughnessFactor)
        .addProperty("RoughThreshold", &GCPhysSurfacePropertiesAudio::GetRoughThreshold, &GCPhysSurfacePropertiesAudio::SetRoughThreshold)
        .addProperty("HardThreshold", &GCPhysSurfacePropertiesAudio::GetHardThreshold, &GCPhysSurfacePropertiesAudio::SetHardThreshold)
        .addProperty("HardVelocityThreshold", &GCPhysSurfacePropertiesAudio::GetHardVelocityThreshold, &GCPhysSurfacePropertiesAudio::SetHardVelocityThreshold)
        .addProperty("StaticImpactVolume", &GCPhysSurfacePropertiesAudio::GetStaticImpactVolume, &GCPhysSurfacePropertiesAudio::SetStaticImpactVolume)
        .addProperty("OcclusionFactor", &GCPhysSurfacePropertiesAudio::GetOcclusionFactor, &GCPhysSurfacePropertiesAudio::SetOcclusionFactor)
        .addFunction("ToPtr", &GCPhysSurfacePropertiesAudio::ToPtr)
        .addFunction("IsValid", &GCPhysSurfacePropertiesAudio::IsValid)
        .endClass();
}
GCNmIDValueNode::GCNmIDValueNode(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCNmIDValueNode::GCNmIDValueNode(void *ptr) {
    m_ptr = ptr;
}
std::string GCNmIDValueNode::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCNmIDValueNode::IsValid() {
    return (m_ptr != nullptr);
}
GCNmValueNode GCNmIDValueNode::GetParent() const {
    GCNmValueNode value(m_ptr);
    return value;
}
void GCNmIDValueNode::SetParent(GCNmValueNode value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCNmIDValueNode(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCNmIDValueNode>("CNmIDValueNode")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCNmIDValueNode::GetParent, &GCNmIDValueNode::SetParent)
        .addFunction("ToPtr", &GCNmIDValueNode::ToPtr)
        .addFunction("IsValid", &GCNmIDValueNode::IsValid)
        .endClass();
}
GFeSimdNodeBase_t::GFeSimdNodeBase_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GFeSimdNodeBase_t::GFeSimdNodeBase_t(void *ptr) {
    m_ptr = ptr;
}
std::vector<uint16_t> GFeSimdNodeBase_t::GetNode() const {
    uint16_t* outValue = GetSchemaValue<uint16_t*>(m_ptr, "FeSimdNodeBase_t", "nNode"); std::vector<uint16_t> ret; for(int i = 0; i < 4; i++) { ret.push_back(outValue[i]); } return ret;
}
void GFeSimdNodeBase_t::SetNode(std::vector<uint16_t> value) {
    uint16_t* outValue = GetSchemaValue<uint16_t*>(m_ptr, "FeSimdNodeBase_t", "nNode"); for(int i = 0; i < 4; i++) { outValue[i] = value[i]; } SetSchemaValue(m_ptr, "FeSimdNodeBase_t", "nNode", true, outValue);
}
std::vector<uint16_t> GFeSimdNodeBase_t::GetNodeX0() const {
    uint16_t* outValue = GetSchemaValue<uint16_t*>(m_ptr, "FeSimdNodeBase_t", "nNodeX0"); std::vector<uint16_t> ret; for(int i = 0; i < 4; i++) { ret.push_back(outValue[i]); } return ret;
}
void GFeSimdNodeBase_t::SetNodeX0(std::vector<uint16_t> value) {
    uint16_t* outValue = GetSchemaValue<uint16_t*>(m_ptr, "FeSimdNodeBase_t", "nNodeX0"); for(int i = 0; i < 4; i++) { outValue[i] = value[i]; } SetSchemaValue(m_ptr, "FeSimdNodeBase_t", "nNodeX0", true, outValue);
}
std::vector<uint16_t> GFeSimdNodeBase_t::GetNodeX1() const {
    uint16_t* outValue = GetSchemaValue<uint16_t*>(m_ptr, "FeSimdNodeBase_t", "nNodeX1"); std::vector<uint16_t> ret; for(int i = 0; i < 4; i++) { ret.push_back(outValue[i]); } return ret;
}
void GFeSimdNodeBase_t::SetNodeX1(std::vector<uint16_t> value) {
    uint16_t* outValue = GetSchemaValue<uint16_t*>(m_ptr, "FeSimdNodeBase_t", "nNodeX1"); for(int i = 0; i < 4; i++) { outValue[i] = value[i]; } SetSchemaValue(m_ptr, "FeSimdNodeBase_t", "nNodeX1", true, outValue);
}
std::vector<uint16_t> GFeSimdNodeBase_t::GetNodeY0() const {
    uint16_t* outValue = GetSchemaValue<uint16_t*>(m_ptr, "FeSimdNodeBase_t", "nNodeY0"); std::vector<uint16_t> ret; for(int i = 0; i < 4; i++) { ret.push_back(outValue[i]); } return ret;
}
void GFeSimdNodeBase_t::SetNodeY0(std::vector<uint16_t> value) {
    uint16_t* outValue = GetSchemaValue<uint16_t*>(m_ptr, "FeSimdNodeBase_t", "nNodeY0"); for(int i = 0; i < 4; i++) { outValue[i] = value[i]; } SetSchemaValue(m_ptr, "FeSimdNodeBase_t", "nNodeY0", true, outValue);
}
std::vector<uint16_t> GFeSimdNodeBase_t::GetNodeY1() const {
    uint16_t* outValue = GetSchemaValue<uint16_t*>(m_ptr, "FeSimdNodeBase_t", "nNodeY1"); std::vector<uint16_t> ret; for(int i = 0; i < 4; i++) { ret.push_back(outValue[i]); } return ret;
}
void GFeSimdNodeBase_t::SetNodeY1(std::vector<uint16_t> value) {
    uint16_t* outValue = GetSchemaValue<uint16_t*>(m_ptr, "FeSimdNodeBase_t", "nNodeY1"); for(int i = 0; i < 4; i++) { outValue[i] = value[i]; } SetSchemaValue(m_ptr, "FeSimdNodeBase_t", "nNodeY1", true, outValue);
}
std::vector<uint16_t> GFeSimdNodeBase_t::GetDummy() const {
    uint16_t* outValue = GetSchemaValue<uint16_t*>(m_ptr, "FeSimdNodeBase_t", "nDummy"); std::vector<uint16_t> ret; for(int i = 0; i < 4; i++) { ret.push_back(outValue[i]); } return ret;
}
void GFeSimdNodeBase_t::SetDummy(std::vector<uint16_t> value) {
    uint16_t* outValue = GetSchemaValue<uint16_t*>(m_ptr, "FeSimdNodeBase_t", "nDummy"); for(int i = 0; i < 4; i++) { outValue[i] = value[i]; } SetSchemaValue(m_ptr, "FeSimdNodeBase_t", "nDummy", true, outValue);
}
GFourQuaternions GFeSimdNodeBase_t::GetAdjust() const {
    GFourQuaternions value(GetSchemaPtr(m_ptr, "FeSimdNodeBase_t", "qAdjust"));
    return value;
}
void GFeSimdNodeBase_t::SetAdjust(GFourQuaternions value) {
    SetSchemaValue(m_ptr, "FeSimdNodeBase_t", "qAdjust", true, value);
}
std::string GFeSimdNodeBase_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GFeSimdNodeBase_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassFeSimdNodeBase_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GFeSimdNodeBase_t>("FeSimdNodeBase_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Node", &GFeSimdNodeBase_t::GetNode, &GFeSimdNodeBase_t::SetNode)
        .addProperty("NodeX0", &GFeSimdNodeBase_t::GetNodeX0, &GFeSimdNodeBase_t::SetNodeX0)
        .addProperty("NodeX1", &GFeSimdNodeBase_t::GetNodeX1, &GFeSimdNodeBase_t::SetNodeX1)
        .addProperty("NodeY0", &GFeSimdNodeBase_t::GetNodeY0, &GFeSimdNodeBase_t::SetNodeY0)
        .addProperty("NodeY1", &GFeSimdNodeBase_t::GetNodeY1, &GFeSimdNodeBase_t::SetNodeY1)
        .addProperty("Dummy", &GFeSimdNodeBase_t::GetDummy, &GFeSimdNodeBase_t::SetDummy)
        .addProperty("Adjust", &GFeSimdNodeBase_t::GetAdjust, &GFeSimdNodeBase_t::SetAdjust)
        .addFunction("ToPtr", &GFeSimdNodeBase_t::ToPtr)
        .addFunction("IsValid", &GFeSimdNodeBase_t::IsValid)
        .endClass();
}
GPermModelExtPart_t::GPermModelExtPart_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GPermModelExtPart_t::GPermModelExtPart_t(void *ptr) {
    m_ptr = ptr;
}
std::string GPermModelExtPart_t::GetName() const {
    return GetSchemaValue<CUtlString>(m_ptr, "PermModelExtPart_t", "m_Name").Get();
}
void GPermModelExtPart_t::SetName(std::string value) {
    SetSchemaValue(m_ptr, "PermModelExtPart_t", "m_Name", true, CUtlString(value.c_str()));
}
int32_t GPermModelExtPart_t::GetParent() const {
    return GetSchemaValue<int32_t>(m_ptr, "PermModelExtPart_t", "m_nParent");
}
void GPermModelExtPart_t::SetParent(int32_t value) {
    SetSchemaValue(m_ptr, "PermModelExtPart_t", "m_nParent", true, value);
}
std::string GPermModelExtPart_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GPermModelExtPart_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassPermModelExtPart_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GPermModelExtPart_t>("PermModelExtPart_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Name", &GPermModelExtPart_t::GetName, &GPermModelExtPart_t::SetName)
        .addProperty("Parent", &GPermModelExtPart_t::GetParent, &GPermModelExtPart_t::SetParent)
        .addFunction("ToPtr", &GPermModelExtPart_t::ToPtr)
        .addFunction("IsValid", &GPermModelExtPart_t::IsValid)
        .endClass();
}
GCCurrentRotationVelocityMetricEvaluator::GCCurrentRotationVelocityMetricEvaluator(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCCurrentRotationVelocityMetricEvaluator::GCCurrentRotationVelocityMetricEvaluator(void *ptr) {
    m_ptr = ptr;
}
std::string GCCurrentRotationVelocityMetricEvaluator::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCCurrentRotationVelocityMetricEvaluator::IsValid() {
    return (m_ptr != nullptr);
}
GCMotionMetricEvaluator GCCurrentRotationVelocityMetricEvaluator::GetParent() const {
    GCMotionMetricEvaluator value(m_ptr);
    return value;
}
void GCCurrentRotationVelocityMetricEvaluator::SetParent(GCMotionMetricEvaluator value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCCurrentRotationVelocityMetricEvaluator(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCCurrentRotationVelocityMetricEvaluator>("CCurrentRotationVelocityMetricEvaluator")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCCurrentRotationVelocityMetricEvaluator::GetParent, &GCCurrentRotationVelocityMetricEvaluator::SetParent)
        .addFunction("ToPtr", &GCCurrentRotationVelocityMetricEvaluator::ToPtr)
        .addFunction("IsValid", &GCCurrentRotationVelocityMetricEvaluator::IsValid)
        .endClass();
}
GCAnimEventDefinition::GCAnimEventDefinition(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCAnimEventDefinition::GCAnimEventDefinition(void *ptr) {
    m_ptr = ptr;
}
int32_t GCAnimEventDefinition::GetFrame() const {
    return GetSchemaValue<int32_t>(m_ptr, "CAnimEventDefinition", "m_nFrame");
}
void GCAnimEventDefinition::SetFrame(int32_t value) {
    SetSchemaValue(m_ptr, "CAnimEventDefinition", "m_nFrame", false, value);
}
int32_t GCAnimEventDefinition::GetEndFrame() const {
    return GetSchemaValue<int32_t>(m_ptr, "CAnimEventDefinition", "m_nEndFrame");
}
void GCAnimEventDefinition::SetEndFrame(int32_t value) {
    SetSchemaValue(m_ptr, "CAnimEventDefinition", "m_nEndFrame", false, value);
}
float GCAnimEventDefinition::GetCycle() const {
    return GetSchemaValue<float>(m_ptr, "CAnimEventDefinition", "m_flCycle");
}
void GCAnimEventDefinition::SetCycle(float value) {
    SetSchemaValue(m_ptr, "CAnimEventDefinition", "m_flCycle", false, value);
}
float GCAnimEventDefinition::GetDuration() const {
    return GetSchemaValue<float>(m_ptr, "CAnimEventDefinition", "m_flDuration");
}
void GCAnimEventDefinition::SetDuration(float value) {
    SetSchemaValue(m_ptr, "CAnimEventDefinition", "m_flDuration", false, value);
}
CBufferString GCAnimEventDefinition::GetLegacyOptions() const {
    return GetSchemaValue<CBufferString>(m_ptr, "CAnimEventDefinition", "m_sLegacyOptions");
}
void GCAnimEventDefinition::SetLegacyOptions(CBufferString value) {
    SetSchemaValue(m_ptr, "CAnimEventDefinition", "m_sLegacyOptions", false, value);
}
std::string GCAnimEventDefinition::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCAnimEventDefinition::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCAnimEventDefinition(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCAnimEventDefinition>("CAnimEventDefinition")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Frame", &GCAnimEventDefinition::GetFrame, &GCAnimEventDefinition::SetFrame)
        .addProperty("EndFrame", &GCAnimEventDefinition::GetEndFrame, &GCAnimEventDefinition::SetEndFrame)
        .addProperty("Cycle", &GCAnimEventDefinition::GetCycle, &GCAnimEventDefinition::SetCycle)
        .addProperty("Duration", &GCAnimEventDefinition::GetDuration, &GCAnimEventDefinition::SetDuration)
        .addProperty("LegacyOptions", &GCAnimEventDefinition::GetLegacyOptions, &GCAnimEventDefinition::SetLegacyOptions)
        .addFunction("ToPtr", &GCAnimEventDefinition::ToPtr)
        .addFunction("IsValid", &GCAnimEventDefinition::IsValid)
        .endClass();
}
GCAnimEnum::GCAnimEnum(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCAnimEnum::GCAnimEnum(void *ptr) {
    m_ptr = ptr;
}
uint8_t GCAnimEnum::GetValue() const {
    return GetSchemaValue<uint8_t>(m_ptr, "CAnimEnum", "m_value");
}
void GCAnimEnum::SetValue(uint8_t value) {
    SetSchemaValue(m_ptr, "CAnimEnum", "m_value", false, value);
}
std::string GCAnimEnum::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCAnimEnum::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCAnimEnum(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCAnimEnum>("CAnimEnum")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Value", &GCAnimEnum::GetValue, &GCAnimEnum::SetValue)
        .addFunction("ToPtr", &GCAnimEnum::ToPtr)
        .addFunction("IsValid", &GCAnimEnum::IsValid)
        .endClass();
}
GCAnimFrameBlockAnim::GCAnimFrameBlockAnim(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCAnimFrameBlockAnim::GCAnimFrameBlockAnim(void *ptr) {
    m_ptr = ptr;
}
int32_t GCAnimFrameBlockAnim::GetStartFrame() const {
    return GetSchemaValue<int32_t>(m_ptr, "CAnimFrameBlockAnim", "m_nStartFrame");
}
void GCAnimFrameBlockAnim::SetStartFrame(int32_t value) {
    SetSchemaValue(m_ptr, "CAnimFrameBlockAnim", "m_nStartFrame", false, value);
}
int32_t GCAnimFrameBlockAnim::GetEndFrame() const {
    return GetSchemaValue<int32_t>(m_ptr, "CAnimFrameBlockAnim", "m_nEndFrame");
}
void GCAnimFrameBlockAnim::SetEndFrame(int32_t value) {
    SetSchemaValue(m_ptr, "CAnimFrameBlockAnim", "m_nEndFrame", false, value);
}
std::vector<int32> GCAnimFrameBlockAnim::GetSegmentIndexArray() const {
    CUtlVector<int32>* vec = GetSchemaValue<CUtlVector<int32>*>(m_ptr, "CAnimFrameBlockAnim", "m_segmentIndexArray"); std::vector<int32> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCAnimFrameBlockAnim::SetSegmentIndexArray(std::vector<int32> value) {
    SetSchemaValueCUtlVector<int32>(m_ptr, "CAnimFrameBlockAnim", "m_segmentIndexArray", false, value);
}
std::string GCAnimFrameBlockAnim::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCAnimFrameBlockAnim::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCAnimFrameBlockAnim(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCAnimFrameBlockAnim>("CAnimFrameBlockAnim")
        .addConstructor<void (*)(std::string)>()
        .addProperty("StartFrame", &GCAnimFrameBlockAnim::GetStartFrame, &GCAnimFrameBlockAnim::SetStartFrame)
        .addProperty("EndFrame", &GCAnimFrameBlockAnim::GetEndFrame, &GCAnimFrameBlockAnim::SetEndFrame)
        .addProperty("SegmentIndexArray", &GCAnimFrameBlockAnim::GetSegmentIndexArray, &GCAnimFrameBlockAnim::SetSegmentIndexArray)
        .addFunction("ToPtr", &GCAnimFrameBlockAnim::ToPtr)
        .addFunction("IsValid", &GCAnimFrameBlockAnim::IsValid)
        .endClass();
}
GCNmVirtualParameterIDNode::GCNmVirtualParameterIDNode(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCNmVirtualParameterIDNode::GCNmVirtualParameterIDNode(void *ptr) {
    m_ptr = ptr;
}
int16_t GCNmVirtualParameterIDNode::GetChildNodeIdx() const {
    return GetSchemaValue<int16_t>(m_ptr, "CNmVirtualParameterIDNode", "m_nChildNodeIdx");
}
void GCNmVirtualParameterIDNode::SetChildNodeIdx(int16_t value) {
    SetSchemaValue(m_ptr, "CNmVirtualParameterIDNode", "m_nChildNodeIdx", false, value);
}
std::string GCNmVirtualParameterIDNode::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCNmVirtualParameterIDNode::IsValid() {
    return (m_ptr != nullptr);
}
GCNmIDValueNode GCNmVirtualParameterIDNode::GetParent() const {
    GCNmIDValueNode value(m_ptr);
    return value;
}
void GCNmVirtualParameterIDNode::SetParent(GCNmIDValueNode value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCNmVirtualParameterIDNode(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCNmVirtualParameterIDNode>("CNmVirtualParameterIDNode")
        .addConstructor<void (*)(std::string)>()
        .addProperty("ChildNodeIdx", &GCNmVirtualParameterIDNode::GetChildNodeIdx, &GCNmVirtualParameterIDNode::SetChildNodeIdx)
        .addProperty("Parent", &GCNmVirtualParameterIDNode::GetParent, &GCNmVirtualParameterIDNode::SetParent)
        .addFunction("ToPtr", &GCNmVirtualParameterIDNode::ToPtr)
        .addFunction("IsValid", &GCNmVirtualParameterIDNode::IsValid)
        .endClass();
}
GCFlashlightEffect::GCFlashlightEffect(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCFlashlightEffect::GCFlashlightEffect(void *ptr) {
    m_ptr = ptr;
}
bool GCFlashlightEffect::GetIsOn() const {
    return GetSchemaValue<bool>(m_ptr, "CFlashlightEffect", "m_bIsOn");
}
void GCFlashlightEffect::SetIsOn(bool value) {
    SetSchemaValue(m_ptr, "CFlashlightEffect", "m_bIsOn", false, value);
}
bool GCFlashlightEffect::GetMuzzleFlashEnabled() const {
    return GetSchemaValue<bool>(m_ptr, "CFlashlightEffect", "m_bMuzzleFlashEnabled");
}
void GCFlashlightEffect::SetMuzzleFlashEnabled(bool value) {
    SetSchemaValue(m_ptr, "CFlashlightEffect", "m_bMuzzleFlashEnabled", false, value);
}
float GCFlashlightEffect::GetMuzzleFlashBrightness() const {
    return GetSchemaValue<float>(m_ptr, "CFlashlightEffect", "m_flMuzzleFlashBrightness");
}
void GCFlashlightEffect::SetMuzzleFlashBrightness(float value) {
    SetSchemaValue(m_ptr, "CFlashlightEffect", "m_flMuzzleFlashBrightness", false, value);
}
Quaternion GCFlashlightEffect::GetQuatMuzzleFlashOrientation() const {
    return GetSchemaValue<Quaternion>(m_ptr, "CFlashlightEffect", "m_quatMuzzleFlashOrientation");
}
void GCFlashlightEffect::SetQuatMuzzleFlashOrientation(Quaternion value) {
    SetSchemaValue(m_ptr, "CFlashlightEffect", "m_quatMuzzleFlashOrientation", false, value);
}
Vector GCFlashlightEffect::GetMuzzleFlashOrigin() const {
    return GetSchemaValue<Vector>(m_ptr, "CFlashlightEffect", "m_vecMuzzleFlashOrigin");
}
void GCFlashlightEffect::SetMuzzleFlashOrigin(Vector value) {
    SetSchemaValue(m_ptr, "CFlashlightEffect", "m_vecMuzzleFlashOrigin", false, value);
}
float GCFlashlightEffect::GetFov() const {
    return GetSchemaValue<float>(m_ptr, "CFlashlightEffect", "m_flFov");
}
void GCFlashlightEffect::SetFov(float value) {
    SetSchemaValue(m_ptr, "CFlashlightEffect", "m_flFov", false, value);
}
float GCFlashlightEffect::GetFarZ() const {
    return GetSchemaValue<float>(m_ptr, "CFlashlightEffect", "m_flFarZ");
}
void GCFlashlightEffect::SetFarZ(float value) {
    SetSchemaValue(m_ptr, "CFlashlightEffect", "m_flFarZ", false, value);
}
float GCFlashlightEffect::GetLinearAtten() const {
    return GetSchemaValue<float>(m_ptr, "CFlashlightEffect", "m_flLinearAtten");
}
void GCFlashlightEffect::SetLinearAtten(float value) {
    SetSchemaValue(m_ptr, "CFlashlightEffect", "m_flLinearAtten", false, value);
}
bool GCFlashlightEffect::GetCastsShadows() const {
    return GetSchemaValue<bool>(m_ptr, "CFlashlightEffect", "m_bCastsShadows");
}
void GCFlashlightEffect::SetCastsShadows(bool value) {
    SetSchemaValue(m_ptr, "CFlashlightEffect", "m_bCastsShadows", false, value);
}
float GCFlashlightEffect::GetCurrentPullBackDist() const {
    return GetSchemaValue<float>(m_ptr, "CFlashlightEffect", "m_flCurrentPullBackDist");
}
void GCFlashlightEffect::SetCurrentPullBackDist(float value) {
    SetSchemaValue(m_ptr, "CFlashlightEffect", "m_flCurrentPullBackDist", false, value);
}
std::string GCFlashlightEffect::GetTextureName() const {
    return GetSchemaValuePtr<char>(m_ptr, "CFlashlightEffect", "m_textureName");
}
void GCFlashlightEffect::SetTextureName(std::string value) {
    WriteSchemaPtrValue(m_ptr, "CFlashlightEffect", "m_textureName", false, reinterpret_cast<byte*>(const_cast<char*>(value.c_str())), 64);
}
std::string GCFlashlightEffect::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCFlashlightEffect::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCFlashlightEffect(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCFlashlightEffect>("CFlashlightEffect")
        .addConstructor<void (*)(std::string)>()
        .addProperty("IsOn", &GCFlashlightEffect::GetIsOn, &GCFlashlightEffect::SetIsOn)
        .addProperty("MuzzleFlashEnabled", &GCFlashlightEffect::GetMuzzleFlashEnabled, &GCFlashlightEffect::SetMuzzleFlashEnabled)
        .addProperty("MuzzleFlashBrightness", &GCFlashlightEffect::GetMuzzleFlashBrightness, &GCFlashlightEffect::SetMuzzleFlashBrightness)
        .addProperty("QuatMuzzleFlashOrientation", &GCFlashlightEffect::GetQuatMuzzleFlashOrientation, &GCFlashlightEffect::SetQuatMuzzleFlashOrientation)
        .addProperty("MuzzleFlashOrigin", &GCFlashlightEffect::GetMuzzleFlashOrigin, &GCFlashlightEffect::SetMuzzleFlashOrigin)
        .addProperty("Fov", &GCFlashlightEffect::GetFov, &GCFlashlightEffect::SetFov)
        .addProperty("FarZ", &GCFlashlightEffect::GetFarZ, &GCFlashlightEffect::SetFarZ)
        .addProperty("LinearAtten", &GCFlashlightEffect::GetLinearAtten, &GCFlashlightEffect::SetLinearAtten)
        .addProperty("CastsShadows", &GCFlashlightEffect::GetCastsShadows, &GCFlashlightEffect::SetCastsShadows)
        .addProperty("CurrentPullBackDist", &GCFlashlightEffect::GetCurrentPullBackDist, &GCFlashlightEffect::SetCurrentPullBackDist)
        .addProperty("TextureName", &GCFlashlightEffect::GetTextureName, &GCFlashlightEffect::SetTextureName)
        .addFunction("ToPtr", &GCFlashlightEffect::ToPtr)
        .addFunction("IsValid", &GCFlashlightEffect::IsValid)
        .endClass();
}
GFeBuildSphereRigid_t::GFeBuildSphereRigid_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GFeBuildSphereRigid_t::GFeBuildSphereRigid_t(void *ptr) {
    m_ptr = ptr;
}
int32_t GFeBuildSphereRigid_t::GetPriority() const {
    return GetSchemaValue<int32_t>(m_ptr, "FeBuildSphereRigid_t", "m_nPriority");
}
void GFeBuildSphereRigid_t::SetPriority(int32_t value) {
    SetSchemaValue(m_ptr, "FeBuildSphereRigid_t", "m_nPriority", true, value);
}
uint32_t GFeBuildSphereRigid_t::GetVertexMapHash() const {
    return GetSchemaValue<uint32_t>(m_ptr, "FeBuildSphereRigid_t", "m_nVertexMapHash");
}
void GFeBuildSphereRigid_t::SetVertexMapHash(uint32_t value) {
    SetSchemaValue(m_ptr, "FeBuildSphereRigid_t", "m_nVertexMapHash", true, value);
}
std::string GFeBuildSphereRigid_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GFeBuildSphereRigid_t::IsValid() {
    return (m_ptr != nullptr);
}
GFeSphereRigid_t GFeBuildSphereRigid_t::GetParent() const {
    GFeSphereRigid_t value(m_ptr);
    return value;
}
void GFeBuildSphereRigid_t::SetParent(GFeSphereRigid_t value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassFeBuildSphereRigid_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GFeBuildSphereRigid_t>("FeBuildSphereRigid_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Priority", &GFeBuildSphereRigid_t::GetPriority, &GFeBuildSphereRigid_t::SetPriority)
        .addProperty("VertexMapHash", &GFeBuildSphereRigid_t::GetVertexMapHash, &GFeBuildSphereRigid_t::SetVertexMapHash)
        .addProperty("Parent", &GFeBuildSphereRigid_t::GetParent, &GFeBuildSphereRigid_t::SetParent)
        .addFunction("ToPtr", &GFeBuildSphereRigid_t::ToPtr)
        .addFunction("IsValid", &GFeBuildSphereRigid_t::IsValid)
        .endClass();
}
GCAnimEncodedFrames::GCAnimEncodedFrames(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCAnimEncodedFrames::GCAnimEncodedFrames(void *ptr) {
    m_ptr = ptr;
}
CBufferString GCAnimEncodedFrames::GetFileName() const {
    return GetSchemaValue<CBufferString>(m_ptr, "CAnimEncodedFrames", "m_fileName");
}
void GCAnimEncodedFrames::SetFileName(CBufferString value) {
    SetSchemaValue(m_ptr, "CAnimEncodedFrames", "m_fileName", false, value);
}
int32_t GCAnimEncodedFrames::GetFrames() const {
    return GetSchemaValue<int32_t>(m_ptr, "CAnimEncodedFrames", "m_nFrames");
}
void GCAnimEncodedFrames::SetFrames(int32_t value) {
    SetSchemaValue(m_ptr, "CAnimEncodedFrames", "m_nFrames", false, value);
}
int32_t GCAnimEncodedFrames::GetFramesPerBlock() const {
    return GetSchemaValue<int32_t>(m_ptr, "CAnimEncodedFrames", "m_nFramesPerBlock");
}
void GCAnimEncodedFrames::SetFramesPerBlock(int32_t value) {
    SetSchemaValue(m_ptr, "CAnimEncodedFrames", "m_nFramesPerBlock", false, value);
}
std::vector<GCAnimFrameBlockAnim> GCAnimEncodedFrames::GetFrameblockArray() const {
    CUtlVector<GCAnimFrameBlockAnim>* vec = GetSchemaValue<CUtlVector<GCAnimFrameBlockAnim>*>(m_ptr, "CAnimEncodedFrames", "m_frameblockArray"); std::vector<GCAnimFrameBlockAnim> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCAnimEncodedFrames::SetFrameblockArray(std::vector<GCAnimFrameBlockAnim> value) {
    SetSchemaValueCUtlVector<GCAnimFrameBlockAnim>(m_ptr, "CAnimEncodedFrames", "m_frameblockArray", false, value);
}
GCAnimEncodeDifference GCAnimEncodedFrames::GetUsageDifferences() const {
    GCAnimEncodeDifference value(GetSchemaPtr(m_ptr, "CAnimEncodedFrames", "m_usageDifferences"));
    return value;
}
void GCAnimEncodedFrames::SetUsageDifferences(GCAnimEncodeDifference value) {
    SetSchemaValue(m_ptr, "CAnimEncodedFrames", "m_usageDifferences", false, value);
}
std::string GCAnimEncodedFrames::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCAnimEncodedFrames::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCAnimEncodedFrames(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCAnimEncodedFrames>("CAnimEncodedFrames")
        .addConstructor<void (*)(std::string)>()
        .addProperty("FileName", &GCAnimEncodedFrames::GetFileName, &GCAnimEncodedFrames::SetFileName)
        .addProperty("Frames", &GCAnimEncodedFrames::GetFrames, &GCAnimEncodedFrames::SetFrames)
        .addProperty("FramesPerBlock", &GCAnimEncodedFrames::GetFramesPerBlock, &GCAnimEncodedFrames::SetFramesPerBlock)
        .addProperty("FrameblockArray", &GCAnimEncodedFrames::GetFrameblockArray, &GCAnimEncodedFrames::SetFrameblockArray)
        .addProperty("UsageDifferences", &GCAnimEncodedFrames::GetUsageDifferences, &GCAnimEncodedFrames::SetUsageDifferences)
        .addFunction("ToPtr", &GCAnimEncodedFrames::ToPtr)
        .addFunction("IsValid", &GCAnimEncodedFrames::IsValid)
        .endClass();
}
GEventSetTime_t::GEventSetTime_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GEventSetTime_t::GEventSetTime_t(void *ptr) {
    m_ptr = ptr;
}
GEngineLoopState_t GEventSetTime_t::GetLoopState() const {
    GEngineLoopState_t value(GetSchemaPtr(m_ptr, "EventSetTime_t", "m_LoopState"));
    return value;
}
void GEventSetTime_t::SetLoopState(GEngineLoopState_t value) {
    SetSchemaValue(m_ptr, "EventSetTime_t", "m_LoopState", true, value);
}
int32_t GEventSetTime_t::GetClientOutputFrames() const {
    return GetSchemaValue<int32_t>(m_ptr, "EventSetTime_t", "m_nClientOutputFrames");
}
void GEventSetTime_t::SetClientOutputFrames(int32_t value) {
    SetSchemaValue(m_ptr, "EventSetTime_t", "m_nClientOutputFrames", true, value);
}
double GEventSetTime_t::GetRealTime() const {
    return GetSchemaValue<double>(m_ptr, "EventSetTime_t", "m_flRealTime");
}
void GEventSetTime_t::SetRealTime(double value) {
    SetSchemaValue(m_ptr, "EventSetTime_t", "m_flRealTime", true, value);
}
double GEventSetTime_t::GetRenderTime() const {
    return GetSchemaValue<double>(m_ptr, "EventSetTime_t", "m_flRenderTime");
}
void GEventSetTime_t::SetRenderTime(double value) {
    SetSchemaValue(m_ptr, "EventSetTime_t", "m_flRenderTime", true, value);
}
double GEventSetTime_t::GetRenderFrameTime() const {
    return GetSchemaValue<double>(m_ptr, "EventSetTime_t", "m_flRenderFrameTime");
}
void GEventSetTime_t::SetRenderFrameTime(double value) {
    SetSchemaValue(m_ptr, "EventSetTime_t", "m_flRenderFrameTime", true, value);
}
double GEventSetTime_t::GetRenderFrameTimeUnbounded() const {
    return GetSchemaValue<double>(m_ptr, "EventSetTime_t", "m_flRenderFrameTimeUnbounded");
}
void GEventSetTime_t::SetRenderFrameTimeUnbounded(double value) {
    SetSchemaValue(m_ptr, "EventSetTime_t", "m_flRenderFrameTimeUnbounded", true, value);
}
double GEventSetTime_t::GetRenderFrameTimeUnscaled() const {
    return GetSchemaValue<double>(m_ptr, "EventSetTime_t", "m_flRenderFrameTimeUnscaled");
}
void GEventSetTime_t::SetRenderFrameTimeUnscaled(double value) {
    SetSchemaValue(m_ptr, "EventSetTime_t", "m_flRenderFrameTimeUnscaled", true, value);
}
double GEventSetTime_t::GetTickRemainder() const {
    return GetSchemaValue<double>(m_ptr, "EventSetTime_t", "m_flTickRemainder");
}
void GEventSetTime_t::SetTickRemainder(double value) {
    SetSchemaValue(m_ptr, "EventSetTime_t", "m_flTickRemainder", true, value);
}
std::string GEventSetTime_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GEventSetTime_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassEventSetTime_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GEventSetTime_t>("EventSetTime_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("LoopState", &GEventSetTime_t::GetLoopState, &GEventSetTime_t::SetLoopState)
        .addProperty("ClientOutputFrames", &GEventSetTime_t::GetClientOutputFrames, &GEventSetTime_t::SetClientOutputFrames)
        .addProperty("RealTime", &GEventSetTime_t::GetRealTime, &GEventSetTime_t::SetRealTime)
        .addProperty("RenderTime", &GEventSetTime_t::GetRenderTime, &GEventSetTime_t::SetRenderTime)
        .addProperty("RenderFrameTime", &GEventSetTime_t::GetRenderFrameTime, &GEventSetTime_t::SetRenderFrameTime)
        .addProperty("RenderFrameTimeUnbounded", &GEventSetTime_t::GetRenderFrameTimeUnbounded, &GEventSetTime_t::SetRenderFrameTimeUnbounded)
        .addProperty("RenderFrameTimeUnscaled", &GEventSetTime_t::GetRenderFrameTimeUnscaled, &GEventSetTime_t::SetRenderFrameTimeUnscaled)
        .addProperty("TickRemainder", &GEventSetTime_t::GetTickRemainder, &GEventSetTime_t::SetTickRemainder)
        .addFunction("ToPtr", &GEventSetTime_t::ToPtr)
        .addFunction("IsValid", &GEventSetTime_t::IsValid)
        .endClass();
}
GOldFeEdge_t::GOldFeEdge_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GOldFeEdge_t::GOldFeEdge_t(void *ptr) {
    m_ptr = ptr;
}
std::vector<float> GOldFeEdge_t::GetK() const {
    float* outValue = GetSchemaValue<float*>(m_ptr, "OldFeEdge_t", "m_flK"); std::vector<float> ret; for(int i = 0; i < 3; i++) { ret.push_back(outValue[i]); } return ret;
}
void GOldFeEdge_t::SetK(std::vector<float> value) {
    float* outValue = GetSchemaValue<float*>(m_ptr, "OldFeEdge_t", "m_flK"); for(int i = 0; i < 3; i++) { outValue[i] = value[i]; } SetSchemaValue(m_ptr, "OldFeEdge_t", "m_flK", true, outValue);
}
float GOldFeEdge_t::GetInvA() const {
    return GetSchemaValue<float>(m_ptr, "OldFeEdge_t", "invA");
}
void GOldFeEdge_t::SetInvA(float value) {
    SetSchemaValue(m_ptr, "OldFeEdge_t", "invA", true, value);
}
float GOldFeEdge_t::GetT() const {
    return GetSchemaValue<float>(m_ptr, "OldFeEdge_t", "t");
}
void GOldFeEdge_t::SetT(float value) {
    SetSchemaValue(m_ptr, "OldFeEdge_t", "t", true, value);
}
float GOldFeEdge_t::GetThetaRelaxed() const {
    return GetSchemaValue<float>(m_ptr, "OldFeEdge_t", "flThetaRelaxed");
}
void GOldFeEdge_t::SetThetaRelaxed(float value) {
    SetSchemaValue(m_ptr, "OldFeEdge_t", "flThetaRelaxed", true, value);
}
float GOldFeEdge_t::GetThetaFactor() const {
    return GetSchemaValue<float>(m_ptr, "OldFeEdge_t", "flThetaFactor");
}
void GOldFeEdge_t::SetThetaFactor(float value) {
    SetSchemaValue(m_ptr, "OldFeEdge_t", "flThetaFactor", true, value);
}
float GOldFeEdge_t::GetC01() const {
    return GetSchemaValue<float>(m_ptr, "OldFeEdge_t", "c01");
}
void GOldFeEdge_t::SetC01(float value) {
    SetSchemaValue(m_ptr, "OldFeEdge_t", "c01", true, value);
}
float GOldFeEdge_t::GetC02() const {
    return GetSchemaValue<float>(m_ptr, "OldFeEdge_t", "c02");
}
void GOldFeEdge_t::SetC02(float value) {
    SetSchemaValue(m_ptr, "OldFeEdge_t", "c02", true, value);
}
float GOldFeEdge_t::GetC03() const {
    return GetSchemaValue<float>(m_ptr, "OldFeEdge_t", "c03");
}
void GOldFeEdge_t::SetC03(float value) {
    SetSchemaValue(m_ptr, "OldFeEdge_t", "c03", true, value);
}
float GOldFeEdge_t::GetC04() const {
    return GetSchemaValue<float>(m_ptr, "OldFeEdge_t", "c04");
}
void GOldFeEdge_t::SetC04(float value) {
    SetSchemaValue(m_ptr, "OldFeEdge_t", "c04", true, value);
}
float GOldFeEdge_t::GetAxialModelDist() const {
    return GetSchemaValue<float>(m_ptr, "OldFeEdge_t", "flAxialModelDist");
}
void GOldFeEdge_t::SetAxialModelDist(float value) {
    SetSchemaValue(m_ptr, "OldFeEdge_t", "flAxialModelDist", true, value);
}
std::vector<float> GOldFeEdge_t::GetAxialModelWeights() const {
    float* outValue = GetSchemaValue<float*>(m_ptr, "OldFeEdge_t", "flAxialModelWeights"); std::vector<float> ret; for(int i = 0; i < 4; i++) { ret.push_back(outValue[i]); } return ret;
}
void GOldFeEdge_t::SetAxialModelWeights(std::vector<float> value) {
    float* outValue = GetSchemaValue<float*>(m_ptr, "OldFeEdge_t", "flAxialModelWeights"); for(int i = 0; i < 4; i++) { outValue[i] = value[i]; } SetSchemaValue(m_ptr, "OldFeEdge_t", "flAxialModelWeights", true, outValue);
}
std::vector<uint16_t> GOldFeEdge_t::GetNode() const {
    uint16_t* outValue = GetSchemaValue<uint16_t*>(m_ptr, "OldFeEdge_t", "m_nNode"); std::vector<uint16_t> ret; for(int i = 0; i < 4; i++) { ret.push_back(outValue[i]); } return ret;
}
void GOldFeEdge_t::SetNode(std::vector<uint16_t> value) {
    uint16_t* outValue = GetSchemaValue<uint16_t*>(m_ptr, "OldFeEdge_t", "m_nNode"); for(int i = 0; i < 4; i++) { outValue[i] = value[i]; } SetSchemaValue(m_ptr, "OldFeEdge_t", "m_nNode", true, outValue);
}
std::string GOldFeEdge_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GOldFeEdge_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassOldFeEdge_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GOldFeEdge_t>("OldFeEdge_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("K", &GOldFeEdge_t::GetK, &GOldFeEdge_t::SetK)
        .addProperty("InvA", &GOldFeEdge_t::GetInvA, &GOldFeEdge_t::SetInvA)
        .addProperty("T", &GOldFeEdge_t::GetT, &GOldFeEdge_t::SetT)
        .addProperty("ThetaRelaxed", &GOldFeEdge_t::GetThetaRelaxed, &GOldFeEdge_t::SetThetaRelaxed)
        .addProperty("ThetaFactor", &GOldFeEdge_t::GetThetaFactor, &GOldFeEdge_t::SetThetaFactor)
        .addProperty("C01", &GOldFeEdge_t::GetC01, &GOldFeEdge_t::SetC01)
        .addProperty("C02", &GOldFeEdge_t::GetC02, &GOldFeEdge_t::SetC02)
        .addProperty("C03", &GOldFeEdge_t::GetC03, &GOldFeEdge_t::SetC03)
        .addProperty("C04", &GOldFeEdge_t::GetC04, &GOldFeEdge_t::SetC04)
        .addProperty("AxialModelDist", &GOldFeEdge_t::GetAxialModelDist, &GOldFeEdge_t::SetAxialModelDist)
        .addProperty("AxialModelWeights", &GOldFeEdge_t::GetAxialModelWeights, &GOldFeEdge_t::SetAxialModelWeights)
        .addProperty("Node", &GOldFeEdge_t::GetNode, &GOldFeEdge_t::SetNode)
        .addFunction("ToPtr", &GOldFeEdge_t::ToPtr)
        .addFunction("IsValid", &GOldFeEdge_t::IsValid)
        .endClass();
}
GCStanceOverrideUpdateNode::GCStanceOverrideUpdateNode(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCStanceOverrideUpdateNode::GCStanceOverrideUpdateNode(void *ptr) {
    m_ptr = ptr;
}
std::vector<GStanceInfo_t> GCStanceOverrideUpdateNode::GetFootStanceInfo() const {
    CUtlVector<GStanceInfo_t>* vec = GetSchemaValue<CUtlVector<GStanceInfo_t>*>(m_ptr, "CStanceOverrideUpdateNode", "m_footStanceInfo"); std::vector<GStanceInfo_t> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCStanceOverrideUpdateNode::SetFootStanceInfo(std::vector<GStanceInfo_t> value) {
    SetSchemaValueCUtlVector<GStanceInfo_t>(m_ptr, "CStanceOverrideUpdateNode", "m_footStanceInfo", false, value);
}
GCAnimUpdateNodeRef GCStanceOverrideUpdateNode::GetStanceSourceNode() const {
    GCAnimUpdateNodeRef value(GetSchemaPtr(m_ptr, "CStanceOverrideUpdateNode", "m_pStanceSourceNode"));
    return value;
}
void GCStanceOverrideUpdateNode::SetStanceSourceNode(GCAnimUpdateNodeRef value) {
    SetSchemaValue(m_ptr, "CStanceOverrideUpdateNode", "m_pStanceSourceNode", false, value);
}
GCAnimParamHandle GCStanceOverrideUpdateNode::GetParameter() const {
    GCAnimParamHandle value(GetSchemaPtr(m_ptr, "CStanceOverrideUpdateNode", "m_hParameter"));
    return value;
}
void GCStanceOverrideUpdateNode::SetParameter(GCAnimParamHandle value) {
    SetSchemaValue(m_ptr, "CStanceOverrideUpdateNode", "m_hParameter", false, value);
}
uint64_t GCStanceOverrideUpdateNode::GetMode() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CStanceOverrideUpdateNode", "m_eMode");
}
void GCStanceOverrideUpdateNode::SetMode(uint64_t value) {
    SetSchemaValue(m_ptr, "CStanceOverrideUpdateNode", "m_eMode", false, value);
}
std::string GCStanceOverrideUpdateNode::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCStanceOverrideUpdateNode::IsValid() {
    return (m_ptr != nullptr);
}
GCUnaryUpdateNode GCStanceOverrideUpdateNode::GetParent() const {
    GCUnaryUpdateNode value(m_ptr);
    return value;
}
void GCStanceOverrideUpdateNode::SetParent(GCUnaryUpdateNode value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCStanceOverrideUpdateNode(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCStanceOverrideUpdateNode>("CStanceOverrideUpdateNode")
        .addConstructor<void (*)(std::string)>()
        .addProperty("FootStanceInfo", &GCStanceOverrideUpdateNode::GetFootStanceInfo, &GCStanceOverrideUpdateNode::SetFootStanceInfo)
        .addProperty("StanceSourceNode", &GCStanceOverrideUpdateNode::GetStanceSourceNode, &GCStanceOverrideUpdateNode::SetStanceSourceNode)
        .addProperty("Parameter", &GCStanceOverrideUpdateNode::GetParameter, &GCStanceOverrideUpdateNode::SetParameter)
        .addProperty("Mode", &GCStanceOverrideUpdateNode::GetMode, &GCStanceOverrideUpdateNode::SetMode)
        .addProperty("Parent", &GCStanceOverrideUpdateNode::GetParent, &GCStanceOverrideUpdateNode::SetParent)
        .addFunction("ToPtr", &GCStanceOverrideUpdateNode::ToPtr)
        .addFunction("IsValid", &GCStanceOverrideUpdateNode::IsValid)
        .endClass();
}
Gconstraint_breakableparams_t::Gconstraint_breakableparams_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
Gconstraint_breakableparams_t::Gconstraint_breakableparams_t(void *ptr) {
    m_ptr = ptr;
}
float Gconstraint_breakableparams_t::GetStrength() const {
    return GetSchemaValue<float>(m_ptr, "constraint_breakableparams_t", "strength");
}
void Gconstraint_breakableparams_t::SetStrength(float value) {
    SetSchemaValue(m_ptr, "constraint_breakableparams_t", "strength", true, value);
}
float Gconstraint_breakableparams_t::GetForceLimit() const {
    return GetSchemaValue<float>(m_ptr, "constraint_breakableparams_t", "forceLimit");
}
void Gconstraint_breakableparams_t::SetForceLimit(float value) {
    SetSchemaValue(m_ptr, "constraint_breakableparams_t", "forceLimit", true, value);
}
float Gconstraint_breakableparams_t::GetTorqueLimit() const {
    return GetSchemaValue<float>(m_ptr, "constraint_breakableparams_t", "torqueLimit");
}
void Gconstraint_breakableparams_t::SetTorqueLimit(float value) {
    SetSchemaValue(m_ptr, "constraint_breakableparams_t", "torqueLimit", true, value);
}
std::vector<float> Gconstraint_breakableparams_t::GetBodyMassScale() const {
    float* outValue = GetSchemaValue<float*>(m_ptr, "constraint_breakableparams_t", "bodyMassScale"); std::vector<float> ret; for(int i = 0; i < 2; i++) { ret.push_back(outValue[i]); } return ret;
}
void Gconstraint_breakableparams_t::SetBodyMassScale(std::vector<float> value) {
    float* outValue = GetSchemaValue<float*>(m_ptr, "constraint_breakableparams_t", "bodyMassScale"); for(int i = 0; i < 2; i++) { outValue[i] = value[i]; } SetSchemaValue(m_ptr, "constraint_breakableparams_t", "bodyMassScale", true, outValue);
}
bool Gconstraint_breakableparams_t::GetIsActive() const {
    return GetSchemaValue<bool>(m_ptr, "constraint_breakableparams_t", "isActive");
}
void Gconstraint_breakableparams_t::SetIsActive(bool value) {
    SetSchemaValue(m_ptr, "constraint_breakableparams_t", "isActive", true, value);
}
std::string Gconstraint_breakableparams_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool Gconstraint_breakableparams_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassconstraint_breakableparams_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<Gconstraint_breakableparams_t>("constraint_breakableparams_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Strength", &Gconstraint_breakableparams_t::GetStrength, &Gconstraint_breakableparams_t::SetStrength)
        .addProperty("ForceLimit", &Gconstraint_breakableparams_t::GetForceLimit, &Gconstraint_breakableparams_t::SetForceLimit)
        .addProperty("TorqueLimit", &Gconstraint_breakableparams_t::GetTorqueLimit, &Gconstraint_breakableparams_t::SetTorqueLimit)
        .addProperty("BodyMassScale", &Gconstraint_breakableparams_t::GetBodyMassScale, &Gconstraint_breakableparams_t::SetBodyMassScale)
        .addProperty("IsActive", &Gconstraint_breakableparams_t::GetIsActive, &Gconstraint_breakableparams_t::SetIsActive)
        .addFunction("ToPtr", &Gconstraint_breakableparams_t::ToPtr)
        .addFunction("IsValid", &Gconstraint_breakableparams_t::IsValid)
        .endClass();
}
GCStateNodeTransitionData::GCStateNodeTransitionData(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCStateNodeTransitionData::GCStateNodeTransitionData(void *ptr) {
    m_ptr = ptr;
}
GCBlendCurve GCStateNodeTransitionData::GetCurve() const {
    GCBlendCurve value(GetSchemaPtr(m_ptr, "CStateNodeTransitionData", "m_curve"));
    return value;
}
void GCStateNodeTransitionData::SetCurve(GCBlendCurve value) {
    SetSchemaValue(m_ptr, "CStateNodeTransitionData", "m_curve", false, value);
}
std::string GCStateNodeTransitionData::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCStateNodeTransitionData::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCStateNodeTransitionData(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCStateNodeTransitionData>("CStateNodeTransitionData")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Curve", &GCStateNodeTransitionData::GetCurve, &GCStateNodeTransitionData::SetCurve)
        .addFunction("ToPtr", &GCStateNodeTransitionData::ToPtr)
        .addFunction("IsValid", &GCStateNodeTransitionData::IsValid)
        .endClass();
}
GCMotionMatchingUpdateNode::GCMotionMatchingUpdateNode(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCMotionMatchingUpdateNode::GCMotionMatchingUpdateNode(void *ptr) {
    m_ptr = ptr;
}
GCMotionDataSet GCMotionMatchingUpdateNode::GetDataSet() const {
    GCMotionDataSet value(GetSchemaPtr(m_ptr, "CMotionMatchingUpdateNode", "m_dataSet"));
    return value;
}
void GCMotionMatchingUpdateNode::SetDataSet(GCMotionDataSet value) {
    SetSchemaValue(m_ptr, "CMotionMatchingUpdateNode", "m_dataSet", false, value);
}
std::vector<float32> GCMotionMatchingUpdateNode::GetWeights() const {
    CUtlVector<float32>* vec = GetSchemaValue<CUtlVector<float32>*>(m_ptr, "CMotionMatchingUpdateNode", "m_weights"); std::vector<float32> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCMotionMatchingUpdateNode::SetWeights(std::vector<float32> value) {
    SetSchemaValueCUtlVector<float32>(m_ptr, "CMotionMatchingUpdateNode", "m_weights", false, value);
}
bool GCMotionMatchingUpdateNode::GetSearchEveryTick() const {
    return GetSchemaValue<bool>(m_ptr, "CMotionMatchingUpdateNode", "m_bSearchEveryTick");
}
void GCMotionMatchingUpdateNode::SetSearchEveryTick(bool value) {
    SetSchemaValue(m_ptr, "CMotionMatchingUpdateNode", "m_bSearchEveryTick", false, value);
}
float GCMotionMatchingUpdateNode::GetSearchInterval() const {
    return GetSchemaValue<float>(m_ptr, "CMotionMatchingUpdateNode", "m_flSearchInterval");
}
void GCMotionMatchingUpdateNode::SetSearchInterval(float value) {
    SetSchemaValue(m_ptr, "CMotionMatchingUpdateNode", "m_flSearchInterval", false, value);
}
bool GCMotionMatchingUpdateNode::GetSearchWhenClipEnds() const {
    return GetSchemaValue<bool>(m_ptr, "CMotionMatchingUpdateNode", "m_bSearchWhenClipEnds");
}
void GCMotionMatchingUpdateNode::SetSearchWhenClipEnds(bool value) {
    SetSchemaValue(m_ptr, "CMotionMatchingUpdateNode", "m_bSearchWhenClipEnds", false, value);
}
bool GCMotionMatchingUpdateNode::GetSearchWhenGoalChanges() const {
    return GetSchemaValue<bool>(m_ptr, "CMotionMatchingUpdateNode", "m_bSearchWhenGoalChanges");
}
void GCMotionMatchingUpdateNode::SetSearchWhenGoalChanges(bool value) {
    SetSchemaValue(m_ptr, "CMotionMatchingUpdateNode", "m_bSearchWhenGoalChanges", false, value);
}
GCBlendCurve GCMotionMatchingUpdateNode::GetBlendCurve() const {
    GCBlendCurve value(GetSchemaPtr(m_ptr, "CMotionMatchingUpdateNode", "m_blendCurve"));
    return value;
}
void GCMotionMatchingUpdateNode::SetBlendCurve(GCBlendCurve value) {
    SetSchemaValue(m_ptr, "CMotionMatchingUpdateNode", "m_blendCurve", false, value);
}
float GCMotionMatchingUpdateNode::GetSampleRate() const {
    return GetSchemaValue<float>(m_ptr, "CMotionMatchingUpdateNode", "m_flSampleRate");
}
void GCMotionMatchingUpdateNode::SetSampleRate(float value) {
    SetSchemaValue(m_ptr, "CMotionMatchingUpdateNode", "m_flSampleRate", false, value);
}
float GCMotionMatchingUpdateNode::GetBlendTime() const {
    return GetSchemaValue<float>(m_ptr, "CMotionMatchingUpdateNode", "m_flBlendTime");
}
void GCMotionMatchingUpdateNode::SetBlendTime(float value) {
    SetSchemaValue(m_ptr, "CMotionMatchingUpdateNode", "m_flBlendTime", false, value);
}
bool GCMotionMatchingUpdateNode::GetLockClipWhenWaning() const {
    return GetSchemaValue<bool>(m_ptr, "CMotionMatchingUpdateNode", "m_bLockClipWhenWaning");
}
void GCMotionMatchingUpdateNode::SetLockClipWhenWaning(bool value) {
    SetSchemaValue(m_ptr, "CMotionMatchingUpdateNode", "m_bLockClipWhenWaning", false, value);
}
float GCMotionMatchingUpdateNode::GetSelectionThreshold() const {
    return GetSchemaValue<float>(m_ptr, "CMotionMatchingUpdateNode", "m_flSelectionThreshold");
}
void GCMotionMatchingUpdateNode::SetSelectionThreshold(float value) {
    SetSchemaValue(m_ptr, "CMotionMatchingUpdateNode", "m_flSelectionThreshold", false, value);
}
float GCMotionMatchingUpdateNode::GetReselectionTimeWindow() const {
    return GetSchemaValue<float>(m_ptr, "CMotionMatchingUpdateNode", "m_flReselectionTimeWindow");
}
void GCMotionMatchingUpdateNode::SetReselectionTimeWindow(float value) {
    SetSchemaValue(m_ptr, "CMotionMatchingUpdateNode", "m_flReselectionTimeWindow", false, value);
}
bool GCMotionMatchingUpdateNode::GetEnableRotationCorrection() const {
    return GetSchemaValue<bool>(m_ptr, "CMotionMatchingUpdateNode", "m_bEnableRotationCorrection");
}
void GCMotionMatchingUpdateNode::SetEnableRotationCorrection(bool value) {
    SetSchemaValue(m_ptr, "CMotionMatchingUpdateNode", "m_bEnableRotationCorrection", false, value);
}
bool GCMotionMatchingUpdateNode::GetGoalAssist() const {
    return GetSchemaValue<bool>(m_ptr, "CMotionMatchingUpdateNode", "m_bGoalAssist");
}
void GCMotionMatchingUpdateNode::SetGoalAssist(bool value) {
    SetSchemaValue(m_ptr, "CMotionMatchingUpdateNode", "m_bGoalAssist", false, value);
}
float GCMotionMatchingUpdateNode::GetGoalAssistDistance() const {
    return GetSchemaValue<float>(m_ptr, "CMotionMatchingUpdateNode", "m_flGoalAssistDistance");
}
void GCMotionMatchingUpdateNode::SetGoalAssistDistance(float value) {
    SetSchemaValue(m_ptr, "CMotionMatchingUpdateNode", "m_flGoalAssistDistance", false, value);
}
float GCMotionMatchingUpdateNode::GetGoalAssistTolerance() const {
    return GetSchemaValue<float>(m_ptr, "CMotionMatchingUpdateNode", "m_flGoalAssistTolerance");
}
void GCMotionMatchingUpdateNode::SetGoalAssistTolerance(float value) {
    SetSchemaValue(m_ptr, "CMotionMatchingUpdateNode", "m_flGoalAssistTolerance", false, value);
}
GCAnimInputDamping GCMotionMatchingUpdateNode::GetDistanceScale_Damping() const {
    GCAnimInputDamping value(GetSchemaPtr(m_ptr, "CMotionMatchingUpdateNode", "m_distanceScale_Damping"));
    return value;
}
void GCMotionMatchingUpdateNode::SetDistanceScale_Damping(GCAnimInputDamping value) {
    SetSchemaValue(m_ptr, "CMotionMatchingUpdateNode", "m_distanceScale_Damping", false, value);
}
float GCMotionMatchingUpdateNode::GetDistanceScale_OuterRadius() const {
    return GetSchemaValue<float>(m_ptr, "CMotionMatchingUpdateNode", "m_flDistanceScale_OuterRadius");
}
void GCMotionMatchingUpdateNode::SetDistanceScale_OuterRadius(float value) {
    SetSchemaValue(m_ptr, "CMotionMatchingUpdateNode", "m_flDistanceScale_OuterRadius", false, value);
}
float GCMotionMatchingUpdateNode::GetDistanceScale_InnerRadius() const {
    return GetSchemaValue<float>(m_ptr, "CMotionMatchingUpdateNode", "m_flDistanceScale_InnerRadius");
}
void GCMotionMatchingUpdateNode::SetDistanceScale_InnerRadius(float value) {
    SetSchemaValue(m_ptr, "CMotionMatchingUpdateNode", "m_flDistanceScale_InnerRadius", false, value);
}
float GCMotionMatchingUpdateNode::GetDistanceScale_MaxScale() const {
    return GetSchemaValue<float>(m_ptr, "CMotionMatchingUpdateNode", "m_flDistanceScale_MaxScale");
}
void GCMotionMatchingUpdateNode::SetDistanceScale_MaxScale(float value) {
    SetSchemaValue(m_ptr, "CMotionMatchingUpdateNode", "m_flDistanceScale_MaxScale", false, value);
}
float GCMotionMatchingUpdateNode::GetDistanceScale_MinScale() const {
    return GetSchemaValue<float>(m_ptr, "CMotionMatchingUpdateNode", "m_flDistanceScale_MinScale");
}
void GCMotionMatchingUpdateNode::SetDistanceScale_MinScale(float value) {
    SetSchemaValue(m_ptr, "CMotionMatchingUpdateNode", "m_flDistanceScale_MinScale", false, value);
}
bool GCMotionMatchingUpdateNode::GetEnableDistanceScaling() const {
    return GetSchemaValue<bool>(m_ptr, "CMotionMatchingUpdateNode", "m_bEnableDistanceScaling");
}
void GCMotionMatchingUpdateNode::SetEnableDistanceScaling(bool value) {
    SetSchemaValue(m_ptr, "CMotionMatchingUpdateNode", "m_bEnableDistanceScaling", false, value);
}
std::string GCMotionMatchingUpdateNode::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCMotionMatchingUpdateNode::IsValid() {
    return (m_ptr != nullptr);
}
GCLeafUpdateNode GCMotionMatchingUpdateNode::GetParent() const {
    GCLeafUpdateNode value(m_ptr);
    return value;
}
void GCMotionMatchingUpdateNode::SetParent(GCLeafUpdateNode value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCMotionMatchingUpdateNode(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCMotionMatchingUpdateNode>("CMotionMatchingUpdateNode")
        .addConstructor<void (*)(std::string)>()
        .addProperty("DataSet", &GCMotionMatchingUpdateNode::GetDataSet, &GCMotionMatchingUpdateNode::SetDataSet)
        .addProperty("Weights", &GCMotionMatchingUpdateNode::GetWeights, &GCMotionMatchingUpdateNode::SetWeights)
        .addProperty("SearchEveryTick", &GCMotionMatchingUpdateNode::GetSearchEveryTick, &GCMotionMatchingUpdateNode::SetSearchEveryTick)
        .addProperty("SearchInterval", &GCMotionMatchingUpdateNode::GetSearchInterval, &GCMotionMatchingUpdateNode::SetSearchInterval)
        .addProperty("SearchWhenClipEnds", &GCMotionMatchingUpdateNode::GetSearchWhenClipEnds, &GCMotionMatchingUpdateNode::SetSearchWhenClipEnds)
        .addProperty("SearchWhenGoalChanges", &GCMotionMatchingUpdateNode::GetSearchWhenGoalChanges, &GCMotionMatchingUpdateNode::SetSearchWhenGoalChanges)
        .addProperty("BlendCurve", &GCMotionMatchingUpdateNode::GetBlendCurve, &GCMotionMatchingUpdateNode::SetBlendCurve)
        .addProperty("SampleRate", &GCMotionMatchingUpdateNode::GetSampleRate, &GCMotionMatchingUpdateNode::SetSampleRate)
        .addProperty("BlendTime", &GCMotionMatchingUpdateNode::GetBlendTime, &GCMotionMatchingUpdateNode::SetBlendTime)
        .addProperty("LockClipWhenWaning", &GCMotionMatchingUpdateNode::GetLockClipWhenWaning, &GCMotionMatchingUpdateNode::SetLockClipWhenWaning)
        .addProperty("SelectionThreshold", &GCMotionMatchingUpdateNode::GetSelectionThreshold, &GCMotionMatchingUpdateNode::SetSelectionThreshold)
        .addProperty("ReselectionTimeWindow", &GCMotionMatchingUpdateNode::GetReselectionTimeWindow, &GCMotionMatchingUpdateNode::SetReselectionTimeWindow)
        .addProperty("EnableRotationCorrection", &GCMotionMatchingUpdateNode::GetEnableRotationCorrection, &GCMotionMatchingUpdateNode::SetEnableRotationCorrection)
        .addProperty("GoalAssist", &GCMotionMatchingUpdateNode::GetGoalAssist, &GCMotionMatchingUpdateNode::SetGoalAssist)
        .addProperty("GoalAssistDistance", &GCMotionMatchingUpdateNode::GetGoalAssistDistance, &GCMotionMatchingUpdateNode::SetGoalAssistDistance)
        .addProperty("GoalAssistTolerance", &GCMotionMatchingUpdateNode::GetGoalAssistTolerance, &GCMotionMatchingUpdateNode::SetGoalAssistTolerance)
        .addProperty("DistanceScale_Damping", &GCMotionMatchingUpdateNode::GetDistanceScale_Damping, &GCMotionMatchingUpdateNode::SetDistanceScale_Damping)
        .addProperty("DistanceScale_OuterRadius", &GCMotionMatchingUpdateNode::GetDistanceScale_OuterRadius, &GCMotionMatchingUpdateNode::SetDistanceScale_OuterRadius)
        .addProperty("DistanceScale_InnerRadius", &GCMotionMatchingUpdateNode::GetDistanceScale_InnerRadius, &GCMotionMatchingUpdateNode::SetDistanceScale_InnerRadius)
        .addProperty("DistanceScale_MaxScale", &GCMotionMatchingUpdateNode::GetDistanceScale_MaxScale, &GCMotionMatchingUpdateNode::SetDistanceScale_MaxScale)
        .addProperty("DistanceScale_MinScale", &GCMotionMatchingUpdateNode::GetDistanceScale_MinScale, &GCMotionMatchingUpdateNode::SetDistanceScale_MinScale)
        .addProperty("EnableDistanceScaling", &GCMotionMatchingUpdateNode::GetEnableDistanceScaling, &GCMotionMatchingUpdateNode::SetEnableDistanceScaling)
        .addProperty("Parent", &GCMotionMatchingUpdateNode::GetParent, &GCMotionMatchingUpdateNode::SetParent)
        .addFunction("ToPtr", &GCMotionMatchingUpdateNode::ToPtr)
        .addFunction("IsValid", &GCMotionMatchingUpdateNode::IsValid)
        .endClass();
}
GCNmSyncTrack__Event_t::GCNmSyncTrack__Event_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCNmSyncTrack__Event_t::GCNmSyncTrack__Event_t(void *ptr) {
    m_ptr = ptr;
}
GNmPercent_t GCNmSyncTrack__Event_t::GetStartTime() const {
    GNmPercent_t value(GetSchemaPtr(m_ptr, "CNmSyncTrack__Event_t", "m_startTime"));
    return value;
}
void GCNmSyncTrack__Event_t::SetStartTime(GNmPercent_t value) {
    SetSchemaValue(m_ptr, "CNmSyncTrack__Event_t", "m_startTime", true, value);
}
GNmPercent_t GCNmSyncTrack__Event_t::GetDuration() const {
    GNmPercent_t value(GetSchemaPtr(m_ptr, "CNmSyncTrack__Event_t", "m_duration"));
    return value;
}
void GCNmSyncTrack__Event_t::SetDuration(GNmPercent_t value) {
    SetSchemaValue(m_ptr, "CNmSyncTrack__Event_t", "m_duration", true, value);
}
std::string GCNmSyncTrack__Event_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCNmSyncTrack__Event_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCNmSyncTrack__Event_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCNmSyncTrack__Event_t>("CNmSyncTrack__Event_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("StartTime", &GCNmSyncTrack__Event_t::GetStartTime, &GCNmSyncTrack__Event_t::SetStartTime)
        .addProperty("Duration", &GCNmSyncTrack__Event_t::GetDuration, &GCNmSyncTrack__Event_t::SetDuration)
        .addFunction("ToPtr", &GCNmSyncTrack__Event_t::ToPtr)
        .addFunction("IsValid", &GCNmSyncTrack__Event_t::IsValid)
        .endClass();
}
GEventSplitScreenStateChanged_t::GEventSplitScreenStateChanged_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GEventSplitScreenStateChanged_t::GEventSplitScreenStateChanged_t(void *ptr) {
    m_ptr = ptr;
}
std::string GEventSplitScreenStateChanged_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GEventSplitScreenStateChanged_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassEventSplitScreenStateChanged_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GEventSplitScreenStateChanged_t>("EventSplitScreenStateChanged_t")
        .addConstructor<void (*)(std::string)>()
        .addFunction("ToPtr", &GEventSplitScreenStateChanged_t::ToPtr)
        .addFunction("IsValid", &GEventSplitScreenStateChanged_t::IsValid)
        .endClass();
}
GParticleNamedValueSource_t::GParticleNamedValueSource_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GParticleNamedValueSource_t::GParticleNamedValueSource_t(void *ptr) {
    m_ptr = ptr;
}
std::string GParticleNamedValueSource_t::GetName() const {
    return GetSchemaValue<CUtlString>(m_ptr, "ParticleNamedValueSource_t", "m_Name").Get();
}
void GParticleNamedValueSource_t::SetName(std::string value) {
    SetSchemaValue(m_ptr, "ParticleNamedValueSource_t", "m_Name", true, CUtlString(value.c_str()));
}
bool GParticleNamedValueSource_t::GetIsPublic() const {
    return GetSchemaValue<bool>(m_ptr, "ParticleNamedValueSource_t", "m_IsPublic");
}
void GParticleNamedValueSource_t::SetIsPublic(bool value) {
    SetSchemaValue(m_ptr, "ParticleNamedValueSource_t", "m_IsPublic", true, value);
}
uint64_t GParticleNamedValueSource_t::GetValueType() const {
    return GetSchemaValue<uint64_t>(m_ptr, "ParticleNamedValueSource_t", "m_ValueType");
}
void GParticleNamedValueSource_t::SetValueType(uint64_t value) {
    SetSchemaValue(m_ptr, "ParticleNamedValueSource_t", "m_ValueType", true, value);
}
GParticleNamedValueConfiguration_t GParticleNamedValueSource_t::GetDefaultConfig() const {
    GParticleNamedValueConfiguration_t value(GetSchemaPtr(m_ptr, "ParticleNamedValueSource_t", "m_DefaultConfig"));
    return value;
}
void GParticleNamedValueSource_t::SetDefaultConfig(GParticleNamedValueConfiguration_t value) {
    SetSchemaValue(m_ptr, "ParticleNamedValueSource_t", "m_DefaultConfig", true, value);
}
std::vector<GParticleNamedValueConfiguration_t> GParticleNamedValueSource_t::GetNamedConfigs() const {
    CUtlVector<GParticleNamedValueConfiguration_t>* vec = GetSchemaValue<CUtlVector<GParticleNamedValueConfiguration_t>*>(m_ptr, "ParticleNamedValueSource_t", "m_NamedConfigs"); std::vector<GParticleNamedValueConfiguration_t> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GParticleNamedValueSource_t::SetNamedConfigs(std::vector<GParticleNamedValueConfiguration_t> value) {
    SetSchemaValueCUtlVector<GParticleNamedValueConfiguration_t>(m_ptr, "ParticleNamedValueSource_t", "m_NamedConfigs", true, value);
}
std::string GParticleNamedValueSource_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GParticleNamedValueSource_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassParticleNamedValueSource_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GParticleNamedValueSource_t>("ParticleNamedValueSource_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Name", &GParticleNamedValueSource_t::GetName, &GParticleNamedValueSource_t::SetName)
        .addProperty("IsPublic", &GParticleNamedValueSource_t::GetIsPublic, &GParticleNamedValueSource_t::SetIsPublic)
        .addProperty("ValueType", &GParticleNamedValueSource_t::GetValueType, &GParticleNamedValueSource_t::SetValueType)
        .addProperty("DefaultConfig", &GParticleNamedValueSource_t::GetDefaultConfig, &GParticleNamedValueSource_t::SetDefaultConfig)
        .addProperty("NamedConfigs", &GParticleNamedValueSource_t::GetNamedConfigs, &GParticleNamedValueSource_t::SetNamedConfigs)
        .addFunction("ToPtr", &GParticleNamedValueSource_t::ToPtr)
        .addFunction("IsValid", &GParticleNamedValueSource_t::IsValid)
        .endClass();
}
GMaterialParamBuffer_t::GMaterialParamBuffer_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GMaterialParamBuffer_t::GMaterialParamBuffer_t(void *ptr) {
    m_ptr = ptr;
}
std::string GMaterialParamBuffer_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GMaterialParamBuffer_t::IsValid() {
    return (m_ptr != nullptr);
}
GMaterialParam_t GMaterialParamBuffer_t::GetParent() const {
    GMaterialParam_t value(m_ptr);
    return value;
}
void GMaterialParamBuffer_t::SetParent(GMaterialParam_t value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassMaterialParamBuffer_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GMaterialParamBuffer_t>("MaterialParamBuffer_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GMaterialParamBuffer_t::GetParent, &GMaterialParamBuffer_t::SetParent)
        .addFunction("ToPtr", &GMaterialParamBuffer_t::ToPtr)
        .addFunction("IsValid", &GMaterialParamBuffer_t::IsValid)
        .endClass();
}
GEventPostDataUpdate_t::GEventPostDataUpdate_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GEventPostDataUpdate_t::GEventPostDataUpdate_t(void *ptr) {
    m_ptr = ptr;
}
int32_t GEventPostDataUpdate_t::GetCount() const {
    return GetSchemaValue<int32_t>(m_ptr, "EventPostDataUpdate_t", "m_nCount");
}
void GEventPostDataUpdate_t::SetCount(int32_t value) {
    SetSchemaValue(m_ptr, "EventPostDataUpdate_t", "m_nCount", true, value);
}
std::string GEventPostDataUpdate_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GEventPostDataUpdate_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassEventPostDataUpdate_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GEventPostDataUpdate_t>("EventPostDataUpdate_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Count", &GEventPostDataUpdate_t::GetCount, &GEventPostDataUpdate_t::SetCount)
        .addFunction("ToPtr", &GEventPostDataUpdate_t::ToPtr)
        .addFunction("IsValid", &GEventPostDataUpdate_t::IsValid)
        .endClass();
}
GRenderProjectedMaterial_t::GRenderProjectedMaterial_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GRenderProjectedMaterial_t::GRenderProjectedMaterial_t(void *ptr) {
    m_ptr = ptr;
}
std::string GRenderProjectedMaterial_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GRenderProjectedMaterial_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassRenderProjectedMaterial_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GRenderProjectedMaterial_t>("RenderProjectedMaterial_t")
        .addConstructor<void (*)(std::string)>()
        .addFunction("ToPtr", &GRenderProjectedMaterial_t::ToPtr)
        .addFunction("IsValid", &GRenderProjectedMaterial_t::IsValid)
        .endClass();
}
GCSSDSMsg_ViewTargetList::GCSSDSMsg_ViewTargetList(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCSSDSMsg_ViewTargetList::GCSSDSMsg_ViewTargetList(void *ptr) {
    m_ptr = ptr;
}
GSceneViewId_t GCSSDSMsg_ViewTargetList::GetViewId() const {
    GSceneViewId_t value(GetSchemaPtr(m_ptr, "CSSDSMsg_ViewTargetList", "m_viewId"));
    return value;
}
void GCSSDSMsg_ViewTargetList::SetViewId(GSceneViewId_t value) {
    SetSchemaValue(m_ptr, "CSSDSMsg_ViewTargetList", "m_viewId", false, value);
}
std::string GCSSDSMsg_ViewTargetList::GetViewName() const {
    return GetSchemaValue<CUtlString>(m_ptr, "CSSDSMsg_ViewTargetList", "m_ViewName").Get();
}
void GCSSDSMsg_ViewTargetList::SetViewName(std::string value) {
    SetSchemaValue(m_ptr, "CSSDSMsg_ViewTargetList", "m_ViewName", false, CUtlString(value.c_str()));
}
std::vector<GCSSDSMsg_ViewTarget> GCSSDSMsg_ViewTargetList::GetTargets() const {
    CUtlVector<GCSSDSMsg_ViewTarget>* vec = GetSchemaValue<CUtlVector<GCSSDSMsg_ViewTarget>*>(m_ptr, "CSSDSMsg_ViewTargetList", "m_Targets"); std::vector<GCSSDSMsg_ViewTarget> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCSSDSMsg_ViewTargetList::SetTargets(std::vector<GCSSDSMsg_ViewTarget> value) {
    SetSchemaValueCUtlVector<GCSSDSMsg_ViewTarget>(m_ptr, "CSSDSMsg_ViewTargetList", "m_Targets", false, value);
}
std::string GCSSDSMsg_ViewTargetList::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCSSDSMsg_ViewTargetList::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCSSDSMsg_ViewTargetList(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCSSDSMsg_ViewTargetList>("CSSDSMsg_ViewTargetList")
        .addConstructor<void (*)(std::string)>()
        .addProperty("ViewId", &GCSSDSMsg_ViewTargetList::GetViewId, &GCSSDSMsg_ViewTargetList::SetViewId)
        .addProperty("ViewName", &GCSSDSMsg_ViewTargetList::GetViewName, &GCSSDSMsg_ViewTargetList::SetViewName)
        .addProperty("Targets", &GCSSDSMsg_ViewTargetList::GetTargets, &GCSSDSMsg_ViewTargetList::SetTargets)
        .addFunction("ToPtr", &GCSSDSMsg_ViewTargetList::ToPtr)
        .addFunction("IsValid", &GCSSDSMsg_ViewTargetList::IsValid)
        .endClass();
}
GFeSimdAnimStrayRadius_t::GFeSimdAnimStrayRadius_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GFeSimdAnimStrayRadius_t::GFeSimdAnimStrayRadius_t(void *ptr) {
    m_ptr = ptr;
}
float GFeSimdAnimStrayRadius_t::GetMaxDist() const {
    return GetSchemaValue<float>(m_ptr, "FeSimdAnimStrayRadius_t", "flMaxDist");
}
void GFeSimdAnimStrayRadius_t::SetMaxDist(float value) {
    SetSchemaValue(m_ptr, "FeSimdAnimStrayRadius_t", "flMaxDist", true, value);
}
float GFeSimdAnimStrayRadius_t::GetRelaxationFactor() const {
    return GetSchemaValue<float>(m_ptr, "FeSimdAnimStrayRadius_t", "flRelaxationFactor");
}
void GFeSimdAnimStrayRadius_t::SetRelaxationFactor(float value) {
    SetSchemaValue(m_ptr, "FeSimdAnimStrayRadius_t", "flRelaxationFactor", true, value);
}
std::string GFeSimdAnimStrayRadius_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GFeSimdAnimStrayRadius_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassFeSimdAnimStrayRadius_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GFeSimdAnimStrayRadius_t>("FeSimdAnimStrayRadius_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("MaxDist", &GFeSimdAnimStrayRadius_t::GetMaxDist, &GFeSimdAnimStrayRadius_t::SetMaxDist)
        .addProperty("RelaxationFactor", &GFeSimdAnimStrayRadius_t::GetRelaxationFactor, &GFeSimdAnimStrayRadius_t::SetRelaxationFactor)
        .addFunction("ToPtr", &GFeSimdAnimStrayRadius_t::ToPtr)
        .addFunction("IsValid", &GFeSimdAnimStrayRadius_t::IsValid)
        .endClass();
}
GCAnimUser::GCAnimUser(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCAnimUser::GCAnimUser(void *ptr) {
    m_ptr = ptr;
}
CBufferString GCAnimUser::GetName() const {
    return GetSchemaValue<CBufferString>(m_ptr, "CAnimUser", "m_name");
}
void GCAnimUser::SetName(CBufferString value) {
    SetSchemaValue(m_ptr, "CAnimUser", "m_name", false, value);
}
int32_t GCAnimUser::GetType() const {
    return GetSchemaValue<int32_t>(m_ptr, "CAnimUser", "m_nType");
}
void GCAnimUser::SetType(int32_t value) {
    SetSchemaValue(m_ptr, "CAnimUser", "m_nType", false, value);
}
std::string GCAnimUser::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCAnimUser::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCAnimUser(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCAnimUser>("CAnimUser")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Name", &GCAnimUser::GetName, &GCAnimUser::SetName)
        .addProperty("Type", &GCAnimUser::GetType, &GCAnimUser::SetType)
        .addFunction("ToPtr", &GCAnimUser::ToPtr)
        .addFunction("IsValid", &GCAnimUser::IsValid)
        .endClass();
}
GFeSpringIntegrator_t::GFeSpringIntegrator_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GFeSpringIntegrator_t::GFeSpringIntegrator_t(void *ptr) {
    m_ptr = ptr;
}
std::vector<uint16_t> GFeSpringIntegrator_t::GetNode() const {
    uint16_t* outValue = GetSchemaValue<uint16_t*>(m_ptr, "FeSpringIntegrator_t", "nNode"); std::vector<uint16_t> ret; for(int i = 0; i < 2; i++) { ret.push_back(outValue[i]); } return ret;
}
void GFeSpringIntegrator_t::SetNode(std::vector<uint16_t> value) {
    uint16_t* outValue = GetSchemaValue<uint16_t*>(m_ptr, "FeSpringIntegrator_t", "nNode"); for(int i = 0; i < 2; i++) { outValue[i] = value[i]; } SetSchemaValue(m_ptr, "FeSpringIntegrator_t", "nNode", true, outValue);
}
float GFeSpringIntegrator_t::GetSpringRestLength() const {
    return GetSchemaValue<float>(m_ptr, "FeSpringIntegrator_t", "flSpringRestLength");
}
void GFeSpringIntegrator_t::SetSpringRestLength(float value) {
    SetSchemaValue(m_ptr, "FeSpringIntegrator_t", "flSpringRestLength", true, value);
}
float GFeSpringIntegrator_t::GetSpringConstant() const {
    return GetSchemaValue<float>(m_ptr, "FeSpringIntegrator_t", "flSpringConstant");
}
void GFeSpringIntegrator_t::SetSpringConstant(float value) {
    SetSchemaValue(m_ptr, "FeSpringIntegrator_t", "flSpringConstant", true, value);
}
float GFeSpringIntegrator_t::GetSpringDamping() const {
    return GetSchemaValue<float>(m_ptr, "FeSpringIntegrator_t", "flSpringDamping");
}
void GFeSpringIntegrator_t::SetSpringDamping(float value) {
    SetSchemaValue(m_ptr, "FeSpringIntegrator_t", "flSpringDamping", true, value);
}
float GFeSpringIntegrator_t::GetNodeWeight0() const {
    return GetSchemaValue<float>(m_ptr, "FeSpringIntegrator_t", "flNodeWeight0");
}
void GFeSpringIntegrator_t::SetNodeWeight0(float value) {
    SetSchemaValue(m_ptr, "FeSpringIntegrator_t", "flNodeWeight0", true, value);
}
std::string GFeSpringIntegrator_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GFeSpringIntegrator_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassFeSpringIntegrator_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GFeSpringIntegrator_t>("FeSpringIntegrator_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Node", &GFeSpringIntegrator_t::GetNode, &GFeSpringIntegrator_t::SetNode)
        .addProperty("SpringRestLength", &GFeSpringIntegrator_t::GetSpringRestLength, &GFeSpringIntegrator_t::SetSpringRestLength)
        .addProperty("SpringConstant", &GFeSpringIntegrator_t::GetSpringConstant, &GFeSpringIntegrator_t::SetSpringConstant)
        .addProperty("SpringDamping", &GFeSpringIntegrator_t::GetSpringDamping, &GFeSpringIntegrator_t::SetSpringDamping)
        .addProperty("NodeWeight0", &GFeSpringIntegrator_t::GetNodeWeight0, &GFeSpringIntegrator_t::SetNodeWeight0)
        .addFunction("ToPtr", &GFeSpringIntegrator_t::ToPtr)
        .addFunction("IsValid", &GFeSpringIntegrator_t::IsValid)
        .endClass();
}
GCModelConfigElement_UserPick::GCModelConfigElement_UserPick(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCModelConfigElement_UserPick::GCModelConfigElement_UserPick(void *ptr) {
    m_ptr = ptr;
}
std::vector<CUtlString> GCModelConfigElement_UserPick::GetChoices() const {
    CUtlVector<CUtlString>* vec = GetSchemaValue<CUtlVector<CUtlString>*>(m_ptr, "CModelConfigElement_UserPick", "m_Choices"); std::vector<CUtlString> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCModelConfigElement_UserPick::SetChoices(std::vector<CUtlString> value) {
    SetSchemaValueCUtlVector<CUtlString>(m_ptr, "CModelConfigElement_UserPick", "m_Choices", false, value);
}
std::string GCModelConfigElement_UserPick::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCModelConfigElement_UserPick::IsValid() {
    return (m_ptr != nullptr);
}
GCModelConfigElement GCModelConfigElement_UserPick::GetParent() const {
    GCModelConfigElement value(m_ptr);
    return value;
}
void GCModelConfigElement_UserPick::SetParent(GCModelConfigElement value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCModelConfigElement_UserPick(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCModelConfigElement_UserPick>("CModelConfigElement_UserPick")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Choices", &GCModelConfigElement_UserPick::GetChoices, &GCModelConfigElement_UserPick::SetChoices)
        .addProperty("Parent", &GCModelConfigElement_UserPick::GetParent, &GCModelConfigElement_UserPick::SetParent)
        .addFunction("ToPtr", &GCModelConfigElement_UserPick::ToPtr)
        .addFunction("IsValid", &GCModelConfigElement_UserPick::IsValid)
        .endClass();
}
GRenderSkeletonBone_t::GRenderSkeletonBone_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GRenderSkeletonBone_t::GRenderSkeletonBone_t(void *ptr) {
    m_ptr = ptr;
}
std::string GRenderSkeletonBone_t::GetBoneName() const {
    return GetSchemaValue<CUtlString>(m_ptr, "RenderSkeletonBone_t", "m_boneName").Get();
}
void GRenderSkeletonBone_t::SetBoneName(std::string value) {
    SetSchemaValue(m_ptr, "RenderSkeletonBone_t", "m_boneName", true, CUtlString(value.c_str()));
}
std::string GRenderSkeletonBone_t::GetParentName() const {
    return GetSchemaValue<CUtlString>(m_ptr, "RenderSkeletonBone_t", "m_parentName").Get();
}
void GRenderSkeletonBone_t::SetParentName(std::string value) {
    SetSchemaValue(m_ptr, "RenderSkeletonBone_t", "m_parentName", true, CUtlString(value.c_str()));
}
matrix3x4_t GRenderSkeletonBone_t::GetInvBindPose() const {
    return GetSchemaValue<matrix3x4_t>(m_ptr, "RenderSkeletonBone_t", "m_invBindPose");
}
void GRenderSkeletonBone_t::SetInvBindPose(matrix3x4_t value) {
    SetSchemaValue(m_ptr, "RenderSkeletonBone_t", "m_invBindPose", true, value);
}
GSkeletonBoneBounds_t GRenderSkeletonBone_t::GetBbox() const {
    GSkeletonBoneBounds_t value(GetSchemaPtr(m_ptr, "RenderSkeletonBone_t", "m_bbox"));
    return value;
}
void GRenderSkeletonBone_t::SetBbox(GSkeletonBoneBounds_t value) {
    SetSchemaValue(m_ptr, "RenderSkeletonBone_t", "m_bbox", true, value);
}
float GRenderSkeletonBone_t::GetSphereRadius() const {
    return GetSchemaValue<float>(m_ptr, "RenderSkeletonBone_t", "m_flSphereRadius");
}
void GRenderSkeletonBone_t::SetSphereRadius(float value) {
    SetSchemaValue(m_ptr, "RenderSkeletonBone_t", "m_flSphereRadius", true, value);
}
std::string GRenderSkeletonBone_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GRenderSkeletonBone_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassRenderSkeletonBone_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GRenderSkeletonBone_t>("RenderSkeletonBone_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("BoneName", &GRenderSkeletonBone_t::GetBoneName, &GRenderSkeletonBone_t::SetBoneName)
        .addProperty("ParentName", &GRenderSkeletonBone_t::GetParentName, &GRenderSkeletonBone_t::SetParentName)
        .addProperty("InvBindPose", &GRenderSkeletonBone_t::GetInvBindPose, &GRenderSkeletonBone_t::SetInvBindPose)
        .addProperty("Bbox", &GRenderSkeletonBone_t::GetBbox, &GRenderSkeletonBone_t::SetBbox)
        .addProperty("SphereRadius", &GRenderSkeletonBone_t::GetSphereRadius, &GRenderSkeletonBone_t::SetSphereRadius)
        .addFunction("ToPtr", &GRenderSkeletonBone_t::ToPtr)
        .addFunction("IsValid", &GRenderSkeletonBone_t::IsValid)
        .endClass();
}
GAnimationDecodeDebugDump_t::GAnimationDecodeDebugDump_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GAnimationDecodeDebugDump_t::GAnimationDecodeDebugDump_t(void *ptr) {
    m_ptr = ptr;
}
uint64_t GAnimationDecodeDebugDump_t::GetProcessingType() const {
    return GetSchemaValue<uint64_t>(m_ptr, "AnimationDecodeDebugDump_t", "m_processingType");
}
void GAnimationDecodeDebugDump_t::SetProcessingType(uint64_t value) {
    SetSchemaValue(m_ptr, "AnimationDecodeDebugDump_t", "m_processingType", true, value);
}
std::vector<GAnimationDecodeDebugDumpElement_t> GAnimationDecodeDebugDump_t::GetElems() const {
    CUtlVector<GAnimationDecodeDebugDumpElement_t>* vec = GetSchemaValue<CUtlVector<GAnimationDecodeDebugDumpElement_t>*>(m_ptr, "AnimationDecodeDebugDump_t", "m_elems"); std::vector<GAnimationDecodeDebugDumpElement_t> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GAnimationDecodeDebugDump_t::SetElems(std::vector<GAnimationDecodeDebugDumpElement_t> value) {
    SetSchemaValueCUtlVector<GAnimationDecodeDebugDumpElement_t>(m_ptr, "AnimationDecodeDebugDump_t", "m_elems", true, value);
}
std::string GAnimationDecodeDebugDump_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GAnimationDecodeDebugDump_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassAnimationDecodeDebugDump_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GAnimationDecodeDebugDump_t>("AnimationDecodeDebugDump_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("ProcessingType", &GAnimationDecodeDebugDump_t::GetProcessingType, &GAnimationDecodeDebugDump_t::SetProcessingType)
        .addProperty("Elems", &GAnimationDecodeDebugDump_t::GetElems, &GAnimationDecodeDebugDump_t::SetElems)
        .addFunction("ToPtr", &GAnimationDecodeDebugDump_t::ToPtr)
        .addFunction("IsValid", &GAnimationDecodeDebugDump_t::IsValid)
        .endClass();
}
GPARTICLE_EHANDLE__::GPARTICLE_EHANDLE__(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GPARTICLE_EHANDLE__::GPARTICLE_EHANDLE__(void *ptr) {
    m_ptr = ptr;
}
int32_t GPARTICLE_EHANDLE__::GetUnused() const {
    return GetSchemaValue<int32_t>(m_ptr, "PARTICLE_EHANDLE__", "unused");
}
void GPARTICLE_EHANDLE__::SetUnused(int32_t value) {
    SetSchemaValue(m_ptr, "PARTICLE_EHANDLE__", "unused", false, value);
}
std::string GPARTICLE_EHANDLE__::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GPARTICLE_EHANDLE__::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassPARTICLE_EHANDLE__(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GPARTICLE_EHANDLE__>("PARTICLE_EHANDLE__")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Unused", &GPARTICLE_EHANDLE__::GetUnused, &GPARTICLE_EHANDLE__::SetUnused)
        .addFunction("ToPtr", &GPARTICLE_EHANDLE__::ToPtr)
        .addFunction("IsValid", &GPARTICLE_EHANDLE__::IsValid)
        .endClass();
}
GFeCollisionPlane_t::GFeCollisionPlane_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GFeCollisionPlane_t::GFeCollisionPlane_t(void *ptr) {
    m_ptr = ptr;
}
uint16_t GFeCollisionPlane_t::GetCtrlParent() const {
    return GetSchemaValue<uint16_t>(m_ptr, "FeCollisionPlane_t", "nCtrlParent");
}
void GFeCollisionPlane_t::SetCtrlParent(uint16_t value) {
    SetSchemaValue(m_ptr, "FeCollisionPlane_t", "nCtrlParent", true, value);
}
uint16_t GFeCollisionPlane_t::GetChildNode() const {
    return GetSchemaValue<uint16_t>(m_ptr, "FeCollisionPlane_t", "nChildNode");
}
void GFeCollisionPlane_t::SetChildNode(uint16_t value) {
    SetSchemaValue(m_ptr, "FeCollisionPlane_t", "nChildNode", true, value);
}
GRnPlane_t GFeCollisionPlane_t::GetPlane() const {
    GRnPlane_t value(GetSchemaPtr(m_ptr, "FeCollisionPlane_t", "m_Plane"));
    return value;
}
void GFeCollisionPlane_t::SetPlane(GRnPlane_t value) {
    SetSchemaValue(m_ptr, "FeCollisionPlane_t", "m_Plane", true, value);
}
float GFeCollisionPlane_t::GetStrength() const {
    return GetSchemaValue<float>(m_ptr, "FeCollisionPlane_t", "flStrength");
}
void GFeCollisionPlane_t::SetStrength(float value) {
    SetSchemaValue(m_ptr, "FeCollisionPlane_t", "flStrength", true, value);
}
std::string GFeCollisionPlane_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GFeCollisionPlane_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassFeCollisionPlane_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GFeCollisionPlane_t>("FeCollisionPlane_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("CtrlParent", &GFeCollisionPlane_t::GetCtrlParent, &GFeCollisionPlane_t::SetCtrlParent)
        .addProperty("ChildNode", &GFeCollisionPlane_t::GetChildNode, &GFeCollisionPlane_t::SetChildNode)
        .addProperty("Plane", &GFeCollisionPlane_t::GetPlane, &GFeCollisionPlane_t::SetPlane)
        .addProperty("Strength", &GFeCollisionPlane_t::GetStrength, &GFeCollisionPlane_t::SetStrength)
        .addFunction("ToPtr", &GFeCollisionPlane_t::ToPtr)
        .addFunction("IsValid", &GFeCollisionPlane_t::IsValid)
        .endClass();
}
GCAnimCycle::GCAnimCycle(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCAnimCycle::GCAnimCycle(void *ptr) {
    m_ptr = ptr;
}
std::string GCAnimCycle::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCAnimCycle::IsValid() {
    return (m_ptr != nullptr);
}
GCCycleBase GCAnimCycle::GetParent() const {
    GCCycleBase value(m_ptr);
    return value;
}
void GCAnimCycle::SetParent(GCCycleBase value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCAnimCycle(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCAnimCycle>("CAnimCycle")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCAnimCycle::GetParent, &GCAnimCycle::SetParent)
        .addFunction("ToPtr", &GCAnimCycle::ToPtr)
        .addFunction("IsValid", &GCAnimCycle::IsValid)
        .endClass();
}
GCNmSyncTrack__EventMarker_t::GCNmSyncTrack__EventMarker_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCNmSyncTrack__EventMarker_t::GCNmSyncTrack__EventMarker_t(void *ptr) {
    m_ptr = ptr;
}
GNmPercent_t GCNmSyncTrack__EventMarker_t::GetStartTime() const {
    GNmPercent_t value(GetSchemaPtr(m_ptr, "CNmSyncTrack__EventMarker_t", "m_startTime"));
    return value;
}
void GCNmSyncTrack__EventMarker_t::SetStartTime(GNmPercent_t value) {
    SetSchemaValue(m_ptr, "CNmSyncTrack__EventMarker_t", "m_startTime", true, value);
}
std::string GCNmSyncTrack__EventMarker_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCNmSyncTrack__EventMarker_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCNmSyncTrack__EventMarker_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCNmSyncTrack__EventMarker_t>("CNmSyncTrack__EventMarker_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("StartTime", &GCNmSyncTrack__EventMarker_t::GetStartTime, &GCNmSyncTrack__EventMarker_t::SetStartTime)
        .addFunction("ToPtr", &GCNmSyncTrack__EventMarker_t::ToPtr)
        .addFunction("IsValid", &GCNmSyncTrack__EventMarker_t::IsValid)
        .endClass();
}
GCAnimGraphSettingsManager::GCAnimGraphSettingsManager(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCAnimGraphSettingsManager::GCAnimGraphSettingsManager(void *ptr) {
    m_ptr = ptr;
}
std::string GCAnimGraphSettingsManager::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCAnimGraphSettingsManager::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCAnimGraphSettingsManager(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCAnimGraphSettingsManager>("CAnimGraphSettingsManager")
        .addConstructor<void (*)(std::string)>()
        .addFunction("ToPtr", &GCAnimGraphSettingsManager::ToPtr)
        .addFunction("IsValid", &GCAnimGraphSettingsManager::IsValid)
        .endClass();
}
GCRagdollUpdateNode::GCRagdollUpdateNode(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCRagdollUpdateNode::GCRagdollUpdateNode(void *ptr) {
    m_ptr = ptr;
}
int32_t GCRagdollUpdateNode::GetWeightListIndex() const {
    return GetSchemaValue<int32_t>(m_ptr, "CRagdollUpdateNode", "m_nWeightListIndex");
}
void GCRagdollUpdateNode::SetWeightListIndex(int32_t value) {
    SetSchemaValue(m_ptr, "CRagdollUpdateNode", "m_nWeightListIndex", false, value);
}
uint64_t GCRagdollUpdateNode::GetPoseControlMethod() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CRagdollUpdateNode", "m_poseControlMethod");
}
void GCRagdollUpdateNode::SetPoseControlMethod(uint64_t value) {
    SetSchemaValue(m_ptr, "CRagdollUpdateNode", "m_poseControlMethod", false, value);
}
std::string GCRagdollUpdateNode::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCRagdollUpdateNode::IsValid() {
    return (m_ptr != nullptr);
}
GCUnaryUpdateNode GCRagdollUpdateNode::GetParent() const {
    GCUnaryUpdateNode value(m_ptr);
    return value;
}
void GCRagdollUpdateNode::SetParent(GCUnaryUpdateNode value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCRagdollUpdateNode(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCRagdollUpdateNode>("CRagdollUpdateNode")
        .addConstructor<void (*)(std::string)>()
        .addProperty("WeightListIndex", &GCRagdollUpdateNode::GetWeightListIndex, &GCRagdollUpdateNode::SetWeightListIndex)
        .addProperty("PoseControlMethod", &GCRagdollUpdateNode::GetPoseControlMethod, &GCRagdollUpdateNode::SetPoseControlMethod)
        .addProperty("Parent", &GCRagdollUpdateNode::GetParent, &GCRagdollUpdateNode::SetParent)
        .addFunction("ToPtr", &GCRagdollUpdateNode::ToPtr)
        .addFunction("IsValid", &GCRagdollUpdateNode::IsValid)
        .endClass();
}
GCEntityComponentHelper::GCEntityComponentHelper(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCEntityComponentHelper::GCEntityComponentHelper(void *ptr) {
    m_ptr = ptr;
}
uint32_t GCEntityComponentHelper::GetFlags() const {
    return GetSchemaValue<uint32_t>(m_ptr, "CEntityComponentHelper", "m_flags");
}
void GCEntityComponentHelper::SetFlags(uint32_t value) {
    SetSchemaValue(m_ptr, "CEntityComponentHelper", "m_flags", false, value);
}
GEntComponentInfo_t GCEntityComponentHelper::GetInfo() const {
    GEntComponentInfo_t value(*GetSchemaValuePtr<void*>(m_ptr, "CEntityComponentHelper", "m_pInfo"));
    return value;
}
void GCEntityComponentHelper::SetInfo(GEntComponentInfo_t* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Info' is not possible.\n");
}
int32_t GCEntityComponentHelper::GetPriority() const {
    return GetSchemaValue<int32_t>(m_ptr, "CEntityComponentHelper", "m_nPriority");
}
void GCEntityComponentHelper::SetPriority(int32_t value) {
    SetSchemaValue(m_ptr, "CEntityComponentHelper", "m_nPriority", false, value);
}
GCEntityComponentHelper GCEntityComponentHelper::GetNext() const {
    GCEntityComponentHelper value(*GetSchemaValuePtr<void*>(m_ptr, "CEntityComponentHelper", "m_pNext"));
    return value;
}
void GCEntityComponentHelper::SetNext(GCEntityComponentHelper* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Next' is not possible.\n");
}
std::string GCEntityComponentHelper::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCEntityComponentHelper::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCEntityComponentHelper(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCEntityComponentHelper>("CEntityComponentHelper")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Flags", &GCEntityComponentHelper::GetFlags, &GCEntityComponentHelper::SetFlags)
        .addProperty("Info", &GCEntityComponentHelper::GetInfo, &GCEntityComponentHelper::SetInfo)
        .addProperty("Priority", &GCEntityComponentHelper::GetPriority, &GCEntityComponentHelper::SetPriority)
        .addProperty("Next", &GCEntityComponentHelper::GetNext, &GCEntityComponentHelper::SetNext)
        .addFunction("ToPtr", &GCEntityComponentHelper::ToPtr)
        .addFunction("IsValid", &GCEntityComponentHelper::IsValid)
        .endClass();
}
GCompositeMaterial_t::GCompositeMaterial_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCompositeMaterial_t::GCompositeMaterial_t(void *ptr) {
    m_ptr = ptr;
}
std::vector<GGeneratedTextureHandle_t> GCompositeMaterial_t::GetGeneratedTextures() const {
    CUtlVector<GGeneratedTextureHandle_t>* vec = GetSchemaValue<CUtlVector<GGeneratedTextureHandle_t>*>(m_ptr, "CompositeMaterial_t", "m_vecGeneratedTextures"); std::vector<GGeneratedTextureHandle_t> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCompositeMaterial_t::SetGeneratedTextures(std::vector<GGeneratedTextureHandle_t> value) {
    SetSchemaValueCUtlVector<GGeneratedTextureHandle_t>(m_ptr, "CompositeMaterial_t", "m_vecGeneratedTextures", true, value);
}
std::string GCompositeMaterial_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCompositeMaterial_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCompositeMaterial_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCompositeMaterial_t>("CompositeMaterial_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("GeneratedTextures", &GCompositeMaterial_t::GetGeneratedTextures, &GCompositeMaterial_t::SetGeneratedTextures)
        .addFunction("ToPtr", &GCompositeMaterial_t::ToPtr)
        .addFunction("IsValid", &GCompositeMaterial_t::IsValid)
        .endClass();
}
GSignatureOutflow_Continue::GSignatureOutflow_Continue(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GSignatureOutflow_Continue::GSignatureOutflow_Continue(void *ptr) {
    m_ptr = ptr;
}
std::string GSignatureOutflow_Continue::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GSignatureOutflow_Continue::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassSignatureOutflow_Continue(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GSignatureOutflow_Continue>("SignatureOutflow_Continue")
        .addConstructor<void (*)(std::string)>()
        .addFunction("ToPtr", &GSignatureOutflow_Continue::ToPtr)
        .addFunction("IsValid", &GSignatureOutflow_Continue::IsValid)
        .endClass();
}
GWeightList::GWeightList(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GWeightList::GWeightList(void *ptr) {
    m_ptr = ptr;
}
std::string GWeightList::GetName() const {
    return GetSchemaValue<CUtlString>(m_ptr, "WeightList", "m_name").Get();
}
void GWeightList::SetName(std::string value) {
    SetSchemaValue(m_ptr, "WeightList", "m_name", false, CUtlString(value.c_str()));
}
std::vector<float32> GWeightList::GetWeights() const {
    CUtlVector<float32>* vec = GetSchemaValue<CUtlVector<float32>*>(m_ptr, "WeightList", "m_weights"); std::vector<float32> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GWeightList::SetWeights(std::vector<float32> value) {
    SetSchemaValueCUtlVector<float32>(m_ptr, "WeightList", "m_weights", false, value);
}
std::string GWeightList::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GWeightList::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassWeightList(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GWeightList>("WeightList")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Name", &GWeightList::GetName, &GWeightList::SetName)
        .addProperty("Weights", &GWeightList::GetWeights, &GWeightList::SetWeights)
        .addFunction("ToPtr", &GWeightList::ToPtr)
        .addFunction("IsValid", &GWeightList::IsValid)
        .endClass();
}
GRnBodyDesc_t::GRnBodyDesc_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GRnBodyDesc_t::GRnBodyDesc_t(void *ptr) {
    m_ptr = ptr;
}
std::string GRnBodyDesc_t::GetDebugName() const {
    return GetSchemaValue<CUtlString>(m_ptr, "RnBodyDesc_t", "m_sDebugName").Get();
}
void GRnBodyDesc_t::SetDebugName(std::string value) {
    SetSchemaValue(m_ptr, "RnBodyDesc_t", "m_sDebugName", true, CUtlString(value.c_str()));
}
Vector GRnBodyDesc_t::GetPosition() const {
    return GetSchemaValue<Vector>(m_ptr, "RnBodyDesc_t", "m_vPosition");
}
void GRnBodyDesc_t::SetPosition(Vector value) {
    SetSchemaValue(m_ptr, "RnBodyDesc_t", "m_vPosition", true, value);
}
Vector GRnBodyDesc_t::GetLinearVelocity() const {
    return GetSchemaValue<Vector>(m_ptr, "RnBodyDesc_t", "m_vLinearVelocity");
}
void GRnBodyDesc_t::SetLinearVelocity(Vector value) {
    SetSchemaValue(m_ptr, "RnBodyDesc_t", "m_vLinearVelocity", true, value);
}
Vector GRnBodyDesc_t::GetAngularVelocity() const {
    return GetSchemaValue<Vector>(m_ptr, "RnBodyDesc_t", "m_vAngularVelocity");
}
void GRnBodyDesc_t::SetAngularVelocity(Vector value) {
    SetSchemaValue(m_ptr, "RnBodyDesc_t", "m_vAngularVelocity", true, value);
}
Vector GRnBodyDesc_t::GetLocalMassCenter() const {
    return GetSchemaValue<Vector>(m_ptr, "RnBodyDesc_t", "m_vLocalMassCenter");
}
void GRnBodyDesc_t::SetLocalMassCenter(Vector value) {
    SetSchemaValue(m_ptr, "RnBodyDesc_t", "m_vLocalMassCenter", true, value);
}
std::vector<Vector> GRnBodyDesc_t::GetLocalInertiaInv() const {
    Vector* outValue = GetSchemaValue<Vector*>(m_ptr, "RnBodyDesc_t", "m_LocalInertiaInv"); std::vector<Vector> ret; for(int i = 0; i < 3; i++) { ret.push_back(outValue[i]); } return ret;
}
void GRnBodyDesc_t::SetLocalInertiaInv(std::vector<Vector> value) {
    Vector* outValue = GetSchemaValue<Vector*>(m_ptr, "RnBodyDesc_t", "m_LocalInertiaInv"); for(int i = 0; i < 3; i++) { outValue[i] = value[i]; } SetSchemaValue(m_ptr, "RnBodyDesc_t", "m_LocalInertiaInv", true, outValue);
}
float GRnBodyDesc_t::GetMassInv() const {
    return GetSchemaValue<float>(m_ptr, "RnBodyDesc_t", "m_flMassInv");
}
void GRnBodyDesc_t::SetMassInv(float value) {
    SetSchemaValue(m_ptr, "RnBodyDesc_t", "m_flMassInv", true, value);
}
float GRnBodyDesc_t::GetGameMass() const {
    return GetSchemaValue<float>(m_ptr, "RnBodyDesc_t", "m_flGameMass");
}
void GRnBodyDesc_t::SetGameMass(float value) {
    SetSchemaValue(m_ptr, "RnBodyDesc_t", "m_flGameMass", true, value);
}
float GRnBodyDesc_t::GetInertiaScaleInv() const {
    return GetSchemaValue<float>(m_ptr, "RnBodyDesc_t", "m_flInertiaScaleInv");
}
void GRnBodyDesc_t::SetInertiaScaleInv(float value) {
    SetSchemaValue(m_ptr, "RnBodyDesc_t", "m_flInertiaScaleInv", true, value);
}
float GRnBodyDesc_t::GetLinearDamping() const {
    return GetSchemaValue<float>(m_ptr, "RnBodyDesc_t", "m_flLinearDamping");
}
void GRnBodyDesc_t::SetLinearDamping(float value) {
    SetSchemaValue(m_ptr, "RnBodyDesc_t", "m_flLinearDamping", true, value);
}
float GRnBodyDesc_t::GetAngularDamping() const {
    return GetSchemaValue<float>(m_ptr, "RnBodyDesc_t", "m_flAngularDamping");
}
void GRnBodyDesc_t::SetAngularDamping(float value) {
    SetSchemaValue(m_ptr, "RnBodyDesc_t", "m_flAngularDamping", true, value);
}
float GRnBodyDesc_t::GetLinearDrag() const {
    return GetSchemaValue<float>(m_ptr, "RnBodyDesc_t", "m_flLinearDrag");
}
void GRnBodyDesc_t::SetLinearDrag(float value) {
    SetSchemaValue(m_ptr, "RnBodyDesc_t", "m_flLinearDrag", true, value);
}
float GRnBodyDesc_t::GetAngularDrag() const {
    return GetSchemaValue<float>(m_ptr, "RnBodyDesc_t", "m_flAngularDrag");
}
void GRnBodyDesc_t::SetAngularDrag(float value) {
    SetSchemaValue(m_ptr, "RnBodyDesc_t", "m_flAngularDrag", true, value);
}
float GRnBodyDesc_t::GetLinearBuoyancyDrag() const {
    return GetSchemaValue<float>(m_ptr, "RnBodyDesc_t", "m_flLinearBuoyancyDrag");
}
void GRnBodyDesc_t::SetLinearBuoyancyDrag(float value) {
    SetSchemaValue(m_ptr, "RnBodyDesc_t", "m_flLinearBuoyancyDrag", true, value);
}
float GRnBodyDesc_t::GetAngularBuoyancyDrag() const {
    return GetSchemaValue<float>(m_ptr, "RnBodyDesc_t", "m_flAngularBuoyancyDrag");
}
void GRnBodyDesc_t::SetAngularBuoyancyDrag(float value) {
    SetSchemaValue(m_ptr, "RnBodyDesc_t", "m_flAngularBuoyancyDrag", true, value);
}
Vector GRnBodyDesc_t::GetLastAwakeForceAccum() const {
    return GetSchemaValue<Vector>(m_ptr, "RnBodyDesc_t", "m_vLastAwakeForceAccum");
}
void GRnBodyDesc_t::SetLastAwakeForceAccum(Vector value) {
    SetSchemaValue(m_ptr, "RnBodyDesc_t", "m_vLastAwakeForceAccum", true, value);
}
Vector GRnBodyDesc_t::GetLastAwakeTorqueAccum() const {
    return GetSchemaValue<Vector>(m_ptr, "RnBodyDesc_t", "m_vLastAwakeTorqueAccum");
}
void GRnBodyDesc_t::SetLastAwakeTorqueAccum(Vector value) {
    SetSchemaValue(m_ptr, "RnBodyDesc_t", "m_vLastAwakeTorqueAccum", true, value);
}
float GRnBodyDesc_t::GetBuoyancyFactor() const {
    return GetSchemaValue<float>(m_ptr, "RnBodyDesc_t", "m_flBuoyancyFactor");
}
void GRnBodyDesc_t::SetBuoyancyFactor(float value) {
    SetSchemaValue(m_ptr, "RnBodyDesc_t", "m_flBuoyancyFactor", true, value);
}
float GRnBodyDesc_t::GetGravityScale() const {
    return GetSchemaValue<float>(m_ptr, "RnBodyDesc_t", "m_flGravityScale");
}
void GRnBodyDesc_t::SetGravityScale(float value) {
    SetSchemaValue(m_ptr, "RnBodyDesc_t", "m_flGravityScale", true, value);
}
float GRnBodyDesc_t::GetTimeScale() const {
    return GetSchemaValue<float>(m_ptr, "RnBodyDesc_t", "m_flTimeScale");
}
void GRnBodyDesc_t::SetTimeScale(float value) {
    SetSchemaValue(m_ptr, "RnBodyDesc_t", "m_flTimeScale", true, value);
}
int32_t GRnBodyDesc_t::GetBodyType() const {
    return GetSchemaValue<int32_t>(m_ptr, "RnBodyDesc_t", "m_nBodyType");
}
void GRnBodyDesc_t::SetBodyType(int32_t value) {
    SetSchemaValue(m_ptr, "RnBodyDesc_t", "m_nBodyType", true, value);
}
uint32_t GRnBodyDesc_t::GetGameIndex() const {
    return GetSchemaValue<uint32_t>(m_ptr, "RnBodyDesc_t", "m_nGameIndex");
}
void GRnBodyDesc_t::SetGameIndex(uint32_t value) {
    SetSchemaValue(m_ptr, "RnBodyDesc_t", "m_nGameIndex", true, value);
}
uint32_t GRnBodyDesc_t::GetGameFlags() const {
    return GetSchemaValue<uint32_t>(m_ptr, "RnBodyDesc_t", "m_nGameFlags");
}
void GRnBodyDesc_t::SetGameFlags(uint32_t value) {
    SetSchemaValue(m_ptr, "RnBodyDesc_t", "m_nGameFlags", true, value);
}
int8_t GRnBodyDesc_t::GetMinVelocityIterations() const {
    return GetSchemaValue<int8_t>(m_ptr, "RnBodyDesc_t", "m_nMinVelocityIterations");
}
void GRnBodyDesc_t::SetMinVelocityIterations(int8_t value) {
    SetSchemaValue(m_ptr, "RnBodyDesc_t", "m_nMinVelocityIterations", true, value);
}
int8_t GRnBodyDesc_t::GetMinPositionIterations() const {
    return GetSchemaValue<int8_t>(m_ptr, "RnBodyDesc_t", "m_nMinPositionIterations");
}
void GRnBodyDesc_t::SetMinPositionIterations(int8_t value) {
    SetSchemaValue(m_ptr, "RnBodyDesc_t", "m_nMinPositionIterations", true, value);
}
int8_t GRnBodyDesc_t::GetMassPriority() const {
    return GetSchemaValue<int8_t>(m_ptr, "RnBodyDesc_t", "m_nMassPriority");
}
void GRnBodyDesc_t::SetMassPriority(int8_t value) {
    SetSchemaValue(m_ptr, "RnBodyDesc_t", "m_nMassPriority", true, value);
}
bool GRnBodyDesc_t::GetEnabled() const {
    return GetSchemaValue<bool>(m_ptr, "RnBodyDesc_t", "m_bEnabled");
}
void GRnBodyDesc_t::SetEnabled(bool value) {
    SetSchemaValue(m_ptr, "RnBodyDesc_t", "m_bEnabled", true, value);
}
bool GRnBodyDesc_t::GetSleeping() const {
    return GetSchemaValue<bool>(m_ptr, "RnBodyDesc_t", "m_bSleeping");
}
void GRnBodyDesc_t::SetSleeping(bool value) {
    SetSchemaValue(m_ptr, "RnBodyDesc_t", "m_bSleeping", true, value);
}
bool GRnBodyDesc_t::GetIsContinuousEnabled() const {
    return GetSchemaValue<bool>(m_ptr, "RnBodyDesc_t", "m_bIsContinuousEnabled");
}
void GRnBodyDesc_t::SetIsContinuousEnabled(bool value) {
    SetSchemaValue(m_ptr, "RnBodyDesc_t", "m_bIsContinuousEnabled", true, value);
}
bool GRnBodyDesc_t::GetDragEnabled() const {
    return GetSchemaValue<bool>(m_ptr, "RnBodyDesc_t", "m_bDragEnabled");
}
void GRnBodyDesc_t::SetDragEnabled(bool value) {
    SetSchemaValue(m_ptr, "RnBodyDesc_t", "m_bDragEnabled", true, value);
}
bool GRnBodyDesc_t::GetBuoyancyDragEnabled() const {
    return GetSchemaValue<bool>(m_ptr, "RnBodyDesc_t", "m_bBuoyancyDragEnabled");
}
void GRnBodyDesc_t::SetBuoyancyDragEnabled(bool value) {
    SetSchemaValue(m_ptr, "RnBodyDesc_t", "m_bBuoyancyDragEnabled", true, value);
}
bool GRnBodyDesc_t::GetGravityDisabled() const {
    return GetSchemaValue<bool>(m_ptr, "RnBodyDesc_t", "m_bGravityDisabled");
}
void GRnBodyDesc_t::SetGravityDisabled(bool value) {
    SetSchemaValue(m_ptr, "RnBodyDesc_t", "m_bGravityDisabled", true, value);
}
bool GRnBodyDesc_t::GetSpeculativeEnabled() const {
    return GetSchemaValue<bool>(m_ptr, "RnBodyDesc_t", "m_bSpeculativeEnabled");
}
void GRnBodyDesc_t::SetSpeculativeEnabled(bool value) {
    SetSchemaValue(m_ptr, "RnBodyDesc_t", "m_bSpeculativeEnabled", true, value);
}
bool GRnBodyDesc_t::GetHasShadowController() const {
    return GetSchemaValue<bool>(m_ptr, "RnBodyDesc_t", "m_bHasShadowController");
}
void GRnBodyDesc_t::SetHasShadowController(bool value) {
    SetSchemaValue(m_ptr, "RnBodyDesc_t", "m_bHasShadowController", true, value);
}
std::string GRnBodyDesc_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GRnBodyDesc_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassRnBodyDesc_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GRnBodyDesc_t>("RnBodyDesc_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("DebugName", &GRnBodyDesc_t::GetDebugName, &GRnBodyDesc_t::SetDebugName)
        .addProperty("Position", &GRnBodyDesc_t::GetPosition, &GRnBodyDesc_t::SetPosition)
        .addProperty("LinearVelocity", &GRnBodyDesc_t::GetLinearVelocity, &GRnBodyDesc_t::SetLinearVelocity)
        .addProperty("AngularVelocity", &GRnBodyDesc_t::GetAngularVelocity, &GRnBodyDesc_t::SetAngularVelocity)
        .addProperty("LocalMassCenter", &GRnBodyDesc_t::GetLocalMassCenter, &GRnBodyDesc_t::SetLocalMassCenter)
        .addProperty("LocalInertiaInv", &GRnBodyDesc_t::GetLocalInertiaInv, &GRnBodyDesc_t::SetLocalInertiaInv)
        .addProperty("MassInv", &GRnBodyDesc_t::GetMassInv, &GRnBodyDesc_t::SetMassInv)
        .addProperty("GameMass", &GRnBodyDesc_t::GetGameMass, &GRnBodyDesc_t::SetGameMass)
        .addProperty("InertiaScaleInv", &GRnBodyDesc_t::GetInertiaScaleInv, &GRnBodyDesc_t::SetInertiaScaleInv)
        .addProperty("LinearDamping", &GRnBodyDesc_t::GetLinearDamping, &GRnBodyDesc_t::SetLinearDamping)
        .addProperty("AngularDamping", &GRnBodyDesc_t::GetAngularDamping, &GRnBodyDesc_t::SetAngularDamping)
        .addProperty("LinearDrag", &GRnBodyDesc_t::GetLinearDrag, &GRnBodyDesc_t::SetLinearDrag)
        .addProperty("AngularDrag", &GRnBodyDesc_t::GetAngularDrag, &GRnBodyDesc_t::SetAngularDrag)
        .addProperty("LinearBuoyancyDrag", &GRnBodyDesc_t::GetLinearBuoyancyDrag, &GRnBodyDesc_t::SetLinearBuoyancyDrag)
        .addProperty("AngularBuoyancyDrag", &GRnBodyDesc_t::GetAngularBuoyancyDrag, &GRnBodyDesc_t::SetAngularBuoyancyDrag)
        .addProperty("LastAwakeForceAccum", &GRnBodyDesc_t::GetLastAwakeForceAccum, &GRnBodyDesc_t::SetLastAwakeForceAccum)
        .addProperty("LastAwakeTorqueAccum", &GRnBodyDesc_t::GetLastAwakeTorqueAccum, &GRnBodyDesc_t::SetLastAwakeTorqueAccum)
        .addProperty("BuoyancyFactor", &GRnBodyDesc_t::GetBuoyancyFactor, &GRnBodyDesc_t::SetBuoyancyFactor)
        .addProperty("GravityScale", &GRnBodyDesc_t::GetGravityScale, &GRnBodyDesc_t::SetGravityScale)
        .addProperty("TimeScale", &GRnBodyDesc_t::GetTimeScale, &GRnBodyDesc_t::SetTimeScale)
        .addProperty("BodyType", &GRnBodyDesc_t::GetBodyType, &GRnBodyDesc_t::SetBodyType)
        .addProperty("GameIndex", &GRnBodyDesc_t::GetGameIndex, &GRnBodyDesc_t::SetGameIndex)
        .addProperty("GameFlags", &GRnBodyDesc_t::GetGameFlags, &GRnBodyDesc_t::SetGameFlags)
        .addProperty("MinVelocityIterations", &GRnBodyDesc_t::GetMinVelocityIterations, &GRnBodyDesc_t::SetMinVelocityIterations)
        .addProperty("MinPositionIterations", &GRnBodyDesc_t::GetMinPositionIterations, &GRnBodyDesc_t::SetMinPositionIterations)
        .addProperty("MassPriority", &GRnBodyDesc_t::GetMassPriority, &GRnBodyDesc_t::SetMassPriority)
        .addProperty("Enabled", &GRnBodyDesc_t::GetEnabled, &GRnBodyDesc_t::SetEnabled)
        .addProperty("Sleeping", &GRnBodyDesc_t::GetSleeping, &GRnBodyDesc_t::SetSleeping)
        .addProperty("IsContinuousEnabled", &GRnBodyDesc_t::GetIsContinuousEnabled, &GRnBodyDesc_t::SetIsContinuousEnabled)
        .addProperty("DragEnabled", &GRnBodyDesc_t::GetDragEnabled, &GRnBodyDesc_t::SetDragEnabled)
        .addProperty("BuoyancyDragEnabled", &GRnBodyDesc_t::GetBuoyancyDragEnabled, &GRnBodyDesc_t::SetBuoyancyDragEnabled)
        .addProperty("GravityDisabled", &GRnBodyDesc_t::GetGravityDisabled, &GRnBodyDesc_t::SetGravityDisabled)
        .addProperty("SpeculativeEnabled", &GRnBodyDesc_t::GetSpeculativeEnabled, &GRnBodyDesc_t::SetSpeculativeEnabled)
        .addProperty("HasShadowController", &GRnBodyDesc_t::GetHasShadowController, &GRnBodyDesc_t::SetHasShadowController)
        .addFunction("ToPtr", &GRnBodyDesc_t::ToPtr)
        .addFunction("IsValid", &GRnBodyDesc_t::IsValid)
        .endClass();
}
GCFeMorphLayer::GCFeMorphLayer(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCFeMorphLayer::GCFeMorphLayer(void *ptr) {
    m_ptr = ptr;
}
std::string GCFeMorphLayer::GetName() const {
    return GetSchemaValue<CUtlString>(m_ptr, "CFeMorphLayer", "m_Name").Get();
}
void GCFeMorphLayer::SetName(std::string value) {
    SetSchemaValue(m_ptr, "CFeMorphLayer", "m_Name", false, CUtlString(value.c_str()));
}
uint32_t GCFeMorphLayer::GetNameHash() const {
    return GetSchemaValue<uint32_t>(m_ptr, "CFeMorphLayer", "m_nNameHash");
}
void GCFeMorphLayer::SetNameHash(uint32_t value) {
    SetSchemaValue(m_ptr, "CFeMorphLayer", "m_nNameHash", false, value);
}
std::vector<uint16> GCFeMorphLayer::GetNodes() const {
    CUtlVector<uint16>* vec = GetSchemaValue<CUtlVector<uint16>*>(m_ptr, "CFeMorphLayer", "m_Nodes"); std::vector<uint16> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCFeMorphLayer::SetNodes(std::vector<uint16> value) {
    SetSchemaValueCUtlVector<uint16>(m_ptr, "CFeMorphLayer", "m_Nodes", false, value);
}
std::vector<Vector> GCFeMorphLayer::GetInitPos() const {
    CUtlVector<Vector>* vec = GetSchemaValue<CUtlVector<Vector>*>(m_ptr, "CFeMorphLayer", "m_InitPos"); std::vector<Vector> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCFeMorphLayer::SetInitPos(std::vector<Vector> value) {
    SetSchemaValueCUtlVector<Vector>(m_ptr, "CFeMorphLayer", "m_InitPos", false, value);
}
std::vector<float32> GCFeMorphLayer::GetGravity() const {
    CUtlVector<float32>* vec = GetSchemaValue<CUtlVector<float32>*>(m_ptr, "CFeMorphLayer", "m_Gravity"); std::vector<float32> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCFeMorphLayer::SetGravity(std::vector<float32> value) {
    SetSchemaValueCUtlVector<float32>(m_ptr, "CFeMorphLayer", "m_Gravity", false, value);
}
std::vector<float32> GCFeMorphLayer::GetGoalStrength() const {
    CUtlVector<float32>* vec = GetSchemaValue<CUtlVector<float32>*>(m_ptr, "CFeMorphLayer", "m_GoalStrength"); std::vector<float32> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCFeMorphLayer::SetGoalStrength(std::vector<float32> value) {
    SetSchemaValueCUtlVector<float32>(m_ptr, "CFeMorphLayer", "m_GoalStrength", false, value);
}
std::vector<float32> GCFeMorphLayer::GetGoalDamping() const {
    CUtlVector<float32>* vec = GetSchemaValue<CUtlVector<float32>*>(m_ptr, "CFeMorphLayer", "m_GoalDamping"); std::vector<float32> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCFeMorphLayer::SetGoalDamping(std::vector<float32> value) {
    SetSchemaValueCUtlVector<float32>(m_ptr, "CFeMorphLayer", "m_GoalDamping", false, value);
}
std::string GCFeMorphLayer::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCFeMorphLayer::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCFeMorphLayer(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCFeMorphLayer>("CFeMorphLayer")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Name", &GCFeMorphLayer::GetName, &GCFeMorphLayer::SetName)
        .addProperty("NameHash", &GCFeMorphLayer::GetNameHash, &GCFeMorphLayer::SetNameHash)
        .addProperty("Nodes", &GCFeMorphLayer::GetNodes, &GCFeMorphLayer::SetNodes)
        .addProperty("InitPos", &GCFeMorphLayer::GetInitPos, &GCFeMorphLayer::SetInitPos)
        .addProperty("Gravity", &GCFeMorphLayer::GetGravity, &GCFeMorphLayer::SetGravity)
        .addProperty("GoalStrength", &GCFeMorphLayer::GetGoalStrength, &GCFeMorphLayer::SetGoalStrength)
        .addProperty("GoalDamping", &GCFeMorphLayer::GetGoalDamping, &GCFeMorphLayer::SetGoalDamping)
        .addFunction("ToPtr", &GCFeMorphLayer::ToPtr)
        .addFunction("IsValid", &GCFeMorphLayer::IsValid)
        .endClass();
}
GAnimNodeOutputID::GAnimNodeOutputID(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GAnimNodeOutputID::GAnimNodeOutputID(void *ptr) {
    m_ptr = ptr;
}
uint32_t GAnimNodeOutputID::GetId() const {
    return GetSchemaValue<uint32_t>(m_ptr, "AnimNodeOutputID", "m_id");
}
void GAnimNodeOutputID::SetId(uint32_t value) {
    SetSchemaValue(m_ptr, "AnimNodeOutputID", "m_id", false, value);
}
std::string GAnimNodeOutputID::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GAnimNodeOutputID::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassAnimNodeOutputID(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GAnimNodeOutputID>("AnimNodeOutputID")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Id", &GAnimNodeOutputID::GetId, &GAnimNodeOutputID::SetId)
        .addFunction("ToPtr", &GAnimNodeOutputID::ToPtr)
        .addFunction("IsValid", &GAnimNodeOutputID::IsValid)
        .endClass();
}
GEventClientSceneSystemThreadStateChange_t::GEventClientSceneSystemThreadStateChange_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GEventClientSceneSystemThreadStateChange_t::GEventClientSceneSystemThreadStateChange_t(void *ptr) {
    m_ptr = ptr;
}
bool GEventClientSceneSystemThreadStateChange_t::GetThreadsActive() const {
    return GetSchemaValue<bool>(m_ptr, "EventClientSceneSystemThreadStateChange_t", "m_bThreadsActive");
}
void GEventClientSceneSystemThreadStateChange_t::SetThreadsActive(bool value) {
    SetSchemaValue(m_ptr, "EventClientSceneSystemThreadStateChange_t", "m_bThreadsActive", true, value);
}
std::string GEventClientSceneSystemThreadStateChange_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GEventClientSceneSystemThreadStateChange_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassEventClientSceneSystemThreadStateChange_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GEventClientSceneSystemThreadStateChange_t>("EventClientSceneSystemThreadStateChange_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("ThreadsActive", &GEventClientSceneSystemThreadStateChange_t::GetThreadsActive, &GEventClientSceneSystemThreadStateChange_t::SetThreadsActive)
        .addFunction("ToPtr", &GEventClientSceneSystemThreadStateChange_t::ToPtr)
        .addFunction("IsValid", &GEventClientSceneSystemThreadStateChange_t::IsValid)
        .endClass();
}
GEventClientPreSimulate_t::GEventClientPreSimulate_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GEventClientPreSimulate_t::GEventClientPreSimulate_t(void *ptr) {
    m_ptr = ptr;
}
std::string GEventClientPreSimulate_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GEventClientPreSimulate_t::IsValid() {
    return (m_ptr != nullptr);
}
GEventSimulate_t GEventClientPreSimulate_t::GetParent() const {
    GEventSimulate_t value(m_ptr);
    return value;
}
void GEventClientPreSimulate_t::SetParent(GEventSimulate_t value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassEventClientPreSimulate_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GEventClientPreSimulate_t>("EventClientPreSimulate_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GEventClientPreSimulate_t::GetParent, &GEventClientPreSimulate_t::SetParent)
        .addFunction("ToPtr", &GEventClientPreSimulate_t::ToPtr)
        .addFunction("IsValid", &GEventClientPreSimulate_t::IsValid)
        .endClass();
}
GClutterSceneObject_t::GClutterSceneObject_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GClutterSceneObject_t::GClutterSceneObject_t(void *ptr) {
    m_ptr = ptr;
}
GAABB_t GClutterSceneObject_t::GetBounds() const {
    GAABB_t value(GetSchemaPtr(m_ptr, "ClutterSceneObject_t", "m_Bounds"));
    return value;
}
void GClutterSceneObject_t::SetBounds(GAABB_t value) {
    SetSchemaValue(m_ptr, "ClutterSceneObject_t", "m_Bounds", true, value);
}
uint64_t GClutterSceneObject_t::GetFlags() const {
    return GetSchemaValue<uint64_t>(m_ptr, "ClutterSceneObject_t", "m_flags");
}
void GClutterSceneObject_t::SetFlags(uint64_t value) {
    SetSchemaValue(m_ptr, "ClutterSceneObject_t", "m_flags", true, value);
}
int16_t GClutterSceneObject_t::GetLayer() const {
    return GetSchemaValue<int16_t>(m_ptr, "ClutterSceneObject_t", "m_nLayer");
}
void GClutterSceneObject_t::SetLayer(int16_t value) {
    SetSchemaValue(m_ptr, "ClutterSceneObject_t", "m_nLayer", true, value);
}
std::vector<Vector> GClutterSceneObject_t::GetInstancePositions() const {
    CUtlVector<Vector>* vec = GetSchemaValue<CUtlVector<Vector>*>(m_ptr, "ClutterSceneObject_t", "m_instancePositions"); std::vector<Vector> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GClutterSceneObject_t::SetInstancePositions(std::vector<Vector> value) {
    SetSchemaValueCUtlVector<Vector>(m_ptr, "ClutterSceneObject_t", "m_instancePositions", true, value);
}
std::vector<float32> GClutterSceneObject_t::GetInstanceScales() const {
    CUtlVector<float32>* vec = GetSchemaValue<CUtlVector<float32>*>(m_ptr, "ClutterSceneObject_t", "m_instanceScales"); std::vector<float32> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GClutterSceneObject_t::SetInstanceScales(std::vector<float32> value) {
    SetSchemaValueCUtlVector<float32>(m_ptr, "ClutterSceneObject_t", "m_instanceScales", true, value);
}
std::vector<Color> GClutterSceneObject_t::GetInstanceTintSrgb() const {
    CUtlVector<Color>* vec = GetSchemaValue<CUtlVector<Color>*>(m_ptr, "ClutterSceneObject_t", "m_instanceTintSrgb"); std::vector<Color> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GClutterSceneObject_t::SetInstanceTintSrgb(std::vector<Color> value) {
    SetSchemaValueCUtlVector<Color>(m_ptr, "ClutterSceneObject_t", "m_instanceTintSrgb", true, value);
}
std::vector<GClutterTile_t> GClutterSceneObject_t::GetTiles() const {
    CUtlVector<GClutterTile_t>* vec = GetSchemaValue<CUtlVector<GClutterTile_t>*>(m_ptr, "ClutterSceneObject_t", "m_tiles"); std::vector<GClutterTile_t> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GClutterSceneObject_t::SetTiles(std::vector<GClutterTile_t> value) {
    SetSchemaValueCUtlVector<GClutterTile_t>(m_ptr, "ClutterSceneObject_t", "m_tiles", true, value);
}
std::string GClutterSceneObject_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GClutterSceneObject_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassClutterSceneObject_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GClutterSceneObject_t>("ClutterSceneObject_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Bounds", &GClutterSceneObject_t::GetBounds, &GClutterSceneObject_t::SetBounds)
        .addProperty("Flags", &GClutterSceneObject_t::GetFlags, &GClutterSceneObject_t::SetFlags)
        .addProperty("Layer", &GClutterSceneObject_t::GetLayer, &GClutterSceneObject_t::SetLayer)
        .addProperty("InstancePositions", &GClutterSceneObject_t::GetInstancePositions, &GClutterSceneObject_t::SetInstancePositions)
        .addProperty("InstanceScales", &GClutterSceneObject_t::GetInstanceScales, &GClutterSceneObject_t::SetInstanceScales)
        .addProperty("InstanceTintSrgb", &GClutterSceneObject_t::GetInstanceTintSrgb, &GClutterSceneObject_t::SetInstanceTintSrgb)
        .addProperty("Tiles", &GClutterSceneObject_t::GetTiles, &GClutterSceneObject_t::SetTiles)
        .addFunction("ToPtr", &GClutterSceneObject_t::ToPtr)
        .addFunction("IsValid", &GClutterSceneObject_t::IsValid)
        .endClass();
}
GCPoseHandle::GCPoseHandle(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCPoseHandle::GCPoseHandle(void *ptr) {
    m_ptr = ptr;
}
uint16_t GCPoseHandle::GetIndex() const {
    return GetSchemaValue<uint16_t>(m_ptr, "CPoseHandle", "m_nIndex");
}
void GCPoseHandle::SetIndex(uint16_t value) {
    SetSchemaValue(m_ptr, "CPoseHandle", "m_nIndex", false, value);
}
uint64_t GCPoseHandle::GetType() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CPoseHandle", "m_eType");
}
void GCPoseHandle::SetType(uint64_t value) {
    SetSchemaValue(m_ptr, "CPoseHandle", "m_eType", false, value);
}
std::string GCPoseHandle::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCPoseHandle::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCPoseHandle(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCPoseHandle>("CPoseHandle")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Index", &GCPoseHandle::GetIndex, &GCPoseHandle::SetIndex)
        .addProperty("Type", &GCPoseHandle::GetType, &GCPoseHandle::SetType)
        .addFunction("ToPtr", &GCPoseHandle::ToPtr)
        .addFunction("IsValid", &GCPoseHandle::IsValid)
        .endClass();
}
GCAnimScriptBase::GCAnimScriptBase(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCAnimScriptBase::GCAnimScriptBase(void *ptr) {
    m_ptr = ptr;
}
bool GCAnimScriptBase::GetIsValid() const {
    return GetSchemaValue<bool>(m_ptr, "CAnimScriptBase", "m_bIsValid");
}
void GCAnimScriptBase::SetIsValid(bool value) {
    SetSchemaValue(m_ptr, "CAnimScriptBase", "m_bIsValid", false, value);
}
std::string GCAnimScriptBase::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCAnimScriptBase::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCAnimScriptBase(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCAnimScriptBase>("CAnimScriptBase")
        .addConstructor<void (*)(std::string)>()
        .addProperty("IsValid", &GCAnimScriptBase::GetIsValid, &GCAnimScriptBase::SetIsValid)
        .addFunction("ToPtr", &GCAnimScriptBase::ToPtr)
        .addFunction("IsValid", &GCAnimScriptBase::IsValid)
        .endClass();
}
GCVoiceContainerBlender::GCVoiceContainerBlender(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCVoiceContainerBlender::GCVoiceContainerBlender(void *ptr) {
    m_ptr = ptr;
}
float GCVoiceContainerBlender::GetBlendFactor() const {
    return GetSchemaValue<float>(m_ptr, "CVoiceContainerBlender", "m_flBlendFactor");
}
void GCVoiceContainerBlender::SetBlendFactor(float value) {
    SetSchemaValue(m_ptr, "CVoiceContainerBlender", "m_flBlendFactor", false, value);
}
std::string GCVoiceContainerBlender::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCVoiceContainerBlender::IsValid() {
    return (m_ptr != nullptr);
}
GCVoiceContainerBase GCVoiceContainerBlender::GetParent() const {
    GCVoiceContainerBase value(m_ptr);
    return value;
}
void GCVoiceContainerBlender::SetParent(GCVoiceContainerBase value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCVoiceContainerBlender(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCVoiceContainerBlender>("CVoiceContainerBlender")
        .addConstructor<void (*)(std::string)>()
        .addProperty("BlendFactor", &GCVoiceContainerBlender::GetBlendFactor, &GCVoiceContainerBlender::SetBlendFactor)
        .addProperty("Parent", &GCVoiceContainerBlender::GetParent, &GCVoiceContainerBlender::SetParent)
        .addFunction("ToPtr", &GCVoiceContainerBlender::ToPtr)
        .addFunction("IsValid", &GCVoiceContainerBlender::IsValid)
        .endClass();
}
Gvphysics_save_cphysicsbody_t::Gvphysics_save_cphysicsbody_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
Gvphysics_save_cphysicsbody_t::Gvphysics_save_cphysicsbody_t(void *ptr) {
    m_ptr = ptr;
}
uint64_t Gvphysics_save_cphysicsbody_t::GetOldPointer() const {
    return GetSchemaValue<uint64_t>(m_ptr, "vphysics_save_cphysicsbody_t", "m_nOldPointer");
}
void Gvphysics_save_cphysicsbody_t::SetOldPointer(uint64_t value) {
    SetSchemaValue(m_ptr, "vphysics_save_cphysicsbody_t", "m_nOldPointer", true, value);
}
std::string Gvphysics_save_cphysicsbody_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool Gvphysics_save_cphysicsbody_t::IsValid() {
    return (m_ptr != nullptr);
}
GRnBodyDesc_t Gvphysics_save_cphysicsbody_t::GetParent() const {
    GRnBodyDesc_t value(m_ptr);
    return value;
}
void Gvphysics_save_cphysicsbody_t::SetParent(GRnBodyDesc_t value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassvphysics_save_cphysicsbody_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<Gvphysics_save_cphysicsbody_t>("vphysics_save_cphysicsbody_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("OldPointer", &Gvphysics_save_cphysicsbody_t::GetOldPointer, &Gvphysics_save_cphysicsbody_t::SetOldPointer)
        .addProperty("Parent", &Gvphysics_save_cphysicsbody_t::GetParent, &Gvphysics_save_cphysicsbody_t::SetParent)
        .addFunction("ToPtr", &Gvphysics_save_cphysicsbody_t::ToPtr)
        .addFunction("IsValid", &Gvphysics_save_cphysicsbody_t::IsValid)
        .endClass();
}
GCRagdollAnimTag::GCRagdollAnimTag(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCRagdollAnimTag::GCRagdollAnimTag(void *ptr) {
    m_ptr = ptr;
}
uint64_t GCRagdollAnimTag::GetPoseControl() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CRagdollAnimTag", "m_nPoseControl");
}
void GCRagdollAnimTag::SetPoseControl(uint64_t value) {
    SetSchemaValue(m_ptr, "CRagdollAnimTag", "m_nPoseControl", false, value);
}
float GCRagdollAnimTag::GetFrequency() const {
    return GetSchemaValue<float>(m_ptr, "CRagdollAnimTag", "m_flFrequency");
}
void GCRagdollAnimTag::SetFrequency(float value) {
    SetSchemaValue(m_ptr, "CRagdollAnimTag", "m_flFrequency", false, value);
}
float GCRagdollAnimTag::GetDampingRatio() const {
    return GetSchemaValue<float>(m_ptr, "CRagdollAnimTag", "m_flDampingRatio");
}
void GCRagdollAnimTag::SetDampingRatio(float value) {
    SetSchemaValue(m_ptr, "CRagdollAnimTag", "m_flDampingRatio", false, value);
}
float GCRagdollAnimTag::GetDecayDuration() const {
    return GetSchemaValue<float>(m_ptr, "CRagdollAnimTag", "m_flDecayDuration");
}
void GCRagdollAnimTag::SetDecayDuration(float value) {
    SetSchemaValue(m_ptr, "CRagdollAnimTag", "m_flDecayDuration", false, value);
}
float GCRagdollAnimTag::GetDecayBias() const {
    return GetSchemaValue<float>(m_ptr, "CRagdollAnimTag", "m_flDecayBias");
}
void GCRagdollAnimTag::SetDecayBias(float value) {
    SetSchemaValue(m_ptr, "CRagdollAnimTag", "m_flDecayBias", false, value);
}
bool GCRagdollAnimTag::GetDestroy() const {
    return GetSchemaValue<bool>(m_ptr, "CRagdollAnimTag", "m_bDestroy");
}
void GCRagdollAnimTag::SetDestroy(bool value) {
    SetSchemaValue(m_ptr, "CRagdollAnimTag", "m_bDestroy", false, value);
}
std::string GCRagdollAnimTag::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCRagdollAnimTag::IsValid() {
    return (m_ptr != nullptr);
}
GCAnimTagBase GCRagdollAnimTag::GetParent() const {
    GCAnimTagBase value(m_ptr);
    return value;
}
void GCRagdollAnimTag::SetParent(GCAnimTagBase value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCRagdollAnimTag(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCRagdollAnimTag>("CRagdollAnimTag")
        .addConstructor<void (*)(std::string)>()
        .addProperty("PoseControl", &GCRagdollAnimTag::GetPoseControl, &GCRagdollAnimTag::SetPoseControl)
        .addProperty("Frequency", &GCRagdollAnimTag::GetFrequency, &GCRagdollAnimTag::SetFrequency)
        .addProperty("DampingRatio", &GCRagdollAnimTag::GetDampingRatio, &GCRagdollAnimTag::SetDampingRatio)
        .addProperty("DecayDuration", &GCRagdollAnimTag::GetDecayDuration, &GCRagdollAnimTag::SetDecayDuration)
        .addProperty("DecayBias", &GCRagdollAnimTag::GetDecayBias, &GCRagdollAnimTag::SetDecayBias)
        .addProperty("Destroy", &GCRagdollAnimTag::GetDestroy, &GCRagdollAnimTag::SetDestroy)
        .addProperty("Parent", &GCRagdollAnimTag::GetParent, &GCRagdollAnimTag::SetParent)
        .addFunction("ToPtr", &GCRagdollAnimTag::ToPtr)
        .addFunction("IsValid", &GCRagdollAnimTag::IsValid)
        .endClass();
}
GIClientAlphaProperty::GIClientAlphaProperty(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GIClientAlphaProperty::GIClientAlphaProperty(void *ptr) {
    m_ptr = ptr;
}
std::string GIClientAlphaProperty::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GIClientAlphaProperty::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassIClientAlphaProperty(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GIClientAlphaProperty>("IClientAlphaProperty")
        .addConstructor<void (*)(std::string)>()
        .addFunction("ToPtr", &GIClientAlphaProperty::ToPtr)
        .addFunction("IsValid", &GIClientAlphaProperty::IsValid)
        .endClass();
}
GPermModelData_t::GPermModelData_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GPermModelData_t::GPermModelData_t(void *ptr) {
    m_ptr = ptr;
}
std::string GPermModelData_t::GetName() const {
    return GetSchemaValue<CUtlString>(m_ptr, "PermModelData_t", "m_name").Get();
}
void GPermModelData_t::SetName(std::string value) {
    SetSchemaValue(m_ptr, "PermModelData_t", "m_name", true, CUtlString(value.c_str()));
}
GPermModelInfo_t GPermModelData_t::GetModelInfo() const {
    GPermModelInfo_t value(GetSchemaPtr(m_ptr, "PermModelData_t", "m_modelInfo"));
    return value;
}
void GPermModelData_t::SetModelInfo(GPermModelInfo_t value) {
    SetSchemaValue(m_ptr, "PermModelData_t", "m_modelInfo", true, value);
}
std::vector<GPermModelExtPart_t> GPermModelData_t::GetExtParts() const {
    CUtlVector<GPermModelExtPart_t>* vec = GetSchemaValue<CUtlVector<GPermModelExtPart_t>*>(m_ptr, "PermModelData_t", "m_ExtParts"); std::vector<GPermModelExtPart_t> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GPermModelData_t::SetExtParts(std::vector<GPermModelExtPart_t> value) {
    SetSchemaValueCUtlVector<GPermModelExtPart_t>(m_ptr, "PermModelData_t", "m_ExtParts", true, value);
}
std::vector<uint64> GPermModelData_t::GetRefMeshGroupMasks() const {
    CUtlVector<uint64>* vec = GetSchemaValue<CUtlVector<uint64>*>(m_ptr, "PermModelData_t", "m_refMeshGroupMasks"); std::vector<uint64> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GPermModelData_t::SetRefMeshGroupMasks(std::vector<uint64> value) {
    SetSchemaValueCUtlVector<uint64>(m_ptr, "PermModelData_t", "m_refMeshGroupMasks", true, value);
}
std::vector<uint64> GPermModelData_t::GetRefPhysGroupMasks() const {
    CUtlVector<uint64>* vec = GetSchemaValue<CUtlVector<uint64>*>(m_ptr, "PermModelData_t", "m_refPhysGroupMasks"); std::vector<uint64> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GPermModelData_t::SetRefPhysGroupMasks(std::vector<uint64> value) {
    SetSchemaValueCUtlVector<uint64>(m_ptr, "PermModelData_t", "m_refPhysGroupMasks", true, value);
}
std::vector<uint8> GPermModelData_t::GetRefLODGroupMasks() const {
    CUtlVector<uint8>* vec = GetSchemaValue<CUtlVector<uint8>*>(m_ptr, "PermModelData_t", "m_refLODGroupMasks"); std::vector<uint8> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GPermModelData_t::SetRefLODGroupMasks(std::vector<uint8> value) {
    SetSchemaValueCUtlVector<uint8>(m_ptr, "PermModelData_t", "m_refLODGroupMasks", true, value);
}
std::vector<float32> GPermModelData_t::GetLodGroupSwitchDistances() const {
    CUtlVector<float32>* vec = GetSchemaValue<CUtlVector<float32>*>(m_ptr, "PermModelData_t", "m_lodGroupSwitchDistances"); std::vector<float32> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GPermModelData_t::SetLodGroupSwitchDistances(std::vector<float32> value) {
    SetSchemaValueCUtlVector<float32>(m_ptr, "PermModelData_t", "m_lodGroupSwitchDistances", true, value);
}
std::vector<CUtlString> GPermModelData_t::GetMeshGroups() const {
    CUtlVector<CUtlString>* vec = GetSchemaValue<CUtlVector<CUtlString>*>(m_ptr, "PermModelData_t", "m_meshGroups"); std::vector<CUtlString> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GPermModelData_t::SetMeshGroups(std::vector<CUtlString> value) {
    SetSchemaValueCUtlVector<CUtlString>(m_ptr, "PermModelData_t", "m_meshGroups", true, value);
}
std::vector<GMaterialGroup_t> GPermModelData_t::GetMaterialGroups() const {
    CUtlVector<GMaterialGroup_t>* vec = GetSchemaValue<CUtlVector<GMaterialGroup_t>*>(m_ptr, "PermModelData_t", "m_materialGroups"); std::vector<GMaterialGroup_t> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GPermModelData_t::SetMaterialGroups(std::vector<GMaterialGroup_t> value) {
    SetSchemaValueCUtlVector<GMaterialGroup_t>(m_ptr, "PermModelData_t", "m_materialGroups", true, value);
}
uint64_t GPermModelData_t::GetDefaultMeshGroupMask() const {
    return GetSchemaValue<uint64_t>(m_ptr, "PermModelData_t", "m_nDefaultMeshGroupMask");
}
void GPermModelData_t::SetDefaultMeshGroupMask(uint64_t value) {
    SetSchemaValue(m_ptr, "PermModelData_t", "m_nDefaultMeshGroupMask", true, value);
}
GModelSkeletonData_t GPermModelData_t::GetModelSkeleton() const {
    GModelSkeletonData_t value(GetSchemaPtr(m_ptr, "PermModelData_t", "m_modelSkeleton"));
    return value;
}
void GPermModelData_t::SetModelSkeleton(GModelSkeletonData_t value) {
    SetSchemaValue(m_ptr, "PermModelData_t", "m_modelSkeleton", true, value);
}
std::vector<int16> GPermModelData_t::GetRemappingTable() const {
    CUtlVector<int16>* vec = GetSchemaValue<CUtlVector<int16>*>(m_ptr, "PermModelData_t", "m_remappingTable"); std::vector<int16> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GPermModelData_t::SetRemappingTable(std::vector<int16> value) {
    SetSchemaValueCUtlVector<int16>(m_ptr, "PermModelData_t", "m_remappingTable", true, value);
}
std::vector<uint16> GPermModelData_t::GetRemappingTableStarts() const {
    CUtlVector<uint16>* vec = GetSchemaValue<CUtlVector<uint16>*>(m_ptr, "PermModelData_t", "m_remappingTableStarts"); std::vector<uint16> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GPermModelData_t::SetRemappingTableStarts(std::vector<uint16> value) {
    SetSchemaValueCUtlVector<uint16>(m_ptr, "PermModelData_t", "m_remappingTableStarts", true, value);
}
std::vector<GModelBoneFlexDriver_t> GPermModelData_t::GetBoneFlexDrivers() const {
    CUtlVector<GModelBoneFlexDriver_t>* vec = GetSchemaValue<CUtlVector<GModelBoneFlexDriver_t>*>(m_ptr, "PermModelData_t", "m_boneFlexDrivers"); std::vector<GModelBoneFlexDriver_t> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GPermModelData_t::SetBoneFlexDrivers(std::vector<GModelBoneFlexDriver_t> value) {
    SetSchemaValueCUtlVector<GModelBoneFlexDriver_t>(m_ptr, "PermModelData_t", "m_boneFlexDrivers", true, value);
}
GCModelConfigList GPermModelData_t::GetModelConfigList() const {
    GCModelConfigList value(*GetSchemaValuePtr<void*>(m_ptr, "PermModelData_t", "m_pModelConfigList"));
    return value;
}
void GPermModelData_t::SetModelConfigList(GCModelConfigList* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'ModelConfigList' is not possible.\n");
}
std::vector<CUtlString> GPermModelData_t::GetBodyGroupsHiddenInTools() const {
    CUtlVector<CUtlString>* vec = GetSchemaValue<CUtlVector<CUtlString>*>(m_ptr, "PermModelData_t", "m_BodyGroupsHiddenInTools"); std::vector<CUtlString> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GPermModelData_t::SetBodyGroupsHiddenInTools(std::vector<CUtlString> value) {
    SetSchemaValueCUtlVector<CUtlString>(m_ptr, "PermModelData_t", "m_BodyGroupsHiddenInTools", true, value);
}
std::vector<GPermModelDataAnimatedMaterialAttribute_t> GPermModelData_t::GetAnimatedMaterialAttributes() const {
    CUtlVector<GPermModelDataAnimatedMaterialAttribute_t>* vec = GetSchemaValue<CUtlVector<GPermModelDataAnimatedMaterialAttribute_t>*>(m_ptr, "PermModelData_t", "m_AnimatedMaterialAttributes"); std::vector<GPermModelDataAnimatedMaterialAttribute_t> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GPermModelData_t::SetAnimatedMaterialAttributes(std::vector<GPermModelDataAnimatedMaterialAttribute_t> value) {
    SetSchemaValueCUtlVector<GPermModelDataAnimatedMaterialAttribute_t>(m_ptr, "PermModelData_t", "m_AnimatedMaterialAttributes", true, value);
}
std::string GPermModelData_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GPermModelData_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassPermModelData_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GPermModelData_t>("PermModelData_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Name", &GPermModelData_t::GetName, &GPermModelData_t::SetName)
        .addProperty("ModelInfo", &GPermModelData_t::GetModelInfo, &GPermModelData_t::SetModelInfo)
        .addProperty("ExtParts", &GPermModelData_t::GetExtParts, &GPermModelData_t::SetExtParts)
        .addProperty("RefMeshGroupMasks", &GPermModelData_t::GetRefMeshGroupMasks, &GPermModelData_t::SetRefMeshGroupMasks)
        .addProperty("RefPhysGroupMasks", &GPermModelData_t::GetRefPhysGroupMasks, &GPermModelData_t::SetRefPhysGroupMasks)
        .addProperty("RefLODGroupMasks", &GPermModelData_t::GetRefLODGroupMasks, &GPermModelData_t::SetRefLODGroupMasks)
        .addProperty("LodGroupSwitchDistances", &GPermModelData_t::GetLodGroupSwitchDistances, &GPermModelData_t::SetLodGroupSwitchDistances)
        .addProperty("MeshGroups", &GPermModelData_t::GetMeshGroups, &GPermModelData_t::SetMeshGroups)
        .addProperty("MaterialGroups", &GPermModelData_t::GetMaterialGroups, &GPermModelData_t::SetMaterialGroups)
        .addProperty("DefaultMeshGroupMask", &GPermModelData_t::GetDefaultMeshGroupMask, &GPermModelData_t::SetDefaultMeshGroupMask)
        .addProperty("ModelSkeleton", &GPermModelData_t::GetModelSkeleton, &GPermModelData_t::SetModelSkeleton)
        .addProperty("RemappingTable", &GPermModelData_t::GetRemappingTable, &GPermModelData_t::SetRemappingTable)
        .addProperty("RemappingTableStarts", &GPermModelData_t::GetRemappingTableStarts, &GPermModelData_t::SetRemappingTableStarts)
        .addProperty("BoneFlexDrivers", &GPermModelData_t::GetBoneFlexDrivers, &GPermModelData_t::SetBoneFlexDrivers)
        .addProperty("ModelConfigList", &GPermModelData_t::GetModelConfigList, &GPermModelData_t::SetModelConfigList)
        .addProperty("BodyGroupsHiddenInTools", &GPermModelData_t::GetBodyGroupsHiddenInTools, &GPermModelData_t::SetBodyGroupsHiddenInTools)
        .addProperty("AnimatedMaterialAttributes", &GPermModelData_t::GetAnimatedMaterialAttributes, &GPermModelData_t::SetAnimatedMaterialAttributes)
        .addFunction("ToPtr", &GPermModelData_t::ToPtr)
        .addFunction("IsValid", &GPermModelData_t::IsValid)
        .endClass();
}
GFootFixedSettings::GFootFixedSettings(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GFootFixedSettings::GFootFixedSettings(void *ptr) {
    m_ptr = ptr;
}
GTraceSettings_t GFootFixedSettings::GetTraceSettings() const {
    GTraceSettings_t value(GetSchemaPtr(m_ptr, "FootFixedSettings", "m_traceSettings"));
    return value;
}
void GFootFixedSettings::SetTraceSettings(GTraceSettings_t value) {
    SetSchemaValue(m_ptr, "FootFixedSettings", "m_traceSettings", false, value);
}
Vector GFootFixedSettings::GetFootBaseBindPosePositionMS() const {
    return GetSchemaValue<Vector>(m_ptr, "FootFixedSettings", "m_vFootBaseBindPosePositionMS");
}
void GFootFixedSettings::SetFootBaseBindPosePositionMS(Vector value) {
    SetSchemaValue(m_ptr, "FootFixedSettings", "m_vFootBaseBindPosePositionMS", false, value);
}
float GFootFixedSettings::GetFootBaseLength() const {
    return GetSchemaValue<float>(m_ptr, "FootFixedSettings", "m_flFootBaseLength");
}
void GFootFixedSettings::SetFootBaseLength(float value) {
    SetSchemaValue(m_ptr, "FootFixedSettings", "m_flFootBaseLength", false, value);
}
float GFootFixedSettings::GetMaxRotationLeft() const {
    return GetSchemaValue<float>(m_ptr, "FootFixedSettings", "m_flMaxRotationLeft");
}
void GFootFixedSettings::SetMaxRotationLeft(float value) {
    SetSchemaValue(m_ptr, "FootFixedSettings", "m_flMaxRotationLeft", false, value);
}
float GFootFixedSettings::GetMaxRotationRight() const {
    return GetSchemaValue<float>(m_ptr, "FootFixedSettings", "m_flMaxRotationRight");
}
void GFootFixedSettings::SetMaxRotationRight(float value) {
    SetSchemaValue(m_ptr, "FootFixedSettings", "m_flMaxRotationRight", false, value);
}
int32_t GFootFixedSettings::GetFootstepLandedTagIndex() const {
    return GetSchemaValue<int32_t>(m_ptr, "FootFixedSettings", "m_footstepLandedTagIndex");
}
void GFootFixedSettings::SetFootstepLandedTagIndex(int32_t value) {
    SetSchemaValue(m_ptr, "FootFixedSettings", "m_footstepLandedTagIndex", false, value);
}
bool GFootFixedSettings::GetEnableTracing() const {
    return GetSchemaValue<bool>(m_ptr, "FootFixedSettings", "m_bEnableTracing");
}
void GFootFixedSettings::SetEnableTracing(bool value) {
    SetSchemaValue(m_ptr, "FootFixedSettings", "m_bEnableTracing", false, value);
}
float GFootFixedSettings::GetTraceAngleBlend() const {
    return GetSchemaValue<float>(m_ptr, "FootFixedSettings", "m_flTraceAngleBlend");
}
void GFootFixedSettings::SetTraceAngleBlend(float value) {
    SetSchemaValue(m_ptr, "FootFixedSettings", "m_flTraceAngleBlend", false, value);
}
int32_t GFootFixedSettings::GetDisableTagIndex() const {
    return GetSchemaValue<int32_t>(m_ptr, "FootFixedSettings", "m_nDisableTagIndex");
}
void GFootFixedSettings::SetDisableTagIndex(int32_t value) {
    SetSchemaValue(m_ptr, "FootFixedSettings", "m_nDisableTagIndex", false, value);
}
int32_t GFootFixedSettings::GetFootIndex() const {
    return GetSchemaValue<int32_t>(m_ptr, "FootFixedSettings", "m_nFootIndex");
}
void GFootFixedSettings::SetFootIndex(int32_t value) {
    SetSchemaValue(m_ptr, "FootFixedSettings", "m_nFootIndex", false, value);
}
std::string GFootFixedSettings::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GFootFixedSettings::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassFootFixedSettings(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GFootFixedSettings>("FootFixedSettings")
        .addConstructor<void (*)(std::string)>()
        .addProperty("TraceSettings", &GFootFixedSettings::GetTraceSettings, &GFootFixedSettings::SetTraceSettings)
        .addProperty("FootBaseBindPosePositionMS", &GFootFixedSettings::GetFootBaseBindPosePositionMS, &GFootFixedSettings::SetFootBaseBindPosePositionMS)
        .addProperty("FootBaseLength", &GFootFixedSettings::GetFootBaseLength, &GFootFixedSettings::SetFootBaseLength)
        .addProperty("MaxRotationLeft", &GFootFixedSettings::GetMaxRotationLeft, &GFootFixedSettings::SetMaxRotationLeft)
        .addProperty("MaxRotationRight", &GFootFixedSettings::GetMaxRotationRight, &GFootFixedSettings::SetMaxRotationRight)
        .addProperty("FootstepLandedTagIndex", &GFootFixedSettings::GetFootstepLandedTagIndex, &GFootFixedSettings::SetFootstepLandedTagIndex)
        .addProperty("EnableTracing", &GFootFixedSettings::GetEnableTracing, &GFootFixedSettings::SetEnableTracing)
        .addProperty("TraceAngleBlend", &GFootFixedSettings::GetTraceAngleBlend, &GFootFixedSettings::SetTraceAngleBlend)
        .addProperty("DisableTagIndex", &GFootFixedSettings::GetDisableTagIndex, &GFootFixedSettings::SetDisableTagIndex)
        .addProperty("FootIndex", &GFootFixedSettings::GetFootIndex, &GFootFixedSettings::SetFootIndex)
        .addFunction("ToPtr", &GFootFixedSettings::ToPtr)
        .addFunction("IsValid", &GFootFixedSettings::IsValid)
        .endClass();
}
GCSolveIKTargetHandle_t::GCSolveIKTargetHandle_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCSolveIKTargetHandle_t::GCSolveIKTargetHandle_t(void *ptr) {
    m_ptr = ptr;
}
GCAnimParamHandle GCSolveIKTargetHandle_t::GetPositionHandle() const {
    GCAnimParamHandle value(GetSchemaPtr(m_ptr, "CSolveIKTargetHandle_t", "m_positionHandle"));
    return value;
}
void GCSolveIKTargetHandle_t::SetPositionHandle(GCAnimParamHandle value) {
    SetSchemaValue(m_ptr, "CSolveIKTargetHandle_t", "m_positionHandle", true, value);
}
GCAnimParamHandle GCSolveIKTargetHandle_t::GetOrientationHandle() const {
    GCAnimParamHandle value(GetSchemaPtr(m_ptr, "CSolveIKTargetHandle_t", "m_orientationHandle"));
    return value;
}
void GCSolveIKTargetHandle_t::SetOrientationHandle(GCAnimParamHandle value) {
    SetSchemaValue(m_ptr, "CSolveIKTargetHandle_t", "m_orientationHandle", true, value);
}
std::string GCSolveIKTargetHandle_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCSolveIKTargetHandle_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCSolveIKTargetHandle_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCSolveIKTargetHandle_t>("CSolveIKTargetHandle_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("PositionHandle", &GCSolveIKTargetHandle_t::GetPositionHandle, &GCSolveIKTargetHandle_t::SetPositionHandle)
        .addProperty("OrientationHandle", &GCSolveIKTargetHandle_t::GetOrientationHandle, &GCSolveIKTargetHandle_t::SetOrientationHandle)
        .addFunction("ToPtr", &GCSolveIKTargetHandle_t::ToPtr)
        .addFunction("IsValid", &GCSolveIKTargetHandle_t::IsValid)
        .endClass();
}
GCBlendUpdateNode::GCBlendUpdateNode(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCBlendUpdateNode::GCBlendUpdateNode(void *ptr) {
    m_ptr = ptr;
}
std::vector<GCAnimUpdateNodeRef> GCBlendUpdateNode::GetChildren() const {
    CUtlVector<GCAnimUpdateNodeRef>* vec = GetSchemaValue<CUtlVector<GCAnimUpdateNodeRef>*>(m_ptr, "CBlendUpdateNode", "m_children"); std::vector<GCAnimUpdateNodeRef> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCBlendUpdateNode::SetChildren(std::vector<GCAnimUpdateNodeRef> value) {
    SetSchemaValueCUtlVector<GCAnimUpdateNodeRef>(m_ptr, "CBlendUpdateNode", "m_children", false, value);
}
std::vector<uint8> GCBlendUpdateNode::GetSortedOrder() const {
    CUtlVector<uint8>* vec = GetSchemaValue<CUtlVector<uint8>*>(m_ptr, "CBlendUpdateNode", "m_sortedOrder"); std::vector<uint8> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCBlendUpdateNode::SetSortedOrder(std::vector<uint8> value) {
    SetSchemaValueCUtlVector<uint8>(m_ptr, "CBlendUpdateNode", "m_sortedOrder", false, value);
}
std::vector<float32> GCBlendUpdateNode::GetTargetValues() const {
    CUtlVector<float32>* vec = GetSchemaValue<CUtlVector<float32>*>(m_ptr, "CBlendUpdateNode", "m_targetValues"); std::vector<float32> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCBlendUpdateNode::SetTargetValues(std::vector<float32> value) {
    SetSchemaValueCUtlVector<float32>(m_ptr, "CBlendUpdateNode", "m_targetValues", false, value);
}
uint64_t GCBlendUpdateNode::GetBlendValueSource() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CBlendUpdateNode", "m_blendValueSource");
}
void GCBlendUpdateNode::SetBlendValueSource(uint64_t value) {
    SetSchemaValue(m_ptr, "CBlendUpdateNode", "m_blendValueSource", false, value);
}
GCAnimParamHandle GCBlendUpdateNode::GetParamIndex() const {
    GCAnimParamHandle value(GetSchemaPtr(m_ptr, "CBlendUpdateNode", "m_paramIndex"));
    return value;
}
void GCBlendUpdateNode::SetParamIndex(GCAnimParamHandle value) {
    SetSchemaValue(m_ptr, "CBlendUpdateNode", "m_paramIndex", false, value);
}
GCAnimInputDamping GCBlendUpdateNode::GetDamping() const {
    GCAnimInputDamping value(GetSchemaPtr(m_ptr, "CBlendUpdateNode", "m_damping"));
    return value;
}
void GCBlendUpdateNode::SetDamping(GCAnimInputDamping value) {
    SetSchemaValue(m_ptr, "CBlendUpdateNode", "m_damping", false, value);
}
uint64_t GCBlendUpdateNode::GetBlendKeyType() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CBlendUpdateNode", "m_blendKeyType");
}
void GCBlendUpdateNode::SetBlendKeyType(uint64_t value) {
    SetSchemaValue(m_ptr, "CBlendUpdateNode", "m_blendKeyType", false, value);
}
bool GCBlendUpdateNode::GetLockBlendOnReset() const {
    return GetSchemaValue<bool>(m_ptr, "CBlendUpdateNode", "m_bLockBlendOnReset");
}
void GCBlendUpdateNode::SetLockBlendOnReset(bool value) {
    SetSchemaValue(m_ptr, "CBlendUpdateNode", "m_bLockBlendOnReset", false, value);
}
bool GCBlendUpdateNode::GetSyncCycles() const {
    return GetSchemaValue<bool>(m_ptr, "CBlendUpdateNode", "m_bSyncCycles");
}
void GCBlendUpdateNode::SetSyncCycles(bool value) {
    SetSchemaValue(m_ptr, "CBlendUpdateNode", "m_bSyncCycles", false, value);
}
bool GCBlendUpdateNode::GetLoop() const {
    return GetSchemaValue<bool>(m_ptr, "CBlendUpdateNode", "m_bLoop");
}
void GCBlendUpdateNode::SetLoop(bool value) {
    SetSchemaValue(m_ptr, "CBlendUpdateNode", "m_bLoop", false, value);
}
bool GCBlendUpdateNode::GetLockWhenWaning() const {
    return GetSchemaValue<bool>(m_ptr, "CBlendUpdateNode", "m_bLockWhenWaning");
}
void GCBlendUpdateNode::SetLockWhenWaning(bool value) {
    SetSchemaValue(m_ptr, "CBlendUpdateNode", "m_bLockWhenWaning", false, value);
}
std::string GCBlendUpdateNode::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCBlendUpdateNode::IsValid() {
    return (m_ptr != nullptr);
}
GCAnimUpdateNodeBase GCBlendUpdateNode::GetParent() const {
    GCAnimUpdateNodeBase value(m_ptr);
    return value;
}
void GCBlendUpdateNode::SetParent(GCAnimUpdateNodeBase value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCBlendUpdateNode(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCBlendUpdateNode>("CBlendUpdateNode")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Children", &GCBlendUpdateNode::GetChildren, &GCBlendUpdateNode::SetChildren)
        .addProperty("SortedOrder", &GCBlendUpdateNode::GetSortedOrder, &GCBlendUpdateNode::SetSortedOrder)
        .addProperty("TargetValues", &GCBlendUpdateNode::GetTargetValues, &GCBlendUpdateNode::SetTargetValues)
        .addProperty("BlendValueSource", &GCBlendUpdateNode::GetBlendValueSource, &GCBlendUpdateNode::SetBlendValueSource)
        .addProperty("ParamIndex", &GCBlendUpdateNode::GetParamIndex, &GCBlendUpdateNode::SetParamIndex)
        .addProperty("Damping", &GCBlendUpdateNode::GetDamping, &GCBlendUpdateNode::SetDamping)
        .addProperty("BlendKeyType", &GCBlendUpdateNode::GetBlendKeyType, &GCBlendUpdateNode::SetBlendKeyType)
        .addProperty("LockBlendOnReset", &GCBlendUpdateNode::GetLockBlendOnReset, &GCBlendUpdateNode::SetLockBlendOnReset)
        .addProperty("SyncCycles", &GCBlendUpdateNode::GetSyncCycles, &GCBlendUpdateNode::SetSyncCycles)
        .addProperty("Loop", &GCBlendUpdateNode::GetLoop, &GCBlendUpdateNode::SetLoop)
        .addProperty("LockWhenWaning", &GCBlendUpdateNode::GetLockWhenWaning, &GCBlendUpdateNode::SetLockWhenWaning)
        .addProperty("Parent", &GCBlendUpdateNode::GetParent, &GCBlendUpdateNode::SetParent)
        .addFunction("ToPtr", &GCBlendUpdateNode::ToPtr)
        .addFunction("IsValid", &GCBlendUpdateNode::IsValid)
        .endClass();
}
GCAnimationGraphVisualizerSphere::GCAnimationGraphVisualizerSphere(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCAnimationGraphVisualizerSphere::GCAnimationGraphVisualizerSphere(void *ptr) {
    m_ptr = ptr;
}
Vector GCAnimationGraphVisualizerSphere::GetWsPosition() const {
    return GetSchemaValue<Vector>(m_ptr, "CAnimationGraphVisualizerSphere", "m_vWsPosition");
}
void GCAnimationGraphVisualizerSphere::SetWsPosition(Vector value) {
    SetSchemaValue(m_ptr, "CAnimationGraphVisualizerSphere", "m_vWsPosition", false, value);
}
float GCAnimationGraphVisualizerSphere::GetRadius() const {
    return GetSchemaValue<float>(m_ptr, "CAnimationGraphVisualizerSphere", "m_flRadius");
}
void GCAnimationGraphVisualizerSphere::SetRadius(float value) {
    SetSchemaValue(m_ptr, "CAnimationGraphVisualizerSphere", "m_flRadius", false, value);
}
Color GCAnimationGraphVisualizerSphere::GetColor() const {
    return GetSchemaValue<Color>(m_ptr, "CAnimationGraphVisualizerSphere", "m_Color");
}
void GCAnimationGraphVisualizerSphere::SetColor(Color value) {
    SetSchemaValue(m_ptr, "CAnimationGraphVisualizerSphere", "m_Color", false, value);
}
std::string GCAnimationGraphVisualizerSphere::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCAnimationGraphVisualizerSphere::IsValid() {
    return (m_ptr != nullptr);
}
GCAnimationGraphVisualizerPrimitiveBase GCAnimationGraphVisualizerSphere::GetParent() const {
    GCAnimationGraphVisualizerPrimitiveBase value(m_ptr);
    return value;
}
void GCAnimationGraphVisualizerSphere::SetParent(GCAnimationGraphVisualizerPrimitiveBase value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCAnimationGraphVisualizerSphere(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCAnimationGraphVisualizerSphere>("CAnimationGraphVisualizerSphere")
        .addConstructor<void (*)(std::string)>()
        .addProperty("WsPosition", &GCAnimationGraphVisualizerSphere::GetWsPosition, &GCAnimationGraphVisualizerSphere::SetWsPosition)
        .addProperty("Radius", &GCAnimationGraphVisualizerSphere::GetRadius, &GCAnimationGraphVisualizerSphere::SetRadius)
        .addProperty("Color", &GCAnimationGraphVisualizerSphere::GetColor, &GCAnimationGraphVisualizerSphere::SetColor)
        .addProperty("Parent", &GCAnimationGraphVisualizerSphere::GetParent, &GCAnimationGraphVisualizerSphere::SetParent)
        .addFunction("ToPtr", &GCAnimationGraphVisualizerSphere::ToPtr)
        .addFunction("IsValid", &GCAnimationGraphVisualizerSphere::IsValid)
        .endClass();
}
GMaterialParamFloat_t::GMaterialParamFloat_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GMaterialParamFloat_t::GMaterialParamFloat_t(void *ptr) {
    m_ptr = ptr;
}
float GMaterialParamFloat_t::GetValue() const {
    return GetSchemaValue<float>(m_ptr, "MaterialParamFloat_t", "m_flValue");
}
void GMaterialParamFloat_t::SetValue(float value) {
    SetSchemaValue(m_ptr, "MaterialParamFloat_t", "m_flValue", true, value);
}
std::string GMaterialParamFloat_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GMaterialParamFloat_t::IsValid() {
    return (m_ptr != nullptr);
}
GMaterialParam_t GMaterialParamFloat_t::GetParent() const {
    GMaterialParam_t value(m_ptr);
    return value;
}
void GMaterialParamFloat_t::SetParent(GMaterialParam_t value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassMaterialParamFloat_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GMaterialParamFloat_t>("MaterialParamFloat_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Value", &GMaterialParamFloat_t::GetValue, &GMaterialParamFloat_t::SetValue)
        .addProperty("Parent", &GMaterialParamFloat_t::GetParent, &GMaterialParamFloat_t::SetParent)
        .addFunction("ToPtr", &GMaterialParamFloat_t::ToPtr)
        .addFunction("IsValid", &GMaterialParamFloat_t::IsValid)
        .endClass();
}
GEventServerSimulate_t::GEventServerSimulate_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GEventServerSimulate_t::GEventServerSimulate_t(void *ptr) {
    m_ptr = ptr;
}
std::string GEventServerSimulate_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GEventServerSimulate_t::IsValid() {
    return (m_ptr != nullptr);
}
GEventSimulate_t GEventServerSimulate_t::GetParent() const {
    GEventSimulate_t value(m_ptr);
    return value;
}
void GEventServerSimulate_t::SetParent(GEventSimulate_t value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassEventServerSimulate_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GEventServerSimulate_t>("EventServerSimulate_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GEventServerSimulate_t::GetParent, &GEventServerSimulate_t::SetParent)
        .addFunction("ToPtr", &GEventServerSimulate_t::ToPtr)
        .addFunction("IsValid", &GEventServerSimulate_t::IsValid)
        .endClass();
}
GCVoiceContainerEnvelopeAnalyzer::GCVoiceContainerEnvelopeAnalyzer(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCVoiceContainerEnvelopeAnalyzer::GCVoiceContainerEnvelopeAnalyzer(void *ptr) {
    m_ptr = ptr;
}
uint64_t GCVoiceContainerEnvelopeAnalyzer::GetMode() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CVoiceContainerEnvelopeAnalyzer", "m_mode");
}
void GCVoiceContainerEnvelopeAnalyzer::SetMode(uint64_t value) {
    SetSchemaValue(m_ptr, "CVoiceContainerEnvelopeAnalyzer", "m_mode", false, value);
}
int32_t GCVoiceContainerEnvelopeAnalyzer::GetSamples() const {
    return GetSchemaValue<int32_t>(m_ptr, "CVoiceContainerEnvelopeAnalyzer", "m_nSamples");
}
void GCVoiceContainerEnvelopeAnalyzer::SetSamples(int32_t value) {
    SetSchemaValue(m_ptr, "CVoiceContainerEnvelopeAnalyzer", "m_nSamples", false, value);
}
float GCVoiceContainerEnvelopeAnalyzer::GetThreshold() const {
    return GetSchemaValue<float>(m_ptr, "CVoiceContainerEnvelopeAnalyzer", "m_flThreshold");
}
void GCVoiceContainerEnvelopeAnalyzer::SetThreshold(float value) {
    SetSchemaValue(m_ptr, "CVoiceContainerEnvelopeAnalyzer", "m_flThreshold", false, value);
}
std::string GCVoiceContainerEnvelopeAnalyzer::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCVoiceContainerEnvelopeAnalyzer::IsValid() {
    return (m_ptr != nullptr);
}
GCVoiceContainerAnalysisBase GCVoiceContainerEnvelopeAnalyzer::GetParent() const {
    GCVoiceContainerAnalysisBase value(m_ptr);
    return value;
}
void GCVoiceContainerEnvelopeAnalyzer::SetParent(GCVoiceContainerAnalysisBase value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCVoiceContainerEnvelopeAnalyzer(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCVoiceContainerEnvelopeAnalyzer>("CVoiceContainerEnvelopeAnalyzer")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Mode", &GCVoiceContainerEnvelopeAnalyzer::GetMode, &GCVoiceContainerEnvelopeAnalyzer::SetMode)
        .addProperty("Samples", &GCVoiceContainerEnvelopeAnalyzer::GetSamples, &GCVoiceContainerEnvelopeAnalyzer::SetSamples)
        .addProperty("Threshold", &GCVoiceContainerEnvelopeAnalyzer::GetThreshold, &GCVoiceContainerEnvelopeAnalyzer::SetThreshold)
        .addProperty("Parent", &GCVoiceContainerEnvelopeAnalyzer::GetParent, &GCVoiceContainerEnvelopeAnalyzer::SetParent)
        .addFunction("ToPtr", &GCVoiceContainerEnvelopeAnalyzer::ToPtr)
        .addFunction("IsValid", &GCVoiceContainerEnvelopeAnalyzer::IsValid)
        .endClass();
}
GFollowAttachmentSettings_t::GFollowAttachmentSettings_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GFollowAttachmentSettings_t::GFollowAttachmentSettings_t(void *ptr) {
    m_ptr = ptr;
}
GCAnimAttachment GFollowAttachmentSettings_t::GetAttachment() const {
    GCAnimAttachment value(GetSchemaPtr(m_ptr, "FollowAttachmentSettings_t", "m_attachment"));
    return value;
}
void GFollowAttachmentSettings_t::SetAttachment(GCAnimAttachment value) {
    SetSchemaValue(m_ptr, "FollowAttachmentSettings_t", "m_attachment", true, value);
}
int32_t GFollowAttachmentSettings_t::GetBoneIndex() const {
    return GetSchemaValue<int32_t>(m_ptr, "FollowAttachmentSettings_t", "m_boneIndex");
}
void GFollowAttachmentSettings_t::SetBoneIndex(int32_t value) {
    SetSchemaValue(m_ptr, "FollowAttachmentSettings_t", "m_boneIndex", true, value);
}
bool GFollowAttachmentSettings_t::GetMatchTranslation() const {
    return GetSchemaValue<bool>(m_ptr, "FollowAttachmentSettings_t", "m_bMatchTranslation");
}
void GFollowAttachmentSettings_t::SetMatchTranslation(bool value) {
    SetSchemaValue(m_ptr, "FollowAttachmentSettings_t", "m_bMatchTranslation", true, value);
}
bool GFollowAttachmentSettings_t::GetMatchRotation() const {
    return GetSchemaValue<bool>(m_ptr, "FollowAttachmentSettings_t", "m_bMatchRotation");
}
void GFollowAttachmentSettings_t::SetMatchRotation(bool value) {
    SetSchemaValue(m_ptr, "FollowAttachmentSettings_t", "m_bMatchRotation", true, value);
}
std::string GFollowAttachmentSettings_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GFollowAttachmentSettings_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassFollowAttachmentSettings_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GFollowAttachmentSettings_t>("FollowAttachmentSettings_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Attachment", &GFollowAttachmentSettings_t::GetAttachment, &GFollowAttachmentSettings_t::SetAttachment)
        .addProperty("BoneIndex", &GFollowAttachmentSettings_t::GetBoneIndex, &GFollowAttachmentSettings_t::SetBoneIndex)
        .addProperty("MatchTranslation", &GFollowAttachmentSettings_t::GetMatchTranslation, &GFollowAttachmentSettings_t::SetMatchTranslation)
        .addProperty("MatchRotation", &GFollowAttachmentSettings_t::GetMatchRotation, &GFollowAttachmentSettings_t::SetMatchRotation)
        .addFunction("ToPtr", &GFollowAttachmentSettings_t::ToPtr)
        .addFunction("IsValid", &GFollowAttachmentSettings_t::IsValid)
        .endClass();
}
GJiggleBoneSettings_t::GJiggleBoneSettings_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GJiggleBoneSettings_t::GJiggleBoneSettings_t(void *ptr) {
    m_ptr = ptr;
}
int32_t GJiggleBoneSettings_t::GetBoneIndex() const {
    return GetSchemaValue<int32_t>(m_ptr, "JiggleBoneSettings_t", "m_nBoneIndex");
}
void GJiggleBoneSettings_t::SetBoneIndex(int32_t value) {
    SetSchemaValue(m_ptr, "JiggleBoneSettings_t", "m_nBoneIndex", true, value);
}
float GJiggleBoneSettings_t::GetSpringStrength() const {
    return GetSchemaValue<float>(m_ptr, "JiggleBoneSettings_t", "m_flSpringStrength");
}
void GJiggleBoneSettings_t::SetSpringStrength(float value) {
    SetSchemaValue(m_ptr, "JiggleBoneSettings_t", "m_flSpringStrength", true, value);
}
float GJiggleBoneSettings_t::GetMaxTimeStep() const {
    return GetSchemaValue<float>(m_ptr, "JiggleBoneSettings_t", "m_flMaxTimeStep");
}
void GJiggleBoneSettings_t::SetMaxTimeStep(float value) {
    SetSchemaValue(m_ptr, "JiggleBoneSettings_t", "m_flMaxTimeStep", true, value);
}
float GJiggleBoneSettings_t::GetDamping() const {
    return GetSchemaValue<float>(m_ptr, "JiggleBoneSettings_t", "m_flDamping");
}
void GJiggleBoneSettings_t::SetDamping(float value) {
    SetSchemaValue(m_ptr, "JiggleBoneSettings_t", "m_flDamping", true, value);
}
Vector GJiggleBoneSettings_t::GetBoundsMaxLS() const {
    return GetSchemaValue<Vector>(m_ptr, "JiggleBoneSettings_t", "m_vBoundsMaxLS");
}
void GJiggleBoneSettings_t::SetBoundsMaxLS(Vector value) {
    SetSchemaValue(m_ptr, "JiggleBoneSettings_t", "m_vBoundsMaxLS", true, value);
}
Vector GJiggleBoneSettings_t::GetBoundsMinLS() const {
    return GetSchemaValue<Vector>(m_ptr, "JiggleBoneSettings_t", "m_vBoundsMinLS");
}
void GJiggleBoneSettings_t::SetBoundsMinLS(Vector value) {
    SetSchemaValue(m_ptr, "JiggleBoneSettings_t", "m_vBoundsMinLS", true, value);
}
uint64_t GJiggleBoneSettings_t::GetSimSpace() const {
    return GetSchemaValue<uint64_t>(m_ptr, "JiggleBoneSettings_t", "m_eSimSpace");
}
void GJiggleBoneSettings_t::SetSimSpace(uint64_t value) {
    SetSchemaValue(m_ptr, "JiggleBoneSettings_t", "m_eSimSpace", true, value);
}
std::string GJiggleBoneSettings_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GJiggleBoneSettings_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassJiggleBoneSettings_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GJiggleBoneSettings_t>("JiggleBoneSettings_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("BoneIndex", &GJiggleBoneSettings_t::GetBoneIndex, &GJiggleBoneSettings_t::SetBoneIndex)
        .addProperty("SpringStrength", &GJiggleBoneSettings_t::GetSpringStrength, &GJiggleBoneSettings_t::SetSpringStrength)
        .addProperty("MaxTimeStep", &GJiggleBoneSettings_t::GetMaxTimeStep, &GJiggleBoneSettings_t::SetMaxTimeStep)
        .addProperty("Damping", &GJiggleBoneSettings_t::GetDamping, &GJiggleBoneSettings_t::SetDamping)
        .addProperty("BoundsMaxLS", &GJiggleBoneSettings_t::GetBoundsMaxLS, &GJiggleBoneSettings_t::SetBoundsMaxLS)
        .addProperty("BoundsMinLS", &GJiggleBoneSettings_t::GetBoundsMinLS, &GJiggleBoneSettings_t::SetBoundsMinLS)
        .addProperty("SimSpace", &GJiggleBoneSettings_t::GetSimSpace, &GJiggleBoneSettings_t::SetSimSpace)
        .addFunction("ToPtr", &GJiggleBoneSettings_t::ToPtr)
        .addFunction("IsValid", &GJiggleBoneSettings_t::IsValid)
        .endClass();
}
GCAnimStateMachineUpdater::GCAnimStateMachineUpdater(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCAnimStateMachineUpdater::GCAnimStateMachineUpdater(void *ptr) {
    m_ptr = ptr;
}
std::vector<GCStateUpdateData> GCAnimStateMachineUpdater::GetStates() const {
    CUtlVector<GCStateUpdateData>* vec = GetSchemaValue<CUtlVector<GCStateUpdateData>*>(m_ptr, "CAnimStateMachineUpdater", "m_states"); std::vector<GCStateUpdateData> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCAnimStateMachineUpdater::SetStates(std::vector<GCStateUpdateData> value) {
    SetSchemaValueCUtlVector<GCStateUpdateData>(m_ptr, "CAnimStateMachineUpdater", "m_states", false, value);
}
std::vector<GCTransitionUpdateData> GCAnimStateMachineUpdater::GetTransitions() const {
    CUtlVector<GCTransitionUpdateData>* vec = GetSchemaValue<CUtlVector<GCTransitionUpdateData>*>(m_ptr, "CAnimStateMachineUpdater", "m_transitions"); std::vector<GCTransitionUpdateData> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCAnimStateMachineUpdater::SetTransitions(std::vector<GCTransitionUpdateData> value) {
    SetSchemaValueCUtlVector<GCTransitionUpdateData>(m_ptr, "CAnimStateMachineUpdater", "m_transitions", false, value);
}
int32_t GCAnimStateMachineUpdater::GetStartStateIndex() const {
    return GetSchemaValue<int32_t>(m_ptr, "CAnimStateMachineUpdater", "m_startStateIndex");
}
void GCAnimStateMachineUpdater::SetStartStateIndex(int32_t value) {
    SetSchemaValue(m_ptr, "CAnimStateMachineUpdater", "m_startStateIndex", false, value);
}
std::string GCAnimStateMachineUpdater::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCAnimStateMachineUpdater::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCAnimStateMachineUpdater(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCAnimStateMachineUpdater>("CAnimStateMachineUpdater")
        .addConstructor<void (*)(std::string)>()
        .addProperty("States", &GCAnimStateMachineUpdater::GetStates, &GCAnimStateMachineUpdater::SetStates)
        .addProperty("Transitions", &GCAnimStateMachineUpdater::GetTransitions, &GCAnimStateMachineUpdater::SetTransitions)
        .addProperty("StartStateIndex", &GCAnimStateMachineUpdater::GetStartStateIndex, &GCAnimStateMachineUpdater::SetStartStateIndex)
        .addFunction("ToPtr", &GCAnimStateMachineUpdater::ToPtr)
        .addFunction("IsValid", &GCAnimStateMachineUpdater::IsValid)
        .endClass();
}
GCNmControlParameterFloatNode::GCNmControlParameterFloatNode(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCNmControlParameterFloatNode::GCNmControlParameterFloatNode(void *ptr) {
    m_ptr = ptr;
}
std::string GCNmControlParameterFloatNode::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCNmControlParameterFloatNode::IsValid() {
    return (m_ptr != nullptr);
}
GCNmFloatValueNode GCNmControlParameterFloatNode::GetParent() const {
    GCNmFloatValueNode value(m_ptr);
    return value;
}
void GCNmControlParameterFloatNode::SetParent(GCNmFloatValueNode value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCNmControlParameterFloatNode(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCNmControlParameterFloatNode>("CNmControlParameterFloatNode")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCNmControlParameterFloatNode::GetParent, &GCNmControlParameterFloatNode::SetParent)
        .addFunction("ToPtr", &GCNmControlParameterFloatNode::ToPtr)
        .addFunction("IsValid", &GCNmControlParameterFloatNode::IsValid)
        .endClass();
}
GCSeqCmdLayer::GCSeqCmdLayer(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCSeqCmdLayer::GCSeqCmdLayer(void *ptr) {
    m_ptr = ptr;
}
int16_t GCSeqCmdLayer::GetCmd() const {
    return GetSchemaValue<int16_t>(m_ptr, "CSeqCmdLayer", "m_cmd");
}
void GCSeqCmdLayer::SetCmd(int16_t value) {
    SetSchemaValue(m_ptr, "CSeqCmdLayer", "m_cmd", false, value);
}
int16_t GCSeqCmdLayer::GetLocalReference() const {
    return GetSchemaValue<int16_t>(m_ptr, "CSeqCmdLayer", "m_nLocalReference");
}
void GCSeqCmdLayer::SetLocalReference(int16_t value) {
    SetSchemaValue(m_ptr, "CSeqCmdLayer", "m_nLocalReference", false, value);
}
int16_t GCSeqCmdLayer::GetLocalBonemask() const {
    return GetSchemaValue<int16_t>(m_ptr, "CSeqCmdLayer", "m_nLocalBonemask");
}
void GCSeqCmdLayer::SetLocalBonemask(int16_t value) {
    SetSchemaValue(m_ptr, "CSeqCmdLayer", "m_nLocalBonemask", false, value);
}
int16_t GCSeqCmdLayer::GetDstResult() const {
    return GetSchemaValue<int16_t>(m_ptr, "CSeqCmdLayer", "m_nDstResult");
}
void GCSeqCmdLayer::SetDstResult(int16_t value) {
    SetSchemaValue(m_ptr, "CSeqCmdLayer", "m_nDstResult", false, value);
}
int16_t GCSeqCmdLayer::GetSrcResult() const {
    return GetSchemaValue<int16_t>(m_ptr, "CSeqCmdLayer", "m_nSrcResult");
}
void GCSeqCmdLayer::SetSrcResult(int16_t value) {
    SetSchemaValue(m_ptr, "CSeqCmdLayer", "m_nSrcResult", false, value);
}
bool GCSeqCmdLayer::GetSpline() const {
    return GetSchemaValue<bool>(m_ptr, "CSeqCmdLayer", "m_bSpline");
}
void GCSeqCmdLayer::SetSpline(bool value) {
    SetSchemaValue(m_ptr, "CSeqCmdLayer", "m_bSpline", false, value);
}
float GCSeqCmdLayer::GetVar1() const {
    return GetSchemaValue<float>(m_ptr, "CSeqCmdLayer", "m_flVar1");
}
void GCSeqCmdLayer::SetVar1(float value) {
    SetSchemaValue(m_ptr, "CSeqCmdLayer", "m_flVar1", false, value);
}
float GCSeqCmdLayer::GetVar2() const {
    return GetSchemaValue<float>(m_ptr, "CSeqCmdLayer", "m_flVar2");
}
void GCSeqCmdLayer::SetVar2(float value) {
    SetSchemaValue(m_ptr, "CSeqCmdLayer", "m_flVar2", false, value);
}
int16_t GCSeqCmdLayer::GetLineNumber() const {
    return GetSchemaValue<int16_t>(m_ptr, "CSeqCmdLayer", "m_nLineNumber");
}
void GCSeqCmdLayer::SetLineNumber(int16_t value) {
    SetSchemaValue(m_ptr, "CSeqCmdLayer", "m_nLineNumber", false, value);
}
std::string GCSeqCmdLayer::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCSeqCmdLayer::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCSeqCmdLayer(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCSeqCmdLayer>("CSeqCmdLayer")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Cmd", &GCSeqCmdLayer::GetCmd, &GCSeqCmdLayer::SetCmd)
        .addProperty("LocalReference", &GCSeqCmdLayer::GetLocalReference, &GCSeqCmdLayer::SetLocalReference)
        .addProperty("LocalBonemask", &GCSeqCmdLayer::GetLocalBonemask, &GCSeqCmdLayer::SetLocalBonemask)
        .addProperty("DstResult", &GCSeqCmdLayer::GetDstResult, &GCSeqCmdLayer::SetDstResult)
        .addProperty("SrcResult", &GCSeqCmdLayer::GetSrcResult, &GCSeqCmdLayer::SetSrcResult)
        .addProperty("Spline", &GCSeqCmdLayer::GetSpline, &GCSeqCmdLayer::SetSpline)
        .addProperty("Var1", &GCSeqCmdLayer::GetVar1, &GCSeqCmdLayer::SetVar1)
        .addProperty("Var2", &GCSeqCmdLayer::GetVar2, &GCSeqCmdLayer::SetVar2)
        .addProperty("LineNumber", &GCSeqCmdLayer::GetLineNumber, &GCSeqCmdLayer::SetLineNumber)
        .addFunction("ToPtr", &GCSeqCmdLayer::ToPtr)
        .addFunction("IsValid", &GCSeqCmdLayer::IsValid)
        .endClass();
}
GCAnimScriptComponentUpdater::GCAnimScriptComponentUpdater(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCAnimScriptComponentUpdater::GCAnimScriptComponentUpdater(void *ptr) {
    m_ptr = ptr;
}
GAnimScriptHandle GCAnimScriptComponentUpdater::GetScript() const {
    GAnimScriptHandle value(GetSchemaPtr(m_ptr, "CAnimScriptComponentUpdater", "m_hScript"));
    return value;
}
void GCAnimScriptComponentUpdater::SetScript(GAnimScriptHandle value) {
    SetSchemaValue(m_ptr, "CAnimScriptComponentUpdater", "m_hScript", false, value);
}
std::string GCAnimScriptComponentUpdater::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCAnimScriptComponentUpdater::IsValid() {
    return (m_ptr != nullptr);
}
GCAnimComponentUpdater GCAnimScriptComponentUpdater::GetParent() const {
    GCAnimComponentUpdater value(m_ptr);
    return value;
}
void GCAnimScriptComponentUpdater::SetParent(GCAnimComponentUpdater value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCAnimScriptComponentUpdater(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCAnimScriptComponentUpdater>("CAnimScriptComponentUpdater")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Script", &GCAnimScriptComponentUpdater::GetScript, &GCAnimScriptComponentUpdater::SetScript)
        .addProperty("Parent", &GCAnimScriptComponentUpdater::GetParent, &GCAnimScriptComponentUpdater::SetParent)
        .addFunction("ToPtr", &GCAnimScriptComponentUpdater::ToPtr)
        .addFunction("IsValid", &GCAnimScriptComponentUpdater::IsValid)
        .endClass();
}
GFeRigidColliderIndices_t::GFeRigidColliderIndices_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GFeRigidColliderIndices_t::GFeRigidColliderIndices_t(void *ptr) {
    m_ptr = ptr;
}
uint16_t GFeRigidColliderIndices_t::GetTaperedCapsuleRigidIndex() const {
    return GetSchemaValue<uint16_t>(m_ptr, "FeRigidColliderIndices_t", "m_nTaperedCapsuleRigidIndex");
}
void GFeRigidColliderIndices_t::SetTaperedCapsuleRigidIndex(uint16_t value) {
    SetSchemaValue(m_ptr, "FeRigidColliderIndices_t", "m_nTaperedCapsuleRigidIndex", true, value);
}
uint16_t GFeRigidColliderIndices_t::GetSphereRigidIndex() const {
    return GetSchemaValue<uint16_t>(m_ptr, "FeRigidColliderIndices_t", "m_nSphereRigidIndex");
}
void GFeRigidColliderIndices_t::SetSphereRigidIndex(uint16_t value) {
    SetSchemaValue(m_ptr, "FeRigidColliderIndices_t", "m_nSphereRigidIndex", true, value);
}
uint16_t GFeRigidColliderIndices_t::GetBoxRigidIndex() const {
    return GetSchemaValue<uint16_t>(m_ptr, "FeRigidColliderIndices_t", "m_nBoxRigidIndex");
}
void GFeRigidColliderIndices_t::SetBoxRigidIndex(uint16_t value) {
    SetSchemaValue(m_ptr, "FeRigidColliderIndices_t", "m_nBoxRigidIndex", true, value);
}
uint16_t GFeRigidColliderIndices_t::GetCollisionPlaneIndex() const {
    return GetSchemaValue<uint16_t>(m_ptr, "FeRigidColliderIndices_t", "m_nCollisionPlaneIndex");
}
void GFeRigidColliderIndices_t::SetCollisionPlaneIndex(uint16_t value) {
    SetSchemaValue(m_ptr, "FeRigidColliderIndices_t", "m_nCollisionPlaneIndex", true, value);
}
std::string GFeRigidColliderIndices_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GFeRigidColliderIndices_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassFeRigidColliderIndices_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GFeRigidColliderIndices_t>("FeRigidColliderIndices_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("TaperedCapsuleRigidIndex", &GFeRigidColliderIndices_t::GetTaperedCapsuleRigidIndex, &GFeRigidColliderIndices_t::SetTaperedCapsuleRigidIndex)
        .addProperty("SphereRigidIndex", &GFeRigidColliderIndices_t::GetSphereRigidIndex, &GFeRigidColliderIndices_t::SetSphereRigidIndex)
        .addProperty("BoxRigidIndex", &GFeRigidColliderIndices_t::GetBoxRigidIndex, &GFeRigidColliderIndices_t::SetBoxRigidIndex)
        .addProperty("CollisionPlaneIndex", &GFeRigidColliderIndices_t::GetCollisionPlaneIndex, &GFeRigidColliderIndices_t::SetCollisionPlaneIndex)
        .addFunction("ToPtr", &GFeRigidColliderIndices_t::ToPtr)
        .addFunction("IsValid", &GFeRigidColliderIndices_t::IsValid)
        .endClass();
}
GCSeqAutoLayer::GCSeqAutoLayer(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCSeqAutoLayer::GCSeqAutoLayer(void *ptr) {
    m_ptr = ptr;
}
int16_t GCSeqAutoLayer::GetLocalReference() const {
    return GetSchemaValue<int16_t>(m_ptr, "CSeqAutoLayer", "m_nLocalReference");
}
void GCSeqAutoLayer::SetLocalReference(int16_t value) {
    SetSchemaValue(m_ptr, "CSeqAutoLayer", "m_nLocalReference", false, value);
}
int16_t GCSeqAutoLayer::GetLocalPose() const {
    return GetSchemaValue<int16_t>(m_ptr, "CSeqAutoLayer", "m_nLocalPose");
}
void GCSeqAutoLayer::SetLocalPose(int16_t value) {
    SetSchemaValue(m_ptr, "CSeqAutoLayer", "m_nLocalPose", false, value);
}
GCSeqAutoLayerFlag GCSeqAutoLayer::GetFlags() const {
    GCSeqAutoLayerFlag value(GetSchemaPtr(m_ptr, "CSeqAutoLayer", "m_flags"));
    return value;
}
void GCSeqAutoLayer::SetFlags(GCSeqAutoLayerFlag value) {
    SetSchemaValue(m_ptr, "CSeqAutoLayer", "m_flags", false, value);
}
float GCSeqAutoLayer::GetStart() const {
    return GetSchemaValue<float>(m_ptr, "CSeqAutoLayer", "m_start");
}
void GCSeqAutoLayer::SetStart(float value) {
    SetSchemaValue(m_ptr, "CSeqAutoLayer", "m_start", false, value);
}
float GCSeqAutoLayer::GetPeak() const {
    return GetSchemaValue<float>(m_ptr, "CSeqAutoLayer", "m_peak");
}
void GCSeqAutoLayer::SetPeak(float value) {
    SetSchemaValue(m_ptr, "CSeqAutoLayer", "m_peak", false, value);
}
float GCSeqAutoLayer::GetTail() const {
    return GetSchemaValue<float>(m_ptr, "CSeqAutoLayer", "m_tail");
}
void GCSeqAutoLayer::SetTail(float value) {
    SetSchemaValue(m_ptr, "CSeqAutoLayer", "m_tail", false, value);
}
float GCSeqAutoLayer::GetEnd() const {
    return GetSchemaValue<float>(m_ptr, "CSeqAutoLayer", "m_end");
}
void GCSeqAutoLayer::SetEnd(float value) {
    SetSchemaValue(m_ptr, "CSeqAutoLayer", "m_end", false, value);
}
std::string GCSeqAutoLayer::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCSeqAutoLayer::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCSeqAutoLayer(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCSeqAutoLayer>("CSeqAutoLayer")
        .addConstructor<void (*)(std::string)>()
        .addProperty("LocalReference", &GCSeqAutoLayer::GetLocalReference, &GCSeqAutoLayer::SetLocalReference)
        .addProperty("LocalPose", &GCSeqAutoLayer::GetLocalPose, &GCSeqAutoLayer::SetLocalPose)
        .addProperty("Flags", &GCSeqAutoLayer::GetFlags, &GCSeqAutoLayer::SetFlags)
        .addProperty("Start", &GCSeqAutoLayer::GetStart, &GCSeqAutoLayer::SetStart)
        .addProperty("Peak", &GCSeqAutoLayer::GetPeak, &GCSeqAutoLayer::SetPeak)
        .addProperty("Tail", &GCSeqAutoLayer::GetTail, &GCSeqAutoLayer::SetTail)
        .addProperty("End", &GCSeqAutoLayer::GetEnd, &GCSeqAutoLayer::SetEnd)
        .addFunction("ToPtr", &GCSeqAutoLayer::ToPtr)
        .addFunction("IsValid", &GCSeqAutoLayer::IsValid)
        .endClass();
}
GBakedLightingInfo_t::GBakedLightingInfo_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GBakedLightingInfo_t::GBakedLightingInfo_t(void *ptr) {
    m_ptr = ptr;
}
uint32_t GBakedLightingInfo_t::GetLightmapVersionNumber() const {
    return GetSchemaValue<uint32_t>(m_ptr, "BakedLightingInfo_t", "m_nLightmapVersionNumber");
}
void GBakedLightingInfo_t::SetLightmapVersionNumber(uint32_t value) {
    SetSchemaValue(m_ptr, "BakedLightingInfo_t", "m_nLightmapVersionNumber", true, value);
}
uint32_t GBakedLightingInfo_t::GetLightmapGameVersionNumber() const {
    return GetSchemaValue<uint32_t>(m_ptr, "BakedLightingInfo_t", "m_nLightmapGameVersionNumber");
}
void GBakedLightingInfo_t::SetLightmapGameVersionNumber(uint32_t value) {
    SetSchemaValue(m_ptr, "BakedLightingInfo_t", "m_nLightmapGameVersionNumber", true, value);
}
Vector2D GBakedLightingInfo_t::GetLightmapUvScale() const {
    return GetSchemaValue<Vector2D>(m_ptr, "BakedLightingInfo_t", "m_vLightmapUvScale");
}
void GBakedLightingInfo_t::SetLightmapUvScale(Vector2D value) {
    SetSchemaValue(m_ptr, "BakedLightingInfo_t", "m_vLightmapUvScale", true, value);
}
bool GBakedLightingInfo_t::GetHasLightmaps() const {
    return GetSchemaValue<bool>(m_ptr, "BakedLightingInfo_t", "m_bHasLightmaps");
}
void GBakedLightingInfo_t::SetHasLightmaps(bool value) {
    SetSchemaValue(m_ptr, "BakedLightingInfo_t", "m_bHasLightmaps", true, value);
}
bool GBakedLightingInfo_t::GetBakedShadowsGamma20() const {
    return GetSchemaValue<bool>(m_ptr, "BakedLightingInfo_t", "m_bBakedShadowsGamma20");
}
void GBakedLightingInfo_t::SetBakedShadowsGamma20(bool value) {
    SetSchemaValue(m_ptr, "BakedLightingInfo_t", "m_bBakedShadowsGamma20", true, value);
}
bool GBakedLightingInfo_t::GetCompressionEnabled() const {
    return GetSchemaValue<bool>(m_ptr, "BakedLightingInfo_t", "m_bCompressionEnabled");
}
void GBakedLightingInfo_t::SetCompressionEnabled(bool value) {
    SetSchemaValue(m_ptr, "BakedLightingInfo_t", "m_bCompressionEnabled", true, value);
}
uint8_t GBakedLightingInfo_t::GetChartPackIterations() const {
    return GetSchemaValue<uint8_t>(m_ptr, "BakedLightingInfo_t", "m_nChartPackIterations");
}
void GBakedLightingInfo_t::SetChartPackIterations(uint8_t value) {
    SetSchemaValue(m_ptr, "BakedLightingInfo_t", "m_nChartPackIterations", true, value);
}
uint8_t GBakedLightingInfo_t::GetVradQuality() const {
    return GetSchemaValue<uint8_t>(m_ptr, "BakedLightingInfo_t", "m_nVradQuality");
}
void GBakedLightingInfo_t::SetVradQuality(uint8_t value) {
    SetSchemaValue(m_ptr, "BakedLightingInfo_t", "m_nVradQuality", true, value);
}
std::string GBakedLightingInfo_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GBakedLightingInfo_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassBakedLightingInfo_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GBakedLightingInfo_t>("BakedLightingInfo_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("LightmapVersionNumber", &GBakedLightingInfo_t::GetLightmapVersionNumber, &GBakedLightingInfo_t::SetLightmapVersionNumber)
        .addProperty("LightmapGameVersionNumber", &GBakedLightingInfo_t::GetLightmapGameVersionNumber, &GBakedLightingInfo_t::SetLightmapGameVersionNumber)
        .addProperty("LightmapUvScale", &GBakedLightingInfo_t::GetLightmapUvScale, &GBakedLightingInfo_t::SetLightmapUvScale)
        .addProperty("HasLightmaps", &GBakedLightingInfo_t::GetHasLightmaps, &GBakedLightingInfo_t::SetHasLightmaps)
        .addProperty("BakedShadowsGamma20", &GBakedLightingInfo_t::GetBakedShadowsGamma20, &GBakedLightingInfo_t::SetBakedShadowsGamma20)
        .addProperty("CompressionEnabled", &GBakedLightingInfo_t::GetCompressionEnabled, &GBakedLightingInfo_t::SetCompressionEnabled)
        .addProperty("ChartPackIterations", &GBakedLightingInfo_t::GetChartPackIterations, &GBakedLightingInfo_t::SetChartPackIterations)
        .addProperty("VradQuality", &GBakedLightingInfo_t::GetVradQuality, &GBakedLightingInfo_t::SetVradQuality)
        .addFunction("ToPtr", &GBakedLightingInfo_t::ToPtr)
        .addFunction("IsValid", &GBakedLightingInfo_t::IsValid)
        .endClass();
}
GCExampleSchemaVData_PolymorphicBase::GCExampleSchemaVData_PolymorphicBase(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCExampleSchemaVData_PolymorphicBase::GCExampleSchemaVData_PolymorphicBase(void *ptr) {
    m_ptr = ptr;
}
int32_t GCExampleSchemaVData_PolymorphicBase::GetBase() const {
    return GetSchemaValue<int32_t>(m_ptr, "CExampleSchemaVData_PolymorphicBase", "m_nBase");
}
void GCExampleSchemaVData_PolymorphicBase::SetBase(int32_t value) {
    SetSchemaValue(m_ptr, "CExampleSchemaVData_PolymorphicBase", "m_nBase", false, value);
}
std::string GCExampleSchemaVData_PolymorphicBase::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCExampleSchemaVData_PolymorphicBase::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCExampleSchemaVData_PolymorphicBase(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCExampleSchemaVData_PolymorphicBase>("CExampleSchemaVData_PolymorphicBase")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Base", &GCExampleSchemaVData_PolymorphicBase::GetBase, &GCExampleSchemaVData_PolymorphicBase::SetBase)
        .addFunction("ToPtr", &GCExampleSchemaVData_PolymorphicBase::ToPtr)
        .addFunction("IsValid", &GCExampleSchemaVData_PolymorphicBase::IsValid)
        .endClass();
}
GFourVectors2D::GFourVectors2D(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GFourVectors2D::GFourVectors2D(void *ptr) {
    m_ptr = ptr;
}
float GFourVectors2D::GetX() const {
    return GetSchemaValue<float>(m_ptr, "FourVectors2D", "x");
}
void GFourVectors2D::SetX(float value) {
    SetSchemaValue(m_ptr, "FourVectors2D", "x", false, value);
}
float GFourVectors2D::GetY() const {
    return GetSchemaValue<float>(m_ptr, "FourVectors2D", "y");
}
void GFourVectors2D::SetY(float value) {
    SetSchemaValue(m_ptr, "FourVectors2D", "y", false, value);
}
std::string GFourVectors2D::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GFourVectors2D::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassFourVectors2D(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GFourVectors2D>("FourVectors2D")
        .addConstructor<void (*)(std::string)>()
        .addProperty("X", &GFourVectors2D::GetX, &GFourVectors2D::SetX)
        .addProperty("Y", &GFourVectors2D::GetY, &GFourVectors2D::SetY)
        .addFunction("ToPtr", &GFourVectors2D::ToPtr)
        .addFunction("IsValid", &GFourVectors2D::IsValid)
        .endClass();
}
GCOrientConstraint::GCOrientConstraint(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCOrientConstraint::GCOrientConstraint(void *ptr) {
    m_ptr = ptr;
}
std::string GCOrientConstraint::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCOrientConstraint::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseConstraint GCOrientConstraint::GetParent() const {
    GCBaseConstraint value(m_ptr);
    return value;
}
void GCOrientConstraint::SetParent(GCBaseConstraint value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCOrientConstraint(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCOrientConstraint>("COrientConstraint")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCOrientConstraint::GetParent, &GCOrientConstraint::SetParent)
        .addFunction("ToPtr", &GCOrientConstraint::ToPtr)
        .addFunction("IsValid", &GCOrientConstraint::IsValid)
        .endClass();
}
GSequenceWeightedList_t::GSequenceWeightedList_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GSequenceWeightedList_t::GSequenceWeightedList_t(void *ptr) {
    m_ptr = ptr;
}
int32_t GSequenceWeightedList_t::GetSequence() const {
    return GetSchemaValue<int32_t>(m_ptr, "SequenceWeightedList_t", "m_nSequence");
}
void GSequenceWeightedList_t::SetSequence(int32_t value) {
    SetSchemaValue(m_ptr, "SequenceWeightedList_t", "m_nSequence", true, value);
}
float GSequenceWeightedList_t::GetRelativeWeight() const {
    return GetSchemaValue<float>(m_ptr, "SequenceWeightedList_t", "m_flRelativeWeight");
}
void GSequenceWeightedList_t::SetRelativeWeight(float value) {
    SetSchemaValue(m_ptr, "SequenceWeightedList_t", "m_flRelativeWeight", true, value);
}
std::string GSequenceWeightedList_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GSequenceWeightedList_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassSequenceWeightedList_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GSequenceWeightedList_t>("SequenceWeightedList_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Sequence", &GSequenceWeightedList_t::GetSequence, &GSequenceWeightedList_t::SetSequence)
        .addProperty("RelativeWeight", &GSequenceWeightedList_t::GetRelativeWeight, &GSequenceWeightedList_t::SetRelativeWeight)
        .addFunction("ToPtr", &GSequenceWeightedList_t::ToPtr)
        .addFunction("IsValid", &GSequenceWeightedList_t::IsValid)
        .endClass();
}
GCSosGroupActionMemberCountEnvelopeSchema::GCSosGroupActionMemberCountEnvelopeSchema(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCSosGroupActionMemberCountEnvelopeSchema::GCSosGroupActionMemberCountEnvelopeSchema(void *ptr) {
    m_ptr = ptr;
}
int32_t GCSosGroupActionMemberCountEnvelopeSchema::GetBaseCount() const {
    return GetSchemaValue<int32_t>(m_ptr, "CSosGroupActionMemberCountEnvelopeSchema", "m_nBaseCount");
}
void GCSosGroupActionMemberCountEnvelopeSchema::SetBaseCount(int32_t value) {
    SetSchemaValue(m_ptr, "CSosGroupActionMemberCountEnvelopeSchema", "m_nBaseCount", false, value);
}
int32_t GCSosGroupActionMemberCountEnvelopeSchema::GetTargetCount() const {
    return GetSchemaValue<int32_t>(m_ptr, "CSosGroupActionMemberCountEnvelopeSchema", "m_nTargetCount");
}
void GCSosGroupActionMemberCountEnvelopeSchema::SetTargetCount(int32_t value) {
    SetSchemaValue(m_ptr, "CSosGroupActionMemberCountEnvelopeSchema", "m_nTargetCount", false, value);
}
float GCSosGroupActionMemberCountEnvelopeSchema::GetBaseValue() const {
    return GetSchemaValue<float>(m_ptr, "CSosGroupActionMemberCountEnvelopeSchema", "m_flBaseValue");
}
void GCSosGroupActionMemberCountEnvelopeSchema::SetBaseValue(float value) {
    SetSchemaValue(m_ptr, "CSosGroupActionMemberCountEnvelopeSchema", "m_flBaseValue", false, value);
}
float GCSosGroupActionMemberCountEnvelopeSchema::GetTargetValue() const {
    return GetSchemaValue<float>(m_ptr, "CSosGroupActionMemberCountEnvelopeSchema", "m_flTargetValue");
}
void GCSosGroupActionMemberCountEnvelopeSchema::SetTargetValue(float value) {
    SetSchemaValue(m_ptr, "CSosGroupActionMemberCountEnvelopeSchema", "m_flTargetValue", false, value);
}
float GCSosGroupActionMemberCountEnvelopeSchema::GetAttack() const {
    return GetSchemaValue<float>(m_ptr, "CSosGroupActionMemberCountEnvelopeSchema", "m_flAttack");
}
void GCSosGroupActionMemberCountEnvelopeSchema::SetAttack(float value) {
    SetSchemaValue(m_ptr, "CSosGroupActionMemberCountEnvelopeSchema", "m_flAttack", false, value);
}
float GCSosGroupActionMemberCountEnvelopeSchema::GetDecay() const {
    return GetSchemaValue<float>(m_ptr, "CSosGroupActionMemberCountEnvelopeSchema", "m_flDecay");
}
void GCSosGroupActionMemberCountEnvelopeSchema::SetDecay(float value) {
    SetSchemaValue(m_ptr, "CSosGroupActionMemberCountEnvelopeSchema", "m_flDecay", false, value);
}
std::string GCSosGroupActionMemberCountEnvelopeSchema::GetResultVarName() const {
    return GetSchemaValue<CUtlString>(m_ptr, "CSosGroupActionMemberCountEnvelopeSchema", "m_resultVarName").Get();
}
void GCSosGroupActionMemberCountEnvelopeSchema::SetResultVarName(std::string value) {
    SetSchemaValue(m_ptr, "CSosGroupActionMemberCountEnvelopeSchema", "m_resultVarName", false, CUtlString(value.c_str()));
}
bool GCSosGroupActionMemberCountEnvelopeSchema::GetSaveToGroup() const {
    return GetSchemaValue<bool>(m_ptr, "CSosGroupActionMemberCountEnvelopeSchema", "m_bSaveToGroup");
}
void GCSosGroupActionMemberCountEnvelopeSchema::SetSaveToGroup(bool value) {
    SetSchemaValue(m_ptr, "CSosGroupActionMemberCountEnvelopeSchema", "m_bSaveToGroup", false, value);
}
std::string GCSosGroupActionMemberCountEnvelopeSchema::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCSosGroupActionMemberCountEnvelopeSchema::IsValid() {
    return (m_ptr != nullptr);
}
GCSosGroupActionSchema GCSosGroupActionMemberCountEnvelopeSchema::GetParent() const {
    GCSosGroupActionSchema value(m_ptr);
    return value;
}
void GCSosGroupActionMemberCountEnvelopeSchema::SetParent(GCSosGroupActionSchema value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCSosGroupActionMemberCountEnvelopeSchema(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCSosGroupActionMemberCountEnvelopeSchema>("CSosGroupActionMemberCountEnvelopeSchema")
        .addConstructor<void (*)(std::string)>()
        .addProperty("BaseCount", &GCSosGroupActionMemberCountEnvelopeSchema::GetBaseCount, &GCSosGroupActionMemberCountEnvelopeSchema::SetBaseCount)
        .addProperty("TargetCount", &GCSosGroupActionMemberCountEnvelopeSchema::GetTargetCount, &GCSosGroupActionMemberCountEnvelopeSchema::SetTargetCount)
        .addProperty("BaseValue", &GCSosGroupActionMemberCountEnvelopeSchema::GetBaseValue, &GCSosGroupActionMemberCountEnvelopeSchema::SetBaseValue)
        .addProperty("TargetValue", &GCSosGroupActionMemberCountEnvelopeSchema::GetTargetValue, &GCSosGroupActionMemberCountEnvelopeSchema::SetTargetValue)
        .addProperty("Attack", &GCSosGroupActionMemberCountEnvelopeSchema::GetAttack, &GCSosGroupActionMemberCountEnvelopeSchema::SetAttack)
        .addProperty("Decay", &GCSosGroupActionMemberCountEnvelopeSchema::GetDecay, &GCSosGroupActionMemberCountEnvelopeSchema::SetDecay)
        .addProperty("ResultVarName", &GCSosGroupActionMemberCountEnvelopeSchema::GetResultVarName, &GCSosGroupActionMemberCountEnvelopeSchema::SetResultVarName)
        .addProperty("SaveToGroup", &GCSosGroupActionMemberCountEnvelopeSchema::GetSaveToGroup, &GCSosGroupActionMemberCountEnvelopeSchema::SetSaveToGroup)
        .addProperty("Parent", &GCSosGroupActionMemberCountEnvelopeSchema::GetParent, &GCSosGroupActionMemberCountEnvelopeSchema::SetParent)
        .addFunction("ToPtr", &GCSosGroupActionMemberCountEnvelopeSchema::ToPtr)
        .addFunction("IsValid", &GCSosGroupActionMemberCountEnvelopeSchema::IsValid)
        .endClass();
}
GFeRodConstraint_t::GFeRodConstraint_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GFeRodConstraint_t::GFeRodConstraint_t(void *ptr) {
    m_ptr = ptr;
}
std::vector<uint16_t> GFeRodConstraint_t::GetNode() const {
    uint16_t* outValue = GetSchemaValue<uint16_t*>(m_ptr, "FeRodConstraint_t", "nNode"); std::vector<uint16_t> ret; for(int i = 0; i < 2; i++) { ret.push_back(outValue[i]); } return ret;
}
void GFeRodConstraint_t::SetNode(std::vector<uint16_t> value) {
    uint16_t* outValue = GetSchemaValue<uint16_t*>(m_ptr, "FeRodConstraint_t", "nNode"); for(int i = 0; i < 2; i++) { outValue[i] = value[i]; } SetSchemaValue(m_ptr, "FeRodConstraint_t", "nNode", true, outValue);
}
float GFeRodConstraint_t::GetMaxDist() const {
    return GetSchemaValue<float>(m_ptr, "FeRodConstraint_t", "flMaxDist");
}
void GFeRodConstraint_t::SetMaxDist(float value) {
    SetSchemaValue(m_ptr, "FeRodConstraint_t", "flMaxDist", true, value);
}
float GFeRodConstraint_t::GetMinDist() const {
    return GetSchemaValue<float>(m_ptr, "FeRodConstraint_t", "flMinDist");
}
void GFeRodConstraint_t::SetMinDist(float value) {
    SetSchemaValue(m_ptr, "FeRodConstraint_t", "flMinDist", true, value);
}
float GFeRodConstraint_t::GetWeight0() const {
    return GetSchemaValue<float>(m_ptr, "FeRodConstraint_t", "flWeight0");
}
void GFeRodConstraint_t::SetWeight0(float value) {
    SetSchemaValue(m_ptr, "FeRodConstraint_t", "flWeight0", true, value);
}
float GFeRodConstraint_t::GetRelaxationFactor() const {
    return GetSchemaValue<float>(m_ptr, "FeRodConstraint_t", "flRelaxationFactor");
}
void GFeRodConstraint_t::SetRelaxationFactor(float value) {
    SetSchemaValue(m_ptr, "FeRodConstraint_t", "flRelaxationFactor", true, value);
}
std::string GFeRodConstraint_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GFeRodConstraint_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassFeRodConstraint_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GFeRodConstraint_t>("FeRodConstraint_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Node", &GFeRodConstraint_t::GetNode, &GFeRodConstraint_t::SetNode)
        .addProperty("MaxDist", &GFeRodConstraint_t::GetMaxDist, &GFeRodConstraint_t::SetMaxDist)
        .addProperty("MinDist", &GFeRodConstraint_t::GetMinDist, &GFeRodConstraint_t::SetMinDist)
        .addProperty("Weight0", &GFeRodConstraint_t::GetWeight0, &GFeRodConstraint_t::SetWeight0)
        .addProperty("RelaxationFactor", &GFeRodConstraint_t::GetRelaxationFactor, &GFeRodConstraint_t::SetRelaxationFactor)
        .addFunction("ToPtr", &GFeRodConstraint_t::ToPtr)
        .addFunction("IsValid", &GFeRodConstraint_t::IsValid)
        .endClass();
}
GFollowTargetOpFixedSettings_t::GFollowTargetOpFixedSettings_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GFollowTargetOpFixedSettings_t::GFollowTargetOpFixedSettings_t(void *ptr) {
    m_ptr = ptr;
}
int32_t GFollowTargetOpFixedSettings_t::GetBoneIndex() const {
    return GetSchemaValue<int32_t>(m_ptr, "FollowTargetOpFixedSettings_t", "m_boneIndex");
}
void GFollowTargetOpFixedSettings_t::SetBoneIndex(int32_t value) {
    SetSchemaValue(m_ptr, "FollowTargetOpFixedSettings_t", "m_boneIndex", true, value);
}
bool GFollowTargetOpFixedSettings_t::GetBoneTarget() const {
    return GetSchemaValue<bool>(m_ptr, "FollowTargetOpFixedSettings_t", "m_bBoneTarget");
}
void GFollowTargetOpFixedSettings_t::SetBoneTarget(bool value) {
    SetSchemaValue(m_ptr, "FollowTargetOpFixedSettings_t", "m_bBoneTarget", true, value);
}
int32_t GFollowTargetOpFixedSettings_t::GetBoneTargetIndex() const {
    return GetSchemaValue<int32_t>(m_ptr, "FollowTargetOpFixedSettings_t", "m_boneTargetIndex");
}
void GFollowTargetOpFixedSettings_t::SetBoneTargetIndex(int32_t value) {
    SetSchemaValue(m_ptr, "FollowTargetOpFixedSettings_t", "m_boneTargetIndex", true, value);
}
bool GFollowTargetOpFixedSettings_t::GetWorldCoodinateTarget() const {
    return GetSchemaValue<bool>(m_ptr, "FollowTargetOpFixedSettings_t", "m_bWorldCoodinateTarget");
}
void GFollowTargetOpFixedSettings_t::SetWorldCoodinateTarget(bool value) {
    SetSchemaValue(m_ptr, "FollowTargetOpFixedSettings_t", "m_bWorldCoodinateTarget", true, value);
}
bool GFollowTargetOpFixedSettings_t::GetMatchTargetOrientation() const {
    return GetSchemaValue<bool>(m_ptr, "FollowTargetOpFixedSettings_t", "m_bMatchTargetOrientation");
}
void GFollowTargetOpFixedSettings_t::SetMatchTargetOrientation(bool value) {
    SetSchemaValue(m_ptr, "FollowTargetOpFixedSettings_t", "m_bMatchTargetOrientation", true, value);
}
std::string GFollowTargetOpFixedSettings_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GFollowTargetOpFixedSettings_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassFollowTargetOpFixedSettings_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GFollowTargetOpFixedSettings_t>("FollowTargetOpFixedSettings_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("BoneIndex", &GFollowTargetOpFixedSettings_t::GetBoneIndex, &GFollowTargetOpFixedSettings_t::SetBoneIndex)
        .addProperty("BoneTarget", &GFollowTargetOpFixedSettings_t::GetBoneTarget, &GFollowTargetOpFixedSettings_t::SetBoneTarget)
        .addProperty("BoneTargetIndex", &GFollowTargetOpFixedSettings_t::GetBoneTargetIndex, &GFollowTargetOpFixedSettings_t::SetBoneTargetIndex)
        .addProperty("WorldCoodinateTarget", &GFollowTargetOpFixedSettings_t::GetWorldCoodinateTarget, &GFollowTargetOpFixedSettings_t::SetWorldCoodinateTarget)
        .addProperty("MatchTargetOrientation", &GFollowTargetOpFixedSettings_t::GetMatchTargetOrientation, &GFollowTargetOpFixedSettings_t::SetMatchTargetOrientation)
        .addFunction("ToPtr", &GFollowTargetOpFixedSettings_t::ToPtr)
        .addFunction("IsValid", &GFollowTargetOpFixedSettings_t::IsValid)
        .endClass();
}
GCRenderSkeleton::GCRenderSkeleton(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCRenderSkeleton::GCRenderSkeleton(void *ptr) {
    m_ptr = ptr;
}
std::vector<GRenderSkeletonBone_t> GCRenderSkeleton::GetBones() const {
    CUtlVector<GRenderSkeletonBone_t>* vec = GetSchemaValue<CUtlVector<GRenderSkeletonBone_t>*>(m_ptr, "CRenderSkeleton", "m_bones"); std::vector<GRenderSkeletonBone_t> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCRenderSkeleton::SetBones(std::vector<GRenderSkeletonBone_t> value) {
    SetSchemaValueCUtlVector<GRenderSkeletonBone_t>(m_ptr, "CRenderSkeleton", "m_bones", false, value);
}
std::vector<int32> GCRenderSkeleton::GetBoneParents() const {
    CUtlVector<int32>* vec = GetSchemaValue<CUtlVector<int32>*>(m_ptr, "CRenderSkeleton", "m_boneParents"); std::vector<int32> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCRenderSkeleton::SetBoneParents(std::vector<int32> value) {
    SetSchemaValueCUtlVector<int32>(m_ptr, "CRenderSkeleton", "m_boneParents", false, value);
}
int32_t GCRenderSkeleton::GetBoneWeightCount() const {
    return GetSchemaValue<int32_t>(m_ptr, "CRenderSkeleton", "m_nBoneWeightCount");
}
void GCRenderSkeleton::SetBoneWeightCount(int32_t value) {
    SetSchemaValue(m_ptr, "CRenderSkeleton", "m_nBoneWeightCount", false, value);
}
std::string GCRenderSkeleton::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCRenderSkeleton::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCRenderSkeleton(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCRenderSkeleton>("CRenderSkeleton")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Bones", &GCRenderSkeleton::GetBones, &GCRenderSkeleton::SetBones)
        .addProperty("BoneParents", &GCRenderSkeleton::GetBoneParents, &GCRenderSkeleton::SetBoneParents)
        .addProperty("BoneWeightCount", &GCRenderSkeleton::GetBoneWeightCount, &GCRenderSkeleton::SetBoneWeightCount)
        .addFunction("ToPtr", &GCRenderSkeleton::ToPtr)
        .addFunction("IsValid", &GCRenderSkeleton::IsValid)
        .endClass();
}
GVMixConvolutionDesc_t::GVMixConvolutionDesc_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GVMixConvolutionDesc_t::GVMixConvolutionDesc_t(void *ptr) {
    m_ptr = ptr;
}
float GVMixConvolutionDesc_t::GetFldbGain() const {
    return GetSchemaValue<float>(m_ptr, "VMixConvolutionDesc_t", "m_fldbGain");
}
void GVMixConvolutionDesc_t::SetFldbGain(float value) {
    SetSchemaValue(m_ptr, "VMixConvolutionDesc_t", "m_fldbGain", true, value);
}
float GVMixConvolutionDesc_t::GetPreDelayMS() const {
    return GetSchemaValue<float>(m_ptr, "VMixConvolutionDesc_t", "m_flPreDelayMS");
}
void GVMixConvolutionDesc_t::SetPreDelayMS(float value) {
    SetSchemaValue(m_ptr, "VMixConvolutionDesc_t", "m_flPreDelayMS", true, value);
}
float GVMixConvolutionDesc_t::GetWetMix() const {
    return GetSchemaValue<float>(m_ptr, "VMixConvolutionDesc_t", "m_flWetMix");
}
void GVMixConvolutionDesc_t::SetWetMix(float value) {
    SetSchemaValue(m_ptr, "VMixConvolutionDesc_t", "m_flWetMix", true, value);
}
float GVMixConvolutionDesc_t::GetFldbLow() const {
    return GetSchemaValue<float>(m_ptr, "VMixConvolutionDesc_t", "m_fldbLow");
}
void GVMixConvolutionDesc_t::SetFldbLow(float value) {
    SetSchemaValue(m_ptr, "VMixConvolutionDesc_t", "m_fldbLow", true, value);
}
float GVMixConvolutionDesc_t::GetFldbMid() const {
    return GetSchemaValue<float>(m_ptr, "VMixConvolutionDesc_t", "m_fldbMid");
}
void GVMixConvolutionDesc_t::SetFldbMid(float value) {
    SetSchemaValue(m_ptr, "VMixConvolutionDesc_t", "m_fldbMid", true, value);
}
float GVMixConvolutionDesc_t::GetFldbHigh() const {
    return GetSchemaValue<float>(m_ptr, "VMixConvolutionDesc_t", "m_fldbHigh");
}
void GVMixConvolutionDesc_t::SetFldbHigh(float value) {
    SetSchemaValue(m_ptr, "VMixConvolutionDesc_t", "m_fldbHigh", true, value);
}
float GVMixConvolutionDesc_t::GetLowCutoffFreq() const {
    return GetSchemaValue<float>(m_ptr, "VMixConvolutionDesc_t", "m_flLowCutoffFreq");
}
void GVMixConvolutionDesc_t::SetLowCutoffFreq(float value) {
    SetSchemaValue(m_ptr, "VMixConvolutionDesc_t", "m_flLowCutoffFreq", true, value);
}
float GVMixConvolutionDesc_t::GetHighCutoffFreq() const {
    return GetSchemaValue<float>(m_ptr, "VMixConvolutionDesc_t", "m_flHighCutoffFreq");
}
void GVMixConvolutionDesc_t::SetHighCutoffFreq(float value) {
    SetSchemaValue(m_ptr, "VMixConvolutionDesc_t", "m_flHighCutoffFreq", true, value);
}
std::string GVMixConvolutionDesc_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GVMixConvolutionDesc_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassVMixConvolutionDesc_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GVMixConvolutionDesc_t>("VMixConvolutionDesc_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("FldbGain", &GVMixConvolutionDesc_t::GetFldbGain, &GVMixConvolutionDesc_t::SetFldbGain)
        .addProperty("PreDelayMS", &GVMixConvolutionDesc_t::GetPreDelayMS, &GVMixConvolutionDesc_t::SetPreDelayMS)
        .addProperty("WetMix", &GVMixConvolutionDesc_t::GetWetMix, &GVMixConvolutionDesc_t::SetWetMix)
        .addProperty("FldbLow", &GVMixConvolutionDesc_t::GetFldbLow, &GVMixConvolutionDesc_t::SetFldbLow)
        .addProperty("FldbMid", &GVMixConvolutionDesc_t::GetFldbMid, &GVMixConvolutionDesc_t::SetFldbMid)
        .addProperty("FldbHigh", &GVMixConvolutionDesc_t::GetFldbHigh, &GVMixConvolutionDesc_t::SetFldbHigh)
        .addProperty("LowCutoffFreq", &GVMixConvolutionDesc_t::GetLowCutoffFreq, &GVMixConvolutionDesc_t::SetLowCutoffFreq)
        .addProperty("HighCutoffFreq", &GVMixConvolutionDesc_t::GetHighCutoffFreq, &GVMixConvolutionDesc_t::SetHighCutoffFreq)
        .addFunction("ToPtr", &GVMixConvolutionDesc_t::ToPtr)
        .addFunction("IsValid", &GVMixConvolutionDesc_t::IsValid)
        .endClass();
}
GCSosGroupBranchPattern::GCSosGroupBranchPattern(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCSosGroupBranchPattern::GCSosGroupBranchPattern(void *ptr) {
    m_ptr = ptr;
}
bool GCSosGroupBranchPattern::GetMatchEventName() const {
    return GetSchemaValue<bool>(m_ptr, "CSosGroupBranchPattern", "m_bMatchEventName");
}
void GCSosGroupBranchPattern::SetMatchEventName(bool value) {
    SetSchemaValue(m_ptr, "CSosGroupBranchPattern", "m_bMatchEventName", false, value);
}
bool GCSosGroupBranchPattern::GetMatchEventSubString() const {
    return GetSchemaValue<bool>(m_ptr, "CSosGroupBranchPattern", "m_bMatchEventSubString");
}
void GCSosGroupBranchPattern::SetMatchEventSubString(bool value) {
    SetSchemaValue(m_ptr, "CSosGroupBranchPattern", "m_bMatchEventSubString", false, value);
}
bool GCSosGroupBranchPattern::GetMatchEntIndex() const {
    return GetSchemaValue<bool>(m_ptr, "CSosGroupBranchPattern", "m_bMatchEntIndex");
}
void GCSosGroupBranchPattern::SetMatchEntIndex(bool value) {
    SetSchemaValue(m_ptr, "CSosGroupBranchPattern", "m_bMatchEntIndex", false, value);
}
bool GCSosGroupBranchPattern::GetMatchOpvar() const {
    return GetSchemaValue<bool>(m_ptr, "CSosGroupBranchPattern", "m_bMatchOpvar");
}
void GCSosGroupBranchPattern::SetMatchOpvar(bool value) {
    SetSchemaValue(m_ptr, "CSosGroupBranchPattern", "m_bMatchOpvar", false, value);
}
bool GCSosGroupBranchPattern::GetMatchString() const {
    return GetSchemaValue<bool>(m_ptr, "CSosGroupBranchPattern", "m_bMatchString");
}
void GCSosGroupBranchPattern::SetMatchString(bool value) {
    SetSchemaValue(m_ptr, "CSosGroupBranchPattern", "m_bMatchString", false, value);
}
std::string GCSosGroupBranchPattern::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCSosGroupBranchPattern::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCSosGroupBranchPattern(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCSosGroupBranchPattern>("CSosGroupBranchPattern")
        .addConstructor<void (*)(std::string)>()
        .addProperty("MatchEventName", &GCSosGroupBranchPattern::GetMatchEventName, &GCSosGroupBranchPattern::SetMatchEventName)
        .addProperty("MatchEventSubString", &GCSosGroupBranchPattern::GetMatchEventSubString, &GCSosGroupBranchPattern::SetMatchEventSubString)
        .addProperty("MatchEntIndex", &GCSosGroupBranchPattern::GetMatchEntIndex, &GCSosGroupBranchPattern::SetMatchEntIndex)
        .addProperty("MatchOpvar", &GCSosGroupBranchPattern::GetMatchOpvar, &GCSosGroupBranchPattern::SetMatchOpvar)
        .addProperty("MatchString", &GCSosGroupBranchPattern::GetMatchString, &GCSosGroupBranchPattern::SetMatchString)
        .addFunction("ToPtr", &GCSosGroupBranchPattern::ToPtr)
        .addFunction("IsValid", &GCSosGroupBranchPattern::IsValid)
        .endClass();
}
GCNmGraphDefinition__ExternalGraphSlot_t::GCNmGraphDefinition__ExternalGraphSlot_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCNmGraphDefinition__ExternalGraphSlot_t::GCNmGraphDefinition__ExternalGraphSlot_t(void *ptr) {
    m_ptr = ptr;
}
int16_t GCNmGraphDefinition__ExternalGraphSlot_t::GetNodeIdx() const {
    return GetSchemaValue<int16_t>(m_ptr, "CNmGraphDefinition__ExternalGraphSlot_t", "m_nNodeIdx");
}
void GCNmGraphDefinition__ExternalGraphSlot_t::SetNodeIdx(int16_t value) {
    SetSchemaValue(m_ptr, "CNmGraphDefinition__ExternalGraphSlot_t", "m_nNodeIdx", true, value);
}
std::string GCNmGraphDefinition__ExternalGraphSlot_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCNmGraphDefinition__ExternalGraphSlot_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCNmGraphDefinition__ExternalGraphSlot_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCNmGraphDefinition__ExternalGraphSlot_t>("CNmGraphDefinition__ExternalGraphSlot_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("NodeIdx", &GCNmGraphDefinition__ExternalGraphSlot_t::GetNodeIdx, &GCNmGraphDefinition__ExternalGraphSlot_t::SetNodeIdx)
        .addFunction("ToPtr", &GCNmGraphDefinition__ExternalGraphSlot_t::ToPtr)
        .addFunction("IsValid", &GCNmGraphDefinition__ExternalGraphSlot_t::IsValid)
        .endClass();
}
GCNmStateMachineNode__StateDefinition_t::GCNmStateMachineNode__StateDefinition_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCNmStateMachineNode__StateDefinition_t::GCNmStateMachineNode__StateDefinition_t(void *ptr) {
    m_ptr = ptr;
}
int16_t GCNmStateMachineNode__StateDefinition_t::GetStateNodeIdx() const {
    return GetSchemaValue<int16_t>(m_ptr, "CNmStateMachineNode__StateDefinition_t", "m_nStateNodeIdx");
}
void GCNmStateMachineNode__StateDefinition_t::SetStateNodeIdx(int16_t value) {
    SetSchemaValue(m_ptr, "CNmStateMachineNode__StateDefinition_t", "m_nStateNodeIdx", true, value);
}
int16_t GCNmStateMachineNode__StateDefinition_t::GetEntryConditionNodeIdx() const {
    return GetSchemaValue<int16_t>(m_ptr, "CNmStateMachineNode__StateDefinition_t", "m_entryConditionNodeIdx");
}
void GCNmStateMachineNode__StateDefinition_t::SetEntryConditionNodeIdx(int16_t value) {
    SetSchemaValue(m_ptr, "CNmStateMachineNode__StateDefinition_t", "m_entryConditionNodeIdx", true, value);
}
std::string GCNmStateMachineNode__StateDefinition_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCNmStateMachineNode__StateDefinition_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCNmStateMachineNode__StateDefinition_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCNmStateMachineNode__StateDefinition_t>("CNmStateMachineNode__StateDefinition_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("StateNodeIdx", &GCNmStateMachineNode__StateDefinition_t::GetStateNodeIdx, &GCNmStateMachineNode__StateDefinition_t::SetStateNodeIdx)
        .addProperty("EntryConditionNodeIdx", &GCNmStateMachineNode__StateDefinition_t::GetEntryConditionNodeIdx, &GCNmStateMachineNode__StateDefinition_t::SetEntryConditionNodeIdx)
        .addFunction("ToPtr", &GCNmStateMachineNode__StateDefinition_t::ToPtr)
        .addFunction("IsValid", &GCNmStateMachineNode__StateDefinition_t::IsValid)
        .endClass();
}
GCModelConfigElement_SetBodygroupOnAttachedModels::GCModelConfigElement_SetBodygroupOnAttachedModels(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCModelConfigElement_SetBodygroupOnAttachedModels::GCModelConfigElement_SetBodygroupOnAttachedModels(void *ptr) {
    m_ptr = ptr;
}
std::string GCModelConfigElement_SetBodygroupOnAttachedModels::GetGroupName() const {
    return GetSchemaValue<CUtlString>(m_ptr, "CModelConfigElement_SetBodygroupOnAttachedModels", "m_GroupName").Get();
}
void GCModelConfigElement_SetBodygroupOnAttachedModels::SetGroupName(std::string value) {
    SetSchemaValue(m_ptr, "CModelConfigElement_SetBodygroupOnAttachedModels", "m_GroupName", false, CUtlString(value.c_str()));
}
int32_t GCModelConfigElement_SetBodygroupOnAttachedModels::GetChoice() const {
    return GetSchemaValue<int32_t>(m_ptr, "CModelConfigElement_SetBodygroupOnAttachedModels", "m_nChoice");
}
void GCModelConfigElement_SetBodygroupOnAttachedModels::SetChoice(int32_t value) {
    SetSchemaValue(m_ptr, "CModelConfigElement_SetBodygroupOnAttachedModels", "m_nChoice", false, value);
}
std::string GCModelConfigElement_SetBodygroupOnAttachedModels::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCModelConfigElement_SetBodygroupOnAttachedModels::IsValid() {
    return (m_ptr != nullptr);
}
GCModelConfigElement GCModelConfigElement_SetBodygroupOnAttachedModels::GetParent() const {
    GCModelConfigElement value(m_ptr);
    return value;
}
void GCModelConfigElement_SetBodygroupOnAttachedModels::SetParent(GCModelConfigElement value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCModelConfigElement_SetBodygroupOnAttachedModels(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCModelConfigElement_SetBodygroupOnAttachedModels>("CModelConfigElement_SetBodygroupOnAttachedModels")
        .addConstructor<void (*)(std::string)>()
        .addProperty("GroupName", &GCModelConfigElement_SetBodygroupOnAttachedModels::GetGroupName, &GCModelConfigElement_SetBodygroupOnAttachedModels::SetGroupName)
        .addProperty("Choice", &GCModelConfigElement_SetBodygroupOnAttachedModels::GetChoice, &GCModelConfigElement_SetBodygroupOnAttachedModels::SetChoice)
        .addProperty("Parent", &GCModelConfigElement_SetBodygroupOnAttachedModels::GetParent, &GCModelConfigElement_SetBodygroupOnAttachedModels::SetParent)
        .addFunction("ToPtr", &GCModelConfigElement_SetBodygroupOnAttachedModels::ToPtr)
        .addFunction("IsValid", &GCModelConfigElement_SetBodygroupOnAttachedModels::IsValid)
        .endClass();
}
GCNmFootEvent::GCNmFootEvent(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCNmFootEvent::GCNmFootEvent(void *ptr) {
    m_ptr = ptr;
}
uint64_t GCNmFootEvent::GetPhase() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CNmFootEvent", "m_phase");
}
void GCNmFootEvent::SetPhase(uint64_t value) {
    SetSchemaValue(m_ptr, "CNmFootEvent", "m_phase", false, value);
}
std::string GCNmFootEvent::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCNmFootEvent::IsValid() {
    return (m_ptr != nullptr);
}
GCNmEvent GCNmFootEvent::GetParent() const {
    GCNmEvent value(m_ptr);
    return value;
}
void GCNmFootEvent::SetParent(GCNmEvent value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCNmFootEvent(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCNmFootEvent>("CNmFootEvent")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Phase", &GCNmFootEvent::GetPhase, &GCNmFootEvent::SetPhase)
        .addProperty("Parent", &GCNmFootEvent::GetParent, &GCNmFootEvent::SetParent)
        .addFunction("ToPtr", &GCNmFootEvent::ToPtr)
        .addFunction("IsValid", &GCNmFootEvent::IsValid)
        .endClass();
}
GCHandshakeAnimTagBase::GCHandshakeAnimTagBase(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCHandshakeAnimTagBase::GCHandshakeAnimTagBase(void *ptr) {
    m_ptr = ptr;
}
bool GCHandshakeAnimTagBase::GetIsDisableTag() const {
    return GetSchemaValue<bool>(m_ptr, "CHandshakeAnimTagBase", "m_bIsDisableTag");
}
void GCHandshakeAnimTagBase::SetIsDisableTag(bool value) {
    SetSchemaValue(m_ptr, "CHandshakeAnimTagBase", "m_bIsDisableTag", false, value);
}
std::string GCHandshakeAnimTagBase::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCHandshakeAnimTagBase::IsValid() {
    return (m_ptr != nullptr);
}
GCAnimTagBase GCHandshakeAnimTagBase::GetParent() const {
    GCAnimTagBase value(m_ptr);
    return value;
}
void GCHandshakeAnimTagBase::SetParent(GCAnimTagBase value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCHandshakeAnimTagBase(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCHandshakeAnimTagBase>("CHandshakeAnimTagBase")
        .addConstructor<void (*)(std::string)>()
        .addProperty("IsDisableTag", &GCHandshakeAnimTagBase::GetIsDisableTag, &GCHandshakeAnimTagBase::SetIsDisableTag)
        .addProperty("Parent", &GCHandshakeAnimTagBase::GetParent, &GCHandshakeAnimTagBase::SetParent)
        .addFunction("ToPtr", &GCHandshakeAnimTagBase::ToPtr)
        .addFunction("IsValid", &GCHandshakeAnimTagBase::IsValid)
        .endClass();
}
GCBlend2DUpdateNode::GCBlend2DUpdateNode(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCBlend2DUpdateNode::GCBlend2DUpdateNode(void *ptr) {
    m_ptr = ptr;
}
std::vector<GBlendItem_t> GCBlend2DUpdateNode::GetItems() const {
    CUtlVector<GBlendItem_t>* vec = GetSchemaValue<CUtlVector<GBlendItem_t>*>(m_ptr, "CBlend2DUpdateNode", "m_items"); std::vector<GBlendItem_t> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCBlend2DUpdateNode::SetItems(std::vector<GBlendItem_t> value) {
    SetSchemaValueCUtlVector<GBlendItem_t>(m_ptr, "CBlend2DUpdateNode", "m_items", false, value);
}
std::vector<GTagSpan_t> GCBlend2DUpdateNode::GetTags() const {
    CUtlVector<GTagSpan_t>* vec = GetSchemaValue<CUtlVector<GTagSpan_t>*>(m_ptr, "CBlend2DUpdateNode", "m_tags"); std::vector<GTagSpan_t> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCBlend2DUpdateNode::SetTags(std::vector<GTagSpan_t> value) {
    SetSchemaValueCUtlVector<GTagSpan_t>(m_ptr, "CBlend2DUpdateNode", "m_tags", false, value);
}
GCParamSpanUpdater GCBlend2DUpdateNode::GetParamSpans() const {
    GCParamSpanUpdater value(GetSchemaPtr(m_ptr, "CBlend2DUpdateNode", "m_paramSpans"));
    return value;
}
void GCBlend2DUpdateNode::SetParamSpans(GCParamSpanUpdater value) {
    SetSchemaValue(m_ptr, "CBlend2DUpdateNode", "m_paramSpans", false, value);
}
std::vector<int32> GCBlend2DUpdateNode::GetNodeItemIndices() const {
    CUtlVector<int32>* vec = GetSchemaValue<CUtlVector<int32>*>(m_ptr, "CBlend2DUpdateNode", "m_nodeItemIndices"); std::vector<int32> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCBlend2DUpdateNode::SetNodeItemIndices(std::vector<int32> value) {
    SetSchemaValueCUtlVector<int32>(m_ptr, "CBlend2DUpdateNode", "m_nodeItemIndices", false, value);
}
GCAnimInputDamping GCBlend2DUpdateNode::GetDamping() const {
    GCAnimInputDamping value(GetSchemaPtr(m_ptr, "CBlend2DUpdateNode", "m_damping"));
    return value;
}
void GCBlend2DUpdateNode::SetDamping(GCAnimInputDamping value) {
    SetSchemaValue(m_ptr, "CBlend2DUpdateNode", "m_damping", false, value);
}
uint64_t GCBlend2DUpdateNode::GetBlendSourceX() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CBlend2DUpdateNode", "m_blendSourceX");
}
void GCBlend2DUpdateNode::SetBlendSourceX(uint64_t value) {
    SetSchemaValue(m_ptr, "CBlend2DUpdateNode", "m_blendSourceX", false, value);
}
GCAnimParamHandle GCBlend2DUpdateNode::GetParamX() const {
    GCAnimParamHandle value(GetSchemaPtr(m_ptr, "CBlend2DUpdateNode", "m_paramX"));
    return value;
}
void GCBlend2DUpdateNode::SetParamX(GCAnimParamHandle value) {
    SetSchemaValue(m_ptr, "CBlend2DUpdateNode", "m_paramX", false, value);
}
uint64_t GCBlend2DUpdateNode::GetBlendSourceY() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CBlend2DUpdateNode", "m_blendSourceY");
}
void GCBlend2DUpdateNode::SetBlendSourceY(uint64_t value) {
    SetSchemaValue(m_ptr, "CBlend2DUpdateNode", "m_blendSourceY", false, value);
}
GCAnimParamHandle GCBlend2DUpdateNode::GetParamY() const {
    GCAnimParamHandle value(GetSchemaPtr(m_ptr, "CBlend2DUpdateNode", "m_paramY"));
    return value;
}
void GCBlend2DUpdateNode::SetParamY(GCAnimParamHandle value) {
    SetSchemaValue(m_ptr, "CBlend2DUpdateNode", "m_paramY", false, value);
}
uint64_t GCBlend2DUpdateNode::GetBlendMode() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CBlend2DUpdateNode", "m_eBlendMode");
}
void GCBlend2DUpdateNode::SetBlendMode(uint64_t value) {
    SetSchemaValue(m_ptr, "CBlend2DUpdateNode", "m_eBlendMode", false, value);
}
float GCBlend2DUpdateNode::GetPlaybackSpeed() const {
    return GetSchemaValue<float>(m_ptr, "CBlend2DUpdateNode", "m_playbackSpeed");
}
void GCBlend2DUpdateNode::SetPlaybackSpeed(float value) {
    SetSchemaValue(m_ptr, "CBlend2DUpdateNode", "m_playbackSpeed", false, value);
}
bool GCBlend2DUpdateNode::GetLoop() const {
    return GetSchemaValue<bool>(m_ptr, "CBlend2DUpdateNode", "m_bLoop");
}
void GCBlend2DUpdateNode::SetLoop(bool value) {
    SetSchemaValue(m_ptr, "CBlend2DUpdateNode", "m_bLoop", false, value);
}
bool GCBlend2DUpdateNode::GetLockBlendOnReset() const {
    return GetSchemaValue<bool>(m_ptr, "CBlend2DUpdateNode", "m_bLockBlendOnReset");
}
void GCBlend2DUpdateNode::SetLockBlendOnReset(bool value) {
    SetSchemaValue(m_ptr, "CBlend2DUpdateNode", "m_bLockBlendOnReset", false, value);
}
bool GCBlend2DUpdateNode::GetLockWhenWaning() const {
    return GetSchemaValue<bool>(m_ptr, "CBlend2DUpdateNode", "m_bLockWhenWaning");
}
void GCBlend2DUpdateNode::SetLockWhenWaning(bool value) {
    SetSchemaValue(m_ptr, "CBlend2DUpdateNode", "m_bLockWhenWaning", false, value);
}
bool GCBlend2DUpdateNode::GetAnimEventsAndTagsOnMostWeightedOnly() const {
    return GetSchemaValue<bool>(m_ptr, "CBlend2DUpdateNode", "m_bAnimEventsAndTagsOnMostWeightedOnly");
}
void GCBlend2DUpdateNode::SetAnimEventsAndTagsOnMostWeightedOnly(bool value) {
    SetSchemaValue(m_ptr, "CBlend2DUpdateNode", "m_bAnimEventsAndTagsOnMostWeightedOnly", false, value);
}
std::string GCBlend2DUpdateNode::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCBlend2DUpdateNode::IsValid() {
    return (m_ptr != nullptr);
}
GCAnimUpdateNodeBase GCBlend2DUpdateNode::GetParent() const {
    GCAnimUpdateNodeBase value(m_ptr);
    return value;
}
void GCBlend2DUpdateNode::SetParent(GCAnimUpdateNodeBase value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCBlend2DUpdateNode(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCBlend2DUpdateNode>("CBlend2DUpdateNode")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Items", &GCBlend2DUpdateNode::GetItems, &GCBlend2DUpdateNode::SetItems)
        .addProperty("Tags", &GCBlend2DUpdateNode::GetTags, &GCBlend2DUpdateNode::SetTags)
        .addProperty("ParamSpans", &GCBlend2DUpdateNode::GetParamSpans, &GCBlend2DUpdateNode::SetParamSpans)
        .addProperty("NodeItemIndices", &GCBlend2DUpdateNode::GetNodeItemIndices, &GCBlend2DUpdateNode::SetNodeItemIndices)
        .addProperty("Damping", &GCBlend2DUpdateNode::GetDamping, &GCBlend2DUpdateNode::SetDamping)
        .addProperty("BlendSourceX", &GCBlend2DUpdateNode::GetBlendSourceX, &GCBlend2DUpdateNode::SetBlendSourceX)
        .addProperty("ParamX", &GCBlend2DUpdateNode::GetParamX, &GCBlend2DUpdateNode::SetParamX)
        .addProperty("BlendSourceY", &GCBlend2DUpdateNode::GetBlendSourceY, &GCBlend2DUpdateNode::SetBlendSourceY)
        .addProperty("ParamY", &GCBlend2DUpdateNode::GetParamY, &GCBlend2DUpdateNode::SetParamY)
        .addProperty("BlendMode", &GCBlend2DUpdateNode::GetBlendMode, &GCBlend2DUpdateNode::SetBlendMode)
        .addProperty("PlaybackSpeed", &GCBlend2DUpdateNode::GetPlaybackSpeed, &GCBlend2DUpdateNode::SetPlaybackSpeed)
        .addProperty("Loop", &GCBlend2DUpdateNode::GetLoop, &GCBlend2DUpdateNode::SetLoop)
        .addProperty("LockBlendOnReset", &GCBlend2DUpdateNode::GetLockBlendOnReset, &GCBlend2DUpdateNode::SetLockBlendOnReset)
        .addProperty("LockWhenWaning", &GCBlend2DUpdateNode::GetLockWhenWaning, &GCBlend2DUpdateNode::SetLockWhenWaning)
        .addProperty("AnimEventsAndTagsOnMostWeightedOnly", &GCBlend2DUpdateNode::GetAnimEventsAndTagsOnMostWeightedOnly, &GCBlend2DUpdateNode::SetAnimEventsAndTagsOnMostWeightedOnly)
        .addProperty("Parent", &GCBlend2DUpdateNode::GetParent, &GCBlend2DUpdateNode::SetParent)
        .addFunction("ToPtr", &GCBlend2DUpdateNode::ToPtr)
        .addFunction("IsValid", &GCBlend2DUpdateNode::IsValid)
        .endClass();
}
GAnimationSnapshotBase_t::GAnimationSnapshotBase_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GAnimationSnapshotBase_t::GAnimationSnapshotBase_t(void *ptr) {
    m_ptr = ptr;
}
float GAnimationSnapshotBase_t::GetRealTime() const {
    return GetSchemaValue<float>(m_ptr, "AnimationSnapshotBase_t", "m_flRealTime");
}
void GAnimationSnapshotBase_t::SetRealTime(float value) {
    SetSchemaValue(m_ptr, "AnimationSnapshotBase_t", "m_flRealTime", true, value);
}
matrix3x4a_t GAnimationSnapshotBase_t::GetRootToWorld() const {
    return GetSchemaValue<matrix3x4a_t>(m_ptr, "AnimationSnapshotBase_t", "m_rootToWorld");
}
void GAnimationSnapshotBase_t::SetRootToWorld(matrix3x4a_t value) {
    SetSchemaValue(m_ptr, "AnimationSnapshotBase_t", "m_rootToWorld", true, value);
}
bool GAnimationSnapshotBase_t::GetBonesInWorldSpace() const {
    return GetSchemaValue<bool>(m_ptr, "AnimationSnapshotBase_t", "m_bBonesInWorldSpace");
}
void GAnimationSnapshotBase_t::SetBonesInWorldSpace(bool value) {
    SetSchemaValue(m_ptr, "AnimationSnapshotBase_t", "m_bBonesInWorldSpace", true, value);
}
std::vector<uint32> GAnimationSnapshotBase_t::GetBoneSetupMask() const {
    CUtlVector<uint32>* vec = GetSchemaValue<CUtlVector<uint32>*>(m_ptr, "AnimationSnapshotBase_t", "m_boneSetupMask"); std::vector<uint32> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GAnimationSnapshotBase_t::SetBoneSetupMask(std::vector<uint32> value) {
    SetSchemaValueCUtlVector<uint32>(m_ptr, "AnimationSnapshotBase_t", "m_boneSetupMask", true, value);
}
std::vector<matrix3x4a_t> GAnimationSnapshotBase_t::GetBoneTransforms() const {
    CUtlVector<matrix3x4a_t>* vec = GetSchemaValue<CUtlVector<matrix3x4a_t>*>(m_ptr, "AnimationSnapshotBase_t", "m_boneTransforms"); std::vector<matrix3x4a_t> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GAnimationSnapshotBase_t::SetBoneTransforms(std::vector<matrix3x4a_t> value) {
    SetSchemaValueCUtlVector<matrix3x4a_t>(m_ptr, "AnimationSnapshotBase_t", "m_boneTransforms", true, value);
}
std::vector<float32> GAnimationSnapshotBase_t::GetFlexControllers() const {
    CUtlVector<float32>* vec = GetSchemaValue<CUtlVector<float32>*>(m_ptr, "AnimationSnapshotBase_t", "m_flexControllers"); std::vector<float32> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GAnimationSnapshotBase_t::SetFlexControllers(std::vector<float32> value) {
    SetSchemaValueCUtlVector<float32>(m_ptr, "AnimationSnapshotBase_t", "m_flexControllers", true, value);
}
uint64_t GAnimationSnapshotBase_t::GetSnapshotType() const {
    return GetSchemaValue<uint64_t>(m_ptr, "AnimationSnapshotBase_t", "m_SnapshotType");
}
void GAnimationSnapshotBase_t::SetSnapshotType(uint64_t value) {
    SetSchemaValue(m_ptr, "AnimationSnapshotBase_t", "m_SnapshotType", true, value);
}
bool GAnimationSnapshotBase_t::GetHasDecodeDump() const {
    return GetSchemaValue<bool>(m_ptr, "AnimationSnapshotBase_t", "m_bHasDecodeDump");
}
void GAnimationSnapshotBase_t::SetHasDecodeDump(bool value) {
    SetSchemaValue(m_ptr, "AnimationSnapshotBase_t", "m_bHasDecodeDump", true, value);
}
GAnimationDecodeDebugDumpElement_t GAnimationSnapshotBase_t::GetDecodeDump() const {
    GAnimationDecodeDebugDumpElement_t value(GetSchemaPtr(m_ptr, "AnimationSnapshotBase_t", "m_DecodeDump"));
    return value;
}
void GAnimationSnapshotBase_t::SetDecodeDump(GAnimationDecodeDebugDumpElement_t value) {
    SetSchemaValue(m_ptr, "AnimationSnapshotBase_t", "m_DecodeDump", true, value);
}
std::string GAnimationSnapshotBase_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GAnimationSnapshotBase_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassAnimationSnapshotBase_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GAnimationSnapshotBase_t>("AnimationSnapshotBase_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("RealTime", &GAnimationSnapshotBase_t::GetRealTime, &GAnimationSnapshotBase_t::SetRealTime)
        .addProperty("RootToWorld", &GAnimationSnapshotBase_t::GetRootToWorld, &GAnimationSnapshotBase_t::SetRootToWorld)
        .addProperty("BonesInWorldSpace", &GAnimationSnapshotBase_t::GetBonesInWorldSpace, &GAnimationSnapshotBase_t::SetBonesInWorldSpace)
        .addProperty("BoneSetupMask", &GAnimationSnapshotBase_t::GetBoneSetupMask, &GAnimationSnapshotBase_t::SetBoneSetupMask)
        .addProperty("BoneTransforms", &GAnimationSnapshotBase_t::GetBoneTransforms, &GAnimationSnapshotBase_t::SetBoneTransforms)
        .addProperty("FlexControllers", &GAnimationSnapshotBase_t::GetFlexControllers, &GAnimationSnapshotBase_t::SetFlexControllers)
        .addProperty("SnapshotType", &GAnimationSnapshotBase_t::GetSnapshotType, &GAnimationSnapshotBase_t::SetSnapshotType)
        .addProperty("HasDecodeDump", &GAnimationSnapshotBase_t::GetHasDecodeDump, &GAnimationSnapshotBase_t::SetHasDecodeDump)
        .addProperty("DecodeDump", &GAnimationSnapshotBase_t::GetDecodeDump, &GAnimationSnapshotBase_t::SetDecodeDump)
        .addFunction("ToPtr", &GAnimationSnapshotBase_t::ToPtr)
        .addFunction("IsValid", &GAnimationSnapshotBase_t::IsValid)
        .endClass();
}
GCTiltTwistConstraint::GCTiltTwistConstraint(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCTiltTwistConstraint::GCTiltTwistConstraint(void *ptr) {
    m_ptr = ptr;
}
int32_t GCTiltTwistConstraint::GetTargetAxis() const {
    return GetSchemaValue<int32_t>(m_ptr, "CTiltTwistConstraint", "m_nTargetAxis");
}
void GCTiltTwistConstraint::SetTargetAxis(int32_t value) {
    SetSchemaValue(m_ptr, "CTiltTwistConstraint", "m_nTargetAxis", false, value);
}
int32_t GCTiltTwistConstraint::GetSlaveAxis() const {
    return GetSchemaValue<int32_t>(m_ptr, "CTiltTwistConstraint", "m_nSlaveAxis");
}
void GCTiltTwistConstraint::SetSlaveAxis(int32_t value) {
    SetSchemaValue(m_ptr, "CTiltTwistConstraint", "m_nSlaveAxis", false, value);
}
std::string GCTiltTwistConstraint::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCTiltTwistConstraint::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseConstraint GCTiltTwistConstraint::GetParent() const {
    GCBaseConstraint value(m_ptr);
    return value;
}
void GCTiltTwistConstraint::SetParent(GCBaseConstraint value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCTiltTwistConstraint(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCTiltTwistConstraint>("CTiltTwistConstraint")
        .addConstructor<void (*)(std::string)>()
        .addProperty("TargetAxis", &GCTiltTwistConstraint::GetTargetAxis, &GCTiltTwistConstraint::SetTargetAxis)
        .addProperty("SlaveAxis", &GCTiltTwistConstraint::GetSlaveAxis, &GCTiltTwistConstraint::SetSlaveAxis)
        .addProperty("Parent", &GCTiltTwistConstraint::GetParent, &GCTiltTwistConstraint::SetParent)
        .addFunction("ToPtr", &GCTiltTwistConstraint::ToPtr)
        .addFunction("IsValid", &GCTiltTwistConstraint::IsValid)
        .endClass();
}
GMaterialParamTexture_t::GMaterialParamTexture_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GMaterialParamTexture_t::GMaterialParamTexture_t(void *ptr) {
    m_ptr = ptr;
}
std::string GMaterialParamTexture_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GMaterialParamTexture_t::IsValid() {
    return (m_ptr != nullptr);
}
GMaterialParam_t GMaterialParamTexture_t::GetParent() const {
    GMaterialParam_t value(m_ptr);
    return value;
}
void GMaterialParamTexture_t::SetParent(GMaterialParam_t value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassMaterialParamTexture_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GMaterialParamTexture_t>("MaterialParamTexture_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GMaterialParamTexture_t::GetParent, &GMaterialParamTexture_t::SetParent)
        .addFunction("ToPtr", &GMaterialParamTexture_t::ToPtr)
        .addFunction("IsValid", &GMaterialParamTexture_t::IsValid)
        .endClass();
}
GCGlobalLightBase::GCGlobalLightBase(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCGlobalLightBase::GCGlobalLightBase(void *ptr) {
    m_ptr = ptr;
}
bool GCGlobalLightBase::GetSpotLight() const {
    return GetSchemaValue<bool>(m_ptr, "CGlobalLightBase", "m_bSpotLight");
}
void GCGlobalLightBase::SetSpotLight(bool value) {
    SetSchemaValue(m_ptr, "CGlobalLightBase", "m_bSpotLight", false, value);
}
Vector GCGlobalLightBase::GetSpotLightOrigin() const {
    return GetSchemaValue<Vector>(m_ptr, "CGlobalLightBase", "m_SpotLightOrigin");
}
void GCGlobalLightBase::SetSpotLightOrigin(Vector value) {
    SetSchemaValue(m_ptr, "CGlobalLightBase", "m_SpotLightOrigin", false, value);
}
QAngle GCGlobalLightBase::GetSpotLightAngles() const {
    return GetSchemaValue<QAngle>(m_ptr, "CGlobalLightBase", "m_SpotLightAngles");
}
void GCGlobalLightBase::SetSpotLightAngles(QAngle value) {
    SetSchemaValue(m_ptr, "CGlobalLightBase", "m_SpotLightAngles", false, value);
}
Vector GCGlobalLightBase::GetShadowDirection() const {
    return GetSchemaValue<Vector>(m_ptr, "CGlobalLightBase", "m_ShadowDirection");
}
void GCGlobalLightBase::SetShadowDirection(Vector value) {
    SetSchemaValue(m_ptr, "CGlobalLightBase", "m_ShadowDirection", false, value);
}
Vector GCGlobalLightBase::GetAmbientDirection() const {
    return GetSchemaValue<Vector>(m_ptr, "CGlobalLightBase", "m_AmbientDirection");
}
void GCGlobalLightBase::SetAmbientDirection(Vector value) {
    SetSchemaValue(m_ptr, "CGlobalLightBase", "m_AmbientDirection", false, value);
}
Vector GCGlobalLightBase::GetSpecularDirection() const {
    return GetSchemaValue<Vector>(m_ptr, "CGlobalLightBase", "m_SpecularDirection");
}
void GCGlobalLightBase::SetSpecularDirection(Vector value) {
    SetSchemaValue(m_ptr, "CGlobalLightBase", "m_SpecularDirection", false, value);
}
Vector GCGlobalLightBase::GetInspectorSpecularDirection() const {
    return GetSchemaValue<Vector>(m_ptr, "CGlobalLightBase", "m_InspectorSpecularDirection");
}
void GCGlobalLightBase::SetInspectorSpecularDirection(Vector value) {
    SetSchemaValue(m_ptr, "CGlobalLightBase", "m_InspectorSpecularDirection", false, value);
}
float GCGlobalLightBase::GetSpecularPower() const {
    return GetSchemaValue<float>(m_ptr, "CGlobalLightBase", "m_flSpecularPower");
}
void GCGlobalLightBase::SetSpecularPower(float value) {
    SetSchemaValue(m_ptr, "CGlobalLightBase", "m_flSpecularPower", false, value);
}
float GCGlobalLightBase::GetSpecularIndependence() const {
    return GetSchemaValue<float>(m_ptr, "CGlobalLightBase", "m_flSpecularIndependence");
}
void GCGlobalLightBase::SetSpecularIndependence(float value) {
    SetSchemaValue(m_ptr, "CGlobalLightBase", "m_flSpecularIndependence", false, value);
}
Color GCGlobalLightBase::GetSpecularColor() const {
    return GetSchemaValue<Color>(m_ptr, "CGlobalLightBase", "m_SpecularColor");
}
void GCGlobalLightBase::SetSpecularColor(Color value) {
    SetSchemaValue(m_ptr, "CGlobalLightBase", "m_SpecularColor", false, value);
}
bool GCGlobalLightBase::GetStartDisabled() const {
    return GetSchemaValue<bool>(m_ptr, "CGlobalLightBase", "m_bStartDisabled");
}
void GCGlobalLightBase::SetStartDisabled(bool value) {
    SetSchemaValue(m_ptr, "CGlobalLightBase", "m_bStartDisabled", false, value);
}
bool GCGlobalLightBase::GetEnabled() const {
    return GetSchemaValue<bool>(m_ptr, "CGlobalLightBase", "m_bEnabled");
}
void GCGlobalLightBase::SetEnabled(bool value) {
    SetSchemaValue(m_ptr, "CGlobalLightBase", "m_bEnabled", false, value);
}
Color GCGlobalLightBase::GetLightColor() const {
    return GetSchemaValue<Color>(m_ptr, "CGlobalLightBase", "m_LightColor");
}
void GCGlobalLightBase::SetLightColor(Color value) {
    SetSchemaValue(m_ptr, "CGlobalLightBase", "m_LightColor", false, value);
}
Color GCGlobalLightBase::GetAmbientColor1() const {
    return GetSchemaValue<Color>(m_ptr, "CGlobalLightBase", "m_AmbientColor1");
}
void GCGlobalLightBase::SetAmbientColor1(Color value) {
    SetSchemaValue(m_ptr, "CGlobalLightBase", "m_AmbientColor1", false, value);
}
Color GCGlobalLightBase::GetAmbientColor2() const {
    return GetSchemaValue<Color>(m_ptr, "CGlobalLightBase", "m_AmbientColor2");
}
void GCGlobalLightBase::SetAmbientColor2(Color value) {
    SetSchemaValue(m_ptr, "CGlobalLightBase", "m_AmbientColor2", false, value);
}
Color GCGlobalLightBase::GetAmbientColor3() const {
    return GetSchemaValue<Color>(m_ptr, "CGlobalLightBase", "m_AmbientColor3");
}
void GCGlobalLightBase::SetAmbientColor3(Color value) {
    SetSchemaValue(m_ptr, "CGlobalLightBase", "m_AmbientColor3", false, value);
}
float GCGlobalLightBase::GetSunDistance() const {
    return GetSchemaValue<float>(m_ptr, "CGlobalLightBase", "m_flSunDistance");
}
void GCGlobalLightBase::SetSunDistance(float value) {
    SetSchemaValue(m_ptr, "CGlobalLightBase", "m_flSunDistance", false, value);
}
float GCGlobalLightBase::GetFOV() const {
    return GetSchemaValue<float>(m_ptr, "CGlobalLightBase", "m_flFOV");
}
void GCGlobalLightBase::SetFOV(float value) {
    SetSchemaValue(m_ptr, "CGlobalLightBase", "m_flFOV", false, value);
}
float GCGlobalLightBase::GetNearZ() const {
    return GetSchemaValue<float>(m_ptr, "CGlobalLightBase", "m_flNearZ");
}
void GCGlobalLightBase::SetNearZ(float value) {
    SetSchemaValue(m_ptr, "CGlobalLightBase", "m_flNearZ", false, value);
}
float GCGlobalLightBase::GetFarZ() const {
    return GetSchemaValue<float>(m_ptr, "CGlobalLightBase", "m_flFarZ");
}
void GCGlobalLightBase::SetFarZ(float value) {
    SetSchemaValue(m_ptr, "CGlobalLightBase", "m_flFarZ", false, value);
}
bool GCGlobalLightBase::GetEnableShadows() const {
    return GetSchemaValue<bool>(m_ptr, "CGlobalLightBase", "m_bEnableShadows");
}
void GCGlobalLightBase::SetEnableShadows(bool value) {
    SetSchemaValue(m_ptr, "CGlobalLightBase", "m_bEnableShadows", false, value);
}
bool GCGlobalLightBase::GetOldEnableShadows() const {
    return GetSchemaValue<bool>(m_ptr, "CGlobalLightBase", "m_bOldEnableShadows");
}
void GCGlobalLightBase::SetOldEnableShadows(bool value) {
    SetSchemaValue(m_ptr, "CGlobalLightBase", "m_bOldEnableShadows", false, value);
}
bool GCGlobalLightBase::GetBackgroundClearNotRequired() const {
    return GetSchemaValue<bool>(m_ptr, "CGlobalLightBase", "m_bBackgroundClearNotRequired");
}
void GCGlobalLightBase::SetBackgroundClearNotRequired(bool value) {
    SetSchemaValue(m_ptr, "CGlobalLightBase", "m_bBackgroundClearNotRequired", false, value);
}
float GCGlobalLightBase::GetCloudScale() const {
    return GetSchemaValue<float>(m_ptr, "CGlobalLightBase", "m_flCloudScale");
}
void GCGlobalLightBase::SetCloudScale(float value) {
    SetSchemaValue(m_ptr, "CGlobalLightBase", "m_flCloudScale", false, value);
}
float GCGlobalLightBase::GetCloud1Speed() const {
    return GetSchemaValue<float>(m_ptr, "CGlobalLightBase", "m_flCloud1Speed");
}
void GCGlobalLightBase::SetCloud1Speed(float value) {
    SetSchemaValue(m_ptr, "CGlobalLightBase", "m_flCloud1Speed", false, value);
}
float GCGlobalLightBase::GetCloud1Direction() const {
    return GetSchemaValue<float>(m_ptr, "CGlobalLightBase", "m_flCloud1Direction");
}
void GCGlobalLightBase::SetCloud1Direction(float value) {
    SetSchemaValue(m_ptr, "CGlobalLightBase", "m_flCloud1Direction", false, value);
}
float GCGlobalLightBase::GetCloud2Speed() const {
    return GetSchemaValue<float>(m_ptr, "CGlobalLightBase", "m_flCloud2Speed");
}
void GCGlobalLightBase::SetCloud2Speed(float value) {
    SetSchemaValue(m_ptr, "CGlobalLightBase", "m_flCloud2Speed", false, value);
}
float GCGlobalLightBase::GetCloud2Direction() const {
    return GetSchemaValue<float>(m_ptr, "CGlobalLightBase", "m_flCloud2Direction");
}
void GCGlobalLightBase::SetCloud2Direction(float value) {
    SetSchemaValue(m_ptr, "CGlobalLightBase", "m_flCloud2Direction", false, value);
}
float GCGlobalLightBase::GetAmbientScale1() const {
    return GetSchemaValue<float>(m_ptr, "CGlobalLightBase", "m_flAmbientScale1");
}
void GCGlobalLightBase::SetAmbientScale1(float value) {
    SetSchemaValue(m_ptr, "CGlobalLightBase", "m_flAmbientScale1", false, value);
}
float GCGlobalLightBase::GetAmbientScale2() const {
    return GetSchemaValue<float>(m_ptr, "CGlobalLightBase", "m_flAmbientScale2");
}
void GCGlobalLightBase::SetAmbientScale2(float value) {
    SetSchemaValue(m_ptr, "CGlobalLightBase", "m_flAmbientScale2", false, value);
}
float GCGlobalLightBase::GetGroundScale() const {
    return GetSchemaValue<float>(m_ptr, "CGlobalLightBase", "m_flGroundScale");
}
void GCGlobalLightBase::SetGroundScale(float value) {
    SetSchemaValue(m_ptr, "CGlobalLightBase", "m_flGroundScale", false, value);
}
float GCGlobalLightBase::GetLightScale() const {
    return GetSchemaValue<float>(m_ptr, "CGlobalLightBase", "m_flLightScale");
}
void GCGlobalLightBase::SetLightScale(float value) {
    SetSchemaValue(m_ptr, "CGlobalLightBase", "m_flLightScale", false, value);
}
float GCGlobalLightBase::GetFoWDarkness() const {
    return GetSchemaValue<float>(m_ptr, "CGlobalLightBase", "m_flFoWDarkness");
}
void GCGlobalLightBase::SetFoWDarkness(float value) {
    SetSchemaValue(m_ptr, "CGlobalLightBase", "m_flFoWDarkness", false, value);
}
bool GCGlobalLightBase::GetEnableSeparateSkyboxFog() const {
    return GetSchemaValue<bool>(m_ptr, "CGlobalLightBase", "m_bEnableSeparateSkyboxFog");
}
void GCGlobalLightBase::SetEnableSeparateSkyboxFog(bool value) {
    SetSchemaValue(m_ptr, "CGlobalLightBase", "m_bEnableSeparateSkyboxFog", false, value);
}
Vector GCGlobalLightBase::GetFowColor() const {
    return GetSchemaValue<Vector>(m_ptr, "CGlobalLightBase", "m_vFowColor");
}
void GCGlobalLightBase::SetFowColor(Vector value) {
    SetSchemaValue(m_ptr, "CGlobalLightBase", "m_vFowColor", false, value);
}
Vector GCGlobalLightBase::GetViewOrigin() const {
    return GetSchemaValue<Vector>(m_ptr, "CGlobalLightBase", "m_ViewOrigin");
}
void GCGlobalLightBase::SetViewOrigin(Vector value) {
    SetSchemaValue(m_ptr, "CGlobalLightBase", "m_ViewOrigin", false, value);
}
QAngle GCGlobalLightBase::GetViewAngles() const {
    return GetSchemaValue<QAngle>(m_ptr, "CGlobalLightBase", "m_ViewAngles");
}
void GCGlobalLightBase::SetViewAngles(QAngle value) {
    SetSchemaValue(m_ptr, "CGlobalLightBase", "m_ViewAngles", false, value);
}
float GCGlobalLightBase::GetViewFoV() const {
    return GetSchemaValue<float>(m_ptr, "CGlobalLightBase", "m_flViewFoV");
}
void GCGlobalLightBase::SetViewFoV(float value) {
    SetSchemaValue(m_ptr, "CGlobalLightBase", "m_flViewFoV", false, value);
}
std::vector<Vector> GCGlobalLightBase::GetWorldPoints() const {
    Vector* outValue = GetSchemaValue<Vector*>(m_ptr, "CGlobalLightBase", "m_WorldPoints"); std::vector<Vector> ret; for(int i = 0; i < 8; i++) { ret.push_back(outValue[i]); } return ret;
}
void GCGlobalLightBase::SetWorldPoints(std::vector<Vector> value) {
    Vector* outValue = GetSchemaValue<Vector*>(m_ptr, "CGlobalLightBase", "m_WorldPoints"); for(int i = 0; i < 8; i++) { outValue[i] = value[i]; } SetSchemaValue(m_ptr, "CGlobalLightBase", "m_WorldPoints", false, outValue);
}
Vector2D GCGlobalLightBase::GetFogOffsetLayer0() const {
    return GetSchemaValue<Vector2D>(m_ptr, "CGlobalLightBase", "m_vFogOffsetLayer0");
}
void GCGlobalLightBase::SetFogOffsetLayer0(Vector2D value) {
    SetSchemaValue(m_ptr, "CGlobalLightBase", "m_vFogOffsetLayer0", false, value);
}
Vector2D GCGlobalLightBase::GetFogOffsetLayer1() const {
    return GetSchemaValue<Vector2D>(m_ptr, "CGlobalLightBase", "m_vFogOffsetLayer1");
}
void GCGlobalLightBase::SetFogOffsetLayer1(Vector2D value) {
    SetSchemaValue(m_ptr, "CGlobalLightBase", "m_vFogOffsetLayer1", false, value);
}
std::string GCGlobalLightBase::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCGlobalLightBase::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCGlobalLightBase(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCGlobalLightBase>("CGlobalLightBase")
        .addConstructor<void (*)(std::string)>()
        .addProperty("SpotLight", &GCGlobalLightBase::GetSpotLight, &GCGlobalLightBase::SetSpotLight)
        .addProperty("SpotLightOrigin", &GCGlobalLightBase::GetSpotLightOrigin, &GCGlobalLightBase::SetSpotLightOrigin)
        .addProperty("SpotLightAngles", &GCGlobalLightBase::GetSpotLightAngles, &GCGlobalLightBase::SetSpotLightAngles)
        .addProperty("ShadowDirection", &GCGlobalLightBase::GetShadowDirection, &GCGlobalLightBase::SetShadowDirection)
        .addProperty("AmbientDirection", &GCGlobalLightBase::GetAmbientDirection, &GCGlobalLightBase::SetAmbientDirection)
        .addProperty("SpecularDirection", &GCGlobalLightBase::GetSpecularDirection, &GCGlobalLightBase::SetSpecularDirection)
        .addProperty("InspectorSpecularDirection", &GCGlobalLightBase::GetInspectorSpecularDirection, &GCGlobalLightBase::SetInspectorSpecularDirection)
        .addProperty("SpecularPower", &GCGlobalLightBase::GetSpecularPower, &GCGlobalLightBase::SetSpecularPower)
        .addProperty("SpecularIndependence", &GCGlobalLightBase::GetSpecularIndependence, &GCGlobalLightBase::SetSpecularIndependence)
        .addProperty("SpecularColor", &GCGlobalLightBase::GetSpecularColor, &GCGlobalLightBase::SetSpecularColor)
        .addProperty("StartDisabled", &GCGlobalLightBase::GetStartDisabled, &GCGlobalLightBase::SetStartDisabled)
        .addProperty("Enabled", &GCGlobalLightBase::GetEnabled, &GCGlobalLightBase::SetEnabled)
        .addProperty("LightColor", &GCGlobalLightBase::GetLightColor, &GCGlobalLightBase::SetLightColor)
        .addProperty("AmbientColor1", &GCGlobalLightBase::GetAmbientColor1, &GCGlobalLightBase::SetAmbientColor1)
        .addProperty("AmbientColor2", &GCGlobalLightBase::GetAmbientColor2, &GCGlobalLightBase::SetAmbientColor2)
        .addProperty("AmbientColor3", &GCGlobalLightBase::GetAmbientColor3, &GCGlobalLightBase::SetAmbientColor3)
        .addProperty("SunDistance", &GCGlobalLightBase::GetSunDistance, &GCGlobalLightBase::SetSunDistance)
        .addProperty("FOV", &GCGlobalLightBase::GetFOV, &GCGlobalLightBase::SetFOV)
        .addProperty("NearZ", &GCGlobalLightBase::GetNearZ, &GCGlobalLightBase::SetNearZ)
        .addProperty("FarZ", &GCGlobalLightBase::GetFarZ, &GCGlobalLightBase::SetFarZ)
        .addProperty("EnableShadows", &GCGlobalLightBase::GetEnableShadows, &GCGlobalLightBase::SetEnableShadows)
        .addProperty("OldEnableShadows", &GCGlobalLightBase::GetOldEnableShadows, &GCGlobalLightBase::SetOldEnableShadows)
        .addProperty("BackgroundClearNotRequired", &GCGlobalLightBase::GetBackgroundClearNotRequired, &GCGlobalLightBase::SetBackgroundClearNotRequired)
        .addProperty("CloudScale", &GCGlobalLightBase::GetCloudScale, &GCGlobalLightBase::SetCloudScale)
        .addProperty("Cloud1Speed", &GCGlobalLightBase::GetCloud1Speed, &GCGlobalLightBase::SetCloud1Speed)
        .addProperty("Cloud1Direction", &GCGlobalLightBase::GetCloud1Direction, &GCGlobalLightBase::SetCloud1Direction)
        .addProperty("Cloud2Speed", &GCGlobalLightBase::GetCloud2Speed, &GCGlobalLightBase::SetCloud2Speed)
        .addProperty("Cloud2Direction", &GCGlobalLightBase::GetCloud2Direction, &GCGlobalLightBase::SetCloud2Direction)
        .addProperty("AmbientScale1", &GCGlobalLightBase::GetAmbientScale1, &GCGlobalLightBase::SetAmbientScale1)
        .addProperty("AmbientScale2", &GCGlobalLightBase::GetAmbientScale2, &GCGlobalLightBase::SetAmbientScale2)
        .addProperty("GroundScale", &GCGlobalLightBase::GetGroundScale, &GCGlobalLightBase::SetGroundScale)
        .addProperty("LightScale", &GCGlobalLightBase::GetLightScale, &GCGlobalLightBase::SetLightScale)
        .addProperty("FoWDarkness", &GCGlobalLightBase::GetFoWDarkness, &GCGlobalLightBase::SetFoWDarkness)
        .addProperty("EnableSeparateSkyboxFog", &GCGlobalLightBase::GetEnableSeparateSkyboxFog, &GCGlobalLightBase::SetEnableSeparateSkyboxFog)
        .addProperty("FowColor", &GCGlobalLightBase::GetFowColor, &GCGlobalLightBase::SetFowColor)
        .addProperty("ViewOrigin", &GCGlobalLightBase::GetViewOrigin, &GCGlobalLightBase::SetViewOrigin)
        .addProperty("ViewAngles", &GCGlobalLightBase::GetViewAngles, &GCGlobalLightBase::SetViewAngles)
        .addProperty("ViewFoV", &GCGlobalLightBase::GetViewFoV, &GCGlobalLightBase::SetViewFoV)
        .addProperty("WorldPoints", &GCGlobalLightBase::GetWorldPoints, &GCGlobalLightBase::SetWorldPoints)
        .addProperty("FogOffsetLayer0", &GCGlobalLightBase::GetFogOffsetLayer0, &GCGlobalLightBase::SetFogOffsetLayer0)
        .addProperty("FogOffsetLayer1", &GCGlobalLightBase::GetFogOffsetLayer1, &GCGlobalLightBase::SetFogOffsetLayer1)
        .addFunction("ToPtr", &GCGlobalLightBase::ToPtr)
        .addFunction("IsValid", &GCGlobalLightBase::IsValid)
        .endClass();
}
GCModelConfigElement_SetBodygroup::GCModelConfigElement_SetBodygroup(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCModelConfigElement_SetBodygroup::GCModelConfigElement_SetBodygroup(void *ptr) {
    m_ptr = ptr;
}
std::string GCModelConfigElement_SetBodygroup::GetGroupName() const {
    return GetSchemaValue<CUtlString>(m_ptr, "CModelConfigElement_SetBodygroup", "m_GroupName").Get();
}
void GCModelConfigElement_SetBodygroup::SetGroupName(std::string value) {
    SetSchemaValue(m_ptr, "CModelConfigElement_SetBodygroup", "m_GroupName", false, CUtlString(value.c_str()));
}
int32_t GCModelConfigElement_SetBodygroup::GetChoice() const {
    return GetSchemaValue<int32_t>(m_ptr, "CModelConfigElement_SetBodygroup", "m_nChoice");
}
void GCModelConfigElement_SetBodygroup::SetChoice(int32_t value) {
    SetSchemaValue(m_ptr, "CModelConfigElement_SetBodygroup", "m_nChoice", false, value);
}
std::string GCModelConfigElement_SetBodygroup::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCModelConfigElement_SetBodygroup::IsValid() {
    return (m_ptr != nullptr);
}
GCModelConfigElement GCModelConfigElement_SetBodygroup::GetParent() const {
    GCModelConfigElement value(m_ptr);
    return value;
}
void GCModelConfigElement_SetBodygroup::SetParent(GCModelConfigElement value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCModelConfigElement_SetBodygroup(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCModelConfigElement_SetBodygroup>("CModelConfigElement_SetBodygroup")
        .addConstructor<void (*)(std::string)>()
        .addProperty("GroupName", &GCModelConfigElement_SetBodygroup::GetGroupName, &GCModelConfigElement_SetBodygroup::SetGroupName)
        .addProperty("Choice", &GCModelConfigElement_SetBodygroup::GetChoice, &GCModelConfigElement_SetBodygroup::SetChoice)
        .addProperty("Parent", &GCModelConfigElement_SetBodygroup::GetParent, &GCModelConfigElement_SetBodygroup::SetParent)
        .addFunction("ToPtr", &GCModelConfigElement_SetBodygroup::ToPtr)
        .addFunction("IsValid", &GCModelConfigElement_SetBodygroup::IsValid)
        .endClass();
}
GCModelConfigElement_AttachedModel::GCModelConfigElement_AttachedModel(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCModelConfigElement_AttachedModel::GCModelConfigElement_AttachedModel(void *ptr) {
    m_ptr = ptr;
}
std::string GCModelConfigElement_AttachedModel::GetInstanceName() const {
    return GetSchemaValue<CUtlString>(m_ptr, "CModelConfigElement_AttachedModel", "m_InstanceName").Get();
}
void GCModelConfigElement_AttachedModel::SetInstanceName(std::string value) {
    SetSchemaValue(m_ptr, "CModelConfigElement_AttachedModel", "m_InstanceName", false, CUtlString(value.c_str()));
}
std::string GCModelConfigElement_AttachedModel::GetEntityClass() const {
    return GetSchemaValue<CUtlString>(m_ptr, "CModelConfigElement_AttachedModel", "m_EntityClass").Get();
}
void GCModelConfigElement_AttachedModel::SetEntityClass(std::string value) {
    SetSchemaValue(m_ptr, "CModelConfigElement_AttachedModel", "m_EntityClass", false, CUtlString(value.c_str()));
}
Vector GCModelConfigElement_AttachedModel::GetOffset() const {
    return GetSchemaValue<Vector>(m_ptr, "CModelConfigElement_AttachedModel", "m_vOffset");
}
void GCModelConfigElement_AttachedModel::SetOffset(Vector value) {
    SetSchemaValue(m_ptr, "CModelConfigElement_AttachedModel", "m_vOffset", false, value);
}
QAngle GCModelConfigElement_AttachedModel::GetAngOffset() const {
    return GetSchemaValue<QAngle>(m_ptr, "CModelConfigElement_AttachedModel", "m_aAngOffset");
}
void GCModelConfigElement_AttachedModel::SetAngOffset(QAngle value) {
    SetSchemaValue(m_ptr, "CModelConfigElement_AttachedModel", "m_aAngOffset", false, value);
}
std::string GCModelConfigElement_AttachedModel::GetAttachmentName() const {
    return GetSchemaValue<CUtlString>(m_ptr, "CModelConfigElement_AttachedModel", "m_AttachmentName").Get();
}
void GCModelConfigElement_AttachedModel::SetAttachmentName(std::string value) {
    SetSchemaValue(m_ptr, "CModelConfigElement_AttachedModel", "m_AttachmentName", false, CUtlString(value.c_str()));
}
std::string GCModelConfigElement_AttachedModel::GetLocalAttachmentOffsetName() const {
    return GetSchemaValue<CUtlString>(m_ptr, "CModelConfigElement_AttachedModel", "m_LocalAttachmentOffsetName").Get();
}
void GCModelConfigElement_AttachedModel::SetLocalAttachmentOffsetName(std::string value) {
    SetSchemaValue(m_ptr, "CModelConfigElement_AttachedModel", "m_LocalAttachmentOffsetName", false, CUtlString(value.c_str()));
}
uint64_t GCModelConfigElement_AttachedModel::GetAttachmentType() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CModelConfigElement_AttachedModel", "m_AttachmentType");
}
void GCModelConfigElement_AttachedModel::SetAttachmentType(uint64_t value) {
    SetSchemaValue(m_ptr, "CModelConfigElement_AttachedModel", "m_AttachmentType", false, value);
}
bool GCModelConfigElement_AttachedModel::GetBoneMergeFlex() const {
    return GetSchemaValue<bool>(m_ptr, "CModelConfigElement_AttachedModel", "m_bBoneMergeFlex");
}
void GCModelConfigElement_AttachedModel::SetBoneMergeFlex(bool value) {
    SetSchemaValue(m_ptr, "CModelConfigElement_AttachedModel", "m_bBoneMergeFlex", false, value);
}
bool GCModelConfigElement_AttachedModel::GetUserSpecifiedColor() const {
    return GetSchemaValue<bool>(m_ptr, "CModelConfigElement_AttachedModel", "m_bUserSpecifiedColor");
}
void GCModelConfigElement_AttachedModel::SetUserSpecifiedColor(bool value) {
    SetSchemaValue(m_ptr, "CModelConfigElement_AttachedModel", "m_bUserSpecifiedColor", false, value);
}
bool GCModelConfigElement_AttachedModel::GetUserSpecifiedMaterialGroup() const {
    return GetSchemaValue<bool>(m_ptr, "CModelConfigElement_AttachedModel", "m_bUserSpecifiedMaterialGroup");
}
void GCModelConfigElement_AttachedModel::SetUserSpecifiedMaterialGroup(bool value) {
    SetSchemaValue(m_ptr, "CModelConfigElement_AttachedModel", "m_bUserSpecifiedMaterialGroup", false, value);
}
bool GCModelConfigElement_AttachedModel::GetAcceptParentMaterialDrivenDecals() const {
    return GetSchemaValue<bool>(m_ptr, "CModelConfigElement_AttachedModel", "m_bAcceptParentMaterialDrivenDecals");
}
void GCModelConfigElement_AttachedModel::SetAcceptParentMaterialDrivenDecals(bool value) {
    SetSchemaValue(m_ptr, "CModelConfigElement_AttachedModel", "m_bAcceptParentMaterialDrivenDecals", false, value);
}
std::string GCModelConfigElement_AttachedModel::GetBodygroupOnOtherModels() const {
    return GetSchemaValue<CUtlString>(m_ptr, "CModelConfigElement_AttachedModel", "m_BodygroupOnOtherModels").Get();
}
void GCModelConfigElement_AttachedModel::SetBodygroupOnOtherModels(std::string value) {
    SetSchemaValue(m_ptr, "CModelConfigElement_AttachedModel", "m_BodygroupOnOtherModels", false, CUtlString(value.c_str()));
}
std::string GCModelConfigElement_AttachedModel::GetMaterialGroupOnOtherModels() const {
    return GetSchemaValue<CUtlString>(m_ptr, "CModelConfigElement_AttachedModel", "m_MaterialGroupOnOtherModels").Get();
}
void GCModelConfigElement_AttachedModel::SetMaterialGroupOnOtherModels(std::string value) {
    SetSchemaValue(m_ptr, "CModelConfigElement_AttachedModel", "m_MaterialGroupOnOtherModels", false, CUtlString(value.c_str()));
}
std::string GCModelConfigElement_AttachedModel::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCModelConfigElement_AttachedModel::IsValid() {
    return (m_ptr != nullptr);
}
GCModelConfigElement GCModelConfigElement_AttachedModel::GetParent() const {
    GCModelConfigElement value(m_ptr);
    return value;
}
void GCModelConfigElement_AttachedModel::SetParent(GCModelConfigElement value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCModelConfigElement_AttachedModel(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCModelConfigElement_AttachedModel>("CModelConfigElement_AttachedModel")
        .addConstructor<void (*)(std::string)>()
        .addProperty("InstanceName", &GCModelConfigElement_AttachedModel::GetInstanceName, &GCModelConfigElement_AttachedModel::SetInstanceName)
        .addProperty("EntityClass", &GCModelConfigElement_AttachedModel::GetEntityClass, &GCModelConfigElement_AttachedModel::SetEntityClass)
        .addProperty("Offset", &GCModelConfigElement_AttachedModel::GetOffset, &GCModelConfigElement_AttachedModel::SetOffset)
        .addProperty("AngOffset", &GCModelConfigElement_AttachedModel::GetAngOffset, &GCModelConfigElement_AttachedModel::SetAngOffset)
        .addProperty("AttachmentName", &GCModelConfigElement_AttachedModel::GetAttachmentName, &GCModelConfigElement_AttachedModel::SetAttachmentName)
        .addProperty("LocalAttachmentOffsetName", &GCModelConfigElement_AttachedModel::GetLocalAttachmentOffsetName, &GCModelConfigElement_AttachedModel::SetLocalAttachmentOffsetName)
        .addProperty("AttachmentType", &GCModelConfigElement_AttachedModel::GetAttachmentType, &GCModelConfigElement_AttachedModel::SetAttachmentType)
        .addProperty("BoneMergeFlex", &GCModelConfigElement_AttachedModel::GetBoneMergeFlex, &GCModelConfigElement_AttachedModel::SetBoneMergeFlex)
        .addProperty("UserSpecifiedColor", &GCModelConfigElement_AttachedModel::GetUserSpecifiedColor, &GCModelConfigElement_AttachedModel::SetUserSpecifiedColor)
        .addProperty("UserSpecifiedMaterialGroup", &GCModelConfigElement_AttachedModel::GetUserSpecifiedMaterialGroup, &GCModelConfigElement_AttachedModel::SetUserSpecifiedMaterialGroup)
        .addProperty("AcceptParentMaterialDrivenDecals", &GCModelConfigElement_AttachedModel::GetAcceptParentMaterialDrivenDecals, &GCModelConfigElement_AttachedModel::SetAcceptParentMaterialDrivenDecals)
        .addProperty("BodygroupOnOtherModels", &GCModelConfigElement_AttachedModel::GetBodygroupOnOtherModels, &GCModelConfigElement_AttachedModel::SetBodygroupOnOtherModels)
        .addProperty("MaterialGroupOnOtherModels", &GCModelConfigElement_AttachedModel::GetMaterialGroupOnOtherModels, &GCModelConfigElement_AttachedModel::SetMaterialGroupOnOtherModels)
        .addProperty("Parent", &GCModelConfigElement_AttachedModel::GetParent, &GCModelConfigElement_AttachedModel::SetParent)
        .addFunction("ToPtr", &GCModelConfigElement_AttachedModel::ToPtr)
        .addFunction("IsValid", &GCModelConfigElement_AttachedModel::IsValid)
        .endClass();
}
GCFollowAttachmentUpdateNode::GCFollowAttachmentUpdateNode(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCFollowAttachmentUpdateNode::GCFollowAttachmentUpdateNode(void *ptr) {
    m_ptr = ptr;
}
GFollowAttachmentSettings_t GCFollowAttachmentUpdateNode::GetOpFixedData() const {
    GFollowAttachmentSettings_t value(GetSchemaPtr(m_ptr, "CFollowAttachmentUpdateNode", "m_opFixedData"));
    return value;
}
void GCFollowAttachmentUpdateNode::SetOpFixedData(GFollowAttachmentSettings_t value) {
    SetSchemaValue(m_ptr, "CFollowAttachmentUpdateNode", "m_opFixedData", false, value);
}
std::string GCFollowAttachmentUpdateNode::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCFollowAttachmentUpdateNode::IsValid() {
    return (m_ptr != nullptr);
}
GCUnaryUpdateNode GCFollowAttachmentUpdateNode::GetParent() const {
    GCUnaryUpdateNode value(m_ptr);
    return value;
}
void GCFollowAttachmentUpdateNode::SetParent(GCUnaryUpdateNode value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCFollowAttachmentUpdateNode(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCFollowAttachmentUpdateNode>("CFollowAttachmentUpdateNode")
        .addConstructor<void (*)(std::string)>()
        .addProperty("OpFixedData", &GCFollowAttachmentUpdateNode::GetOpFixedData, &GCFollowAttachmentUpdateNode::SetOpFixedData)
        .addProperty("Parent", &GCFollowAttachmentUpdateNode::GetParent, &GCFollowAttachmentUpdateNode::SetParent)
        .addFunction("ToPtr", &GCFollowAttachmentUpdateNode::ToPtr)
        .addFunction("IsValid", &GCFollowAttachmentUpdateNode::IsValid)
        .endClass();
}
GParticleChildrenInfo_t::GParticleChildrenInfo_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GParticleChildrenInfo_t::GParticleChildrenInfo_t(void *ptr) {
    m_ptr = ptr;
}
float GParticleChildrenInfo_t::GetDelay() const {
    return GetSchemaValue<float>(m_ptr, "ParticleChildrenInfo_t", "m_flDelay");
}
void GParticleChildrenInfo_t::SetDelay(float value) {
    SetSchemaValue(m_ptr, "ParticleChildrenInfo_t", "m_flDelay", true, value);
}
bool GParticleChildrenInfo_t::GetEndCap() const {
    return GetSchemaValue<bool>(m_ptr, "ParticleChildrenInfo_t", "m_bEndCap");
}
void GParticleChildrenInfo_t::SetEndCap(bool value) {
    SetSchemaValue(m_ptr, "ParticleChildrenInfo_t", "m_bEndCap", true, value);
}
bool GParticleChildrenInfo_t::GetDisableChild() const {
    return GetSchemaValue<bool>(m_ptr, "ParticleChildrenInfo_t", "m_bDisableChild");
}
void GParticleChildrenInfo_t::SetDisableChild(bool value) {
    SetSchemaValue(m_ptr, "ParticleChildrenInfo_t", "m_bDisableChild", true, value);
}
uint64_t GParticleChildrenInfo_t::GetDetailLevel() const {
    return GetSchemaValue<uint64_t>(m_ptr, "ParticleChildrenInfo_t", "m_nDetailLevel");
}
void GParticleChildrenInfo_t::SetDetailLevel(uint64_t value) {
    SetSchemaValue(m_ptr, "ParticleChildrenInfo_t", "m_nDetailLevel", true, value);
}
std::string GParticleChildrenInfo_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GParticleChildrenInfo_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassParticleChildrenInfo_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GParticleChildrenInfo_t>("ParticleChildrenInfo_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Delay", &GParticleChildrenInfo_t::GetDelay, &GParticleChildrenInfo_t::SetDelay)
        .addProperty("EndCap", &GParticleChildrenInfo_t::GetEndCap, &GParticleChildrenInfo_t::SetEndCap)
        .addProperty("DisableChild", &GParticleChildrenInfo_t::GetDisableChild, &GParticleChildrenInfo_t::SetDisableChild)
        .addProperty("DetailLevel", &GParticleChildrenInfo_t::GetDetailLevel, &GParticleChildrenInfo_t::SetDetailLevel)
        .addFunction("ToPtr", &GParticleChildrenInfo_t::ToPtr)
        .addFunction("IsValid", &GParticleChildrenInfo_t::IsValid)
        .endClass();
}
GCVoiceContainerNull::GCVoiceContainerNull(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCVoiceContainerNull::GCVoiceContainerNull(void *ptr) {
    m_ptr = ptr;
}
std::string GCVoiceContainerNull::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCVoiceContainerNull::IsValid() {
    return (m_ptr != nullptr);
}
GCVoiceContainerBase GCVoiceContainerNull::GetParent() const {
    GCVoiceContainerBase value(m_ptr);
    return value;
}
void GCVoiceContainerNull::SetParent(GCVoiceContainerBase value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCVoiceContainerNull(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCVoiceContainerNull>("CVoiceContainerNull")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCVoiceContainerNull::GetParent, &GCVoiceContainerNull::SetParent)
        .addFunction("ToPtr", &GCVoiceContainerNull::ToPtr)
        .addFunction("IsValid", &GCVoiceContainerNull::IsValid)
        .endClass();
}
GMoodAnimation_t::GMoodAnimation_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GMoodAnimation_t::GMoodAnimation_t(void *ptr) {
    m_ptr = ptr;
}
std::string GMoodAnimation_t::GetName() const {
    return GetSchemaValue<CUtlString>(m_ptr, "MoodAnimation_t", "m_sName").Get();
}
void GMoodAnimation_t::SetName(std::string value) {
    SetSchemaValue(m_ptr, "MoodAnimation_t", "m_sName", true, CUtlString(value.c_str()));
}
float GMoodAnimation_t::GetWeight() const {
    return GetSchemaValue<float>(m_ptr, "MoodAnimation_t", "m_flWeight");
}
void GMoodAnimation_t::SetWeight(float value) {
    SetSchemaValue(m_ptr, "MoodAnimation_t", "m_flWeight", true, value);
}
std::string GMoodAnimation_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GMoodAnimation_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassMoodAnimation_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GMoodAnimation_t>("MoodAnimation_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Name", &GMoodAnimation_t::GetName, &GMoodAnimation_t::SetName)
        .addProperty("Weight", &GMoodAnimation_t::GetWeight, &GMoodAnimation_t::SetWeight)
        .addFunction("ToPtr", &GMoodAnimation_t::ToPtr)
        .addFunction("IsValid", &GMoodAnimation_t::IsValid)
        .endClass();
}
GCClientAlphaProperty::GCClientAlphaProperty(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCClientAlphaProperty::GCClientAlphaProperty(void *ptr) {
    m_ptr = ptr;
}
uint8_t GCClientAlphaProperty::GetRenderFX() const {
    return GetSchemaValue<uint8_t>(m_ptr, "CClientAlphaProperty", "m_nRenderFX");
}
void GCClientAlphaProperty::SetRenderFX(uint8_t value) {
    SetSchemaValue(m_ptr, "CClientAlphaProperty", "m_nRenderFX", false, value);
}
uint8_t GCClientAlphaProperty::GetRenderMode() const {
    return GetSchemaValue<uint8_t>(m_ptr, "CClientAlphaProperty", "m_nRenderMode");
}
void GCClientAlphaProperty::SetRenderMode(uint8_t value) {
    SetSchemaValue(m_ptr, "CClientAlphaProperty", "m_nRenderMode", false, value);
}
uint8_t GCClientAlphaProperty::GetAlpha() const {
    return GetSchemaValue<uint8_t>(m_ptr, "CClientAlphaProperty", "m_nAlpha");
}
void GCClientAlphaProperty::SetAlpha(uint8_t value) {
    SetSchemaValue(m_ptr, "CClientAlphaProperty", "m_nAlpha", false, value);
}
uint16_t GCClientAlphaProperty::GetDesyncOffset() const {
    return GetSchemaValue<uint16_t>(m_ptr, "CClientAlphaProperty", "m_nDesyncOffset");
}
void GCClientAlphaProperty::SetDesyncOffset(uint16_t value) {
    SetSchemaValue(m_ptr, "CClientAlphaProperty", "m_nDesyncOffset", false, value);
}
uint16_t GCClientAlphaProperty::GetReserved2() const {
    return GetSchemaValue<uint16_t>(m_ptr, "CClientAlphaProperty", "m_nReserved2");
}
void GCClientAlphaProperty::SetReserved2(uint16_t value) {
    SetSchemaValue(m_ptr, "CClientAlphaProperty", "m_nReserved2", false, value);
}
uint16_t GCClientAlphaProperty::GetDistFadeStart() const {
    return GetSchemaValue<uint16_t>(m_ptr, "CClientAlphaProperty", "m_nDistFadeStart");
}
void GCClientAlphaProperty::SetDistFadeStart(uint16_t value) {
    SetSchemaValue(m_ptr, "CClientAlphaProperty", "m_nDistFadeStart", false, value);
}
uint16_t GCClientAlphaProperty::GetDistFadeEnd() const {
    return GetSchemaValue<uint16_t>(m_ptr, "CClientAlphaProperty", "m_nDistFadeEnd");
}
void GCClientAlphaProperty::SetDistFadeEnd(uint16_t value) {
    SetSchemaValue(m_ptr, "CClientAlphaProperty", "m_nDistFadeEnd", false, value);
}
float GCClientAlphaProperty::GetFadeScale() const {
    return GetSchemaValue<float>(m_ptr, "CClientAlphaProperty", "m_flFadeScale");
}
void GCClientAlphaProperty::SetFadeScale(float value) {
    SetSchemaValue(m_ptr, "CClientAlphaProperty", "m_flFadeScale", false, value);
}
float GCClientAlphaProperty::GetRenderFxStartTime() const {
    return GetSchemaValue<float>(m_ptr, "CClientAlphaProperty", "m_flRenderFxStartTime");
}
void GCClientAlphaProperty::SetRenderFxStartTime(float value) {
    SetSchemaValue(m_ptr, "CClientAlphaProperty", "m_flRenderFxStartTime", false, value);
}
float GCClientAlphaProperty::GetRenderFxDuration() const {
    return GetSchemaValue<float>(m_ptr, "CClientAlphaProperty", "m_flRenderFxDuration");
}
void GCClientAlphaProperty::SetRenderFxDuration(float value) {
    SetSchemaValue(m_ptr, "CClientAlphaProperty", "m_flRenderFxDuration", false, value);
}
std::string GCClientAlphaProperty::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCClientAlphaProperty::IsValid() {
    return (m_ptr != nullptr);
}
GIClientAlphaProperty GCClientAlphaProperty::GetParent() const {
    GIClientAlphaProperty value(m_ptr);
    return value;
}
void GCClientAlphaProperty::SetParent(GIClientAlphaProperty value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCClientAlphaProperty(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCClientAlphaProperty>("CClientAlphaProperty")
        .addConstructor<void (*)(std::string)>()
        .addProperty("RenderFX", &GCClientAlphaProperty::GetRenderFX, &GCClientAlphaProperty::SetRenderFX)
        .addProperty("RenderMode", &GCClientAlphaProperty::GetRenderMode, &GCClientAlphaProperty::SetRenderMode)
        .addProperty("Alpha", &GCClientAlphaProperty::GetAlpha, &GCClientAlphaProperty::SetAlpha)
        .addProperty("DesyncOffset", &GCClientAlphaProperty::GetDesyncOffset, &GCClientAlphaProperty::SetDesyncOffset)
        .addProperty("Reserved2", &GCClientAlphaProperty::GetReserved2, &GCClientAlphaProperty::SetReserved2)
        .addProperty("DistFadeStart", &GCClientAlphaProperty::GetDistFadeStart, &GCClientAlphaProperty::SetDistFadeStart)
        .addProperty("DistFadeEnd", &GCClientAlphaProperty::GetDistFadeEnd, &GCClientAlphaProperty::SetDistFadeEnd)
        .addProperty("FadeScale", &GCClientAlphaProperty::GetFadeScale, &GCClientAlphaProperty::SetFadeScale)
        .addProperty("RenderFxStartTime", &GCClientAlphaProperty::GetRenderFxStartTime, &GCClientAlphaProperty::SetRenderFxStartTime)
        .addProperty("RenderFxDuration", &GCClientAlphaProperty::GetRenderFxDuration, &GCClientAlphaProperty::SetRenderFxDuration)
        .addProperty("Parent", &GCClientAlphaProperty::GetParent, &GCClientAlphaProperty::SetParent)
        .addFunction("ToPtr", &GCClientAlphaProperty::ToPtr)
        .addFunction("IsValid", &GCClientAlphaProperty::IsValid)
        .endClass();
}
GCTimeRemainingMetricEvaluator::GCTimeRemainingMetricEvaluator(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCTimeRemainingMetricEvaluator::GCTimeRemainingMetricEvaluator(void *ptr) {
    m_ptr = ptr;
}
bool GCTimeRemainingMetricEvaluator::GetMatchByTimeRemaining() const {
    return GetSchemaValue<bool>(m_ptr, "CTimeRemainingMetricEvaluator", "m_bMatchByTimeRemaining");
}
void GCTimeRemainingMetricEvaluator::SetMatchByTimeRemaining(bool value) {
    SetSchemaValue(m_ptr, "CTimeRemainingMetricEvaluator", "m_bMatchByTimeRemaining", false, value);
}
float GCTimeRemainingMetricEvaluator::GetMaxTimeRemaining() const {
    return GetSchemaValue<float>(m_ptr, "CTimeRemainingMetricEvaluator", "m_flMaxTimeRemaining");
}
void GCTimeRemainingMetricEvaluator::SetMaxTimeRemaining(float value) {
    SetSchemaValue(m_ptr, "CTimeRemainingMetricEvaluator", "m_flMaxTimeRemaining", false, value);
}
bool GCTimeRemainingMetricEvaluator::GetFilterByTimeRemaining() const {
    return GetSchemaValue<bool>(m_ptr, "CTimeRemainingMetricEvaluator", "m_bFilterByTimeRemaining");
}
void GCTimeRemainingMetricEvaluator::SetFilterByTimeRemaining(bool value) {
    SetSchemaValue(m_ptr, "CTimeRemainingMetricEvaluator", "m_bFilterByTimeRemaining", false, value);
}
float GCTimeRemainingMetricEvaluator::GetMinTimeRemaining() const {
    return GetSchemaValue<float>(m_ptr, "CTimeRemainingMetricEvaluator", "m_flMinTimeRemaining");
}
void GCTimeRemainingMetricEvaluator::SetMinTimeRemaining(float value) {
    SetSchemaValue(m_ptr, "CTimeRemainingMetricEvaluator", "m_flMinTimeRemaining", false, value);
}
std::string GCTimeRemainingMetricEvaluator::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCTimeRemainingMetricEvaluator::IsValid() {
    return (m_ptr != nullptr);
}
GCMotionMetricEvaluator GCTimeRemainingMetricEvaluator::GetParent() const {
    GCMotionMetricEvaluator value(m_ptr);
    return value;
}
void GCTimeRemainingMetricEvaluator::SetParent(GCMotionMetricEvaluator value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCTimeRemainingMetricEvaluator(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCTimeRemainingMetricEvaluator>("CTimeRemainingMetricEvaluator")
        .addConstructor<void (*)(std::string)>()
        .addProperty("MatchByTimeRemaining", &GCTimeRemainingMetricEvaluator::GetMatchByTimeRemaining, &GCTimeRemainingMetricEvaluator::SetMatchByTimeRemaining)
        .addProperty("MaxTimeRemaining", &GCTimeRemainingMetricEvaluator::GetMaxTimeRemaining, &GCTimeRemainingMetricEvaluator::SetMaxTimeRemaining)
        .addProperty("FilterByTimeRemaining", &GCTimeRemainingMetricEvaluator::GetFilterByTimeRemaining, &GCTimeRemainingMetricEvaluator::SetFilterByTimeRemaining)
        .addProperty("MinTimeRemaining", &GCTimeRemainingMetricEvaluator::GetMinTimeRemaining, &GCTimeRemainingMetricEvaluator::SetMinTimeRemaining)
        .addProperty("Parent", &GCTimeRemainingMetricEvaluator::GetParent, &GCTimeRemainingMetricEvaluator::SetParent)
        .addFunction("ToPtr", &GCTimeRemainingMetricEvaluator::ToPtr)
        .addFunction("IsValid", &GCTimeRemainingMetricEvaluator::IsValid)
        .endClass();
}
GNmSyncTrackTimeRange_t::GNmSyncTrackTimeRange_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GNmSyncTrackTimeRange_t::GNmSyncTrackTimeRange_t(void *ptr) {
    m_ptr = ptr;
}
GNmSyncTrackTime_t GNmSyncTrackTimeRange_t::GetStartTime() const {
    GNmSyncTrackTime_t value(GetSchemaPtr(m_ptr, "NmSyncTrackTimeRange_t", "m_startTime"));
    return value;
}
void GNmSyncTrackTimeRange_t::SetStartTime(GNmSyncTrackTime_t value) {
    SetSchemaValue(m_ptr, "NmSyncTrackTimeRange_t", "m_startTime", true, value);
}
GNmSyncTrackTime_t GNmSyncTrackTimeRange_t::GetEndTime() const {
    GNmSyncTrackTime_t value(GetSchemaPtr(m_ptr, "NmSyncTrackTimeRange_t", "m_endTime"));
    return value;
}
void GNmSyncTrackTimeRange_t::SetEndTime(GNmSyncTrackTime_t value) {
    SetSchemaValue(m_ptr, "NmSyncTrackTimeRange_t", "m_endTime", true, value);
}
std::string GNmSyncTrackTimeRange_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GNmSyncTrackTimeRange_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassNmSyncTrackTimeRange_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GNmSyncTrackTimeRange_t>("NmSyncTrackTimeRange_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("StartTime", &GNmSyncTrackTimeRange_t::GetStartTime, &GNmSyncTrackTimeRange_t::SetStartTime)
        .addProperty("EndTime", &GNmSyncTrackTimeRange_t::GetEndTime, &GNmSyncTrackTimeRange_t::SetEndTime)
        .addFunction("ToPtr", &GNmSyncTrackTimeRange_t::ToPtr)
        .addFunction("IsValid", &GNmSyncTrackTimeRange_t::IsValid)
        .endClass();
}
GCAnimActivity::GCAnimActivity(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCAnimActivity::GCAnimActivity(void *ptr) {
    m_ptr = ptr;
}
CBufferString GCAnimActivity::GetName() const {
    return GetSchemaValue<CBufferString>(m_ptr, "CAnimActivity", "m_name");
}
void GCAnimActivity::SetName(CBufferString value) {
    SetSchemaValue(m_ptr, "CAnimActivity", "m_name", false, value);
}
int32_t GCAnimActivity::GetActivity() const {
    return GetSchemaValue<int32_t>(m_ptr, "CAnimActivity", "m_nActivity");
}
void GCAnimActivity::SetActivity(int32_t value) {
    SetSchemaValue(m_ptr, "CAnimActivity", "m_nActivity", false, value);
}
int32_t GCAnimActivity::GetFlags() const {
    return GetSchemaValue<int32_t>(m_ptr, "CAnimActivity", "m_nFlags");
}
void GCAnimActivity::SetFlags(int32_t value) {
    SetSchemaValue(m_ptr, "CAnimActivity", "m_nFlags", false, value);
}
int32_t GCAnimActivity::GetWeight() const {
    return GetSchemaValue<int32_t>(m_ptr, "CAnimActivity", "m_nWeight");
}
void GCAnimActivity::SetWeight(int32_t value) {
    SetSchemaValue(m_ptr, "CAnimActivity", "m_nWeight", false, value);
}
std::string GCAnimActivity::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCAnimActivity::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCAnimActivity(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCAnimActivity>("CAnimActivity")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Name", &GCAnimActivity::GetName, &GCAnimActivity::SetName)
        .addProperty("Activity", &GCAnimActivity::GetActivity, &GCAnimActivity::SetActivity)
        .addProperty("Flags", &GCAnimActivity::GetFlags, &GCAnimActivity::SetFlags)
        .addProperty("Weight", &GCAnimActivity::GetWeight, &GCAnimActivity::SetWeight)
        .addFunction("ToPtr", &GCAnimActivity::ToPtr)
        .addFunction("IsValid", &GCAnimActivity::IsValid)
        .endClass();
}
GCNmGraphDefinition::GCNmGraphDefinition(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCNmGraphDefinition::GCNmGraphDefinition(void *ptr) {
    m_ptr = ptr;
}
std::vector<int16> GCNmGraphDefinition::GetPersistentNodeIndices() const {
    CUtlVector<int16>* vec = GetSchemaValue<CUtlVector<int16>*>(m_ptr, "CNmGraphDefinition", "m_persistentNodeIndices"); std::vector<int16> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCNmGraphDefinition::SetPersistentNodeIndices(std::vector<int16> value) {
    SetSchemaValueCUtlVector<int16>(m_ptr, "CNmGraphDefinition", "m_persistentNodeIndices", false, value);
}
int16_t GCNmGraphDefinition::GetRootNodeIdx() const {
    return GetSchemaValue<int16_t>(m_ptr, "CNmGraphDefinition", "m_nRootNodeIdx");
}
void GCNmGraphDefinition::SetRootNodeIdx(int16_t value) {
    SetSchemaValue(m_ptr, "CNmGraphDefinition", "m_nRootNodeIdx", false, value);
}
std::vector<int16> GCNmGraphDefinition::GetVirtualParameterNodeIndices() const {
    CUtlVector<int16>* vec = GetSchemaValue<CUtlVector<int16>*>(m_ptr, "CNmGraphDefinition", "m_virtualParameterNodeIndices"); std::vector<int16> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCNmGraphDefinition::SetVirtualParameterNodeIndices(std::vector<int16> value) {
    SetSchemaValueCUtlVector<int16>(m_ptr, "CNmGraphDefinition", "m_virtualParameterNodeIndices", false, value);
}
std::vector<GCNmGraphDefinition> GCNmGraphDefinition::GetChildGraphSlots() const {
    CUtlVector<GCNmGraphDefinition>* vec = GetSchemaValue<CUtlVector<GCNmGraphDefinition>*>(m_ptr, "CNmGraphDefinition", "m_childGraphSlots"); std::vector<GCNmGraphDefinition> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCNmGraphDefinition::SetChildGraphSlots(std::vector<GCNmGraphDefinition> value) {
    SetSchemaValueCUtlVector<GCNmGraphDefinition>(m_ptr, "CNmGraphDefinition", "m_childGraphSlots", false, value);
}
std::vector<GCNmGraphDefinition> GCNmGraphDefinition::GetExternalGraphSlots() const {
    CUtlVector<GCNmGraphDefinition>* vec = GetSchemaValue<CUtlVector<GCNmGraphDefinition>*>(m_ptr, "CNmGraphDefinition", "m_externalGraphSlots"); std::vector<GCNmGraphDefinition> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCNmGraphDefinition::SetExternalGraphSlots(std::vector<GCNmGraphDefinition> value) {
    SetSchemaValueCUtlVector<GCNmGraphDefinition>(m_ptr, "CNmGraphDefinition", "m_externalGraphSlots", false, value);
}
std::string GCNmGraphDefinition::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCNmGraphDefinition::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCNmGraphDefinition(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCNmGraphDefinition>("CNmGraphDefinition")
        .addConstructor<void (*)(std::string)>()
        .addProperty("PersistentNodeIndices", &GCNmGraphDefinition::GetPersistentNodeIndices, &GCNmGraphDefinition::SetPersistentNodeIndices)
        .addProperty("RootNodeIdx", &GCNmGraphDefinition::GetRootNodeIdx, &GCNmGraphDefinition::SetRootNodeIdx)
        .addProperty("VirtualParameterNodeIndices", &GCNmGraphDefinition::GetVirtualParameterNodeIndices, &GCNmGraphDefinition::SetVirtualParameterNodeIndices)
        .addProperty("ChildGraphSlots", &GCNmGraphDefinition::GetChildGraphSlots, &GCNmGraphDefinition::SetChildGraphSlots)
        .addProperty("ExternalGraphSlots", &GCNmGraphDefinition::GetExternalGraphSlots, &GCNmGraphDefinition::SetExternalGraphSlots)
        .addFunction("ToPtr", &GCNmGraphDefinition::ToPtr)
        .addFunction("IsValid", &GCNmGraphDefinition::IsValid)
        .endClass();
}
GCSolveIKChainUpdateNode::GCSolveIKChainUpdateNode(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCSolveIKChainUpdateNode::GCSolveIKChainUpdateNode(void *ptr) {
    m_ptr = ptr;
}
std::vector<GCSolveIKTargetHandle_t> GCSolveIKChainUpdateNode::GetTargetHandles() const {
    CUtlVector<GCSolveIKTargetHandle_t>* vec = GetSchemaValue<CUtlVector<GCSolveIKTargetHandle_t>*>(m_ptr, "CSolveIKChainUpdateNode", "m_targetHandles"); std::vector<GCSolveIKTargetHandle_t> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCSolveIKChainUpdateNode::SetTargetHandles(std::vector<GCSolveIKTargetHandle_t> value) {
    SetSchemaValueCUtlVector<GCSolveIKTargetHandle_t>(m_ptr, "CSolveIKChainUpdateNode", "m_targetHandles", false, value);
}
GSolveIKChainPoseOpFixedSettings_t GCSolveIKChainUpdateNode::GetOpFixedData() const {
    GSolveIKChainPoseOpFixedSettings_t value(GetSchemaPtr(m_ptr, "CSolveIKChainUpdateNode", "m_opFixedData"));
    return value;
}
void GCSolveIKChainUpdateNode::SetOpFixedData(GSolveIKChainPoseOpFixedSettings_t value) {
    SetSchemaValue(m_ptr, "CSolveIKChainUpdateNode", "m_opFixedData", false, value);
}
std::string GCSolveIKChainUpdateNode::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCSolveIKChainUpdateNode::IsValid() {
    return (m_ptr != nullptr);
}
GCUnaryUpdateNode GCSolveIKChainUpdateNode::GetParent() const {
    GCUnaryUpdateNode value(m_ptr);
    return value;
}
void GCSolveIKChainUpdateNode::SetParent(GCUnaryUpdateNode value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCSolveIKChainUpdateNode(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCSolveIKChainUpdateNode>("CSolveIKChainUpdateNode")
        .addConstructor<void (*)(std::string)>()
        .addProperty("TargetHandles", &GCSolveIKChainUpdateNode::GetTargetHandles, &GCSolveIKChainUpdateNode::SetTargetHandles)
        .addProperty("OpFixedData", &GCSolveIKChainUpdateNode::GetOpFixedData, &GCSolveIKChainUpdateNode::SetOpFixedData)
        .addProperty("Parent", &GCSolveIKChainUpdateNode::GetParent, &GCSolveIKChainUpdateNode::SetParent)
        .addFunction("ToPtr", &GCSolveIKChainUpdateNode::ToPtr)
        .addFunction("IsValid", &GCSolveIKChainUpdateNode::IsValid)
        .endClass();
}
GEventClientPollNetworking_t::GEventClientPollNetworking_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GEventClientPollNetworking_t::GEventClientPollNetworking_t(void *ptr) {
    m_ptr = ptr;
}
int32_t GEventClientPollNetworking_t::GetTickCount() const {
    return GetSchemaValue<int32_t>(m_ptr, "EventClientPollNetworking_t", "m_nTickCount");
}
void GEventClientPollNetworking_t::SetTickCount(int32_t value) {
    SetSchemaValue(m_ptr, "EventClientPollNetworking_t", "m_nTickCount", true, value);
}
std::string GEventClientPollNetworking_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GEventClientPollNetworking_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassEventClientPollNetworking_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GEventClientPollNetworking_t>("EventClientPollNetworking_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("TickCount", &GEventClientPollNetworking_t::GetTickCount, &GEventClientPollNetworking_t::SetTickCount)
        .addFunction("ToPtr", &GEventClientPollNetworking_t::ToPtr)
        .addFunction("IsValid", &GEventClientPollNetworking_t::IsValid)
        .endClass();
}
GCMeshletDescriptor::GCMeshletDescriptor(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCMeshletDescriptor::GCMeshletDescriptor(void *ptr) {
    m_ptr = ptr;
}
GCDrawCullingData GCMeshletDescriptor::GetCullingData() const {
    GCDrawCullingData value(GetSchemaPtr(m_ptr, "CMeshletDescriptor", "m_CullingData"));
    return value;
}
void GCMeshletDescriptor::SetCullingData(GCDrawCullingData value) {
    SetSchemaValue(m_ptr, "CMeshletDescriptor", "m_CullingData", false, value);
}
std::string GCMeshletDescriptor::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCMeshletDescriptor::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCMeshletDescriptor(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCMeshletDescriptor>("CMeshletDescriptor")
        .addConstructor<void (*)(std::string)>()
        .addProperty("CullingData", &GCMeshletDescriptor::GetCullingData, &GCMeshletDescriptor::SetCullingData)
        .addFunction("ToPtr", &GCMeshletDescriptor::ToPtr)
        .addFunction("IsValid", &GCMeshletDescriptor::IsValid)
        .endClass();
}
GCNmLayerBlendNode__LayerDefinition_t::GCNmLayerBlendNode__LayerDefinition_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCNmLayerBlendNode__LayerDefinition_t::GCNmLayerBlendNode__LayerDefinition_t(void *ptr) {
    m_ptr = ptr;
}
int16_t GCNmLayerBlendNode__LayerDefinition_t::GetInputNodeIdx() const {
    return GetSchemaValue<int16_t>(m_ptr, "CNmLayerBlendNode__LayerDefinition_t", "m_nInputNodeIdx");
}
void GCNmLayerBlendNode__LayerDefinition_t::SetInputNodeIdx(int16_t value) {
    SetSchemaValue(m_ptr, "CNmLayerBlendNode__LayerDefinition_t", "m_nInputNodeIdx", true, value);
}
int16_t GCNmLayerBlendNode__LayerDefinition_t::GetWeightValueNodeIdx() const {
    return GetSchemaValue<int16_t>(m_ptr, "CNmLayerBlendNode__LayerDefinition_t", "m_nWeightValueNodeIdx");
}
void GCNmLayerBlendNode__LayerDefinition_t::SetWeightValueNodeIdx(int16_t value) {
    SetSchemaValue(m_ptr, "CNmLayerBlendNode__LayerDefinition_t", "m_nWeightValueNodeIdx", true, value);
}
int16_t GCNmLayerBlendNode__LayerDefinition_t::GetBoneMaskValueNodeIdx() const {
    return GetSchemaValue<int16_t>(m_ptr, "CNmLayerBlendNode__LayerDefinition_t", "m_nBoneMaskValueNodeIdx");
}
void GCNmLayerBlendNode__LayerDefinition_t::SetBoneMaskValueNodeIdx(int16_t value) {
    SetSchemaValue(m_ptr, "CNmLayerBlendNode__LayerDefinition_t", "m_nBoneMaskValueNodeIdx", true, value);
}
int16_t GCNmLayerBlendNode__LayerDefinition_t::GetRootMotionWeightValueNodeIdx() const {
    return GetSchemaValue<int16_t>(m_ptr, "CNmLayerBlendNode__LayerDefinition_t", "m_nRootMotionWeightValueNodeIdx");
}
void GCNmLayerBlendNode__LayerDefinition_t::SetRootMotionWeightValueNodeIdx(int16_t value) {
    SetSchemaValue(m_ptr, "CNmLayerBlendNode__LayerDefinition_t", "m_nRootMotionWeightValueNodeIdx", true, value);
}
bool GCNmLayerBlendNode__LayerDefinition_t::GetIsSynchronized() const {
    return GetSchemaValue<bool>(m_ptr, "CNmLayerBlendNode__LayerDefinition_t", "m_bIsSynchronized");
}
void GCNmLayerBlendNode__LayerDefinition_t::SetIsSynchronized(bool value) {
    SetSchemaValue(m_ptr, "CNmLayerBlendNode__LayerDefinition_t", "m_bIsSynchronized", true, value);
}
bool GCNmLayerBlendNode__LayerDefinition_t::GetIgnoreEvents() const {
    return GetSchemaValue<bool>(m_ptr, "CNmLayerBlendNode__LayerDefinition_t", "m_bIgnoreEvents");
}
void GCNmLayerBlendNode__LayerDefinition_t::SetIgnoreEvents(bool value) {
    SetSchemaValue(m_ptr, "CNmLayerBlendNode__LayerDefinition_t", "m_bIgnoreEvents", true, value);
}
bool GCNmLayerBlendNode__LayerDefinition_t::GetIsStateMachineLayer() const {
    return GetSchemaValue<bool>(m_ptr, "CNmLayerBlendNode__LayerDefinition_t", "m_bIsStateMachineLayer");
}
void GCNmLayerBlendNode__LayerDefinition_t::SetIsStateMachineLayer(bool value) {
    SetSchemaValue(m_ptr, "CNmLayerBlendNode__LayerDefinition_t", "m_bIsStateMachineLayer", true, value);
}
uint64_t GCNmLayerBlendNode__LayerDefinition_t::GetBlendMode() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CNmLayerBlendNode__LayerDefinition_t", "m_blendMode");
}
void GCNmLayerBlendNode__LayerDefinition_t::SetBlendMode(uint64_t value) {
    SetSchemaValue(m_ptr, "CNmLayerBlendNode__LayerDefinition_t", "m_blendMode", true, value);
}
std::string GCNmLayerBlendNode__LayerDefinition_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCNmLayerBlendNode__LayerDefinition_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCNmLayerBlendNode__LayerDefinition_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCNmLayerBlendNode__LayerDefinition_t>("CNmLayerBlendNode__LayerDefinition_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("InputNodeIdx", &GCNmLayerBlendNode__LayerDefinition_t::GetInputNodeIdx, &GCNmLayerBlendNode__LayerDefinition_t::SetInputNodeIdx)
        .addProperty("WeightValueNodeIdx", &GCNmLayerBlendNode__LayerDefinition_t::GetWeightValueNodeIdx, &GCNmLayerBlendNode__LayerDefinition_t::SetWeightValueNodeIdx)
        .addProperty("BoneMaskValueNodeIdx", &GCNmLayerBlendNode__LayerDefinition_t::GetBoneMaskValueNodeIdx, &GCNmLayerBlendNode__LayerDefinition_t::SetBoneMaskValueNodeIdx)
        .addProperty("RootMotionWeightValueNodeIdx", &GCNmLayerBlendNode__LayerDefinition_t::GetRootMotionWeightValueNodeIdx, &GCNmLayerBlendNode__LayerDefinition_t::SetRootMotionWeightValueNodeIdx)
        .addProperty("IsSynchronized", &GCNmLayerBlendNode__LayerDefinition_t::GetIsSynchronized, &GCNmLayerBlendNode__LayerDefinition_t::SetIsSynchronized)
        .addProperty("IgnoreEvents", &GCNmLayerBlendNode__LayerDefinition_t::GetIgnoreEvents, &GCNmLayerBlendNode__LayerDefinition_t::SetIgnoreEvents)
        .addProperty("IsStateMachineLayer", &GCNmLayerBlendNode__LayerDefinition_t::GetIsStateMachineLayer, &GCNmLayerBlendNode__LayerDefinition_t::SetIsStateMachineLayer)
        .addProperty("BlendMode", &GCNmLayerBlendNode__LayerDefinition_t::GetBlendMode, &GCNmLayerBlendNode__LayerDefinition_t::SetBlendMode)
        .addFunction("ToPtr", &GCNmLayerBlendNode__LayerDefinition_t::ToPtr)
        .addFunction("IsValid", &GCNmLayerBlendNode__LayerDefinition_t::IsValid)
        .endClass();
}
GCAnimSequenceParams::GCAnimSequenceParams(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCAnimSequenceParams::GCAnimSequenceParams(void *ptr) {
    m_ptr = ptr;
}
float GCAnimSequenceParams::GetFadeInTime() const {
    return GetSchemaValue<float>(m_ptr, "CAnimSequenceParams", "m_flFadeInTime");
}
void GCAnimSequenceParams::SetFadeInTime(float value) {
    SetSchemaValue(m_ptr, "CAnimSequenceParams", "m_flFadeInTime", false, value);
}
float GCAnimSequenceParams::GetFadeOutTime() const {
    return GetSchemaValue<float>(m_ptr, "CAnimSequenceParams", "m_flFadeOutTime");
}
void GCAnimSequenceParams::SetFadeOutTime(float value) {
    SetSchemaValue(m_ptr, "CAnimSequenceParams", "m_flFadeOutTime", false, value);
}
std::string GCAnimSequenceParams::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCAnimSequenceParams::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCAnimSequenceParams(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCAnimSequenceParams>("CAnimSequenceParams")
        .addConstructor<void (*)(std::string)>()
        .addProperty("FadeInTime", &GCAnimSequenceParams::GetFadeInTime, &GCAnimSequenceParams::SetFadeInTime)
        .addProperty("FadeOutTime", &GCAnimSequenceParams::GetFadeOutTime, &GCAnimSequenceParams::SetFadeOutTime)
        .addFunction("ToPtr", &GCAnimSequenceParams::ToPtr)
        .addFunction("IsValid", &GCAnimSequenceParams::IsValid)
        .endClass();
}
GCDemoSettingsComponentUpdater::GCDemoSettingsComponentUpdater(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCDemoSettingsComponentUpdater::GCDemoSettingsComponentUpdater(void *ptr) {
    m_ptr = ptr;
}
GCAnimDemoCaptureSettings GCDemoSettingsComponentUpdater::GetSettings() const {
    GCAnimDemoCaptureSettings value(GetSchemaPtr(m_ptr, "CDemoSettingsComponentUpdater", "m_settings"));
    return value;
}
void GCDemoSettingsComponentUpdater::SetSettings(GCAnimDemoCaptureSettings value) {
    SetSchemaValue(m_ptr, "CDemoSettingsComponentUpdater", "m_settings", false, value);
}
std::string GCDemoSettingsComponentUpdater::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCDemoSettingsComponentUpdater::IsValid() {
    return (m_ptr != nullptr);
}
GCAnimComponentUpdater GCDemoSettingsComponentUpdater::GetParent() const {
    GCAnimComponentUpdater value(m_ptr);
    return value;
}
void GCDemoSettingsComponentUpdater::SetParent(GCAnimComponentUpdater value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCDemoSettingsComponentUpdater(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCDemoSettingsComponentUpdater>("CDemoSettingsComponentUpdater")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Settings", &GCDemoSettingsComponentUpdater::GetSettings, &GCDemoSettingsComponentUpdater::SetSettings)
        .addProperty("Parent", &GCDemoSettingsComponentUpdater::GetParent, &GCDemoSettingsComponentUpdater::SetParent)
        .addFunction("ToPtr", &GCDemoSettingsComponentUpdater::ToPtr)
        .addFunction("IsValid", &GCDemoSettingsComponentUpdater::IsValid)
        .endClass();
}
GCompositeMaterialAssemblyProcedure_t::GCompositeMaterialAssemblyProcedure_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCompositeMaterialAssemblyProcedure_t::GCompositeMaterialAssemblyProcedure_t(void *ptr) {
    m_ptr = ptr;
}
std::vector<GCompositeMaterialMatchFilter_t> GCompositeMaterialAssemblyProcedure_t::GetMatchFilters() const {
    CUtlVector<GCompositeMaterialMatchFilter_t>* vec = GetSchemaValue<CUtlVector<GCompositeMaterialMatchFilter_t>*>(m_ptr, "CompositeMaterialAssemblyProcedure_t", "m_vecMatchFilters"); std::vector<GCompositeMaterialMatchFilter_t> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCompositeMaterialAssemblyProcedure_t::SetMatchFilters(std::vector<GCompositeMaterialMatchFilter_t> value) {
    SetSchemaValueCUtlVector<GCompositeMaterialMatchFilter_t>(m_ptr, "CompositeMaterialAssemblyProcedure_t", "m_vecMatchFilters", true, value);
}
std::vector<GCompositeMaterialInputContainer_t> GCompositeMaterialAssemblyProcedure_t::GetCompositeInputContainers() const {
    CUtlVector<GCompositeMaterialInputContainer_t>* vec = GetSchemaValue<CUtlVector<GCompositeMaterialInputContainer_t>*>(m_ptr, "CompositeMaterialAssemblyProcedure_t", "m_vecCompositeInputContainers"); std::vector<GCompositeMaterialInputContainer_t> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCompositeMaterialAssemblyProcedure_t::SetCompositeInputContainers(std::vector<GCompositeMaterialInputContainer_t> value) {
    SetSchemaValueCUtlVector<GCompositeMaterialInputContainer_t>(m_ptr, "CompositeMaterialAssemblyProcedure_t", "m_vecCompositeInputContainers", true, value);
}
std::vector<GCompMatPropertyMutator_t> GCompositeMaterialAssemblyProcedure_t::GetPropertyMutators() const {
    CUtlVector<GCompMatPropertyMutator_t>* vec = GetSchemaValue<CUtlVector<GCompMatPropertyMutator_t>*>(m_ptr, "CompositeMaterialAssemblyProcedure_t", "m_vecPropertyMutators"); std::vector<GCompMatPropertyMutator_t> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCompositeMaterialAssemblyProcedure_t::SetPropertyMutators(std::vector<GCompMatPropertyMutator_t> value) {
    SetSchemaValueCUtlVector<GCompMatPropertyMutator_t>(m_ptr, "CompositeMaterialAssemblyProcedure_t", "m_vecPropertyMutators", true, value);
}
std::string GCompositeMaterialAssemblyProcedure_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCompositeMaterialAssemblyProcedure_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCompositeMaterialAssemblyProcedure_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCompositeMaterialAssemblyProcedure_t>("CompositeMaterialAssemblyProcedure_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("MatchFilters", &GCompositeMaterialAssemblyProcedure_t::GetMatchFilters, &GCompositeMaterialAssemblyProcedure_t::SetMatchFilters)
        .addProperty("CompositeInputContainers", &GCompositeMaterialAssemblyProcedure_t::GetCompositeInputContainers, &GCompositeMaterialAssemblyProcedure_t::SetCompositeInputContainers)
        .addProperty("PropertyMutators", &GCompositeMaterialAssemblyProcedure_t::GetPropertyMutators, &GCompositeMaterialAssemblyProcedure_t::SetPropertyMutators)
        .addFunction("ToPtr", &GCompositeMaterialAssemblyProcedure_t::ToPtr)
        .addFunction("IsValid", &GCompositeMaterialAssemblyProcedure_t::IsValid)
        .endClass();
}
GCTaskHandshakeAnimTag::GCTaskHandshakeAnimTag(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCTaskHandshakeAnimTag::GCTaskHandshakeAnimTag(void *ptr) {
    m_ptr = ptr;
}
std::string GCTaskHandshakeAnimTag::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCTaskHandshakeAnimTag::IsValid() {
    return (m_ptr != nullptr);
}
GCHandshakeAnimTagBase GCTaskHandshakeAnimTag::GetParent() const {
    GCHandshakeAnimTagBase value(m_ptr);
    return value;
}
void GCTaskHandshakeAnimTag::SetParent(GCHandshakeAnimTagBase value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCTaskHandshakeAnimTag(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCTaskHandshakeAnimTag>("CTaskHandshakeAnimTag")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCTaskHandshakeAnimTag::GetParent, &GCTaskHandshakeAnimTag::SetParent)
        .addFunction("ToPtr", &GCTaskHandshakeAnimTag::ToPtr)
        .addFunction("IsValid", &GCTaskHandshakeAnimTag::IsValid)
        .endClass();
}
GEventClientPauseSimulate_t::GEventClientPauseSimulate_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GEventClientPauseSimulate_t::GEventClientPauseSimulate_t(void *ptr) {
    m_ptr = ptr;
}
std::string GEventClientPauseSimulate_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GEventClientPauseSimulate_t::IsValid() {
    return (m_ptr != nullptr);
}
GEventSimulate_t GEventClientPauseSimulate_t::GetParent() const {
    GEventSimulate_t value(m_ptr);
    return value;
}
void GEventClientPauseSimulate_t::SetParent(GEventSimulate_t value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassEventClientPauseSimulate_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GEventClientPauseSimulate_t>("EventClientPauseSimulate_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GEventClientPauseSimulate_t::GetParent, &GEventClientPauseSimulate_t::SetParent)
        .addFunction("ToPtr", &GEventClientPauseSimulate_t::ToPtr)
        .addFunction("IsValid", &GEventClientPauseSimulate_t::IsValid)
        .endClass();
}
GCFireOverlay::GCFireOverlay(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCFireOverlay::GCFireOverlay(void *ptr) {
    m_ptr = ptr;
}
std::vector<Vector> GCFireOverlay::GetBaseColors() const {
    Vector* outValue = GetSchemaValue<Vector*>(m_ptr, "CFireOverlay", "m_vBaseColors"); std::vector<Vector> ret; for(int i = 0; i < 4; i++) { ret.push_back(outValue[i]); } return ret;
}
void GCFireOverlay::SetBaseColors(std::vector<Vector> value) {
    Vector* outValue = GetSchemaValue<Vector*>(m_ptr, "CFireOverlay", "m_vBaseColors"); for(int i = 0; i < 4; i++) { outValue[i] = value[i]; } SetSchemaValue(m_ptr, "CFireOverlay", "m_vBaseColors", false, outValue);
}
float GCFireOverlay::GetScale() const {
    return GetSchemaValue<float>(m_ptr, "CFireOverlay", "m_flScale");
}
void GCFireOverlay::SetScale(float value) {
    SetSchemaValue(m_ptr, "CFireOverlay", "m_flScale", false, value);
}
int32_t GCFireOverlay::GetGUID() const {
    return GetSchemaValue<int32_t>(m_ptr, "CFireOverlay", "m_nGUID");
}
void GCFireOverlay::SetGUID(int32_t value) {
    SetSchemaValue(m_ptr, "CFireOverlay", "m_nGUID", false, value);
}
std::string GCFireOverlay::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCFireOverlay::IsValid() {
    return (m_ptr != nullptr);
}
GCGlowOverlay GCFireOverlay::GetParent() const {
    GCGlowOverlay value(m_ptr);
    return value;
}
void GCFireOverlay::SetParent(GCGlowOverlay value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCFireOverlay(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCFireOverlay>("CFireOverlay")
        .addConstructor<void (*)(std::string)>()
        .addProperty("BaseColors", &GCFireOverlay::GetBaseColors, &GCFireOverlay::SetBaseColors)
        .addProperty("Scale", &GCFireOverlay::GetScale, &GCFireOverlay::SetScale)
        .addProperty("GUID", &GCFireOverlay::GetGUID, &GCFireOverlay::SetGUID)
        .addProperty("Parent", &GCFireOverlay::GetParent, &GCFireOverlay::SetParent)
        .addFunction("ToPtr", &GCFireOverlay::ToPtr)
        .addFunction("IsValid", &GCFireOverlay::IsValid)
        .endClass();
}
GFeBuildTaperedCapsuleRigid_t::GFeBuildTaperedCapsuleRigid_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GFeBuildTaperedCapsuleRigid_t::GFeBuildTaperedCapsuleRigid_t(void *ptr) {
    m_ptr = ptr;
}
int32_t GFeBuildTaperedCapsuleRigid_t::GetPriority() const {
    return GetSchemaValue<int32_t>(m_ptr, "FeBuildTaperedCapsuleRigid_t", "m_nPriority");
}
void GFeBuildTaperedCapsuleRigid_t::SetPriority(int32_t value) {
    SetSchemaValue(m_ptr, "FeBuildTaperedCapsuleRigid_t", "m_nPriority", true, value);
}
uint32_t GFeBuildTaperedCapsuleRigid_t::GetVertexMapHash() const {
    return GetSchemaValue<uint32_t>(m_ptr, "FeBuildTaperedCapsuleRigid_t", "m_nVertexMapHash");
}
void GFeBuildTaperedCapsuleRigid_t::SetVertexMapHash(uint32_t value) {
    SetSchemaValue(m_ptr, "FeBuildTaperedCapsuleRigid_t", "m_nVertexMapHash", true, value);
}
std::string GFeBuildTaperedCapsuleRigid_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GFeBuildTaperedCapsuleRigid_t::IsValid() {
    return (m_ptr != nullptr);
}
GFeTaperedCapsuleRigid_t GFeBuildTaperedCapsuleRigid_t::GetParent() const {
    GFeTaperedCapsuleRigid_t value(m_ptr);
    return value;
}
void GFeBuildTaperedCapsuleRigid_t::SetParent(GFeTaperedCapsuleRigid_t value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassFeBuildTaperedCapsuleRigid_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GFeBuildTaperedCapsuleRigid_t>("FeBuildTaperedCapsuleRigid_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Priority", &GFeBuildTaperedCapsuleRigid_t::GetPriority, &GFeBuildTaperedCapsuleRigid_t::SetPriority)
        .addProperty("VertexMapHash", &GFeBuildTaperedCapsuleRigid_t::GetVertexMapHash, &GFeBuildTaperedCapsuleRigid_t::SetVertexMapHash)
        .addProperty("Parent", &GFeBuildTaperedCapsuleRigid_t::GetParent, &GFeBuildTaperedCapsuleRigid_t::SetParent)
        .addFunction("ToPtr", &GFeBuildTaperedCapsuleRigid_t::ToPtr)
        .addFunction("IsValid", &GFeBuildTaperedCapsuleRigid_t::IsValid)
        .endClass();
}
GCStateUpdateData::GCStateUpdateData(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCStateUpdateData::GCStateUpdateData(void *ptr) {
    m_ptr = ptr;
}
std::string GCStateUpdateData::GetName() const {
    return GetSchemaValue<CUtlString>(m_ptr, "CStateUpdateData", "m_name").Get();
}
void GCStateUpdateData::SetName(std::string value) {
    SetSchemaValue(m_ptr, "CStateUpdateData", "m_name", false, CUtlString(value.c_str()));
}
GAnimScriptHandle GCStateUpdateData::GetScript() const {
    GAnimScriptHandle value(GetSchemaPtr(m_ptr, "CStateUpdateData", "m_hScript"));
    return value;
}
void GCStateUpdateData::SetScript(GAnimScriptHandle value) {
    SetSchemaValue(m_ptr, "CStateUpdateData", "m_hScript", false, value);
}
std::vector<int32> GCStateUpdateData::GetTransitionIndices() const {
    CUtlVector<int32>* vec = GetSchemaValue<CUtlVector<int32>*>(m_ptr, "CStateUpdateData", "m_transitionIndices"); std::vector<int32> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCStateUpdateData::SetTransitionIndices(std::vector<int32> value) {
    SetSchemaValueCUtlVector<int32>(m_ptr, "CStateUpdateData", "m_transitionIndices", false, value);
}
std::vector<GCStateActionUpdater> GCStateUpdateData::GetActions() const {
    CUtlVector<GCStateActionUpdater>* vec = GetSchemaValue<CUtlVector<GCStateActionUpdater>*>(m_ptr, "CStateUpdateData", "m_actions"); std::vector<GCStateActionUpdater> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCStateUpdateData::SetActions(std::vector<GCStateActionUpdater> value) {
    SetSchemaValueCUtlVector<GCStateActionUpdater>(m_ptr, "CStateUpdateData", "m_actions", false, value);
}
GAnimStateID GCStateUpdateData::GetStateID() const {
    GAnimStateID value(GetSchemaPtr(m_ptr, "CStateUpdateData", "m_stateID"));
    return value;
}
void GCStateUpdateData::SetStateID(GAnimStateID value) {
    SetSchemaValue(m_ptr, "CStateUpdateData", "m_stateID", false, value);
}
std::string GCStateUpdateData::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCStateUpdateData::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCStateUpdateData(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCStateUpdateData>("CStateUpdateData")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Name", &GCStateUpdateData::GetName, &GCStateUpdateData::SetName)
        .addProperty("Script", &GCStateUpdateData::GetScript, &GCStateUpdateData::SetScript)
        .addProperty("TransitionIndices", &GCStateUpdateData::GetTransitionIndices, &GCStateUpdateData::SetTransitionIndices)
        .addProperty("Actions", &GCStateUpdateData::GetActions, &GCStateUpdateData::SetActions)
        .addProperty("StateID", &GCStateUpdateData::GetStateID, &GCStateUpdateData::SetStateID)
        .addFunction("ToPtr", &GCStateUpdateData::ToPtr)
        .addFunction("IsValid", &GCStateUpdateData::IsValid)
        .endClass();
}
GCPhysSurfaceProperties::GCPhysSurfaceProperties(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCPhysSurfaceProperties::GCPhysSurfaceProperties(void *ptr) {
    m_ptr = ptr;
}
std::string GCPhysSurfaceProperties::GetName() const {
    return GetSchemaValue<CUtlString>(m_ptr, "CPhysSurfaceProperties", "m_name").Get();
}
void GCPhysSurfaceProperties::SetName(std::string value) {
    SetSchemaValue(m_ptr, "CPhysSurfaceProperties", "m_name", false, CUtlString(value.c_str()));
}
uint32_t GCPhysSurfaceProperties::GetNameHash() const {
    return GetSchemaValue<uint32_t>(m_ptr, "CPhysSurfaceProperties", "m_nameHash");
}
void GCPhysSurfaceProperties::SetNameHash(uint32_t value) {
    SetSchemaValue(m_ptr, "CPhysSurfaceProperties", "m_nameHash", false, value);
}
uint32_t GCPhysSurfaceProperties::GetBaseNameHash() const {
    return GetSchemaValue<uint32_t>(m_ptr, "CPhysSurfaceProperties", "m_baseNameHash");
}
void GCPhysSurfaceProperties::SetBaseNameHash(uint32_t value) {
    SetSchemaValue(m_ptr, "CPhysSurfaceProperties", "m_baseNameHash", false, value);
}
bool GCPhysSurfaceProperties::GetHidden() const {
    return GetSchemaValue<bool>(m_ptr, "CPhysSurfaceProperties", "m_bHidden");
}
void GCPhysSurfaceProperties::SetHidden(bool value) {
    SetSchemaValue(m_ptr, "CPhysSurfaceProperties", "m_bHidden", false, value);
}
std::string GCPhysSurfaceProperties::GetDescription() const {
    return GetSchemaValue<CUtlString>(m_ptr, "CPhysSurfaceProperties", "m_description").Get();
}
void GCPhysSurfaceProperties::SetDescription(std::string value) {
    SetSchemaValue(m_ptr, "CPhysSurfaceProperties", "m_description", false, CUtlString(value.c_str()));
}
GCPhysSurfacePropertiesPhysics GCPhysSurfaceProperties::GetPhysics() const {
    GCPhysSurfacePropertiesPhysics value(GetSchemaPtr(m_ptr, "CPhysSurfaceProperties", "m_physics"));
    return value;
}
void GCPhysSurfaceProperties::SetPhysics(GCPhysSurfacePropertiesPhysics value) {
    SetSchemaValue(m_ptr, "CPhysSurfaceProperties", "m_physics", false, value);
}
GCPhysSurfacePropertiesSoundNames GCPhysSurfaceProperties::GetAudioSounds() const {
    GCPhysSurfacePropertiesSoundNames value(GetSchemaPtr(m_ptr, "CPhysSurfaceProperties", "m_audioSounds"));
    return value;
}
void GCPhysSurfaceProperties::SetAudioSounds(GCPhysSurfacePropertiesSoundNames value) {
    SetSchemaValue(m_ptr, "CPhysSurfaceProperties", "m_audioSounds", false, value);
}
GCPhysSurfacePropertiesAudio GCPhysSurfaceProperties::GetAudioParams() const {
    GCPhysSurfacePropertiesAudio value(GetSchemaPtr(m_ptr, "CPhysSurfaceProperties", "m_audioParams"));
    return value;
}
void GCPhysSurfaceProperties::SetAudioParams(GCPhysSurfacePropertiesAudio value) {
    SetSchemaValue(m_ptr, "CPhysSurfaceProperties", "m_audioParams", false, value);
}
std::string GCPhysSurfaceProperties::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCPhysSurfaceProperties::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCPhysSurfaceProperties(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCPhysSurfaceProperties>("CPhysSurfaceProperties")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Name", &GCPhysSurfaceProperties::GetName, &GCPhysSurfaceProperties::SetName)
        .addProperty("NameHash", &GCPhysSurfaceProperties::GetNameHash, &GCPhysSurfaceProperties::SetNameHash)
        .addProperty("BaseNameHash", &GCPhysSurfaceProperties::GetBaseNameHash, &GCPhysSurfaceProperties::SetBaseNameHash)
        .addProperty("Hidden", &GCPhysSurfaceProperties::GetHidden, &GCPhysSurfaceProperties::SetHidden)
        .addProperty("Description", &GCPhysSurfaceProperties::GetDescription, &GCPhysSurfaceProperties::SetDescription)
        .addProperty("Physics", &GCPhysSurfaceProperties::GetPhysics, &GCPhysSurfaceProperties::SetPhysics)
        .addProperty("AudioSounds", &GCPhysSurfaceProperties::GetAudioSounds, &GCPhysSurfaceProperties::SetAudioSounds)
        .addProperty("AudioParams", &GCPhysSurfaceProperties::GetAudioParams, &GCPhysSurfaceProperties::SetAudioParams)
        .addFunction("ToPtr", &GCPhysSurfaceProperties::ToPtr)
        .addFunction("IsValid", &GCPhysSurfaceProperties::IsValid)
        .endClass();
}
GCMotionSearchNode::GCMotionSearchNode(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCMotionSearchNode::GCMotionSearchNode(void *ptr) {
    m_ptr = ptr;
}
std::vector<GCMotionSearchNode*> GCMotionSearchNode::GetChildren() const {
    CUtlVector<GCMotionSearchNode*>* vec = GetSchemaValue<CUtlVector<GCMotionSearchNode*>*>(m_ptr, "CMotionSearchNode", "m_children"); std::vector<GCMotionSearchNode*> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCMotionSearchNode::SetChildren(std::vector<GCMotionSearchNode*> value) {
    SetSchemaValueCUtlVector<GCMotionSearchNode*>(m_ptr, "CMotionSearchNode", "m_children", false, value);
}
GCVectorQuantizer GCMotionSearchNode::GetQuantizer() const {
    GCVectorQuantizer value(GetSchemaPtr(m_ptr, "CMotionSearchNode", "m_quantizer"));
    return value;
}
void GCMotionSearchNode::SetQuantizer(GCVectorQuantizer value) {
    SetSchemaValue(m_ptr, "CMotionSearchNode", "m_quantizer", false, value);
}
std::vector<int32> GCMotionSearchNode::GetSelectableSamples() const {
    CUtlVector<int32>* vec = GetSchemaValue<CUtlVector<int32>*>(m_ptr, "CMotionSearchNode", "m_selectableSamples"); std::vector<int32> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCMotionSearchNode::SetSelectableSamples(std::vector<int32> value) {
    SetSchemaValueCUtlVector<int32>(m_ptr, "CMotionSearchNode", "m_selectableSamples", false, value);
}
std::string GCMotionSearchNode::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCMotionSearchNode::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCMotionSearchNode(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCMotionSearchNode>("CMotionSearchNode")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Children", &GCMotionSearchNode::GetChildren, &GCMotionSearchNode::SetChildren)
        .addProperty("Quantizer", &GCMotionSearchNode::GetQuantizer, &GCMotionSearchNode::SetQuantizer)
        .addProperty("SelectableSamples", &GCMotionSearchNode::GetSelectableSamples, &GCMotionSearchNode::SetSelectableSamples)
        .addFunction("ToPtr", &GCMotionSearchNode::ToPtr)
        .addFunction("IsValid", &GCMotionSearchNode::IsValid)
        .endClass();
}
GVMixVocoderDesc_t::GVMixVocoderDesc_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GVMixVocoderDesc_t::GVMixVocoderDesc_t(void *ptr) {
    m_ptr = ptr;
}
int32_t GVMixVocoderDesc_t::GetBandCount() const {
    return GetSchemaValue<int32_t>(m_ptr, "VMixVocoderDesc_t", "m_nBandCount");
}
void GVMixVocoderDesc_t::SetBandCount(int32_t value) {
    SetSchemaValue(m_ptr, "VMixVocoderDesc_t", "m_nBandCount", true, value);
}
float GVMixVocoderDesc_t::GetBandwidth() const {
    return GetSchemaValue<float>(m_ptr, "VMixVocoderDesc_t", "m_flBandwidth");
}
void GVMixVocoderDesc_t::SetBandwidth(float value) {
    SetSchemaValue(m_ptr, "VMixVocoderDesc_t", "m_flBandwidth", true, value);
}
float GVMixVocoderDesc_t::GetFldBModGain() const {
    return GetSchemaValue<float>(m_ptr, "VMixVocoderDesc_t", "m_fldBModGain");
}
void GVMixVocoderDesc_t::SetFldBModGain(float value) {
    SetSchemaValue(m_ptr, "VMixVocoderDesc_t", "m_fldBModGain", true, value);
}
float GVMixVocoderDesc_t::GetFreqRangeStart() const {
    return GetSchemaValue<float>(m_ptr, "VMixVocoderDesc_t", "m_flFreqRangeStart");
}
void GVMixVocoderDesc_t::SetFreqRangeStart(float value) {
    SetSchemaValue(m_ptr, "VMixVocoderDesc_t", "m_flFreqRangeStart", true, value);
}
float GVMixVocoderDesc_t::GetFreqRangeEnd() const {
    return GetSchemaValue<float>(m_ptr, "VMixVocoderDesc_t", "m_flFreqRangeEnd");
}
void GVMixVocoderDesc_t::SetFreqRangeEnd(float value) {
    SetSchemaValue(m_ptr, "VMixVocoderDesc_t", "m_flFreqRangeEnd", true, value);
}
float GVMixVocoderDesc_t::GetFldBUnvoicedGain() const {
    return GetSchemaValue<float>(m_ptr, "VMixVocoderDesc_t", "m_fldBUnvoicedGain");
}
void GVMixVocoderDesc_t::SetFldBUnvoicedGain(float value) {
    SetSchemaValue(m_ptr, "VMixVocoderDesc_t", "m_fldBUnvoicedGain", true, value);
}
float GVMixVocoderDesc_t::GetAttackTimeMS() const {
    return GetSchemaValue<float>(m_ptr, "VMixVocoderDesc_t", "m_flAttackTimeMS");
}
void GVMixVocoderDesc_t::SetAttackTimeMS(float value) {
    SetSchemaValue(m_ptr, "VMixVocoderDesc_t", "m_flAttackTimeMS", true, value);
}
float GVMixVocoderDesc_t::GetReleaseTimeMS() const {
    return GetSchemaValue<float>(m_ptr, "VMixVocoderDesc_t", "m_flReleaseTimeMS");
}
void GVMixVocoderDesc_t::SetReleaseTimeMS(float value) {
    SetSchemaValue(m_ptr, "VMixVocoderDesc_t", "m_flReleaseTimeMS", true, value);
}
int32_t GVMixVocoderDesc_t::GetDebugBand() const {
    return GetSchemaValue<int32_t>(m_ptr, "VMixVocoderDesc_t", "m_nDebugBand");
}
void GVMixVocoderDesc_t::SetDebugBand(int32_t value) {
    SetSchemaValue(m_ptr, "VMixVocoderDesc_t", "m_nDebugBand", true, value);
}
bool GVMixVocoderDesc_t::GetPeakMode() const {
    return GetSchemaValue<bool>(m_ptr, "VMixVocoderDesc_t", "m_bPeakMode");
}
void GVMixVocoderDesc_t::SetPeakMode(bool value) {
    SetSchemaValue(m_ptr, "VMixVocoderDesc_t", "m_bPeakMode", true, value);
}
std::string GVMixVocoderDesc_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GVMixVocoderDesc_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassVMixVocoderDesc_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GVMixVocoderDesc_t>("VMixVocoderDesc_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("BandCount", &GVMixVocoderDesc_t::GetBandCount, &GVMixVocoderDesc_t::SetBandCount)
        .addProperty("Bandwidth", &GVMixVocoderDesc_t::GetBandwidth, &GVMixVocoderDesc_t::SetBandwidth)
        .addProperty("FldBModGain", &GVMixVocoderDesc_t::GetFldBModGain, &GVMixVocoderDesc_t::SetFldBModGain)
        .addProperty("FreqRangeStart", &GVMixVocoderDesc_t::GetFreqRangeStart, &GVMixVocoderDesc_t::SetFreqRangeStart)
        .addProperty("FreqRangeEnd", &GVMixVocoderDesc_t::GetFreqRangeEnd, &GVMixVocoderDesc_t::SetFreqRangeEnd)
        .addProperty("FldBUnvoicedGain", &GVMixVocoderDesc_t::GetFldBUnvoicedGain, &GVMixVocoderDesc_t::SetFldBUnvoicedGain)
        .addProperty("AttackTimeMS", &GVMixVocoderDesc_t::GetAttackTimeMS, &GVMixVocoderDesc_t::SetAttackTimeMS)
        .addProperty("ReleaseTimeMS", &GVMixVocoderDesc_t::GetReleaseTimeMS, &GVMixVocoderDesc_t::SetReleaseTimeMS)
        .addProperty("DebugBand", &GVMixVocoderDesc_t::GetDebugBand, &GVMixVocoderDesc_t::SetDebugBand)
        .addProperty("PeakMode", &GVMixVocoderDesc_t::GetPeakMode, &GVMixVocoderDesc_t::SetPeakMode)
        .addFunction("ToPtr", &GVMixVocoderDesc_t::ToPtr)
        .addFunction("IsValid", &GVMixVocoderDesc_t::IsValid)
        .endClass();
}
GCAnimScriptManager::GCAnimScriptManager(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCAnimScriptManager::GCAnimScriptManager(void *ptr) {
    m_ptr = ptr;
}
std::vector<GScriptInfo_t> GCAnimScriptManager::GetScriptInfo() const {
    CUtlVector<GScriptInfo_t>* vec = GetSchemaValue<CUtlVector<GScriptInfo_t>*>(m_ptr, "CAnimScriptManager", "m_scriptInfo"); std::vector<GScriptInfo_t> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCAnimScriptManager::SetScriptInfo(std::vector<GScriptInfo_t> value) {
    SetSchemaValueCUtlVector<GScriptInfo_t>(m_ptr, "CAnimScriptManager", "m_scriptInfo", false, value);
}
std::string GCAnimScriptManager::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCAnimScriptManager::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCAnimScriptManager(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCAnimScriptManager>("CAnimScriptManager")
        .addConstructor<void (*)(std::string)>()
        .addProperty("ScriptInfo", &GCAnimScriptManager::GetScriptInfo, &GCAnimScriptManager::SetScriptInfo)
        .addFunction("ToPtr", &GCAnimScriptManager::ToPtr)
        .addFunction("IsValid", &GCAnimScriptManager::IsValid)
        .endClass();
}
GCAnimationGraphVisualizerLine::GCAnimationGraphVisualizerLine(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCAnimationGraphVisualizerLine::GCAnimationGraphVisualizerLine(void *ptr) {
    m_ptr = ptr;
}
Vector GCAnimationGraphVisualizerLine::GetWsPositionStart() const {
    return GetSchemaValue<Vector>(m_ptr, "CAnimationGraphVisualizerLine", "m_vWsPositionStart");
}
void GCAnimationGraphVisualizerLine::SetWsPositionStart(Vector value) {
    SetSchemaValue(m_ptr, "CAnimationGraphVisualizerLine", "m_vWsPositionStart", false, value);
}
Vector GCAnimationGraphVisualizerLine::GetWsPositionEnd() const {
    return GetSchemaValue<Vector>(m_ptr, "CAnimationGraphVisualizerLine", "m_vWsPositionEnd");
}
void GCAnimationGraphVisualizerLine::SetWsPositionEnd(Vector value) {
    SetSchemaValue(m_ptr, "CAnimationGraphVisualizerLine", "m_vWsPositionEnd", false, value);
}
Color GCAnimationGraphVisualizerLine::GetColor() const {
    return GetSchemaValue<Color>(m_ptr, "CAnimationGraphVisualizerLine", "m_Color");
}
void GCAnimationGraphVisualizerLine::SetColor(Color value) {
    SetSchemaValue(m_ptr, "CAnimationGraphVisualizerLine", "m_Color", false, value);
}
std::string GCAnimationGraphVisualizerLine::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCAnimationGraphVisualizerLine::IsValid() {
    return (m_ptr != nullptr);
}
GCAnimationGraphVisualizerPrimitiveBase GCAnimationGraphVisualizerLine::GetParent() const {
    GCAnimationGraphVisualizerPrimitiveBase value(m_ptr);
    return value;
}
void GCAnimationGraphVisualizerLine::SetParent(GCAnimationGraphVisualizerPrimitiveBase value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCAnimationGraphVisualizerLine(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCAnimationGraphVisualizerLine>("CAnimationGraphVisualizerLine")
        .addConstructor<void (*)(std::string)>()
        .addProperty("WsPositionStart", &GCAnimationGraphVisualizerLine::GetWsPositionStart, &GCAnimationGraphVisualizerLine::SetWsPositionStart)
        .addProperty("WsPositionEnd", &GCAnimationGraphVisualizerLine::GetWsPositionEnd, &GCAnimationGraphVisualizerLine::SetWsPositionEnd)
        .addProperty("Color", &GCAnimationGraphVisualizerLine::GetColor, &GCAnimationGraphVisualizerLine::SetColor)
        .addProperty("Parent", &GCAnimationGraphVisualizerLine::GetParent, &GCAnimationGraphVisualizerLine::SetParent)
        .addFunction("ToPtr", &GCAnimationGraphVisualizerLine::ToPtr)
        .addFunction("IsValid", &GCAnimationGraphVisualizerLine::IsValid)
        .endClass();
}
GCFootTrajectory::GCFootTrajectory(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCFootTrajectory::GCFootTrajectory(void *ptr) {
    m_ptr = ptr;
}
Vector GCFootTrajectory::GetOffset() const {
    return GetSchemaValue<Vector>(m_ptr, "CFootTrajectory", "m_vOffset");
}
void GCFootTrajectory::SetOffset(Vector value) {
    SetSchemaValue(m_ptr, "CFootTrajectory", "m_vOffset", false, value);
}
float GCFootTrajectory::GetRotationOffset() const {
    return GetSchemaValue<float>(m_ptr, "CFootTrajectory", "m_flRotationOffset");
}
void GCFootTrajectory::SetRotationOffset(float value) {
    SetSchemaValue(m_ptr, "CFootTrajectory", "m_flRotationOffset", false, value);
}
float GCFootTrajectory::GetProgression() const {
    return GetSchemaValue<float>(m_ptr, "CFootTrajectory", "m_flProgression");
}
void GCFootTrajectory::SetProgression(float value) {
    SetSchemaValue(m_ptr, "CFootTrajectory", "m_flProgression", false, value);
}
std::string GCFootTrajectory::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCFootTrajectory::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCFootTrajectory(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCFootTrajectory>("CFootTrajectory")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Offset", &GCFootTrajectory::GetOffset, &GCFootTrajectory::SetOffset)
        .addProperty("RotationOffset", &GCFootTrajectory::GetRotationOffset, &GCFootTrajectory::SetRotationOffset)
        .addProperty("Progression", &GCFootTrajectory::GetProgression, &GCFootTrajectory::SetProgression)
        .addFunction("ToPtr", &GCFootTrajectory::ToPtr)
        .addFunction("IsValid", &GCFootTrajectory::IsValid)
        .endClass();
}
GVMixModDelayDesc_t::GVMixModDelayDesc_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GVMixModDelayDesc_t::GVMixModDelayDesc_t(void *ptr) {
    m_ptr = ptr;
}
GVMixFilterDesc_t GVMixModDelayDesc_t::GetFeedbackFilter() const {
    GVMixFilterDesc_t value(GetSchemaPtr(m_ptr, "VMixModDelayDesc_t", "m_feedbackFilter"));
    return value;
}
void GVMixModDelayDesc_t::SetFeedbackFilter(GVMixFilterDesc_t value) {
    SetSchemaValue(m_ptr, "VMixModDelayDesc_t", "m_feedbackFilter", true, value);
}
bool GVMixModDelayDesc_t::GetPhaseInvert() const {
    return GetSchemaValue<bool>(m_ptr, "VMixModDelayDesc_t", "m_bPhaseInvert");
}
void GVMixModDelayDesc_t::SetPhaseInvert(bool value) {
    SetSchemaValue(m_ptr, "VMixModDelayDesc_t", "m_bPhaseInvert", true, value);
}
float GVMixModDelayDesc_t::GetGlideTime() const {
    return GetSchemaValue<float>(m_ptr, "VMixModDelayDesc_t", "m_flGlideTime");
}
void GVMixModDelayDesc_t::SetGlideTime(float value) {
    SetSchemaValue(m_ptr, "VMixModDelayDesc_t", "m_flGlideTime", true, value);
}
float GVMixModDelayDesc_t::GetDelay() const {
    return GetSchemaValue<float>(m_ptr, "VMixModDelayDesc_t", "m_flDelay");
}
void GVMixModDelayDesc_t::SetDelay(float value) {
    SetSchemaValue(m_ptr, "VMixModDelayDesc_t", "m_flDelay", true, value);
}
float GVMixModDelayDesc_t::GetOutputGain() const {
    return GetSchemaValue<float>(m_ptr, "VMixModDelayDesc_t", "m_flOutputGain");
}
void GVMixModDelayDesc_t::SetOutputGain(float value) {
    SetSchemaValue(m_ptr, "VMixModDelayDesc_t", "m_flOutputGain", true, value);
}
float GVMixModDelayDesc_t::GetFeedbackGain() const {
    return GetSchemaValue<float>(m_ptr, "VMixModDelayDesc_t", "m_flFeedbackGain");
}
void GVMixModDelayDesc_t::SetFeedbackGain(float value) {
    SetSchemaValue(m_ptr, "VMixModDelayDesc_t", "m_flFeedbackGain", true, value);
}
float GVMixModDelayDesc_t::GetModRate() const {
    return GetSchemaValue<float>(m_ptr, "VMixModDelayDesc_t", "m_flModRate");
}
void GVMixModDelayDesc_t::SetModRate(float value) {
    SetSchemaValue(m_ptr, "VMixModDelayDesc_t", "m_flModRate", true, value);
}
float GVMixModDelayDesc_t::GetModDepth() const {
    return GetSchemaValue<float>(m_ptr, "VMixModDelayDesc_t", "m_flModDepth");
}
void GVMixModDelayDesc_t::SetModDepth(float value) {
    SetSchemaValue(m_ptr, "VMixModDelayDesc_t", "m_flModDepth", true, value);
}
bool GVMixModDelayDesc_t::GetApplyAntialiasing() const {
    return GetSchemaValue<bool>(m_ptr, "VMixModDelayDesc_t", "m_bApplyAntialiasing");
}
void GVMixModDelayDesc_t::SetApplyAntialiasing(bool value) {
    SetSchemaValue(m_ptr, "VMixModDelayDesc_t", "m_bApplyAntialiasing", true, value);
}
std::string GVMixModDelayDesc_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GVMixModDelayDesc_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassVMixModDelayDesc_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GVMixModDelayDesc_t>("VMixModDelayDesc_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("FeedbackFilter", &GVMixModDelayDesc_t::GetFeedbackFilter, &GVMixModDelayDesc_t::SetFeedbackFilter)
        .addProperty("PhaseInvert", &GVMixModDelayDesc_t::GetPhaseInvert, &GVMixModDelayDesc_t::SetPhaseInvert)
        .addProperty("GlideTime", &GVMixModDelayDesc_t::GetGlideTime, &GVMixModDelayDesc_t::SetGlideTime)
        .addProperty("Delay", &GVMixModDelayDesc_t::GetDelay, &GVMixModDelayDesc_t::SetDelay)
        .addProperty("OutputGain", &GVMixModDelayDesc_t::GetOutputGain, &GVMixModDelayDesc_t::SetOutputGain)
        .addProperty("FeedbackGain", &GVMixModDelayDesc_t::GetFeedbackGain, &GVMixModDelayDesc_t::SetFeedbackGain)
        .addProperty("ModRate", &GVMixModDelayDesc_t::GetModRate, &GVMixModDelayDesc_t::SetModRate)
        .addProperty("ModDepth", &GVMixModDelayDesc_t::GetModDepth, &GVMixModDelayDesc_t::SetModDepth)
        .addProperty("ApplyAntialiasing", &GVMixModDelayDesc_t::GetApplyAntialiasing, &GVMixModDelayDesc_t::SetApplyAntialiasing)
        .addFunction("ToPtr", &GVMixModDelayDesc_t::ToPtr)
        .addFunction("IsValid", &GVMixModDelayDesc_t::IsValid)
        .endClass();
}
GCHitBox::GCHitBox(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCHitBox::GCHitBox(void *ptr) {
    m_ptr = ptr;
}
std::string GCHitBox::GetName() const {
    return GetSchemaValue<CUtlString>(m_ptr, "CHitBox", "m_name").Get();
}
void GCHitBox::SetName(std::string value) {
    SetSchemaValue(m_ptr, "CHitBox", "m_name", false, CUtlString(value.c_str()));
}
std::string GCHitBox::GetSurfaceProperty() const {
    return GetSchemaValue<CUtlString>(m_ptr, "CHitBox", "m_sSurfaceProperty").Get();
}
void GCHitBox::SetSurfaceProperty(std::string value) {
    SetSchemaValue(m_ptr, "CHitBox", "m_sSurfaceProperty", false, CUtlString(value.c_str()));
}
std::string GCHitBox::GetBoneName() const {
    return GetSchemaValue<CUtlString>(m_ptr, "CHitBox", "m_sBoneName").Get();
}
void GCHitBox::SetBoneName(std::string value) {
    SetSchemaValue(m_ptr, "CHitBox", "m_sBoneName", false, CUtlString(value.c_str()));
}
Vector GCHitBox::GetMinBounds() const {
    return GetSchemaValue<Vector>(m_ptr, "CHitBox", "m_vMinBounds");
}
void GCHitBox::SetMinBounds(Vector value) {
    SetSchemaValue(m_ptr, "CHitBox", "m_vMinBounds", false, value);
}
Vector GCHitBox::GetMaxBounds() const {
    return GetSchemaValue<Vector>(m_ptr, "CHitBox", "m_vMaxBounds");
}
void GCHitBox::SetMaxBounds(Vector value) {
    SetSchemaValue(m_ptr, "CHitBox", "m_vMaxBounds", false, value);
}
float GCHitBox::GetShapeRadius() const {
    return GetSchemaValue<float>(m_ptr, "CHitBox", "m_flShapeRadius");
}
void GCHitBox::SetShapeRadius(float value) {
    SetSchemaValue(m_ptr, "CHitBox", "m_flShapeRadius", false, value);
}
uint32_t GCHitBox::GetBoneNameHash() const {
    return GetSchemaValue<uint32_t>(m_ptr, "CHitBox", "m_nBoneNameHash");
}
void GCHitBox::SetBoneNameHash(uint32_t value) {
    SetSchemaValue(m_ptr, "CHitBox", "m_nBoneNameHash", false, value);
}
int32_t GCHitBox::GetGroupId() const {
    return GetSchemaValue<int32_t>(m_ptr, "CHitBox", "m_nGroupId");
}
void GCHitBox::SetGroupId(int32_t value) {
    SetSchemaValue(m_ptr, "CHitBox", "m_nGroupId", false, value);
}
uint8_t GCHitBox::GetShapeType() const {
    return GetSchemaValue<uint8_t>(m_ptr, "CHitBox", "m_nShapeType");
}
void GCHitBox::SetShapeType(uint8_t value) {
    SetSchemaValue(m_ptr, "CHitBox", "m_nShapeType", false, value);
}
bool GCHitBox::GetTranslationOnly() const {
    return GetSchemaValue<bool>(m_ptr, "CHitBox", "m_bTranslationOnly");
}
void GCHitBox::SetTranslationOnly(bool value) {
    SetSchemaValue(m_ptr, "CHitBox", "m_bTranslationOnly", false, value);
}
uint32_t GCHitBox::GetCRC() const {
    return GetSchemaValue<uint32_t>(m_ptr, "CHitBox", "m_CRC");
}
void GCHitBox::SetCRC(uint32_t value) {
    SetSchemaValue(m_ptr, "CHitBox", "m_CRC", false, value);
}
Color GCHitBox::GetCRenderColor() const {
    return GetSchemaValue<Color>(m_ptr, "CHitBox", "m_cRenderColor");
}
void GCHitBox::SetCRenderColor(Color value) {
    SetSchemaValue(m_ptr, "CHitBox", "m_cRenderColor", false, value);
}
uint16_t GCHitBox::GetHitBoxIndex() const {
    return GetSchemaValue<uint16_t>(m_ptr, "CHitBox", "m_nHitBoxIndex");
}
void GCHitBox::SetHitBoxIndex(uint16_t value) {
    SetSchemaValue(m_ptr, "CHitBox", "m_nHitBoxIndex", false, value);
}
std::string GCHitBox::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCHitBox::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCHitBox(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCHitBox>("CHitBox")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Name", &GCHitBox::GetName, &GCHitBox::SetName)
        .addProperty("SurfaceProperty", &GCHitBox::GetSurfaceProperty, &GCHitBox::SetSurfaceProperty)
        .addProperty("BoneName", &GCHitBox::GetBoneName, &GCHitBox::SetBoneName)
        .addProperty("MinBounds", &GCHitBox::GetMinBounds, &GCHitBox::SetMinBounds)
        .addProperty("MaxBounds", &GCHitBox::GetMaxBounds, &GCHitBox::SetMaxBounds)
        .addProperty("ShapeRadius", &GCHitBox::GetShapeRadius, &GCHitBox::SetShapeRadius)
        .addProperty("BoneNameHash", &GCHitBox::GetBoneNameHash, &GCHitBox::SetBoneNameHash)
        .addProperty("GroupId", &GCHitBox::GetGroupId, &GCHitBox::SetGroupId)
        .addProperty("ShapeType", &GCHitBox::GetShapeType, &GCHitBox::SetShapeType)
        .addProperty("TranslationOnly", &GCHitBox::GetTranslationOnly, &GCHitBox::SetTranslationOnly)
        .addProperty("CRC", &GCHitBox::GetCRC, &GCHitBox::SetCRC)
        .addProperty("CRenderColor", &GCHitBox::GetCRenderColor, &GCHitBox::SetCRenderColor)
        .addProperty("HitBoxIndex", &GCHitBox::GetHitBoxIndex, &GCHitBox::SetHitBoxIndex)
        .addFunction("ToPtr", &GCHitBox::ToPtr)
        .addFunction("IsValid", &GCHitBox::IsValid)
        .endClass();
}
GCTestDomainDerived_Cursor::GCTestDomainDerived_Cursor(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCTestDomainDerived_Cursor::GCTestDomainDerived_Cursor(void *ptr) {
    m_ptr = ptr;
}
int32_t GCTestDomainDerived_Cursor::GetCursorValueA() const {
    return GetSchemaValue<int32_t>(m_ptr, "CTestDomainDerived_Cursor", "m_nCursorValueA");
}
void GCTestDomainDerived_Cursor::SetCursorValueA(int32_t value) {
    SetSchemaValue(m_ptr, "CTestDomainDerived_Cursor", "m_nCursorValueA", false, value);
}
int32_t GCTestDomainDerived_Cursor::GetCursorValueB() const {
    return GetSchemaValue<int32_t>(m_ptr, "CTestDomainDerived_Cursor", "m_nCursorValueB");
}
void GCTestDomainDerived_Cursor::SetCursorValueB(int32_t value) {
    SetSchemaValue(m_ptr, "CTestDomainDerived_Cursor", "m_nCursorValueB", false, value);
}
std::string GCTestDomainDerived_Cursor::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCTestDomainDerived_Cursor::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCTestDomainDerived_Cursor(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCTestDomainDerived_Cursor>("CTestDomainDerived_Cursor")
        .addConstructor<void (*)(std::string)>()
        .addProperty("CursorValueA", &GCTestDomainDerived_Cursor::GetCursorValueA, &GCTestDomainDerived_Cursor::SetCursorValueA)
        .addProperty("CursorValueB", &GCTestDomainDerived_Cursor::GetCursorValueB, &GCTestDomainDerived_Cursor::SetCursorValueB)
        .addFunction("ToPtr", &GCTestDomainDerived_Cursor::ToPtr)
        .addFunction("IsValid", &GCTestDomainDerived_Cursor::IsValid)
        .endClass();
}
GCAudioMorphData::GCAudioMorphData(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCAudioMorphData::GCAudioMorphData(void *ptr) {
    m_ptr = ptr;
}
std::vector<float32> GCAudioMorphData::GetTimes() const {
    CUtlVector<float32>* vec = GetSchemaValue<CUtlVector<float32>*>(m_ptr, "CAudioMorphData", "m_times"); std::vector<float32> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCAudioMorphData::SetTimes(std::vector<float32> value) {
    SetSchemaValueCUtlVector<float32>(m_ptr, "CAudioMorphData", "m_times", false, value);
}
std::vector<uint32> GCAudioMorphData::GetNameHashCodes() const {
    CUtlVector<uint32>* vec = GetSchemaValue<CUtlVector<uint32>*>(m_ptr, "CAudioMorphData", "m_nameHashCodes"); std::vector<uint32> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCAudioMorphData::SetNameHashCodes(std::vector<uint32> value) {
    SetSchemaValueCUtlVector<uint32>(m_ptr, "CAudioMorphData", "m_nameHashCodes", false, value);
}
std::vector<CUtlString> GCAudioMorphData::GetNameStrings() const {
    CUtlVector<CUtlString>* vec = GetSchemaValue<CUtlVector<CUtlString>*>(m_ptr, "CAudioMorphData", "m_nameStrings"); std::vector<CUtlString> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCAudioMorphData::SetNameStrings(std::vector<CUtlString> value) {
    SetSchemaValueCUtlVector<CUtlString>(m_ptr, "CAudioMorphData", "m_nameStrings", false, value);
}
float GCAudioMorphData::GetEaseIn() const {
    return GetSchemaValue<float>(m_ptr, "CAudioMorphData", "m_flEaseIn");
}
void GCAudioMorphData::SetEaseIn(float value) {
    SetSchemaValue(m_ptr, "CAudioMorphData", "m_flEaseIn", false, value);
}
float GCAudioMorphData::GetEaseOut() const {
    return GetSchemaValue<float>(m_ptr, "CAudioMorphData", "m_flEaseOut");
}
void GCAudioMorphData::SetEaseOut(float value) {
    SetSchemaValue(m_ptr, "CAudioMorphData", "m_flEaseOut", false, value);
}
std::string GCAudioMorphData::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCAudioMorphData::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCAudioMorphData(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCAudioMorphData>("CAudioMorphData")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Times", &GCAudioMorphData::GetTimes, &GCAudioMorphData::SetTimes)
        .addProperty("NameHashCodes", &GCAudioMorphData::GetNameHashCodes, &GCAudioMorphData::SetNameHashCodes)
        .addProperty("NameStrings", &GCAudioMorphData::GetNameStrings, &GCAudioMorphData::SetNameStrings)
        .addProperty("EaseIn", &GCAudioMorphData::GetEaseIn, &GCAudioMorphData::SetEaseIn)
        .addProperty("EaseOut", &GCAudioMorphData::GetEaseOut, &GCAudioMorphData::SetEaseOut)
        .addFunction("ToPtr", &GCAudioMorphData::ToPtr)
        .addFunction("IsValid", &GCAudioMorphData::IsValid)
        .endClass();
}
GCSeqIKLock::GCSeqIKLock(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCSeqIKLock::GCSeqIKLock(void *ptr) {
    m_ptr = ptr;
}
float GCSeqIKLock::GetPosWeight() const {
    return GetSchemaValue<float>(m_ptr, "CSeqIKLock", "m_flPosWeight");
}
void GCSeqIKLock::SetPosWeight(float value) {
    SetSchemaValue(m_ptr, "CSeqIKLock", "m_flPosWeight", false, value);
}
float GCSeqIKLock::GetAngleWeight() const {
    return GetSchemaValue<float>(m_ptr, "CSeqIKLock", "m_flAngleWeight");
}
void GCSeqIKLock::SetAngleWeight(float value) {
    SetSchemaValue(m_ptr, "CSeqIKLock", "m_flAngleWeight", false, value);
}
int16_t GCSeqIKLock::GetLocalBone() const {
    return GetSchemaValue<int16_t>(m_ptr, "CSeqIKLock", "m_nLocalBone");
}
void GCSeqIKLock::SetLocalBone(int16_t value) {
    SetSchemaValue(m_ptr, "CSeqIKLock", "m_nLocalBone", false, value);
}
bool GCSeqIKLock::GetBonesOrientedAlongPositiveX() const {
    return GetSchemaValue<bool>(m_ptr, "CSeqIKLock", "m_bBonesOrientedAlongPositiveX");
}
void GCSeqIKLock::SetBonesOrientedAlongPositiveX(bool value) {
    SetSchemaValue(m_ptr, "CSeqIKLock", "m_bBonesOrientedAlongPositiveX", false, value);
}
std::string GCSeqIKLock::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCSeqIKLock::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCSeqIKLock(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCSeqIKLock>("CSeqIKLock")
        .addConstructor<void (*)(std::string)>()
        .addProperty("PosWeight", &GCSeqIKLock::GetPosWeight, &GCSeqIKLock::SetPosWeight)
        .addProperty("AngleWeight", &GCSeqIKLock::GetAngleWeight, &GCSeqIKLock::SetAngleWeight)
        .addProperty("LocalBone", &GCSeqIKLock::GetLocalBone, &GCSeqIKLock::SetLocalBone)
        .addProperty("BonesOrientedAlongPositiveX", &GCSeqIKLock::GetBonesOrientedAlongPositiveX, &GCSeqIKLock::SetBonesOrientedAlongPositiveX)
        .addFunction("ToPtr", &GCSeqIKLock::ToPtr)
        .addFunction("IsValid", &GCSeqIKLock::IsValid)
        .endClass();
}
GFeQuad_t::GFeQuad_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GFeQuad_t::GFeQuad_t(void *ptr) {
    m_ptr = ptr;
}
std::vector<uint16_t> GFeQuad_t::GetNode() const {
    uint16_t* outValue = GetSchemaValue<uint16_t*>(m_ptr, "FeQuad_t", "nNode"); std::vector<uint16_t> ret; for(int i = 0; i < 4; i++) { ret.push_back(outValue[i]); } return ret;
}
void GFeQuad_t::SetNode(std::vector<uint16_t> value) {
    uint16_t* outValue = GetSchemaValue<uint16_t*>(m_ptr, "FeQuad_t", "nNode"); for(int i = 0; i < 4; i++) { outValue[i] = value[i]; } SetSchemaValue(m_ptr, "FeQuad_t", "nNode", true, outValue);
}
float GFeQuad_t::GetSlack() const {
    return GetSchemaValue<float>(m_ptr, "FeQuad_t", "flSlack");
}
void GFeQuad_t::SetSlack(float value) {
    SetSchemaValue(m_ptr, "FeQuad_t", "flSlack", true, value);
}
std::vector<Vector4D> GFeQuad_t::GetShape() const {
    Vector4D* outValue = GetSchemaValue<Vector4D*>(m_ptr, "FeQuad_t", "vShape"); std::vector<Vector4D> ret; for(int i = 0; i < 4; i++) { ret.push_back(outValue[i]); } return ret;
}
void GFeQuad_t::SetShape(std::vector<Vector4D> value) {
    Vector4D* outValue = GetSchemaValue<Vector4D*>(m_ptr, "FeQuad_t", "vShape"); for(int i = 0; i < 4; i++) { outValue[i] = value[i]; } SetSchemaValue(m_ptr, "FeQuad_t", "vShape", true, outValue);
}
std::string GFeQuad_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GFeQuad_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassFeQuad_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GFeQuad_t>("FeQuad_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Node", &GFeQuad_t::GetNode, &GFeQuad_t::SetNode)
        .addProperty("Slack", &GFeQuad_t::GetSlack, &GFeQuad_t::SetSlack)
        .addProperty("Shape", &GFeQuad_t::GetShape, &GFeQuad_t::SetShape)
        .addFunction("ToPtr", &GFeQuad_t::ToPtr)
        .addFunction("IsValid", &GFeQuad_t::IsValid)
        .endClass();
}
GCSosGroupMatchPattern::GCSosGroupMatchPattern(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCSosGroupMatchPattern::GCSosGroupMatchPattern(void *ptr) {
    m_ptr = ptr;
}
std::string GCSosGroupMatchPattern::GetMatchSoundEventName() const {
    return GetSchemaValue<CUtlString>(m_ptr, "CSosGroupMatchPattern", "m_matchSoundEventName").Get();
}
void GCSosGroupMatchPattern::SetMatchSoundEventName(std::string value) {
    SetSchemaValue(m_ptr, "CSosGroupMatchPattern", "m_matchSoundEventName", false, CUtlString(value.c_str()));
}
std::string GCSosGroupMatchPattern::GetMatchSoundEventSubString() const {
    return GetSchemaValue<CUtlString>(m_ptr, "CSosGroupMatchPattern", "m_matchSoundEventSubString").Get();
}
void GCSosGroupMatchPattern::SetMatchSoundEventSubString(std::string value) {
    SetSchemaValue(m_ptr, "CSosGroupMatchPattern", "m_matchSoundEventSubString", false, CUtlString(value.c_str()));
}
float GCSosGroupMatchPattern::GetEntIndex() const {
    return GetSchemaValue<float>(m_ptr, "CSosGroupMatchPattern", "m_flEntIndex");
}
void GCSosGroupMatchPattern::SetEntIndex(float value) {
    SetSchemaValue(m_ptr, "CSosGroupMatchPattern", "m_flEntIndex", false, value);
}
float GCSosGroupMatchPattern::GetOpvar() const {
    return GetSchemaValue<float>(m_ptr, "CSosGroupMatchPattern", "m_flOpvar");
}
void GCSosGroupMatchPattern::SetOpvar(float value) {
    SetSchemaValue(m_ptr, "CSosGroupMatchPattern", "m_flOpvar", false, value);
}
std::string GCSosGroupMatchPattern::GetOpvarString() const {
    return GetSchemaValue<CUtlString>(m_ptr, "CSosGroupMatchPattern", "m_opvarString").Get();
}
void GCSosGroupMatchPattern::SetOpvarString(std::string value) {
    SetSchemaValue(m_ptr, "CSosGroupMatchPattern", "m_opvarString", false, CUtlString(value.c_str()));
}
std::string GCSosGroupMatchPattern::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCSosGroupMatchPattern::IsValid() {
    return (m_ptr != nullptr);
}
GCSosGroupBranchPattern GCSosGroupMatchPattern::GetParent() const {
    GCSosGroupBranchPattern value(m_ptr);
    return value;
}
void GCSosGroupMatchPattern::SetParent(GCSosGroupBranchPattern value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCSosGroupMatchPattern(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCSosGroupMatchPattern>("CSosGroupMatchPattern")
        .addConstructor<void (*)(std::string)>()
        .addProperty("MatchSoundEventName", &GCSosGroupMatchPattern::GetMatchSoundEventName, &GCSosGroupMatchPattern::SetMatchSoundEventName)
        .addProperty("MatchSoundEventSubString", &GCSosGroupMatchPattern::GetMatchSoundEventSubString, &GCSosGroupMatchPattern::SetMatchSoundEventSubString)
        .addProperty("EntIndex", &GCSosGroupMatchPattern::GetEntIndex, &GCSosGroupMatchPattern::SetEntIndex)
        .addProperty("Opvar", &GCSosGroupMatchPattern::GetOpvar, &GCSosGroupMatchPattern::SetOpvar)
        .addProperty("OpvarString", &GCSosGroupMatchPattern::GetOpvarString, &GCSosGroupMatchPattern::SetOpvarString)
        .addProperty("Parent", &GCSosGroupMatchPattern::GetParent, &GCSosGroupMatchPattern::SetParent)
        .addFunction("ToPtr", &GCSosGroupMatchPattern::ToPtr)
        .addFunction("IsValid", &GCSosGroupMatchPattern::IsValid)
        .endClass();
}
GCSSDSEndFrameViewInfo::GCSSDSEndFrameViewInfo(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCSSDSEndFrameViewInfo::GCSSDSEndFrameViewInfo(void *ptr) {
    m_ptr = ptr;
}
uint64_t GCSSDSEndFrameViewInfo::GetViewId() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CSSDSEndFrameViewInfo", "m_nViewId");
}
void GCSSDSEndFrameViewInfo::SetViewId(uint64_t value) {
    SetSchemaValue(m_ptr, "CSSDSEndFrameViewInfo", "m_nViewId", false, value);
}
std::string GCSSDSEndFrameViewInfo::GetViewName() const {
    return GetSchemaValue<CUtlString>(m_ptr, "CSSDSEndFrameViewInfo", "m_ViewName").Get();
}
void GCSSDSEndFrameViewInfo::SetViewName(std::string value) {
    SetSchemaValue(m_ptr, "CSSDSEndFrameViewInfo", "m_ViewName", false, CUtlString(value.c_str()));
}
std::string GCSSDSEndFrameViewInfo::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCSSDSEndFrameViewInfo::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCSSDSEndFrameViewInfo(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCSSDSEndFrameViewInfo>("CSSDSEndFrameViewInfo")
        .addConstructor<void (*)(std::string)>()
        .addProperty("ViewId", &GCSSDSEndFrameViewInfo::GetViewId, &GCSSDSEndFrameViewInfo::SetViewId)
        .addProperty("ViewName", &GCSSDSEndFrameViewInfo::GetViewName, &GCSSDSEndFrameViewInfo::SetViewName)
        .addFunction("ToPtr", &GCSSDSEndFrameViewInfo::ToPtr)
        .addFunction("IsValid", &GCSSDSEndFrameViewInfo::IsValid)
        .endClass();
}
GCNmExternalGraphNode::GCNmExternalGraphNode(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCNmExternalGraphNode::GCNmExternalGraphNode(void *ptr) {
    m_ptr = ptr;
}
std::string GCNmExternalGraphNode::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCNmExternalGraphNode::IsValid() {
    return (m_ptr != nullptr);
}
GCNmPoseNode GCNmExternalGraphNode::GetParent() const {
    GCNmPoseNode value(m_ptr);
    return value;
}
void GCNmExternalGraphNode::SetParent(GCNmPoseNode value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCNmExternalGraphNode(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCNmExternalGraphNode>("CNmExternalGraphNode")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCNmExternalGraphNode::GetParent, &GCNmExternalGraphNode::SetParent)
        .addFunction("ToPtr", &GCNmExternalGraphNode::ToPtr)
        .addFunction("IsValid", &GCNmExternalGraphNode::IsValid)
        .endClass();
}
GCMoverUpdateNode::GCMoverUpdateNode(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCMoverUpdateNode::GCMoverUpdateNode(void *ptr) {
    m_ptr = ptr;
}
GCAnimInputDamping GCMoverUpdateNode::GetDamping() const {
    GCAnimInputDamping value(GetSchemaPtr(m_ptr, "CMoverUpdateNode", "m_damping"));
    return value;
}
void GCMoverUpdateNode::SetDamping(GCAnimInputDamping value) {
    SetSchemaValue(m_ptr, "CMoverUpdateNode", "m_damping", false, value);
}
uint64_t GCMoverUpdateNode::GetFacingTarget() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CMoverUpdateNode", "m_facingTarget");
}
void GCMoverUpdateNode::SetFacingTarget(uint64_t value) {
    SetSchemaValue(m_ptr, "CMoverUpdateNode", "m_facingTarget", false, value);
}
GCAnimParamHandle GCMoverUpdateNode::GetMoveVecParam() const {
    GCAnimParamHandle value(GetSchemaPtr(m_ptr, "CMoverUpdateNode", "m_hMoveVecParam"));
    return value;
}
void GCMoverUpdateNode::SetMoveVecParam(GCAnimParamHandle value) {
    SetSchemaValue(m_ptr, "CMoverUpdateNode", "m_hMoveVecParam", false, value);
}
GCAnimParamHandle GCMoverUpdateNode::GetMoveHeadingParam() const {
    GCAnimParamHandle value(GetSchemaPtr(m_ptr, "CMoverUpdateNode", "m_hMoveHeadingParam"));
    return value;
}
void GCMoverUpdateNode::SetMoveHeadingParam(GCAnimParamHandle value) {
    SetSchemaValue(m_ptr, "CMoverUpdateNode", "m_hMoveHeadingParam", false, value);
}
GCAnimParamHandle GCMoverUpdateNode::GetTurnToFaceParam() const {
    GCAnimParamHandle value(GetSchemaPtr(m_ptr, "CMoverUpdateNode", "m_hTurnToFaceParam"));
    return value;
}
void GCMoverUpdateNode::SetTurnToFaceParam(GCAnimParamHandle value) {
    SetSchemaValue(m_ptr, "CMoverUpdateNode", "m_hTurnToFaceParam", false, value);
}
float GCMoverUpdateNode::GetTurnToFaceOffset() const {
    return GetSchemaValue<float>(m_ptr, "CMoverUpdateNode", "m_flTurnToFaceOffset");
}
void GCMoverUpdateNode::SetTurnToFaceOffset(float value) {
    SetSchemaValue(m_ptr, "CMoverUpdateNode", "m_flTurnToFaceOffset", false, value);
}
float GCMoverUpdateNode::GetTurnToFaceLimit() const {
    return GetSchemaValue<float>(m_ptr, "CMoverUpdateNode", "m_flTurnToFaceLimit");
}
void GCMoverUpdateNode::SetTurnToFaceLimit(float value) {
    SetSchemaValue(m_ptr, "CMoverUpdateNode", "m_flTurnToFaceLimit", false, value);
}
bool GCMoverUpdateNode::GetAdditive() const {
    return GetSchemaValue<bool>(m_ptr, "CMoverUpdateNode", "m_bAdditive");
}
void GCMoverUpdateNode::SetAdditive(bool value) {
    SetSchemaValue(m_ptr, "CMoverUpdateNode", "m_bAdditive", false, value);
}
bool GCMoverUpdateNode::GetApplyMovement() const {
    return GetSchemaValue<bool>(m_ptr, "CMoverUpdateNode", "m_bApplyMovement");
}
void GCMoverUpdateNode::SetApplyMovement(bool value) {
    SetSchemaValue(m_ptr, "CMoverUpdateNode", "m_bApplyMovement", false, value);
}
bool GCMoverUpdateNode::GetOrientMovement() const {
    return GetSchemaValue<bool>(m_ptr, "CMoverUpdateNode", "m_bOrientMovement");
}
void GCMoverUpdateNode::SetOrientMovement(bool value) {
    SetSchemaValue(m_ptr, "CMoverUpdateNode", "m_bOrientMovement", false, value);
}
bool GCMoverUpdateNode::GetApplyRotation() const {
    return GetSchemaValue<bool>(m_ptr, "CMoverUpdateNode", "m_bApplyRotation");
}
void GCMoverUpdateNode::SetApplyRotation(bool value) {
    SetSchemaValue(m_ptr, "CMoverUpdateNode", "m_bApplyRotation", false, value);
}
bool GCMoverUpdateNode::GetLimitOnly() const {
    return GetSchemaValue<bool>(m_ptr, "CMoverUpdateNode", "m_bLimitOnly");
}
void GCMoverUpdateNode::SetLimitOnly(bool value) {
    SetSchemaValue(m_ptr, "CMoverUpdateNode", "m_bLimitOnly", false, value);
}
std::string GCMoverUpdateNode::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCMoverUpdateNode::IsValid() {
    return (m_ptr != nullptr);
}
GCUnaryUpdateNode GCMoverUpdateNode::GetParent() const {
    GCUnaryUpdateNode value(m_ptr);
    return value;
}
void GCMoverUpdateNode::SetParent(GCUnaryUpdateNode value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCMoverUpdateNode(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCMoverUpdateNode>("CMoverUpdateNode")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Damping", &GCMoverUpdateNode::GetDamping, &GCMoverUpdateNode::SetDamping)
        .addProperty("FacingTarget", &GCMoverUpdateNode::GetFacingTarget, &GCMoverUpdateNode::SetFacingTarget)
        .addProperty("MoveVecParam", &GCMoverUpdateNode::GetMoveVecParam, &GCMoverUpdateNode::SetMoveVecParam)
        .addProperty("MoveHeadingParam", &GCMoverUpdateNode::GetMoveHeadingParam, &GCMoverUpdateNode::SetMoveHeadingParam)
        .addProperty("TurnToFaceParam", &GCMoverUpdateNode::GetTurnToFaceParam, &GCMoverUpdateNode::SetTurnToFaceParam)
        .addProperty("TurnToFaceOffset", &GCMoverUpdateNode::GetTurnToFaceOffset, &GCMoverUpdateNode::SetTurnToFaceOffset)
        .addProperty("TurnToFaceLimit", &GCMoverUpdateNode::GetTurnToFaceLimit, &GCMoverUpdateNode::SetTurnToFaceLimit)
        .addProperty("Additive", &GCMoverUpdateNode::GetAdditive, &GCMoverUpdateNode::SetAdditive)
        .addProperty("ApplyMovement", &GCMoverUpdateNode::GetApplyMovement, &GCMoverUpdateNode::SetApplyMovement)
        .addProperty("OrientMovement", &GCMoverUpdateNode::GetOrientMovement, &GCMoverUpdateNode::SetOrientMovement)
        .addProperty("ApplyRotation", &GCMoverUpdateNode::GetApplyRotation, &GCMoverUpdateNode::SetApplyRotation)
        .addProperty("LimitOnly", &GCMoverUpdateNode::GetLimitOnly, &GCMoverUpdateNode::SetLimitOnly)
        .addProperty("Parent", &GCMoverUpdateNode::GetParent, &GCMoverUpdateNode::SetParent)
        .addFunction("ToPtr", &GCMoverUpdateNode::ToPtr)
        .addFunction("IsValid", &GCMoverUpdateNode::IsValid)
        .endClass();
}
GRnHull_t::GRnHull_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GRnHull_t::GRnHull_t(void *ptr) {
    m_ptr = ptr;
}
Vector GRnHull_t::GetCentroid() const {
    return GetSchemaValue<Vector>(m_ptr, "RnHull_t", "m_vCentroid");
}
void GRnHull_t::SetCentroid(Vector value) {
    SetSchemaValue(m_ptr, "RnHull_t", "m_vCentroid", true, value);
}
float GRnHull_t::GetMaxAngularRadius() const {
    return GetSchemaValue<float>(m_ptr, "RnHull_t", "m_flMaxAngularRadius");
}
void GRnHull_t::SetMaxAngularRadius(float value) {
    SetSchemaValue(m_ptr, "RnHull_t", "m_flMaxAngularRadius", true, value);
}
GAABB_t GRnHull_t::GetBounds() const {
    GAABB_t value(GetSchemaPtr(m_ptr, "RnHull_t", "m_Bounds"));
    return value;
}
void GRnHull_t::SetBounds(GAABB_t value) {
    SetSchemaValue(m_ptr, "RnHull_t", "m_Bounds", true, value);
}
Vector GRnHull_t::GetOrthographicAreas() const {
    return GetSchemaValue<Vector>(m_ptr, "RnHull_t", "m_vOrthographicAreas");
}
void GRnHull_t::SetOrthographicAreas(Vector value) {
    SetSchemaValue(m_ptr, "RnHull_t", "m_vOrthographicAreas", true, value);
}
matrix3x4_t GRnHull_t::GetMassProperties() const {
    return GetSchemaValue<matrix3x4_t>(m_ptr, "RnHull_t", "m_MassProperties");
}
void GRnHull_t::SetMassProperties(matrix3x4_t value) {
    SetSchemaValue(m_ptr, "RnHull_t", "m_MassProperties", true, value);
}
float GRnHull_t::GetVolume() const {
    return GetSchemaValue<float>(m_ptr, "RnHull_t", "m_flVolume");
}
void GRnHull_t::SetVolume(float value) {
    SetSchemaValue(m_ptr, "RnHull_t", "m_flVolume", true, value);
}
float GRnHull_t::GetSurfaceArea() const {
    return GetSchemaValue<float>(m_ptr, "RnHull_t", "m_flSurfaceArea");
}
void GRnHull_t::SetSurfaceArea(float value) {
    SetSchemaValue(m_ptr, "RnHull_t", "m_flSurfaceArea", true, value);
}
std::vector<GRnVertex_t> GRnHull_t::GetVertices() const {
    CUtlVector<GRnVertex_t>* vec = GetSchemaValue<CUtlVector<GRnVertex_t>*>(m_ptr, "RnHull_t", "m_Vertices"); std::vector<GRnVertex_t> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GRnHull_t::SetVertices(std::vector<GRnVertex_t> value) {
    SetSchemaValueCUtlVector<GRnVertex_t>(m_ptr, "RnHull_t", "m_Vertices", true, value);
}
std::vector<Vector> GRnHull_t::GetVertexPositions() const {
    CUtlVector<Vector>* vec = GetSchemaValue<CUtlVector<Vector>*>(m_ptr, "RnHull_t", "m_VertexPositions"); std::vector<Vector> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GRnHull_t::SetVertexPositions(std::vector<Vector> value) {
    SetSchemaValueCUtlVector<Vector>(m_ptr, "RnHull_t", "m_VertexPositions", true, value);
}
std::vector<GRnHalfEdge_t> GRnHull_t::GetEdges() const {
    CUtlVector<GRnHalfEdge_t>* vec = GetSchemaValue<CUtlVector<GRnHalfEdge_t>*>(m_ptr, "RnHull_t", "m_Edges"); std::vector<GRnHalfEdge_t> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GRnHull_t::SetEdges(std::vector<GRnHalfEdge_t> value) {
    SetSchemaValueCUtlVector<GRnHalfEdge_t>(m_ptr, "RnHull_t", "m_Edges", true, value);
}
std::vector<GRnFace_t> GRnHull_t::GetFaces() const {
    CUtlVector<GRnFace_t>* vec = GetSchemaValue<CUtlVector<GRnFace_t>*>(m_ptr, "RnHull_t", "m_Faces"); std::vector<GRnFace_t> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GRnHull_t::SetFaces(std::vector<GRnFace_t> value) {
    SetSchemaValueCUtlVector<GRnFace_t>(m_ptr, "RnHull_t", "m_Faces", true, value);
}
std::vector<GRnPlane_t> GRnHull_t::GetFacePlanes() const {
    CUtlVector<GRnPlane_t>* vec = GetSchemaValue<CUtlVector<GRnPlane_t>*>(m_ptr, "RnHull_t", "m_FacePlanes"); std::vector<GRnPlane_t> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GRnHull_t::SetFacePlanes(std::vector<GRnPlane_t> value) {
    SetSchemaValueCUtlVector<GRnPlane_t>(m_ptr, "RnHull_t", "m_FacePlanes", true, value);
}
uint32_t GRnHull_t::GetFlags() const {
    return GetSchemaValue<uint32_t>(m_ptr, "RnHull_t", "m_nFlags");
}
void GRnHull_t::SetFlags(uint32_t value) {
    SetSchemaValue(m_ptr, "RnHull_t", "m_nFlags", true, value);
}
GCRegionSVM GRnHull_t::GetRegionSVM() const {
    GCRegionSVM value(*GetSchemaValuePtr<void*>(m_ptr, "RnHull_t", "m_pRegionSVM"));
    return value;
}
void GRnHull_t::SetRegionSVM(GCRegionSVM* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'RegionSVM' is not possible.\n");
}
std::string GRnHull_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GRnHull_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassRnHull_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GRnHull_t>("RnHull_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Centroid", &GRnHull_t::GetCentroid, &GRnHull_t::SetCentroid)
        .addProperty("MaxAngularRadius", &GRnHull_t::GetMaxAngularRadius, &GRnHull_t::SetMaxAngularRadius)
        .addProperty("Bounds", &GRnHull_t::GetBounds, &GRnHull_t::SetBounds)
        .addProperty("OrthographicAreas", &GRnHull_t::GetOrthographicAreas, &GRnHull_t::SetOrthographicAreas)
        .addProperty("MassProperties", &GRnHull_t::GetMassProperties, &GRnHull_t::SetMassProperties)
        .addProperty("Volume", &GRnHull_t::GetVolume, &GRnHull_t::SetVolume)
        .addProperty("SurfaceArea", &GRnHull_t::GetSurfaceArea, &GRnHull_t::SetSurfaceArea)
        .addProperty("Vertices", &GRnHull_t::GetVertices, &GRnHull_t::SetVertices)
        .addProperty("VertexPositions", &GRnHull_t::GetVertexPositions, &GRnHull_t::SetVertexPositions)
        .addProperty("Edges", &GRnHull_t::GetEdges, &GRnHull_t::SetEdges)
        .addProperty("Faces", &GRnHull_t::GetFaces, &GRnHull_t::SetFaces)
        .addProperty("FacePlanes", &GRnHull_t::GetFacePlanes, &GRnHull_t::SetFacePlanes)
        .addProperty("Flags", &GRnHull_t::GetFlags, &GRnHull_t::SetFlags)
        .addProperty("RegionSVM", &GRnHull_t::GetRegionSVM, &GRnHull_t::SetRegionSVM)
        .addFunction("ToPtr", &GRnHull_t::ToPtr)
        .addFunction("IsValid", &GRnHull_t::IsValid)
        .endClass();
}
GCMoodVData::GCMoodVData(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCMoodVData::GCMoodVData(void *ptr) {
    m_ptr = ptr;
}
uint64_t GCMoodVData::GetMoodType() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CMoodVData", "m_nMoodType");
}
void GCMoodVData::SetMoodType(uint64_t value) {
    SetSchemaValue(m_ptr, "CMoodVData", "m_nMoodType", false, value);
}
std::string GCMoodVData::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCMoodVData::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCMoodVData(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCMoodVData>("CMoodVData")
        .addConstructor<void (*)(std::string)>()
        .addProperty("MoodType", &GCMoodVData::GetMoodType, &GCMoodVData::SetMoodType)
        .addFunction("ToPtr", &GCMoodVData::ToPtr)
        .addFunction("IsValid", &GCMoodVData::IsValid)
        .endClass();
}
GEventClientFrameSimulate_t::GEventClientFrameSimulate_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GEventClientFrameSimulate_t::GEventClientFrameSimulate_t(void *ptr) {
    m_ptr = ptr;
}
GEngineLoopState_t GEventClientFrameSimulate_t::GetLoopState() const {
    GEngineLoopState_t value(GetSchemaPtr(m_ptr, "EventClientFrameSimulate_t", "m_LoopState"));
    return value;
}
void GEventClientFrameSimulate_t::SetLoopState(GEngineLoopState_t value) {
    SetSchemaValue(m_ptr, "EventClientFrameSimulate_t", "m_LoopState", true, value);
}
float GEventClientFrameSimulate_t::GetRealTime() const {
    return GetSchemaValue<float>(m_ptr, "EventClientFrameSimulate_t", "m_flRealTime");
}
void GEventClientFrameSimulate_t::SetRealTime(float value) {
    SetSchemaValue(m_ptr, "EventClientFrameSimulate_t", "m_flRealTime", true, value);
}
float GEventClientFrameSimulate_t::GetFrameTime() const {
    return GetSchemaValue<float>(m_ptr, "EventClientFrameSimulate_t", "m_flFrameTime");
}
void GEventClientFrameSimulate_t::SetFrameTime(float value) {
    SetSchemaValue(m_ptr, "EventClientFrameSimulate_t", "m_flFrameTime", true, value);
}
double GEventClientFrameSimulate_t::GetWhenScheduleSendTickPacket() const {
    return GetSchemaValue<double>(m_ptr, "EventClientFrameSimulate_t", "m_flWhenScheduleSendTickPacket");
}
void GEventClientFrameSimulate_t::SetWhenScheduleSendTickPacket(double value) {
    SetSchemaValue(m_ptr, "EventClientFrameSimulate_t", "m_flWhenScheduleSendTickPacket", true, value);
}
std::string GEventClientFrameSimulate_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GEventClientFrameSimulate_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassEventClientFrameSimulate_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GEventClientFrameSimulate_t>("EventClientFrameSimulate_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("LoopState", &GEventClientFrameSimulate_t::GetLoopState, &GEventClientFrameSimulate_t::SetLoopState)
        .addProperty("RealTime", &GEventClientFrameSimulate_t::GetRealTime, &GEventClientFrameSimulate_t::SetRealTime)
        .addProperty("FrameTime", &GEventClientFrameSimulate_t::GetFrameTime, &GEventClientFrameSimulate_t::SetFrameTime)
        .addProperty("WhenScheduleSendTickPacket", &GEventClientFrameSimulate_t::GetWhenScheduleSendTickPacket, &GEventClientFrameSimulate_t::SetWhenScheduleSendTickPacket)
        .addFunction("ToPtr", &GEventClientFrameSimulate_t::ToPtr)
        .addFunction("IsValid", &GEventClientFrameSimulate_t::IsValid)
        .endClass();
}
GCRagdollComponentUpdater::GCRagdollComponentUpdater(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCRagdollComponentUpdater::GCRagdollComponentUpdater(void *ptr) {
    m_ptr = ptr;
}
std::vector<GCAnimNodePath> GCRagdollComponentUpdater::GetRagdollNodePaths() const {
    CUtlVector<GCAnimNodePath>* vec = GetSchemaValue<CUtlVector<GCAnimNodePath>*>(m_ptr, "CRagdollComponentUpdater", "m_ragdollNodePaths"); std::vector<GCAnimNodePath> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCRagdollComponentUpdater::SetRagdollNodePaths(std::vector<GCAnimNodePath> value) {
    SetSchemaValueCUtlVector<GCAnimNodePath>(m_ptr, "CRagdollComponentUpdater", "m_ragdollNodePaths", false, value);
}
std::vector<int32> GCRagdollComponentUpdater::GetBoneIndices() const {
    CUtlVector<int32>* vec = GetSchemaValue<CUtlVector<int32>*>(m_ptr, "CRagdollComponentUpdater", "m_boneIndices"); std::vector<int32> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCRagdollComponentUpdater::SetBoneIndices(std::vector<int32> value) {
    SetSchemaValueCUtlVector<int32>(m_ptr, "CRagdollComponentUpdater", "m_boneIndices", false, value);
}
std::vector<CUtlString> GCRagdollComponentUpdater::GetBoneNames() const {
    CUtlVector<CUtlString>* vec = GetSchemaValue<CUtlVector<CUtlString>*>(m_ptr, "CRagdollComponentUpdater", "m_boneNames"); std::vector<CUtlString> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCRagdollComponentUpdater::SetBoneNames(std::vector<CUtlString> value) {
    SetSchemaValueCUtlVector<CUtlString>(m_ptr, "CRagdollComponentUpdater", "m_boneNames", false, value);
}
std::vector<GWeightList> GCRagdollComponentUpdater::GetWeightLists() const {
    CUtlVector<GWeightList>* vec = GetSchemaValue<CUtlVector<GWeightList>*>(m_ptr, "CRagdollComponentUpdater", "m_weightLists"); std::vector<GWeightList> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCRagdollComponentUpdater::SetWeightLists(std::vector<GWeightList> value) {
    SetSchemaValueCUtlVector<GWeightList>(m_ptr, "CRagdollComponentUpdater", "m_weightLists", false, value);
}
float GCRagdollComponentUpdater::GetSpringFrequencyMin() const {
    return GetSchemaValue<float>(m_ptr, "CRagdollComponentUpdater", "m_flSpringFrequencyMin");
}
void GCRagdollComponentUpdater::SetSpringFrequencyMin(float value) {
    SetSchemaValue(m_ptr, "CRagdollComponentUpdater", "m_flSpringFrequencyMin", false, value);
}
float GCRagdollComponentUpdater::GetSpringFrequencyMax() const {
    return GetSchemaValue<float>(m_ptr, "CRagdollComponentUpdater", "m_flSpringFrequencyMax");
}
void GCRagdollComponentUpdater::SetSpringFrequencyMax(float value) {
    SetSchemaValue(m_ptr, "CRagdollComponentUpdater", "m_flSpringFrequencyMax", false, value);
}
float GCRagdollComponentUpdater::GetMaxStretch() const {
    return GetSchemaValue<float>(m_ptr, "CRagdollComponentUpdater", "m_flMaxStretch");
}
void GCRagdollComponentUpdater::SetMaxStretch(float value) {
    SetSchemaValue(m_ptr, "CRagdollComponentUpdater", "m_flMaxStretch", false, value);
}
bool GCRagdollComponentUpdater::GetSolidCollisionAtZeroWeight() const {
    return GetSchemaValue<bool>(m_ptr, "CRagdollComponentUpdater", "m_bSolidCollisionAtZeroWeight");
}
void GCRagdollComponentUpdater::SetSolidCollisionAtZeroWeight(bool value) {
    SetSchemaValue(m_ptr, "CRagdollComponentUpdater", "m_bSolidCollisionAtZeroWeight", false, value);
}
std::string GCRagdollComponentUpdater::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCRagdollComponentUpdater::IsValid() {
    return (m_ptr != nullptr);
}
GCAnimComponentUpdater GCRagdollComponentUpdater::GetParent() const {
    GCAnimComponentUpdater value(m_ptr);
    return value;
}
void GCRagdollComponentUpdater::SetParent(GCAnimComponentUpdater value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCRagdollComponentUpdater(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCRagdollComponentUpdater>("CRagdollComponentUpdater")
        .addConstructor<void (*)(std::string)>()
        .addProperty("RagdollNodePaths", &GCRagdollComponentUpdater::GetRagdollNodePaths, &GCRagdollComponentUpdater::SetRagdollNodePaths)
        .addProperty("BoneIndices", &GCRagdollComponentUpdater::GetBoneIndices, &GCRagdollComponentUpdater::SetBoneIndices)
        .addProperty("BoneNames", &GCRagdollComponentUpdater::GetBoneNames, &GCRagdollComponentUpdater::SetBoneNames)
        .addProperty("WeightLists", &GCRagdollComponentUpdater::GetWeightLists, &GCRagdollComponentUpdater::SetWeightLists)
        .addProperty("SpringFrequencyMin", &GCRagdollComponentUpdater::GetSpringFrequencyMin, &GCRagdollComponentUpdater::SetSpringFrequencyMin)
        .addProperty("SpringFrequencyMax", &GCRagdollComponentUpdater::GetSpringFrequencyMax, &GCRagdollComponentUpdater::SetSpringFrequencyMax)
        .addProperty("MaxStretch", &GCRagdollComponentUpdater::GetMaxStretch, &GCRagdollComponentUpdater::SetMaxStretch)
        .addProperty("SolidCollisionAtZeroWeight", &GCRagdollComponentUpdater::GetSolidCollisionAtZeroWeight, &GCRagdollComponentUpdater::SetSolidCollisionAtZeroWeight)
        .addProperty("Parent", &GCRagdollComponentUpdater::GetParent, &GCRagdollComponentUpdater::SetParent)
        .addFunction("ToPtr", &GCRagdollComponentUpdater::ToPtr)
        .addFunction("IsValid", &GCRagdollComponentUpdater::IsValid)
        .endClass();
}
GCMotionNodeBlend1D::GCMotionNodeBlend1D(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCMotionNodeBlend1D::GCMotionNodeBlend1D(void *ptr) {
    m_ptr = ptr;
}
std::vector<GMotionBlendItem> GCMotionNodeBlend1D::GetBlendItems() const {
    CUtlVector<GMotionBlendItem>* vec = GetSchemaValue<CUtlVector<GMotionBlendItem>*>(m_ptr, "CMotionNodeBlend1D", "m_blendItems"); std::vector<GMotionBlendItem> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCMotionNodeBlend1D::SetBlendItems(std::vector<GMotionBlendItem> value) {
    SetSchemaValueCUtlVector<GMotionBlendItem>(m_ptr, "CMotionNodeBlend1D", "m_blendItems", false, value);
}
int32_t GCMotionNodeBlend1D::GetParamIndex() const {
    return GetSchemaValue<int32_t>(m_ptr, "CMotionNodeBlend1D", "m_nParamIndex");
}
void GCMotionNodeBlend1D::SetParamIndex(int32_t value) {
    SetSchemaValue(m_ptr, "CMotionNodeBlend1D", "m_nParamIndex", false, value);
}
std::string GCMotionNodeBlend1D::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCMotionNodeBlend1D::IsValid() {
    return (m_ptr != nullptr);
}
GCMotionNode GCMotionNodeBlend1D::GetParent() const {
    GCMotionNode value(m_ptr);
    return value;
}
void GCMotionNodeBlend1D::SetParent(GCMotionNode value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCMotionNodeBlend1D(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCMotionNodeBlend1D>("CMotionNodeBlend1D")
        .addConstructor<void (*)(std::string)>()
        .addProperty("BlendItems", &GCMotionNodeBlend1D::GetBlendItems, &GCMotionNodeBlend1D::SetBlendItems)
        .addProperty("ParamIndex", &GCMotionNodeBlend1D::GetParamIndex, &GCMotionNodeBlend1D::SetParamIndex)
        .addProperty("Parent", &GCMotionNodeBlend1D::GetParent, &GCMotionNodeBlend1D::SetParent)
        .addFunction("ToPtr", &GCMotionNodeBlend1D::ToPtr)
        .addFunction("IsValid", &GCMotionNodeBlend1D::IsValid)
        .endClass();
}
GCNmControlParameterVectorNode::GCNmControlParameterVectorNode(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCNmControlParameterVectorNode::GCNmControlParameterVectorNode(void *ptr) {
    m_ptr = ptr;
}
std::string GCNmControlParameterVectorNode::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCNmControlParameterVectorNode::IsValid() {
    return (m_ptr != nullptr);
}
GCNmVectorValueNode GCNmControlParameterVectorNode::GetParent() const {
    GCNmVectorValueNode value(m_ptr);
    return value;
}
void GCNmControlParameterVectorNode::SetParent(GCNmVectorValueNode value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCNmControlParameterVectorNode(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCNmControlParameterVectorNode>("CNmControlParameterVectorNode")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCNmControlParameterVectorNode::GetParent, &GCNmControlParameterVectorNode::SetParent)
        .addFunction("ToPtr", &GCNmControlParameterVectorNode::ToPtr)
        .addFunction("IsValid", &GCNmControlParameterVectorNode::IsValid)
        .endClass();
}
GCPathHelperUpdateNode::GCPathHelperUpdateNode(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCPathHelperUpdateNode::GCPathHelperUpdateNode(void *ptr) {
    m_ptr = ptr;
}
float GCPathHelperUpdateNode::GetStoppingRadius() const {
    return GetSchemaValue<float>(m_ptr, "CPathHelperUpdateNode", "m_flStoppingRadius");
}
void GCPathHelperUpdateNode::SetStoppingRadius(float value) {
    SetSchemaValue(m_ptr, "CPathHelperUpdateNode", "m_flStoppingRadius", false, value);
}
float GCPathHelperUpdateNode::GetStoppingSpeedScale() const {
    return GetSchemaValue<float>(m_ptr, "CPathHelperUpdateNode", "m_flStoppingSpeedScale");
}
void GCPathHelperUpdateNode::SetStoppingSpeedScale(float value) {
    SetSchemaValue(m_ptr, "CPathHelperUpdateNode", "m_flStoppingSpeedScale", false, value);
}
std::string GCPathHelperUpdateNode::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCPathHelperUpdateNode::IsValid() {
    return (m_ptr != nullptr);
}
GCUnaryUpdateNode GCPathHelperUpdateNode::GetParent() const {
    GCUnaryUpdateNode value(m_ptr);
    return value;
}
void GCPathHelperUpdateNode::SetParent(GCUnaryUpdateNode value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCPathHelperUpdateNode(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCPathHelperUpdateNode>("CPathHelperUpdateNode")
        .addConstructor<void (*)(std::string)>()
        .addProperty("StoppingRadius", &GCPathHelperUpdateNode::GetStoppingRadius, &GCPathHelperUpdateNode::SetStoppingRadius)
        .addProperty("StoppingSpeedScale", &GCPathHelperUpdateNode::GetStoppingSpeedScale, &GCPathHelperUpdateNode::SetStoppingSpeedScale)
        .addProperty("Parent", &GCPathHelperUpdateNode::GetParent, &GCPathHelperUpdateNode::SetParent)
        .addFunction("ToPtr", &GCPathHelperUpdateNode::ToPtr)
        .addFunction("IsValid", &GCPathHelperUpdateNode::IsValid)
        .endClass();
}
GCSeqPoseParamDesc::GCSeqPoseParamDesc(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCSeqPoseParamDesc::GCSeqPoseParamDesc(void *ptr) {
    m_ptr = ptr;
}
CBufferString GCSeqPoseParamDesc::GetName() const {
    return GetSchemaValue<CBufferString>(m_ptr, "CSeqPoseParamDesc", "m_sName");
}
void GCSeqPoseParamDesc::SetName(CBufferString value) {
    SetSchemaValue(m_ptr, "CSeqPoseParamDesc", "m_sName", false, value);
}
float GCSeqPoseParamDesc::GetStart() const {
    return GetSchemaValue<float>(m_ptr, "CSeqPoseParamDesc", "m_flStart");
}
void GCSeqPoseParamDesc::SetStart(float value) {
    SetSchemaValue(m_ptr, "CSeqPoseParamDesc", "m_flStart", false, value);
}
float GCSeqPoseParamDesc::GetEnd() const {
    return GetSchemaValue<float>(m_ptr, "CSeqPoseParamDesc", "m_flEnd");
}
void GCSeqPoseParamDesc::SetEnd(float value) {
    SetSchemaValue(m_ptr, "CSeqPoseParamDesc", "m_flEnd", false, value);
}
float GCSeqPoseParamDesc::GetLoop() const {
    return GetSchemaValue<float>(m_ptr, "CSeqPoseParamDesc", "m_flLoop");
}
void GCSeqPoseParamDesc::SetLoop(float value) {
    SetSchemaValue(m_ptr, "CSeqPoseParamDesc", "m_flLoop", false, value);
}
bool GCSeqPoseParamDesc::GetLooping() const {
    return GetSchemaValue<bool>(m_ptr, "CSeqPoseParamDesc", "m_bLooping");
}
void GCSeqPoseParamDesc::SetLooping(bool value) {
    SetSchemaValue(m_ptr, "CSeqPoseParamDesc", "m_bLooping", false, value);
}
std::string GCSeqPoseParamDesc::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCSeqPoseParamDesc::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCSeqPoseParamDesc(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCSeqPoseParamDesc>("CSeqPoseParamDesc")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Name", &GCSeqPoseParamDesc::GetName, &GCSeqPoseParamDesc::SetName)
        .addProperty("Start", &GCSeqPoseParamDesc::GetStart, &GCSeqPoseParamDesc::SetStart)
        .addProperty("End", &GCSeqPoseParamDesc::GetEnd, &GCSeqPoseParamDesc::SetEnd)
        .addProperty("Loop", &GCSeqPoseParamDesc::GetLoop, &GCSeqPoseParamDesc::SetLoop)
        .addProperty("Looping", &GCSeqPoseParamDesc::GetLooping, &GCSeqPoseParamDesc::SetLooping)
        .addFunction("ToPtr", &GCSeqPoseParamDesc::ToPtr)
        .addFunction("IsValid", &GCSeqPoseParamDesc::IsValid)
        .endClass();
}
GVMixPitchShiftDesc_t::GVMixPitchShiftDesc_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GVMixPitchShiftDesc_t::GVMixPitchShiftDesc_t(void *ptr) {
    m_ptr = ptr;
}
int32_t GVMixPitchShiftDesc_t::GetGrainSampleCount() const {
    return GetSchemaValue<int32_t>(m_ptr, "VMixPitchShiftDesc_t", "m_nGrainSampleCount");
}
void GVMixPitchShiftDesc_t::SetGrainSampleCount(int32_t value) {
    SetSchemaValue(m_ptr, "VMixPitchShiftDesc_t", "m_nGrainSampleCount", true, value);
}
float GVMixPitchShiftDesc_t::GetPitchShift() const {
    return GetSchemaValue<float>(m_ptr, "VMixPitchShiftDesc_t", "m_flPitchShift");
}
void GVMixPitchShiftDesc_t::SetPitchShift(float value) {
    SetSchemaValue(m_ptr, "VMixPitchShiftDesc_t", "m_flPitchShift", true, value);
}
int32_t GVMixPitchShiftDesc_t::GetQuality() const {
    return GetSchemaValue<int32_t>(m_ptr, "VMixPitchShiftDesc_t", "m_nQuality");
}
void GVMixPitchShiftDesc_t::SetQuality(int32_t value) {
    SetSchemaValue(m_ptr, "VMixPitchShiftDesc_t", "m_nQuality", true, value);
}
int32_t GVMixPitchShiftDesc_t::GetProcType() const {
    return GetSchemaValue<int32_t>(m_ptr, "VMixPitchShiftDesc_t", "m_nProcType");
}
void GVMixPitchShiftDesc_t::SetProcType(int32_t value) {
    SetSchemaValue(m_ptr, "VMixPitchShiftDesc_t", "m_nProcType", true, value);
}
std::string GVMixPitchShiftDesc_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GVMixPitchShiftDesc_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassVMixPitchShiftDesc_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GVMixPitchShiftDesc_t>("VMixPitchShiftDesc_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("GrainSampleCount", &GVMixPitchShiftDesc_t::GetGrainSampleCount, &GVMixPitchShiftDesc_t::SetGrainSampleCount)
        .addProperty("PitchShift", &GVMixPitchShiftDesc_t::GetPitchShift, &GVMixPitchShiftDesc_t::SetPitchShift)
        .addProperty("Quality", &GVMixPitchShiftDesc_t::GetQuality, &GVMixPitchShiftDesc_t::SetQuality)
        .addProperty("ProcType", &GVMixPitchShiftDesc_t::GetProcType, &GVMixPitchShiftDesc_t::SetProcType)
        .addFunction("ToPtr", &GVMixPitchShiftDesc_t::ToPtr)
        .addFunction("IsValid", &GVMixPitchShiftDesc_t::IsValid)
        .endClass();
}
GCAudioSentence::GCAudioSentence(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCAudioSentence::GCAudioSentence(void *ptr) {
    m_ptr = ptr;
}
bool GCAudioSentence::GetShouldVoiceDuck() const {
    return GetSchemaValue<bool>(m_ptr, "CAudioSentence", "m_bShouldVoiceDuck");
}
void GCAudioSentence::SetShouldVoiceDuck(bool value) {
    SetSchemaValue(m_ptr, "CAudioSentence", "m_bShouldVoiceDuck", false, value);
}
std::vector<GCAudioPhonemeTag> GCAudioSentence::GetRunTimePhonemes() const {
    CUtlVector<GCAudioPhonemeTag>* vec = GetSchemaValue<CUtlVector<GCAudioPhonemeTag>*>(m_ptr, "CAudioSentence", "m_RunTimePhonemes"); std::vector<GCAudioPhonemeTag> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCAudioSentence::SetRunTimePhonemes(std::vector<GCAudioPhonemeTag> value) {
    SetSchemaValueCUtlVector<GCAudioPhonemeTag>(m_ptr, "CAudioSentence", "m_RunTimePhonemes", false, value);
}
std::vector<GCAudioEmphasisSample> GCAudioSentence::GetEmphasisSamples() const {
    CUtlVector<GCAudioEmphasisSample>* vec = GetSchemaValue<CUtlVector<GCAudioEmphasisSample>*>(m_ptr, "CAudioSentence", "m_EmphasisSamples"); std::vector<GCAudioEmphasisSample> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCAudioSentence::SetEmphasisSamples(std::vector<GCAudioEmphasisSample> value) {
    SetSchemaValueCUtlVector<GCAudioEmphasisSample>(m_ptr, "CAudioSentence", "m_EmphasisSamples", false, value);
}
GCAudioMorphData GCAudioSentence::GetMorphData() const {
    GCAudioMorphData value(GetSchemaPtr(m_ptr, "CAudioSentence", "m_morphData"));
    return value;
}
void GCAudioSentence::SetMorphData(GCAudioMorphData value) {
    SetSchemaValue(m_ptr, "CAudioSentence", "m_morphData", false, value);
}
std::string GCAudioSentence::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCAudioSentence::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCAudioSentence(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCAudioSentence>("CAudioSentence")
        .addConstructor<void (*)(std::string)>()
        .addProperty("ShouldVoiceDuck", &GCAudioSentence::GetShouldVoiceDuck, &GCAudioSentence::SetShouldVoiceDuck)
        .addProperty("RunTimePhonemes", &GCAudioSentence::GetRunTimePhonemes, &GCAudioSentence::SetRunTimePhonemes)
        .addProperty("EmphasisSamples", &GCAudioSentence::GetEmphasisSamples, &GCAudioSentence::SetEmphasisSamples)
        .addProperty("MorphData", &GCAudioSentence::GetMorphData, &GCAudioSentence::SetMorphData)
        .addFunction("ToPtr", &GCAudioSentence::ToPtr)
        .addFunction("IsValid", &GCAudioSentence::IsValid)
        .endClass();
}
GCRenderBufferBinding::GCRenderBufferBinding(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCRenderBufferBinding::GCRenderBufferBinding(void *ptr) {
    m_ptr = ptr;
}
uint64_t GCRenderBufferBinding::GetBuffer() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CRenderBufferBinding", "m_hBuffer");
}
void GCRenderBufferBinding::SetBuffer(uint64_t value) {
    SetSchemaValue(m_ptr, "CRenderBufferBinding", "m_hBuffer", false, value);
}
uint32_t GCRenderBufferBinding::GetBindOffsetBytes() const {
    return GetSchemaValue<uint32_t>(m_ptr, "CRenderBufferBinding", "m_nBindOffsetBytes");
}
void GCRenderBufferBinding::SetBindOffsetBytes(uint32_t value) {
    SetSchemaValue(m_ptr, "CRenderBufferBinding", "m_nBindOffsetBytes", false, value);
}
std::string GCRenderBufferBinding::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCRenderBufferBinding::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCRenderBufferBinding(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCRenderBufferBinding>("CRenderBufferBinding")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Buffer", &GCRenderBufferBinding::GetBuffer, &GCRenderBufferBinding::SetBuffer)
        .addProperty("BindOffsetBytes", &GCRenderBufferBinding::GetBindOffsetBytes, &GCRenderBufferBinding::SetBindOffsetBytes)
        .addFunction("ToPtr", &GCRenderBufferBinding::ToPtr)
        .addFunction("IsValid", &GCRenderBufferBinding::IsValid)
        .endClass();
}
GCParticleAnimTag::GCParticleAnimTag(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCParticleAnimTag::GCParticleAnimTag(void *ptr) {
    m_ptr = ptr;
}
std::string GCParticleAnimTag::GetParticleSystemName() const {
    return GetSchemaValue<CUtlString>(m_ptr, "CParticleAnimTag", "m_particleSystemName").Get();
}
void GCParticleAnimTag::SetParticleSystemName(std::string value) {
    SetSchemaValue(m_ptr, "CParticleAnimTag", "m_particleSystemName", false, CUtlString(value.c_str()));
}
std::string GCParticleAnimTag::GetConfigName() const {
    return GetSchemaValue<CUtlString>(m_ptr, "CParticleAnimTag", "m_configName").Get();
}
void GCParticleAnimTag::SetConfigName(std::string value) {
    SetSchemaValue(m_ptr, "CParticleAnimTag", "m_configName", false, CUtlString(value.c_str()));
}
bool GCParticleAnimTag::GetDetachFromOwner() const {
    return GetSchemaValue<bool>(m_ptr, "CParticleAnimTag", "m_bDetachFromOwner");
}
void GCParticleAnimTag::SetDetachFromOwner(bool value) {
    SetSchemaValue(m_ptr, "CParticleAnimTag", "m_bDetachFromOwner", false, value);
}
bool GCParticleAnimTag::GetStopWhenTagEnds() const {
    return GetSchemaValue<bool>(m_ptr, "CParticleAnimTag", "m_bStopWhenTagEnds");
}
void GCParticleAnimTag::SetStopWhenTagEnds(bool value) {
    SetSchemaValue(m_ptr, "CParticleAnimTag", "m_bStopWhenTagEnds", false, value);
}
bool GCParticleAnimTag::GetTagEndStopIsInstant() const {
    return GetSchemaValue<bool>(m_ptr, "CParticleAnimTag", "m_bTagEndStopIsInstant");
}
void GCParticleAnimTag::SetTagEndStopIsInstant(bool value) {
    SetSchemaValue(m_ptr, "CParticleAnimTag", "m_bTagEndStopIsInstant", false, value);
}
std::string GCParticleAnimTag::GetAttachmentName() const {
    return GetSchemaValue<CUtlString>(m_ptr, "CParticleAnimTag", "m_attachmentName").Get();
}
void GCParticleAnimTag::SetAttachmentName(std::string value) {
    SetSchemaValue(m_ptr, "CParticleAnimTag", "m_attachmentName", false, CUtlString(value.c_str()));
}
uint64_t GCParticleAnimTag::GetAttachmentType() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CParticleAnimTag", "m_attachmentType");
}
void GCParticleAnimTag::SetAttachmentType(uint64_t value) {
    SetSchemaValue(m_ptr, "CParticleAnimTag", "m_attachmentType", false, value);
}
std::string GCParticleAnimTag::GetAttachmentCP1Name() const {
    return GetSchemaValue<CUtlString>(m_ptr, "CParticleAnimTag", "m_attachmentCP1Name").Get();
}
void GCParticleAnimTag::SetAttachmentCP1Name(std::string value) {
    SetSchemaValue(m_ptr, "CParticleAnimTag", "m_attachmentCP1Name", false, CUtlString(value.c_str()));
}
uint64_t GCParticleAnimTag::GetAttachmentCP1Type() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CParticleAnimTag", "m_attachmentCP1Type");
}
void GCParticleAnimTag::SetAttachmentCP1Type(uint64_t value) {
    SetSchemaValue(m_ptr, "CParticleAnimTag", "m_attachmentCP1Type", false, value);
}
std::string GCParticleAnimTag::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCParticleAnimTag::IsValid() {
    return (m_ptr != nullptr);
}
GCAnimTagBase GCParticleAnimTag::GetParent() const {
    GCAnimTagBase value(m_ptr);
    return value;
}
void GCParticleAnimTag::SetParent(GCAnimTagBase value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCParticleAnimTag(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCParticleAnimTag>("CParticleAnimTag")
        .addConstructor<void (*)(std::string)>()
        .addProperty("ParticleSystemName", &GCParticleAnimTag::GetParticleSystemName, &GCParticleAnimTag::SetParticleSystemName)
        .addProperty("ConfigName", &GCParticleAnimTag::GetConfigName, &GCParticleAnimTag::SetConfigName)
        .addProperty("DetachFromOwner", &GCParticleAnimTag::GetDetachFromOwner, &GCParticleAnimTag::SetDetachFromOwner)
        .addProperty("StopWhenTagEnds", &GCParticleAnimTag::GetStopWhenTagEnds, &GCParticleAnimTag::SetStopWhenTagEnds)
        .addProperty("TagEndStopIsInstant", &GCParticleAnimTag::GetTagEndStopIsInstant, &GCParticleAnimTag::SetTagEndStopIsInstant)
        .addProperty("AttachmentName", &GCParticleAnimTag::GetAttachmentName, &GCParticleAnimTag::SetAttachmentName)
        .addProperty("AttachmentType", &GCParticleAnimTag::GetAttachmentType, &GCParticleAnimTag::SetAttachmentType)
        .addProperty("AttachmentCP1Name", &GCParticleAnimTag::GetAttachmentCP1Name, &GCParticleAnimTag::SetAttachmentCP1Name)
        .addProperty("AttachmentCP1Type", &GCParticleAnimTag::GetAttachmentCP1Type, &GCParticleAnimTag::SetAttachmentCP1Type)
        .addProperty("Parent", &GCParticleAnimTag::GetParent, &GCParticleAnimTag::SetParent)
        .addFunction("ToPtr", &GCParticleAnimTag::ToPtr)
        .addFunction("IsValid", &GCParticleAnimTag::IsValid)
        .endClass();
}
GCStaticPoseCacheBuilder::GCStaticPoseCacheBuilder(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCStaticPoseCacheBuilder::GCStaticPoseCacheBuilder(void *ptr) {
    m_ptr = ptr;
}
std::string GCStaticPoseCacheBuilder::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCStaticPoseCacheBuilder::IsValid() {
    return (m_ptr != nullptr);
}
GCStaticPoseCache GCStaticPoseCacheBuilder::GetParent() const {
    GCStaticPoseCache value(m_ptr);
    return value;
}
void GCStaticPoseCacheBuilder::SetParent(GCStaticPoseCache value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCStaticPoseCacheBuilder(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCStaticPoseCacheBuilder>("CStaticPoseCacheBuilder")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCStaticPoseCacheBuilder::GetParent, &GCStaticPoseCacheBuilder::SetParent)
        .addFunction("ToPtr", &GCStaticPoseCacheBuilder::ToPtr)
        .addFunction("IsValid", &GCStaticPoseCacheBuilder::IsValid)
        .endClass();
}
GCNmRootMotionData::GCNmRootMotionData(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCNmRootMotionData::GCNmRootMotionData(void *ptr) {
    m_ptr = ptr;
}
int32_t GCNmRootMotionData::GetNumFrames() const {
    return GetSchemaValue<int32_t>(m_ptr, "CNmRootMotionData", "m_nNumFrames");
}
void GCNmRootMotionData::SetNumFrames(int32_t value) {
    SetSchemaValue(m_ptr, "CNmRootMotionData", "m_nNumFrames", false, value);
}
float GCNmRootMotionData::GetAverageLinearVelocity() const {
    return GetSchemaValue<float>(m_ptr, "CNmRootMotionData", "m_flAverageLinearVelocity");
}
void GCNmRootMotionData::SetAverageLinearVelocity(float value) {
    SetSchemaValue(m_ptr, "CNmRootMotionData", "m_flAverageLinearVelocity", false, value);
}
float GCNmRootMotionData::GetAverageAngularVelocityRadians() const {
    return GetSchemaValue<float>(m_ptr, "CNmRootMotionData", "m_flAverageAngularVelocityRadians");
}
void GCNmRootMotionData::SetAverageAngularVelocityRadians(float value) {
    SetSchemaValue(m_ptr, "CNmRootMotionData", "m_flAverageAngularVelocityRadians", false, value);
}
std::string GCNmRootMotionData::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCNmRootMotionData::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCNmRootMotionData(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCNmRootMotionData>("CNmRootMotionData")
        .addConstructor<void (*)(std::string)>()
        .addProperty("NumFrames", &GCNmRootMotionData::GetNumFrames, &GCNmRootMotionData::SetNumFrames)
        .addProperty("AverageLinearVelocity", &GCNmRootMotionData::GetAverageLinearVelocity, &GCNmRootMotionData::SetAverageLinearVelocity)
        .addProperty("AverageAngularVelocityRadians", &GCNmRootMotionData::GetAverageAngularVelocityRadians, &GCNmRootMotionData::SetAverageAngularVelocityRadians)
        .addFunction("ToPtr", &GCNmRootMotionData::ToPtr)
        .addFunction("IsValid", &GCNmRootMotionData::IsValid)
        .endClass();
}
GCAnimReplayFrame::GCAnimReplayFrame(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCAnimReplayFrame::GCAnimReplayFrame(void *ptr) {
    m_ptr = ptr;
}
float GCAnimReplayFrame::GetTimeStamp() const {
    return GetSchemaValue<float>(m_ptr, "CAnimReplayFrame", "m_timeStamp");
}
void GCAnimReplayFrame::SetTimeStamp(float value) {
    SetSchemaValue(m_ptr, "CAnimReplayFrame", "m_timeStamp", false, value);
}
std::string GCAnimReplayFrame::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCAnimReplayFrame::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCAnimReplayFrame(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCAnimReplayFrame>("CAnimReplayFrame")
        .addConstructor<void (*)(std::string)>()
        .addProperty("TimeStamp", &GCAnimReplayFrame::GetTimeStamp, &GCAnimReplayFrame::SetTimeStamp)
        .addFunction("ToPtr", &GCAnimReplayFrame::ToPtr)
        .addFunction("IsValid", &GCAnimReplayFrame::IsValid)
        .endClass();
}
GCNmVirtualParameterBoneMaskNode::GCNmVirtualParameterBoneMaskNode(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCNmVirtualParameterBoneMaskNode::GCNmVirtualParameterBoneMaskNode(void *ptr) {
    m_ptr = ptr;
}
int16_t GCNmVirtualParameterBoneMaskNode::GetChildNodeIdx() const {
    return GetSchemaValue<int16_t>(m_ptr, "CNmVirtualParameterBoneMaskNode", "m_nChildNodeIdx");
}
void GCNmVirtualParameterBoneMaskNode::SetChildNodeIdx(int16_t value) {
    SetSchemaValue(m_ptr, "CNmVirtualParameterBoneMaskNode", "m_nChildNodeIdx", false, value);
}
std::string GCNmVirtualParameterBoneMaskNode::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCNmVirtualParameterBoneMaskNode::IsValid() {
    return (m_ptr != nullptr);
}
GCNmBoneMaskValueNode GCNmVirtualParameterBoneMaskNode::GetParent() const {
    GCNmBoneMaskValueNode value(m_ptr);
    return value;
}
void GCNmVirtualParameterBoneMaskNode::SetParent(GCNmBoneMaskValueNode value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCNmVirtualParameterBoneMaskNode(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCNmVirtualParameterBoneMaskNode>("CNmVirtualParameterBoneMaskNode")
        .addConstructor<void (*)(std::string)>()
        .addProperty("ChildNodeIdx", &GCNmVirtualParameterBoneMaskNode::GetChildNodeIdx, &GCNmVirtualParameterBoneMaskNode::SetChildNodeIdx)
        .addProperty("Parent", &GCNmVirtualParameterBoneMaskNode::GetParent, &GCNmVirtualParameterBoneMaskNode::SetParent)
        .addFunction("ToPtr", &GCNmVirtualParameterBoneMaskNode::ToPtr)
        .addFunction("IsValid", &GCNmVirtualParameterBoneMaskNode::IsValid)
        .endClass();
}
GCBlockSelectionMetricEvaluator::GCBlockSelectionMetricEvaluator(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCBlockSelectionMetricEvaluator::GCBlockSelectionMetricEvaluator(void *ptr) {
    m_ptr = ptr;
}
std::string GCBlockSelectionMetricEvaluator::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCBlockSelectionMetricEvaluator::IsValid() {
    return (m_ptr != nullptr);
}
GCMotionMetricEvaluator GCBlockSelectionMetricEvaluator::GetParent() const {
    GCMotionMetricEvaluator value(m_ptr);
    return value;
}
void GCBlockSelectionMetricEvaluator::SetParent(GCMotionMetricEvaluator value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCBlockSelectionMetricEvaluator(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCBlockSelectionMetricEvaluator>("CBlockSelectionMetricEvaluator")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCBlockSelectionMetricEvaluator::GetParent, &GCBlockSelectionMetricEvaluator::SetParent)
        .addFunction("ToPtr", &GCBlockSelectionMetricEvaluator::ToPtr)
        .addFunction("IsValid", &GCBlockSelectionMetricEvaluator::IsValid)
        .endClass();
}
GCMotionGraph::GCMotionGraph(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCMotionGraph::GCMotionGraph(void *ptr) {
    m_ptr = ptr;
}
GCParamSpanUpdater GCMotionGraph::GetParamSpans() const {
    GCParamSpanUpdater value(GetSchemaPtr(m_ptr, "CMotionGraph", "m_paramSpans"));
    return value;
}
void GCMotionGraph::SetParamSpans(GCParamSpanUpdater value) {
    SetSchemaValue(m_ptr, "CMotionGraph", "m_paramSpans", false, value);
}
std::vector<GTagSpan_t> GCMotionGraph::GetTags() const {
    CUtlVector<GTagSpan_t>* vec = GetSchemaValue<CUtlVector<GTagSpan_t>*>(m_ptr, "CMotionGraph", "m_tags"); std::vector<GTagSpan_t> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCMotionGraph::SetTags(std::vector<GTagSpan_t> value) {
    SetSchemaValueCUtlVector<GTagSpan_t>(m_ptr, "CMotionGraph", "m_tags", false, value);
}
int32_t GCMotionGraph::GetParameterCount() const {
    return GetSchemaValue<int32_t>(m_ptr, "CMotionGraph", "m_nParameterCount");
}
void GCMotionGraph::SetParameterCount(int32_t value) {
    SetSchemaValue(m_ptr, "CMotionGraph", "m_nParameterCount", false, value);
}
int32_t GCMotionGraph::GetConfigStartIndex() const {
    return GetSchemaValue<int32_t>(m_ptr, "CMotionGraph", "m_nConfigStartIndex");
}
void GCMotionGraph::SetConfigStartIndex(int32_t value) {
    SetSchemaValue(m_ptr, "CMotionGraph", "m_nConfigStartIndex", false, value);
}
int32_t GCMotionGraph::GetConfigCount() const {
    return GetSchemaValue<int32_t>(m_ptr, "CMotionGraph", "m_nConfigCount");
}
void GCMotionGraph::SetConfigCount(int32_t value) {
    SetSchemaValue(m_ptr, "CMotionGraph", "m_nConfigCount", false, value);
}
bool GCMotionGraph::GetLoop() const {
    return GetSchemaValue<bool>(m_ptr, "CMotionGraph", "m_bLoop");
}
void GCMotionGraph::SetLoop(bool value) {
    SetSchemaValue(m_ptr, "CMotionGraph", "m_bLoop", false, value);
}
std::string GCMotionGraph::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCMotionGraph::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCMotionGraph(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCMotionGraph>("CMotionGraph")
        .addConstructor<void (*)(std::string)>()
        .addProperty("ParamSpans", &GCMotionGraph::GetParamSpans, &GCMotionGraph::SetParamSpans)
        .addProperty("Tags", &GCMotionGraph::GetTags, &GCMotionGraph::SetTags)
        .addProperty("ParameterCount", &GCMotionGraph::GetParameterCount, &GCMotionGraph::SetParameterCount)
        .addProperty("ConfigStartIndex", &GCMotionGraph::GetConfigStartIndex, &GCMotionGraph::SetConfigStartIndex)
        .addProperty("ConfigCount", &GCMotionGraph::GetConfigCount, &GCMotionGraph::SetConfigCount)
        .addProperty("Loop", &GCMotionGraph::GetLoop, &GCMotionGraph::SetLoop)
        .addFunction("ToPtr", &GCMotionGraph::ToPtr)
        .addFunction("IsValid", &GCMotionGraph::IsValid)
        .endClass();
}
GCSosSoundEventGroupSchema::GCSosSoundEventGroupSchema(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCSosSoundEventGroupSchema::GCSosSoundEventGroupSchema(void *ptr) {
    m_ptr = ptr;
}
std::string GCSosSoundEventGroupSchema::GetName() const {
    return GetSchemaValue<CUtlString>(m_ptr, "CSosSoundEventGroupSchema", "m_name").Get();
}
void GCSosSoundEventGroupSchema::SetName(std::string value) {
    SetSchemaValue(m_ptr, "CSosSoundEventGroupSchema", "m_name", false, CUtlString(value.c_str()));
}
uint64_t GCSosSoundEventGroupSchema::GetType() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CSosSoundEventGroupSchema", "m_nType");
}
void GCSosSoundEventGroupSchema::SetType(uint64_t value) {
    SetSchemaValue(m_ptr, "CSosSoundEventGroupSchema", "m_nType", false, value);
}
bool GCSosSoundEventGroupSchema::GetIsBlocking() const {
    return GetSchemaValue<bool>(m_ptr, "CSosSoundEventGroupSchema", "m_bIsBlocking");
}
void GCSosSoundEventGroupSchema::SetIsBlocking(bool value) {
    SetSchemaValue(m_ptr, "CSosSoundEventGroupSchema", "m_bIsBlocking", false, value);
}
int32_t GCSosSoundEventGroupSchema::GetBlockMaxCount() const {
    return GetSchemaValue<int32_t>(m_ptr, "CSosSoundEventGroupSchema", "m_nBlockMaxCount");
}
void GCSosSoundEventGroupSchema::SetBlockMaxCount(int32_t value) {
    SetSchemaValue(m_ptr, "CSosSoundEventGroupSchema", "m_nBlockMaxCount", false, value);
}
bool GCSosSoundEventGroupSchema::GetInvertMatch() const {
    return GetSchemaValue<bool>(m_ptr, "CSosSoundEventGroupSchema", "m_bInvertMatch");
}
void GCSosSoundEventGroupSchema::SetInvertMatch(bool value) {
    SetSchemaValue(m_ptr, "CSosSoundEventGroupSchema", "m_bInvertMatch", false, value);
}
GCSosGroupMatchPattern GCSosSoundEventGroupSchema::GetMatchPattern() const {
    GCSosGroupMatchPattern value(GetSchemaPtr(m_ptr, "CSosSoundEventGroupSchema", "m_matchPattern"));
    return value;
}
void GCSosSoundEventGroupSchema::SetMatchPattern(GCSosGroupMatchPattern value) {
    SetSchemaValue(m_ptr, "CSosSoundEventGroupSchema", "m_matchPattern", false, value);
}
GCSosGroupBranchPattern GCSosSoundEventGroupSchema::GetBranchPattern() const {
    GCSosGroupBranchPattern value(GetSchemaPtr(m_ptr, "CSosSoundEventGroupSchema", "m_branchPattern"));
    return value;
}
void GCSosSoundEventGroupSchema::SetBranchPattern(GCSosGroupBranchPattern value) {
    SetSchemaValue(m_ptr, "CSosSoundEventGroupSchema", "m_branchPattern", false, value);
}
float GCSosSoundEventGroupSchema::GetLifeSpanTime() const {
    return GetSchemaValue<float>(m_ptr, "CSosSoundEventGroupSchema", "m_flLifeSpanTime");
}
void GCSosSoundEventGroupSchema::SetLifeSpanTime(float value) {
    SetSchemaValue(m_ptr, "CSosSoundEventGroupSchema", "m_flLifeSpanTime", false, value);
}
std::vector<GCSosGroupActionSchema*> GCSosSoundEventGroupSchema::GetActions() const {
    GCSosGroupActionSchema** outValue = GetSchemaValue<GCSosGroupActionSchema**>(m_ptr, "CSosSoundEventGroupSchema", "m_vActions"); std::vector<GCSosGroupActionSchema*> ret; for(int i = 0; i < 4; i++) { ret.push_back(outValue[i]); } return ret;
}
void GCSosSoundEventGroupSchema::SetActions(std::vector<GCSosGroupActionSchema*> value) {
    GCSosGroupActionSchema** outValue = GetSchemaValue<GCSosGroupActionSchema**>(m_ptr, "CSosSoundEventGroupSchema", "m_vActions"); for(int i = 0; i < 4; i++) { outValue[i] = value[i]; } SetSchemaValue(m_ptr, "CSosSoundEventGroupSchema", "m_vActions", false, outValue);
}
std::string GCSosSoundEventGroupSchema::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCSosSoundEventGroupSchema::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCSosSoundEventGroupSchema(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCSosSoundEventGroupSchema>("CSosSoundEventGroupSchema")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Name", &GCSosSoundEventGroupSchema::GetName, &GCSosSoundEventGroupSchema::SetName)
        .addProperty("Type", &GCSosSoundEventGroupSchema::GetType, &GCSosSoundEventGroupSchema::SetType)
        .addProperty("IsBlocking", &GCSosSoundEventGroupSchema::GetIsBlocking, &GCSosSoundEventGroupSchema::SetIsBlocking)
        .addProperty("BlockMaxCount", &GCSosSoundEventGroupSchema::GetBlockMaxCount, &GCSosSoundEventGroupSchema::SetBlockMaxCount)
        .addProperty("InvertMatch", &GCSosSoundEventGroupSchema::GetInvertMatch, &GCSosSoundEventGroupSchema::SetInvertMatch)
        .addProperty("MatchPattern", &GCSosSoundEventGroupSchema::GetMatchPattern, &GCSosSoundEventGroupSchema::SetMatchPattern)
        .addProperty("BranchPattern", &GCSosSoundEventGroupSchema::GetBranchPattern, &GCSosSoundEventGroupSchema::SetBranchPattern)
        .addProperty("LifeSpanTime", &GCSosSoundEventGroupSchema::GetLifeSpanTime, &GCSosSoundEventGroupSchema::SetLifeSpanTime)
        .addProperty("Actions", &GCSosSoundEventGroupSchema::GetActions, &GCSosSoundEventGroupSchema::SetActions)
        .addFunction("ToPtr", &GCSosSoundEventGroupSchema::ToPtr)
        .addFunction("IsValid", &GCSosSoundEventGroupSchema::IsValid)
        .endClass();
}
GCFootMotion::GCFootMotion(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCFootMotion::GCFootMotion(void *ptr) {
    m_ptr = ptr;
}
std::vector<GCFootStride> GCFootMotion::GetStrides() const {
    CUtlVector<GCFootStride>* vec = GetSchemaValue<CUtlVector<GCFootStride>*>(m_ptr, "CFootMotion", "m_strides"); std::vector<GCFootStride> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCFootMotion::SetStrides(std::vector<GCFootStride> value) {
    SetSchemaValueCUtlVector<GCFootStride>(m_ptr, "CFootMotion", "m_strides", false, value);
}
std::string GCFootMotion::GetName() const {
    return GetSchemaValue<CUtlString>(m_ptr, "CFootMotion", "m_name").Get();
}
void GCFootMotion::SetName(std::string value) {
    SetSchemaValue(m_ptr, "CFootMotion", "m_name", false, CUtlString(value.c_str()));
}
bool GCFootMotion::GetAdditive() const {
    return GetSchemaValue<bool>(m_ptr, "CFootMotion", "m_bAdditive");
}
void GCFootMotion::SetAdditive(bool value) {
    SetSchemaValue(m_ptr, "CFootMotion", "m_bAdditive", false, value);
}
std::string GCFootMotion::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCFootMotion::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCFootMotion(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCFootMotion>("CFootMotion")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Strides", &GCFootMotion::GetStrides, &GCFootMotion::SetStrides)
        .addProperty("Name", &GCFootMotion::GetName, &GCFootMotion::SetName)
        .addProperty("Additive", &GCFootMotion::GetAdditive, &GCFootMotion::SetAdditive)
        .addFunction("ToPtr", &GCFootMotion::ToPtr)
        .addFunction("IsValid", &GCFootMotion::IsValid)
        .endClass();
}
GCDampedValueUpdateItem::GCDampedValueUpdateItem(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCDampedValueUpdateItem::GCDampedValueUpdateItem(void *ptr) {
    m_ptr = ptr;
}
GCAnimInputDamping GCDampedValueUpdateItem::GetDamping() const {
    GCAnimInputDamping value(GetSchemaPtr(m_ptr, "CDampedValueUpdateItem", "m_damping"));
    return value;
}
void GCDampedValueUpdateItem::SetDamping(GCAnimInputDamping value) {
    SetSchemaValue(m_ptr, "CDampedValueUpdateItem", "m_damping", false, value);
}
GCAnimParamHandle GCDampedValueUpdateItem::GetParamIn() const {
    GCAnimParamHandle value(GetSchemaPtr(m_ptr, "CDampedValueUpdateItem", "m_hParamIn"));
    return value;
}
void GCDampedValueUpdateItem::SetParamIn(GCAnimParamHandle value) {
    SetSchemaValue(m_ptr, "CDampedValueUpdateItem", "m_hParamIn", false, value);
}
GCAnimParamHandle GCDampedValueUpdateItem::GetParamOut() const {
    GCAnimParamHandle value(GetSchemaPtr(m_ptr, "CDampedValueUpdateItem", "m_hParamOut"));
    return value;
}
void GCDampedValueUpdateItem::SetParamOut(GCAnimParamHandle value) {
    SetSchemaValue(m_ptr, "CDampedValueUpdateItem", "m_hParamOut", false, value);
}
std::string GCDampedValueUpdateItem::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCDampedValueUpdateItem::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCDampedValueUpdateItem(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCDampedValueUpdateItem>("CDampedValueUpdateItem")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Damping", &GCDampedValueUpdateItem::GetDamping, &GCDampedValueUpdateItem::SetDamping)
        .addProperty("ParamIn", &GCDampedValueUpdateItem::GetParamIn, &GCDampedValueUpdateItem::SetParamIn)
        .addProperty("ParamOut", &GCDampedValueUpdateItem::GetParamOut, &GCDampedValueUpdateItem::SetParamOut)
        .addFunction("ToPtr", &GCDampedValueUpdateItem::ToPtr)
        .addFunction("IsValid", &GCDampedValueUpdateItem::IsValid)
        .endClass();
}
GRnHalfEdge_t::GRnHalfEdge_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GRnHalfEdge_t::GRnHalfEdge_t(void *ptr) {
    m_ptr = ptr;
}
uint8_t GRnHalfEdge_t::GetNext() const {
    return GetSchemaValue<uint8_t>(m_ptr, "RnHalfEdge_t", "m_nNext");
}
void GRnHalfEdge_t::SetNext(uint8_t value) {
    SetSchemaValue(m_ptr, "RnHalfEdge_t", "m_nNext", true, value);
}
uint8_t GRnHalfEdge_t::GetTwin() const {
    return GetSchemaValue<uint8_t>(m_ptr, "RnHalfEdge_t", "m_nTwin");
}
void GRnHalfEdge_t::SetTwin(uint8_t value) {
    SetSchemaValue(m_ptr, "RnHalfEdge_t", "m_nTwin", true, value);
}
uint8_t GRnHalfEdge_t::GetOrigin() const {
    return GetSchemaValue<uint8_t>(m_ptr, "RnHalfEdge_t", "m_nOrigin");
}
void GRnHalfEdge_t::SetOrigin(uint8_t value) {
    SetSchemaValue(m_ptr, "RnHalfEdge_t", "m_nOrigin", true, value);
}
uint8_t GRnHalfEdge_t::GetFace() const {
    return GetSchemaValue<uint8_t>(m_ptr, "RnHalfEdge_t", "m_nFace");
}
void GRnHalfEdge_t::SetFace(uint8_t value) {
    SetSchemaValue(m_ptr, "RnHalfEdge_t", "m_nFace", true, value);
}
std::string GRnHalfEdge_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GRnHalfEdge_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassRnHalfEdge_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GRnHalfEdge_t>("RnHalfEdge_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Next", &GRnHalfEdge_t::GetNext, &GRnHalfEdge_t::SetNext)
        .addProperty("Twin", &GRnHalfEdge_t::GetTwin, &GRnHalfEdge_t::SetTwin)
        .addProperty("Origin", &GRnHalfEdge_t::GetOrigin, &GRnHalfEdge_t::SetOrigin)
        .addProperty("Face", &GRnHalfEdge_t::GetFace, &GRnHalfEdge_t::SetFace)
        .addFunction("ToPtr", &GRnHalfEdge_t::ToPtr)
        .addFunction("IsValid", &GRnHalfEdge_t::IsValid)
        .endClass();
}
GCAnimDataChannelDesc::GCAnimDataChannelDesc(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCAnimDataChannelDesc::GCAnimDataChannelDesc(void *ptr) {
    m_ptr = ptr;
}
CBufferString GCAnimDataChannelDesc::GetChannelClass() const {
    return GetSchemaValue<CBufferString>(m_ptr, "CAnimDataChannelDesc", "m_szChannelClass");
}
void GCAnimDataChannelDesc::SetChannelClass(CBufferString value) {
    SetSchemaValue(m_ptr, "CAnimDataChannelDesc", "m_szChannelClass", false, value);
}
CBufferString GCAnimDataChannelDesc::GetVariableName() const {
    return GetSchemaValue<CBufferString>(m_ptr, "CAnimDataChannelDesc", "m_szVariableName");
}
void GCAnimDataChannelDesc::SetVariableName(CBufferString value) {
    SetSchemaValue(m_ptr, "CAnimDataChannelDesc", "m_szVariableName", false, value);
}
int32_t GCAnimDataChannelDesc::GetFlags() const {
    return GetSchemaValue<int32_t>(m_ptr, "CAnimDataChannelDesc", "m_nFlags");
}
void GCAnimDataChannelDesc::SetFlags(int32_t value) {
    SetSchemaValue(m_ptr, "CAnimDataChannelDesc", "m_nFlags", false, value);
}
int32_t GCAnimDataChannelDesc::GetType() const {
    return GetSchemaValue<int32_t>(m_ptr, "CAnimDataChannelDesc", "m_nType");
}
void GCAnimDataChannelDesc::SetType(int32_t value) {
    SetSchemaValue(m_ptr, "CAnimDataChannelDesc", "m_nType", false, value);
}
CBufferString GCAnimDataChannelDesc::GetGrouping() const {
    return GetSchemaValue<CBufferString>(m_ptr, "CAnimDataChannelDesc", "m_szGrouping");
}
void GCAnimDataChannelDesc::SetGrouping(CBufferString value) {
    SetSchemaValue(m_ptr, "CAnimDataChannelDesc", "m_szGrouping", false, value);
}
CBufferString GCAnimDataChannelDesc::GetDescription() const {
    return GetSchemaValue<CBufferString>(m_ptr, "CAnimDataChannelDesc", "m_szDescription");
}
void GCAnimDataChannelDesc::SetDescription(CBufferString value) {
    SetSchemaValue(m_ptr, "CAnimDataChannelDesc", "m_szDescription", false, value);
}
std::vector<CBufferString> GCAnimDataChannelDesc::GetElementNameArray() const {
    CUtlVector<CBufferString>* vec = GetSchemaValue<CUtlVector<CBufferString>*>(m_ptr, "CAnimDataChannelDesc", "m_szElementNameArray"); std::vector<CBufferString> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCAnimDataChannelDesc::SetElementNameArray(std::vector<CBufferString> value) {
    SetSchemaValueCUtlVector<CBufferString>(m_ptr, "CAnimDataChannelDesc", "m_szElementNameArray", false, value);
}
std::vector<int32> GCAnimDataChannelDesc::GetElementIndexArray() const {
    CUtlVector<int32>* vec = GetSchemaValue<CUtlVector<int32>*>(m_ptr, "CAnimDataChannelDesc", "m_nElementIndexArray"); std::vector<int32> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCAnimDataChannelDesc::SetElementIndexArray(std::vector<int32> value) {
    SetSchemaValueCUtlVector<int32>(m_ptr, "CAnimDataChannelDesc", "m_nElementIndexArray", false, value);
}
std::vector<uint32> GCAnimDataChannelDesc::GetElementMaskArray() const {
    CUtlVector<uint32>* vec = GetSchemaValue<CUtlVector<uint32>*>(m_ptr, "CAnimDataChannelDesc", "m_nElementMaskArray"); std::vector<uint32> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCAnimDataChannelDesc::SetElementMaskArray(std::vector<uint32> value) {
    SetSchemaValueCUtlVector<uint32>(m_ptr, "CAnimDataChannelDesc", "m_nElementMaskArray", false, value);
}
std::string GCAnimDataChannelDesc::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCAnimDataChannelDesc::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCAnimDataChannelDesc(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCAnimDataChannelDesc>("CAnimDataChannelDesc")
        .addConstructor<void (*)(std::string)>()
        .addProperty("ChannelClass", &GCAnimDataChannelDesc::GetChannelClass, &GCAnimDataChannelDesc::SetChannelClass)
        .addProperty("VariableName", &GCAnimDataChannelDesc::GetVariableName, &GCAnimDataChannelDesc::SetVariableName)
        .addProperty("Flags", &GCAnimDataChannelDesc::GetFlags, &GCAnimDataChannelDesc::SetFlags)
        .addProperty("Type", &GCAnimDataChannelDesc::GetType, &GCAnimDataChannelDesc::SetType)
        .addProperty("Grouping", &GCAnimDataChannelDesc::GetGrouping, &GCAnimDataChannelDesc::SetGrouping)
        .addProperty("Description", &GCAnimDataChannelDesc::GetDescription, &GCAnimDataChannelDesc::SetDescription)
        .addProperty("ElementNameArray", &GCAnimDataChannelDesc::GetElementNameArray, &GCAnimDataChannelDesc::SetElementNameArray)
        .addProperty("ElementIndexArray", &GCAnimDataChannelDesc::GetElementIndexArray, &GCAnimDataChannelDesc::SetElementIndexArray)
        .addProperty("ElementMaskArray", &GCAnimDataChannelDesc::GetElementMaskArray, &GCAnimDataChannelDesc::SetElementMaskArray)
        .addFunction("ToPtr", &GCAnimDataChannelDesc::ToPtr)
        .addFunction("IsValid", &GCAnimDataChannelDesc::IsValid)
        .endClass();
}
GEventClientProcessNetworking_t::GEventClientProcessNetworking_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GEventClientProcessNetworking_t::GEventClientProcessNetworking_t(void *ptr) {
    m_ptr = ptr;
}
std::string GEventClientProcessNetworking_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GEventClientProcessNetworking_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassEventClientProcessNetworking_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GEventClientProcessNetworking_t>("EventClientProcessNetworking_t")
        .addConstructor<void (*)(std::string)>()
        .addFunction("ToPtr", &GEventClientProcessNetworking_t::ToPtr)
        .addFunction("IsValid", &GEventClientProcessNetworking_t::IsValid)
        .endClass();
}
GCModelConfigList::GCModelConfigList(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCModelConfigList::GCModelConfigList(void *ptr) {
    m_ptr = ptr;
}
bool GCModelConfigList::GetHideMaterialGroupInTools() const {
    return GetSchemaValue<bool>(m_ptr, "CModelConfigList", "m_bHideMaterialGroupInTools");
}
void GCModelConfigList::SetHideMaterialGroupInTools(bool value) {
    SetSchemaValue(m_ptr, "CModelConfigList", "m_bHideMaterialGroupInTools", false, value);
}
bool GCModelConfigList::GetHideRenderColorInTools() const {
    return GetSchemaValue<bool>(m_ptr, "CModelConfigList", "m_bHideRenderColorInTools");
}
void GCModelConfigList::SetHideRenderColorInTools(bool value) {
    SetSchemaValue(m_ptr, "CModelConfigList", "m_bHideRenderColorInTools", false, value);
}
std::vector<GCModelConfig*> GCModelConfigList::GetConfigs() const {
    CUtlVector<GCModelConfig*>* vec = GetSchemaValue<CUtlVector<GCModelConfig*>*>(m_ptr, "CModelConfigList", "m_Configs"); std::vector<GCModelConfig*> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCModelConfigList::SetConfigs(std::vector<GCModelConfig*> value) {
    SetSchemaValueCUtlVector<GCModelConfig*>(m_ptr, "CModelConfigList", "m_Configs", false, value);
}
std::string GCModelConfigList::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCModelConfigList::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCModelConfigList(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCModelConfigList>("CModelConfigList")
        .addConstructor<void (*)(std::string)>()
        .addProperty("HideMaterialGroupInTools", &GCModelConfigList::GetHideMaterialGroupInTools, &GCModelConfigList::SetHideMaterialGroupInTools)
        .addProperty("HideRenderColorInTools", &GCModelConfigList::GetHideRenderColorInTools, &GCModelConfigList::SetHideRenderColorInTools)
        .addProperty("Configs", &GCModelConfigList::GetConfigs, &GCModelConfigList::SetConfigs)
        .addFunction("ToPtr", &GCModelConfigList::ToPtr)
        .addFunction("IsValid", &GCModelConfigList::IsValid)
        .endClass();
}
GCNmGraphVariation::GCNmGraphVariation(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCNmGraphVariation::GCNmGraphVariation(void *ptr) {
    m_ptr = ptr;
}
std::string GCNmGraphVariation::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCNmGraphVariation::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCNmGraphVariation(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCNmGraphVariation>("CNmGraphVariation")
        .addConstructor<void (*)(std::string)>()
        .addFunction("ToPtr", &GCNmGraphVariation::ToPtr)
        .addFunction("IsValid", &GCNmGraphVariation::IsValid)
        .endClass();
}
GCSosGroupActionTimeBlockLimitSchema::GCSosGroupActionTimeBlockLimitSchema(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCSosGroupActionTimeBlockLimitSchema::GCSosGroupActionTimeBlockLimitSchema(void *ptr) {
    m_ptr = ptr;
}
int32_t GCSosGroupActionTimeBlockLimitSchema::GetMaxCount() const {
    return GetSchemaValue<int32_t>(m_ptr, "CSosGroupActionTimeBlockLimitSchema", "m_nMaxCount");
}
void GCSosGroupActionTimeBlockLimitSchema::SetMaxCount(int32_t value) {
    SetSchemaValue(m_ptr, "CSosGroupActionTimeBlockLimitSchema", "m_nMaxCount", false, value);
}
float GCSosGroupActionTimeBlockLimitSchema::GetMaxDuration() const {
    return GetSchemaValue<float>(m_ptr, "CSosGroupActionTimeBlockLimitSchema", "m_flMaxDuration");
}
void GCSosGroupActionTimeBlockLimitSchema::SetMaxDuration(float value) {
    SetSchemaValue(m_ptr, "CSosGroupActionTimeBlockLimitSchema", "m_flMaxDuration", false, value);
}
std::string GCSosGroupActionTimeBlockLimitSchema::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCSosGroupActionTimeBlockLimitSchema::IsValid() {
    return (m_ptr != nullptr);
}
GCSosGroupActionSchema GCSosGroupActionTimeBlockLimitSchema::GetParent() const {
    GCSosGroupActionSchema value(m_ptr);
    return value;
}
void GCSosGroupActionTimeBlockLimitSchema::SetParent(GCSosGroupActionSchema value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCSosGroupActionTimeBlockLimitSchema(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCSosGroupActionTimeBlockLimitSchema>("CSosGroupActionTimeBlockLimitSchema")
        .addConstructor<void (*)(std::string)>()
        .addProperty("MaxCount", &GCSosGroupActionTimeBlockLimitSchema::GetMaxCount, &GCSosGroupActionTimeBlockLimitSchema::SetMaxCount)
        .addProperty("MaxDuration", &GCSosGroupActionTimeBlockLimitSchema::GetMaxDuration, &GCSosGroupActionTimeBlockLimitSchema::SetMaxDuration)
        .addProperty("Parent", &GCSosGroupActionTimeBlockLimitSchema::GetParent, &GCSosGroupActionTimeBlockLimitSchema::SetParent)
        .addFunction("ToPtr", &GCSosGroupActionTimeBlockLimitSchema::ToPtr)
        .addFunction("IsValid", &GCSosGroupActionTimeBlockLimitSchema::IsValid)
        .endClass();
}
GVMixDynamics3BandDesc_t::GVMixDynamics3BandDesc_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GVMixDynamics3BandDesc_t::GVMixDynamics3BandDesc_t(void *ptr) {
    m_ptr = ptr;
}
float GVMixDynamics3BandDesc_t::GetFldbGainOutput() const {
    return GetSchemaValue<float>(m_ptr, "VMixDynamics3BandDesc_t", "m_fldbGainOutput");
}
void GVMixDynamics3BandDesc_t::SetFldbGainOutput(float value) {
    SetSchemaValue(m_ptr, "VMixDynamics3BandDesc_t", "m_fldbGainOutput", true, value);
}
float GVMixDynamics3BandDesc_t::GetRMSTimeMS() const {
    return GetSchemaValue<float>(m_ptr, "VMixDynamics3BandDesc_t", "m_flRMSTimeMS");
}
void GVMixDynamics3BandDesc_t::SetRMSTimeMS(float value) {
    SetSchemaValue(m_ptr, "VMixDynamics3BandDesc_t", "m_flRMSTimeMS", true, value);
}
float GVMixDynamics3BandDesc_t::GetFldbKneeWidth() const {
    return GetSchemaValue<float>(m_ptr, "VMixDynamics3BandDesc_t", "m_fldbKneeWidth");
}
void GVMixDynamics3BandDesc_t::SetFldbKneeWidth(float value) {
    SetSchemaValue(m_ptr, "VMixDynamics3BandDesc_t", "m_fldbKneeWidth", true, value);
}
float GVMixDynamics3BandDesc_t::GetDepth() const {
    return GetSchemaValue<float>(m_ptr, "VMixDynamics3BandDesc_t", "m_flDepth");
}
void GVMixDynamics3BandDesc_t::SetDepth(float value) {
    SetSchemaValue(m_ptr, "VMixDynamics3BandDesc_t", "m_flDepth", true, value);
}
float GVMixDynamics3BandDesc_t::GetWetMix() const {
    return GetSchemaValue<float>(m_ptr, "VMixDynamics3BandDesc_t", "m_flWetMix");
}
void GVMixDynamics3BandDesc_t::SetWetMix(float value) {
    SetSchemaValue(m_ptr, "VMixDynamics3BandDesc_t", "m_flWetMix", true, value);
}
float GVMixDynamics3BandDesc_t::GetTimeScale() const {
    return GetSchemaValue<float>(m_ptr, "VMixDynamics3BandDesc_t", "m_flTimeScale");
}
void GVMixDynamics3BandDesc_t::SetTimeScale(float value) {
    SetSchemaValue(m_ptr, "VMixDynamics3BandDesc_t", "m_flTimeScale", true, value);
}
float GVMixDynamics3BandDesc_t::GetLowCutoffFreq() const {
    return GetSchemaValue<float>(m_ptr, "VMixDynamics3BandDesc_t", "m_flLowCutoffFreq");
}
void GVMixDynamics3BandDesc_t::SetLowCutoffFreq(float value) {
    SetSchemaValue(m_ptr, "VMixDynamics3BandDesc_t", "m_flLowCutoffFreq", true, value);
}
float GVMixDynamics3BandDesc_t::GetHighCutoffFreq() const {
    return GetSchemaValue<float>(m_ptr, "VMixDynamics3BandDesc_t", "m_flHighCutoffFreq");
}
void GVMixDynamics3BandDesc_t::SetHighCutoffFreq(float value) {
    SetSchemaValue(m_ptr, "VMixDynamics3BandDesc_t", "m_flHighCutoffFreq", true, value);
}
bool GVMixDynamics3BandDesc_t::GetPeakMode() const {
    return GetSchemaValue<bool>(m_ptr, "VMixDynamics3BandDesc_t", "m_bPeakMode");
}
void GVMixDynamics3BandDesc_t::SetPeakMode(bool value) {
    SetSchemaValue(m_ptr, "VMixDynamics3BandDesc_t", "m_bPeakMode", true, value);
}
std::vector<GVMixDynamicsBand_t> GVMixDynamics3BandDesc_t::GetBandDesc() const {
    GVMixDynamicsBand_t* outValue = GetSchemaValue<GVMixDynamicsBand_t*>(m_ptr, "VMixDynamics3BandDesc_t", "m_bandDesc"); std::vector<GVMixDynamicsBand_t> ret; for(int i = 0; i < 3; i++) { ret.push_back(outValue[i]); } return ret;
}
void GVMixDynamics3BandDesc_t::SetBandDesc(std::vector<GVMixDynamicsBand_t> value) {
    GVMixDynamicsBand_t* outValue = GetSchemaValue<GVMixDynamicsBand_t*>(m_ptr, "VMixDynamics3BandDesc_t", "m_bandDesc"); for(int i = 0; i < 3; i++) { outValue[i] = value[i]; } SetSchemaValue(m_ptr, "VMixDynamics3BandDesc_t", "m_bandDesc", true, outValue);
}
std::string GVMixDynamics3BandDesc_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GVMixDynamics3BandDesc_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassVMixDynamics3BandDesc_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GVMixDynamics3BandDesc_t>("VMixDynamics3BandDesc_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("FldbGainOutput", &GVMixDynamics3BandDesc_t::GetFldbGainOutput, &GVMixDynamics3BandDesc_t::SetFldbGainOutput)
        .addProperty("RMSTimeMS", &GVMixDynamics3BandDesc_t::GetRMSTimeMS, &GVMixDynamics3BandDesc_t::SetRMSTimeMS)
        .addProperty("FldbKneeWidth", &GVMixDynamics3BandDesc_t::GetFldbKneeWidth, &GVMixDynamics3BandDesc_t::SetFldbKneeWidth)
        .addProperty("Depth", &GVMixDynamics3BandDesc_t::GetDepth, &GVMixDynamics3BandDesc_t::SetDepth)
        .addProperty("WetMix", &GVMixDynamics3BandDesc_t::GetWetMix, &GVMixDynamics3BandDesc_t::SetWetMix)
        .addProperty("TimeScale", &GVMixDynamics3BandDesc_t::GetTimeScale, &GVMixDynamics3BandDesc_t::SetTimeScale)
        .addProperty("LowCutoffFreq", &GVMixDynamics3BandDesc_t::GetLowCutoffFreq, &GVMixDynamics3BandDesc_t::SetLowCutoffFreq)
        .addProperty("HighCutoffFreq", &GVMixDynamics3BandDesc_t::GetHighCutoffFreq, &GVMixDynamics3BandDesc_t::SetHighCutoffFreq)
        .addProperty("PeakMode", &GVMixDynamics3BandDesc_t::GetPeakMode, &GVMixDynamics3BandDesc_t::SetPeakMode)
        .addProperty("BandDesc", &GVMixDynamics3BandDesc_t::GetBandDesc, &GVMixDynamics3BandDesc_t::SetBandDesc)
        .addFunction("ToPtr", &GVMixDynamics3BandDesc_t::ToPtr)
        .addFunction("IsValid", &GVMixDynamics3BandDesc_t::IsValid)
        .endClass();
}
GCModelConfigElement_SetMaterialGroup::GCModelConfigElement_SetMaterialGroup(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCModelConfigElement_SetMaterialGroup::GCModelConfigElement_SetMaterialGroup(void *ptr) {
    m_ptr = ptr;
}
std::string GCModelConfigElement_SetMaterialGroup::GetMaterialGroupName() const {
    return GetSchemaValue<CUtlString>(m_ptr, "CModelConfigElement_SetMaterialGroup", "m_MaterialGroupName").Get();
}
void GCModelConfigElement_SetMaterialGroup::SetMaterialGroupName(std::string value) {
    SetSchemaValue(m_ptr, "CModelConfigElement_SetMaterialGroup", "m_MaterialGroupName", false, CUtlString(value.c_str()));
}
std::string GCModelConfigElement_SetMaterialGroup::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCModelConfigElement_SetMaterialGroup::IsValid() {
    return (m_ptr != nullptr);
}
GCModelConfigElement GCModelConfigElement_SetMaterialGroup::GetParent() const {
    GCModelConfigElement value(m_ptr);
    return value;
}
void GCModelConfigElement_SetMaterialGroup::SetParent(GCModelConfigElement value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCModelConfigElement_SetMaterialGroup(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCModelConfigElement_SetMaterialGroup>("CModelConfigElement_SetMaterialGroup")
        .addConstructor<void (*)(std::string)>()
        .addProperty("MaterialGroupName", &GCModelConfigElement_SetMaterialGroup::GetMaterialGroupName, &GCModelConfigElement_SetMaterialGroup::SetMaterialGroupName)
        .addProperty("Parent", &GCModelConfigElement_SetMaterialGroup::GetParent, &GCModelConfigElement_SetMaterialGroup::SetParent)
        .addFunction("ToPtr", &GCModelConfigElement_SetMaterialGroup::ToPtr)
        .addFunction("IsValid", &GCModelConfigElement_SetMaterialGroup::IsValid)
        .endClass();
}
GCMovementHandshakeAnimTag::GCMovementHandshakeAnimTag(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCMovementHandshakeAnimTag::GCMovementHandshakeAnimTag(void *ptr) {
    m_ptr = ptr;
}
std::string GCMovementHandshakeAnimTag::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCMovementHandshakeAnimTag::IsValid() {
    return (m_ptr != nullptr);
}
GCHandshakeAnimTagBase GCMovementHandshakeAnimTag::GetParent() const {
    GCHandshakeAnimTagBase value(m_ptr);
    return value;
}
void GCMovementHandshakeAnimTag::SetParent(GCHandshakeAnimTagBase value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCMovementHandshakeAnimTag(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCMovementHandshakeAnimTag>("CMovementHandshakeAnimTag")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCMovementHandshakeAnimTag::GetParent, &GCMovementHandshakeAnimTag::SetParent)
        .addFunction("ToPtr", &GCMovementHandshakeAnimTag::ToPtr)
        .addFunction("IsValid", &GCMovementHandshakeAnimTag::IsValid)
        .endClass();
}
GCSeqScaleSet::GCSeqScaleSet(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCSeqScaleSet::GCSeqScaleSet(void *ptr) {
    m_ptr = ptr;
}
CBufferString GCSeqScaleSet::GetName() const {
    return GetSchemaValue<CBufferString>(m_ptr, "CSeqScaleSet", "m_sName");
}
void GCSeqScaleSet::SetName(CBufferString value) {
    SetSchemaValue(m_ptr, "CSeqScaleSet", "m_sName", false, value);
}
bool GCSeqScaleSet::GetRootOffset() const {
    return GetSchemaValue<bool>(m_ptr, "CSeqScaleSet", "m_bRootOffset");
}
void GCSeqScaleSet::SetRootOffset(bool value) {
    SetSchemaValue(m_ptr, "CSeqScaleSet", "m_bRootOffset", false, value);
}
Vector GCSeqScaleSet::GetRootOffset1() const {
    return GetSchemaValue<Vector>(m_ptr, "CSeqScaleSet", "m_vRootOffset");
}
void GCSeqScaleSet::SetRootOffset1(Vector value) {
    SetSchemaValue(m_ptr, "CSeqScaleSet", "m_vRootOffset", false, value);
}
std::vector<int16> GCSeqScaleSet::GetLocalBoneArray() const {
    CUtlVector<int16>* vec = GetSchemaValue<CUtlVector<int16>*>(m_ptr, "CSeqScaleSet", "m_nLocalBoneArray"); std::vector<int16> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCSeqScaleSet::SetLocalBoneArray(std::vector<int16> value) {
    SetSchemaValueCUtlVector<int16>(m_ptr, "CSeqScaleSet", "m_nLocalBoneArray", false, value);
}
std::vector<float32> GCSeqScaleSet::GetBoneScaleArray() const {
    CUtlVector<float32>* vec = GetSchemaValue<CUtlVector<float32>*>(m_ptr, "CSeqScaleSet", "m_flBoneScaleArray"); std::vector<float32> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCSeqScaleSet::SetBoneScaleArray(std::vector<float32> value) {
    SetSchemaValueCUtlVector<float32>(m_ptr, "CSeqScaleSet", "m_flBoneScaleArray", false, value);
}
std::string GCSeqScaleSet::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCSeqScaleSet::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCSeqScaleSet(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCSeqScaleSet>("CSeqScaleSet")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Name", &GCSeqScaleSet::GetName, &GCSeqScaleSet::SetName)
        .addProperty("RootOffset", &GCSeqScaleSet::GetRootOffset, &GCSeqScaleSet::SetRootOffset)
        .addProperty("RootOffset1", &GCSeqScaleSet::GetRootOffset1, &GCSeqScaleSet::SetRootOffset1)
        .addProperty("LocalBoneArray", &GCSeqScaleSet::GetLocalBoneArray, &GCSeqScaleSet::SetLocalBoneArray)
        .addProperty("BoneScaleArray", &GCSeqScaleSet::GetBoneScaleArray, &GCSeqScaleSet::SetBoneScaleArray)
        .addFunction("ToPtr", &GCSeqScaleSet::ToPtr)
        .addFunction("IsValid", &GCSeqScaleSet::IsValid)
        .endClass();
}
GEventClientProcessGameInput_t::GEventClientProcessGameInput_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GEventClientProcessGameInput_t::GEventClientProcessGameInput_t(void *ptr) {
    m_ptr = ptr;
}
GEngineLoopState_t GEventClientProcessGameInput_t::GetLoopState() const {
    GEngineLoopState_t value(GetSchemaPtr(m_ptr, "EventClientProcessGameInput_t", "m_LoopState"));
    return value;
}
void GEventClientProcessGameInput_t::SetLoopState(GEngineLoopState_t value) {
    SetSchemaValue(m_ptr, "EventClientProcessGameInput_t", "m_LoopState", true, value);
}
float GEventClientProcessGameInput_t::GetRealTime() const {
    return GetSchemaValue<float>(m_ptr, "EventClientProcessGameInput_t", "m_flRealTime");
}
void GEventClientProcessGameInput_t::SetRealTime(float value) {
    SetSchemaValue(m_ptr, "EventClientProcessGameInput_t", "m_flRealTime", true, value);
}
float GEventClientProcessGameInput_t::GetFrameTime() const {
    return GetSchemaValue<float>(m_ptr, "EventClientProcessGameInput_t", "m_flFrameTime");
}
void GEventClientProcessGameInput_t::SetFrameTime(float value) {
    SetSchemaValue(m_ptr, "EventClientProcessGameInput_t", "m_flFrameTime", true, value);
}
std::string GEventClientProcessGameInput_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GEventClientProcessGameInput_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassEventClientProcessGameInput_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GEventClientProcessGameInput_t>("EventClientProcessGameInput_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("LoopState", &GEventClientProcessGameInput_t::GetLoopState, &GEventClientProcessGameInput_t::SetLoopState)
        .addProperty("RealTime", &GEventClientProcessGameInput_t::GetRealTime, &GEventClientProcessGameInput_t::SetRealTime)
        .addProperty("FrameTime", &GEventClientProcessGameInput_t::GetFrameTime, &GEventClientProcessGameInput_t::SetFrameTime)
        .addFunction("ToPtr", &GEventClientProcessGameInput_t::ToPtr)
        .addFunction("IsValid", &GEventClientProcessGameInput_t::IsValid)
        .endClass();
}
GVsInputSignatureElement_t::GVsInputSignatureElement_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GVsInputSignatureElement_t::GVsInputSignatureElement_t(void *ptr) {
    m_ptr = ptr;
}
std::string GVsInputSignatureElement_t::GetName() const {
    return GetSchemaValuePtr<char>(m_ptr, "VsInputSignatureElement_t", "m_pName");
}
void GVsInputSignatureElement_t::SetName(std::string value) {
    WriteSchemaPtrValue(m_ptr, "VsInputSignatureElement_t", "m_pName", true, reinterpret_cast<byte*>(const_cast<char*>(value.c_str())), 64);
}
std::string GVsInputSignatureElement_t::GetSemantic() const {
    return GetSchemaValuePtr<char>(m_ptr, "VsInputSignatureElement_t", "m_pSemantic");
}
void GVsInputSignatureElement_t::SetSemantic(std::string value) {
    WriteSchemaPtrValue(m_ptr, "VsInputSignatureElement_t", "m_pSemantic", true, reinterpret_cast<byte*>(const_cast<char*>(value.c_str())), 64);
}
std::string GVsInputSignatureElement_t::GetD3DSemanticName() const {
    return GetSchemaValuePtr<char>(m_ptr, "VsInputSignatureElement_t", "m_pD3DSemanticName");
}
void GVsInputSignatureElement_t::SetD3DSemanticName(std::string value) {
    WriteSchemaPtrValue(m_ptr, "VsInputSignatureElement_t", "m_pD3DSemanticName", true, reinterpret_cast<byte*>(const_cast<char*>(value.c_str())), 64);
}
int32_t GVsInputSignatureElement_t::GetD3DSemanticIndex() const {
    return GetSchemaValue<int32_t>(m_ptr, "VsInputSignatureElement_t", "m_nD3DSemanticIndex");
}
void GVsInputSignatureElement_t::SetD3DSemanticIndex(int32_t value) {
    SetSchemaValue(m_ptr, "VsInputSignatureElement_t", "m_nD3DSemanticIndex", true, value);
}
std::string GVsInputSignatureElement_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GVsInputSignatureElement_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassVsInputSignatureElement_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GVsInputSignatureElement_t>("VsInputSignatureElement_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Name", &GVsInputSignatureElement_t::GetName, &GVsInputSignatureElement_t::SetName)
        .addProperty("Semantic", &GVsInputSignatureElement_t::GetSemantic, &GVsInputSignatureElement_t::SetSemantic)
        .addProperty("D3DSemanticName", &GVsInputSignatureElement_t::GetD3DSemanticName, &GVsInputSignatureElement_t::SetD3DSemanticName)
        .addProperty("D3DSemanticIndex", &GVsInputSignatureElement_t::GetD3DSemanticIndex, &GVsInputSignatureElement_t::SetD3DSemanticIndex)
        .addFunction("ToPtr", &GVsInputSignatureElement_t::ToPtr)
        .addFunction("IsValid", &GVsInputSignatureElement_t::IsValid)
        .endClass();
}
GCompositeMaterialMatchFilter_t::GCompositeMaterialMatchFilter_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCompositeMaterialMatchFilter_t::GCompositeMaterialMatchFilter_t(void *ptr) {
    m_ptr = ptr;
}
uint64_t GCompositeMaterialMatchFilter_t::GetCompositeMaterialMatchFilterType() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CompositeMaterialMatchFilter_t", "m_nCompositeMaterialMatchFilterType");
}
void GCompositeMaterialMatchFilter_t::SetCompositeMaterialMatchFilterType(uint64_t value) {
    SetSchemaValue(m_ptr, "CompositeMaterialMatchFilter_t", "m_nCompositeMaterialMatchFilterType", true, value);
}
std::string GCompositeMaterialMatchFilter_t::GetStrMatchFilter() const {
    return GetSchemaValue<CUtlString>(m_ptr, "CompositeMaterialMatchFilter_t", "m_strMatchFilter").Get();
}
void GCompositeMaterialMatchFilter_t::SetStrMatchFilter(std::string value) {
    SetSchemaValue(m_ptr, "CompositeMaterialMatchFilter_t", "m_strMatchFilter", true, CUtlString(value.c_str()));
}
std::string GCompositeMaterialMatchFilter_t::GetStrMatchValue() const {
    return GetSchemaValue<CUtlString>(m_ptr, "CompositeMaterialMatchFilter_t", "m_strMatchValue").Get();
}
void GCompositeMaterialMatchFilter_t::SetStrMatchValue(std::string value) {
    SetSchemaValue(m_ptr, "CompositeMaterialMatchFilter_t", "m_strMatchValue", true, CUtlString(value.c_str()));
}
bool GCompositeMaterialMatchFilter_t::GetPassWhenTrue() const {
    return GetSchemaValue<bool>(m_ptr, "CompositeMaterialMatchFilter_t", "m_bPassWhenTrue");
}
void GCompositeMaterialMatchFilter_t::SetPassWhenTrue(bool value) {
    SetSchemaValue(m_ptr, "CompositeMaterialMatchFilter_t", "m_bPassWhenTrue", true, value);
}
std::string GCompositeMaterialMatchFilter_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCompositeMaterialMatchFilter_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCompositeMaterialMatchFilter_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCompositeMaterialMatchFilter_t>("CompositeMaterialMatchFilter_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("CompositeMaterialMatchFilterType", &GCompositeMaterialMatchFilter_t::GetCompositeMaterialMatchFilterType, &GCompositeMaterialMatchFilter_t::SetCompositeMaterialMatchFilterType)
        .addProperty("StrMatchFilter", &GCompositeMaterialMatchFilter_t::GetStrMatchFilter, &GCompositeMaterialMatchFilter_t::SetStrMatchFilter)
        .addProperty("StrMatchValue", &GCompositeMaterialMatchFilter_t::GetStrMatchValue, &GCompositeMaterialMatchFilter_t::SetStrMatchValue)
        .addProperty("PassWhenTrue", &GCompositeMaterialMatchFilter_t::GetPassWhenTrue, &GCompositeMaterialMatchFilter_t::SetPassWhenTrue)
        .addFunction("ToPtr", &GCompositeMaterialMatchFilter_t::ToPtr)
        .addFunction("IsValid", &GCompositeMaterialMatchFilter_t::IsValid)
        .endClass();
}
GVertexPositionColor_t::GVertexPositionColor_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GVertexPositionColor_t::GVertexPositionColor_t(void *ptr) {
    m_ptr = ptr;
}
Vector GVertexPositionColor_t::GetPosition() const {
    return GetSchemaValue<Vector>(m_ptr, "VertexPositionColor_t", "m_vPosition");
}
void GVertexPositionColor_t::SetPosition(Vector value) {
    SetSchemaValue(m_ptr, "VertexPositionColor_t", "m_vPosition", true, value);
}
std::string GVertexPositionColor_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GVertexPositionColor_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassVertexPositionColor_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GVertexPositionColor_t>("VertexPositionColor_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Position", &GVertexPositionColor_t::GetPosition, &GVertexPositionColor_t::SetPosition)
        .addFunction("ToPtr", &GVertexPositionColor_t::ToPtr)
        .addFunction("IsValid", &GVertexPositionColor_t::IsValid)
        .endClass();
}
GCFootTrajectories::GCFootTrajectories(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCFootTrajectories::GCFootTrajectories(void *ptr) {
    m_ptr = ptr;
}
std::vector<GCFootTrajectory> GCFootTrajectories::GetTrajectories() const {
    CUtlVector<GCFootTrajectory>* vec = GetSchemaValue<CUtlVector<GCFootTrajectory>*>(m_ptr, "CFootTrajectories", "m_trajectories"); std::vector<GCFootTrajectory> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCFootTrajectories::SetTrajectories(std::vector<GCFootTrajectory> value) {
    SetSchemaValueCUtlVector<GCFootTrajectory>(m_ptr, "CFootTrajectories", "m_trajectories", false, value);
}
std::string GCFootTrajectories::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCFootTrajectories::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCFootTrajectories(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCFootTrajectories>("CFootTrajectories")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Trajectories", &GCFootTrajectories::GetTrajectories, &GCFootTrajectories::SetTrajectories)
        .addFunction("ToPtr", &GCFootTrajectories::ToPtr)
        .addFunction("IsValid", &GCFootTrajectories::IsValid)
        .endClass();
}
GSceneObject_t::GSceneObject_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GSceneObject_t::GSceneObject_t(void *ptr) {
    m_ptr = ptr;
}
uint32_t GSceneObject_t::GetObjectID() const {
    return GetSchemaValue<uint32_t>(m_ptr, "SceneObject_t", "m_nObjectID");
}
void GSceneObject_t::SetObjectID(uint32_t value) {
    SetSchemaValue(m_ptr, "SceneObject_t", "m_nObjectID", true, value);
}
std::vector<Vector4D> GSceneObject_t::GetTransform() const {
    Vector4D* outValue = GetSchemaValue<Vector4D*>(m_ptr, "SceneObject_t", "m_vTransform"); std::vector<Vector4D> ret; for(int i = 0; i < 3; i++) { ret.push_back(outValue[i]); } return ret;
}
void GSceneObject_t::SetTransform(std::vector<Vector4D> value) {
    Vector4D* outValue = GetSchemaValue<Vector4D*>(m_ptr, "SceneObject_t", "m_vTransform"); for(int i = 0; i < 3; i++) { outValue[i] = value[i]; } SetSchemaValue(m_ptr, "SceneObject_t", "m_vTransform", true, outValue);
}
float GSceneObject_t::GetFadeStartDistance() const {
    return GetSchemaValue<float>(m_ptr, "SceneObject_t", "m_flFadeStartDistance");
}
void GSceneObject_t::SetFadeStartDistance(float value) {
    SetSchemaValue(m_ptr, "SceneObject_t", "m_flFadeStartDistance", true, value);
}
float GSceneObject_t::GetFadeEndDistance() const {
    return GetSchemaValue<float>(m_ptr, "SceneObject_t", "m_flFadeEndDistance");
}
void GSceneObject_t::SetFadeEndDistance(float value) {
    SetSchemaValue(m_ptr, "SceneObject_t", "m_flFadeEndDistance", true, value);
}
Vector4D GSceneObject_t::GetTintColor() const {
    return GetSchemaValue<Vector4D>(m_ptr, "SceneObject_t", "m_vTintColor");
}
void GSceneObject_t::SetTintColor(Vector4D value) {
    SetSchemaValue(m_ptr, "SceneObject_t", "m_vTintColor", true, value);
}
std::string GSceneObject_t::GetSkin() const {
    return GetSchemaValue<CUtlString>(m_ptr, "SceneObject_t", "m_skin").Get();
}
void GSceneObject_t::SetSkin(std::string value) {
    SetSchemaValue(m_ptr, "SceneObject_t", "m_skin", true, CUtlString(value.c_str()));
}
uint64_t GSceneObject_t::GetObjectTypeFlags() const {
    return GetSchemaValue<uint64_t>(m_ptr, "SceneObject_t", "m_nObjectTypeFlags");
}
void GSceneObject_t::SetObjectTypeFlags(uint64_t value) {
    SetSchemaValue(m_ptr, "SceneObject_t", "m_nObjectTypeFlags", true, value);
}
Vector GSceneObject_t::GetLightingOrigin() const {
    return GetSchemaValue<Vector>(m_ptr, "SceneObject_t", "m_vLightingOrigin");
}
void GSceneObject_t::SetLightingOrigin(Vector value) {
    SetSchemaValue(m_ptr, "SceneObject_t", "m_vLightingOrigin", true, value);
}
int16_t GSceneObject_t::GetOverlayRenderOrder() const {
    return GetSchemaValue<int16_t>(m_ptr, "SceneObject_t", "m_nOverlayRenderOrder");
}
void GSceneObject_t::SetOverlayRenderOrder(int16_t value) {
    SetSchemaValue(m_ptr, "SceneObject_t", "m_nOverlayRenderOrder", true, value);
}
int16_t GSceneObject_t::GetLODOverride() const {
    return GetSchemaValue<int16_t>(m_ptr, "SceneObject_t", "m_nLODOverride");
}
void GSceneObject_t::SetLODOverride(int16_t value) {
    SetSchemaValue(m_ptr, "SceneObject_t", "m_nLODOverride", true, value);
}
int32_t GSceneObject_t::GetCubeMapPrecomputedHandshake() const {
    return GetSchemaValue<int32_t>(m_ptr, "SceneObject_t", "m_nCubeMapPrecomputedHandshake");
}
void GSceneObject_t::SetCubeMapPrecomputedHandshake(int32_t value) {
    SetSchemaValue(m_ptr, "SceneObject_t", "m_nCubeMapPrecomputedHandshake", true, value);
}
int32_t GSceneObject_t::GetLightProbeVolumePrecomputedHandshake() const {
    return GetSchemaValue<int32_t>(m_ptr, "SceneObject_t", "m_nLightProbeVolumePrecomputedHandshake");
}
void GSceneObject_t::SetLightProbeVolumePrecomputedHandshake(int32_t value) {
    SetSchemaValue(m_ptr, "SceneObject_t", "m_nLightProbeVolumePrecomputedHandshake", true, value);
}
std::string GSceneObject_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GSceneObject_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassSceneObject_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GSceneObject_t>("SceneObject_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("ObjectID", &GSceneObject_t::GetObjectID, &GSceneObject_t::SetObjectID)
        .addProperty("Transform", &GSceneObject_t::GetTransform, &GSceneObject_t::SetTransform)
        .addProperty("FadeStartDistance", &GSceneObject_t::GetFadeStartDistance, &GSceneObject_t::SetFadeStartDistance)
        .addProperty("FadeEndDistance", &GSceneObject_t::GetFadeEndDistance, &GSceneObject_t::SetFadeEndDistance)
        .addProperty("TintColor", &GSceneObject_t::GetTintColor, &GSceneObject_t::SetTintColor)
        .addProperty("Skin", &GSceneObject_t::GetSkin, &GSceneObject_t::SetSkin)
        .addProperty("ObjectTypeFlags", &GSceneObject_t::GetObjectTypeFlags, &GSceneObject_t::SetObjectTypeFlags)
        .addProperty("LightingOrigin", &GSceneObject_t::GetLightingOrigin, &GSceneObject_t::SetLightingOrigin)
        .addProperty("OverlayRenderOrder", &GSceneObject_t::GetOverlayRenderOrder, &GSceneObject_t::SetOverlayRenderOrder)
        .addProperty("LODOverride", &GSceneObject_t::GetLODOverride, &GSceneObject_t::SetLODOverride)
        .addProperty("CubeMapPrecomputedHandshake", &GSceneObject_t::GetCubeMapPrecomputedHandshake, &GSceneObject_t::SetCubeMapPrecomputedHandshake)
        .addProperty("LightProbeVolumePrecomputedHandshake", &GSceneObject_t::GetLightProbeVolumePrecomputedHandshake, &GSceneObject_t::SetLightProbeVolumePrecomputedHandshake)
        .addFunction("ToPtr", &GSceneObject_t::ToPtr)
        .addFunction("IsValid", &GSceneObject_t::IsValid)
        .endClass();
}
GCSSDSMsg_ViewTarget::GCSSDSMsg_ViewTarget(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCSSDSMsg_ViewTarget::GCSSDSMsg_ViewTarget(void *ptr) {
    m_ptr = ptr;
}
std::string GCSSDSMsg_ViewTarget::GetName() const {
    return GetSchemaValue<CUtlString>(m_ptr, "CSSDSMsg_ViewTarget", "m_Name").Get();
}
void GCSSDSMsg_ViewTarget::SetName(std::string value) {
    SetSchemaValue(m_ptr, "CSSDSMsg_ViewTarget", "m_Name", false, CUtlString(value.c_str()));
}
uint64_t GCSSDSMsg_ViewTarget::GetTextureId() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CSSDSMsg_ViewTarget", "m_TextureId");
}
void GCSSDSMsg_ViewTarget::SetTextureId(uint64_t value) {
    SetSchemaValue(m_ptr, "CSSDSMsg_ViewTarget", "m_TextureId", false, value);
}
int32_t GCSSDSMsg_ViewTarget::GetWidth() const {
    return GetSchemaValue<int32_t>(m_ptr, "CSSDSMsg_ViewTarget", "m_nWidth");
}
void GCSSDSMsg_ViewTarget::SetWidth(int32_t value) {
    SetSchemaValue(m_ptr, "CSSDSMsg_ViewTarget", "m_nWidth", false, value);
}
int32_t GCSSDSMsg_ViewTarget::GetHeight() const {
    return GetSchemaValue<int32_t>(m_ptr, "CSSDSMsg_ViewTarget", "m_nHeight");
}
void GCSSDSMsg_ViewTarget::SetHeight(int32_t value) {
    SetSchemaValue(m_ptr, "CSSDSMsg_ViewTarget", "m_nHeight", false, value);
}
int32_t GCSSDSMsg_ViewTarget::GetRequestedWidth() const {
    return GetSchemaValue<int32_t>(m_ptr, "CSSDSMsg_ViewTarget", "m_nRequestedWidth");
}
void GCSSDSMsg_ViewTarget::SetRequestedWidth(int32_t value) {
    SetSchemaValue(m_ptr, "CSSDSMsg_ViewTarget", "m_nRequestedWidth", false, value);
}
int32_t GCSSDSMsg_ViewTarget::GetRequestedHeight() const {
    return GetSchemaValue<int32_t>(m_ptr, "CSSDSMsg_ViewTarget", "m_nRequestedHeight");
}
void GCSSDSMsg_ViewTarget::SetRequestedHeight(int32_t value) {
    SetSchemaValue(m_ptr, "CSSDSMsg_ViewTarget", "m_nRequestedHeight", false, value);
}
int32_t GCSSDSMsg_ViewTarget::GetNumMipLevels() const {
    return GetSchemaValue<int32_t>(m_ptr, "CSSDSMsg_ViewTarget", "m_nNumMipLevels");
}
void GCSSDSMsg_ViewTarget::SetNumMipLevels(int32_t value) {
    SetSchemaValue(m_ptr, "CSSDSMsg_ViewTarget", "m_nNumMipLevels", false, value);
}
int32_t GCSSDSMsg_ViewTarget::GetDepth() const {
    return GetSchemaValue<int32_t>(m_ptr, "CSSDSMsg_ViewTarget", "m_nDepth");
}
void GCSSDSMsg_ViewTarget::SetDepth(int32_t value) {
    SetSchemaValue(m_ptr, "CSSDSMsg_ViewTarget", "m_nDepth", false, value);
}
int32_t GCSSDSMsg_ViewTarget::GetMultisampleNumSamples() const {
    return GetSchemaValue<int32_t>(m_ptr, "CSSDSMsg_ViewTarget", "m_nMultisampleNumSamples");
}
void GCSSDSMsg_ViewTarget::SetMultisampleNumSamples(int32_t value) {
    SetSchemaValue(m_ptr, "CSSDSMsg_ViewTarget", "m_nMultisampleNumSamples", false, value);
}
int32_t GCSSDSMsg_ViewTarget::GetFormat() const {
    return GetSchemaValue<int32_t>(m_ptr, "CSSDSMsg_ViewTarget", "m_nFormat");
}
void GCSSDSMsg_ViewTarget::SetFormat(int32_t value) {
    SetSchemaValue(m_ptr, "CSSDSMsg_ViewTarget", "m_nFormat", false, value);
}
std::string GCSSDSMsg_ViewTarget::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCSSDSMsg_ViewTarget::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCSSDSMsg_ViewTarget(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCSSDSMsg_ViewTarget>("CSSDSMsg_ViewTarget")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Name", &GCSSDSMsg_ViewTarget::GetName, &GCSSDSMsg_ViewTarget::SetName)
        .addProperty("TextureId", &GCSSDSMsg_ViewTarget::GetTextureId, &GCSSDSMsg_ViewTarget::SetTextureId)
        .addProperty("Width", &GCSSDSMsg_ViewTarget::GetWidth, &GCSSDSMsg_ViewTarget::SetWidth)
        .addProperty("Height", &GCSSDSMsg_ViewTarget::GetHeight, &GCSSDSMsg_ViewTarget::SetHeight)
        .addProperty("RequestedWidth", &GCSSDSMsg_ViewTarget::GetRequestedWidth, &GCSSDSMsg_ViewTarget::SetRequestedWidth)
        .addProperty("RequestedHeight", &GCSSDSMsg_ViewTarget::GetRequestedHeight, &GCSSDSMsg_ViewTarget::SetRequestedHeight)
        .addProperty("NumMipLevels", &GCSSDSMsg_ViewTarget::GetNumMipLevels, &GCSSDSMsg_ViewTarget::SetNumMipLevels)
        .addProperty("Depth", &GCSSDSMsg_ViewTarget::GetDepth, &GCSSDSMsg_ViewTarget::SetDepth)
        .addProperty("MultisampleNumSamples", &GCSSDSMsg_ViewTarget::GetMultisampleNumSamples, &GCSSDSMsg_ViewTarget::SetMultisampleNumSamples)
        .addProperty("Format", &GCSSDSMsg_ViewTarget::GetFormat, &GCSSDSMsg_ViewTarget::SetFormat)
        .addFunction("ToPtr", &GCSSDSMsg_ViewTarget::ToPtr)
        .addFunction("IsValid", &GCSSDSMsg_ViewTarget::IsValid)
        .endClass();
}
GVMixSubgraphSwitchDesc_t::GVMixSubgraphSwitchDesc_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GVMixSubgraphSwitchDesc_t::GVMixSubgraphSwitchDesc_t(void *ptr) {
    m_ptr = ptr;
}
uint64_t GVMixSubgraphSwitchDesc_t::GetInterpolationMode() const {
    return GetSchemaValue<uint64_t>(m_ptr, "VMixSubgraphSwitchDesc_t", "m_interpolationMode");
}
void GVMixSubgraphSwitchDesc_t::SetInterpolationMode(uint64_t value) {
    SetSchemaValue(m_ptr, "VMixSubgraphSwitchDesc_t", "m_interpolationMode", true, value);
}
bool GVMixSubgraphSwitchDesc_t::GetOnlyTailsOnFadeOut() const {
    return GetSchemaValue<bool>(m_ptr, "VMixSubgraphSwitchDesc_t", "m_bOnlyTailsOnFadeOut");
}
void GVMixSubgraphSwitchDesc_t::SetOnlyTailsOnFadeOut(bool value) {
    SetSchemaValue(m_ptr, "VMixSubgraphSwitchDesc_t", "m_bOnlyTailsOnFadeOut", true, value);
}
float GVMixSubgraphSwitchDesc_t::GetInterpolationTime() const {
    return GetSchemaValue<float>(m_ptr, "VMixSubgraphSwitchDesc_t", "m_flInterpolationTime");
}
void GVMixSubgraphSwitchDesc_t::SetInterpolationTime(float value) {
    SetSchemaValue(m_ptr, "VMixSubgraphSwitchDesc_t", "m_flInterpolationTime", true, value);
}
std::string GVMixSubgraphSwitchDesc_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GVMixSubgraphSwitchDesc_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassVMixSubgraphSwitchDesc_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GVMixSubgraphSwitchDesc_t>("VMixSubgraphSwitchDesc_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("InterpolationMode", &GVMixSubgraphSwitchDesc_t::GetInterpolationMode, &GVMixSubgraphSwitchDesc_t::SetInterpolationMode)
        .addProperty("OnlyTailsOnFadeOut", &GVMixSubgraphSwitchDesc_t::GetOnlyTailsOnFadeOut, &GVMixSubgraphSwitchDesc_t::SetOnlyTailsOnFadeOut)
        .addProperty("InterpolationTime", &GVMixSubgraphSwitchDesc_t::GetInterpolationTime, &GVMixSubgraphSwitchDesc_t::SetInterpolationTime)
        .addFunction("ToPtr", &GVMixSubgraphSwitchDesc_t::ToPtr)
        .addFunction("IsValid", &GVMixSubgraphSwitchDesc_t::IsValid)
        .endClass();
}
GCNmTransitionNode::GCNmTransitionNode(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCNmTransitionNode::GCNmTransitionNode(void *ptr) {
    m_ptr = ptr;
}
int16_t GCNmTransitionNode::GetTargetCNmStateNodeIdx() const {
    return GetSchemaValue<int16_t>(m_ptr, "CNmTransitionNode", "m_targetCNmStateNodeIdx");
}
void GCNmTransitionNode::SetTargetCNmStateNodeIdx(int16_t value) {
    SetSchemaValue(m_ptr, "CNmTransitionNode", "m_targetCNmStateNodeIdx", false, value);
}
int16_t GCNmTransitionNode::GetDurationOverrideNodeIdx() const {
    return GetSchemaValue<int16_t>(m_ptr, "CNmTransitionNode", "m_durationOverrideNodeIdx");
}
void GCNmTransitionNode::SetDurationOverrideNodeIdx(int16_t value) {
    SetSchemaValue(m_ptr, "CNmTransitionNode", "m_durationOverrideNodeIdx", false, value);
}
int16_t GCNmTransitionNode::GetSyncEventOffsetOverrideNodeIdx() const {
    return GetSchemaValue<int16_t>(m_ptr, "CNmTransitionNode", "m_syncEventOffsetOverrideNodeIdx");
}
void GCNmTransitionNode::SetSyncEventOffsetOverrideNodeIdx(int16_t value) {
    SetSchemaValue(m_ptr, "CNmTransitionNode", "m_syncEventOffsetOverrideNodeIdx", false, value);
}
int16_t GCNmTransitionNode::GetStartBoneMaskNodeIdx() const {
    return GetSchemaValue<int16_t>(m_ptr, "CNmTransitionNode", "m_startBoneMaskNodeIdx");
}
void GCNmTransitionNode::SetStartBoneMaskNodeIdx(int16_t value) {
    SetSchemaValue(m_ptr, "CNmTransitionNode", "m_startBoneMaskNodeIdx", false, value);
}
float GCNmTransitionNode::GetDuration() const {
    return GetSchemaValue<float>(m_ptr, "CNmTransitionNode", "m_flDuration");
}
void GCNmTransitionNode::SetDuration(float value) {
    SetSchemaValue(m_ptr, "CNmTransitionNode", "m_flDuration", false, value);
}
GNmPercent_t GCNmTransitionNode::GetBoneMaskBlendInTimePercentage() const {
    GNmPercent_t value(GetSchemaPtr(m_ptr, "CNmTransitionNode", "m_boneMaskBlendInTimePercentage"));
    return value;
}
void GCNmTransitionNode::SetBoneMaskBlendInTimePercentage(GNmPercent_t value) {
    SetSchemaValue(m_ptr, "CNmTransitionNode", "m_boneMaskBlendInTimePercentage", false, value);
}
float GCNmTransitionNode::GetSyncEventOffset() const {
    return GetSchemaValue<float>(m_ptr, "CNmTransitionNode", "m_syncEventOffset");
}
void GCNmTransitionNode::SetSyncEventOffset(float value) {
    SetSchemaValue(m_ptr, "CNmTransitionNode", "m_syncEventOffset", false, value);
}
GCNmTransitionNode GCNmTransitionNode::GetTransitionOptions() const {
    GCNmTransitionNode value(GetSchemaPtr(m_ptr, "CNmTransitionNode", "m_transitionOptions"));
    return value;
}
void GCNmTransitionNode::SetTransitionOptions(GCNmTransitionNode value) {
    SetSchemaValue(m_ptr, "CNmTransitionNode", "m_transitionOptions", false, value);
}
int16_t GCNmTransitionNode::GetTargetSyncIDNodeIdx() const {
    return GetSchemaValue<int16_t>(m_ptr, "CNmTransitionNode", "m_targetSyncIDNodeIdx");
}
void GCNmTransitionNode::SetTargetSyncIDNodeIdx(int16_t value) {
    SetSchemaValue(m_ptr, "CNmTransitionNode", "m_targetSyncIDNodeIdx", false, value);
}
uint64_t GCNmTransitionNode::GetBlendWeightEasing() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CNmTransitionNode", "m_blendWeightEasing");
}
void GCNmTransitionNode::SetBlendWeightEasing(uint64_t value) {
    SetSchemaValue(m_ptr, "CNmTransitionNode", "m_blendWeightEasing", false, value);
}
uint64_t GCNmTransitionNode::GetRootMotionBlend() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CNmTransitionNode", "m_rootMotionBlend");
}
void GCNmTransitionNode::SetRootMotionBlend(uint64_t value) {
    SetSchemaValue(m_ptr, "CNmTransitionNode", "m_rootMotionBlend", false, value);
}
std::string GCNmTransitionNode::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCNmTransitionNode::IsValid() {
    return (m_ptr != nullptr);
}
GCNmPoseNode GCNmTransitionNode::GetParent() const {
    GCNmPoseNode value(m_ptr);
    return value;
}
void GCNmTransitionNode::SetParent(GCNmPoseNode value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCNmTransitionNode(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCNmTransitionNode>("CNmTransitionNode")
        .addConstructor<void (*)(std::string)>()
        .addProperty("TargetCNmStateNodeIdx", &GCNmTransitionNode::GetTargetCNmStateNodeIdx, &GCNmTransitionNode::SetTargetCNmStateNodeIdx)
        .addProperty("DurationOverrideNodeIdx", &GCNmTransitionNode::GetDurationOverrideNodeIdx, &GCNmTransitionNode::SetDurationOverrideNodeIdx)
        .addProperty("SyncEventOffsetOverrideNodeIdx", &GCNmTransitionNode::GetSyncEventOffsetOverrideNodeIdx, &GCNmTransitionNode::SetSyncEventOffsetOverrideNodeIdx)
        .addProperty("StartBoneMaskNodeIdx", &GCNmTransitionNode::GetStartBoneMaskNodeIdx, &GCNmTransitionNode::SetStartBoneMaskNodeIdx)
        .addProperty("Duration", &GCNmTransitionNode::GetDuration, &GCNmTransitionNode::SetDuration)
        .addProperty("BoneMaskBlendInTimePercentage", &GCNmTransitionNode::GetBoneMaskBlendInTimePercentage, &GCNmTransitionNode::SetBoneMaskBlendInTimePercentage)
        .addProperty("SyncEventOffset", &GCNmTransitionNode::GetSyncEventOffset, &GCNmTransitionNode::SetSyncEventOffset)
        .addProperty("TransitionOptions", &GCNmTransitionNode::GetTransitionOptions, &GCNmTransitionNode::SetTransitionOptions)
        .addProperty("TargetSyncIDNodeIdx", &GCNmTransitionNode::GetTargetSyncIDNodeIdx, &GCNmTransitionNode::SetTargetSyncIDNodeIdx)
        .addProperty("BlendWeightEasing", &GCNmTransitionNode::GetBlendWeightEasing, &GCNmTransitionNode::SetBlendWeightEasing)
        .addProperty("RootMotionBlend", &GCNmTransitionNode::GetRootMotionBlend, &GCNmTransitionNode::SetRootMotionBlend)
        .addProperty("Parent", &GCNmTransitionNode::GetParent, &GCNmTransitionNode::SetParent)
        .addFunction("ToPtr", &GCNmTransitionNode::ToPtr)
        .addFunction("IsValid", &GCNmTransitionNode::IsValid)
        .endClass();
}
GMotionDBIndex::GMotionDBIndex(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GMotionDBIndex::GMotionDBIndex(void *ptr) {
    m_ptr = ptr;
}
uint32_t GMotionDBIndex::GetIndex() const {
    return GetSchemaValue<uint32_t>(m_ptr, "MotionDBIndex", "m_nIndex");
}
void GMotionDBIndex::SetIndex(uint32_t value) {
    SetSchemaValue(m_ptr, "MotionDBIndex", "m_nIndex", false, value);
}
std::string GMotionDBIndex::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GMotionDBIndex::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassMotionDBIndex(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GMotionDBIndex>("MotionDBIndex")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Index", &GMotionDBIndex::GetIndex, &GMotionDBIndex::SetIndex)
        .addFunction("ToPtr", &GMotionDBIndex::ToPtr)
        .addFunction("IsValid", &GMotionDBIndex::IsValid)
        .endClass();
}
GCToggleComponentActionUpdater::GCToggleComponentActionUpdater(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCToggleComponentActionUpdater::GCToggleComponentActionUpdater(void *ptr) {
    m_ptr = ptr;
}
GAnimComponentID GCToggleComponentActionUpdater::GetComponentID() const {
    GAnimComponentID value(GetSchemaPtr(m_ptr, "CToggleComponentActionUpdater", "m_componentID"));
    return value;
}
void GCToggleComponentActionUpdater::SetComponentID(GAnimComponentID value) {
    SetSchemaValue(m_ptr, "CToggleComponentActionUpdater", "m_componentID", false, value);
}
bool GCToggleComponentActionUpdater::GetSetEnabled() const {
    return GetSchemaValue<bool>(m_ptr, "CToggleComponentActionUpdater", "m_bSetEnabled");
}
void GCToggleComponentActionUpdater::SetSetEnabled(bool value) {
    SetSchemaValue(m_ptr, "CToggleComponentActionUpdater", "m_bSetEnabled", false, value);
}
std::string GCToggleComponentActionUpdater::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCToggleComponentActionUpdater::IsValid() {
    return (m_ptr != nullptr);
}
GCAnimActionUpdater GCToggleComponentActionUpdater::GetParent() const {
    GCAnimActionUpdater value(m_ptr);
    return value;
}
void GCToggleComponentActionUpdater::SetParent(GCAnimActionUpdater value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCToggleComponentActionUpdater(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCToggleComponentActionUpdater>("CToggleComponentActionUpdater")
        .addConstructor<void (*)(std::string)>()
        .addProperty("ComponentID", &GCToggleComponentActionUpdater::GetComponentID, &GCToggleComponentActionUpdater::SetComponentID)
        .addProperty("SetEnabled", &GCToggleComponentActionUpdater::GetSetEnabled, &GCToggleComponentActionUpdater::SetSetEnabled)
        .addProperty("Parent", &GCToggleComponentActionUpdater::GetParent, &GCToggleComponentActionUpdater::SetParent)
        .addFunction("ToPtr", &GCToggleComponentActionUpdater::ToPtr)
        .addFunction("IsValid", &GCToggleComponentActionUpdater::IsValid)
        .endClass();
}
GCNmControlParameterIDNode::GCNmControlParameterIDNode(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCNmControlParameterIDNode::GCNmControlParameterIDNode(void *ptr) {
    m_ptr = ptr;
}
std::string GCNmControlParameterIDNode::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCNmControlParameterIDNode::IsValid() {
    return (m_ptr != nullptr);
}
GCNmIDValueNode GCNmControlParameterIDNode::GetParent() const {
    GCNmIDValueNode value(m_ptr);
    return value;
}
void GCNmControlParameterIDNode::SetParent(GCNmIDValueNode value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCNmControlParameterIDNode(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCNmControlParameterIDNode>("CNmControlParameterIDNode")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCNmControlParameterIDNode::GetParent, &GCNmControlParameterIDNode::SetParent)
        .addFunction("ToPtr", &GCNmControlParameterIDNode::ToPtr)
        .addFunction("IsValid", &GCNmControlParameterIDNode::IsValid)
        .endClass();
}
GPostProcessingTonemapParameters_t::GPostProcessingTonemapParameters_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GPostProcessingTonemapParameters_t::GPostProcessingTonemapParameters_t(void *ptr) {
    m_ptr = ptr;
}
float GPostProcessingTonemapParameters_t::GetExposureBias() const {
    return GetSchemaValue<float>(m_ptr, "PostProcessingTonemapParameters_t", "m_flExposureBias");
}
void GPostProcessingTonemapParameters_t::SetExposureBias(float value) {
    SetSchemaValue(m_ptr, "PostProcessingTonemapParameters_t", "m_flExposureBias", true, value);
}
float GPostProcessingTonemapParameters_t::GetShoulderStrength() const {
    return GetSchemaValue<float>(m_ptr, "PostProcessingTonemapParameters_t", "m_flShoulderStrength");
}
void GPostProcessingTonemapParameters_t::SetShoulderStrength(float value) {
    SetSchemaValue(m_ptr, "PostProcessingTonemapParameters_t", "m_flShoulderStrength", true, value);
}
float GPostProcessingTonemapParameters_t::GetLinearStrength() const {
    return GetSchemaValue<float>(m_ptr, "PostProcessingTonemapParameters_t", "m_flLinearStrength");
}
void GPostProcessingTonemapParameters_t::SetLinearStrength(float value) {
    SetSchemaValue(m_ptr, "PostProcessingTonemapParameters_t", "m_flLinearStrength", true, value);
}
float GPostProcessingTonemapParameters_t::GetLinearAngle() const {
    return GetSchemaValue<float>(m_ptr, "PostProcessingTonemapParameters_t", "m_flLinearAngle");
}
void GPostProcessingTonemapParameters_t::SetLinearAngle(float value) {
    SetSchemaValue(m_ptr, "PostProcessingTonemapParameters_t", "m_flLinearAngle", true, value);
}
float GPostProcessingTonemapParameters_t::GetToeStrength() const {
    return GetSchemaValue<float>(m_ptr, "PostProcessingTonemapParameters_t", "m_flToeStrength");
}
void GPostProcessingTonemapParameters_t::SetToeStrength(float value) {
    SetSchemaValue(m_ptr, "PostProcessingTonemapParameters_t", "m_flToeStrength", true, value);
}
float GPostProcessingTonemapParameters_t::GetToeNum() const {
    return GetSchemaValue<float>(m_ptr, "PostProcessingTonemapParameters_t", "m_flToeNum");
}
void GPostProcessingTonemapParameters_t::SetToeNum(float value) {
    SetSchemaValue(m_ptr, "PostProcessingTonemapParameters_t", "m_flToeNum", true, value);
}
float GPostProcessingTonemapParameters_t::GetToeDenom() const {
    return GetSchemaValue<float>(m_ptr, "PostProcessingTonemapParameters_t", "m_flToeDenom");
}
void GPostProcessingTonemapParameters_t::SetToeDenom(float value) {
    SetSchemaValue(m_ptr, "PostProcessingTonemapParameters_t", "m_flToeDenom", true, value);
}
float GPostProcessingTonemapParameters_t::GetWhitePoint() const {
    return GetSchemaValue<float>(m_ptr, "PostProcessingTonemapParameters_t", "m_flWhitePoint");
}
void GPostProcessingTonemapParameters_t::SetWhitePoint(float value) {
    SetSchemaValue(m_ptr, "PostProcessingTonemapParameters_t", "m_flWhitePoint", true, value);
}
float GPostProcessingTonemapParameters_t::GetLuminanceSource() const {
    return GetSchemaValue<float>(m_ptr, "PostProcessingTonemapParameters_t", "m_flLuminanceSource");
}
void GPostProcessingTonemapParameters_t::SetLuminanceSource(float value) {
    SetSchemaValue(m_ptr, "PostProcessingTonemapParameters_t", "m_flLuminanceSource", true, value);
}
float GPostProcessingTonemapParameters_t::GetExposureBiasShadows() const {
    return GetSchemaValue<float>(m_ptr, "PostProcessingTonemapParameters_t", "m_flExposureBiasShadows");
}
void GPostProcessingTonemapParameters_t::SetExposureBiasShadows(float value) {
    SetSchemaValue(m_ptr, "PostProcessingTonemapParameters_t", "m_flExposureBiasShadows", true, value);
}
float GPostProcessingTonemapParameters_t::GetExposureBiasHighlights() const {
    return GetSchemaValue<float>(m_ptr, "PostProcessingTonemapParameters_t", "m_flExposureBiasHighlights");
}
void GPostProcessingTonemapParameters_t::SetExposureBiasHighlights(float value) {
    SetSchemaValue(m_ptr, "PostProcessingTonemapParameters_t", "m_flExposureBiasHighlights", true, value);
}
float GPostProcessingTonemapParameters_t::GetMinShadowLum() const {
    return GetSchemaValue<float>(m_ptr, "PostProcessingTonemapParameters_t", "m_flMinShadowLum");
}
void GPostProcessingTonemapParameters_t::SetMinShadowLum(float value) {
    SetSchemaValue(m_ptr, "PostProcessingTonemapParameters_t", "m_flMinShadowLum", true, value);
}
float GPostProcessingTonemapParameters_t::GetMaxShadowLum() const {
    return GetSchemaValue<float>(m_ptr, "PostProcessingTonemapParameters_t", "m_flMaxShadowLum");
}
void GPostProcessingTonemapParameters_t::SetMaxShadowLum(float value) {
    SetSchemaValue(m_ptr, "PostProcessingTonemapParameters_t", "m_flMaxShadowLum", true, value);
}
float GPostProcessingTonemapParameters_t::GetMinHighlightLum() const {
    return GetSchemaValue<float>(m_ptr, "PostProcessingTonemapParameters_t", "m_flMinHighlightLum");
}
void GPostProcessingTonemapParameters_t::SetMinHighlightLum(float value) {
    SetSchemaValue(m_ptr, "PostProcessingTonemapParameters_t", "m_flMinHighlightLum", true, value);
}
float GPostProcessingTonemapParameters_t::GetMaxHighlightLum() const {
    return GetSchemaValue<float>(m_ptr, "PostProcessingTonemapParameters_t", "m_flMaxHighlightLum");
}
void GPostProcessingTonemapParameters_t::SetMaxHighlightLum(float value) {
    SetSchemaValue(m_ptr, "PostProcessingTonemapParameters_t", "m_flMaxHighlightLum", true, value);
}
std::string GPostProcessingTonemapParameters_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GPostProcessingTonemapParameters_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassPostProcessingTonemapParameters_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GPostProcessingTonemapParameters_t>("PostProcessingTonemapParameters_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("ExposureBias", &GPostProcessingTonemapParameters_t::GetExposureBias, &GPostProcessingTonemapParameters_t::SetExposureBias)
        .addProperty("ShoulderStrength", &GPostProcessingTonemapParameters_t::GetShoulderStrength, &GPostProcessingTonemapParameters_t::SetShoulderStrength)
        .addProperty("LinearStrength", &GPostProcessingTonemapParameters_t::GetLinearStrength, &GPostProcessingTonemapParameters_t::SetLinearStrength)
        .addProperty("LinearAngle", &GPostProcessingTonemapParameters_t::GetLinearAngle, &GPostProcessingTonemapParameters_t::SetLinearAngle)
        .addProperty("ToeStrength", &GPostProcessingTonemapParameters_t::GetToeStrength, &GPostProcessingTonemapParameters_t::SetToeStrength)
        .addProperty("ToeNum", &GPostProcessingTonemapParameters_t::GetToeNum, &GPostProcessingTonemapParameters_t::SetToeNum)
        .addProperty("ToeDenom", &GPostProcessingTonemapParameters_t::GetToeDenom, &GPostProcessingTonemapParameters_t::SetToeDenom)
        .addProperty("WhitePoint", &GPostProcessingTonemapParameters_t::GetWhitePoint, &GPostProcessingTonemapParameters_t::SetWhitePoint)
        .addProperty("LuminanceSource", &GPostProcessingTonemapParameters_t::GetLuminanceSource, &GPostProcessingTonemapParameters_t::SetLuminanceSource)
        .addProperty("ExposureBiasShadows", &GPostProcessingTonemapParameters_t::GetExposureBiasShadows, &GPostProcessingTonemapParameters_t::SetExposureBiasShadows)
        .addProperty("ExposureBiasHighlights", &GPostProcessingTonemapParameters_t::GetExposureBiasHighlights, &GPostProcessingTonemapParameters_t::SetExposureBiasHighlights)
        .addProperty("MinShadowLum", &GPostProcessingTonemapParameters_t::GetMinShadowLum, &GPostProcessingTonemapParameters_t::SetMinShadowLum)
        .addProperty("MaxShadowLum", &GPostProcessingTonemapParameters_t::GetMaxShadowLum, &GPostProcessingTonemapParameters_t::SetMaxShadowLum)
        .addProperty("MinHighlightLum", &GPostProcessingTonemapParameters_t::GetMinHighlightLum, &GPostProcessingTonemapParameters_t::SetMinHighlightLum)
        .addProperty("MaxHighlightLum", &GPostProcessingTonemapParameters_t::GetMaxHighlightLum, &GPostProcessingTonemapParameters_t::SetMaxHighlightLum)
        .addFunction("ToPtr", &GPostProcessingTonemapParameters_t::ToPtr)
        .addFunction("IsValid", &GPostProcessingTonemapParameters_t::IsValid)
        .endClass();
}
GVMixAutoFilterDesc_t::GVMixAutoFilterDesc_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GVMixAutoFilterDesc_t::GVMixAutoFilterDesc_t(void *ptr) {
    m_ptr = ptr;
}
float GVMixAutoFilterDesc_t::GetEnvelopeAmount() const {
    return GetSchemaValue<float>(m_ptr, "VMixAutoFilterDesc_t", "m_flEnvelopeAmount");
}
void GVMixAutoFilterDesc_t::SetEnvelopeAmount(float value) {
    SetSchemaValue(m_ptr, "VMixAutoFilterDesc_t", "m_flEnvelopeAmount", true, value);
}
float GVMixAutoFilterDesc_t::GetAttackTimeMS() const {
    return GetSchemaValue<float>(m_ptr, "VMixAutoFilterDesc_t", "m_flAttackTimeMS");
}
void GVMixAutoFilterDesc_t::SetAttackTimeMS(float value) {
    SetSchemaValue(m_ptr, "VMixAutoFilterDesc_t", "m_flAttackTimeMS", true, value);
}
float GVMixAutoFilterDesc_t::GetReleaseTimeMS() const {
    return GetSchemaValue<float>(m_ptr, "VMixAutoFilterDesc_t", "m_flReleaseTimeMS");
}
void GVMixAutoFilterDesc_t::SetReleaseTimeMS(float value) {
    SetSchemaValue(m_ptr, "VMixAutoFilterDesc_t", "m_flReleaseTimeMS", true, value);
}
GVMixFilterDesc_t GVMixAutoFilterDesc_t::GetFilter() const {
    GVMixFilterDesc_t value(GetSchemaPtr(m_ptr, "VMixAutoFilterDesc_t", "m_filter"));
    return value;
}
void GVMixAutoFilterDesc_t::SetFilter(GVMixFilterDesc_t value) {
    SetSchemaValue(m_ptr, "VMixAutoFilterDesc_t", "m_filter", true, value);
}
float GVMixAutoFilterDesc_t::GetLFOAmount() const {
    return GetSchemaValue<float>(m_ptr, "VMixAutoFilterDesc_t", "m_flLFOAmount");
}
void GVMixAutoFilterDesc_t::SetLFOAmount(float value) {
    SetSchemaValue(m_ptr, "VMixAutoFilterDesc_t", "m_flLFOAmount", true, value);
}
float GVMixAutoFilterDesc_t::GetLFORate() const {
    return GetSchemaValue<float>(m_ptr, "VMixAutoFilterDesc_t", "m_flLFORate");
}
void GVMixAutoFilterDesc_t::SetLFORate(float value) {
    SetSchemaValue(m_ptr, "VMixAutoFilterDesc_t", "m_flLFORate", true, value);
}
float GVMixAutoFilterDesc_t::GetPhase() const {
    return GetSchemaValue<float>(m_ptr, "VMixAutoFilterDesc_t", "m_flPhase");
}
void GVMixAutoFilterDesc_t::SetPhase(float value) {
    SetSchemaValue(m_ptr, "VMixAutoFilterDesc_t", "m_flPhase", true, value);
}
uint64_t GVMixAutoFilterDesc_t::GetLFOShape() const {
    return GetSchemaValue<uint64_t>(m_ptr, "VMixAutoFilterDesc_t", "m_nLFOShape");
}
void GVMixAutoFilterDesc_t::SetLFOShape(uint64_t value) {
    SetSchemaValue(m_ptr, "VMixAutoFilterDesc_t", "m_nLFOShape", true, value);
}
std::string GVMixAutoFilterDesc_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GVMixAutoFilterDesc_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassVMixAutoFilterDesc_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GVMixAutoFilterDesc_t>("VMixAutoFilterDesc_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("EnvelopeAmount", &GVMixAutoFilterDesc_t::GetEnvelopeAmount, &GVMixAutoFilterDesc_t::SetEnvelopeAmount)
        .addProperty("AttackTimeMS", &GVMixAutoFilterDesc_t::GetAttackTimeMS, &GVMixAutoFilterDesc_t::SetAttackTimeMS)
        .addProperty("ReleaseTimeMS", &GVMixAutoFilterDesc_t::GetReleaseTimeMS, &GVMixAutoFilterDesc_t::SetReleaseTimeMS)
        .addProperty("Filter", &GVMixAutoFilterDesc_t::GetFilter, &GVMixAutoFilterDesc_t::SetFilter)
        .addProperty("LFOAmount", &GVMixAutoFilterDesc_t::GetLFOAmount, &GVMixAutoFilterDesc_t::SetLFOAmount)
        .addProperty("LFORate", &GVMixAutoFilterDesc_t::GetLFORate, &GVMixAutoFilterDesc_t::SetLFORate)
        .addProperty("Phase", &GVMixAutoFilterDesc_t::GetPhase, &GVMixAutoFilterDesc_t::SetPhase)
        .addProperty("LFOShape", &GVMixAutoFilterDesc_t::GetLFOShape, &GVMixAutoFilterDesc_t::SetLFOShape)
        .addFunction("ToPtr", &GVMixAutoFilterDesc_t::ToPtr)
        .addFunction("IsValid", &GVMixAutoFilterDesc_t::IsValid)
        .endClass();
}
GCSeqMultiFetch::GCSeqMultiFetch(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCSeqMultiFetch::GCSeqMultiFetch(void *ptr) {
    m_ptr = ptr;
}
GCSeqMultiFetchFlag GCSeqMultiFetch::GetFlags() const {
    GCSeqMultiFetchFlag value(GetSchemaPtr(m_ptr, "CSeqMultiFetch", "m_flags"));
    return value;
}
void GCSeqMultiFetch::SetFlags(GCSeqMultiFetchFlag value) {
    SetSchemaValue(m_ptr, "CSeqMultiFetch", "m_flags", false, value);
}
std::vector<int16> GCSeqMultiFetch::GetLocalReferenceArray() const {
    CUtlVector<int16>* vec = GetSchemaValue<CUtlVector<int16>*>(m_ptr, "CSeqMultiFetch", "m_localReferenceArray"); std::vector<int16> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCSeqMultiFetch::SetLocalReferenceArray(std::vector<int16> value) {
    SetSchemaValueCUtlVector<int16>(m_ptr, "CSeqMultiFetch", "m_localReferenceArray", false, value);
}
std::vector<int32_t> GCSeqMultiFetch::GetGroupSize() const {
    int32_t* outValue = GetSchemaValue<int32_t*>(m_ptr, "CSeqMultiFetch", "m_nGroupSize"); std::vector<int32_t> ret; for(int i = 0; i < 2; i++) { ret.push_back(outValue[i]); } return ret;
}
void GCSeqMultiFetch::SetGroupSize(std::vector<int32_t> value) {
    int32_t* outValue = GetSchemaValue<int32_t*>(m_ptr, "CSeqMultiFetch", "m_nGroupSize"); for(int i = 0; i < 2; i++) { outValue[i] = value[i]; } SetSchemaValue(m_ptr, "CSeqMultiFetch", "m_nGroupSize", false, outValue);
}
std::vector<int32_t> GCSeqMultiFetch::GetLocalPose() const {
    int32_t* outValue = GetSchemaValue<int32_t*>(m_ptr, "CSeqMultiFetch", "m_nLocalPose"); std::vector<int32_t> ret; for(int i = 0; i < 2; i++) { ret.push_back(outValue[i]); } return ret;
}
void GCSeqMultiFetch::SetLocalPose(std::vector<int32_t> value) {
    int32_t* outValue = GetSchemaValue<int32_t*>(m_ptr, "CSeqMultiFetch", "m_nLocalPose"); for(int i = 0; i < 2; i++) { outValue[i] = value[i]; } SetSchemaValue(m_ptr, "CSeqMultiFetch", "m_nLocalPose", false, outValue);
}
std::vector<float32> GCSeqMultiFetch::GetPoseKeyArray0() const {
    CUtlVector<float32>* vec = GetSchemaValue<CUtlVector<float32>*>(m_ptr, "CSeqMultiFetch", "m_poseKeyArray0"); std::vector<float32> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCSeqMultiFetch::SetPoseKeyArray0(std::vector<float32> value) {
    SetSchemaValueCUtlVector<float32>(m_ptr, "CSeqMultiFetch", "m_poseKeyArray0", false, value);
}
std::vector<float32> GCSeqMultiFetch::GetPoseKeyArray1() const {
    CUtlVector<float32>* vec = GetSchemaValue<CUtlVector<float32>*>(m_ptr, "CSeqMultiFetch", "m_poseKeyArray1"); std::vector<float32> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCSeqMultiFetch::SetPoseKeyArray1(std::vector<float32> value) {
    SetSchemaValueCUtlVector<float32>(m_ptr, "CSeqMultiFetch", "m_poseKeyArray1", false, value);
}
int32_t GCSeqMultiFetch::GetLocalCyclePoseParameter() const {
    return GetSchemaValue<int32_t>(m_ptr, "CSeqMultiFetch", "m_nLocalCyclePoseParameter");
}
void GCSeqMultiFetch::SetLocalCyclePoseParameter(int32_t value) {
    SetSchemaValue(m_ptr, "CSeqMultiFetch", "m_nLocalCyclePoseParameter", false, value);
}
bool GCSeqMultiFetch::GetCalculatePoseParameters() const {
    return GetSchemaValue<bool>(m_ptr, "CSeqMultiFetch", "m_bCalculatePoseParameters");
}
void GCSeqMultiFetch::SetCalculatePoseParameters(bool value) {
    SetSchemaValue(m_ptr, "CSeqMultiFetch", "m_bCalculatePoseParameters", false, value);
}
bool GCSeqMultiFetch::GetFixedBlendWeight() const {
    return GetSchemaValue<bool>(m_ptr, "CSeqMultiFetch", "m_bFixedBlendWeight");
}
void GCSeqMultiFetch::SetFixedBlendWeight(bool value) {
    SetSchemaValue(m_ptr, "CSeqMultiFetch", "m_bFixedBlendWeight", false, value);
}
std::vector<float> GCSeqMultiFetch::GetFixedBlendWeightVals() const {
    float* outValue = GetSchemaValue<float*>(m_ptr, "CSeqMultiFetch", "m_flFixedBlendWeightVals"); std::vector<float> ret; for(int i = 0; i < 2; i++) { ret.push_back(outValue[i]); } return ret;
}
void GCSeqMultiFetch::SetFixedBlendWeightVals(std::vector<float> value) {
    float* outValue = GetSchemaValue<float*>(m_ptr, "CSeqMultiFetch", "m_flFixedBlendWeightVals"); for(int i = 0; i < 2; i++) { outValue[i] = value[i]; } SetSchemaValue(m_ptr, "CSeqMultiFetch", "m_flFixedBlendWeightVals", false, outValue);
}
std::string GCSeqMultiFetch::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCSeqMultiFetch::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCSeqMultiFetch(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCSeqMultiFetch>("CSeqMultiFetch")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Flags", &GCSeqMultiFetch::GetFlags, &GCSeqMultiFetch::SetFlags)
        .addProperty("LocalReferenceArray", &GCSeqMultiFetch::GetLocalReferenceArray, &GCSeqMultiFetch::SetLocalReferenceArray)
        .addProperty("GroupSize", &GCSeqMultiFetch::GetGroupSize, &GCSeqMultiFetch::SetGroupSize)
        .addProperty("LocalPose", &GCSeqMultiFetch::GetLocalPose, &GCSeqMultiFetch::SetLocalPose)
        .addProperty("PoseKeyArray0", &GCSeqMultiFetch::GetPoseKeyArray0, &GCSeqMultiFetch::SetPoseKeyArray0)
        .addProperty("PoseKeyArray1", &GCSeqMultiFetch::GetPoseKeyArray1, &GCSeqMultiFetch::SetPoseKeyArray1)
        .addProperty("LocalCyclePoseParameter", &GCSeqMultiFetch::GetLocalCyclePoseParameter, &GCSeqMultiFetch::SetLocalCyclePoseParameter)
        .addProperty("CalculatePoseParameters", &GCSeqMultiFetch::GetCalculatePoseParameters, &GCSeqMultiFetch::SetCalculatePoseParameters)
        .addProperty("FixedBlendWeight", &GCSeqMultiFetch::GetFixedBlendWeight, &GCSeqMultiFetch::SetFixedBlendWeight)
        .addProperty("FixedBlendWeightVals", &GCSeqMultiFetch::GetFixedBlendWeightVals, &GCSeqMultiFetch::SetFixedBlendWeightVals)
        .addFunction("ToPtr", &GCSeqMultiFetch::ToPtr)
        .addFunction("IsValid", &GCSeqMultiFetch::IsValid)
        .endClass();
}
GCNmStateMachineNode::GCNmStateMachineNode(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCNmStateMachineNode::GCNmStateMachineNode(void *ptr) {
    m_ptr = ptr;
}
int16_t GCNmStateMachineNode::GetDefaultStateIndex() const {
    return GetSchemaValue<int16_t>(m_ptr, "CNmStateMachineNode", "m_nDefaultStateIndex");
}
void GCNmStateMachineNode::SetDefaultStateIndex(int16_t value) {
    SetSchemaValue(m_ptr, "CNmStateMachineNode", "m_nDefaultStateIndex", false, value);
}
std::string GCNmStateMachineNode::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCNmStateMachineNode::IsValid() {
    return (m_ptr != nullptr);
}
GCNmPoseNode GCNmStateMachineNode::GetParent() const {
    GCNmPoseNode value(m_ptr);
    return value;
}
void GCNmStateMachineNode::SetParent(GCNmPoseNode value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCNmStateMachineNode(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCNmStateMachineNode>("CNmStateMachineNode")
        .addConstructor<void (*)(std::string)>()
        .addProperty("DefaultStateIndex", &GCNmStateMachineNode::GetDefaultStateIndex, &GCNmStateMachineNode::SetDefaultStateIndex)
        .addProperty("Parent", &GCNmStateMachineNode::GetParent, &GCNmStateMachineNode::SetParent)
        .addFunction("ToPtr", &GCNmStateMachineNode::ToPtr)
        .addFunction("IsValid", &GCNmStateMachineNode::IsValid)
        .endClass();
}
GCBoneConstraintPoseSpaceMorph::GCBoneConstraintPoseSpaceMorph(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCBoneConstraintPoseSpaceMorph::GCBoneConstraintPoseSpaceMorph(void *ptr) {
    m_ptr = ptr;
}
std::string GCBoneConstraintPoseSpaceMorph::GetBoneName() const {
    return GetSchemaValue<CUtlString>(m_ptr, "CBoneConstraintPoseSpaceMorph", "m_sBoneName").Get();
}
void GCBoneConstraintPoseSpaceMorph::SetBoneName(std::string value) {
    SetSchemaValue(m_ptr, "CBoneConstraintPoseSpaceMorph", "m_sBoneName", false, CUtlString(value.c_str()));
}
std::string GCBoneConstraintPoseSpaceMorph::GetAttachmentName() const {
    return GetSchemaValue<CUtlString>(m_ptr, "CBoneConstraintPoseSpaceMorph", "m_sAttachmentName").Get();
}
void GCBoneConstraintPoseSpaceMorph::SetAttachmentName(std::string value) {
    SetSchemaValue(m_ptr, "CBoneConstraintPoseSpaceMorph", "m_sAttachmentName", false, CUtlString(value.c_str()));
}
std::vector<CUtlString> GCBoneConstraintPoseSpaceMorph::GetOutputMorph() const {
    CUtlVector<CUtlString>* vec = GetSchemaValue<CUtlVector<CUtlString>*>(m_ptr, "CBoneConstraintPoseSpaceMorph", "m_outputMorph"); std::vector<CUtlString> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCBoneConstraintPoseSpaceMorph::SetOutputMorph(std::vector<CUtlString> value) {
    SetSchemaValueCUtlVector<CUtlString>(m_ptr, "CBoneConstraintPoseSpaceMorph", "m_outputMorph", false, value);
}
std::vector<GCBoneConstraintPoseSpaceMorph> GCBoneConstraintPoseSpaceMorph::GetInputList() const {
    CUtlVector<GCBoneConstraintPoseSpaceMorph>* vec = GetSchemaValue<CUtlVector<GCBoneConstraintPoseSpaceMorph>*>(m_ptr, "CBoneConstraintPoseSpaceMorph", "m_inputList"); std::vector<GCBoneConstraintPoseSpaceMorph> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCBoneConstraintPoseSpaceMorph::SetInputList(std::vector<GCBoneConstraintPoseSpaceMorph> value) {
    SetSchemaValueCUtlVector<GCBoneConstraintPoseSpaceMorph>(m_ptr, "CBoneConstraintPoseSpaceMorph", "m_inputList", false, value);
}
bool GCBoneConstraintPoseSpaceMorph::GetClamp() const {
    return GetSchemaValue<bool>(m_ptr, "CBoneConstraintPoseSpaceMorph", "m_bClamp");
}
void GCBoneConstraintPoseSpaceMorph::SetClamp(bool value) {
    SetSchemaValue(m_ptr, "CBoneConstraintPoseSpaceMorph", "m_bClamp", false, value);
}
std::string GCBoneConstraintPoseSpaceMorph::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCBoneConstraintPoseSpaceMorph::IsValid() {
    return (m_ptr != nullptr);
}
GCBoneConstraintBase GCBoneConstraintPoseSpaceMorph::GetParent() const {
    GCBoneConstraintBase value(m_ptr);
    return value;
}
void GCBoneConstraintPoseSpaceMorph::SetParent(GCBoneConstraintBase value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCBoneConstraintPoseSpaceMorph(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCBoneConstraintPoseSpaceMorph>("CBoneConstraintPoseSpaceMorph")
        .addConstructor<void (*)(std::string)>()
        .addProperty("BoneName", &GCBoneConstraintPoseSpaceMorph::GetBoneName, &GCBoneConstraintPoseSpaceMorph::SetBoneName)
        .addProperty("AttachmentName", &GCBoneConstraintPoseSpaceMorph::GetAttachmentName, &GCBoneConstraintPoseSpaceMorph::SetAttachmentName)
        .addProperty("OutputMorph", &GCBoneConstraintPoseSpaceMorph::GetOutputMorph, &GCBoneConstraintPoseSpaceMorph::SetOutputMorph)
        .addProperty("InputList", &GCBoneConstraintPoseSpaceMorph::GetInputList, &GCBoneConstraintPoseSpaceMorph::SetInputList)
        .addProperty("Clamp", &GCBoneConstraintPoseSpaceMorph::GetClamp, &GCBoneConstraintPoseSpaceMorph::SetClamp)
        .addProperty("Parent", &GCBoneConstraintPoseSpaceMorph::GetParent, &GCBoneConstraintPoseSpaceMorph::SetParent)
        .addFunction("ToPtr", &GCBoneConstraintPoseSpaceMorph::ToPtr)
        .addFunction("IsValid", &GCBoneConstraintPoseSpaceMorph::IsValid)
        .endClass();
}
GCSSDSMsg_PreLayer::GCSSDSMsg_PreLayer(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCSSDSMsg_PreLayer::GCSSDSMsg_PreLayer(void *ptr) {
    m_ptr = ptr;
}
std::string GCSSDSMsg_PreLayer::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCSSDSMsg_PreLayer::IsValid() {
    return (m_ptr != nullptr);
}
GCSSDSMsg_LayerBase GCSSDSMsg_PreLayer::GetParent() const {
    GCSSDSMsg_LayerBase value(m_ptr);
    return value;
}
void GCSSDSMsg_PreLayer::SetParent(GCSSDSMsg_LayerBase value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCSSDSMsg_PreLayer(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCSSDSMsg_PreLayer>("CSSDSMsg_PreLayer")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCSSDSMsg_PreLayer::GetParent, &GCSSDSMsg_PreLayer::SetParent)
        .addFunction("ToPtr", &GCSSDSMsg_PreLayer::ToPtr)
        .addFunction("IsValid", &GCSSDSMsg_PreLayer::IsValid)
        .endClass();
}
GCSelectorUpdateNode::GCSelectorUpdateNode(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCSelectorUpdateNode::GCSelectorUpdateNode(void *ptr) {
    m_ptr = ptr;
}
std::vector<GCAnimUpdateNodeRef> GCSelectorUpdateNode::GetChildren() const {
    CUtlVector<GCAnimUpdateNodeRef>* vec = GetSchemaValue<CUtlVector<GCAnimUpdateNodeRef>*>(m_ptr, "CSelectorUpdateNode", "m_children"); std::vector<GCAnimUpdateNodeRef> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCSelectorUpdateNode::SetChildren(std::vector<GCAnimUpdateNodeRef> value) {
    SetSchemaValueCUtlVector<GCAnimUpdateNodeRef>(m_ptr, "CSelectorUpdateNode", "m_children", false, value);
}
std::vector<int8> GCSelectorUpdateNode::GetTags() const {
    CUtlVector<int8>* vec = GetSchemaValue<CUtlVector<int8>*>(m_ptr, "CSelectorUpdateNode", "m_tags"); std::vector<int8> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCSelectorUpdateNode::SetTags(std::vector<int8> value) {
    SetSchemaValueCUtlVector<int8>(m_ptr, "CSelectorUpdateNode", "m_tags", false, value);
}
GCBlendCurve GCSelectorUpdateNode::GetBlendCurve() const {
    GCBlendCurve value(GetSchemaPtr(m_ptr, "CSelectorUpdateNode", "m_blendCurve"));
    return value;
}
void GCSelectorUpdateNode::SetBlendCurve(GCBlendCurve value) {
    SetSchemaValue(m_ptr, "CSelectorUpdateNode", "m_blendCurve", false, value);
}
GCAnimParamHandle GCSelectorUpdateNode::GetParameter() const {
    GCAnimParamHandle value(GetSchemaPtr(m_ptr, "CSelectorUpdateNode", "m_hParameter"));
    return value;
}
void GCSelectorUpdateNode::SetParameter(GCAnimParamHandle value) {
    SetSchemaValue(m_ptr, "CSelectorUpdateNode", "m_hParameter", false, value);
}
int32_t GCSelectorUpdateNode::GetTagIndex() const {
    return GetSchemaValue<int32_t>(m_ptr, "CSelectorUpdateNode", "m_nTagIndex");
}
void GCSelectorUpdateNode::SetTagIndex(int32_t value) {
    SetSchemaValue(m_ptr, "CSelectorUpdateNode", "m_nTagIndex", false, value);
}
uint64_t GCSelectorUpdateNode::GetTagBehavior() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CSelectorUpdateNode", "m_eTagBehavior");
}
void GCSelectorUpdateNode::SetTagBehavior(uint64_t value) {
    SetSchemaValue(m_ptr, "CSelectorUpdateNode", "m_eTagBehavior", false, value);
}
bool GCSelectorUpdateNode::GetResetOnChange() const {
    return GetSchemaValue<bool>(m_ptr, "CSelectorUpdateNode", "m_bResetOnChange");
}
void GCSelectorUpdateNode::SetResetOnChange(bool value) {
    SetSchemaValue(m_ptr, "CSelectorUpdateNode", "m_bResetOnChange", false, value);
}
bool GCSelectorUpdateNode::GetLockWhenWaning() const {
    return GetSchemaValue<bool>(m_ptr, "CSelectorUpdateNode", "m_bLockWhenWaning");
}
void GCSelectorUpdateNode::SetLockWhenWaning(bool value) {
    SetSchemaValue(m_ptr, "CSelectorUpdateNode", "m_bLockWhenWaning", false, value);
}
bool GCSelectorUpdateNode::GetSyncCyclesOnChange() const {
    return GetSchemaValue<bool>(m_ptr, "CSelectorUpdateNode", "m_bSyncCyclesOnChange");
}
void GCSelectorUpdateNode::SetSyncCyclesOnChange(bool value) {
    SetSchemaValue(m_ptr, "CSelectorUpdateNode", "m_bSyncCyclesOnChange", false, value);
}
std::string GCSelectorUpdateNode::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCSelectorUpdateNode::IsValid() {
    return (m_ptr != nullptr);
}
GCAnimUpdateNodeBase GCSelectorUpdateNode::GetParent() const {
    GCAnimUpdateNodeBase value(m_ptr);
    return value;
}
void GCSelectorUpdateNode::SetParent(GCAnimUpdateNodeBase value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCSelectorUpdateNode(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCSelectorUpdateNode>("CSelectorUpdateNode")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Children", &GCSelectorUpdateNode::GetChildren, &GCSelectorUpdateNode::SetChildren)
        .addProperty("Tags", &GCSelectorUpdateNode::GetTags, &GCSelectorUpdateNode::SetTags)
        .addProperty("BlendCurve", &GCSelectorUpdateNode::GetBlendCurve, &GCSelectorUpdateNode::SetBlendCurve)
        .addProperty("Parameter", &GCSelectorUpdateNode::GetParameter, &GCSelectorUpdateNode::SetParameter)
        .addProperty("TagIndex", &GCSelectorUpdateNode::GetTagIndex, &GCSelectorUpdateNode::SetTagIndex)
        .addProperty("TagBehavior", &GCSelectorUpdateNode::GetTagBehavior, &GCSelectorUpdateNode::SetTagBehavior)
        .addProperty("ResetOnChange", &GCSelectorUpdateNode::GetResetOnChange, &GCSelectorUpdateNode::SetResetOnChange)
        .addProperty("LockWhenWaning", &GCSelectorUpdateNode::GetLockWhenWaning, &GCSelectorUpdateNode::SetLockWhenWaning)
        .addProperty("SyncCyclesOnChange", &GCSelectorUpdateNode::GetSyncCyclesOnChange, &GCSelectorUpdateNode::SetSyncCyclesOnChange)
        .addProperty("Parent", &GCSelectorUpdateNode::GetParent, &GCSelectorUpdateNode::SetParent)
        .addFunction("ToPtr", &GCSelectorUpdateNode::ToPtr)
        .addFunction("IsValid", &GCSelectorUpdateNode::IsValid)
        .endClass();
}
GCAimCameraUpdateNode::GCAimCameraUpdateNode(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCAimCameraUpdateNode::GCAimCameraUpdateNode(void *ptr) {
    m_ptr = ptr;
}
GCAnimParamHandle GCAimCameraUpdateNode::GetParameterPosition() const {
    GCAnimParamHandle value(GetSchemaPtr(m_ptr, "CAimCameraUpdateNode", "m_hParameterPosition"));
    return value;
}
void GCAimCameraUpdateNode::SetParameterPosition(GCAnimParamHandle value) {
    SetSchemaValue(m_ptr, "CAimCameraUpdateNode", "m_hParameterPosition", false, value);
}
GCAnimParamHandle GCAimCameraUpdateNode::GetParameterOrientation() const {
    GCAnimParamHandle value(GetSchemaPtr(m_ptr, "CAimCameraUpdateNode", "m_hParameterOrientation"));
    return value;
}
void GCAimCameraUpdateNode::SetParameterOrientation(GCAnimParamHandle value) {
    SetSchemaValue(m_ptr, "CAimCameraUpdateNode", "m_hParameterOrientation", false, value);
}
GCAnimParamHandle GCAimCameraUpdateNode::GetParameterSpineRotationWeight() const {
    GCAnimParamHandle value(GetSchemaPtr(m_ptr, "CAimCameraUpdateNode", "m_hParameterSpineRotationWeight"));
    return value;
}
void GCAimCameraUpdateNode::SetParameterSpineRotationWeight(GCAnimParamHandle value) {
    SetSchemaValue(m_ptr, "CAimCameraUpdateNode", "m_hParameterSpineRotationWeight", false, value);
}
GCAnimParamHandle GCAimCameraUpdateNode::GetParameterPelvisOffset() const {
    GCAnimParamHandle value(GetSchemaPtr(m_ptr, "CAimCameraUpdateNode", "m_hParameterPelvisOffset"));
    return value;
}
void GCAimCameraUpdateNode::SetParameterPelvisOffset(GCAnimParamHandle value) {
    SetSchemaValue(m_ptr, "CAimCameraUpdateNode", "m_hParameterPelvisOffset", false, value);
}
GCAnimParamHandle GCAimCameraUpdateNode::GetParameterUseIK() const {
    GCAnimParamHandle value(GetSchemaPtr(m_ptr, "CAimCameraUpdateNode", "m_hParameterUseIK"));
    return value;
}
void GCAimCameraUpdateNode::SetParameterUseIK(GCAnimParamHandle value) {
    SetSchemaValue(m_ptr, "CAimCameraUpdateNode", "m_hParameterUseIK", false, value);
}
GCAnimParamHandle GCAimCameraUpdateNode::GetParameterWeaponDepenetrationDistance() const {
    GCAnimParamHandle value(GetSchemaPtr(m_ptr, "CAimCameraUpdateNode", "m_hParameterWeaponDepenetrationDistance"));
    return value;
}
void GCAimCameraUpdateNode::SetParameterWeaponDepenetrationDistance(GCAnimParamHandle value) {
    SetSchemaValue(m_ptr, "CAimCameraUpdateNode", "m_hParameterWeaponDepenetrationDistance", false, value);
}
GCAnimParamHandle GCAimCameraUpdateNode::GetParameterCameraClearanceDistance() const {
    GCAnimParamHandle value(GetSchemaPtr(m_ptr, "CAimCameraUpdateNode", "m_hParameterCameraClearanceDistance"));
    return value;
}
void GCAimCameraUpdateNode::SetParameterCameraClearanceDistance(GCAnimParamHandle value) {
    SetSchemaValue(m_ptr, "CAimCameraUpdateNode", "m_hParameterCameraClearanceDistance", false, value);
}
GAimCameraOpFixedSettings_t GCAimCameraUpdateNode::GetOpFixedSettings() const {
    GAimCameraOpFixedSettings_t value(GetSchemaPtr(m_ptr, "CAimCameraUpdateNode", "m_opFixedSettings"));
    return value;
}
void GCAimCameraUpdateNode::SetOpFixedSettings(GAimCameraOpFixedSettings_t value) {
    SetSchemaValue(m_ptr, "CAimCameraUpdateNode", "m_opFixedSettings", false, value);
}
std::string GCAimCameraUpdateNode::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCAimCameraUpdateNode::IsValid() {
    return (m_ptr != nullptr);
}
GCUnaryUpdateNode GCAimCameraUpdateNode::GetParent() const {
    GCUnaryUpdateNode value(m_ptr);
    return value;
}
void GCAimCameraUpdateNode::SetParent(GCUnaryUpdateNode value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCAimCameraUpdateNode(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCAimCameraUpdateNode>("CAimCameraUpdateNode")
        .addConstructor<void (*)(std::string)>()
        .addProperty("ParameterPosition", &GCAimCameraUpdateNode::GetParameterPosition, &GCAimCameraUpdateNode::SetParameterPosition)
        .addProperty("ParameterOrientation", &GCAimCameraUpdateNode::GetParameterOrientation, &GCAimCameraUpdateNode::SetParameterOrientation)
        .addProperty("ParameterSpineRotationWeight", &GCAimCameraUpdateNode::GetParameterSpineRotationWeight, &GCAimCameraUpdateNode::SetParameterSpineRotationWeight)
        .addProperty("ParameterPelvisOffset", &GCAimCameraUpdateNode::GetParameterPelvisOffset, &GCAimCameraUpdateNode::SetParameterPelvisOffset)
        .addProperty("ParameterUseIK", &GCAimCameraUpdateNode::GetParameterUseIK, &GCAimCameraUpdateNode::SetParameterUseIK)
        .addProperty("ParameterWeaponDepenetrationDistance", &GCAimCameraUpdateNode::GetParameterWeaponDepenetrationDistance, &GCAimCameraUpdateNode::SetParameterWeaponDepenetrationDistance)
        .addProperty("ParameterCameraClearanceDistance", &GCAimCameraUpdateNode::GetParameterCameraClearanceDistance, &GCAimCameraUpdateNode::SetParameterCameraClearanceDistance)
        .addProperty("OpFixedSettings", &GCAimCameraUpdateNode::GetOpFixedSettings, &GCAimCameraUpdateNode::SetOpFixedSettings)
        .addProperty("Parent", &GCAimCameraUpdateNode::GetParent, &GCAimCameraUpdateNode::SetParent)
        .addFunction("ToPtr", &GCAimCameraUpdateNode::ToPtr)
        .addFunction("IsValid", &GCAimCameraUpdateNode::IsValid)
        .endClass();
}
GCFootStepTriggerUpdateNode::GCFootStepTriggerUpdateNode(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCFootStepTriggerUpdateNode::GCFootStepTriggerUpdateNode(void *ptr) {
    m_ptr = ptr;
}
std::vector<GFootStepTrigger> GCFootStepTriggerUpdateNode::GetTriggers() const {
    CUtlVector<GFootStepTrigger>* vec = GetSchemaValue<CUtlVector<GFootStepTrigger>*>(m_ptr, "CFootStepTriggerUpdateNode", "m_triggers"); std::vector<GFootStepTrigger> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCFootStepTriggerUpdateNode::SetTriggers(std::vector<GFootStepTrigger> value) {
    SetSchemaValueCUtlVector<GFootStepTrigger>(m_ptr, "CFootStepTriggerUpdateNode", "m_triggers", false, value);
}
float GCFootStepTriggerUpdateNode::GetTolerance() const {
    return GetSchemaValue<float>(m_ptr, "CFootStepTriggerUpdateNode", "m_flTolerance");
}
void GCFootStepTriggerUpdateNode::SetTolerance(float value) {
    SetSchemaValue(m_ptr, "CFootStepTriggerUpdateNode", "m_flTolerance", false, value);
}
std::string GCFootStepTriggerUpdateNode::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCFootStepTriggerUpdateNode::IsValid() {
    return (m_ptr != nullptr);
}
GCUnaryUpdateNode GCFootStepTriggerUpdateNode::GetParent() const {
    GCUnaryUpdateNode value(m_ptr);
    return value;
}
void GCFootStepTriggerUpdateNode::SetParent(GCUnaryUpdateNode value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCFootStepTriggerUpdateNode(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCFootStepTriggerUpdateNode>("CFootStepTriggerUpdateNode")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Triggers", &GCFootStepTriggerUpdateNode::GetTriggers, &GCFootStepTriggerUpdateNode::SetTriggers)
        .addProperty("Tolerance", &GCFootStepTriggerUpdateNode::GetTolerance, &GCFootStepTriggerUpdateNode::SetTolerance)
        .addProperty("Parent", &GCFootStepTriggerUpdateNode::GetParent, &GCFootStepTriggerUpdateNode::SetParent)
        .addFunction("ToPtr", &GCFootStepTriggerUpdateNode::ToPtr)
        .addFunction("IsValid", &GCFootStepTriggerUpdateNode::IsValid)
        .endClass();
}
GRnSoftbodyParticle_t::GRnSoftbodyParticle_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GRnSoftbodyParticle_t::GRnSoftbodyParticle_t(void *ptr) {
    m_ptr = ptr;
}
float GRnSoftbodyParticle_t::GetMassInv() const {
    return GetSchemaValue<float>(m_ptr, "RnSoftbodyParticle_t", "m_flMassInv");
}
void GRnSoftbodyParticle_t::SetMassInv(float value) {
    SetSchemaValue(m_ptr, "RnSoftbodyParticle_t", "m_flMassInv", true, value);
}
std::string GRnSoftbodyParticle_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GRnSoftbodyParticle_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassRnSoftbodyParticle_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GRnSoftbodyParticle_t>("RnSoftbodyParticle_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("MassInv", &GRnSoftbodyParticle_t::GetMassInv, &GRnSoftbodyParticle_t::SetMassInv)
        .addFunction("ToPtr", &GRnSoftbodyParticle_t::ToPtr)
        .addFunction("IsValid", &GRnSoftbodyParticle_t::IsValid)
        .endClass();
}
GCSingleFrameUpdateNode::GCSingleFrameUpdateNode(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCSingleFrameUpdateNode::GCSingleFrameUpdateNode(void *ptr) {
    m_ptr = ptr;
}
GCPoseHandle GCSingleFrameUpdateNode::GetPoseCacheHandle() const {
    GCPoseHandle value(GetSchemaPtr(m_ptr, "CSingleFrameUpdateNode", "m_hPoseCacheHandle"));
    return value;
}
void GCSingleFrameUpdateNode::SetPoseCacheHandle(GCPoseHandle value) {
    SetSchemaValue(m_ptr, "CSingleFrameUpdateNode", "m_hPoseCacheHandle", false, value);
}
float GCSingleFrameUpdateNode::GetCycle() const {
    return GetSchemaValue<float>(m_ptr, "CSingleFrameUpdateNode", "m_flCycle");
}
void GCSingleFrameUpdateNode::SetCycle(float value) {
    SetSchemaValue(m_ptr, "CSingleFrameUpdateNode", "m_flCycle", false, value);
}
std::string GCSingleFrameUpdateNode::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCSingleFrameUpdateNode::IsValid() {
    return (m_ptr != nullptr);
}
GCLeafUpdateNode GCSingleFrameUpdateNode::GetParent() const {
    GCLeafUpdateNode value(m_ptr);
    return value;
}
void GCSingleFrameUpdateNode::SetParent(GCLeafUpdateNode value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCSingleFrameUpdateNode(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCSingleFrameUpdateNode>("CSingleFrameUpdateNode")
        .addConstructor<void (*)(std::string)>()
        .addProperty("PoseCacheHandle", &GCSingleFrameUpdateNode::GetPoseCacheHandle, &GCSingleFrameUpdateNode::SetPoseCacheHandle)
        .addProperty("Cycle", &GCSingleFrameUpdateNode::GetCycle, &GCSingleFrameUpdateNode::SetCycle)
        .addProperty("Parent", &GCSingleFrameUpdateNode::GetParent, &GCSingleFrameUpdateNode::SetParent)
        .addFunction("ToPtr", &GCSingleFrameUpdateNode::ToPtr)
        .addFunction("IsValid", &GCSingleFrameUpdateNode::IsValid)
        .endClass();
}
GCSeqSynthAnimDesc::GCSeqSynthAnimDesc(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCSeqSynthAnimDesc::GCSeqSynthAnimDesc(void *ptr) {
    m_ptr = ptr;
}
CBufferString GCSeqSynthAnimDesc::GetName() const {
    return GetSchemaValue<CBufferString>(m_ptr, "CSeqSynthAnimDesc", "m_sName");
}
void GCSeqSynthAnimDesc::SetName(CBufferString value) {
    SetSchemaValue(m_ptr, "CSeqSynthAnimDesc", "m_sName", false, value);
}
GCSeqSeqDescFlag GCSeqSynthAnimDesc::GetFlags() const {
    GCSeqSeqDescFlag value(GetSchemaPtr(m_ptr, "CSeqSynthAnimDesc", "m_flags"));
    return value;
}
void GCSeqSynthAnimDesc::SetFlags(GCSeqSeqDescFlag value) {
    SetSchemaValue(m_ptr, "CSeqSynthAnimDesc", "m_flags", false, value);
}
GCSeqTransition GCSeqSynthAnimDesc::GetTransition() const {
    GCSeqTransition value(GetSchemaPtr(m_ptr, "CSeqSynthAnimDesc", "m_transition"));
    return value;
}
void GCSeqSynthAnimDesc::SetTransition(GCSeqTransition value) {
    SetSchemaValue(m_ptr, "CSeqSynthAnimDesc", "m_transition", false, value);
}
int16_t GCSeqSynthAnimDesc::GetLocalBaseReference() const {
    return GetSchemaValue<int16_t>(m_ptr, "CSeqSynthAnimDesc", "m_nLocalBaseReference");
}
void GCSeqSynthAnimDesc::SetLocalBaseReference(int16_t value) {
    SetSchemaValue(m_ptr, "CSeqSynthAnimDesc", "m_nLocalBaseReference", false, value);
}
int16_t GCSeqSynthAnimDesc::GetLocalBoneMask() const {
    return GetSchemaValue<int16_t>(m_ptr, "CSeqSynthAnimDesc", "m_nLocalBoneMask");
}
void GCSeqSynthAnimDesc::SetLocalBoneMask(int16_t value) {
    SetSchemaValue(m_ptr, "CSeqSynthAnimDesc", "m_nLocalBoneMask", false, value);
}
std::vector<GCAnimActivity> GCSeqSynthAnimDesc::GetActivityArray() const {
    CUtlVector<GCAnimActivity>* vec = GetSchemaValue<CUtlVector<GCAnimActivity>*>(m_ptr, "CSeqSynthAnimDesc", "m_activityArray"); std::vector<GCAnimActivity> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCSeqSynthAnimDesc::SetActivityArray(std::vector<GCAnimActivity> value) {
    SetSchemaValueCUtlVector<GCAnimActivity>(m_ptr, "CSeqSynthAnimDesc", "m_activityArray", false, value);
}
std::string GCSeqSynthAnimDesc::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCSeqSynthAnimDesc::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCSeqSynthAnimDesc(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCSeqSynthAnimDesc>("CSeqSynthAnimDesc")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Name", &GCSeqSynthAnimDesc::GetName, &GCSeqSynthAnimDesc::SetName)
        .addProperty("Flags", &GCSeqSynthAnimDesc::GetFlags, &GCSeqSynthAnimDesc::SetFlags)
        .addProperty("Transition", &GCSeqSynthAnimDesc::GetTransition, &GCSeqSynthAnimDesc::SetTransition)
        .addProperty("LocalBaseReference", &GCSeqSynthAnimDesc::GetLocalBaseReference, &GCSeqSynthAnimDesc::SetLocalBaseReference)
        .addProperty("LocalBoneMask", &GCSeqSynthAnimDesc::GetLocalBoneMask, &GCSeqSynthAnimDesc::SetLocalBoneMask)
        .addProperty("ActivityArray", &GCSeqSynthAnimDesc::GetActivityArray, &GCSeqSynthAnimDesc::SetActivityArray)
        .addFunction("ToPtr", &GCSeqSynthAnimDesc::ToPtr)
        .addFunction("IsValid", &GCSeqSynthAnimDesc::IsValid)
        .endClass();
}
GCDirectPlaybackTagData::GCDirectPlaybackTagData(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCDirectPlaybackTagData::GCDirectPlaybackTagData(void *ptr) {
    m_ptr = ptr;
}
std::string GCDirectPlaybackTagData::GetSequenceName() const {
    return GetSchemaValue<CUtlString>(m_ptr, "CDirectPlaybackTagData", "m_sequenceName").Get();
}
void GCDirectPlaybackTagData::SetSequenceName(std::string value) {
    SetSchemaValue(m_ptr, "CDirectPlaybackTagData", "m_sequenceName", false, CUtlString(value.c_str()));
}
std::vector<GTagSpan_t> GCDirectPlaybackTagData::GetTags() const {
    CUtlVector<GTagSpan_t>* vec = GetSchemaValue<CUtlVector<GTagSpan_t>*>(m_ptr, "CDirectPlaybackTagData", "m_tags"); std::vector<GTagSpan_t> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCDirectPlaybackTagData::SetTags(std::vector<GTagSpan_t> value) {
    SetSchemaValueCUtlVector<GTagSpan_t>(m_ptr, "CDirectPlaybackTagData", "m_tags", false, value);
}
std::string GCDirectPlaybackTagData::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCDirectPlaybackTagData::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCDirectPlaybackTagData(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCDirectPlaybackTagData>("CDirectPlaybackTagData")
        .addConstructor<void (*)(std::string)>()
        .addProperty("SequenceName", &GCDirectPlaybackTagData::GetSequenceName, &GCDirectPlaybackTagData::SetSequenceName)
        .addProperty("Tags", &GCDirectPlaybackTagData::GetTags, &GCDirectPlaybackTagData::SetTags)
        .addFunction("ToPtr", &GCDirectPlaybackTagData::ToPtr)
        .addFunction("IsValid", &GCDirectPlaybackTagData::IsValid)
        .endClass();
}
GEventFrameBoundary_t::GEventFrameBoundary_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GEventFrameBoundary_t::GEventFrameBoundary_t(void *ptr) {
    m_ptr = ptr;
}
float GEventFrameBoundary_t::GetFrameTime() const {
    return GetSchemaValue<float>(m_ptr, "EventFrameBoundary_t", "m_flFrameTime");
}
void GEventFrameBoundary_t::SetFrameTime(float value) {
    SetSchemaValue(m_ptr, "EventFrameBoundary_t", "m_flFrameTime", true, value);
}
std::string GEventFrameBoundary_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GEventFrameBoundary_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassEventFrameBoundary_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GEventFrameBoundary_t>("EventFrameBoundary_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("FrameTime", &GEventFrameBoundary_t::GetFrameTime, &GEventFrameBoundary_t::SetFrameTime)
        .addFunction("ToPtr", &GEventFrameBoundary_t::ToPtr)
        .addFunction("IsValid", &GEventFrameBoundary_t::IsValid)
        .endClass();
}
GWorldNode_t::GWorldNode_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GWorldNode_t::GWorldNode_t(void *ptr) {
    m_ptr = ptr;
}
std::vector<GSceneObject_t> GWorldNode_t::GetSceneObjects() const {
    CUtlVector<GSceneObject_t>* vec = GetSchemaValue<CUtlVector<GSceneObject_t>*>(m_ptr, "WorldNode_t", "m_sceneObjects"); std::vector<GSceneObject_t> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GWorldNode_t::SetSceneObjects(std::vector<GSceneObject_t> value) {
    SetSchemaValueCUtlVector<GSceneObject_t>(m_ptr, "WorldNode_t", "m_sceneObjects", true, value);
}
std::vector<GInfoOverlayData_t> GWorldNode_t::GetInfoOverlays() const {
    CUtlVector<GInfoOverlayData_t>* vec = GetSchemaValue<CUtlVector<GInfoOverlayData_t>*>(m_ptr, "WorldNode_t", "m_infoOverlays"); std::vector<GInfoOverlayData_t> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GWorldNode_t::SetInfoOverlays(std::vector<GInfoOverlayData_t> value) {
    SetSchemaValueCUtlVector<GInfoOverlayData_t>(m_ptr, "WorldNode_t", "m_infoOverlays", true, value);
}
std::vector<uint16> GWorldNode_t::GetVisClusterMembership() const {
    CUtlVector<uint16>* vec = GetSchemaValue<CUtlVector<uint16>*>(m_ptr, "WorldNode_t", "m_visClusterMembership"); std::vector<uint16> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GWorldNode_t::SetVisClusterMembership(std::vector<uint16> value) {
    SetSchemaValueCUtlVector<uint16>(m_ptr, "WorldNode_t", "m_visClusterMembership", true, value);
}
std::vector<GAggregateSceneObject_t> GWorldNode_t::GetAggregateSceneObjects() const {
    CUtlVector<GAggregateSceneObject_t>* vec = GetSchemaValue<CUtlVector<GAggregateSceneObject_t>*>(m_ptr, "WorldNode_t", "m_aggregateSceneObjects"); std::vector<GAggregateSceneObject_t> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GWorldNode_t::SetAggregateSceneObjects(std::vector<GAggregateSceneObject_t> value) {
    SetSchemaValueCUtlVector<GAggregateSceneObject_t>(m_ptr, "WorldNode_t", "m_aggregateSceneObjects", true, value);
}
std::vector<GClutterSceneObject_t> GWorldNode_t::GetClutterSceneObjects() const {
    CUtlVector<GClutterSceneObject_t>* vec = GetSchemaValue<CUtlVector<GClutterSceneObject_t>*>(m_ptr, "WorldNode_t", "m_clutterSceneObjects"); std::vector<GClutterSceneObject_t> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GWorldNode_t::SetClutterSceneObjects(std::vector<GClutterSceneObject_t> value) {
    SetSchemaValueCUtlVector<GClutterSceneObject_t>(m_ptr, "WorldNode_t", "m_clutterSceneObjects", true, value);
}
std::vector<GExtraVertexStreamOverride_t> GWorldNode_t::GetExtraVertexStreamOverrides() const {
    CUtlVector<GExtraVertexStreamOverride_t>* vec = GetSchemaValue<CUtlVector<GExtraVertexStreamOverride_t>*>(m_ptr, "WorldNode_t", "m_extraVertexStreamOverrides"); std::vector<GExtraVertexStreamOverride_t> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GWorldNode_t::SetExtraVertexStreamOverrides(std::vector<GExtraVertexStreamOverride_t> value) {
    SetSchemaValueCUtlVector<GExtraVertexStreamOverride_t>(m_ptr, "WorldNode_t", "m_extraVertexStreamOverrides", true, value);
}
std::vector<GMaterialOverride_t> GWorldNode_t::GetMaterialOverrides() const {
    CUtlVector<GMaterialOverride_t>* vec = GetSchemaValue<CUtlVector<GMaterialOverride_t>*>(m_ptr, "WorldNode_t", "m_materialOverrides"); std::vector<GMaterialOverride_t> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GWorldNode_t::SetMaterialOverrides(std::vector<GMaterialOverride_t> value) {
    SetSchemaValueCUtlVector<GMaterialOverride_t>(m_ptr, "WorldNode_t", "m_materialOverrides", true, value);
}
std::vector<GWorldNodeOnDiskBufferData_t> GWorldNode_t::GetExtraVertexStreams() const {
    CUtlVector<GWorldNodeOnDiskBufferData_t>* vec = GetSchemaValue<CUtlVector<GWorldNodeOnDiskBufferData_t>*>(m_ptr, "WorldNode_t", "m_extraVertexStreams"); std::vector<GWorldNodeOnDiskBufferData_t> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GWorldNode_t::SetExtraVertexStreams(std::vector<GWorldNodeOnDiskBufferData_t> value) {
    SetSchemaValueCUtlVector<GWorldNodeOnDiskBufferData_t>(m_ptr, "WorldNode_t", "m_extraVertexStreams", true, value);
}
std::vector<CUtlString> GWorldNode_t::GetLayerNames() const {
    CUtlVector<CUtlString>* vec = GetSchemaValue<CUtlVector<CUtlString>*>(m_ptr, "WorldNode_t", "m_layerNames"); std::vector<CUtlString> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GWorldNode_t::SetLayerNames(std::vector<CUtlString> value) {
    SetSchemaValueCUtlVector<CUtlString>(m_ptr, "WorldNode_t", "m_layerNames", true, value);
}
std::vector<uint8> GWorldNode_t::GetSceneObjectLayerIndices() const {
    CUtlVector<uint8>* vec = GetSchemaValue<CUtlVector<uint8>*>(m_ptr, "WorldNode_t", "m_sceneObjectLayerIndices"); std::vector<uint8> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GWorldNode_t::SetSceneObjectLayerIndices(std::vector<uint8> value) {
    SetSchemaValueCUtlVector<uint8>(m_ptr, "WorldNode_t", "m_sceneObjectLayerIndices", true, value);
}
std::vector<uint8> GWorldNode_t::GetOverlayLayerIndices() const {
    CUtlVector<uint8>* vec = GetSchemaValue<CUtlVector<uint8>*>(m_ptr, "WorldNode_t", "m_overlayLayerIndices"); std::vector<uint8> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GWorldNode_t::SetOverlayLayerIndices(std::vector<uint8> value) {
    SetSchemaValueCUtlVector<uint8>(m_ptr, "WorldNode_t", "m_overlayLayerIndices", true, value);
}
std::string GWorldNode_t::GetGrassFileName() const {
    return GetSchemaValue<CUtlString>(m_ptr, "WorldNode_t", "m_grassFileName").Get();
}
void GWorldNode_t::SetGrassFileName(std::string value) {
    SetSchemaValue(m_ptr, "WorldNode_t", "m_grassFileName", true, CUtlString(value.c_str()));
}
GBakedLightingInfo_t GWorldNode_t::GetNodeLightingInfo() const {
    GBakedLightingInfo_t value(GetSchemaPtr(m_ptr, "WorldNode_t", "m_nodeLightingInfo"));
    return value;
}
void GWorldNode_t::SetNodeLightingInfo(GBakedLightingInfo_t value) {
    SetSchemaValue(m_ptr, "WorldNode_t", "m_nodeLightingInfo", true, value);
}
std::string GWorldNode_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GWorldNode_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassWorldNode_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GWorldNode_t>("WorldNode_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("SceneObjects", &GWorldNode_t::GetSceneObjects, &GWorldNode_t::SetSceneObjects)
        .addProperty("InfoOverlays", &GWorldNode_t::GetInfoOverlays, &GWorldNode_t::SetInfoOverlays)
        .addProperty("VisClusterMembership", &GWorldNode_t::GetVisClusterMembership, &GWorldNode_t::SetVisClusterMembership)
        .addProperty("AggregateSceneObjects", &GWorldNode_t::GetAggregateSceneObjects, &GWorldNode_t::SetAggregateSceneObjects)
        .addProperty("ClutterSceneObjects", &GWorldNode_t::GetClutterSceneObjects, &GWorldNode_t::SetClutterSceneObjects)
        .addProperty("ExtraVertexStreamOverrides", &GWorldNode_t::GetExtraVertexStreamOverrides, &GWorldNode_t::SetExtraVertexStreamOverrides)
        .addProperty("MaterialOverrides", &GWorldNode_t::GetMaterialOverrides, &GWorldNode_t::SetMaterialOverrides)
        .addProperty("ExtraVertexStreams", &GWorldNode_t::GetExtraVertexStreams, &GWorldNode_t::SetExtraVertexStreams)
        .addProperty("LayerNames", &GWorldNode_t::GetLayerNames, &GWorldNode_t::SetLayerNames)
        .addProperty("SceneObjectLayerIndices", &GWorldNode_t::GetSceneObjectLayerIndices, &GWorldNode_t::SetSceneObjectLayerIndices)
        .addProperty("OverlayLayerIndices", &GWorldNode_t::GetOverlayLayerIndices, &GWorldNode_t::SetOverlayLayerIndices)
        .addProperty("GrassFileName", &GWorldNode_t::GetGrassFileName, &GWorldNode_t::SetGrassFileName)
        .addProperty("NodeLightingInfo", &GWorldNode_t::GetNodeLightingInfo, &GWorldNode_t::SetNodeLightingInfo)
        .addFunction("ToPtr", &GWorldNode_t::ToPtr)
        .addFunction("IsValid", &GWorldNode_t::IsValid)
        .endClass();
}
GAggregateMeshInfo_t::GAggregateMeshInfo_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GAggregateMeshInfo_t::GAggregateMeshInfo_t(void *ptr) {
    m_ptr = ptr;
}
uint32_t GAggregateMeshInfo_t::GetVisClusterMemberOffset() const {
    return GetSchemaValue<uint32_t>(m_ptr, "AggregateMeshInfo_t", "m_nVisClusterMemberOffset");
}
void GAggregateMeshInfo_t::SetVisClusterMemberOffset(uint32_t value) {
    SetSchemaValue(m_ptr, "AggregateMeshInfo_t", "m_nVisClusterMemberOffset", true, value);
}
uint8_t GAggregateMeshInfo_t::GetVisClusterMemberCount() const {
    return GetSchemaValue<uint8_t>(m_ptr, "AggregateMeshInfo_t", "m_nVisClusterMemberCount");
}
void GAggregateMeshInfo_t::SetVisClusterMemberCount(uint8_t value) {
    SetSchemaValue(m_ptr, "AggregateMeshInfo_t", "m_nVisClusterMemberCount", true, value);
}
bool GAggregateMeshInfo_t::GetHasTransform() const {
    return GetSchemaValue<bool>(m_ptr, "AggregateMeshInfo_t", "m_bHasTransform");
}
void GAggregateMeshInfo_t::SetHasTransform(bool value) {
    SetSchemaValue(m_ptr, "AggregateMeshInfo_t", "m_bHasTransform", true, value);
}
int16_t GAggregateMeshInfo_t::GetDrawCallIndex() const {
    return GetSchemaValue<int16_t>(m_ptr, "AggregateMeshInfo_t", "m_nDrawCallIndex");
}
void GAggregateMeshInfo_t::SetDrawCallIndex(int16_t value) {
    SetSchemaValue(m_ptr, "AggregateMeshInfo_t", "m_nDrawCallIndex", true, value);
}
int16_t GAggregateMeshInfo_t::GetLODSetupIndex() const {
    return GetSchemaValue<int16_t>(m_ptr, "AggregateMeshInfo_t", "m_nLODSetupIndex");
}
void GAggregateMeshInfo_t::SetLODSetupIndex(int16_t value) {
    SetSchemaValue(m_ptr, "AggregateMeshInfo_t", "m_nLODSetupIndex", true, value);
}
uint8_t GAggregateMeshInfo_t::GetLODGroupMask() const {
    return GetSchemaValue<uint8_t>(m_ptr, "AggregateMeshInfo_t", "m_nLODGroupMask");
}
void GAggregateMeshInfo_t::SetLODGroupMask(uint8_t value) {
    SetSchemaValue(m_ptr, "AggregateMeshInfo_t", "m_nLODGroupMask", true, value);
}
Color GAggregateMeshInfo_t::GetTintColor() const {
    return GetSchemaValue<Color>(m_ptr, "AggregateMeshInfo_t", "m_vTintColor");
}
void GAggregateMeshInfo_t::SetTintColor(Color value) {
    SetSchemaValue(m_ptr, "AggregateMeshInfo_t", "m_vTintColor", true, value);
}
uint64_t GAggregateMeshInfo_t::GetObjectFlags() const {
    return GetSchemaValue<uint64_t>(m_ptr, "AggregateMeshInfo_t", "m_objectFlags");
}
void GAggregateMeshInfo_t::SetObjectFlags(uint64_t value) {
    SetSchemaValue(m_ptr, "AggregateMeshInfo_t", "m_objectFlags", true, value);
}
int32_t GAggregateMeshInfo_t::GetLightProbeVolumePrecomputedHandshake() const {
    return GetSchemaValue<int32_t>(m_ptr, "AggregateMeshInfo_t", "m_nLightProbeVolumePrecomputedHandshake");
}
void GAggregateMeshInfo_t::SetLightProbeVolumePrecomputedHandshake(int32_t value) {
    SetSchemaValue(m_ptr, "AggregateMeshInfo_t", "m_nLightProbeVolumePrecomputedHandshake", true, value);
}
std::string GAggregateMeshInfo_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GAggregateMeshInfo_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassAggregateMeshInfo_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GAggregateMeshInfo_t>("AggregateMeshInfo_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("VisClusterMemberOffset", &GAggregateMeshInfo_t::GetVisClusterMemberOffset, &GAggregateMeshInfo_t::SetVisClusterMemberOffset)
        .addProperty("VisClusterMemberCount", &GAggregateMeshInfo_t::GetVisClusterMemberCount, &GAggregateMeshInfo_t::SetVisClusterMemberCount)
        .addProperty("HasTransform", &GAggregateMeshInfo_t::GetHasTransform, &GAggregateMeshInfo_t::SetHasTransform)
        .addProperty("DrawCallIndex", &GAggregateMeshInfo_t::GetDrawCallIndex, &GAggregateMeshInfo_t::SetDrawCallIndex)
        .addProperty("LODSetupIndex", &GAggregateMeshInfo_t::GetLODSetupIndex, &GAggregateMeshInfo_t::SetLODSetupIndex)
        .addProperty("LODGroupMask", &GAggregateMeshInfo_t::GetLODGroupMask, &GAggregateMeshInfo_t::SetLODGroupMask)
        .addProperty("TintColor", &GAggregateMeshInfo_t::GetTintColor, &GAggregateMeshInfo_t::SetTintColor)
        .addProperty("ObjectFlags", &GAggregateMeshInfo_t::GetObjectFlags, &GAggregateMeshInfo_t::SetObjectFlags)
        .addProperty("LightProbeVolumePrecomputedHandshake", &GAggregateMeshInfo_t::GetLightProbeVolumePrecomputedHandshake, &GAggregateMeshInfo_t::SetLightProbeVolumePrecomputedHandshake)
        .addFunction("ToPtr", &GAggregateMeshInfo_t::ToPtr)
        .addFunction("IsValid", &GAggregateMeshInfo_t::IsValid)
        .endClass();
}
GFeSimdRodConstraintAnim_t::GFeSimdRodConstraintAnim_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GFeSimdRodConstraintAnim_t::GFeSimdRodConstraintAnim_t(void *ptr) {
    m_ptr = ptr;
}
float GFeSimdRodConstraintAnim_t::Get4Weight0() const {
    return GetSchemaValue<float>(m_ptr, "FeSimdRodConstraintAnim_t", "f4Weight0");
}
void GFeSimdRodConstraintAnim_t::Set4Weight0(float value) {
    SetSchemaValue(m_ptr, "FeSimdRodConstraintAnim_t", "f4Weight0", true, value);
}
float GFeSimdRodConstraintAnim_t::Get4RelaxationFactor() const {
    return GetSchemaValue<float>(m_ptr, "FeSimdRodConstraintAnim_t", "f4RelaxationFactor");
}
void GFeSimdRodConstraintAnim_t::Set4RelaxationFactor(float value) {
    SetSchemaValue(m_ptr, "FeSimdRodConstraintAnim_t", "f4RelaxationFactor", true, value);
}
std::string GFeSimdRodConstraintAnim_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GFeSimdRodConstraintAnim_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassFeSimdRodConstraintAnim_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GFeSimdRodConstraintAnim_t>("FeSimdRodConstraintAnim_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("4Weight0", &GFeSimdRodConstraintAnim_t::Get4Weight0, &GFeSimdRodConstraintAnim_t::Set4Weight0)
        .addProperty("4RelaxationFactor", &GFeSimdRodConstraintAnim_t::Get4RelaxationFactor, &GFeSimdRodConstraintAnim_t::Set4RelaxationFactor)
        .addFunction("ToPtr", &GFeSimdRodConstraintAnim_t::ToPtr)
        .addFunction("IsValid", &GFeSimdRodConstraintAnim_t::IsValid)
        .endClass();
}
GEventPostAdvanceTick_t::GEventPostAdvanceTick_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GEventPostAdvanceTick_t::GEventPostAdvanceTick_t(void *ptr) {
    m_ptr = ptr;
}
int32_t GEventPostAdvanceTick_t::GetCurrentTick() const {
    return GetSchemaValue<int32_t>(m_ptr, "EventPostAdvanceTick_t", "m_nCurrentTick");
}
void GEventPostAdvanceTick_t::SetCurrentTick(int32_t value) {
    SetSchemaValue(m_ptr, "EventPostAdvanceTick_t", "m_nCurrentTick", true, value);
}
int32_t GEventPostAdvanceTick_t::GetCurrentTickThisFrame() const {
    return GetSchemaValue<int32_t>(m_ptr, "EventPostAdvanceTick_t", "m_nCurrentTickThisFrame");
}
void GEventPostAdvanceTick_t::SetCurrentTickThisFrame(int32_t value) {
    SetSchemaValue(m_ptr, "EventPostAdvanceTick_t", "m_nCurrentTickThisFrame", true, value);
}
int32_t GEventPostAdvanceTick_t::GetTotalTicksThisFrame() const {
    return GetSchemaValue<int32_t>(m_ptr, "EventPostAdvanceTick_t", "m_nTotalTicksThisFrame");
}
void GEventPostAdvanceTick_t::SetTotalTicksThisFrame(int32_t value) {
    SetSchemaValue(m_ptr, "EventPostAdvanceTick_t", "m_nTotalTicksThisFrame", true, value);
}
int32_t GEventPostAdvanceTick_t::GetTotalTicks() const {
    return GetSchemaValue<int32_t>(m_ptr, "EventPostAdvanceTick_t", "m_nTotalTicks");
}
void GEventPostAdvanceTick_t::SetTotalTicks(int32_t value) {
    SetSchemaValue(m_ptr, "EventPostAdvanceTick_t", "m_nTotalTicks", true, value);
}
std::string GEventPostAdvanceTick_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GEventPostAdvanceTick_t::IsValid() {
    return (m_ptr != nullptr);
}
GEventSimulate_t GEventPostAdvanceTick_t::GetParent() const {
    GEventSimulate_t value(m_ptr);
    return value;
}
void GEventPostAdvanceTick_t::SetParent(GEventSimulate_t value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassEventPostAdvanceTick_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GEventPostAdvanceTick_t>("EventPostAdvanceTick_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("CurrentTick", &GEventPostAdvanceTick_t::GetCurrentTick, &GEventPostAdvanceTick_t::SetCurrentTick)
        .addProperty("CurrentTickThisFrame", &GEventPostAdvanceTick_t::GetCurrentTickThisFrame, &GEventPostAdvanceTick_t::SetCurrentTickThisFrame)
        .addProperty("TotalTicksThisFrame", &GEventPostAdvanceTick_t::GetTotalTicksThisFrame, &GEventPostAdvanceTick_t::SetTotalTicksThisFrame)
        .addProperty("TotalTicks", &GEventPostAdvanceTick_t::GetTotalTicks, &GEventPostAdvanceTick_t::SetTotalTicks)
        .addProperty("Parent", &GEventPostAdvanceTick_t::GetParent, &GEventPostAdvanceTick_t::SetParent)
        .addFunction("ToPtr", &GEventPostAdvanceTick_t::ToPtr)
        .addFunction("IsValid", &GEventPostAdvanceTick_t::IsValid)
        .endClass();
}
GFeBuildBoxRigid_t::GFeBuildBoxRigid_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GFeBuildBoxRigid_t::GFeBuildBoxRigid_t(void *ptr) {
    m_ptr = ptr;
}
int32_t GFeBuildBoxRigid_t::GetPriority() const {
    return GetSchemaValue<int32_t>(m_ptr, "FeBuildBoxRigid_t", "m_nPriority");
}
void GFeBuildBoxRigid_t::SetPriority(int32_t value) {
    SetSchemaValue(m_ptr, "FeBuildBoxRigid_t", "m_nPriority", true, value);
}
uint32_t GFeBuildBoxRigid_t::GetVertexMapHash() const {
    return GetSchemaValue<uint32_t>(m_ptr, "FeBuildBoxRigid_t", "m_nVertexMapHash");
}
void GFeBuildBoxRigid_t::SetVertexMapHash(uint32_t value) {
    SetSchemaValue(m_ptr, "FeBuildBoxRigid_t", "m_nVertexMapHash", true, value);
}
std::string GFeBuildBoxRigid_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GFeBuildBoxRigid_t::IsValid() {
    return (m_ptr != nullptr);
}
GFeBoxRigid_t GFeBuildBoxRigid_t::GetParent() const {
    GFeBoxRigid_t value(m_ptr);
    return value;
}
void GFeBuildBoxRigid_t::SetParent(GFeBoxRigid_t value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassFeBuildBoxRigid_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GFeBuildBoxRigid_t>("FeBuildBoxRigid_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Priority", &GFeBuildBoxRigid_t::GetPriority, &GFeBuildBoxRigid_t::SetPriority)
        .addProperty("VertexMapHash", &GFeBuildBoxRigid_t::GetVertexMapHash, &GFeBuildBoxRigid_t::SetVertexMapHash)
        .addProperty("Parent", &GFeBuildBoxRigid_t::GetParent, &GFeBuildBoxRigid_t::SetParent)
        .addFunction("ToPtr", &GFeBuildBoxRigid_t::ToPtr)
        .addFunction("IsValid", &GFeBuildBoxRigid_t::IsValid)
        .endClass();
}
GIPhysicsPlayerController::GIPhysicsPlayerController(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GIPhysicsPlayerController::GIPhysicsPlayerController(void *ptr) {
    m_ptr = ptr;
}
std::string GIPhysicsPlayerController::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GIPhysicsPlayerController::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassIPhysicsPlayerController(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GIPhysicsPlayerController>("IPhysicsPlayerController")
        .addConstructor<void (*)(std::string)>()
        .addFunction("ToPtr", &GIPhysicsPlayerController::ToPtr)
        .addFunction("IsValid", &GIPhysicsPlayerController::IsValid)
        .endClass();
}
GEventServerPostAdvanceTick_t::GEventServerPostAdvanceTick_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GEventServerPostAdvanceTick_t::GEventServerPostAdvanceTick_t(void *ptr) {
    m_ptr = ptr;
}
std::string GEventServerPostAdvanceTick_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GEventServerPostAdvanceTick_t::IsValid() {
    return (m_ptr != nullptr);
}
GEventPostAdvanceTick_t GEventServerPostAdvanceTick_t::GetParent() const {
    GEventPostAdvanceTick_t value(m_ptr);
    return value;
}
void GEventServerPostAdvanceTick_t::SetParent(GEventPostAdvanceTick_t value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassEventServerPostAdvanceTick_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GEventServerPostAdvanceTick_t>("EventServerPostAdvanceTick_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GEventServerPostAdvanceTick_t::GetParent, &GEventServerPostAdvanceTick_t::SetParent)
        .addFunction("ToPtr", &GEventServerPostAdvanceTick_t::ToPtr)
        .addFunction("IsValid", &GEventServerPostAdvanceTick_t::IsValid)
        .endClass();
}
GEventClientPreOutput_t::GEventClientPreOutput_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GEventClientPreOutput_t::GEventClientPreOutput_t(void *ptr) {
    m_ptr = ptr;
}
GEngineLoopState_t GEventClientPreOutput_t::GetLoopState() const {
    GEngineLoopState_t value(GetSchemaPtr(m_ptr, "EventClientPreOutput_t", "m_LoopState"));
    return value;
}
void GEventClientPreOutput_t::SetLoopState(GEngineLoopState_t value) {
    SetSchemaValue(m_ptr, "EventClientPreOutput_t", "m_LoopState", true, value);
}
double GEventClientPreOutput_t::GetRenderTime() const {
    return GetSchemaValue<double>(m_ptr, "EventClientPreOutput_t", "m_flRenderTime");
}
void GEventClientPreOutput_t::SetRenderTime(double value) {
    SetSchemaValue(m_ptr, "EventClientPreOutput_t", "m_flRenderTime", true, value);
}
double GEventClientPreOutput_t::GetRenderFrameTime() const {
    return GetSchemaValue<double>(m_ptr, "EventClientPreOutput_t", "m_flRenderFrameTime");
}
void GEventClientPreOutput_t::SetRenderFrameTime(double value) {
    SetSchemaValue(m_ptr, "EventClientPreOutput_t", "m_flRenderFrameTime", true, value);
}
double GEventClientPreOutput_t::GetRenderFrameTimeUnbounded() const {
    return GetSchemaValue<double>(m_ptr, "EventClientPreOutput_t", "m_flRenderFrameTimeUnbounded");
}
void GEventClientPreOutput_t::SetRenderFrameTimeUnbounded(double value) {
    SetSchemaValue(m_ptr, "EventClientPreOutput_t", "m_flRenderFrameTimeUnbounded", true, value);
}
float GEventClientPreOutput_t::GetRealTime() const {
    return GetSchemaValue<float>(m_ptr, "EventClientPreOutput_t", "m_flRealTime");
}
void GEventClientPreOutput_t::SetRealTime(float value) {
    SetSchemaValue(m_ptr, "EventClientPreOutput_t", "m_flRealTime", true, value);
}
bool GEventClientPreOutput_t::GetRenderOnly() const {
    return GetSchemaValue<bool>(m_ptr, "EventClientPreOutput_t", "m_bRenderOnly");
}
void GEventClientPreOutput_t::SetRenderOnly(bool value) {
    SetSchemaValue(m_ptr, "EventClientPreOutput_t", "m_bRenderOnly", true, value);
}
std::string GEventClientPreOutput_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GEventClientPreOutput_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassEventClientPreOutput_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GEventClientPreOutput_t>("EventClientPreOutput_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("LoopState", &GEventClientPreOutput_t::GetLoopState, &GEventClientPreOutput_t::SetLoopState)
        .addProperty("RenderTime", &GEventClientPreOutput_t::GetRenderTime, &GEventClientPreOutput_t::SetRenderTime)
        .addProperty("RenderFrameTime", &GEventClientPreOutput_t::GetRenderFrameTime, &GEventClientPreOutput_t::SetRenderFrameTime)
        .addProperty("RenderFrameTimeUnbounded", &GEventClientPreOutput_t::GetRenderFrameTimeUnbounded, &GEventClientPreOutput_t::SetRenderFrameTimeUnbounded)
        .addProperty("RealTime", &GEventClientPreOutput_t::GetRealTime, &GEventClientPreOutput_t::SetRealTime)
        .addProperty("RenderOnly", &GEventClientPreOutput_t::GetRenderOnly, &GEventClientPreOutput_t::SetRenderOnly)
        .addFunction("ToPtr", &GEventClientPreOutput_t::ToPtr)
        .addFunction("IsValid", &GEventClientPreOutput_t::IsValid)
        .endClass();
}
GRnSoftbodySpring_t::GRnSoftbodySpring_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GRnSoftbodySpring_t::GRnSoftbodySpring_t(void *ptr) {
    m_ptr = ptr;
}
std::vector<uint16_t> GRnSoftbodySpring_t::GetParticle() const {
    uint16_t* outValue = GetSchemaValue<uint16_t*>(m_ptr, "RnSoftbodySpring_t", "m_nParticle"); std::vector<uint16_t> ret; for(int i = 0; i < 2; i++) { ret.push_back(outValue[i]); } return ret;
}
void GRnSoftbodySpring_t::SetParticle(std::vector<uint16_t> value) {
    uint16_t* outValue = GetSchemaValue<uint16_t*>(m_ptr, "RnSoftbodySpring_t", "m_nParticle"); for(int i = 0; i < 2; i++) { outValue[i] = value[i]; } SetSchemaValue(m_ptr, "RnSoftbodySpring_t", "m_nParticle", true, outValue);
}
float GRnSoftbodySpring_t::GetLength() const {
    return GetSchemaValue<float>(m_ptr, "RnSoftbodySpring_t", "m_flLength");
}
void GRnSoftbodySpring_t::SetLength(float value) {
    SetSchemaValue(m_ptr, "RnSoftbodySpring_t", "m_flLength", true, value);
}
std::string GRnSoftbodySpring_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GRnSoftbodySpring_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassRnSoftbodySpring_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GRnSoftbodySpring_t>("RnSoftbodySpring_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Particle", &GRnSoftbodySpring_t::GetParticle, &GRnSoftbodySpring_t::SetParticle)
        .addProperty("Length", &GRnSoftbodySpring_t::GetLength, &GRnSoftbodySpring_t::SetLength)
        .addFunction("ToPtr", &GRnSoftbodySpring_t::ToPtr)
        .addFunction("IsValid", &GRnSoftbodySpring_t::IsValid)
        .endClass();
}
GFeNodeReverseOffset_t::GFeNodeReverseOffset_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GFeNodeReverseOffset_t::GFeNodeReverseOffset_t(void *ptr) {
    m_ptr = ptr;
}
Vector GFeNodeReverseOffset_t::GetOffset() const {
    return GetSchemaValue<Vector>(m_ptr, "FeNodeReverseOffset_t", "vOffset");
}
void GFeNodeReverseOffset_t::SetOffset(Vector value) {
    SetSchemaValue(m_ptr, "FeNodeReverseOffset_t", "vOffset", true, value);
}
uint16_t GFeNodeReverseOffset_t::GetBoneCtrl() const {
    return GetSchemaValue<uint16_t>(m_ptr, "FeNodeReverseOffset_t", "nBoneCtrl");
}
void GFeNodeReverseOffset_t::SetBoneCtrl(uint16_t value) {
    SetSchemaValue(m_ptr, "FeNodeReverseOffset_t", "nBoneCtrl", true, value);
}
uint16_t GFeNodeReverseOffset_t::GetTargetNode() const {
    return GetSchemaValue<uint16_t>(m_ptr, "FeNodeReverseOffset_t", "nTargetNode");
}
void GFeNodeReverseOffset_t::SetTargetNode(uint16_t value) {
    SetSchemaValue(m_ptr, "FeNodeReverseOffset_t", "nTargetNode", true, value);
}
std::string GFeNodeReverseOffset_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GFeNodeReverseOffset_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassFeNodeReverseOffset_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GFeNodeReverseOffset_t>("FeNodeReverseOffset_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Offset", &GFeNodeReverseOffset_t::GetOffset, &GFeNodeReverseOffset_t::SetOffset)
        .addProperty("BoneCtrl", &GFeNodeReverseOffset_t::GetBoneCtrl, &GFeNodeReverseOffset_t::SetBoneCtrl)
        .addProperty("TargetNode", &GFeNodeReverseOffset_t::GetTargetNode, &GFeNodeReverseOffset_t::SetTargetNode)
        .addFunction("ToPtr", &GFeNodeReverseOffset_t::ToPtr)
        .addFunction("IsValid", &GFeNodeReverseOffset_t::IsValid)
        .endClass();
}
GRnHullDesc_t::GRnHullDesc_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GRnHullDesc_t::GRnHullDesc_t(void *ptr) {
    m_ptr = ptr;
}
GRnHull_t GRnHullDesc_t::GetHull() const {
    GRnHull_t value(GetSchemaPtr(m_ptr, "RnHullDesc_t", "m_Hull"));
    return value;
}
void GRnHullDesc_t::SetHull(GRnHull_t value) {
    SetSchemaValue(m_ptr, "RnHullDesc_t", "m_Hull", true, value);
}
std::string GRnHullDesc_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GRnHullDesc_t::IsValid() {
    return (m_ptr != nullptr);
}
GRnShapeDesc_t GRnHullDesc_t::GetParent() const {
    GRnShapeDesc_t value(m_ptr);
    return value;
}
void GRnHullDesc_t::SetParent(GRnShapeDesc_t value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassRnHullDesc_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GRnHullDesc_t>("RnHullDesc_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Hull", &GRnHullDesc_t::GetHull, &GRnHullDesc_t::SetHull)
        .addProperty("Parent", &GRnHullDesc_t::GetParent, &GRnHullDesc_t::SetParent)
        .addFunction("ToPtr", &GRnHullDesc_t::ToPtr)
        .addFunction("IsValid", &GRnHullDesc_t::IsValid)
        .endClass();
}
GCSymbolAnimParameter::GCSymbolAnimParameter(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCSymbolAnimParameter::GCSymbolAnimParameter(void *ptr) {
    m_ptr = ptr;
}
std::string GCSymbolAnimParameter::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCSymbolAnimParameter::IsValid() {
    return (m_ptr != nullptr);
}
GCConcreteAnimParameter GCSymbolAnimParameter::GetParent() const {
    GCConcreteAnimParameter value(m_ptr);
    return value;
}
void GCSymbolAnimParameter::SetParent(GCConcreteAnimParameter value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCSymbolAnimParameter(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCSymbolAnimParameter>("CSymbolAnimParameter")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCSymbolAnimParameter::GetParent, &GCSymbolAnimParameter::SetParent)
        .addFunction("ToPtr", &GCSymbolAnimParameter::ToPtr)
        .addFunction("IsValid", &GCSymbolAnimParameter::IsValid)
        .endClass();
}
GFeStiffHingeBuild_t::GFeStiffHingeBuild_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GFeStiffHingeBuild_t::GFeStiffHingeBuild_t(void *ptr) {
    m_ptr = ptr;
}
float GFeStiffHingeBuild_t::GetMaxAngle() const {
    return GetSchemaValue<float>(m_ptr, "FeStiffHingeBuild_t", "flMaxAngle");
}
void GFeStiffHingeBuild_t::SetMaxAngle(float value) {
    SetSchemaValue(m_ptr, "FeStiffHingeBuild_t", "flMaxAngle", true, value);
}
float GFeStiffHingeBuild_t::GetStrength() const {
    return GetSchemaValue<float>(m_ptr, "FeStiffHingeBuild_t", "flStrength");
}
void GFeStiffHingeBuild_t::SetStrength(float value) {
    SetSchemaValue(m_ptr, "FeStiffHingeBuild_t", "flStrength", true, value);
}
std::vector<float> GFeStiffHingeBuild_t::GetMotionBias() const {
    float* outValue = GetSchemaValue<float*>(m_ptr, "FeStiffHingeBuild_t", "flMotionBias"); std::vector<float> ret; for(int i = 0; i < 3; i++) { ret.push_back(outValue[i]); } return ret;
}
void GFeStiffHingeBuild_t::SetMotionBias(std::vector<float> value) {
    float* outValue = GetSchemaValue<float*>(m_ptr, "FeStiffHingeBuild_t", "flMotionBias"); for(int i = 0; i < 3; i++) { outValue[i] = value[i]; } SetSchemaValue(m_ptr, "FeStiffHingeBuild_t", "flMotionBias", true, outValue);
}
std::vector<uint16_t> GFeStiffHingeBuild_t::GetNode() const {
    uint16_t* outValue = GetSchemaValue<uint16_t*>(m_ptr, "FeStiffHingeBuild_t", "nNode"); std::vector<uint16_t> ret; for(int i = 0; i < 3; i++) { ret.push_back(outValue[i]); } return ret;
}
void GFeStiffHingeBuild_t::SetNode(std::vector<uint16_t> value) {
    uint16_t* outValue = GetSchemaValue<uint16_t*>(m_ptr, "FeStiffHingeBuild_t", "nNode"); for(int i = 0; i < 3; i++) { outValue[i] = value[i]; } SetSchemaValue(m_ptr, "FeStiffHingeBuild_t", "nNode", true, outValue);
}
std::string GFeStiffHingeBuild_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GFeStiffHingeBuild_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassFeStiffHingeBuild_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GFeStiffHingeBuild_t>("FeStiffHingeBuild_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("MaxAngle", &GFeStiffHingeBuild_t::GetMaxAngle, &GFeStiffHingeBuild_t::SetMaxAngle)
        .addProperty("Strength", &GFeStiffHingeBuild_t::GetStrength, &GFeStiffHingeBuild_t::SetStrength)
        .addProperty("MotionBias", &GFeStiffHingeBuild_t::GetMotionBias, &GFeStiffHingeBuild_t::SetMotionBias)
        .addProperty("Node", &GFeStiffHingeBuild_t::GetNode, &GFeStiffHingeBuild_t::SetNode)
        .addFunction("ToPtr", &GFeStiffHingeBuild_t::ToPtr)
        .addFunction("IsValid", &GFeStiffHingeBuild_t::IsValid)
        .endClass();
}
GExtraVertexStreamOverride_t::GExtraVertexStreamOverride_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GExtraVertexStreamOverride_t::GExtraVertexStreamOverride_t(void *ptr) {
    m_ptr = ptr;
}
uint32_t GExtraVertexStreamOverride_t::GetSubSceneObject() const {
    return GetSchemaValue<uint32_t>(m_ptr, "ExtraVertexStreamOverride_t", "m_nSubSceneObject");
}
void GExtraVertexStreamOverride_t::SetSubSceneObject(uint32_t value) {
    SetSchemaValue(m_ptr, "ExtraVertexStreamOverride_t", "m_nSubSceneObject", true, value);
}
uint32_t GExtraVertexStreamOverride_t::GetDrawCallIndex() const {
    return GetSchemaValue<uint32_t>(m_ptr, "ExtraVertexStreamOverride_t", "m_nDrawCallIndex");
}
void GExtraVertexStreamOverride_t::SetDrawCallIndex(uint32_t value) {
    SetSchemaValue(m_ptr, "ExtraVertexStreamOverride_t", "m_nDrawCallIndex", true, value);
}
uint64_t GExtraVertexStreamOverride_t::GetAdditionalMeshDrawPrimitiveFlags() const {
    return GetSchemaValue<uint64_t>(m_ptr, "ExtraVertexStreamOverride_t", "m_nAdditionalMeshDrawPrimitiveFlags");
}
void GExtraVertexStreamOverride_t::SetAdditionalMeshDrawPrimitiveFlags(uint64_t value) {
    SetSchemaValue(m_ptr, "ExtraVertexStreamOverride_t", "m_nAdditionalMeshDrawPrimitiveFlags", true, value);
}
GCRenderBufferBinding GExtraVertexStreamOverride_t::GetExtraBufferBinding() const {
    GCRenderBufferBinding value(GetSchemaPtr(m_ptr, "ExtraVertexStreamOverride_t", "m_extraBufferBinding"));
    return value;
}
void GExtraVertexStreamOverride_t::SetExtraBufferBinding(GCRenderBufferBinding value) {
    SetSchemaValue(m_ptr, "ExtraVertexStreamOverride_t", "m_extraBufferBinding", true, value);
}
std::string GExtraVertexStreamOverride_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GExtraVertexStreamOverride_t::IsValid() {
    return (m_ptr != nullptr);
}
GBaseSceneObjectOverride_t GExtraVertexStreamOverride_t::GetParent() const {
    GBaseSceneObjectOverride_t value(m_ptr);
    return value;
}
void GExtraVertexStreamOverride_t::SetParent(GBaseSceneObjectOverride_t value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassExtraVertexStreamOverride_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GExtraVertexStreamOverride_t>("ExtraVertexStreamOverride_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("SubSceneObject", &GExtraVertexStreamOverride_t::GetSubSceneObject, &GExtraVertexStreamOverride_t::SetSubSceneObject)
        .addProperty("DrawCallIndex", &GExtraVertexStreamOverride_t::GetDrawCallIndex, &GExtraVertexStreamOverride_t::SetDrawCallIndex)
        .addProperty("AdditionalMeshDrawPrimitiveFlags", &GExtraVertexStreamOverride_t::GetAdditionalMeshDrawPrimitiveFlags, &GExtraVertexStreamOverride_t::SetAdditionalMeshDrawPrimitiveFlags)
        .addProperty("ExtraBufferBinding", &GExtraVertexStreamOverride_t::GetExtraBufferBinding, &GExtraVertexStreamOverride_t::SetExtraBufferBinding)
        .addProperty("Parent", &GExtraVertexStreamOverride_t::GetParent, &GExtraVertexStreamOverride_t::SetParent)
        .addFunction("ToPtr", &GExtraVertexStreamOverride_t::ToPtr)
        .addFunction("IsValid", &GExtraVertexStreamOverride_t::IsValid)
        .endClass();
}
GEntityIOConnectionData_t::GEntityIOConnectionData_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GEntityIOConnectionData_t::GEntityIOConnectionData_t(void *ptr) {
    m_ptr = ptr;
}
std::string GEntityIOConnectionData_t::GetOutputName() const {
    return GetSchemaValue<CUtlString>(m_ptr, "EntityIOConnectionData_t", "m_outputName").Get();
}
void GEntityIOConnectionData_t::SetOutputName(std::string value) {
    SetSchemaValue(m_ptr, "EntityIOConnectionData_t", "m_outputName", true, CUtlString(value.c_str()));
}
uint32_t GEntityIOConnectionData_t::GetTargetType() const {
    return GetSchemaValue<uint32_t>(m_ptr, "EntityIOConnectionData_t", "m_targetType");
}
void GEntityIOConnectionData_t::SetTargetType(uint32_t value) {
    SetSchemaValue(m_ptr, "EntityIOConnectionData_t", "m_targetType", true, value);
}
std::string GEntityIOConnectionData_t::GetTargetName() const {
    return GetSchemaValue<CUtlString>(m_ptr, "EntityIOConnectionData_t", "m_targetName").Get();
}
void GEntityIOConnectionData_t::SetTargetName(std::string value) {
    SetSchemaValue(m_ptr, "EntityIOConnectionData_t", "m_targetName", true, CUtlString(value.c_str()));
}
std::string GEntityIOConnectionData_t::GetInputName() const {
    return GetSchemaValue<CUtlString>(m_ptr, "EntityIOConnectionData_t", "m_inputName").Get();
}
void GEntityIOConnectionData_t::SetInputName(std::string value) {
    SetSchemaValue(m_ptr, "EntityIOConnectionData_t", "m_inputName", true, CUtlString(value.c_str()));
}
std::string GEntityIOConnectionData_t::GetOverrideParam() const {
    return GetSchemaValue<CUtlString>(m_ptr, "EntityIOConnectionData_t", "m_overrideParam").Get();
}
void GEntityIOConnectionData_t::SetOverrideParam(std::string value) {
    SetSchemaValue(m_ptr, "EntityIOConnectionData_t", "m_overrideParam", true, CUtlString(value.c_str()));
}
float GEntityIOConnectionData_t::GetDelay() const {
    return GetSchemaValue<float>(m_ptr, "EntityIOConnectionData_t", "m_flDelay");
}
void GEntityIOConnectionData_t::SetDelay(float value) {
    SetSchemaValue(m_ptr, "EntityIOConnectionData_t", "m_flDelay", true, value);
}
int32_t GEntityIOConnectionData_t::GetTimesToFire() const {
    return GetSchemaValue<int32_t>(m_ptr, "EntityIOConnectionData_t", "m_nTimesToFire");
}
void GEntityIOConnectionData_t::SetTimesToFire(int32_t value) {
    SetSchemaValue(m_ptr, "EntityIOConnectionData_t", "m_nTimesToFire", true, value);
}
std::string GEntityIOConnectionData_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GEntityIOConnectionData_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassEntityIOConnectionData_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GEntityIOConnectionData_t>("EntityIOConnectionData_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("OutputName", &GEntityIOConnectionData_t::GetOutputName, &GEntityIOConnectionData_t::SetOutputName)
        .addProperty("TargetType", &GEntityIOConnectionData_t::GetTargetType, &GEntityIOConnectionData_t::SetTargetType)
        .addProperty("TargetName", &GEntityIOConnectionData_t::GetTargetName, &GEntityIOConnectionData_t::SetTargetName)
        .addProperty("InputName", &GEntityIOConnectionData_t::GetInputName, &GEntityIOConnectionData_t::SetInputName)
        .addProperty("OverrideParam", &GEntityIOConnectionData_t::GetOverrideParam, &GEntityIOConnectionData_t::SetOverrideParam)
        .addProperty("Delay", &GEntityIOConnectionData_t::GetDelay, &GEntityIOConnectionData_t::SetDelay)
        .addProperty("TimesToFire", &GEntityIOConnectionData_t::GetTimesToFire, &GEntityIOConnectionData_t::SetTimesToFire)
        .addFunction("ToPtr", &GEntityIOConnectionData_t::ToPtr)
        .addFunction("IsValid", &GEntityIOConnectionData_t::IsValid)
        .endClass();
}
GSkeletonAnimCapture_t::GSkeletonAnimCapture_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GSkeletonAnimCapture_t::GSkeletonAnimCapture_t(void *ptr) {
    m_ptr = ptr;
}
CEntityIndex GSkeletonAnimCapture_t::GetEntIndex() const {
    return GetSchemaValue<CEntityIndex>(m_ptr, "SkeletonAnimCapture_t", "m_nEntIndex");
}
void GSkeletonAnimCapture_t::SetEntIndex(CEntityIndex value) {
    SetSchemaValue(m_ptr, "SkeletonAnimCapture_t", "m_nEntIndex", true, value);
}
CEntityIndex GSkeletonAnimCapture_t::GetEntParent() const {
    return GetSchemaValue<CEntityIndex>(m_ptr, "SkeletonAnimCapture_t", "m_nEntParent");
}
void GSkeletonAnimCapture_t::SetEntParent(CEntityIndex value) {
    SetSchemaValue(m_ptr, "SkeletonAnimCapture_t", "m_nEntParent", true, value);
}
std::vector<CEntityIndex> GSkeletonAnimCapture_t::GetImportedCollision() const {
    CUtlVector<CEntityIndex>* vec = GetSchemaValue<CUtlVector<CEntityIndex>*>(m_ptr, "SkeletonAnimCapture_t", "m_ImportedCollision"); std::vector<CEntityIndex> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GSkeletonAnimCapture_t::SetImportedCollision(std::vector<CEntityIndex> value) {
    SetSchemaValueCUtlVector<CEntityIndex>(m_ptr, "SkeletonAnimCapture_t", "m_ImportedCollision", true, value);
}
std::string GSkeletonAnimCapture_t::GetModelName() const {
    return GetSchemaValue<CUtlString>(m_ptr, "SkeletonAnimCapture_t", "m_ModelName").Get();
}
void GSkeletonAnimCapture_t::SetModelName(std::string value) {
    SetSchemaValue(m_ptr, "SkeletonAnimCapture_t", "m_ModelName", true, CUtlString(value.c_str()));
}
std::string GSkeletonAnimCapture_t::GetCaptureName() const {
    return GetSchemaValue<CUtlString>(m_ptr, "SkeletonAnimCapture_t", "m_CaptureName").Get();
}
void GSkeletonAnimCapture_t::SetCaptureName(std::string value) {
    SetSchemaValue(m_ptr, "SkeletonAnimCapture_t", "m_CaptureName", true, CUtlString(value.c_str()));
}
std::vector<GSkeletonAnimCapture_t> GSkeletonAnimCapture_t::GetModelBindPose() const {
    CUtlVector<GSkeletonAnimCapture_t>* vec = GetSchemaValue<CUtlVector<GSkeletonAnimCapture_t>*>(m_ptr, "SkeletonAnimCapture_t", "m_ModelBindPose"); std::vector<GSkeletonAnimCapture_t> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GSkeletonAnimCapture_t::SetModelBindPose(std::vector<GSkeletonAnimCapture_t> value) {
    SetSchemaValueCUtlVector<GSkeletonAnimCapture_t>(m_ptr, "SkeletonAnimCapture_t", "m_ModelBindPose", true, value);
}
std::vector<GSkeletonAnimCapture_t> GSkeletonAnimCapture_t::GetFeModelInitPose() const {
    CUtlVector<GSkeletonAnimCapture_t>* vec = GetSchemaValue<CUtlVector<GSkeletonAnimCapture_t>*>(m_ptr, "SkeletonAnimCapture_t", "m_FeModelInitPose"); std::vector<GSkeletonAnimCapture_t> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GSkeletonAnimCapture_t::SetFeModelInitPose(std::vector<GSkeletonAnimCapture_t> value) {
    SetSchemaValueCUtlVector<GSkeletonAnimCapture_t>(m_ptr, "SkeletonAnimCapture_t", "m_FeModelInitPose", true, value);
}
int32_t GSkeletonAnimCapture_t::GetFlexControllers() const {
    return GetSchemaValue<int32_t>(m_ptr, "SkeletonAnimCapture_t", "m_nFlexControllers");
}
void GSkeletonAnimCapture_t::SetFlexControllers(int32_t value) {
    SetSchemaValue(m_ptr, "SkeletonAnimCapture_t", "m_nFlexControllers", true, value);
}
bool GSkeletonAnimCapture_t::GetPredicted() const {
    return GetSchemaValue<bool>(m_ptr, "SkeletonAnimCapture_t", "m_bPredicted");
}
void GSkeletonAnimCapture_t::SetPredicted(bool value) {
    SetSchemaValue(m_ptr, "SkeletonAnimCapture_t", "m_bPredicted", true, value);
}
std::vector<GSkeletonAnimCapture_t> GSkeletonAnimCapture_t::GetFrames() const {
    CUtlVector<GSkeletonAnimCapture_t>* vec = GetSchemaValue<CUtlVector<GSkeletonAnimCapture_t>*>(m_ptr, "SkeletonAnimCapture_t", "m_Frames"); std::vector<GSkeletonAnimCapture_t> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GSkeletonAnimCapture_t::SetFrames(std::vector<GSkeletonAnimCapture_t> value) {
    SetSchemaValueCUtlVector<GSkeletonAnimCapture_t>(m_ptr, "SkeletonAnimCapture_t", "m_Frames", true, value);
}
std::string GSkeletonAnimCapture_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GSkeletonAnimCapture_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassSkeletonAnimCapture_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GSkeletonAnimCapture_t>("SkeletonAnimCapture_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("EntIndex", &GSkeletonAnimCapture_t::GetEntIndex, &GSkeletonAnimCapture_t::SetEntIndex)
        .addProperty("EntParent", &GSkeletonAnimCapture_t::GetEntParent, &GSkeletonAnimCapture_t::SetEntParent)
        .addProperty("ImportedCollision", &GSkeletonAnimCapture_t::GetImportedCollision, &GSkeletonAnimCapture_t::SetImportedCollision)
        .addProperty("ModelName", &GSkeletonAnimCapture_t::GetModelName, &GSkeletonAnimCapture_t::SetModelName)
        .addProperty("CaptureName", &GSkeletonAnimCapture_t::GetCaptureName, &GSkeletonAnimCapture_t::SetCaptureName)
        .addProperty("ModelBindPose", &GSkeletonAnimCapture_t::GetModelBindPose, &GSkeletonAnimCapture_t::SetModelBindPose)
        .addProperty("FeModelInitPose", &GSkeletonAnimCapture_t::GetFeModelInitPose, &GSkeletonAnimCapture_t::SetFeModelInitPose)
        .addProperty("FlexControllers", &GSkeletonAnimCapture_t::GetFlexControllers, &GSkeletonAnimCapture_t::SetFlexControllers)
        .addProperty("Predicted", &GSkeletonAnimCapture_t::GetPredicted, &GSkeletonAnimCapture_t::SetPredicted)
        .addProperty("Frames", &GSkeletonAnimCapture_t::GetFrames, &GSkeletonAnimCapture_t::SetFrames)
        .addFunction("ToPtr", &GSkeletonAnimCapture_t::ToPtr)
        .addFunction("IsValid", &GSkeletonAnimCapture_t::IsValid)
        .endClass();
}
GCStateActionUpdater::GCStateActionUpdater(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCStateActionUpdater::GCStateActionUpdater(void *ptr) {
    m_ptr = ptr;
}
uint64_t GCStateActionUpdater::GetBehavior() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CStateActionUpdater", "m_eBehavior");
}
void GCStateActionUpdater::SetBehavior(uint64_t value) {
    SetSchemaValue(m_ptr, "CStateActionUpdater", "m_eBehavior", false, value);
}
std::string GCStateActionUpdater::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCStateActionUpdater::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCStateActionUpdater(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCStateActionUpdater>("CStateActionUpdater")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Behavior", &GCStateActionUpdater::GetBehavior, &GCStateActionUpdater::SetBehavior)
        .addFunction("ToPtr", &GCStateActionUpdater::ToPtr)
        .addFunction("IsValid", &GCStateActionUpdater::IsValid)
        .endClass();
}
GCSeqS1SeqDesc::GCSeqS1SeqDesc(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCSeqS1SeqDesc::GCSeqS1SeqDesc(void *ptr) {
    m_ptr = ptr;
}
CBufferString GCSeqS1SeqDesc::GetName() const {
    return GetSchemaValue<CBufferString>(m_ptr, "CSeqS1SeqDesc", "m_sName");
}
void GCSeqS1SeqDesc::SetName(CBufferString value) {
    SetSchemaValue(m_ptr, "CSeqS1SeqDesc", "m_sName", false, value);
}
GCSeqSeqDescFlag GCSeqS1SeqDesc::GetFlags() const {
    GCSeqSeqDescFlag value(GetSchemaPtr(m_ptr, "CSeqS1SeqDesc", "m_flags"));
    return value;
}
void GCSeqS1SeqDesc::SetFlags(GCSeqSeqDescFlag value) {
    SetSchemaValue(m_ptr, "CSeqS1SeqDesc", "m_flags", false, value);
}
GCSeqMultiFetch GCSeqS1SeqDesc::GetFetch() const {
    GCSeqMultiFetch value(GetSchemaPtr(m_ptr, "CSeqS1SeqDesc", "m_fetch"));
    return value;
}
void GCSeqS1SeqDesc::SetFetch(GCSeqMultiFetch value) {
    SetSchemaValue(m_ptr, "CSeqS1SeqDesc", "m_fetch", false, value);
}
int32_t GCSeqS1SeqDesc::GetLocalWeightlist() const {
    return GetSchemaValue<int32_t>(m_ptr, "CSeqS1SeqDesc", "m_nLocalWeightlist");
}
void GCSeqS1SeqDesc::SetLocalWeightlist(int32_t value) {
    SetSchemaValue(m_ptr, "CSeqS1SeqDesc", "m_nLocalWeightlist", false, value);
}
std::vector<GCSeqAutoLayer> GCSeqS1SeqDesc::GetAutoLayerArray() const {
    CUtlVector<GCSeqAutoLayer>* vec = GetSchemaValue<CUtlVector<GCSeqAutoLayer>*>(m_ptr, "CSeqS1SeqDesc", "m_autoLayerArray"); std::vector<GCSeqAutoLayer> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCSeqS1SeqDesc::SetAutoLayerArray(std::vector<GCSeqAutoLayer> value) {
    SetSchemaValueCUtlVector<GCSeqAutoLayer>(m_ptr, "CSeqS1SeqDesc", "m_autoLayerArray", false, value);
}
std::vector<GCSeqIKLock> GCSeqS1SeqDesc::GetIKLockArray() const {
    CUtlVector<GCSeqIKLock>* vec = GetSchemaValue<CUtlVector<GCSeqIKLock>*>(m_ptr, "CSeqS1SeqDesc", "m_IKLockArray"); std::vector<GCSeqIKLock> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCSeqS1SeqDesc::SetIKLockArray(std::vector<GCSeqIKLock> value) {
    SetSchemaValueCUtlVector<GCSeqIKLock>(m_ptr, "CSeqS1SeqDesc", "m_IKLockArray", false, value);
}
GCSeqTransition GCSeqS1SeqDesc::GetTransition() const {
    GCSeqTransition value(GetSchemaPtr(m_ptr, "CSeqS1SeqDesc", "m_transition"));
    return value;
}
void GCSeqS1SeqDesc::SetTransition(GCSeqTransition value) {
    SetSchemaValue(m_ptr, "CSeqS1SeqDesc", "m_transition", false, value);
}
CBufferString GCSeqS1SeqDesc::GetLegacyKeyValueText() const {
    return GetSchemaValue<CBufferString>(m_ptr, "CSeqS1SeqDesc", "m_LegacyKeyValueText");
}
void GCSeqS1SeqDesc::SetLegacyKeyValueText(CBufferString value) {
    SetSchemaValue(m_ptr, "CSeqS1SeqDesc", "m_LegacyKeyValueText", false, value);
}
std::vector<GCAnimActivity> GCSeqS1SeqDesc::GetActivityArray() const {
    CUtlVector<GCAnimActivity>* vec = GetSchemaValue<CUtlVector<GCAnimActivity>*>(m_ptr, "CSeqS1SeqDesc", "m_activityArray"); std::vector<GCAnimActivity> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCSeqS1SeqDesc::SetActivityArray(std::vector<GCAnimActivity> value) {
    SetSchemaValueCUtlVector<GCAnimActivity>(m_ptr, "CSeqS1SeqDesc", "m_activityArray", false, value);
}
std::vector<GCFootMotion> GCSeqS1SeqDesc::GetFootMotion() const {
    CUtlVector<GCFootMotion>* vec = GetSchemaValue<CUtlVector<GCFootMotion>*>(m_ptr, "CSeqS1SeqDesc", "m_footMotion"); std::vector<GCFootMotion> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCSeqS1SeqDesc::SetFootMotion(std::vector<GCFootMotion> value) {
    SetSchemaValueCUtlVector<GCFootMotion>(m_ptr, "CSeqS1SeqDesc", "m_footMotion", false, value);
}
std::string GCSeqS1SeqDesc::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCSeqS1SeqDesc::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCSeqS1SeqDesc(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCSeqS1SeqDesc>("CSeqS1SeqDesc")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Name", &GCSeqS1SeqDesc::GetName, &GCSeqS1SeqDesc::SetName)
        .addProperty("Flags", &GCSeqS1SeqDesc::GetFlags, &GCSeqS1SeqDesc::SetFlags)
        .addProperty("Fetch", &GCSeqS1SeqDesc::GetFetch, &GCSeqS1SeqDesc::SetFetch)
        .addProperty("LocalWeightlist", &GCSeqS1SeqDesc::GetLocalWeightlist, &GCSeqS1SeqDesc::SetLocalWeightlist)
        .addProperty("AutoLayerArray", &GCSeqS1SeqDesc::GetAutoLayerArray, &GCSeqS1SeqDesc::SetAutoLayerArray)
        .addProperty("IKLockArray", &GCSeqS1SeqDesc::GetIKLockArray, &GCSeqS1SeqDesc::SetIKLockArray)
        .addProperty("Transition", &GCSeqS1SeqDesc::GetTransition, &GCSeqS1SeqDesc::SetTransition)
        .addProperty("LegacyKeyValueText", &GCSeqS1SeqDesc::GetLegacyKeyValueText, &GCSeqS1SeqDesc::SetLegacyKeyValueText)
        .addProperty("ActivityArray", &GCSeqS1SeqDesc::GetActivityArray, &GCSeqS1SeqDesc::SetActivityArray)
        .addProperty("FootMotion", &GCSeqS1SeqDesc::GetFootMotion, &GCSeqS1SeqDesc::SetFootMotion)
        .addFunction("ToPtr", &GCSeqS1SeqDesc::ToPtr)
        .addFunction("IsValid", &GCSeqS1SeqDesc::IsValid)
        .endClass();
}
GAimMatrixOpFixedSettings_t::GAimMatrixOpFixedSettings_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GAimMatrixOpFixedSettings_t::GAimMatrixOpFixedSettings_t(void *ptr) {
    m_ptr = ptr;
}
GCAnimAttachment GAimMatrixOpFixedSettings_t::GetAttachment() const {
    GCAnimAttachment value(GetSchemaPtr(m_ptr, "AimMatrixOpFixedSettings_t", "m_attachment"));
    return value;
}
void GAimMatrixOpFixedSettings_t::SetAttachment(GCAnimAttachment value) {
    SetSchemaValue(m_ptr, "AimMatrixOpFixedSettings_t", "m_attachment", true, value);
}
GCAnimInputDamping GAimMatrixOpFixedSettings_t::GetDamping() const {
    GCAnimInputDamping value(GetSchemaPtr(m_ptr, "AimMatrixOpFixedSettings_t", "m_damping"));
    return value;
}
void GAimMatrixOpFixedSettings_t::SetDamping(GCAnimInputDamping value) {
    SetSchemaValue(m_ptr, "AimMatrixOpFixedSettings_t", "m_damping", true, value);
}
std::vector<GCPoseHandle> GAimMatrixOpFixedSettings_t::GetPoseCacheHandles() const {
    GCPoseHandle* outValue = GetSchemaValue<GCPoseHandle*>(m_ptr, "AimMatrixOpFixedSettings_t", "m_poseCacheHandles"); std::vector<GCPoseHandle> ret; for(int i = 0; i < 10; i++) { ret.push_back(outValue[i]); } return ret;
}
void GAimMatrixOpFixedSettings_t::SetPoseCacheHandles(std::vector<GCPoseHandle> value) {
    GCPoseHandle* outValue = GetSchemaValue<GCPoseHandle*>(m_ptr, "AimMatrixOpFixedSettings_t", "m_poseCacheHandles"); for(int i = 0; i < 10; i++) { outValue[i] = value[i]; } SetSchemaValue(m_ptr, "AimMatrixOpFixedSettings_t", "m_poseCacheHandles", true, outValue);
}
uint64_t GAimMatrixOpFixedSettings_t::GetBlendMode() const {
    return GetSchemaValue<uint64_t>(m_ptr, "AimMatrixOpFixedSettings_t", "m_eBlendMode");
}
void GAimMatrixOpFixedSettings_t::SetBlendMode(uint64_t value) {
    SetSchemaValue(m_ptr, "AimMatrixOpFixedSettings_t", "m_eBlendMode", true, value);
}
float GAimMatrixOpFixedSettings_t::GetMaxYawAngle() const {
    return GetSchemaValue<float>(m_ptr, "AimMatrixOpFixedSettings_t", "m_flMaxYawAngle");
}
void GAimMatrixOpFixedSettings_t::SetMaxYawAngle(float value) {
    SetSchemaValue(m_ptr, "AimMatrixOpFixedSettings_t", "m_flMaxYawAngle", true, value);
}
float GAimMatrixOpFixedSettings_t::GetMaxPitchAngle() const {
    return GetSchemaValue<float>(m_ptr, "AimMatrixOpFixedSettings_t", "m_flMaxPitchAngle");
}
void GAimMatrixOpFixedSettings_t::SetMaxPitchAngle(float value) {
    SetSchemaValue(m_ptr, "AimMatrixOpFixedSettings_t", "m_flMaxPitchAngle", true, value);
}
int32_t GAimMatrixOpFixedSettings_t::GetSequenceMaxFrame() const {
    return GetSchemaValue<int32_t>(m_ptr, "AimMatrixOpFixedSettings_t", "m_nSequenceMaxFrame");
}
void GAimMatrixOpFixedSettings_t::SetSequenceMaxFrame(int32_t value) {
    SetSchemaValue(m_ptr, "AimMatrixOpFixedSettings_t", "m_nSequenceMaxFrame", true, value);
}
int32_t GAimMatrixOpFixedSettings_t::GetBoneMaskIndex() const {
    return GetSchemaValue<int32_t>(m_ptr, "AimMatrixOpFixedSettings_t", "m_nBoneMaskIndex");
}
void GAimMatrixOpFixedSettings_t::SetBoneMaskIndex(int32_t value) {
    SetSchemaValue(m_ptr, "AimMatrixOpFixedSettings_t", "m_nBoneMaskIndex", true, value);
}
bool GAimMatrixOpFixedSettings_t::GetTargetIsPosition() const {
    return GetSchemaValue<bool>(m_ptr, "AimMatrixOpFixedSettings_t", "m_bTargetIsPosition");
}
void GAimMatrixOpFixedSettings_t::SetTargetIsPosition(bool value) {
    SetSchemaValue(m_ptr, "AimMatrixOpFixedSettings_t", "m_bTargetIsPosition", true, value);
}
bool GAimMatrixOpFixedSettings_t::GetUseBiasAndClamp() const {
    return GetSchemaValue<bool>(m_ptr, "AimMatrixOpFixedSettings_t", "m_bUseBiasAndClamp");
}
void GAimMatrixOpFixedSettings_t::SetUseBiasAndClamp(bool value) {
    SetSchemaValue(m_ptr, "AimMatrixOpFixedSettings_t", "m_bUseBiasAndClamp", true, value);
}
float GAimMatrixOpFixedSettings_t::GetBiasAndClampYawOffset() const {
    return GetSchemaValue<float>(m_ptr, "AimMatrixOpFixedSettings_t", "m_flBiasAndClampYawOffset");
}
void GAimMatrixOpFixedSettings_t::SetBiasAndClampYawOffset(float value) {
    SetSchemaValue(m_ptr, "AimMatrixOpFixedSettings_t", "m_flBiasAndClampYawOffset", true, value);
}
float GAimMatrixOpFixedSettings_t::GetBiasAndClampPitchOffset() const {
    return GetSchemaValue<float>(m_ptr, "AimMatrixOpFixedSettings_t", "m_flBiasAndClampPitchOffset");
}
void GAimMatrixOpFixedSettings_t::SetBiasAndClampPitchOffset(float value) {
    SetSchemaValue(m_ptr, "AimMatrixOpFixedSettings_t", "m_flBiasAndClampPitchOffset", true, value);
}
GCBlendCurve GAimMatrixOpFixedSettings_t::GetBiasAndClampBlendCurve() const {
    GCBlendCurve value(GetSchemaPtr(m_ptr, "AimMatrixOpFixedSettings_t", "m_biasAndClampBlendCurve"));
    return value;
}
void GAimMatrixOpFixedSettings_t::SetBiasAndClampBlendCurve(GCBlendCurve value) {
    SetSchemaValue(m_ptr, "AimMatrixOpFixedSettings_t", "m_biasAndClampBlendCurve", true, value);
}
std::string GAimMatrixOpFixedSettings_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GAimMatrixOpFixedSettings_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassAimMatrixOpFixedSettings_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GAimMatrixOpFixedSettings_t>("AimMatrixOpFixedSettings_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Attachment", &GAimMatrixOpFixedSettings_t::GetAttachment, &GAimMatrixOpFixedSettings_t::SetAttachment)
        .addProperty("Damping", &GAimMatrixOpFixedSettings_t::GetDamping, &GAimMatrixOpFixedSettings_t::SetDamping)
        .addProperty("PoseCacheHandles", &GAimMatrixOpFixedSettings_t::GetPoseCacheHandles, &GAimMatrixOpFixedSettings_t::SetPoseCacheHandles)
        .addProperty("BlendMode", &GAimMatrixOpFixedSettings_t::GetBlendMode, &GAimMatrixOpFixedSettings_t::SetBlendMode)
        .addProperty("MaxYawAngle", &GAimMatrixOpFixedSettings_t::GetMaxYawAngle, &GAimMatrixOpFixedSettings_t::SetMaxYawAngle)
        .addProperty("MaxPitchAngle", &GAimMatrixOpFixedSettings_t::GetMaxPitchAngle, &GAimMatrixOpFixedSettings_t::SetMaxPitchAngle)
        .addProperty("SequenceMaxFrame", &GAimMatrixOpFixedSettings_t::GetSequenceMaxFrame, &GAimMatrixOpFixedSettings_t::SetSequenceMaxFrame)
        .addProperty("BoneMaskIndex", &GAimMatrixOpFixedSettings_t::GetBoneMaskIndex, &GAimMatrixOpFixedSettings_t::SetBoneMaskIndex)
        .addProperty("TargetIsPosition", &GAimMatrixOpFixedSettings_t::GetTargetIsPosition, &GAimMatrixOpFixedSettings_t::SetTargetIsPosition)
        .addProperty("UseBiasAndClamp", &GAimMatrixOpFixedSettings_t::GetUseBiasAndClamp, &GAimMatrixOpFixedSettings_t::SetUseBiasAndClamp)
        .addProperty("BiasAndClampYawOffset", &GAimMatrixOpFixedSettings_t::GetBiasAndClampYawOffset, &GAimMatrixOpFixedSettings_t::SetBiasAndClampYawOffset)
        .addProperty("BiasAndClampPitchOffset", &GAimMatrixOpFixedSettings_t::GetBiasAndClampPitchOffset, &GAimMatrixOpFixedSettings_t::SetBiasAndClampPitchOffset)
        .addProperty("BiasAndClampBlendCurve", &GAimMatrixOpFixedSettings_t::GetBiasAndClampBlendCurve, &GAimMatrixOpFixedSettings_t::SetBiasAndClampBlendCurve)
        .addFunction("ToPtr", &GAimMatrixOpFixedSettings_t::ToPtr)
        .addFunction("IsValid", &GAimMatrixOpFixedSettings_t::IsValid)
        .endClass();
}
GParticlePreviewState_t::GParticlePreviewState_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GParticlePreviewState_t::GParticlePreviewState_t(void *ptr) {
    m_ptr = ptr;
}
std::string GParticlePreviewState_t::GetPreviewModel() const {
    return GetSchemaValue<CUtlString>(m_ptr, "ParticlePreviewState_t", "m_previewModel").Get();
}
void GParticlePreviewState_t::SetPreviewModel(std::string value) {
    SetSchemaValue(m_ptr, "ParticlePreviewState_t", "m_previewModel", true, CUtlString(value.c_str()));
}
uint32_t GParticlePreviewState_t::GetModSpecificData() const {
    return GetSchemaValue<uint32_t>(m_ptr, "ParticlePreviewState_t", "m_nModSpecificData");
}
void GParticlePreviewState_t::SetModSpecificData(uint32_t value) {
    SetSchemaValue(m_ptr, "ParticlePreviewState_t", "m_nModSpecificData", true, value);
}
uint64_t GParticlePreviewState_t::GetGroundType() const {
    return GetSchemaValue<uint64_t>(m_ptr, "ParticlePreviewState_t", "m_groundType");
}
void GParticlePreviewState_t::SetGroundType(uint64_t value) {
    SetSchemaValue(m_ptr, "ParticlePreviewState_t", "m_groundType", true, value);
}
std::string GParticlePreviewState_t::GetSequenceName() const {
    return GetSchemaValue<CUtlString>(m_ptr, "ParticlePreviewState_t", "m_sequenceName").Get();
}
void GParticlePreviewState_t::SetSequenceName(std::string value) {
    SetSchemaValue(m_ptr, "ParticlePreviewState_t", "m_sequenceName", true, CUtlString(value.c_str()));
}
int32_t GParticlePreviewState_t::GetFireParticleOnSequenceFrame() const {
    return GetSchemaValue<int32_t>(m_ptr, "ParticlePreviewState_t", "m_nFireParticleOnSequenceFrame");
}
void GParticlePreviewState_t::SetFireParticleOnSequenceFrame(int32_t value) {
    SetSchemaValue(m_ptr, "ParticlePreviewState_t", "m_nFireParticleOnSequenceFrame", true, value);
}
std::string GParticlePreviewState_t::GetHitboxSetName() const {
    return GetSchemaValue<CUtlString>(m_ptr, "ParticlePreviewState_t", "m_hitboxSetName").Get();
}
void GParticlePreviewState_t::SetHitboxSetName(std::string value) {
    SetSchemaValue(m_ptr, "ParticlePreviewState_t", "m_hitboxSetName", true, CUtlString(value.c_str()));
}
std::string GParticlePreviewState_t::GetMaterialGroupName() const {
    return GetSchemaValue<CUtlString>(m_ptr, "ParticlePreviewState_t", "m_materialGroupName").Get();
}
void GParticlePreviewState_t::SetMaterialGroupName(std::string value) {
    SetSchemaValue(m_ptr, "ParticlePreviewState_t", "m_materialGroupName", true, CUtlString(value.c_str()));
}
std::vector<GParticlePreviewBodyGroup_t> GParticlePreviewState_t::GetBodyGroups() const {
    CUtlVector<GParticlePreviewBodyGroup_t>* vec = GetSchemaValue<CUtlVector<GParticlePreviewBodyGroup_t>*>(m_ptr, "ParticlePreviewState_t", "m_vecBodyGroups"); std::vector<GParticlePreviewBodyGroup_t> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GParticlePreviewState_t::SetBodyGroups(std::vector<GParticlePreviewBodyGroup_t> value) {
    SetSchemaValueCUtlVector<GParticlePreviewBodyGroup_t>(m_ptr, "ParticlePreviewState_t", "m_vecBodyGroups", true, value);
}
float GParticlePreviewState_t::GetPlaybackSpeed() const {
    return GetSchemaValue<float>(m_ptr, "ParticlePreviewState_t", "m_flPlaybackSpeed");
}
void GParticlePreviewState_t::SetPlaybackSpeed(float value) {
    SetSchemaValue(m_ptr, "ParticlePreviewState_t", "m_flPlaybackSpeed", true, value);
}
float GParticlePreviewState_t::GetParticleSimulationRate() const {
    return GetSchemaValue<float>(m_ptr, "ParticlePreviewState_t", "m_flParticleSimulationRate");
}
void GParticlePreviewState_t::SetParticleSimulationRate(float value) {
    SetSchemaValue(m_ptr, "ParticlePreviewState_t", "m_flParticleSimulationRate", true, value);
}
bool GParticlePreviewState_t::GetShouldDrawHitboxes() const {
    return GetSchemaValue<bool>(m_ptr, "ParticlePreviewState_t", "m_bShouldDrawHitboxes");
}
void GParticlePreviewState_t::SetShouldDrawHitboxes(bool value) {
    SetSchemaValue(m_ptr, "ParticlePreviewState_t", "m_bShouldDrawHitboxes", true, value);
}
bool GParticlePreviewState_t::GetShouldDrawAttachments() const {
    return GetSchemaValue<bool>(m_ptr, "ParticlePreviewState_t", "m_bShouldDrawAttachments");
}
void GParticlePreviewState_t::SetShouldDrawAttachments(bool value) {
    SetSchemaValue(m_ptr, "ParticlePreviewState_t", "m_bShouldDrawAttachments", true, value);
}
bool GParticlePreviewState_t::GetShouldDrawAttachmentNames() const {
    return GetSchemaValue<bool>(m_ptr, "ParticlePreviewState_t", "m_bShouldDrawAttachmentNames");
}
void GParticlePreviewState_t::SetShouldDrawAttachmentNames(bool value) {
    SetSchemaValue(m_ptr, "ParticlePreviewState_t", "m_bShouldDrawAttachmentNames", true, value);
}
bool GParticlePreviewState_t::GetShouldDrawControlPointAxes() const {
    return GetSchemaValue<bool>(m_ptr, "ParticlePreviewState_t", "m_bShouldDrawControlPointAxes");
}
void GParticlePreviewState_t::SetShouldDrawControlPointAxes(bool value) {
    SetSchemaValue(m_ptr, "ParticlePreviewState_t", "m_bShouldDrawControlPointAxes", true, value);
}
bool GParticlePreviewState_t::GetAnimationNonLooping() const {
    return GetSchemaValue<bool>(m_ptr, "ParticlePreviewState_t", "m_bAnimationNonLooping");
}
void GParticlePreviewState_t::SetAnimationNonLooping(bool value) {
    SetSchemaValue(m_ptr, "ParticlePreviewState_t", "m_bAnimationNonLooping", true, value);
}
Vector GParticlePreviewState_t::GetPreviewGravity() const {
    return GetSchemaValue<Vector>(m_ptr, "ParticlePreviewState_t", "m_vecPreviewGravity");
}
void GParticlePreviewState_t::SetPreviewGravity(Vector value) {
    SetSchemaValue(m_ptr, "ParticlePreviewState_t", "m_vecPreviewGravity", true, value);
}
std::string GParticlePreviewState_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GParticlePreviewState_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassParticlePreviewState_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GParticlePreviewState_t>("ParticlePreviewState_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("PreviewModel", &GParticlePreviewState_t::GetPreviewModel, &GParticlePreviewState_t::SetPreviewModel)
        .addProperty("ModSpecificData", &GParticlePreviewState_t::GetModSpecificData, &GParticlePreviewState_t::SetModSpecificData)
        .addProperty("GroundType", &GParticlePreviewState_t::GetGroundType, &GParticlePreviewState_t::SetGroundType)
        .addProperty("SequenceName", &GParticlePreviewState_t::GetSequenceName, &GParticlePreviewState_t::SetSequenceName)
        .addProperty("FireParticleOnSequenceFrame", &GParticlePreviewState_t::GetFireParticleOnSequenceFrame, &GParticlePreviewState_t::SetFireParticleOnSequenceFrame)
        .addProperty("HitboxSetName", &GParticlePreviewState_t::GetHitboxSetName, &GParticlePreviewState_t::SetHitboxSetName)
        .addProperty("MaterialGroupName", &GParticlePreviewState_t::GetMaterialGroupName, &GParticlePreviewState_t::SetMaterialGroupName)
        .addProperty("BodyGroups", &GParticlePreviewState_t::GetBodyGroups, &GParticlePreviewState_t::SetBodyGroups)
        .addProperty("PlaybackSpeed", &GParticlePreviewState_t::GetPlaybackSpeed, &GParticlePreviewState_t::SetPlaybackSpeed)
        .addProperty("ParticleSimulationRate", &GParticlePreviewState_t::GetParticleSimulationRate, &GParticlePreviewState_t::SetParticleSimulationRate)
        .addProperty("ShouldDrawHitboxes", &GParticlePreviewState_t::GetShouldDrawHitboxes, &GParticlePreviewState_t::SetShouldDrawHitboxes)
        .addProperty("ShouldDrawAttachments", &GParticlePreviewState_t::GetShouldDrawAttachments, &GParticlePreviewState_t::SetShouldDrawAttachments)
        .addProperty("ShouldDrawAttachmentNames", &GParticlePreviewState_t::GetShouldDrawAttachmentNames, &GParticlePreviewState_t::SetShouldDrawAttachmentNames)
        .addProperty("ShouldDrawControlPointAxes", &GParticlePreviewState_t::GetShouldDrawControlPointAxes, &GParticlePreviewState_t::SetShouldDrawControlPointAxes)
        .addProperty("AnimationNonLooping", &GParticlePreviewState_t::GetAnimationNonLooping, &GParticlePreviewState_t::SetAnimationNonLooping)
        .addProperty("PreviewGravity", &GParticlePreviewState_t::GetPreviewGravity, &GParticlePreviewState_t::SetPreviewGravity)
        .addFunction("ToPtr", &GParticlePreviewState_t::ToPtr)
        .addFunction("IsValid", &GParticlePreviewState_t::IsValid)
        .endClass();
}
GFeCtrlOsOffset_t::GFeCtrlOsOffset_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GFeCtrlOsOffset_t::GFeCtrlOsOffset_t(void *ptr) {
    m_ptr = ptr;
}
uint16_t GFeCtrlOsOffset_t::GetCtrlParent() const {
    return GetSchemaValue<uint16_t>(m_ptr, "FeCtrlOsOffset_t", "nCtrlParent");
}
void GFeCtrlOsOffset_t::SetCtrlParent(uint16_t value) {
    SetSchemaValue(m_ptr, "FeCtrlOsOffset_t", "nCtrlParent", true, value);
}
uint16_t GFeCtrlOsOffset_t::GetCtrlChild() const {
    return GetSchemaValue<uint16_t>(m_ptr, "FeCtrlOsOffset_t", "nCtrlChild");
}
void GFeCtrlOsOffset_t::SetCtrlChild(uint16_t value) {
    SetSchemaValue(m_ptr, "FeCtrlOsOffset_t", "nCtrlChild", true, value);
}
std::string GFeCtrlOsOffset_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GFeCtrlOsOffset_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassFeCtrlOsOffset_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GFeCtrlOsOffset_t>("FeCtrlOsOffset_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("CtrlParent", &GFeCtrlOsOffset_t::GetCtrlParent, &GFeCtrlOsOffset_t::SetCtrlParent)
        .addProperty("CtrlChild", &GFeCtrlOsOffset_t::GetCtrlChild, &GFeCtrlOsOffset_t::SetCtrlChild)
        .addFunction("ToPtr", &GFeCtrlOsOffset_t::ToPtr)
        .addFunction("IsValid", &GFeCtrlOsOffset_t::IsValid)
        .endClass();
}
GCMorphData::GCMorphData(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCMorphData::GCMorphData(void *ptr) {
    m_ptr = ptr;
}
std::string GCMorphData::GetName() const {
    return GetSchemaValue<CUtlString>(m_ptr, "CMorphData", "m_name").Get();
}
void GCMorphData::SetName(std::string value) {
    SetSchemaValue(m_ptr, "CMorphData", "m_name", false, CUtlString(value.c_str()));
}
std::vector<GCMorphRectData> GCMorphData::GetMorphRectDatas() const {
    CUtlVector<GCMorphRectData>* vec = GetSchemaValue<CUtlVector<GCMorphRectData>*>(m_ptr, "CMorphData", "m_morphRectDatas"); std::vector<GCMorphRectData> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCMorphData::SetMorphRectDatas(std::vector<GCMorphRectData> value) {
    SetSchemaValueCUtlVector<GCMorphRectData>(m_ptr, "CMorphData", "m_morphRectDatas", false, value);
}
std::string GCMorphData::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCMorphData::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCMorphData(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCMorphData>("CMorphData")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Name", &GCMorphData::GetName, &GCMorphData::SetName)
        .addProperty("MorphRectDatas", &GCMorphData::GetMorphRectDatas, &GCMorphData::SetMorphRectDatas)
        .addFunction("ToPtr", &GCMorphData::ToPtr)
        .addFunction("IsValid", &GCMorphData::IsValid)
        .endClass();
}
GCAimMatrixUpdateNode::GCAimMatrixUpdateNode(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCAimMatrixUpdateNode::GCAimMatrixUpdateNode(void *ptr) {
    m_ptr = ptr;
}
GAimMatrixOpFixedSettings_t GCAimMatrixUpdateNode::GetOpFixedSettings() const {
    GAimMatrixOpFixedSettings_t value(GetSchemaPtr(m_ptr, "CAimMatrixUpdateNode", "m_opFixedSettings"));
    return value;
}
void GCAimMatrixUpdateNode::SetOpFixedSettings(GAimMatrixOpFixedSettings_t value) {
    SetSchemaValue(m_ptr, "CAimMatrixUpdateNode", "m_opFixedSettings", false, value);
}
uint64_t GCAimMatrixUpdateNode::GetTarget() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CAimMatrixUpdateNode", "m_target");
}
void GCAimMatrixUpdateNode::SetTarget(uint64_t value) {
    SetSchemaValue(m_ptr, "CAimMatrixUpdateNode", "m_target", false, value);
}
GCAnimParamHandle GCAimMatrixUpdateNode::GetParamIndex() const {
    GCAnimParamHandle value(GetSchemaPtr(m_ptr, "CAimMatrixUpdateNode", "m_paramIndex"));
    return value;
}
void GCAimMatrixUpdateNode::SetParamIndex(GCAnimParamHandle value) {
    SetSchemaValue(m_ptr, "CAimMatrixUpdateNode", "m_paramIndex", false, value);
}
bool GCAimMatrixUpdateNode::GetResetChild() const {
    return GetSchemaValue<bool>(m_ptr, "CAimMatrixUpdateNode", "m_bResetChild");
}
void GCAimMatrixUpdateNode::SetResetChild(bool value) {
    SetSchemaValue(m_ptr, "CAimMatrixUpdateNode", "m_bResetChild", false, value);
}
bool GCAimMatrixUpdateNode::GetLockWhenWaning() const {
    return GetSchemaValue<bool>(m_ptr, "CAimMatrixUpdateNode", "m_bLockWhenWaning");
}
void GCAimMatrixUpdateNode::SetLockWhenWaning(bool value) {
    SetSchemaValue(m_ptr, "CAimMatrixUpdateNode", "m_bLockWhenWaning", false, value);
}
std::string GCAimMatrixUpdateNode::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCAimMatrixUpdateNode::IsValid() {
    return (m_ptr != nullptr);
}
GCUnaryUpdateNode GCAimMatrixUpdateNode::GetParent() const {
    GCUnaryUpdateNode value(m_ptr);
    return value;
}
void GCAimMatrixUpdateNode::SetParent(GCUnaryUpdateNode value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCAimMatrixUpdateNode(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCAimMatrixUpdateNode>("CAimMatrixUpdateNode")
        .addConstructor<void (*)(std::string)>()
        .addProperty("OpFixedSettings", &GCAimMatrixUpdateNode::GetOpFixedSettings, &GCAimMatrixUpdateNode::SetOpFixedSettings)
        .addProperty("Target", &GCAimMatrixUpdateNode::GetTarget, &GCAimMatrixUpdateNode::SetTarget)
        .addProperty("ParamIndex", &GCAimMatrixUpdateNode::GetParamIndex, &GCAimMatrixUpdateNode::SetParamIndex)
        .addProperty("ResetChild", &GCAimMatrixUpdateNode::GetResetChild, &GCAimMatrixUpdateNode::SetResetChild)
        .addProperty("LockWhenWaning", &GCAimMatrixUpdateNode::GetLockWhenWaning, &GCAimMatrixUpdateNode::SetLockWhenWaning)
        .addProperty("Parent", &GCAimMatrixUpdateNode::GetParent, &GCAimMatrixUpdateNode::SetParent)
        .addFunction("ToPtr", &GCAimMatrixUpdateNode::ToPtr)
        .addFunction("IsValid", &GCAimMatrixUpdateNode::IsValid)
        .endClass();
}
GCDirectionalBlendUpdateNode::GCDirectionalBlendUpdateNode(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCDirectionalBlendUpdateNode::GCDirectionalBlendUpdateNode(void *ptr) {
    m_ptr = ptr;
}
GCAnimInputDamping GCDirectionalBlendUpdateNode::GetDamping() const {
    GCAnimInputDamping value(GetSchemaPtr(m_ptr, "CDirectionalBlendUpdateNode", "m_damping"));
    return value;
}
void GCDirectionalBlendUpdateNode::SetDamping(GCAnimInputDamping value) {
    SetSchemaValue(m_ptr, "CDirectionalBlendUpdateNode", "m_damping", false, value);
}
uint64_t GCDirectionalBlendUpdateNode::GetBlendValueSource() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CDirectionalBlendUpdateNode", "m_blendValueSource");
}
void GCDirectionalBlendUpdateNode::SetBlendValueSource(uint64_t value) {
    SetSchemaValue(m_ptr, "CDirectionalBlendUpdateNode", "m_blendValueSource", false, value);
}
GCAnimParamHandle GCDirectionalBlendUpdateNode::GetParamIndex() const {
    GCAnimParamHandle value(GetSchemaPtr(m_ptr, "CDirectionalBlendUpdateNode", "m_paramIndex"));
    return value;
}
void GCDirectionalBlendUpdateNode::SetParamIndex(GCAnimParamHandle value) {
    SetSchemaValue(m_ptr, "CDirectionalBlendUpdateNode", "m_paramIndex", false, value);
}
float GCDirectionalBlendUpdateNode::GetPlaybackSpeed() const {
    return GetSchemaValue<float>(m_ptr, "CDirectionalBlendUpdateNode", "m_playbackSpeed");
}
void GCDirectionalBlendUpdateNode::SetPlaybackSpeed(float value) {
    SetSchemaValue(m_ptr, "CDirectionalBlendUpdateNode", "m_playbackSpeed", false, value);
}
float GCDirectionalBlendUpdateNode::GetDuration() const {
    return GetSchemaValue<float>(m_ptr, "CDirectionalBlendUpdateNode", "m_duration");
}
void GCDirectionalBlendUpdateNode::SetDuration(float value) {
    SetSchemaValue(m_ptr, "CDirectionalBlendUpdateNode", "m_duration", false, value);
}
bool GCDirectionalBlendUpdateNode::GetLoop() const {
    return GetSchemaValue<bool>(m_ptr, "CDirectionalBlendUpdateNode", "m_bLoop");
}
void GCDirectionalBlendUpdateNode::SetLoop(bool value) {
    SetSchemaValue(m_ptr, "CDirectionalBlendUpdateNode", "m_bLoop", false, value);
}
bool GCDirectionalBlendUpdateNode::GetLockBlendOnReset() const {
    return GetSchemaValue<bool>(m_ptr, "CDirectionalBlendUpdateNode", "m_bLockBlendOnReset");
}
void GCDirectionalBlendUpdateNode::SetLockBlendOnReset(bool value) {
    SetSchemaValue(m_ptr, "CDirectionalBlendUpdateNode", "m_bLockBlendOnReset", false, value);
}
std::string GCDirectionalBlendUpdateNode::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCDirectionalBlendUpdateNode::IsValid() {
    return (m_ptr != nullptr);
}
GCLeafUpdateNode GCDirectionalBlendUpdateNode::GetParent() const {
    GCLeafUpdateNode value(m_ptr);
    return value;
}
void GCDirectionalBlendUpdateNode::SetParent(GCLeafUpdateNode value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCDirectionalBlendUpdateNode(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCDirectionalBlendUpdateNode>("CDirectionalBlendUpdateNode")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Damping", &GCDirectionalBlendUpdateNode::GetDamping, &GCDirectionalBlendUpdateNode::SetDamping)
        .addProperty("BlendValueSource", &GCDirectionalBlendUpdateNode::GetBlendValueSource, &GCDirectionalBlendUpdateNode::SetBlendValueSource)
        .addProperty("ParamIndex", &GCDirectionalBlendUpdateNode::GetParamIndex, &GCDirectionalBlendUpdateNode::SetParamIndex)
        .addProperty("PlaybackSpeed", &GCDirectionalBlendUpdateNode::GetPlaybackSpeed, &GCDirectionalBlendUpdateNode::SetPlaybackSpeed)
        .addProperty("Duration", &GCDirectionalBlendUpdateNode::GetDuration, &GCDirectionalBlendUpdateNode::SetDuration)
        .addProperty("Loop", &GCDirectionalBlendUpdateNode::GetLoop, &GCDirectionalBlendUpdateNode::SetLoop)
        .addProperty("LockBlendOnReset", &GCDirectionalBlendUpdateNode::GetLockBlendOnReset, &GCDirectionalBlendUpdateNode::SetLockBlendOnReset)
        .addProperty("Parent", &GCDirectionalBlendUpdateNode::GetParent, &GCDirectionalBlendUpdateNode::SetParent)
        .addFunction("ToPtr", &GCDirectionalBlendUpdateNode::ToPtr)
        .addFunction("IsValid", &GCDirectionalBlendUpdateNode::IsValid)
        .endClass();
}
GVMixPannerDesc_t::GVMixPannerDesc_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GVMixPannerDesc_t::GVMixPannerDesc_t(void *ptr) {
    m_ptr = ptr;
}
uint64_t GVMixPannerDesc_t::GetType() const {
    return GetSchemaValue<uint64_t>(m_ptr, "VMixPannerDesc_t", "m_type");
}
void GVMixPannerDesc_t::SetType(uint64_t value) {
    SetSchemaValue(m_ptr, "VMixPannerDesc_t", "m_type", true, value);
}
float GVMixPannerDesc_t::GetStrength() const {
    return GetSchemaValue<float>(m_ptr, "VMixPannerDesc_t", "m_flStrength");
}
void GVMixPannerDesc_t::SetStrength(float value) {
    SetSchemaValue(m_ptr, "VMixPannerDesc_t", "m_flStrength", true, value);
}
std::string GVMixPannerDesc_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GVMixPannerDesc_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassVMixPannerDesc_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GVMixPannerDesc_t>("VMixPannerDesc_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Type", &GVMixPannerDesc_t::GetType, &GVMixPannerDesc_t::SetType)
        .addProperty("Strength", &GVMixPannerDesc_t::GetStrength, &GVMixPannerDesc_t::SetStrength)
        .addFunction("ToPtr", &GVMixPannerDesc_t::ToPtr)
        .addFunction("IsValid", &GVMixPannerDesc_t::IsValid)
        .endClass();
}
GFeSimdSpringIntegrator_t::GFeSimdSpringIntegrator_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GFeSimdSpringIntegrator_t::GFeSimdSpringIntegrator_t(void *ptr) {
    m_ptr = ptr;
}
float GFeSimdSpringIntegrator_t::GetSpringRestLength() const {
    return GetSchemaValue<float>(m_ptr, "FeSimdSpringIntegrator_t", "flSpringRestLength");
}
void GFeSimdSpringIntegrator_t::SetSpringRestLength(float value) {
    SetSchemaValue(m_ptr, "FeSimdSpringIntegrator_t", "flSpringRestLength", true, value);
}
float GFeSimdSpringIntegrator_t::GetSpringConstant() const {
    return GetSchemaValue<float>(m_ptr, "FeSimdSpringIntegrator_t", "flSpringConstant");
}
void GFeSimdSpringIntegrator_t::SetSpringConstant(float value) {
    SetSchemaValue(m_ptr, "FeSimdSpringIntegrator_t", "flSpringConstant", true, value);
}
float GFeSimdSpringIntegrator_t::GetSpringDamping() const {
    return GetSchemaValue<float>(m_ptr, "FeSimdSpringIntegrator_t", "flSpringDamping");
}
void GFeSimdSpringIntegrator_t::SetSpringDamping(float value) {
    SetSchemaValue(m_ptr, "FeSimdSpringIntegrator_t", "flSpringDamping", true, value);
}
float GFeSimdSpringIntegrator_t::GetNodeWeight0() const {
    return GetSchemaValue<float>(m_ptr, "FeSimdSpringIntegrator_t", "flNodeWeight0");
}
void GFeSimdSpringIntegrator_t::SetNodeWeight0(float value) {
    SetSchemaValue(m_ptr, "FeSimdSpringIntegrator_t", "flNodeWeight0", true, value);
}
std::string GFeSimdSpringIntegrator_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GFeSimdSpringIntegrator_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassFeSimdSpringIntegrator_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GFeSimdSpringIntegrator_t>("FeSimdSpringIntegrator_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("SpringRestLength", &GFeSimdSpringIntegrator_t::GetSpringRestLength, &GFeSimdSpringIntegrator_t::SetSpringRestLength)
        .addProperty("SpringConstant", &GFeSimdSpringIntegrator_t::GetSpringConstant, &GFeSimdSpringIntegrator_t::SetSpringConstant)
        .addProperty("SpringDamping", &GFeSimdSpringIntegrator_t::GetSpringDamping, &GFeSimdSpringIntegrator_t::SetSpringDamping)
        .addProperty("NodeWeight0", &GFeSimdSpringIntegrator_t::GetNodeWeight0, &GFeSimdSpringIntegrator_t::SetNodeWeight0)
        .addFunction("ToPtr", &GFeSimdSpringIntegrator_t::ToPtr)
        .addFunction("IsValid", &GFeSimdSpringIntegrator_t::IsValid)
        .endClass();
}
GModelBoneFlexDriver_t::GModelBoneFlexDriver_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GModelBoneFlexDriver_t::GModelBoneFlexDriver_t(void *ptr) {
    m_ptr = ptr;
}
std::string GModelBoneFlexDriver_t::GetBoneName() const {
    return GetSchemaValue<CUtlString>(m_ptr, "ModelBoneFlexDriver_t", "m_boneName").Get();
}
void GModelBoneFlexDriver_t::SetBoneName(std::string value) {
    SetSchemaValue(m_ptr, "ModelBoneFlexDriver_t", "m_boneName", true, CUtlString(value.c_str()));
}
uint32_t GModelBoneFlexDriver_t::GetBoneNameToken() const {
    return GetSchemaValue<uint32_t>(m_ptr, "ModelBoneFlexDriver_t", "m_boneNameToken");
}
void GModelBoneFlexDriver_t::SetBoneNameToken(uint32_t value) {
    SetSchemaValue(m_ptr, "ModelBoneFlexDriver_t", "m_boneNameToken", true, value);
}
std::vector<GModelBoneFlexDriverControl_t> GModelBoneFlexDriver_t::GetControls() const {
    CUtlVector<GModelBoneFlexDriverControl_t>* vec = GetSchemaValue<CUtlVector<GModelBoneFlexDriverControl_t>*>(m_ptr, "ModelBoneFlexDriver_t", "m_controls"); std::vector<GModelBoneFlexDriverControl_t> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GModelBoneFlexDriver_t::SetControls(std::vector<GModelBoneFlexDriverControl_t> value) {
    SetSchemaValueCUtlVector<GModelBoneFlexDriverControl_t>(m_ptr, "ModelBoneFlexDriver_t", "m_controls", true, value);
}
std::string GModelBoneFlexDriver_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GModelBoneFlexDriver_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassModelBoneFlexDriver_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GModelBoneFlexDriver_t>("ModelBoneFlexDriver_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("BoneName", &GModelBoneFlexDriver_t::GetBoneName, &GModelBoneFlexDriver_t::SetBoneName)
        .addProperty("BoneNameToken", &GModelBoneFlexDriver_t::GetBoneNameToken, &GModelBoneFlexDriver_t::SetBoneNameToken)
        .addProperty("Controls", &GModelBoneFlexDriver_t::GetControls, &GModelBoneFlexDriver_t::SetControls)
        .addFunction("ToPtr", &GModelBoneFlexDriver_t::ToPtr)
        .addFunction("IsValid", &GModelBoneFlexDriver_t::IsValid)
        .endClass();
}
GCBoolAnimParameter::GCBoolAnimParameter(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCBoolAnimParameter::GCBoolAnimParameter(void *ptr) {
    m_ptr = ptr;
}
bool GCBoolAnimParameter::GetDefaultValue() const {
    return GetSchemaValue<bool>(m_ptr, "CBoolAnimParameter", "m_bDefaultValue");
}
void GCBoolAnimParameter::SetDefaultValue(bool value) {
    SetSchemaValue(m_ptr, "CBoolAnimParameter", "m_bDefaultValue", false, value);
}
std::string GCBoolAnimParameter::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCBoolAnimParameter::IsValid() {
    return (m_ptr != nullptr);
}
GCConcreteAnimParameter GCBoolAnimParameter::GetParent() const {
    GCConcreteAnimParameter value(m_ptr);
    return value;
}
void GCBoolAnimParameter::SetParent(GCConcreteAnimParameter value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCBoolAnimParameter(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCBoolAnimParameter>("CBoolAnimParameter")
        .addConstructor<void (*)(std::string)>()
        .addProperty("DefaultValue", &GCBoolAnimParameter::GetDefaultValue, &GCBoolAnimParameter::SetDefaultValue)
        .addProperty("Parent", &GCBoolAnimParameter::GetParent, &GCBoolAnimParameter::SetParent)
        .addFunction("ToPtr", &GCBoolAnimParameter::ToPtr)
        .addFunction("IsValid", &GCBoolAnimParameter::IsValid)
        .endClass();
}
GEventAppShutdown_t::GEventAppShutdown_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GEventAppShutdown_t::GEventAppShutdown_t(void *ptr) {
    m_ptr = ptr;
}
int32_t GEventAppShutdown_t::GetDummy0() const {
    return GetSchemaValue<int32_t>(m_ptr, "EventAppShutdown_t", "m_nDummy0");
}
void GEventAppShutdown_t::SetDummy0(int32_t value) {
    SetSchemaValue(m_ptr, "EventAppShutdown_t", "m_nDummy0", true, value);
}
std::string GEventAppShutdown_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GEventAppShutdown_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassEventAppShutdown_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GEventAppShutdown_t>("EventAppShutdown_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Dummy0", &GEventAppShutdown_t::GetDummy0, &GEventAppShutdown_t::SetDummy0)
        .addFunction("ToPtr", &GEventAppShutdown_t::ToPtr)
        .addFunction("IsValid", &GEventAppShutdown_t::IsValid)
        .endClass();
}
GResourceId_t::GResourceId_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GResourceId_t::GResourceId_t(void *ptr) {
    m_ptr = ptr;
}
uint64_t GResourceId_t::GetValue() const {
    return GetSchemaValue<uint64_t>(m_ptr, "ResourceId_t", "m_Value");
}
void GResourceId_t::SetValue(uint64_t value) {
    SetSchemaValue(m_ptr, "ResourceId_t", "m_Value", true, value);
}
std::string GResourceId_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GResourceId_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassResourceId_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GResourceId_t>("ResourceId_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Value", &GResourceId_t::GetValue, &GResourceId_t::SetValue)
        .addFunction("ToPtr", &GResourceId_t::ToPtr)
        .addFunction("IsValid", &GResourceId_t::IsValid)
        .endClass();
}
GCVoiceContainerRealtimeFMSineWave::GCVoiceContainerRealtimeFMSineWave(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCVoiceContainerRealtimeFMSineWave::GCVoiceContainerRealtimeFMSineWave(void *ptr) {
    m_ptr = ptr;
}
float GCVoiceContainerRealtimeFMSineWave::GetCarrierFrequency() const {
    return GetSchemaValue<float>(m_ptr, "CVoiceContainerRealtimeFMSineWave", "m_flCarrierFrequency");
}
void GCVoiceContainerRealtimeFMSineWave::SetCarrierFrequency(float value) {
    SetSchemaValue(m_ptr, "CVoiceContainerRealtimeFMSineWave", "m_flCarrierFrequency", false, value);
}
float GCVoiceContainerRealtimeFMSineWave::GetModulatorFrequency() const {
    return GetSchemaValue<float>(m_ptr, "CVoiceContainerRealtimeFMSineWave", "m_flModulatorFrequency");
}
void GCVoiceContainerRealtimeFMSineWave::SetModulatorFrequency(float value) {
    SetSchemaValue(m_ptr, "CVoiceContainerRealtimeFMSineWave", "m_flModulatorFrequency", false, value);
}
float GCVoiceContainerRealtimeFMSineWave::GetModulatorAmount() const {
    return GetSchemaValue<float>(m_ptr, "CVoiceContainerRealtimeFMSineWave", "m_flModulatorAmount");
}
void GCVoiceContainerRealtimeFMSineWave::SetModulatorAmount(float value) {
    SetSchemaValue(m_ptr, "CVoiceContainerRealtimeFMSineWave", "m_flModulatorAmount", false, value);
}
std::string GCVoiceContainerRealtimeFMSineWave::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCVoiceContainerRealtimeFMSineWave::IsValid() {
    return (m_ptr != nullptr);
}
GCVoiceContainerBase GCVoiceContainerRealtimeFMSineWave::GetParent() const {
    GCVoiceContainerBase value(m_ptr);
    return value;
}
void GCVoiceContainerRealtimeFMSineWave::SetParent(GCVoiceContainerBase value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCVoiceContainerRealtimeFMSineWave(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCVoiceContainerRealtimeFMSineWave>("CVoiceContainerRealtimeFMSineWave")
        .addConstructor<void (*)(std::string)>()
        .addProperty("CarrierFrequency", &GCVoiceContainerRealtimeFMSineWave::GetCarrierFrequency, &GCVoiceContainerRealtimeFMSineWave::SetCarrierFrequency)
        .addProperty("ModulatorFrequency", &GCVoiceContainerRealtimeFMSineWave::GetModulatorFrequency, &GCVoiceContainerRealtimeFMSineWave::SetModulatorFrequency)
        .addProperty("ModulatorAmount", &GCVoiceContainerRealtimeFMSineWave::GetModulatorAmount, &GCVoiceContainerRealtimeFMSineWave::SetModulatorAmount)
        .addProperty("Parent", &GCVoiceContainerRealtimeFMSineWave::GetParent, &GCVoiceContainerRealtimeFMSineWave::SetParent)
        .addFunction("ToPtr", &GCVoiceContainerRealtimeFMSineWave::ToPtr)
        .addFunction("IsValid", &GCVoiceContainerRealtimeFMSineWave::IsValid)
        .endClass();
}
GCNmVirtualParameterBoolNode::GCNmVirtualParameterBoolNode(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCNmVirtualParameterBoolNode::GCNmVirtualParameterBoolNode(void *ptr) {
    m_ptr = ptr;
}
int16_t GCNmVirtualParameterBoolNode::GetChildNodeIdx() const {
    return GetSchemaValue<int16_t>(m_ptr, "CNmVirtualParameterBoolNode", "m_nChildNodeIdx");
}
void GCNmVirtualParameterBoolNode::SetChildNodeIdx(int16_t value) {
    SetSchemaValue(m_ptr, "CNmVirtualParameterBoolNode", "m_nChildNodeIdx", false, value);
}
std::string GCNmVirtualParameterBoolNode::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCNmVirtualParameterBoolNode::IsValid() {
    return (m_ptr != nullptr);
}
GCNmBoolValueNode GCNmVirtualParameterBoolNode::GetParent() const {
    GCNmBoolValueNode value(m_ptr);
    return value;
}
void GCNmVirtualParameterBoolNode::SetParent(GCNmBoolValueNode value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCNmVirtualParameterBoolNode(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCNmVirtualParameterBoolNode>("CNmVirtualParameterBoolNode")
        .addConstructor<void (*)(std::string)>()
        .addProperty("ChildNodeIdx", &GCNmVirtualParameterBoolNode::GetChildNodeIdx, &GCNmVirtualParameterBoolNode::SetChildNodeIdx)
        .addProperty("Parent", &GCNmVirtualParameterBoolNode::GetParent, &GCNmVirtualParameterBoolNode::SetParent)
        .addFunction("ToPtr", &GCNmVirtualParameterBoolNode::ToPtr)
        .addFunction("IsValid", &GCNmVirtualParameterBoolNode::IsValid)
        .endClass();
}
GCNmSyncTrack::GCNmSyncTrack(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCNmSyncTrack::GCNmSyncTrack(void *ptr) {
    m_ptr = ptr;
}
int32_t GCNmSyncTrack::GetStartEventOffset() const {
    return GetSchemaValue<int32_t>(m_ptr, "CNmSyncTrack", "m_nStartEventOffset");
}
void GCNmSyncTrack::SetStartEventOffset(int32_t value) {
    SetSchemaValue(m_ptr, "CNmSyncTrack", "m_nStartEventOffset", false, value);
}
std::string GCNmSyncTrack::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCNmSyncTrack::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCNmSyncTrack(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCNmSyncTrack>("CNmSyncTrack")
        .addConstructor<void (*)(std::string)>()
        .addProperty("StartEventOffset", &GCNmSyncTrack::GetStartEventOffset, &GCNmSyncTrack::SetStartEventOffset)
        .addFunction("ToPtr", &GCNmSyncTrack::ToPtr)
        .addFunction("IsValid", &GCNmSyncTrack::IsValid)
        .endClass();
}
GTagSpan_t::GTagSpan_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GTagSpan_t::GTagSpan_t(void *ptr) {
    m_ptr = ptr;
}
int32_t GTagSpan_t::GetTagIndex() const {
    return GetSchemaValue<int32_t>(m_ptr, "TagSpan_t", "m_tagIndex");
}
void GTagSpan_t::SetTagIndex(int32_t value) {
    SetSchemaValue(m_ptr, "TagSpan_t", "m_tagIndex", true, value);
}
float GTagSpan_t::GetStartCycle() const {
    return GetSchemaValue<float>(m_ptr, "TagSpan_t", "m_startCycle");
}
void GTagSpan_t::SetStartCycle(float value) {
    SetSchemaValue(m_ptr, "TagSpan_t", "m_startCycle", true, value);
}
float GTagSpan_t::GetEndCycle() const {
    return GetSchemaValue<float>(m_ptr, "TagSpan_t", "m_endCycle");
}
void GTagSpan_t::SetEndCycle(float value) {
    SetSchemaValue(m_ptr, "TagSpan_t", "m_endCycle", true, value);
}
std::string GTagSpan_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GTagSpan_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassTagSpan_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GTagSpan_t>("TagSpan_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("TagIndex", &GTagSpan_t::GetTagIndex, &GTagSpan_t::SetTagIndex)
        .addProperty("StartCycle", &GTagSpan_t::GetStartCycle, &GTagSpan_t::SetStartCycle)
        .addProperty("EndCycle", &GTagSpan_t::GetEndCycle, &GTagSpan_t::SetEndCycle)
        .addFunction("ToPtr", &GTagSpan_t::ToPtr)
        .addFunction("IsValid", &GTagSpan_t::IsValid)
        .endClass();
}
GCNmStateNode__TimedEvent_t::GCNmStateNode__TimedEvent_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCNmStateNode__TimedEvent_t::GCNmStateNode__TimedEvent_t(void *ptr) {
    m_ptr = ptr;
}
float GCNmStateNode__TimedEvent_t::GetTimeValue() const {
    return GetSchemaValue<float>(m_ptr, "CNmStateNode__TimedEvent_t", "m_timeValue");
}
void GCNmStateNode__TimedEvent_t::SetTimeValue(float value) {
    SetSchemaValue(m_ptr, "CNmStateNode__TimedEvent_t", "m_timeValue", true, value);
}
std::string GCNmStateNode__TimedEvent_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCNmStateNode__TimedEvent_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCNmStateNode__TimedEvent_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCNmStateNode__TimedEvent_t>("CNmStateNode__TimedEvent_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("TimeValue", &GCNmStateNode__TimedEvent_t::GetTimeValue, &GCNmStateNode__TimedEvent_t::SetTimeValue)
        .addFunction("ToPtr", &GCNmStateNode__TimedEvent_t::ToPtr)
        .addFunction("IsValid", &GCNmStateNode__TimedEvent_t::IsValid)
        .endClass();
}
GCNmControlParameterTargetNode::GCNmControlParameterTargetNode(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCNmControlParameterTargetNode::GCNmControlParameterTargetNode(void *ptr) {
    m_ptr = ptr;
}
std::string GCNmControlParameterTargetNode::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCNmControlParameterTargetNode::IsValid() {
    return (m_ptr != nullptr);
}
GCNmTargetValueNode GCNmControlParameterTargetNode::GetParent() const {
    GCNmTargetValueNode value(m_ptr);
    return value;
}
void GCNmControlParameterTargetNode::SetParent(GCNmTargetValueNode value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCNmControlParameterTargetNode(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCNmControlParameterTargetNode>("CNmControlParameterTargetNode")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCNmControlParameterTargetNode::GetParent, &GCNmControlParameterTargetNode::SetParent)
        .addFunction("ToPtr", &GCNmControlParameterTargetNode::ToPtr)
        .addFunction("IsValid", &GCNmControlParameterTargetNode::IsValid)
        .endClass();
}
GCFootstepLandedAnimTag::GCFootstepLandedAnimTag(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCFootstepLandedAnimTag::GCFootstepLandedAnimTag(void *ptr) {
    m_ptr = ptr;
}
uint64_t GCFootstepLandedAnimTag::GetFootstepType() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CFootstepLandedAnimTag", "m_FootstepType");
}
void GCFootstepLandedAnimTag::SetFootstepType(uint64_t value) {
    SetSchemaValue(m_ptr, "CFootstepLandedAnimTag", "m_FootstepType", false, value);
}
std::string GCFootstepLandedAnimTag::GetOverrideSoundName() const {
    return GetSchemaValue<CUtlString>(m_ptr, "CFootstepLandedAnimTag", "m_OverrideSoundName").Get();
}
void GCFootstepLandedAnimTag::SetOverrideSoundName(std::string value) {
    SetSchemaValue(m_ptr, "CFootstepLandedAnimTag", "m_OverrideSoundName", false, CUtlString(value.c_str()));
}
std::string GCFootstepLandedAnimTag::GetDebugAnimSourceString() const {
    return GetSchemaValue<CUtlString>(m_ptr, "CFootstepLandedAnimTag", "m_DebugAnimSourceString").Get();
}
void GCFootstepLandedAnimTag::SetDebugAnimSourceString(std::string value) {
    SetSchemaValue(m_ptr, "CFootstepLandedAnimTag", "m_DebugAnimSourceString", false, CUtlString(value.c_str()));
}
std::string GCFootstepLandedAnimTag::GetBoneName() const {
    return GetSchemaValue<CUtlString>(m_ptr, "CFootstepLandedAnimTag", "m_BoneName").Get();
}
void GCFootstepLandedAnimTag::SetBoneName(std::string value) {
    SetSchemaValue(m_ptr, "CFootstepLandedAnimTag", "m_BoneName", false, CUtlString(value.c_str()));
}
std::string GCFootstepLandedAnimTag::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCFootstepLandedAnimTag::IsValid() {
    return (m_ptr != nullptr);
}
GCAnimTagBase GCFootstepLandedAnimTag::GetParent() const {
    GCAnimTagBase value(m_ptr);
    return value;
}
void GCFootstepLandedAnimTag::SetParent(GCAnimTagBase value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCFootstepLandedAnimTag(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCFootstepLandedAnimTag>("CFootstepLandedAnimTag")
        .addConstructor<void (*)(std::string)>()
        .addProperty("FootstepType", &GCFootstepLandedAnimTag::GetFootstepType, &GCFootstepLandedAnimTag::SetFootstepType)
        .addProperty("OverrideSoundName", &GCFootstepLandedAnimTag::GetOverrideSoundName, &GCFootstepLandedAnimTag::SetOverrideSoundName)
        .addProperty("DebugAnimSourceString", &GCFootstepLandedAnimTag::GetDebugAnimSourceString, &GCFootstepLandedAnimTag::SetDebugAnimSourceString)
        .addProperty("BoneName", &GCFootstepLandedAnimTag::GetBoneName, &GCFootstepLandedAnimTag::SetBoneName)
        .addProperty("Parent", &GCFootstepLandedAnimTag::GetParent, &GCFootstepLandedAnimTag::SetParent)
        .addFunction("ToPtr", &GCFootstepLandedAnimTag::ToPtr)
        .addFunction("IsValid", &GCFootstepLandedAnimTag::IsValid)
        .endClass();
}
GCEnumAnimParameter::GCEnumAnimParameter(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCEnumAnimParameter::GCEnumAnimParameter(void *ptr) {
    m_ptr = ptr;
}
uint8_t GCEnumAnimParameter::GetDefaultValue() const {
    return GetSchemaValue<uint8_t>(m_ptr, "CEnumAnimParameter", "m_defaultValue");
}
void GCEnumAnimParameter::SetDefaultValue(uint8_t value) {
    SetSchemaValue(m_ptr, "CEnumAnimParameter", "m_defaultValue", false, value);
}
std::vector<CUtlString> GCEnumAnimParameter::GetEnumOptions() const {
    CUtlVector<CUtlString>* vec = GetSchemaValue<CUtlVector<CUtlString>*>(m_ptr, "CEnumAnimParameter", "m_enumOptions"); std::vector<CUtlString> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCEnumAnimParameter::SetEnumOptions(std::vector<CUtlString> value) {
    SetSchemaValueCUtlVector<CUtlString>(m_ptr, "CEnumAnimParameter", "m_enumOptions", false, value);
}
std::vector<uint64> GCEnumAnimParameter::GetEnumReferenced() const {
    CUtlVector<uint64>* vec = GetSchemaValue<CUtlVector<uint64>*>(m_ptr, "CEnumAnimParameter", "m_vecEnumReferenced"); std::vector<uint64> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCEnumAnimParameter::SetEnumReferenced(std::vector<uint64> value) {
    SetSchemaValueCUtlVector<uint64>(m_ptr, "CEnumAnimParameter", "m_vecEnumReferenced", false, value);
}
std::string GCEnumAnimParameter::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCEnumAnimParameter::IsValid() {
    return (m_ptr != nullptr);
}
GCConcreteAnimParameter GCEnumAnimParameter::GetParent() const {
    GCConcreteAnimParameter value(m_ptr);
    return value;
}
void GCEnumAnimParameter::SetParent(GCConcreteAnimParameter value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCEnumAnimParameter(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCEnumAnimParameter>("CEnumAnimParameter")
        .addConstructor<void (*)(std::string)>()
        .addProperty("DefaultValue", &GCEnumAnimParameter::GetDefaultValue, &GCEnumAnimParameter::SetDefaultValue)
        .addProperty("EnumOptions", &GCEnumAnimParameter::GetEnumOptions, &GCEnumAnimParameter::SetEnumOptions)
        .addProperty("EnumReferenced", &GCEnumAnimParameter::GetEnumReferenced, &GCEnumAnimParameter::SetEnumReferenced)
        .addProperty("Parent", &GCEnumAnimParameter::GetParent, &GCEnumAnimParameter::SetParent)
        .addFunction("ToPtr", &GCEnumAnimParameter::ToPtr)
        .addFunction("IsValid", &GCEnumAnimParameter::IsValid)
        .endClass();
}
GCAnimationGraphVisualizerPie::GCAnimationGraphVisualizerPie(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCAnimationGraphVisualizerPie::GCAnimationGraphVisualizerPie(void *ptr) {
    m_ptr = ptr;
}
Vector GCAnimationGraphVisualizerPie::GetWsCenter() const {
    return GetSchemaValue<Vector>(m_ptr, "CAnimationGraphVisualizerPie", "m_vWsCenter");
}
void GCAnimationGraphVisualizerPie::SetWsCenter(Vector value) {
    SetSchemaValue(m_ptr, "CAnimationGraphVisualizerPie", "m_vWsCenter", false, value);
}
Vector GCAnimationGraphVisualizerPie::GetWsStart() const {
    return GetSchemaValue<Vector>(m_ptr, "CAnimationGraphVisualizerPie", "m_vWsStart");
}
void GCAnimationGraphVisualizerPie::SetWsStart(Vector value) {
    SetSchemaValue(m_ptr, "CAnimationGraphVisualizerPie", "m_vWsStart", false, value);
}
Vector GCAnimationGraphVisualizerPie::GetWsEnd() const {
    return GetSchemaValue<Vector>(m_ptr, "CAnimationGraphVisualizerPie", "m_vWsEnd");
}
void GCAnimationGraphVisualizerPie::SetWsEnd(Vector value) {
    SetSchemaValue(m_ptr, "CAnimationGraphVisualizerPie", "m_vWsEnd", false, value);
}
Color GCAnimationGraphVisualizerPie::GetColor() const {
    return GetSchemaValue<Color>(m_ptr, "CAnimationGraphVisualizerPie", "m_Color");
}
void GCAnimationGraphVisualizerPie::SetColor(Color value) {
    SetSchemaValue(m_ptr, "CAnimationGraphVisualizerPie", "m_Color", false, value);
}
std::string GCAnimationGraphVisualizerPie::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCAnimationGraphVisualizerPie::IsValid() {
    return (m_ptr != nullptr);
}
GCAnimationGraphVisualizerPrimitiveBase GCAnimationGraphVisualizerPie::GetParent() const {
    GCAnimationGraphVisualizerPrimitiveBase value(m_ptr);
    return value;
}
void GCAnimationGraphVisualizerPie::SetParent(GCAnimationGraphVisualizerPrimitiveBase value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCAnimationGraphVisualizerPie(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCAnimationGraphVisualizerPie>("CAnimationGraphVisualizerPie")
        .addConstructor<void (*)(std::string)>()
        .addProperty("WsCenter", &GCAnimationGraphVisualizerPie::GetWsCenter, &GCAnimationGraphVisualizerPie::SetWsCenter)
        .addProperty("WsStart", &GCAnimationGraphVisualizerPie::GetWsStart, &GCAnimationGraphVisualizerPie::SetWsStart)
        .addProperty("WsEnd", &GCAnimationGraphVisualizerPie::GetWsEnd, &GCAnimationGraphVisualizerPie::SetWsEnd)
        .addProperty("Color", &GCAnimationGraphVisualizerPie::GetColor, &GCAnimationGraphVisualizerPie::SetColor)
        .addProperty("Parent", &GCAnimationGraphVisualizerPie::GetParent, &GCAnimationGraphVisualizerPie::SetParent)
        .addFunction("ToPtr", &GCAnimationGraphVisualizerPie::ToPtr)
        .addFunction("IsValid", &GCAnimationGraphVisualizerPie::IsValid)
        .endClass();
}
GAnimationSnapshot_t::GAnimationSnapshot_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GAnimationSnapshot_t::GAnimationSnapshot_t(void *ptr) {
    m_ptr = ptr;
}
int32_t GAnimationSnapshot_t::GetEntIndex() const {
    return GetSchemaValue<int32_t>(m_ptr, "AnimationSnapshot_t", "m_nEntIndex");
}
void GAnimationSnapshot_t::SetEntIndex(int32_t value) {
    SetSchemaValue(m_ptr, "AnimationSnapshot_t", "m_nEntIndex", true, value);
}
std::string GAnimationSnapshot_t::GetModelName() const {
    return GetSchemaValue<CUtlString>(m_ptr, "AnimationSnapshot_t", "m_modelName").Get();
}
void GAnimationSnapshot_t::SetModelName(std::string value) {
    SetSchemaValue(m_ptr, "AnimationSnapshot_t", "m_modelName", true, CUtlString(value.c_str()));
}
std::string GAnimationSnapshot_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GAnimationSnapshot_t::IsValid() {
    return (m_ptr != nullptr);
}
GAnimationSnapshotBase_t GAnimationSnapshot_t::GetParent() const {
    GAnimationSnapshotBase_t value(m_ptr);
    return value;
}
void GAnimationSnapshot_t::SetParent(GAnimationSnapshotBase_t value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassAnimationSnapshot_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GAnimationSnapshot_t>("AnimationSnapshot_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("EntIndex", &GAnimationSnapshot_t::GetEntIndex, &GAnimationSnapshot_t::SetEntIndex)
        .addProperty("ModelName", &GAnimationSnapshot_t::GetModelName, &GAnimationSnapshot_t::SetModelName)
        .addProperty("Parent", &GAnimationSnapshot_t::GetParent, &GAnimationSnapshot_t::SetParent)
        .addFunction("ToPtr", &GAnimationSnapshot_t::ToPtr)
        .addFunction("IsValid", &GAnimationSnapshot_t::IsValid)
        .endClass();
}
GVPhysXCollisionAttributes_t::GVPhysXCollisionAttributes_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GVPhysXCollisionAttributes_t::GVPhysXCollisionAttributes_t(void *ptr) {
    m_ptr = ptr;
}
uint32_t GVPhysXCollisionAttributes_t::GetCollisionGroup() const {
    return GetSchemaValue<uint32_t>(m_ptr, "VPhysXCollisionAttributes_t", "m_CollisionGroup");
}
void GVPhysXCollisionAttributes_t::SetCollisionGroup(uint32_t value) {
    SetSchemaValue(m_ptr, "VPhysXCollisionAttributes_t", "m_CollisionGroup", true, value);
}
std::vector<uint32> GVPhysXCollisionAttributes_t::GetInteractAs() const {
    CUtlVector<uint32>* vec = GetSchemaValue<CUtlVector<uint32>*>(m_ptr, "VPhysXCollisionAttributes_t", "m_InteractAs"); std::vector<uint32> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GVPhysXCollisionAttributes_t::SetInteractAs(std::vector<uint32> value) {
    SetSchemaValueCUtlVector<uint32>(m_ptr, "VPhysXCollisionAttributes_t", "m_InteractAs", true, value);
}
std::vector<uint32> GVPhysXCollisionAttributes_t::GetInteractWith() const {
    CUtlVector<uint32>* vec = GetSchemaValue<CUtlVector<uint32>*>(m_ptr, "VPhysXCollisionAttributes_t", "m_InteractWith"); std::vector<uint32> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GVPhysXCollisionAttributes_t::SetInteractWith(std::vector<uint32> value) {
    SetSchemaValueCUtlVector<uint32>(m_ptr, "VPhysXCollisionAttributes_t", "m_InteractWith", true, value);
}
std::vector<uint32> GVPhysXCollisionAttributes_t::GetInteractExclude() const {
    CUtlVector<uint32>* vec = GetSchemaValue<CUtlVector<uint32>*>(m_ptr, "VPhysXCollisionAttributes_t", "m_InteractExclude"); std::vector<uint32> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GVPhysXCollisionAttributes_t::SetInteractExclude(std::vector<uint32> value) {
    SetSchemaValueCUtlVector<uint32>(m_ptr, "VPhysXCollisionAttributes_t", "m_InteractExclude", true, value);
}
std::string GVPhysXCollisionAttributes_t::GetCollisionGroupString() const {
    return GetSchemaValue<CUtlString>(m_ptr, "VPhysXCollisionAttributes_t", "m_CollisionGroupString").Get();
}
void GVPhysXCollisionAttributes_t::SetCollisionGroupString(std::string value) {
    SetSchemaValue(m_ptr, "VPhysXCollisionAttributes_t", "m_CollisionGroupString", true, CUtlString(value.c_str()));
}
std::vector<CUtlString> GVPhysXCollisionAttributes_t::GetInteractAsStrings() const {
    CUtlVector<CUtlString>* vec = GetSchemaValue<CUtlVector<CUtlString>*>(m_ptr, "VPhysXCollisionAttributes_t", "m_InteractAsStrings"); std::vector<CUtlString> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GVPhysXCollisionAttributes_t::SetInteractAsStrings(std::vector<CUtlString> value) {
    SetSchemaValueCUtlVector<CUtlString>(m_ptr, "VPhysXCollisionAttributes_t", "m_InteractAsStrings", true, value);
}
std::vector<CUtlString> GVPhysXCollisionAttributes_t::GetInteractWithStrings() const {
    CUtlVector<CUtlString>* vec = GetSchemaValue<CUtlVector<CUtlString>*>(m_ptr, "VPhysXCollisionAttributes_t", "m_InteractWithStrings"); std::vector<CUtlString> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GVPhysXCollisionAttributes_t::SetInteractWithStrings(std::vector<CUtlString> value) {
    SetSchemaValueCUtlVector<CUtlString>(m_ptr, "VPhysXCollisionAttributes_t", "m_InteractWithStrings", true, value);
}
std::vector<CUtlString> GVPhysXCollisionAttributes_t::GetInteractExcludeStrings() const {
    CUtlVector<CUtlString>* vec = GetSchemaValue<CUtlVector<CUtlString>*>(m_ptr, "VPhysXCollisionAttributes_t", "m_InteractExcludeStrings"); std::vector<CUtlString> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GVPhysXCollisionAttributes_t::SetInteractExcludeStrings(std::vector<CUtlString> value) {
    SetSchemaValueCUtlVector<CUtlString>(m_ptr, "VPhysXCollisionAttributes_t", "m_InteractExcludeStrings", true, value);
}
std::string GVPhysXCollisionAttributes_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GVPhysXCollisionAttributes_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassVPhysXCollisionAttributes_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GVPhysXCollisionAttributes_t>("VPhysXCollisionAttributes_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("CollisionGroup", &GVPhysXCollisionAttributes_t::GetCollisionGroup, &GVPhysXCollisionAttributes_t::SetCollisionGroup)
        .addProperty("InteractAs", &GVPhysXCollisionAttributes_t::GetInteractAs, &GVPhysXCollisionAttributes_t::SetInteractAs)
        .addProperty("InteractWith", &GVPhysXCollisionAttributes_t::GetInteractWith, &GVPhysXCollisionAttributes_t::SetInteractWith)
        .addProperty("InteractExclude", &GVPhysXCollisionAttributes_t::GetInteractExclude, &GVPhysXCollisionAttributes_t::SetInteractExclude)
        .addProperty("CollisionGroupString", &GVPhysXCollisionAttributes_t::GetCollisionGroupString, &GVPhysXCollisionAttributes_t::SetCollisionGroupString)
        .addProperty("InteractAsStrings", &GVPhysXCollisionAttributes_t::GetInteractAsStrings, &GVPhysXCollisionAttributes_t::SetInteractAsStrings)
        .addProperty("InteractWithStrings", &GVPhysXCollisionAttributes_t::GetInteractWithStrings, &GVPhysXCollisionAttributes_t::SetInteractWithStrings)
        .addProperty("InteractExcludeStrings", &GVPhysXCollisionAttributes_t::GetInteractExcludeStrings, &GVPhysXCollisionAttributes_t::SetInteractExcludeStrings)
        .addFunction("ToPtr", &GVPhysXCollisionAttributes_t::ToPtr)
        .addFunction("IsValid", &GVPhysXCollisionAttributes_t::IsValid)
        .endClass();
}
GCActionComponentUpdater::GCActionComponentUpdater(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCActionComponentUpdater::GCActionComponentUpdater(void *ptr) {
    m_ptr = ptr;
}
std::string GCActionComponentUpdater::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCActionComponentUpdater::IsValid() {
    return (m_ptr != nullptr);
}
GCAnimComponentUpdater GCActionComponentUpdater::GetParent() const {
    GCAnimComponentUpdater value(m_ptr);
    return value;
}
void GCActionComponentUpdater::SetParent(GCAnimComponentUpdater value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCActionComponentUpdater(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCActionComponentUpdater>("CActionComponentUpdater")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCActionComponentUpdater::GetParent, &GCActionComponentUpdater::SetParent)
        .addFunction("ToPtr", &GCActionComponentUpdater::ToPtr)
        .addFunction("IsValid", &GCActionComponentUpdater::IsValid)
        .endClass();
}
GCNmVirtualParameterVectorNode::GCNmVirtualParameterVectorNode(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCNmVirtualParameterVectorNode::GCNmVirtualParameterVectorNode(void *ptr) {
    m_ptr = ptr;
}
int16_t GCNmVirtualParameterVectorNode::GetChildNodeIdx() const {
    return GetSchemaValue<int16_t>(m_ptr, "CNmVirtualParameterVectorNode", "m_nChildNodeIdx");
}
void GCNmVirtualParameterVectorNode::SetChildNodeIdx(int16_t value) {
    SetSchemaValue(m_ptr, "CNmVirtualParameterVectorNode", "m_nChildNodeIdx", false, value);
}
std::string GCNmVirtualParameterVectorNode::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCNmVirtualParameterVectorNode::IsValid() {
    return (m_ptr != nullptr);
}
GCNmVectorValueNode GCNmVirtualParameterVectorNode::GetParent() const {
    GCNmVectorValueNode value(m_ptr);
    return value;
}
void GCNmVirtualParameterVectorNode::SetParent(GCNmVectorValueNode value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCNmVirtualParameterVectorNode(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCNmVirtualParameterVectorNode>("CNmVirtualParameterVectorNode")
        .addConstructor<void (*)(std::string)>()
        .addProperty("ChildNodeIdx", &GCNmVirtualParameterVectorNode::GetChildNodeIdx, &GCNmVirtualParameterVectorNode::SetChildNodeIdx)
        .addProperty("Parent", &GCNmVirtualParameterVectorNode::GetParent, &GCNmVirtualParameterVectorNode::SetParent)
        .addFunction("ToPtr", &GCNmVirtualParameterVectorNode::ToPtr)
        .addFunction("IsValid", &GCNmVirtualParameterVectorNode::IsValid)
        .endClass();
}
GCAnimFrameSegment::GCAnimFrameSegment(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCAnimFrameSegment::GCAnimFrameSegment(void *ptr) {
    m_ptr = ptr;
}
int32_t GCAnimFrameSegment::GetUniqueFrameIndex() const {
    return GetSchemaValue<int32_t>(m_ptr, "CAnimFrameSegment", "m_nUniqueFrameIndex");
}
void GCAnimFrameSegment::SetUniqueFrameIndex(int32_t value) {
    SetSchemaValue(m_ptr, "CAnimFrameSegment", "m_nUniqueFrameIndex", false, value);
}
uint32_t GCAnimFrameSegment::GetLocalElementMasks() const {
    return GetSchemaValue<uint32_t>(m_ptr, "CAnimFrameSegment", "m_nLocalElementMasks");
}
void GCAnimFrameSegment::SetLocalElementMasks(uint32_t value) {
    SetSchemaValue(m_ptr, "CAnimFrameSegment", "m_nLocalElementMasks", false, value);
}
int32_t GCAnimFrameSegment::GetLocalChannel() const {
    return GetSchemaValue<int32_t>(m_ptr, "CAnimFrameSegment", "m_nLocalChannel");
}
void GCAnimFrameSegment::SetLocalChannel(int32_t value) {
    SetSchemaValue(m_ptr, "CAnimFrameSegment", "m_nLocalChannel", false, value);
}
std::string GCAnimFrameSegment::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCAnimFrameSegment::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCAnimFrameSegment(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCAnimFrameSegment>("CAnimFrameSegment")
        .addConstructor<void (*)(std::string)>()
        .addProperty("UniqueFrameIndex", &GCAnimFrameSegment::GetUniqueFrameIndex, &GCAnimFrameSegment::SetUniqueFrameIndex)
        .addProperty("LocalElementMasks", &GCAnimFrameSegment::GetLocalElementMasks, &GCAnimFrameSegment::SetLocalElementMasks)
        .addProperty("LocalChannel", &GCAnimFrameSegment::GetLocalChannel, &GCAnimFrameSegment::SetLocalChannel)
        .addFunction("ToPtr", &GCAnimFrameSegment::ToPtr)
        .addFunction("IsValid", &GCAnimFrameSegment::IsValid)
        .endClass();
}
GCClothSettingsAnimTag::GCClothSettingsAnimTag(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCClothSettingsAnimTag::GCClothSettingsAnimTag(void *ptr) {
    m_ptr = ptr;
}
float GCClothSettingsAnimTag::GetStiffness() const {
    return GetSchemaValue<float>(m_ptr, "CClothSettingsAnimTag", "m_flStiffness");
}
void GCClothSettingsAnimTag::SetStiffness(float value) {
    SetSchemaValue(m_ptr, "CClothSettingsAnimTag", "m_flStiffness", false, value);
}
float GCClothSettingsAnimTag::GetEaseIn() const {
    return GetSchemaValue<float>(m_ptr, "CClothSettingsAnimTag", "m_flEaseIn");
}
void GCClothSettingsAnimTag::SetEaseIn(float value) {
    SetSchemaValue(m_ptr, "CClothSettingsAnimTag", "m_flEaseIn", false, value);
}
float GCClothSettingsAnimTag::GetEaseOut() const {
    return GetSchemaValue<float>(m_ptr, "CClothSettingsAnimTag", "m_flEaseOut");
}
void GCClothSettingsAnimTag::SetEaseOut(float value) {
    SetSchemaValue(m_ptr, "CClothSettingsAnimTag", "m_flEaseOut", false, value);
}
std::string GCClothSettingsAnimTag::GetVertexSet() const {
    return GetSchemaValue<CUtlString>(m_ptr, "CClothSettingsAnimTag", "m_nVertexSet").Get();
}
void GCClothSettingsAnimTag::SetVertexSet(std::string value) {
    SetSchemaValue(m_ptr, "CClothSettingsAnimTag", "m_nVertexSet", false, CUtlString(value.c_str()));
}
std::string GCClothSettingsAnimTag::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCClothSettingsAnimTag::IsValid() {
    return (m_ptr != nullptr);
}
GCAnimTagBase GCClothSettingsAnimTag::GetParent() const {
    GCAnimTagBase value(m_ptr);
    return value;
}
void GCClothSettingsAnimTag::SetParent(GCAnimTagBase value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCClothSettingsAnimTag(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCClothSettingsAnimTag>("CClothSettingsAnimTag")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Stiffness", &GCClothSettingsAnimTag::GetStiffness, &GCClothSettingsAnimTag::SetStiffness)
        .addProperty("EaseIn", &GCClothSettingsAnimTag::GetEaseIn, &GCClothSettingsAnimTag::SetEaseIn)
        .addProperty("EaseOut", &GCClothSettingsAnimTag::GetEaseOut, &GCClothSettingsAnimTag::SetEaseOut)
        .addProperty("VertexSet", &GCClothSettingsAnimTag::GetVertexSet, &GCClothSettingsAnimTag::SetVertexSet)
        .addProperty("Parent", &GCClothSettingsAnimTag::GetParent, &GCClothSettingsAnimTag::SetParent)
        .addFunction("ToPtr", &GCClothSettingsAnimTag::ToPtr)
        .addFunction("IsValid", &GCClothSettingsAnimTag::IsValid)
        .endClass();
}
GVariableInfo_t::GVariableInfo_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GVariableInfo_t::GVariableInfo_t(void *ptr) {
    m_ptr = ptr;
}
std::string GVariableInfo_t::GetName() const {
    return GetSchemaValue<CUtlString>(m_ptr, "VariableInfo_t", "m_name").Get();
}
void GVariableInfo_t::SetName(std::string value) {
    SetSchemaValue(m_ptr, "VariableInfo_t", "m_name", true, CUtlString(value.c_str()));
}
CUtlStringToken GVariableInfo_t::GetNameToken() const {
    return GetSchemaValue<CUtlStringToken>(m_ptr, "VariableInfo_t", "m_nameToken");
}
void GVariableInfo_t::SetNameToken(CUtlStringToken value) {
    SetSchemaValue(m_ptr, "VariableInfo_t", "m_nameToken", true, value);
}
GFuseVariableIndex_t GVariableInfo_t::GetIndex() const {
    GFuseVariableIndex_t value(GetSchemaPtr(m_ptr, "VariableInfo_t", "m_nIndex"));
    return value;
}
void GVariableInfo_t::SetIndex(GFuseVariableIndex_t value) {
    SetSchemaValue(m_ptr, "VariableInfo_t", "m_nIndex", true, value);
}
uint8_t GVariableInfo_t::GetNumComponents() const {
    return GetSchemaValue<uint8_t>(m_ptr, "VariableInfo_t", "m_nNumComponents");
}
void GVariableInfo_t::SetNumComponents(uint8_t value) {
    SetSchemaValue(m_ptr, "VariableInfo_t", "m_nNumComponents", true, value);
}
uint64_t GVariableInfo_t::GetVarType() const {
    return GetSchemaValue<uint64_t>(m_ptr, "VariableInfo_t", "m_eVarType");
}
void GVariableInfo_t::SetVarType(uint64_t value) {
    SetSchemaValue(m_ptr, "VariableInfo_t", "m_eVarType", true, value);
}
uint64_t GVariableInfo_t::GetAccess() const {
    return GetSchemaValue<uint64_t>(m_ptr, "VariableInfo_t", "m_eAccess");
}
void GVariableInfo_t::SetAccess(uint64_t value) {
    SetSchemaValue(m_ptr, "VariableInfo_t", "m_eAccess", true, value);
}
std::string GVariableInfo_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GVariableInfo_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassVariableInfo_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GVariableInfo_t>("VariableInfo_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Name", &GVariableInfo_t::GetName, &GVariableInfo_t::SetName)
        .addProperty("NameToken", &GVariableInfo_t::GetNameToken, &GVariableInfo_t::SetNameToken)
        .addProperty("Index", &GVariableInfo_t::GetIndex, &GVariableInfo_t::SetIndex)
        .addProperty("NumComponents", &GVariableInfo_t::GetNumComponents, &GVariableInfo_t::SetNumComponents)
        .addProperty("VarType", &GVariableInfo_t::GetVarType, &GVariableInfo_t::SetVarType)
        .addProperty("Access", &GVariableInfo_t::GetAccess, &GVariableInfo_t::SetAccess)
        .addFunction("ToPtr", &GVariableInfo_t::ToPtr)
        .addFunction("IsValid", &GVariableInfo_t::IsValid)
        .endClass();
}
GVMixShaperDesc_t::GVMixShaperDesc_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GVMixShaperDesc_t::GVMixShaperDesc_t(void *ptr) {
    m_ptr = ptr;
}
int32_t GVMixShaperDesc_t::GetShape() const {
    return GetSchemaValue<int32_t>(m_ptr, "VMixShaperDesc_t", "m_nShape");
}
void GVMixShaperDesc_t::SetShape(int32_t value) {
    SetSchemaValue(m_ptr, "VMixShaperDesc_t", "m_nShape", true, value);
}
float GVMixShaperDesc_t::GetFldbDrive() const {
    return GetSchemaValue<float>(m_ptr, "VMixShaperDesc_t", "m_fldbDrive");
}
void GVMixShaperDesc_t::SetFldbDrive(float value) {
    SetSchemaValue(m_ptr, "VMixShaperDesc_t", "m_fldbDrive", true, value);
}
float GVMixShaperDesc_t::GetFldbOutputGain() const {
    return GetSchemaValue<float>(m_ptr, "VMixShaperDesc_t", "m_fldbOutputGain");
}
void GVMixShaperDesc_t::SetFldbOutputGain(float value) {
    SetSchemaValue(m_ptr, "VMixShaperDesc_t", "m_fldbOutputGain", true, value);
}
float GVMixShaperDesc_t::GetWetMix() const {
    return GetSchemaValue<float>(m_ptr, "VMixShaperDesc_t", "m_flWetMix");
}
void GVMixShaperDesc_t::SetWetMix(float value) {
    SetSchemaValue(m_ptr, "VMixShaperDesc_t", "m_flWetMix", true, value);
}
int32_t GVMixShaperDesc_t::GetOversampleFactor() const {
    return GetSchemaValue<int32_t>(m_ptr, "VMixShaperDesc_t", "m_nOversampleFactor");
}
void GVMixShaperDesc_t::SetOversampleFactor(int32_t value) {
    SetSchemaValue(m_ptr, "VMixShaperDesc_t", "m_nOversampleFactor", true, value);
}
std::string GVMixShaperDesc_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GVMixShaperDesc_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassVMixShaperDesc_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GVMixShaperDesc_t>("VMixShaperDesc_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Shape", &GVMixShaperDesc_t::GetShape, &GVMixShaperDesc_t::SetShape)
        .addProperty("FldbDrive", &GVMixShaperDesc_t::GetFldbDrive, &GVMixShaperDesc_t::SetFldbDrive)
        .addProperty("FldbOutputGain", &GVMixShaperDesc_t::GetFldbOutputGain, &GVMixShaperDesc_t::SetFldbOutputGain)
        .addProperty("WetMix", &GVMixShaperDesc_t::GetWetMix, &GVMixShaperDesc_t::SetWetMix)
        .addProperty("OversampleFactor", &GVMixShaperDesc_t::GetOversampleFactor, &GVMixShaperDesc_t::SetOversampleFactor)
        .addFunction("ToPtr", &GVMixShaperDesc_t::ToPtr)
        .addFunction("IsValid", &GVMixShaperDesc_t::IsValid)
        .endClass();
}
GCSoundInfoHeader::GCSoundInfoHeader(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCSoundInfoHeader::GCSoundInfoHeader(void *ptr) {
    m_ptr = ptr;
}
std::string GCSoundInfoHeader::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCSoundInfoHeader::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCSoundInfoHeader(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCSoundInfoHeader>("CSoundInfoHeader")
        .addConstructor<void (*)(std::string)>()
        .addFunction("ToPtr", &GCSoundInfoHeader::ToPtr)
        .addFunction("IsValid", &GCSoundInfoHeader::IsValid)
        .endClass();
}
GCVoiceContainerDecayingSineWave::GCVoiceContainerDecayingSineWave(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCVoiceContainerDecayingSineWave::GCVoiceContainerDecayingSineWave(void *ptr) {
    m_ptr = ptr;
}
float GCVoiceContainerDecayingSineWave::GetFrequency() const {
    return GetSchemaValue<float>(m_ptr, "CVoiceContainerDecayingSineWave", "m_flFrequency");
}
void GCVoiceContainerDecayingSineWave::SetFrequency(float value) {
    SetSchemaValue(m_ptr, "CVoiceContainerDecayingSineWave", "m_flFrequency", false, value);
}
float GCVoiceContainerDecayingSineWave::GetDecayTime() const {
    return GetSchemaValue<float>(m_ptr, "CVoiceContainerDecayingSineWave", "m_flDecayTime");
}
void GCVoiceContainerDecayingSineWave::SetDecayTime(float value) {
    SetSchemaValue(m_ptr, "CVoiceContainerDecayingSineWave", "m_flDecayTime", false, value);
}
std::string GCVoiceContainerDecayingSineWave::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCVoiceContainerDecayingSineWave::IsValid() {
    return (m_ptr != nullptr);
}
GCVoiceContainerBase GCVoiceContainerDecayingSineWave::GetParent() const {
    GCVoiceContainerBase value(m_ptr);
    return value;
}
void GCVoiceContainerDecayingSineWave::SetParent(GCVoiceContainerBase value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCVoiceContainerDecayingSineWave(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCVoiceContainerDecayingSineWave>("CVoiceContainerDecayingSineWave")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Frequency", &GCVoiceContainerDecayingSineWave::GetFrequency, &GCVoiceContainerDecayingSineWave::SetFrequency)
        .addProperty("DecayTime", &GCVoiceContainerDecayingSineWave::GetDecayTime, &GCVoiceContainerDecayingSineWave::SetDecayTime)
        .addProperty("Parent", &GCVoiceContainerDecayingSineWave::GetParent, &GCVoiceContainerDecayingSineWave::SetParent)
        .addFunction("ToPtr", &GCVoiceContainerDecayingSineWave::ToPtr)
        .addFunction("IsValid", &GCVoiceContainerDecayingSineWave::IsValid)
        .endClass();
}
GCCycleControlClipUpdateNode::GCCycleControlClipUpdateNode(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCCycleControlClipUpdateNode::GCCycleControlClipUpdateNode(void *ptr) {
    m_ptr = ptr;
}
std::vector<GTagSpan_t> GCCycleControlClipUpdateNode::GetTags() const {
    CUtlVector<GTagSpan_t>* vec = GetSchemaValue<CUtlVector<GTagSpan_t>*>(m_ptr, "CCycleControlClipUpdateNode", "m_tags"); std::vector<GTagSpan_t> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCCycleControlClipUpdateNode::SetTags(std::vector<GTagSpan_t> value) {
    SetSchemaValueCUtlVector<GTagSpan_t>(m_ptr, "CCycleControlClipUpdateNode", "m_tags", false, value);
}
float GCCycleControlClipUpdateNode::GetDuration() const {
    return GetSchemaValue<float>(m_ptr, "CCycleControlClipUpdateNode", "m_duration");
}
void GCCycleControlClipUpdateNode::SetDuration(float value) {
    SetSchemaValue(m_ptr, "CCycleControlClipUpdateNode", "m_duration", false, value);
}
uint64_t GCCycleControlClipUpdateNode::GetValueSource() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CCycleControlClipUpdateNode", "m_valueSource");
}
void GCCycleControlClipUpdateNode::SetValueSource(uint64_t value) {
    SetSchemaValue(m_ptr, "CCycleControlClipUpdateNode", "m_valueSource", false, value);
}
GCAnimParamHandle GCCycleControlClipUpdateNode::GetParamIndex() const {
    GCAnimParamHandle value(GetSchemaPtr(m_ptr, "CCycleControlClipUpdateNode", "m_paramIndex"));
    return value;
}
void GCCycleControlClipUpdateNode::SetParamIndex(GCAnimParamHandle value) {
    SetSchemaValue(m_ptr, "CCycleControlClipUpdateNode", "m_paramIndex", false, value);
}
std::string GCCycleControlClipUpdateNode::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCCycleControlClipUpdateNode::IsValid() {
    return (m_ptr != nullptr);
}
GCLeafUpdateNode GCCycleControlClipUpdateNode::GetParent() const {
    GCLeafUpdateNode value(m_ptr);
    return value;
}
void GCCycleControlClipUpdateNode::SetParent(GCLeafUpdateNode value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCCycleControlClipUpdateNode(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCCycleControlClipUpdateNode>("CCycleControlClipUpdateNode")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Tags", &GCCycleControlClipUpdateNode::GetTags, &GCCycleControlClipUpdateNode::SetTags)
        .addProperty("Duration", &GCCycleControlClipUpdateNode::GetDuration, &GCCycleControlClipUpdateNode::SetDuration)
        .addProperty("ValueSource", &GCCycleControlClipUpdateNode::GetValueSource, &GCCycleControlClipUpdateNode::SetValueSource)
        .addProperty("ParamIndex", &GCCycleControlClipUpdateNode::GetParamIndex, &GCCycleControlClipUpdateNode::SetParamIndex)
        .addProperty("Parent", &GCCycleControlClipUpdateNode::GetParent, &GCCycleControlClipUpdateNode::SetParent)
        .addFunction("ToPtr", &GCCycleControlClipUpdateNode::ToPtr)
        .addFunction("IsValid", &GCCycleControlClipUpdateNode::IsValid)
        .endClass();
}
GCBaseTrailRenderer::GCBaseTrailRenderer(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCBaseTrailRenderer::GCBaseTrailRenderer(void *ptr) {
    m_ptr = ptr;
}
uint64_t GCBaseTrailRenderer::GetOrientationType() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CBaseTrailRenderer", "m_nOrientationType");
}
void GCBaseTrailRenderer::SetOrientationType(uint64_t value) {
    SetSchemaValue(m_ptr, "CBaseTrailRenderer", "m_nOrientationType", false, value);
}
int32_t GCBaseTrailRenderer::GetOrientationControlPoint() const {
    return GetSchemaValue<int32_t>(m_ptr, "CBaseTrailRenderer", "m_nOrientationControlPoint");
}
void GCBaseTrailRenderer::SetOrientationControlPoint(int32_t value) {
    SetSchemaValue(m_ptr, "CBaseTrailRenderer", "m_nOrientationControlPoint", false, value);
}
float GCBaseTrailRenderer::GetMinSize() const {
    return GetSchemaValue<float>(m_ptr, "CBaseTrailRenderer", "m_flMinSize");
}
void GCBaseTrailRenderer::SetMinSize(float value) {
    SetSchemaValue(m_ptr, "CBaseTrailRenderer", "m_flMinSize", false, value);
}
float GCBaseTrailRenderer::GetMaxSize() const {
    return GetSchemaValue<float>(m_ptr, "CBaseTrailRenderer", "m_flMaxSize");
}
void GCBaseTrailRenderer::SetMaxSize(float value) {
    SetSchemaValue(m_ptr, "CBaseTrailRenderer", "m_flMaxSize", false, value);
}
GCParticleCollectionRendererFloatInput GCBaseTrailRenderer::GetStartFadeSize() const {
    GCParticleCollectionRendererFloatInput value(GetSchemaPtr(m_ptr, "CBaseTrailRenderer", "m_flStartFadeSize"));
    return value;
}
void GCBaseTrailRenderer::SetStartFadeSize(GCParticleCollectionRendererFloatInput value) {
    SetSchemaValue(m_ptr, "CBaseTrailRenderer", "m_flStartFadeSize", false, value);
}
GCParticleCollectionRendererFloatInput GCBaseTrailRenderer::GetEndFadeSize() const {
    GCParticleCollectionRendererFloatInput value(GetSchemaPtr(m_ptr, "CBaseTrailRenderer", "m_flEndFadeSize"));
    return value;
}
void GCBaseTrailRenderer::SetEndFadeSize(GCParticleCollectionRendererFloatInput value) {
    SetSchemaValue(m_ptr, "CBaseTrailRenderer", "m_flEndFadeSize", false, value);
}
bool GCBaseTrailRenderer::GetClampV() const {
    return GetSchemaValue<bool>(m_ptr, "CBaseTrailRenderer", "m_bClampV");
}
void GCBaseTrailRenderer::SetClampV(bool value) {
    SetSchemaValue(m_ptr, "CBaseTrailRenderer", "m_bClampV", false, value);
}
std::string GCBaseTrailRenderer::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCBaseTrailRenderer::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseRendererSource2 GCBaseTrailRenderer::GetParent() const {
    GCBaseRendererSource2 value(m_ptr);
    return value;
}
void GCBaseTrailRenderer::SetParent(GCBaseRendererSource2 value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCBaseTrailRenderer(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCBaseTrailRenderer>("CBaseTrailRenderer")
        .addConstructor<void (*)(std::string)>()
        .addProperty("OrientationType", &GCBaseTrailRenderer::GetOrientationType, &GCBaseTrailRenderer::SetOrientationType)
        .addProperty("OrientationControlPoint", &GCBaseTrailRenderer::GetOrientationControlPoint, &GCBaseTrailRenderer::SetOrientationControlPoint)
        .addProperty("MinSize", &GCBaseTrailRenderer::GetMinSize, &GCBaseTrailRenderer::SetMinSize)
        .addProperty("MaxSize", &GCBaseTrailRenderer::GetMaxSize, &GCBaseTrailRenderer::SetMaxSize)
        .addProperty("StartFadeSize", &GCBaseTrailRenderer::GetStartFadeSize, &GCBaseTrailRenderer::SetStartFadeSize)
        .addProperty("EndFadeSize", &GCBaseTrailRenderer::GetEndFadeSize, &GCBaseTrailRenderer::SetEndFadeSize)
        .addProperty("ClampV", &GCBaseTrailRenderer::GetClampV, &GCBaseTrailRenderer::SetClampV)
        .addProperty("Parent", &GCBaseTrailRenderer::GetParent, &GCBaseTrailRenderer::SetParent)
        .addFunction("ToPtr", &GCBaseTrailRenderer::ToPtr)
        .addFunction("IsValid", &GCBaseTrailRenderer::IsValid)
        .endClass();
}
GCBoneConstraintPoseSpaceBone::GCBoneConstraintPoseSpaceBone(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCBoneConstraintPoseSpaceBone::GCBoneConstraintPoseSpaceBone(void *ptr) {
    m_ptr = ptr;
}
std::vector<GCBoneConstraintPoseSpaceBone> GCBoneConstraintPoseSpaceBone::GetInputList() const {
    CUtlVector<GCBoneConstraintPoseSpaceBone>* vec = GetSchemaValue<CUtlVector<GCBoneConstraintPoseSpaceBone>*>(m_ptr, "CBoneConstraintPoseSpaceBone", "m_inputList"); std::vector<GCBoneConstraintPoseSpaceBone> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCBoneConstraintPoseSpaceBone::SetInputList(std::vector<GCBoneConstraintPoseSpaceBone> value) {
    SetSchemaValueCUtlVector<GCBoneConstraintPoseSpaceBone>(m_ptr, "CBoneConstraintPoseSpaceBone", "m_inputList", false, value);
}
std::string GCBoneConstraintPoseSpaceBone::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCBoneConstraintPoseSpaceBone::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseConstraint GCBoneConstraintPoseSpaceBone::GetParent() const {
    GCBaseConstraint value(m_ptr);
    return value;
}
void GCBoneConstraintPoseSpaceBone::SetParent(GCBaseConstraint value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCBoneConstraintPoseSpaceBone(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCBoneConstraintPoseSpaceBone>("CBoneConstraintPoseSpaceBone")
        .addConstructor<void (*)(std::string)>()
        .addProperty("InputList", &GCBoneConstraintPoseSpaceBone::GetInputList, &GCBoneConstraintPoseSpaceBone::SetInputList)
        .addProperty("Parent", &GCBoneConstraintPoseSpaceBone::GetParent, &GCBoneConstraintPoseSpaceBone::SetParent)
        .addFunction("ToPtr", &GCBoneConstraintPoseSpaceBone::ToPtr)
        .addFunction("IsValid", &GCBoneConstraintPoseSpaceBone::IsValid)
        .endClass();
}
GEventServerPostSimulate_t::GEventServerPostSimulate_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GEventServerPostSimulate_t::GEventServerPostSimulate_t(void *ptr) {
    m_ptr = ptr;
}
std::string GEventServerPostSimulate_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GEventServerPostSimulate_t::IsValid() {
    return (m_ptr != nullptr);
}
GEventSimulate_t GEventServerPostSimulate_t::GetParent() const {
    GEventSimulate_t value(m_ptr);
    return value;
}
void GEventServerPostSimulate_t::SetParent(GEventSimulate_t value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassEventServerPostSimulate_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GEventServerPostSimulate_t>("EventServerPostSimulate_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GEventServerPostSimulate_t::GetParent, &GEventServerPostSimulate_t::SetParent)
        .addFunction("ToPtr", &GEventServerPostSimulate_t::ToPtr)
        .addFunction("IsValid", &GEventServerPostSimulate_t::IsValid)
        .endClass();
}
GCChoreoUpdateNode::GCChoreoUpdateNode(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCChoreoUpdateNode::GCChoreoUpdateNode(void *ptr) {
    m_ptr = ptr;
}
std::string GCChoreoUpdateNode::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCChoreoUpdateNode::IsValid() {
    return (m_ptr != nullptr);
}
GCUnaryUpdateNode GCChoreoUpdateNode::GetParent() const {
    GCUnaryUpdateNode value(m_ptr);
    return value;
}
void GCChoreoUpdateNode::SetParent(GCUnaryUpdateNode value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCChoreoUpdateNode(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCChoreoUpdateNode>("CChoreoUpdateNode")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCChoreoUpdateNode::GetParent, &GCChoreoUpdateNode::SetParent)
        .addFunction("ToPtr", &GCChoreoUpdateNode::ToPtr)
        .addFunction("IsValid", &GCChoreoUpdateNode::IsValid)
        .endClass();
}
GCNmSkeleton::GCNmSkeleton(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCNmSkeleton::GCNmSkeleton(void *ptr) {
    m_ptr = ptr;
}
std::vector<int32> GCNmSkeleton::GetParentIndices() const {
    CUtlVector<int32>* vec = GetSchemaValue<CUtlVector<int32>*>(m_ptr, "CNmSkeleton", "m_parentIndices"); std::vector<int32> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCNmSkeleton::SetParentIndices(std::vector<int32> value) {
    SetSchemaValueCUtlVector<int32>(m_ptr, "CNmSkeleton", "m_parentIndices", false, value);
}
int32_t GCNmSkeleton::GetNumBonesToSampleAtLowLOD() const {
    return GetSchemaValue<int32_t>(m_ptr, "CNmSkeleton", "m_numBonesToSampleAtLowLOD");
}
void GCNmSkeleton::SetNumBonesToSampleAtLowLOD(int32_t value) {
    SetSchemaValue(m_ptr, "CNmSkeleton", "m_numBonesToSampleAtLowLOD", false, value);
}
std::string GCNmSkeleton::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCNmSkeleton::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCNmSkeleton(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCNmSkeleton>("CNmSkeleton")
        .addConstructor<void (*)(std::string)>()
        .addProperty("ParentIndices", &GCNmSkeleton::GetParentIndices, &GCNmSkeleton::SetParentIndices)
        .addProperty("NumBonesToSampleAtLowLOD", &GCNmSkeleton::GetNumBonesToSampleAtLowLOD, &GCNmSkeleton::SetNumBonesToSampleAtLowLOD)
        .addFunction("ToPtr", &GCNmSkeleton::ToPtr)
        .addFunction("IsValid", &GCNmSkeleton::IsValid)
        .endClass();
}
GVMixBoxverbDesc_t::GVMixBoxverbDesc_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GVMixBoxverbDesc_t::GVMixBoxverbDesc_t(void *ptr) {
    m_ptr = ptr;
}
float GVMixBoxverbDesc_t::GetSizeMax() const {
    return GetSchemaValue<float>(m_ptr, "VMixBoxverbDesc_t", "m_flSizeMax");
}
void GVMixBoxverbDesc_t::SetSizeMax(float value) {
    SetSchemaValue(m_ptr, "VMixBoxverbDesc_t", "m_flSizeMax", true, value);
}
float GVMixBoxverbDesc_t::GetSizeMin() const {
    return GetSchemaValue<float>(m_ptr, "VMixBoxverbDesc_t", "m_flSizeMin");
}
void GVMixBoxverbDesc_t::SetSizeMin(float value) {
    SetSchemaValue(m_ptr, "VMixBoxverbDesc_t", "m_flSizeMin", true, value);
}
float GVMixBoxverbDesc_t::GetComplexity() const {
    return GetSchemaValue<float>(m_ptr, "VMixBoxverbDesc_t", "m_flComplexity");
}
void GVMixBoxverbDesc_t::SetComplexity(float value) {
    SetSchemaValue(m_ptr, "VMixBoxverbDesc_t", "m_flComplexity", true, value);
}
float GVMixBoxverbDesc_t::GetDiffusion() const {
    return GetSchemaValue<float>(m_ptr, "VMixBoxverbDesc_t", "m_flDiffusion");
}
void GVMixBoxverbDesc_t::SetDiffusion(float value) {
    SetSchemaValue(m_ptr, "VMixBoxverbDesc_t", "m_flDiffusion", true, value);
}
float GVMixBoxverbDesc_t::GetModDepth() const {
    return GetSchemaValue<float>(m_ptr, "VMixBoxverbDesc_t", "m_flModDepth");
}
void GVMixBoxverbDesc_t::SetModDepth(float value) {
    SetSchemaValue(m_ptr, "VMixBoxverbDesc_t", "m_flModDepth", true, value);
}
float GVMixBoxverbDesc_t::GetModRate() const {
    return GetSchemaValue<float>(m_ptr, "VMixBoxverbDesc_t", "m_flModRate");
}
void GVMixBoxverbDesc_t::SetModRate(float value) {
    SetSchemaValue(m_ptr, "VMixBoxverbDesc_t", "m_flModRate", true, value);
}
bool GVMixBoxverbDesc_t::GetParallel() const {
    return GetSchemaValue<bool>(m_ptr, "VMixBoxverbDesc_t", "m_bParallel");
}
void GVMixBoxverbDesc_t::SetParallel(bool value) {
    SetSchemaValue(m_ptr, "VMixBoxverbDesc_t", "m_bParallel", true, value);
}
GVMixFilterDesc_t GVMixBoxverbDesc_t::GetFilterType() const {
    GVMixFilterDesc_t value(GetSchemaPtr(m_ptr, "VMixBoxverbDesc_t", "m_filterType"));
    return value;
}
void GVMixBoxverbDesc_t::SetFilterType(GVMixFilterDesc_t value) {
    SetSchemaValue(m_ptr, "VMixBoxverbDesc_t", "m_filterType", true, value);
}
float GVMixBoxverbDesc_t::GetWidth() const {
    return GetSchemaValue<float>(m_ptr, "VMixBoxverbDesc_t", "m_flWidth");
}
void GVMixBoxverbDesc_t::SetWidth(float value) {
    SetSchemaValue(m_ptr, "VMixBoxverbDesc_t", "m_flWidth", true, value);
}
float GVMixBoxverbDesc_t::GetHeight() const {
    return GetSchemaValue<float>(m_ptr, "VMixBoxverbDesc_t", "m_flHeight");
}
void GVMixBoxverbDesc_t::SetHeight(float value) {
    SetSchemaValue(m_ptr, "VMixBoxverbDesc_t", "m_flHeight", true, value);
}
float GVMixBoxverbDesc_t::GetDepth() const {
    return GetSchemaValue<float>(m_ptr, "VMixBoxverbDesc_t", "m_flDepth");
}
void GVMixBoxverbDesc_t::SetDepth(float value) {
    SetSchemaValue(m_ptr, "VMixBoxverbDesc_t", "m_flDepth", true, value);
}
float GVMixBoxverbDesc_t::GetFeedbackScale() const {
    return GetSchemaValue<float>(m_ptr, "VMixBoxverbDesc_t", "m_flFeedbackScale");
}
void GVMixBoxverbDesc_t::SetFeedbackScale(float value) {
    SetSchemaValue(m_ptr, "VMixBoxverbDesc_t", "m_flFeedbackScale", true, value);
}
float GVMixBoxverbDesc_t::GetFeedbackWidth() const {
    return GetSchemaValue<float>(m_ptr, "VMixBoxverbDesc_t", "m_flFeedbackWidth");
}
void GVMixBoxverbDesc_t::SetFeedbackWidth(float value) {
    SetSchemaValue(m_ptr, "VMixBoxverbDesc_t", "m_flFeedbackWidth", true, value);
}
float GVMixBoxverbDesc_t::GetFeedbackHeight() const {
    return GetSchemaValue<float>(m_ptr, "VMixBoxverbDesc_t", "m_flFeedbackHeight");
}
void GVMixBoxverbDesc_t::SetFeedbackHeight(float value) {
    SetSchemaValue(m_ptr, "VMixBoxverbDesc_t", "m_flFeedbackHeight", true, value);
}
float GVMixBoxverbDesc_t::GetFeedbackDepth() const {
    return GetSchemaValue<float>(m_ptr, "VMixBoxverbDesc_t", "m_flFeedbackDepth");
}
void GVMixBoxverbDesc_t::SetFeedbackDepth(float value) {
    SetSchemaValue(m_ptr, "VMixBoxverbDesc_t", "m_flFeedbackDepth", true, value);
}
float GVMixBoxverbDesc_t::GetOutputGain() const {
    return GetSchemaValue<float>(m_ptr, "VMixBoxverbDesc_t", "m_flOutputGain");
}
void GVMixBoxverbDesc_t::SetOutputGain(float value) {
    SetSchemaValue(m_ptr, "VMixBoxverbDesc_t", "m_flOutputGain", true, value);
}
float GVMixBoxverbDesc_t::GetTaps() const {
    return GetSchemaValue<float>(m_ptr, "VMixBoxverbDesc_t", "m_flTaps");
}
void GVMixBoxverbDesc_t::SetTaps(float value) {
    SetSchemaValue(m_ptr, "VMixBoxverbDesc_t", "m_flTaps", true, value);
}
std::string GVMixBoxverbDesc_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GVMixBoxverbDesc_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassVMixBoxverbDesc_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GVMixBoxverbDesc_t>("VMixBoxverbDesc_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("SizeMax", &GVMixBoxverbDesc_t::GetSizeMax, &GVMixBoxverbDesc_t::SetSizeMax)
        .addProperty("SizeMin", &GVMixBoxverbDesc_t::GetSizeMin, &GVMixBoxverbDesc_t::SetSizeMin)
        .addProperty("Complexity", &GVMixBoxverbDesc_t::GetComplexity, &GVMixBoxverbDesc_t::SetComplexity)
        .addProperty("Diffusion", &GVMixBoxverbDesc_t::GetDiffusion, &GVMixBoxverbDesc_t::SetDiffusion)
        .addProperty("ModDepth", &GVMixBoxverbDesc_t::GetModDepth, &GVMixBoxverbDesc_t::SetModDepth)
        .addProperty("ModRate", &GVMixBoxverbDesc_t::GetModRate, &GVMixBoxverbDesc_t::SetModRate)
        .addProperty("Parallel", &GVMixBoxverbDesc_t::GetParallel, &GVMixBoxverbDesc_t::SetParallel)
        .addProperty("FilterType", &GVMixBoxverbDesc_t::GetFilterType, &GVMixBoxverbDesc_t::SetFilterType)
        .addProperty("Width", &GVMixBoxverbDesc_t::GetWidth, &GVMixBoxverbDesc_t::SetWidth)
        .addProperty("Height", &GVMixBoxverbDesc_t::GetHeight, &GVMixBoxverbDesc_t::SetHeight)
        .addProperty("Depth", &GVMixBoxverbDesc_t::GetDepth, &GVMixBoxverbDesc_t::SetDepth)
        .addProperty("FeedbackScale", &GVMixBoxverbDesc_t::GetFeedbackScale, &GVMixBoxverbDesc_t::SetFeedbackScale)
        .addProperty("FeedbackWidth", &GVMixBoxverbDesc_t::GetFeedbackWidth, &GVMixBoxverbDesc_t::SetFeedbackWidth)
        .addProperty("FeedbackHeight", &GVMixBoxverbDesc_t::GetFeedbackHeight, &GVMixBoxverbDesc_t::SetFeedbackHeight)
        .addProperty("FeedbackDepth", &GVMixBoxverbDesc_t::GetFeedbackDepth, &GVMixBoxverbDesc_t::SetFeedbackDepth)
        .addProperty("OutputGain", &GVMixBoxverbDesc_t::GetOutputGain, &GVMixBoxverbDesc_t::SetOutputGain)
        .addProperty("Taps", &GVMixBoxverbDesc_t::GetTaps, &GVMixBoxverbDesc_t::SetTaps)
        .addFunction("ToPtr", &GVMixBoxverbDesc_t::ToPtr)
        .addFunction("IsValid", &GVMixBoxverbDesc_t::IsValid)
        .endClass();
}
GFeTreeChildren_t::GFeTreeChildren_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GFeTreeChildren_t::GFeTreeChildren_t(void *ptr) {
    m_ptr = ptr;
}
std::vector<uint16_t> GFeTreeChildren_t::GetChild() const {
    uint16_t* outValue = GetSchemaValue<uint16_t*>(m_ptr, "FeTreeChildren_t", "nChild"); std::vector<uint16_t> ret; for(int i = 0; i < 2; i++) { ret.push_back(outValue[i]); } return ret;
}
void GFeTreeChildren_t::SetChild(std::vector<uint16_t> value) {
    uint16_t* outValue = GetSchemaValue<uint16_t*>(m_ptr, "FeTreeChildren_t", "nChild"); for(int i = 0; i < 2; i++) { outValue[i] = value[i]; } SetSchemaValue(m_ptr, "FeTreeChildren_t", "nChild", true, outValue);
}
std::string GFeTreeChildren_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GFeTreeChildren_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassFeTreeChildren_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GFeTreeChildren_t>("FeTreeChildren_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Child", &GFeTreeChildren_t::GetChild, &GFeTreeChildren_t::SetChild)
        .addFunction("ToPtr", &GFeTreeChildren_t::ToPtr)
        .addFunction("IsValid", &GFeTreeChildren_t::IsValid)
        .endClass();
}
GCSceneObjectData::GCSceneObjectData(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCSceneObjectData::GCSceneObjectData(void *ptr) {
    m_ptr = ptr;
}
Vector GCSceneObjectData::GetMinBounds() const {
    return GetSchemaValue<Vector>(m_ptr, "CSceneObjectData", "m_vMinBounds");
}
void GCSceneObjectData::SetMinBounds(Vector value) {
    SetSchemaValue(m_ptr, "CSceneObjectData", "m_vMinBounds", false, value);
}
Vector GCSceneObjectData::GetMaxBounds() const {
    return GetSchemaValue<Vector>(m_ptr, "CSceneObjectData", "m_vMaxBounds");
}
void GCSceneObjectData::SetMaxBounds(Vector value) {
    SetSchemaValue(m_ptr, "CSceneObjectData", "m_vMaxBounds", false, value);
}
std::vector<GCMaterialDrawDescriptor> GCSceneObjectData::GetDrawCalls() const {
    CUtlVector<GCMaterialDrawDescriptor>* vec = GetSchemaValue<CUtlVector<GCMaterialDrawDescriptor>*>(m_ptr, "CSceneObjectData", "m_drawCalls"); std::vector<GCMaterialDrawDescriptor> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCSceneObjectData::SetDrawCalls(std::vector<GCMaterialDrawDescriptor> value) {
    SetSchemaValueCUtlVector<GCMaterialDrawDescriptor>(m_ptr, "CSceneObjectData", "m_drawCalls", false, value);
}
std::vector<GAABB_t> GCSceneObjectData::GetDrawBounds() const {
    CUtlVector<GAABB_t>* vec = GetSchemaValue<CUtlVector<GAABB_t>*>(m_ptr, "CSceneObjectData", "m_drawBounds"); std::vector<GAABB_t> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCSceneObjectData::SetDrawBounds(std::vector<GAABB_t> value) {
    SetSchemaValueCUtlVector<GAABB_t>(m_ptr, "CSceneObjectData", "m_drawBounds", false, value);
}
std::vector<GCMeshletDescriptor> GCSceneObjectData::GetMeshlets() const {
    CUtlVector<GCMeshletDescriptor>* vec = GetSchemaValue<CUtlVector<GCMeshletDescriptor>*>(m_ptr, "CSceneObjectData", "m_meshlets"); std::vector<GCMeshletDescriptor> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCSceneObjectData::SetMeshlets(std::vector<GCMeshletDescriptor> value) {
    SetSchemaValueCUtlVector<GCMeshletDescriptor>(m_ptr, "CSceneObjectData", "m_meshlets", false, value);
}
Vector4D GCSceneObjectData::GetTintColor() const {
    return GetSchemaValue<Vector4D>(m_ptr, "CSceneObjectData", "m_vTintColor");
}
void GCSceneObjectData::SetTintColor(Vector4D value) {
    SetSchemaValue(m_ptr, "CSceneObjectData", "m_vTintColor", false, value);
}
std::string GCSceneObjectData::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCSceneObjectData::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCSceneObjectData(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCSceneObjectData>("CSceneObjectData")
        .addConstructor<void (*)(std::string)>()
        .addProperty("MinBounds", &GCSceneObjectData::GetMinBounds, &GCSceneObjectData::SetMinBounds)
        .addProperty("MaxBounds", &GCSceneObjectData::GetMaxBounds, &GCSceneObjectData::SetMaxBounds)
        .addProperty("DrawCalls", &GCSceneObjectData::GetDrawCalls, &GCSceneObjectData::SetDrawCalls)
        .addProperty("DrawBounds", &GCSceneObjectData::GetDrawBounds, &GCSceneObjectData::SetDrawBounds)
        .addProperty("Meshlets", &GCSceneObjectData::GetMeshlets, &GCSceneObjectData::SetMeshlets)
        .addProperty("TintColor", &GCSceneObjectData::GetTintColor, &GCSceneObjectData::SetTintColor)
        .addFunction("ToPtr", &GCSceneObjectData::ToPtr)
        .addFunction("IsValid", &GCSceneObjectData::IsValid)
        .endClass();
}
GStanceInfo_t::GStanceInfo_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GStanceInfo_t::GStanceInfo_t(void *ptr) {
    m_ptr = ptr;
}
Vector GStanceInfo_t::GetPosition() const {
    return GetSchemaValue<Vector>(m_ptr, "StanceInfo_t", "m_vPosition");
}
void GStanceInfo_t::SetPosition(Vector value) {
    SetSchemaValue(m_ptr, "StanceInfo_t", "m_vPosition", true, value);
}
float GStanceInfo_t::GetDirection() const {
    return GetSchemaValue<float>(m_ptr, "StanceInfo_t", "m_flDirection");
}
void GStanceInfo_t::SetDirection(float value) {
    SetSchemaValue(m_ptr, "StanceInfo_t", "m_flDirection", true, value);
}
std::string GStanceInfo_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GStanceInfo_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassStanceInfo_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GStanceInfo_t>("StanceInfo_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Position", &GStanceInfo_t::GetPosition, &GStanceInfo_t::SetPosition)
        .addProperty("Direction", &GStanceInfo_t::GetDirection, &GStanceInfo_t::SetDirection)
        .addFunction("ToPtr", &GStanceInfo_t::ToPtr)
        .addFunction("IsValid", &GStanceInfo_t::IsValid)
        .endClass();
}
GCMotionNodeSequence::GCMotionNodeSequence(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCMotionNodeSequence::GCMotionNodeSequence(void *ptr) {
    m_ptr = ptr;
}
std::vector<GTagSpan_t> GCMotionNodeSequence::GetTags() const {
    CUtlVector<GTagSpan_t>* vec = GetSchemaValue<CUtlVector<GTagSpan_t>*>(m_ptr, "CMotionNodeSequence", "m_tags"); std::vector<GTagSpan_t> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCMotionNodeSequence::SetTags(std::vector<GTagSpan_t> value) {
    SetSchemaValueCUtlVector<GTagSpan_t>(m_ptr, "CMotionNodeSequence", "m_tags", false, value);
}
float GCMotionNodeSequence::GetPlaybackSpeed() const {
    return GetSchemaValue<float>(m_ptr, "CMotionNodeSequence", "m_flPlaybackSpeed");
}
void GCMotionNodeSequence::SetPlaybackSpeed(float value) {
    SetSchemaValue(m_ptr, "CMotionNodeSequence", "m_flPlaybackSpeed", false, value);
}
std::string GCMotionNodeSequence::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCMotionNodeSequence::IsValid() {
    return (m_ptr != nullptr);
}
GCMotionNode GCMotionNodeSequence::GetParent() const {
    GCMotionNode value(m_ptr);
    return value;
}
void GCMotionNodeSequence::SetParent(GCMotionNode value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCMotionNodeSequence(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCMotionNodeSequence>("CMotionNodeSequence")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Tags", &GCMotionNodeSequence::GetTags, &GCMotionNodeSequence::SetTags)
        .addProperty("PlaybackSpeed", &GCMotionNodeSequence::GetPlaybackSpeed, &GCMotionNodeSequence::SetPlaybackSpeed)
        .addProperty("Parent", &GCMotionNodeSequence::GetParent, &GCMotionNodeSequence::SetParent)
        .addFunction("ToPtr", &GCMotionNodeSequence::ToPtr)
        .addFunction("IsValid", &GCMotionNodeSequence::IsValid)
        .endClass();
}
GCFootCycleDefinition::GCFootCycleDefinition(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCFootCycleDefinition::GCFootCycleDefinition(void *ptr) {
    m_ptr = ptr;
}
Vector GCFootCycleDefinition::GetStancePositionMS() const {
    return GetSchemaValue<Vector>(m_ptr, "CFootCycleDefinition", "m_vStancePositionMS");
}
void GCFootCycleDefinition::SetStancePositionMS(Vector value) {
    SetSchemaValue(m_ptr, "CFootCycleDefinition", "m_vStancePositionMS", false, value);
}
Vector GCFootCycleDefinition::GetMidpointPositionMS() const {
    return GetSchemaValue<Vector>(m_ptr, "CFootCycleDefinition", "m_vMidpointPositionMS");
}
void GCFootCycleDefinition::SetMidpointPositionMS(Vector value) {
    SetSchemaValue(m_ptr, "CFootCycleDefinition", "m_vMidpointPositionMS", false, value);
}
float GCFootCycleDefinition::GetStanceDirectionMS() const {
    return GetSchemaValue<float>(m_ptr, "CFootCycleDefinition", "m_flStanceDirectionMS");
}
void GCFootCycleDefinition::SetStanceDirectionMS(float value) {
    SetSchemaValue(m_ptr, "CFootCycleDefinition", "m_flStanceDirectionMS", false, value);
}
Vector GCFootCycleDefinition::GetToStrideStartPos() const {
    return GetSchemaValue<Vector>(m_ptr, "CFootCycleDefinition", "m_vToStrideStartPos");
}
void GCFootCycleDefinition::SetToStrideStartPos(Vector value) {
    SetSchemaValue(m_ptr, "CFootCycleDefinition", "m_vToStrideStartPos", false, value);
}
GCAnimCycle GCFootCycleDefinition::GetStanceCycle() const {
    GCAnimCycle value(GetSchemaPtr(m_ptr, "CFootCycleDefinition", "m_stanceCycle"));
    return value;
}
void GCFootCycleDefinition::SetStanceCycle(GCAnimCycle value) {
    SetSchemaValue(m_ptr, "CFootCycleDefinition", "m_stanceCycle", false, value);
}
GCFootCycle GCFootCycleDefinition::GetFootLiftCycle() const {
    GCFootCycle value(GetSchemaPtr(m_ptr, "CFootCycleDefinition", "m_footLiftCycle"));
    return value;
}
void GCFootCycleDefinition::SetFootLiftCycle(GCFootCycle value) {
    SetSchemaValue(m_ptr, "CFootCycleDefinition", "m_footLiftCycle", false, value);
}
GCFootCycle GCFootCycleDefinition::GetFootOffCycle() const {
    GCFootCycle value(GetSchemaPtr(m_ptr, "CFootCycleDefinition", "m_footOffCycle"));
    return value;
}
void GCFootCycleDefinition::SetFootOffCycle(GCFootCycle value) {
    SetSchemaValue(m_ptr, "CFootCycleDefinition", "m_footOffCycle", false, value);
}
GCFootCycle GCFootCycleDefinition::GetFootStrikeCycle() const {
    GCFootCycle value(GetSchemaPtr(m_ptr, "CFootCycleDefinition", "m_footStrikeCycle"));
    return value;
}
void GCFootCycleDefinition::SetFootStrikeCycle(GCFootCycle value) {
    SetSchemaValue(m_ptr, "CFootCycleDefinition", "m_footStrikeCycle", false, value);
}
GCFootCycle GCFootCycleDefinition::GetFootLandCycle() const {
    GCFootCycle value(GetSchemaPtr(m_ptr, "CFootCycleDefinition", "m_footLandCycle"));
    return value;
}
void GCFootCycleDefinition::SetFootLandCycle(GCFootCycle value) {
    SetSchemaValue(m_ptr, "CFootCycleDefinition", "m_footLandCycle", false, value);
}
std::string GCFootCycleDefinition::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCFootCycleDefinition::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCFootCycleDefinition(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCFootCycleDefinition>("CFootCycleDefinition")
        .addConstructor<void (*)(std::string)>()
        .addProperty("StancePositionMS", &GCFootCycleDefinition::GetStancePositionMS, &GCFootCycleDefinition::SetStancePositionMS)
        .addProperty("MidpointPositionMS", &GCFootCycleDefinition::GetMidpointPositionMS, &GCFootCycleDefinition::SetMidpointPositionMS)
        .addProperty("StanceDirectionMS", &GCFootCycleDefinition::GetStanceDirectionMS, &GCFootCycleDefinition::SetStanceDirectionMS)
        .addProperty("ToStrideStartPos", &GCFootCycleDefinition::GetToStrideStartPos, &GCFootCycleDefinition::SetToStrideStartPos)
        .addProperty("StanceCycle", &GCFootCycleDefinition::GetStanceCycle, &GCFootCycleDefinition::SetStanceCycle)
        .addProperty("FootLiftCycle", &GCFootCycleDefinition::GetFootLiftCycle, &GCFootCycleDefinition::SetFootLiftCycle)
        .addProperty("FootOffCycle", &GCFootCycleDefinition::GetFootOffCycle, &GCFootCycleDefinition::SetFootOffCycle)
        .addProperty("FootStrikeCycle", &GCFootCycleDefinition::GetFootStrikeCycle, &GCFootCycleDefinition::SetFootStrikeCycle)
        .addProperty("FootLandCycle", &GCFootCycleDefinition::GetFootLandCycle, &GCFootCycleDefinition::SetFootLandCycle)
        .addFunction("ToPtr", &GCFootCycleDefinition::ToPtr)
        .addFunction("IsValid", &GCFootCycleDefinition::IsValid)
        .endClass();
}
GCAnimDesc_Flag::GCAnimDesc_Flag(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCAnimDesc_Flag::GCAnimDesc_Flag(void *ptr) {
    m_ptr = ptr;
}
bool GCAnimDesc_Flag::GetLooping() const {
    return GetSchemaValue<bool>(m_ptr, "CAnimDesc_Flag", "m_bLooping");
}
void GCAnimDesc_Flag::SetLooping(bool value) {
    SetSchemaValue(m_ptr, "CAnimDesc_Flag", "m_bLooping", false, value);
}
bool GCAnimDesc_Flag::GetAllZeros() const {
    return GetSchemaValue<bool>(m_ptr, "CAnimDesc_Flag", "m_bAllZeros");
}
void GCAnimDesc_Flag::SetAllZeros(bool value) {
    SetSchemaValue(m_ptr, "CAnimDesc_Flag", "m_bAllZeros", false, value);
}
bool GCAnimDesc_Flag::GetHidden() const {
    return GetSchemaValue<bool>(m_ptr, "CAnimDesc_Flag", "m_bHidden");
}
void GCAnimDesc_Flag::SetHidden(bool value) {
    SetSchemaValue(m_ptr, "CAnimDesc_Flag", "m_bHidden", false, value);
}
bool GCAnimDesc_Flag::GetDelta() const {
    return GetSchemaValue<bool>(m_ptr, "CAnimDesc_Flag", "m_bDelta");
}
void GCAnimDesc_Flag::SetDelta(bool value) {
    SetSchemaValue(m_ptr, "CAnimDesc_Flag", "m_bDelta", false, value);
}
bool GCAnimDesc_Flag::GetLegacyWorldspace() const {
    return GetSchemaValue<bool>(m_ptr, "CAnimDesc_Flag", "m_bLegacyWorldspace");
}
void GCAnimDesc_Flag::SetLegacyWorldspace(bool value) {
    SetSchemaValue(m_ptr, "CAnimDesc_Flag", "m_bLegacyWorldspace", false, value);
}
bool GCAnimDesc_Flag::GetModelDoc() const {
    return GetSchemaValue<bool>(m_ptr, "CAnimDesc_Flag", "m_bModelDoc");
}
void GCAnimDesc_Flag::SetModelDoc(bool value) {
    SetSchemaValue(m_ptr, "CAnimDesc_Flag", "m_bModelDoc", false, value);
}
bool GCAnimDesc_Flag::GetImplicitSeqIgnoreDelta() const {
    return GetSchemaValue<bool>(m_ptr, "CAnimDesc_Flag", "m_bImplicitSeqIgnoreDelta");
}
void GCAnimDesc_Flag::SetImplicitSeqIgnoreDelta(bool value) {
    SetSchemaValue(m_ptr, "CAnimDesc_Flag", "m_bImplicitSeqIgnoreDelta", false, value);
}
bool GCAnimDesc_Flag::GetAnimGraphAdditive() const {
    return GetSchemaValue<bool>(m_ptr, "CAnimDesc_Flag", "m_bAnimGraphAdditive");
}
void GCAnimDesc_Flag::SetAnimGraphAdditive(bool value) {
    SetSchemaValue(m_ptr, "CAnimDesc_Flag", "m_bAnimGraphAdditive", false, value);
}
std::string GCAnimDesc_Flag::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCAnimDesc_Flag::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCAnimDesc_Flag(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCAnimDesc_Flag>("CAnimDesc_Flag")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Looping", &GCAnimDesc_Flag::GetLooping, &GCAnimDesc_Flag::SetLooping)
        .addProperty("AllZeros", &GCAnimDesc_Flag::GetAllZeros, &GCAnimDesc_Flag::SetAllZeros)
        .addProperty("Hidden", &GCAnimDesc_Flag::GetHidden, &GCAnimDesc_Flag::SetHidden)
        .addProperty("Delta", &GCAnimDesc_Flag::GetDelta, &GCAnimDesc_Flag::SetDelta)
        .addProperty("LegacyWorldspace", &GCAnimDesc_Flag::GetLegacyWorldspace, &GCAnimDesc_Flag::SetLegacyWorldspace)
        .addProperty("ModelDoc", &GCAnimDesc_Flag::GetModelDoc, &GCAnimDesc_Flag::SetModelDoc)
        .addProperty("ImplicitSeqIgnoreDelta", &GCAnimDesc_Flag::GetImplicitSeqIgnoreDelta, &GCAnimDesc_Flag::SetImplicitSeqIgnoreDelta)
        .addProperty("AnimGraphAdditive", &GCAnimDesc_Flag::GetAnimGraphAdditive, &GCAnimDesc_Flag::SetAnimGraphAdditive)
        .addFunction("ToPtr", &GCAnimDesc_Flag::ToPtr)
        .addFunction("IsValid", &GCAnimDesc_Flag::IsValid)
        .endClass();
}
GCBoneVelocityMetricEvaluator::GCBoneVelocityMetricEvaluator(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCBoneVelocityMetricEvaluator::GCBoneVelocityMetricEvaluator(void *ptr) {
    m_ptr = ptr;
}
int32_t GCBoneVelocityMetricEvaluator::GetBoneIndex() const {
    return GetSchemaValue<int32_t>(m_ptr, "CBoneVelocityMetricEvaluator", "m_nBoneIndex");
}
void GCBoneVelocityMetricEvaluator::SetBoneIndex(int32_t value) {
    SetSchemaValue(m_ptr, "CBoneVelocityMetricEvaluator", "m_nBoneIndex", false, value);
}
std::string GCBoneVelocityMetricEvaluator::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCBoneVelocityMetricEvaluator::IsValid() {
    return (m_ptr != nullptr);
}
GCMotionMetricEvaluator GCBoneVelocityMetricEvaluator::GetParent() const {
    GCMotionMetricEvaluator value(m_ptr);
    return value;
}
void GCBoneVelocityMetricEvaluator::SetParent(GCMotionMetricEvaluator value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCBoneVelocityMetricEvaluator(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCBoneVelocityMetricEvaluator>("CBoneVelocityMetricEvaluator")
        .addConstructor<void (*)(std::string)>()
        .addProperty("BoneIndex", &GCBoneVelocityMetricEvaluator::GetBoneIndex, &GCBoneVelocityMetricEvaluator::SetBoneIndex)
        .addProperty("Parent", &GCBoneVelocityMetricEvaluator::GetParent, &GCBoneVelocityMetricEvaluator::SetParent)
        .addFunction("ToPtr", &GCBoneVelocityMetricEvaluator::ToPtr)
        .addFunction("IsValid", &GCBoneVelocityMetricEvaluator::IsValid)
        .endClass();
}
GCFuseProgram::GCFuseProgram(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCFuseProgram::GCFuseProgram(void *ptr) {
    m_ptr = ptr;
}
std::vector<uint8> GCFuseProgram::GetProgramBuffer() const {
    CUtlVector<uint8>* vec = GetSchemaValue<CUtlVector<uint8>*>(m_ptr, "CFuseProgram", "m_programBuffer"); std::vector<uint8> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCFuseProgram::SetProgramBuffer(std::vector<uint8> value) {
    SetSchemaValueCUtlVector<uint8>(m_ptr, "CFuseProgram", "m_programBuffer", false, value);
}
std::vector<GFuseVariableIndex_t> GCFuseProgram::GetVariablesRead() const {
    CUtlVector<GFuseVariableIndex_t>* vec = GetSchemaValue<CUtlVector<GFuseVariableIndex_t>*>(m_ptr, "CFuseProgram", "m_variablesRead"); std::vector<GFuseVariableIndex_t> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCFuseProgram::SetVariablesRead(std::vector<GFuseVariableIndex_t> value) {
    SetSchemaValueCUtlVector<GFuseVariableIndex_t>(m_ptr, "CFuseProgram", "m_variablesRead", false, value);
}
std::vector<GFuseVariableIndex_t> GCFuseProgram::GetVariablesWritten() const {
    CUtlVector<GFuseVariableIndex_t>* vec = GetSchemaValue<CUtlVector<GFuseVariableIndex_t>*>(m_ptr, "CFuseProgram", "m_variablesWritten"); std::vector<GFuseVariableIndex_t> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCFuseProgram::SetVariablesWritten(std::vector<GFuseVariableIndex_t> value) {
    SetSchemaValueCUtlVector<GFuseVariableIndex_t>(m_ptr, "CFuseProgram", "m_variablesWritten", false, value);
}
int32_t GCFuseProgram::GetMaxTempVarsUsed() const {
    return GetSchemaValue<int32_t>(m_ptr, "CFuseProgram", "m_nMaxTempVarsUsed");
}
void GCFuseProgram::SetMaxTempVarsUsed(int32_t value) {
    SetSchemaValue(m_ptr, "CFuseProgram", "m_nMaxTempVarsUsed", false, value);
}
std::string GCFuseProgram::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCFuseProgram::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCFuseProgram(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCFuseProgram>("CFuseProgram")
        .addConstructor<void (*)(std::string)>()
        .addProperty("ProgramBuffer", &GCFuseProgram::GetProgramBuffer, &GCFuseProgram::SetProgramBuffer)
        .addProperty("VariablesRead", &GCFuseProgram::GetVariablesRead, &GCFuseProgram::SetVariablesRead)
        .addProperty("VariablesWritten", &GCFuseProgram::GetVariablesWritten, &GCFuseProgram::SetVariablesWritten)
        .addProperty("MaxTempVarsUsed", &GCFuseProgram::GetMaxTempVarsUsed, &GCFuseProgram::SetMaxTempVarsUsed)
        .addFunction("ToPtr", &GCFuseProgram::ToPtr)
        .addFunction("IsValid", &GCFuseProgram::IsValid)
        .endClass();
}
GCFeVertexMapBuildArray::GCFeVertexMapBuildArray(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCFeVertexMapBuildArray::GCFeVertexMapBuildArray(void *ptr) {
    m_ptr = ptr;
}
std::vector<GFeVertexMapBuild_t*> GCFeVertexMapBuildArray::GetArray() const {
    CUtlVector<GFeVertexMapBuild_t*>* vec = GetSchemaValue<CUtlVector<GFeVertexMapBuild_t*>*>(m_ptr, "CFeVertexMapBuildArray", "m_Array"); std::vector<GFeVertexMapBuild_t*> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCFeVertexMapBuildArray::SetArray(std::vector<GFeVertexMapBuild_t*> value) {
    SetSchemaValueCUtlVector<GFeVertexMapBuild_t*>(m_ptr, "CFeVertexMapBuildArray", "m_Array", false, value);
}
std::string GCFeVertexMapBuildArray::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCFeVertexMapBuildArray::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCFeVertexMapBuildArray(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCFeVertexMapBuildArray>("CFeVertexMapBuildArray")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Array", &GCFeVertexMapBuildArray::GetArray, &GCFeVertexMapBuildArray::SetArray)
        .addFunction("ToPtr", &GCFeVertexMapBuildArray::ToPtr)
        .addFunction("IsValid", &GCFeVertexMapBuildArray::IsValid)
        .endClass();
}
GFeSoftParent_t::GFeSoftParent_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GFeSoftParent_t::GFeSoftParent_t(void *ptr) {
    m_ptr = ptr;
}
int32_t GFeSoftParent_t::GetParent() const {
    return GetSchemaValue<int32_t>(m_ptr, "FeSoftParent_t", "nParent");
}
void GFeSoftParent_t::SetParent(int32_t value) {
    SetSchemaValue(m_ptr, "FeSoftParent_t", "nParent", true, value);
}
float GFeSoftParent_t::GetAlpha() const {
    return GetSchemaValue<float>(m_ptr, "FeSoftParent_t", "flAlpha");
}
void GFeSoftParent_t::SetAlpha(float value) {
    SetSchemaValue(m_ptr, "FeSoftParent_t", "flAlpha", true, value);
}
std::string GFeSoftParent_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GFeSoftParent_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassFeSoftParent_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GFeSoftParent_t>("FeSoftParent_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GFeSoftParent_t::GetParent, &GFeSoftParent_t::SetParent)
        .addProperty("Alpha", &GFeSoftParent_t::GetAlpha, &GFeSoftParent_t::SetAlpha)
        .addFunction("ToPtr", &GFeSoftParent_t::ToPtr)
        .addFunction("IsValid", &GFeSoftParent_t::IsValid)
        .endClass();
}
GCFootFallAnimTag::GCFootFallAnimTag(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCFootFallAnimTag::GCFootFallAnimTag(void *ptr) {
    m_ptr = ptr;
}
uint64_t GCFootFallAnimTag::GetFoot() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CFootFallAnimTag", "m_foot");
}
void GCFootFallAnimTag::SetFoot(uint64_t value) {
    SetSchemaValue(m_ptr, "CFootFallAnimTag", "m_foot", false, value);
}
std::string GCFootFallAnimTag::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCFootFallAnimTag::IsValid() {
    return (m_ptr != nullptr);
}
GCAnimTagBase GCFootFallAnimTag::GetParent() const {
    GCAnimTagBase value(m_ptr);
    return value;
}
void GCFootFallAnimTag::SetParent(GCAnimTagBase value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCFootFallAnimTag(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCFootFallAnimTag>("CFootFallAnimTag")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Foot", &GCFootFallAnimTag::GetFoot, &GCFootFallAnimTag::SetFoot)
        .addProperty("Parent", &GCFootFallAnimTag::GetParent, &GCFootFallAnimTag::SetParent)
        .addFunction("ToPtr", &GCFootFallAnimTag::ToPtr)
        .addFunction("IsValid", &GCFootFallAnimTag::IsValid)
        .endClass();
}
GEventClientOutput_t::GEventClientOutput_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GEventClientOutput_t::GEventClientOutput_t(void *ptr) {
    m_ptr = ptr;
}
GEngineLoopState_t GEventClientOutput_t::GetLoopState() const {
    GEngineLoopState_t value(GetSchemaPtr(m_ptr, "EventClientOutput_t", "m_LoopState"));
    return value;
}
void GEventClientOutput_t::SetLoopState(GEngineLoopState_t value) {
    SetSchemaValue(m_ptr, "EventClientOutput_t", "m_LoopState", true, value);
}
float GEventClientOutput_t::GetRenderTime() const {
    return GetSchemaValue<float>(m_ptr, "EventClientOutput_t", "m_flRenderTime");
}
void GEventClientOutput_t::SetRenderTime(float value) {
    SetSchemaValue(m_ptr, "EventClientOutput_t", "m_flRenderTime", true, value);
}
float GEventClientOutput_t::GetRealTime() const {
    return GetSchemaValue<float>(m_ptr, "EventClientOutput_t", "m_flRealTime");
}
void GEventClientOutput_t::SetRealTime(float value) {
    SetSchemaValue(m_ptr, "EventClientOutput_t", "m_flRealTime", true, value);
}
float GEventClientOutput_t::GetRenderFrameTimeUnbounded() const {
    return GetSchemaValue<float>(m_ptr, "EventClientOutput_t", "m_flRenderFrameTimeUnbounded");
}
void GEventClientOutput_t::SetRenderFrameTimeUnbounded(float value) {
    SetSchemaValue(m_ptr, "EventClientOutput_t", "m_flRenderFrameTimeUnbounded", true, value);
}
bool GEventClientOutput_t::GetRenderOnly() const {
    return GetSchemaValue<bool>(m_ptr, "EventClientOutput_t", "m_bRenderOnly");
}
void GEventClientOutput_t::SetRenderOnly(bool value) {
    SetSchemaValue(m_ptr, "EventClientOutput_t", "m_bRenderOnly", true, value);
}
std::string GEventClientOutput_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GEventClientOutput_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassEventClientOutput_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GEventClientOutput_t>("EventClientOutput_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("LoopState", &GEventClientOutput_t::GetLoopState, &GEventClientOutput_t::SetLoopState)
        .addProperty("RenderTime", &GEventClientOutput_t::GetRenderTime, &GEventClientOutput_t::SetRenderTime)
        .addProperty("RealTime", &GEventClientOutput_t::GetRealTime, &GEventClientOutput_t::SetRealTime)
        .addProperty("RenderFrameTimeUnbounded", &GEventClientOutput_t::GetRenderFrameTimeUnbounded, &GEventClientOutput_t::SetRenderFrameTimeUnbounded)
        .addProperty("RenderOnly", &GEventClientOutput_t::GetRenderOnly, &GEventClientOutput_t::SetRenderOnly)
        .addFunction("ToPtr", &GEventClientOutput_t::ToPtr)
        .addFunction("IsValid", &GEventClientOutput_t::IsValid)
        .endClass();
}
GMaterialVariable_t::GMaterialVariable_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GMaterialVariable_t::GMaterialVariable_t(void *ptr) {
    m_ptr = ptr;
}
std::string GMaterialVariable_t::GetStrVariable() const {
    return GetSchemaValue<CUtlString>(m_ptr, "MaterialVariable_t", "m_strVariable").Get();
}
void GMaterialVariable_t::SetStrVariable(std::string value) {
    SetSchemaValue(m_ptr, "MaterialVariable_t", "m_strVariable", true, CUtlString(value.c_str()));
}
GParticleAttributeIndex_t GMaterialVariable_t::GetVariableField() const {
    GParticleAttributeIndex_t value(GetSchemaPtr(m_ptr, "MaterialVariable_t", "m_nVariableField"));
    return value;
}
void GMaterialVariable_t::SetVariableField(GParticleAttributeIndex_t value) {
    SetSchemaValue(m_ptr, "MaterialVariable_t", "m_nVariableField", true, value);
}
float GMaterialVariable_t::GetScale() const {
    return GetSchemaValue<float>(m_ptr, "MaterialVariable_t", "m_flScale");
}
void GMaterialVariable_t::SetScale(float value) {
    SetSchemaValue(m_ptr, "MaterialVariable_t", "m_flScale", true, value);
}
std::string GMaterialVariable_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GMaterialVariable_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassMaterialVariable_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GMaterialVariable_t>("MaterialVariable_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("StrVariable", &GMaterialVariable_t::GetStrVariable, &GMaterialVariable_t::SetStrVariable)
        .addProperty("VariableField", &GMaterialVariable_t::GetVariableField, &GMaterialVariable_t::SetVariableField)
        .addProperty("Scale", &GMaterialVariable_t::GetScale, &GMaterialVariable_t::SetScale)
        .addFunction("ToPtr", &GMaterialVariable_t::ToPtr)
        .addFunction("IsValid", &GMaterialVariable_t::IsValid)
        .endClass();
}
GCFeNamedJiggleBone::GCFeNamedJiggleBone(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCFeNamedJiggleBone::GCFeNamedJiggleBone(void *ptr) {
    m_ptr = ptr;
}
std::string GCFeNamedJiggleBone::GetStrParentBone() const {
    return GetSchemaValue<CUtlString>(m_ptr, "CFeNamedJiggleBone", "m_strParentBone").Get();
}
void GCFeNamedJiggleBone::SetStrParentBone(std::string value) {
    SetSchemaValue(m_ptr, "CFeNamedJiggleBone", "m_strParentBone", false, CUtlString(value.c_str()));
}
uint32_t GCFeNamedJiggleBone::GetJiggleParent() const {
    return GetSchemaValue<uint32_t>(m_ptr, "CFeNamedJiggleBone", "m_nJiggleParent");
}
void GCFeNamedJiggleBone::SetJiggleParent(uint32_t value) {
    SetSchemaValue(m_ptr, "CFeNamedJiggleBone", "m_nJiggleParent", false, value);
}
GCFeJiggleBone GCFeNamedJiggleBone::GetJiggleBone() const {
    GCFeJiggleBone value(GetSchemaPtr(m_ptr, "CFeNamedJiggleBone", "m_jiggleBone"));
    return value;
}
void GCFeNamedJiggleBone::SetJiggleBone(GCFeJiggleBone value) {
    SetSchemaValue(m_ptr, "CFeNamedJiggleBone", "m_jiggleBone", false, value);
}
std::string GCFeNamedJiggleBone::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCFeNamedJiggleBone::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCFeNamedJiggleBone(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCFeNamedJiggleBone>("CFeNamedJiggleBone")
        .addConstructor<void (*)(std::string)>()
        .addProperty("StrParentBone", &GCFeNamedJiggleBone::GetStrParentBone, &GCFeNamedJiggleBone::SetStrParentBone)
        .addProperty("JiggleParent", &GCFeNamedJiggleBone::GetJiggleParent, &GCFeNamedJiggleBone::SetJiggleParent)
        .addProperty("JiggleBone", &GCFeNamedJiggleBone::GetJiggleBone, &GCFeNamedJiggleBone::SetJiggleBone)
        .addFunction("ToPtr", &GCFeNamedJiggleBone::ToPtr)
        .addFunction("IsValid", &GCFeNamedJiggleBone::IsValid)
        .endClass();
}
GEventClientProcessInput_t::GEventClientProcessInput_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GEventClientProcessInput_t::GEventClientProcessInput_t(void *ptr) {
    m_ptr = ptr;
}
GEngineLoopState_t GEventClientProcessInput_t::GetLoopState() const {
    GEngineLoopState_t value(GetSchemaPtr(m_ptr, "EventClientProcessInput_t", "m_LoopState"));
    return value;
}
void GEventClientProcessInput_t::SetLoopState(GEngineLoopState_t value) {
    SetSchemaValue(m_ptr, "EventClientProcessInput_t", "m_LoopState", true, value);
}
float GEventClientProcessInput_t::GetRealTime() const {
    return GetSchemaValue<float>(m_ptr, "EventClientProcessInput_t", "m_flRealTime");
}
void GEventClientProcessInput_t::SetRealTime(float value) {
    SetSchemaValue(m_ptr, "EventClientProcessInput_t", "m_flRealTime", true, value);
}
float GEventClientProcessInput_t::GetTickInterval() const {
    return GetSchemaValue<float>(m_ptr, "EventClientProcessInput_t", "m_flTickInterval");
}
void GEventClientProcessInput_t::SetTickInterval(float value) {
    SetSchemaValue(m_ptr, "EventClientProcessInput_t", "m_flTickInterval", true, value);
}
double GEventClientProcessInput_t::GetTickStartTime() const {
    return GetSchemaValue<double>(m_ptr, "EventClientProcessInput_t", "m_flTickStartTime");
}
void GEventClientProcessInput_t::SetTickStartTime(double value) {
    SetSchemaValue(m_ptr, "EventClientProcessInput_t", "m_flTickStartTime", true, value);
}
std::string GEventClientProcessInput_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GEventClientProcessInput_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassEventClientProcessInput_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GEventClientProcessInput_t>("EventClientProcessInput_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("LoopState", &GEventClientProcessInput_t::GetLoopState, &GEventClientProcessInput_t::SetLoopState)
        .addProperty("RealTime", &GEventClientProcessInput_t::GetRealTime, &GEventClientProcessInput_t::SetRealTime)
        .addProperty("TickInterval", &GEventClientProcessInput_t::GetTickInterval, &GEventClientProcessInput_t::SetTickInterval)
        .addProperty("TickStartTime", &GEventClientProcessInput_t::GetTickStartTime, &GEventClientProcessInput_t::SetTickStartTime)
        .addFunction("ToPtr", &GEventClientProcessInput_t::ToPtr)
        .addFunction("IsValid", &GEventClientProcessInput_t::IsValid)
        .endClass();
}
GJiggleBoneSettingsList_t::GJiggleBoneSettingsList_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GJiggleBoneSettingsList_t::GJiggleBoneSettingsList_t(void *ptr) {
    m_ptr = ptr;
}
std::vector<GJiggleBoneSettings_t> GJiggleBoneSettingsList_t::GetBoneSettings() const {
    CUtlVector<GJiggleBoneSettings_t>* vec = GetSchemaValue<CUtlVector<GJiggleBoneSettings_t>*>(m_ptr, "JiggleBoneSettingsList_t", "m_boneSettings"); std::vector<GJiggleBoneSettings_t> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GJiggleBoneSettingsList_t::SetBoneSettings(std::vector<GJiggleBoneSettings_t> value) {
    SetSchemaValueCUtlVector<GJiggleBoneSettings_t>(m_ptr, "JiggleBoneSettingsList_t", "m_boneSettings", true, value);
}
std::string GJiggleBoneSettingsList_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GJiggleBoneSettingsList_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassJiggleBoneSettingsList_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GJiggleBoneSettingsList_t>("JiggleBoneSettingsList_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("BoneSettings", &GJiggleBoneSettingsList_t::GetBoneSettings, &GJiggleBoneSettingsList_t::SetBoneSettings)
        .addFunction("ToPtr", &GJiggleBoneSettingsList_t::ToPtr)
        .addFunction("IsValid", &GJiggleBoneSettingsList_t::IsValid)
        .endClass();
}
GCSequenceFinishedAnimTag::GCSequenceFinishedAnimTag(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCSequenceFinishedAnimTag::GCSequenceFinishedAnimTag(void *ptr) {
    m_ptr = ptr;
}
std::string GCSequenceFinishedAnimTag::GetSequenceName() const {
    return GetSchemaValue<CUtlString>(m_ptr, "CSequenceFinishedAnimTag", "m_sequenceName").Get();
}
void GCSequenceFinishedAnimTag::SetSequenceName(std::string value) {
    SetSchemaValue(m_ptr, "CSequenceFinishedAnimTag", "m_sequenceName", false, CUtlString(value.c_str()));
}
std::string GCSequenceFinishedAnimTag::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCSequenceFinishedAnimTag::IsValid() {
    return (m_ptr != nullptr);
}
GCAnimTagBase GCSequenceFinishedAnimTag::GetParent() const {
    GCAnimTagBase value(m_ptr);
    return value;
}
void GCSequenceFinishedAnimTag::SetParent(GCAnimTagBase value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCSequenceFinishedAnimTag(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCSequenceFinishedAnimTag>("CSequenceFinishedAnimTag")
        .addConstructor<void (*)(std::string)>()
        .addProperty("SequenceName", &GCSequenceFinishedAnimTag::GetSequenceName, &GCSequenceFinishedAnimTag::SetSequenceName)
        .addProperty("Parent", &GCSequenceFinishedAnimTag::GetParent, &GCSequenceFinishedAnimTag::SetParent)
        .addFunction("ToPtr", &GCSequenceFinishedAnimTag::ToPtr)
        .addFunction("IsValid", &GCSequenceFinishedAnimTag::IsValid)
        .endClass();
}
GCAnimationGraphVisualizerText::GCAnimationGraphVisualizerText(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCAnimationGraphVisualizerText::GCAnimationGraphVisualizerText(void *ptr) {
    m_ptr = ptr;
}
Vector GCAnimationGraphVisualizerText::GetWsPosition() const {
    return GetSchemaValue<Vector>(m_ptr, "CAnimationGraphVisualizerText", "m_vWsPosition");
}
void GCAnimationGraphVisualizerText::SetWsPosition(Vector value) {
    SetSchemaValue(m_ptr, "CAnimationGraphVisualizerText", "m_vWsPosition", false, value);
}
Color GCAnimationGraphVisualizerText::GetColor() const {
    return GetSchemaValue<Color>(m_ptr, "CAnimationGraphVisualizerText", "m_Color");
}
void GCAnimationGraphVisualizerText::SetColor(Color value) {
    SetSchemaValue(m_ptr, "CAnimationGraphVisualizerText", "m_Color", false, value);
}
std::string GCAnimationGraphVisualizerText::GetText() const {
    return GetSchemaValue<CUtlString>(m_ptr, "CAnimationGraphVisualizerText", "m_Text").Get();
}
void GCAnimationGraphVisualizerText::SetText(std::string value) {
    SetSchemaValue(m_ptr, "CAnimationGraphVisualizerText", "m_Text", false, CUtlString(value.c_str()));
}
std::string GCAnimationGraphVisualizerText::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCAnimationGraphVisualizerText::IsValid() {
    return (m_ptr != nullptr);
}
GCAnimationGraphVisualizerPrimitiveBase GCAnimationGraphVisualizerText::GetParent() const {
    GCAnimationGraphVisualizerPrimitiveBase value(m_ptr);
    return value;
}
void GCAnimationGraphVisualizerText::SetParent(GCAnimationGraphVisualizerPrimitiveBase value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCAnimationGraphVisualizerText(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCAnimationGraphVisualizerText>("CAnimationGraphVisualizerText")
        .addConstructor<void (*)(std::string)>()
        .addProperty("WsPosition", &GCAnimationGraphVisualizerText::GetWsPosition, &GCAnimationGraphVisualizerText::SetWsPosition)
        .addProperty("Color", &GCAnimationGraphVisualizerText::GetColor, &GCAnimationGraphVisualizerText::SetColor)
        .addProperty("Text", &GCAnimationGraphVisualizerText::GetText, &GCAnimationGraphVisualizerText::SetText)
        .addProperty("Parent", &GCAnimationGraphVisualizerText::GetParent, &GCAnimationGraphVisualizerText::SetParent)
        .addFunction("ToPtr", &GCAnimationGraphVisualizerText::ToPtr)
        .addFunction("IsValid", &GCAnimationGraphVisualizerText::IsValid)
        .endClass();
}
GCDampedPathAnimMotorUpdater::GCDampedPathAnimMotorUpdater(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCDampedPathAnimMotorUpdater::GCDampedPathAnimMotorUpdater(void *ptr) {
    m_ptr = ptr;
}
float GCDampedPathAnimMotorUpdater::GetAnticipationTime() const {
    return GetSchemaValue<float>(m_ptr, "CDampedPathAnimMotorUpdater", "m_flAnticipationTime");
}
void GCDampedPathAnimMotorUpdater::SetAnticipationTime(float value) {
    SetSchemaValue(m_ptr, "CDampedPathAnimMotorUpdater", "m_flAnticipationTime", false, value);
}
float GCDampedPathAnimMotorUpdater::GetMinSpeedScale() const {
    return GetSchemaValue<float>(m_ptr, "CDampedPathAnimMotorUpdater", "m_flMinSpeedScale");
}
void GCDampedPathAnimMotorUpdater::SetMinSpeedScale(float value) {
    SetSchemaValue(m_ptr, "CDampedPathAnimMotorUpdater", "m_flMinSpeedScale", false, value);
}
GCAnimParamHandle GCDampedPathAnimMotorUpdater::GetAnticipationPosParam() const {
    GCAnimParamHandle value(GetSchemaPtr(m_ptr, "CDampedPathAnimMotorUpdater", "m_hAnticipationPosParam"));
    return value;
}
void GCDampedPathAnimMotorUpdater::SetAnticipationPosParam(GCAnimParamHandle value) {
    SetSchemaValue(m_ptr, "CDampedPathAnimMotorUpdater", "m_hAnticipationPosParam", false, value);
}
GCAnimParamHandle GCDampedPathAnimMotorUpdater::GetAnticipationHeadingParam() const {
    GCAnimParamHandle value(GetSchemaPtr(m_ptr, "CDampedPathAnimMotorUpdater", "m_hAnticipationHeadingParam"));
    return value;
}
void GCDampedPathAnimMotorUpdater::SetAnticipationHeadingParam(GCAnimParamHandle value) {
    SetSchemaValue(m_ptr, "CDampedPathAnimMotorUpdater", "m_hAnticipationHeadingParam", false, value);
}
float GCDampedPathAnimMotorUpdater::GetSpringConstant() const {
    return GetSchemaValue<float>(m_ptr, "CDampedPathAnimMotorUpdater", "m_flSpringConstant");
}
void GCDampedPathAnimMotorUpdater::SetSpringConstant(float value) {
    SetSchemaValue(m_ptr, "CDampedPathAnimMotorUpdater", "m_flSpringConstant", false, value);
}
float GCDampedPathAnimMotorUpdater::GetMinSpringTension() const {
    return GetSchemaValue<float>(m_ptr, "CDampedPathAnimMotorUpdater", "m_flMinSpringTension");
}
void GCDampedPathAnimMotorUpdater::SetMinSpringTension(float value) {
    SetSchemaValue(m_ptr, "CDampedPathAnimMotorUpdater", "m_flMinSpringTension", false, value);
}
float GCDampedPathAnimMotorUpdater::GetMaxSpringTension() const {
    return GetSchemaValue<float>(m_ptr, "CDampedPathAnimMotorUpdater", "m_flMaxSpringTension");
}
void GCDampedPathAnimMotorUpdater::SetMaxSpringTension(float value) {
    SetSchemaValue(m_ptr, "CDampedPathAnimMotorUpdater", "m_flMaxSpringTension", false, value);
}
std::string GCDampedPathAnimMotorUpdater::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCDampedPathAnimMotorUpdater::IsValid() {
    return (m_ptr != nullptr);
}
GCPathAnimMotorUpdaterBase GCDampedPathAnimMotorUpdater::GetParent() const {
    GCPathAnimMotorUpdaterBase value(m_ptr);
    return value;
}
void GCDampedPathAnimMotorUpdater::SetParent(GCPathAnimMotorUpdaterBase value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCDampedPathAnimMotorUpdater(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCDampedPathAnimMotorUpdater>("CDampedPathAnimMotorUpdater")
        .addConstructor<void (*)(std::string)>()
        .addProperty("AnticipationTime", &GCDampedPathAnimMotorUpdater::GetAnticipationTime, &GCDampedPathAnimMotorUpdater::SetAnticipationTime)
        .addProperty("MinSpeedScale", &GCDampedPathAnimMotorUpdater::GetMinSpeedScale, &GCDampedPathAnimMotorUpdater::SetMinSpeedScale)
        .addProperty("AnticipationPosParam", &GCDampedPathAnimMotorUpdater::GetAnticipationPosParam, &GCDampedPathAnimMotorUpdater::SetAnticipationPosParam)
        .addProperty("AnticipationHeadingParam", &GCDampedPathAnimMotorUpdater::GetAnticipationHeadingParam, &GCDampedPathAnimMotorUpdater::SetAnticipationHeadingParam)
        .addProperty("SpringConstant", &GCDampedPathAnimMotorUpdater::GetSpringConstant, &GCDampedPathAnimMotorUpdater::SetSpringConstant)
        .addProperty("MinSpringTension", &GCDampedPathAnimMotorUpdater::GetMinSpringTension, &GCDampedPathAnimMotorUpdater::SetMinSpringTension)
        .addProperty("MaxSpringTension", &GCDampedPathAnimMotorUpdater::GetMaxSpringTension, &GCDampedPathAnimMotorUpdater::SetMaxSpringTension)
        .addProperty("Parent", &GCDampedPathAnimMotorUpdater::GetParent, &GCDampedPathAnimMotorUpdater::SetParent)
        .addFunction("ToPtr", &GCDampedPathAnimMotorUpdater::ToPtr)
        .addFunction("IsValid", &GCDampedPathAnimMotorUpdater::IsValid)
        .endClass();
}
GLookAtOpFixedSettings_t::GLookAtOpFixedSettings_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GLookAtOpFixedSettings_t::GLookAtOpFixedSettings_t(void *ptr) {
    m_ptr = ptr;
}
GCAnimAttachment GLookAtOpFixedSettings_t::GetAttachment() const {
    GCAnimAttachment value(GetSchemaPtr(m_ptr, "LookAtOpFixedSettings_t", "m_attachment"));
    return value;
}
void GLookAtOpFixedSettings_t::SetAttachment(GCAnimAttachment value) {
    SetSchemaValue(m_ptr, "LookAtOpFixedSettings_t", "m_attachment", true, value);
}
GCAnimInputDamping GLookAtOpFixedSettings_t::GetDamping() const {
    GCAnimInputDamping value(GetSchemaPtr(m_ptr, "LookAtOpFixedSettings_t", "m_damping"));
    return value;
}
void GLookAtOpFixedSettings_t::SetDamping(GCAnimInputDamping value) {
    SetSchemaValue(m_ptr, "LookAtOpFixedSettings_t", "m_damping", true, value);
}
std::vector<GLookAtBone_t> GLookAtOpFixedSettings_t::GetBones() const {
    CUtlVector<GLookAtBone_t>* vec = GetSchemaValue<CUtlVector<GLookAtBone_t>*>(m_ptr, "LookAtOpFixedSettings_t", "m_bones"); std::vector<GLookAtBone_t> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GLookAtOpFixedSettings_t::SetBones(std::vector<GLookAtBone_t> value) {
    SetSchemaValueCUtlVector<GLookAtBone_t>(m_ptr, "LookAtOpFixedSettings_t", "m_bones", true, value);
}
float GLookAtOpFixedSettings_t::GetYawLimit() const {
    return GetSchemaValue<float>(m_ptr, "LookAtOpFixedSettings_t", "m_flYawLimit");
}
void GLookAtOpFixedSettings_t::SetYawLimit(float value) {
    SetSchemaValue(m_ptr, "LookAtOpFixedSettings_t", "m_flYawLimit", true, value);
}
float GLookAtOpFixedSettings_t::GetPitchLimit() const {
    return GetSchemaValue<float>(m_ptr, "LookAtOpFixedSettings_t", "m_flPitchLimit");
}
void GLookAtOpFixedSettings_t::SetPitchLimit(float value) {
    SetSchemaValue(m_ptr, "LookAtOpFixedSettings_t", "m_flPitchLimit", true, value);
}
float GLookAtOpFixedSettings_t::GetHysteresisInnerAngle() const {
    return GetSchemaValue<float>(m_ptr, "LookAtOpFixedSettings_t", "m_flHysteresisInnerAngle");
}
void GLookAtOpFixedSettings_t::SetHysteresisInnerAngle(float value) {
    SetSchemaValue(m_ptr, "LookAtOpFixedSettings_t", "m_flHysteresisInnerAngle", true, value);
}
float GLookAtOpFixedSettings_t::GetHysteresisOuterAngle() const {
    return GetSchemaValue<float>(m_ptr, "LookAtOpFixedSettings_t", "m_flHysteresisOuterAngle");
}
void GLookAtOpFixedSettings_t::SetHysteresisOuterAngle(float value) {
    SetSchemaValue(m_ptr, "LookAtOpFixedSettings_t", "m_flHysteresisOuterAngle", true, value);
}
bool GLookAtOpFixedSettings_t::GetRotateYawForward() const {
    return GetSchemaValue<bool>(m_ptr, "LookAtOpFixedSettings_t", "m_bRotateYawForward");
}
void GLookAtOpFixedSettings_t::SetRotateYawForward(bool value) {
    SetSchemaValue(m_ptr, "LookAtOpFixedSettings_t", "m_bRotateYawForward", true, value);
}
bool GLookAtOpFixedSettings_t::GetMaintainUpDirection() const {
    return GetSchemaValue<bool>(m_ptr, "LookAtOpFixedSettings_t", "m_bMaintainUpDirection");
}
void GLookAtOpFixedSettings_t::SetMaintainUpDirection(bool value) {
    SetSchemaValue(m_ptr, "LookAtOpFixedSettings_t", "m_bMaintainUpDirection", true, value);
}
bool GLookAtOpFixedSettings_t::GetTargetIsPosition() const {
    return GetSchemaValue<bool>(m_ptr, "LookAtOpFixedSettings_t", "m_bTargetIsPosition");
}
void GLookAtOpFixedSettings_t::SetTargetIsPosition(bool value) {
    SetSchemaValue(m_ptr, "LookAtOpFixedSettings_t", "m_bTargetIsPosition", true, value);
}
bool GLookAtOpFixedSettings_t::GetUseHysteresis() const {
    return GetSchemaValue<bool>(m_ptr, "LookAtOpFixedSettings_t", "m_bUseHysteresis");
}
void GLookAtOpFixedSettings_t::SetUseHysteresis(bool value) {
    SetSchemaValue(m_ptr, "LookAtOpFixedSettings_t", "m_bUseHysteresis", true, value);
}
std::string GLookAtOpFixedSettings_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GLookAtOpFixedSettings_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassLookAtOpFixedSettings_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GLookAtOpFixedSettings_t>("LookAtOpFixedSettings_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Attachment", &GLookAtOpFixedSettings_t::GetAttachment, &GLookAtOpFixedSettings_t::SetAttachment)
        .addProperty("Damping", &GLookAtOpFixedSettings_t::GetDamping, &GLookAtOpFixedSettings_t::SetDamping)
        .addProperty("Bones", &GLookAtOpFixedSettings_t::GetBones, &GLookAtOpFixedSettings_t::SetBones)
        .addProperty("YawLimit", &GLookAtOpFixedSettings_t::GetYawLimit, &GLookAtOpFixedSettings_t::SetYawLimit)
        .addProperty("PitchLimit", &GLookAtOpFixedSettings_t::GetPitchLimit, &GLookAtOpFixedSettings_t::SetPitchLimit)
        .addProperty("HysteresisInnerAngle", &GLookAtOpFixedSettings_t::GetHysteresisInnerAngle, &GLookAtOpFixedSettings_t::SetHysteresisInnerAngle)
        .addProperty("HysteresisOuterAngle", &GLookAtOpFixedSettings_t::GetHysteresisOuterAngle, &GLookAtOpFixedSettings_t::SetHysteresisOuterAngle)
        .addProperty("RotateYawForward", &GLookAtOpFixedSettings_t::GetRotateYawForward, &GLookAtOpFixedSettings_t::SetRotateYawForward)
        .addProperty("MaintainUpDirection", &GLookAtOpFixedSettings_t::GetMaintainUpDirection, &GLookAtOpFixedSettings_t::SetMaintainUpDirection)
        .addProperty("TargetIsPosition", &GLookAtOpFixedSettings_t::GetTargetIsPosition, &GLookAtOpFixedSettings_t::SetTargetIsPosition)
        .addProperty("UseHysteresis", &GLookAtOpFixedSettings_t::GetUseHysteresis, &GLookAtOpFixedSettings_t::SetUseHysteresis)
        .addFunction("ToPtr", &GLookAtOpFixedSettings_t::ToPtr)
        .addFunction("IsValid", &GLookAtOpFixedSettings_t::IsValid)
        .endClass();
}
GCEntityIOOutput::GCEntityIOOutput(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCEntityIOOutput::GCEntityIOOutput(void *ptr) {
    m_ptr = ptr;
}
std::string GCEntityIOOutput::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCEntityIOOutput::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCEntityIOOutput(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCEntityIOOutput>("CEntityIOOutput")
        .addConstructor<void (*)(std::string)>()
        .addFunction("ToPtr", &GCEntityIOOutput::ToPtr)
        .addFunction("IsValid", &GCEntityIOOutput::IsValid)
        .endClass();
}
GCDSPPresetMixgroupModifierTable::GCDSPPresetMixgroupModifierTable(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCDSPPresetMixgroupModifierTable::GCDSPPresetMixgroupModifierTable(void *ptr) {
    m_ptr = ptr;
}
std::vector<GCDspPresetModifierList> GCDSPPresetMixgroupModifierTable::GetTable() const {
    CUtlVector<GCDspPresetModifierList>* vec = GetSchemaValue<CUtlVector<GCDspPresetModifierList>*>(m_ptr, "CDSPPresetMixgroupModifierTable", "m_table"); std::vector<GCDspPresetModifierList> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCDSPPresetMixgroupModifierTable::SetTable(std::vector<GCDspPresetModifierList> value) {
    SetSchemaValueCUtlVector<GCDspPresetModifierList>(m_ptr, "CDSPPresetMixgroupModifierTable", "m_table", false, value);
}
std::string GCDSPPresetMixgroupModifierTable::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCDSPPresetMixgroupModifierTable::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCDSPPresetMixgroupModifierTable(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCDSPPresetMixgroupModifierTable>("CDSPPresetMixgroupModifierTable")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Table", &GCDSPPresetMixgroupModifierTable::GetTable, &GCDSPPresetMixgroupModifierTable::SetTable)
        .addFunction("ToPtr", &GCDSPPresetMixgroupModifierTable::ToPtr)
        .addFunction("IsValid", &GCDSPPresetMixgroupModifierTable::IsValid)
        .endClass();
}
GRnWing_t::GRnWing_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GRnWing_t::GRnWing_t(void *ptr) {
    m_ptr = ptr;
}
std::vector<int32_t> GRnWing_t::GetIndex() const {
    int32_t* outValue = GetSchemaValue<int32_t*>(m_ptr, "RnWing_t", "m_nIndex"); std::vector<int32_t> ret; for(int i = 0; i < 3; i++) { ret.push_back(outValue[i]); } return ret;
}
void GRnWing_t::SetIndex(std::vector<int32_t> value) {
    int32_t* outValue = GetSchemaValue<int32_t*>(m_ptr, "RnWing_t", "m_nIndex"); for(int i = 0; i < 3; i++) { outValue[i] = value[i]; } SetSchemaValue(m_ptr, "RnWing_t", "m_nIndex", true, outValue);
}
std::string GRnWing_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GRnWing_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassRnWing_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GRnWing_t>("RnWing_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Index", &GRnWing_t::GetIndex, &GRnWing_t::SetIndex)
        .addFunction("ToPtr", &GRnWing_t::ToPtr)
        .addFunction("IsValid", &GRnWing_t::IsValid)
        .endClass();
}
GCNmChildGraphNode::GCNmChildGraphNode(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCNmChildGraphNode::GCNmChildGraphNode(void *ptr) {
    m_ptr = ptr;
}
int16_t GCNmChildGraphNode::GetChildGraphIdx() const {
    return GetSchemaValue<int16_t>(m_ptr, "CNmChildGraphNode", "m_nChildGraphIdx");
}
void GCNmChildGraphNode::SetChildGraphIdx(int16_t value) {
    SetSchemaValue(m_ptr, "CNmChildGraphNode", "m_nChildGraphIdx", false, value);
}
std::string GCNmChildGraphNode::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCNmChildGraphNode::IsValid() {
    return (m_ptr != nullptr);
}
GCNmPoseNode GCNmChildGraphNode::GetParent() const {
    GCNmPoseNode value(m_ptr);
    return value;
}
void GCNmChildGraphNode::SetParent(GCNmPoseNode value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCNmChildGraphNode(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCNmChildGraphNode>("CNmChildGraphNode")
        .addConstructor<void (*)(std::string)>()
        .addProperty("ChildGraphIdx", &GCNmChildGraphNode::GetChildGraphIdx, &GCNmChildGraphNode::SetChildGraphIdx)
        .addProperty("Parent", &GCNmChildGraphNode::GetParent, &GCNmChildGraphNode::SetParent)
        .addFunction("ToPtr", &GCNmChildGraphNode::ToPtr)
        .addFunction("IsValid", &GCNmChildGraphNode::IsValid)
        .endClass();
}
GVMixPlateverbDesc_t::GVMixPlateverbDesc_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GVMixPlateverbDesc_t::GVMixPlateverbDesc_t(void *ptr) {
    m_ptr = ptr;
}
float GVMixPlateverbDesc_t::GetPrefilter() const {
    return GetSchemaValue<float>(m_ptr, "VMixPlateverbDesc_t", "m_flPrefilter");
}
void GVMixPlateverbDesc_t::SetPrefilter(float value) {
    SetSchemaValue(m_ptr, "VMixPlateverbDesc_t", "m_flPrefilter", true, value);
}
float GVMixPlateverbDesc_t::GetInputDiffusion1() const {
    return GetSchemaValue<float>(m_ptr, "VMixPlateverbDesc_t", "m_flInputDiffusion1");
}
void GVMixPlateverbDesc_t::SetInputDiffusion1(float value) {
    SetSchemaValue(m_ptr, "VMixPlateverbDesc_t", "m_flInputDiffusion1", true, value);
}
float GVMixPlateverbDesc_t::GetInputDiffusion2() const {
    return GetSchemaValue<float>(m_ptr, "VMixPlateverbDesc_t", "m_flInputDiffusion2");
}
void GVMixPlateverbDesc_t::SetInputDiffusion2(float value) {
    SetSchemaValue(m_ptr, "VMixPlateverbDesc_t", "m_flInputDiffusion2", true, value);
}
float GVMixPlateverbDesc_t::GetDecay() const {
    return GetSchemaValue<float>(m_ptr, "VMixPlateverbDesc_t", "m_flDecay");
}
void GVMixPlateverbDesc_t::SetDecay(float value) {
    SetSchemaValue(m_ptr, "VMixPlateverbDesc_t", "m_flDecay", true, value);
}
float GVMixPlateverbDesc_t::GetDamp() const {
    return GetSchemaValue<float>(m_ptr, "VMixPlateverbDesc_t", "m_flDamp");
}
void GVMixPlateverbDesc_t::SetDamp(float value) {
    SetSchemaValue(m_ptr, "VMixPlateverbDesc_t", "m_flDamp", true, value);
}
float GVMixPlateverbDesc_t::GetFeedbackDiffusion1() const {
    return GetSchemaValue<float>(m_ptr, "VMixPlateverbDesc_t", "m_flFeedbackDiffusion1");
}
void GVMixPlateverbDesc_t::SetFeedbackDiffusion1(float value) {
    SetSchemaValue(m_ptr, "VMixPlateverbDesc_t", "m_flFeedbackDiffusion1", true, value);
}
float GVMixPlateverbDesc_t::GetFeedbackDiffusion2() const {
    return GetSchemaValue<float>(m_ptr, "VMixPlateverbDesc_t", "m_flFeedbackDiffusion2");
}
void GVMixPlateverbDesc_t::SetFeedbackDiffusion2(float value) {
    SetSchemaValue(m_ptr, "VMixPlateverbDesc_t", "m_flFeedbackDiffusion2", true, value);
}
std::string GVMixPlateverbDesc_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GVMixPlateverbDesc_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassVMixPlateverbDesc_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GVMixPlateverbDesc_t>("VMixPlateverbDesc_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Prefilter", &GVMixPlateverbDesc_t::GetPrefilter, &GVMixPlateverbDesc_t::SetPrefilter)
        .addProperty("InputDiffusion1", &GVMixPlateverbDesc_t::GetInputDiffusion1, &GVMixPlateverbDesc_t::SetInputDiffusion1)
        .addProperty("InputDiffusion2", &GVMixPlateverbDesc_t::GetInputDiffusion2, &GVMixPlateverbDesc_t::SetInputDiffusion2)
        .addProperty("Decay", &GVMixPlateverbDesc_t::GetDecay, &GVMixPlateverbDesc_t::SetDecay)
        .addProperty("Damp", &GVMixPlateverbDesc_t::GetDamp, &GVMixPlateverbDesc_t::SetDamp)
        .addProperty("FeedbackDiffusion1", &GVMixPlateverbDesc_t::GetFeedbackDiffusion1, &GVMixPlateverbDesc_t::SetFeedbackDiffusion1)
        .addProperty("FeedbackDiffusion2", &GVMixPlateverbDesc_t::GetFeedbackDiffusion2, &GVMixPlateverbDesc_t::SetFeedbackDiffusion2)
        .addFunction("ToPtr", &GVMixPlateverbDesc_t::ToPtr)
        .addFunction("IsValid", &GVMixPlateverbDesc_t::IsValid)
        .endClass();
}
GCMotionSearchDB::GCMotionSearchDB(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCMotionSearchDB::GCMotionSearchDB(void *ptr) {
    m_ptr = ptr;
}
GCMotionSearchNode GCMotionSearchDB::GetRootNode() const {
    GCMotionSearchNode value(GetSchemaPtr(m_ptr, "CMotionSearchDB", "m_rootNode"));
    return value;
}
void GCMotionSearchDB::SetRootNode(GCMotionSearchNode value) {
    SetSchemaValue(m_ptr, "CMotionSearchDB", "m_rootNode", false, value);
}
GCProductQuantizer GCMotionSearchDB::GetResidualQuantizer() const {
    GCProductQuantizer value(GetSchemaPtr(m_ptr, "CMotionSearchDB", "m_residualQuantizer"));
    return value;
}
void GCMotionSearchDB::SetResidualQuantizer(GCProductQuantizer value) {
    SetSchemaValue(m_ptr, "CMotionSearchDB", "m_residualQuantizer", false, value);
}
std::vector<GMotionDBIndex> GCMotionSearchDB::GetCodeIndices() const {
    CUtlVector<GMotionDBIndex>* vec = GetSchemaValue<CUtlVector<GMotionDBIndex>*>(m_ptr, "CMotionSearchDB", "m_codeIndices"); std::vector<GMotionDBIndex> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCMotionSearchDB::SetCodeIndices(std::vector<GMotionDBIndex> value) {
    SetSchemaValueCUtlVector<GMotionDBIndex>(m_ptr, "CMotionSearchDB", "m_codeIndices", false, value);
}
std::string GCMotionSearchDB::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCMotionSearchDB::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCMotionSearchDB(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCMotionSearchDB>("CMotionSearchDB")
        .addConstructor<void (*)(std::string)>()
        .addProperty("RootNode", &GCMotionSearchDB::GetRootNode, &GCMotionSearchDB::SetRootNode)
        .addProperty("ResidualQuantizer", &GCMotionSearchDB::GetResidualQuantizer, &GCMotionSearchDB::SetResidualQuantizer)
        .addProperty("CodeIndices", &GCMotionSearchDB::GetCodeIndices, &GCMotionSearchDB::SetCodeIndices)
        .addFunction("ToPtr", &GCMotionSearchDB::ToPtr)
        .addFunction("IsValid", &GCMotionSearchDB::IsValid)
        .endClass();
}
GVPhysics2ShapeDef_t::GVPhysics2ShapeDef_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GVPhysics2ShapeDef_t::GVPhysics2ShapeDef_t(void *ptr) {
    m_ptr = ptr;
}
std::vector<GRnSphereDesc_t> GVPhysics2ShapeDef_t::GetSpheres() const {
    CUtlVector<GRnSphereDesc_t>* vec = GetSchemaValue<CUtlVector<GRnSphereDesc_t>*>(m_ptr, "VPhysics2ShapeDef_t", "m_spheres"); std::vector<GRnSphereDesc_t> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GVPhysics2ShapeDef_t::SetSpheres(std::vector<GRnSphereDesc_t> value) {
    SetSchemaValueCUtlVector<GRnSphereDesc_t>(m_ptr, "VPhysics2ShapeDef_t", "m_spheres", true, value);
}
std::vector<GRnCapsuleDesc_t> GVPhysics2ShapeDef_t::GetCapsules() const {
    CUtlVector<GRnCapsuleDesc_t>* vec = GetSchemaValue<CUtlVector<GRnCapsuleDesc_t>*>(m_ptr, "VPhysics2ShapeDef_t", "m_capsules"); std::vector<GRnCapsuleDesc_t> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GVPhysics2ShapeDef_t::SetCapsules(std::vector<GRnCapsuleDesc_t> value) {
    SetSchemaValueCUtlVector<GRnCapsuleDesc_t>(m_ptr, "VPhysics2ShapeDef_t", "m_capsules", true, value);
}
std::vector<GRnHullDesc_t> GVPhysics2ShapeDef_t::GetHulls() const {
    CUtlVector<GRnHullDesc_t>* vec = GetSchemaValue<CUtlVector<GRnHullDesc_t>*>(m_ptr, "VPhysics2ShapeDef_t", "m_hulls"); std::vector<GRnHullDesc_t> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GVPhysics2ShapeDef_t::SetHulls(std::vector<GRnHullDesc_t> value) {
    SetSchemaValueCUtlVector<GRnHullDesc_t>(m_ptr, "VPhysics2ShapeDef_t", "m_hulls", true, value);
}
std::vector<GRnMeshDesc_t> GVPhysics2ShapeDef_t::GetMeshes() const {
    CUtlVector<GRnMeshDesc_t>* vec = GetSchemaValue<CUtlVector<GRnMeshDesc_t>*>(m_ptr, "VPhysics2ShapeDef_t", "m_meshes"); std::vector<GRnMeshDesc_t> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GVPhysics2ShapeDef_t::SetMeshes(std::vector<GRnMeshDesc_t> value) {
    SetSchemaValueCUtlVector<GRnMeshDesc_t>(m_ptr, "VPhysics2ShapeDef_t", "m_meshes", true, value);
}
std::vector<uint16> GVPhysics2ShapeDef_t::GetCollisionAttributeIndices() const {
    CUtlVector<uint16>* vec = GetSchemaValue<CUtlVector<uint16>*>(m_ptr, "VPhysics2ShapeDef_t", "m_CollisionAttributeIndices"); std::vector<uint16> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GVPhysics2ShapeDef_t::SetCollisionAttributeIndices(std::vector<uint16> value) {
    SetSchemaValueCUtlVector<uint16>(m_ptr, "VPhysics2ShapeDef_t", "m_CollisionAttributeIndices", true, value);
}
std::string GVPhysics2ShapeDef_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GVPhysics2ShapeDef_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassVPhysics2ShapeDef_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GVPhysics2ShapeDef_t>("VPhysics2ShapeDef_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Spheres", &GVPhysics2ShapeDef_t::GetSpheres, &GVPhysics2ShapeDef_t::SetSpheres)
        .addProperty("Capsules", &GVPhysics2ShapeDef_t::GetCapsules, &GVPhysics2ShapeDef_t::SetCapsules)
        .addProperty("Hulls", &GVPhysics2ShapeDef_t::GetHulls, &GVPhysics2ShapeDef_t::SetHulls)
        .addProperty("Meshes", &GVPhysics2ShapeDef_t::GetMeshes, &GVPhysics2ShapeDef_t::SetMeshes)
        .addProperty("CollisionAttributeIndices", &GVPhysics2ShapeDef_t::GetCollisionAttributeIndices, &GVPhysics2ShapeDef_t::SetCollisionAttributeIndices)
        .addFunction("ToPtr", &GVPhysics2ShapeDef_t::ToPtr)
        .addFunction("IsValid", &GVPhysics2ShapeDef_t::IsValid)
        .endClass();
}
GWorldBuilderParams_t::GWorldBuilderParams_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GWorldBuilderParams_t::GWorldBuilderParams_t(void *ptr) {
    m_ptr = ptr;
}
float GWorldBuilderParams_t::GetMinDrawVolumeSize() const {
    return GetSchemaValue<float>(m_ptr, "WorldBuilderParams_t", "m_flMinDrawVolumeSize");
}
void GWorldBuilderParams_t::SetMinDrawVolumeSize(float value) {
    SetSchemaValue(m_ptr, "WorldBuilderParams_t", "m_flMinDrawVolumeSize", true, value);
}
bool GWorldBuilderParams_t::GetBuildBakedLighting() const {
    return GetSchemaValue<bool>(m_ptr, "WorldBuilderParams_t", "m_bBuildBakedLighting");
}
void GWorldBuilderParams_t::SetBuildBakedLighting(bool value) {
    SetSchemaValue(m_ptr, "WorldBuilderParams_t", "m_bBuildBakedLighting", true, value);
}
GBakedLightingInfo_t GWorldBuilderParams_t::GetBakedLightingInfo() const {
    GBakedLightingInfo_t value(GetSchemaPtr(m_ptr, "WorldBuilderParams_t", "m_bakedLightingInfo"));
    return value;
}
void GWorldBuilderParams_t::SetBakedLightingInfo(GBakedLightingInfo_t value) {
    SetSchemaValue(m_ptr, "WorldBuilderParams_t", "m_bakedLightingInfo", true, value);
}
uint64_t GWorldBuilderParams_t::GetCompileTimestamp() const {
    return GetSchemaValue<uint64_t>(m_ptr, "WorldBuilderParams_t", "m_nCompileTimestamp");
}
void GWorldBuilderParams_t::SetCompileTimestamp(uint64_t value) {
    SetSchemaValue(m_ptr, "WorldBuilderParams_t", "m_nCompileTimestamp", true, value);
}
uint64_t GWorldBuilderParams_t::GetCompileFingerprint() const {
    return GetSchemaValue<uint64_t>(m_ptr, "WorldBuilderParams_t", "m_nCompileFingerprint");
}
void GWorldBuilderParams_t::SetCompileFingerprint(uint64_t value) {
    SetSchemaValue(m_ptr, "WorldBuilderParams_t", "m_nCompileFingerprint", true, value);
}
std::string GWorldBuilderParams_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GWorldBuilderParams_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassWorldBuilderParams_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GWorldBuilderParams_t>("WorldBuilderParams_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("MinDrawVolumeSize", &GWorldBuilderParams_t::GetMinDrawVolumeSize, &GWorldBuilderParams_t::SetMinDrawVolumeSize)
        .addProperty("BuildBakedLighting", &GWorldBuilderParams_t::GetBuildBakedLighting, &GWorldBuilderParams_t::SetBuildBakedLighting)
        .addProperty("BakedLightingInfo", &GWorldBuilderParams_t::GetBakedLightingInfo, &GWorldBuilderParams_t::SetBakedLightingInfo)
        .addProperty("CompileTimestamp", &GWorldBuilderParams_t::GetCompileTimestamp, &GWorldBuilderParams_t::SetCompileTimestamp)
        .addProperty("CompileFingerprint", &GWorldBuilderParams_t::GetCompileFingerprint, &GWorldBuilderParams_t::SetCompileFingerprint)
        .addFunction("ToPtr", &GWorldBuilderParams_t::ToPtr)
        .addFunction("IsValid", &GWorldBuilderParams_t::IsValid)
        .endClass();
}
GCFootAdjustmentUpdateNode::GCFootAdjustmentUpdateNode(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCFootAdjustmentUpdateNode::GCFootAdjustmentUpdateNode(void *ptr) {
    m_ptr = ptr;
}
GCPoseHandle GCFootAdjustmentUpdateNode::GetBasePoseCacheHandle() const {
    GCPoseHandle value(GetSchemaPtr(m_ptr, "CFootAdjustmentUpdateNode", "m_hBasePoseCacheHandle"));
    return value;
}
void GCFootAdjustmentUpdateNode::SetBasePoseCacheHandle(GCPoseHandle value) {
    SetSchemaValue(m_ptr, "CFootAdjustmentUpdateNode", "m_hBasePoseCacheHandle", false, value);
}
GCAnimParamHandle GCFootAdjustmentUpdateNode::GetFacingTarget() const {
    GCAnimParamHandle value(GetSchemaPtr(m_ptr, "CFootAdjustmentUpdateNode", "m_facingTarget"));
    return value;
}
void GCFootAdjustmentUpdateNode::SetFacingTarget(GCAnimParamHandle value) {
    SetSchemaValue(m_ptr, "CFootAdjustmentUpdateNode", "m_facingTarget", false, value);
}
float GCFootAdjustmentUpdateNode::GetTurnTimeMin() const {
    return GetSchemaValue<float>(m_ptr, "CFootAdjustmentUpdateNode", "m_flTurnTimeMin");
}
void GCFootAdjustmentUpdateNode::SetTurnTimeMin(float value) {
    SetSchemaValue(m_ptr, "CFootAdjustmentUpdateNode", "m_flTurnTimeMin", false, value);
}
float GCFootAdjustmentUpdateNode::GetTurnTimeMax() const {
    return GetSchemaValue<float>(m_ptr, "CFootAdjustmentUpdateNode", "m_flTurnTimeMax");
}
void GCFootAdjustmentUpdateNode::SetTurnTimeMax(float value) {
    SetSchemaValue(m_ptr, "CFootAdjustmentUpdateNode", "m_flTurnTimeMax", false, value);
}
float GCFootAdjustmentUpdateNode::GetStepHeightMax() const {
    return GetSchemaValue<float>(m_ptr, "CFootAdjustmentUpdateNode", "m_flStepHeightMax");
}
void GCFootAdjustmentUpdateNode::SetStepHeightMax(float value) {
    SetSchemaValue(m_ptr, "CFootAdjustmentUpdateNode", "m_flStepHeightMax", false, value);
}
float GCFootAdjustmentUpdateNode::GetStepHeightMaxAngle() const {
    return GetSchemaValue<float>(m_ptr, "CFootAdjustmentUpdateNode", "m_flStepHeightMaxAngle");
}
void GCFootAdjustmentUpdateNode::SetStepHeightMaxAngle(float value) {
    SetSchemaValue(m_ptr, "CFootAdjustmentUpdateNode", "m_flStepHeightMaxAngle", false, value);
}
bool GCFootAdjustmentUpdateNode::GetResetChild() const {
    return GetSchemaValue<bool>(m_ptr, "CFootAdjustmentUpdateNode", "m_bResetChild");
}
void GCFootAdjustmentUpdateNode::SetResetChild(bool value) {
    SetSchemaValue(m_ptr, "CFootAdjustmentUpdateNode", "m_bResetChild", false, value);
}
bool GCFootAdjustmentUpdateNode::GetAnimationDriven() const {
    return GetSchemaValue<bool>(m_ptr, "CFootAdjustmentUpdateNode", "m_bAnimationDriven");
}
void GCFootAdjustmentUpdateNode::SetAnimationDriven(bool value) {
    SetSchemaValue(m_ptr, "CFootAdjustmentUpdateNode", "m_bAnimationDriven", false, value);
}
std::string GCFootAdjustmentUpdateNode::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCFootAdjustmentUpdateNode::IsValid() {
    return (m_ptr != nullptr);
}
GCUnaryUpdateNode GCFootAdjustmentUpdateNode::GetParent() const {
    GCUnaryUpdateNode value(m_ptr);
    return value;
}
void GCFootAdjustmentUpdateNode::SetParent(GCUnaryUpdateNode value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCFootAdjustmentUpdateNode(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCFootAdjustmentUpdateNode>("CFootAdjustmentUpdateNode")
        .addConstructor<void (*)(std::string)>()
        .addProperty("BasePoseCacheHandle", &GCFootAdjustmentUpdateNode::GetBasePoseCacheHandle, &GCFootAdjustmentUpdateNode::SetBasePoseCacheHandle)
        .addProperty("FacingTarget", &GCFootAdjustmentUpdateNode::GetFacingTarget, &GCFootAdjustmentUpdateNode::SetFacingTarget)
        .addProperty("TurnTimeMin", &GCFootAdjustmentUpdateNode::GetTurnTimeMin, &GCFootAdjustmentUpdateNode::SetTurnTimeMin)
        .addProperty("TurnTimeMax", &GCFootAdjustmentUpdateNode::GetTurnTimeMax, &GCFootAdjustmentUpdateNode::SetTurnTimeMax)
        .addProperty("StepHeightMax", &GCFootAdjustmentUpdateNode::GetStepHeightMax, &GCFootAdjustmentUpdateNode::SetStepHeightMax)
        .addProperty("StepHeightMaxAngle", &GCFootAdjustmentUpdateNode::GetStepHeightMaxAngle, &GCFootAdjustmentUpdateNode::SetStepHeightMaxAngle)
        .addProperty("ResetChild", &GCFootAdjustmentUpdateNode::GetResetChild, &GCFootAdjustmentUpdateNode::SetResetChild)
        .addProperty("AnimationDriven", &GCFootAdjustmentUpdateNode::GetAnimationDriven, &GCFootAdjustmentUpdateNode::SetAnimationDriven)
        .addProperty("Parent", &GCFootAdjustmentUpdateNode::GetParent, &GCFootAdjustmentUpdateNode::SetParent)
        .addFunction("ToPtr", &GCFootAdjustmentUpdateNode::ToPtr)
        .addFunction("IsValid", &GCFootAdjustmentUpdateNode::IsValid)
        .endClass();
}
GCNmClipNode::GCNmClipNode(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCNmClipNode::GCNmClipNode(void *ptr) {
    m_ptr = ptr;
}
int16_t GCNmClipNode::GetPlayInReverseValueNodeIdx() const {
    return GetSchemaValue<int16_t>(m_ptr, "CNmClipNode", "m_nPlayInReverseValueNodeIdx");
}
void GCNmClipNode::SetPlayInReverseValueNodeIdx(int16_t value) {
    SetSchemaValue(m_ptr, "CNmClipNode", "m_nPlayInReverseValueNodeIdx", false, value);
}
int16_t GCNmClipNode::GetResetTimeValueNodeIdx() const {
    return GetSchemaValue<int16_t>(m_ptr, "CNmClipNode", "m_nResetTimeValueNodeIdx");
}
void GCNmClipNode::SetResetTimeValueNodeIdx(int16_t value) {
    SetSchemaValue(m_ptr, "CNmClipNode", "m_nResetTimeValueNodeIdx", false, value);
}
bool GCNmClipNode::GetSampleRootMotion() const {
    return GetSchemaValue<bool>(m_ptr, "CNmClipNode", "m_bSampleRootMotion");
}
void GCNmClipNode::SetSampleRootMotion(bool value) {
    SetSchemaValue(m_ptr, "CNmClipNode", "m_bSampleRootMotion", false, value);
}
bool GCNmClipNode::GetAllowLooping() const {
    return GetSchemaValue<bool>(m_ptr, "CNmClipNode", "m_bAllowLooping");
}
void GCNmClipNode::SetAllowLooping(bool value) {
    SetSchemaValue(m_ptr, "CNmClipNode", "m_bAllowLooping", false, value);
}
int16_t GCNmClipNode::GetDataSlotIdx() const {
    return GetSchemaValue<int16_t>(m_ptr, "CNmClipNode", "m_nDataSlotIdx");
}
void GCNmClipNode::SetDataSlotIdx(int16_t value) {
    SetSchemaValue(m_ptr, "CNmClipNode", "m_nDataSlotIdx", false, value);
}
std::string GCNmClipNode::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCNmClipNode::IsValid() {
    return (m_ptr != nullptr);
}
GCNmPoseNode GCNmClipNode::GetParent() const {
    GCNmPoseNode value(m_ptr);
    return value;
}
void GCNmClipNode::SetParent(GCNmPoseNode value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCNmClipNode(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCNmClipNode>("CNmClipNode")
        .addConstructor<void (*)(std::string)>()
        .addProperty("PlayInReverseValueNodeIdx", &GCNmClipNode::GetPlayInReverseValueNodeIdx, &GCNmClipNode::SetPlayInReverseValueNodeIdx)
        .addProperty("ResetTimeValueNodeIdx", &GCNmClipNode::GetResetTimeValueNodeIdx, &GCNmClipNode::SetResetTimeValueNodeIdx)
        .addProperty("SampleRootMotion", &GCNmClipNode::GetSampleRootMotion, &GCNmClipNode::SetSampleRootMotion)
        .addProperty("AllowLooping", &GCNmClipNode::GetAllowLooping, &GCNmClipNode::SetAllowLooping)
        .addProperty("DataSlotIdx", &GCNmClipNode::GetDataSlotIdx, &GCNmClipNode::SetDataSlotIdx)
        .addProperty("Parent", &GCNmClipNode::GetParent, &GCNmClipNode::SetParent)
        .addFunction("ToPtr", &GCNmClipNode::ToPtr)
        .addFunction("IsValid", &GCNmClipNode::IsValid)
        .endClass();
}
GCAnimMorphDifference::GCAnimMorphDifference(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCAnimMorphDifference::GCAnimMorphDifference(void *ptr) {
    m_ptr = ptr;
}
CBufferString GCAnimMorphDifference::GetName() const {
    return GetSchemaValue<CBufferString>(m_ptr, "CAnimMorphDifference", "m_name");
}
void GCAnimMorphDifference::SetName(CBufferString value) {
    SetSchemaValue(m_ptr, "CAnimMorphDifference", "m_name", false, value);
}
std::string GCAnimMorphDifference::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCAnimMorphDifference::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCAnimMorphDifference(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCAnimMorphDifference>("CAnimMorphDifference")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Name", &GCAnimMorphDifference::GetName, &GCAnimMorphDifference::SetName)
        .addFunction("ToPtr", &GCAnimMorphDifference::ToPtr)
        .addFunction("IsValid", &GCAnimMorphDifference::IsValid)
        .endClass();
}
GIParticleCollection::GIParticleCollection(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GIParticleCollection::GIParticleCollection(void *ptr) {
    m_ptr = ptr;
}
std::string GIParticleCollection::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GIParticleCollection::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassIParticleCollection(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GIParticleCollection>("IParticleCollection")
        .addConstructor<void (*)(std::string)>()
        .addFunction("ToPtr", &GIParticleCollection::ToPtr)
        .addFunction("IsValid", &GIParticleCollection::IsValid)
        .endClass();
}
GCNmGraphDefinition__ChildGraphSlot_t::GCNmGraphDefinition__ChildGraphSlot_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCNmGraphDefinition__ChildGraphSlot_t::GCNmGraphDefinition__ChildGraphSlot_t(void *ptr) {
    m_ptr = ptr;
}
int16_t GCNmGraphDefinition__ChildGraphSlot_t::GetNodeIdx() const {
    return GetSchemaValue<int16_t>(m_ptr, "CNmGraphDefinition__ChildGraphSlot_t", "m_nNodeIdx");
}
void GCNmGraphDefinition__ChildGraphSlot_t::SetNodeIdx(int16_t value) {
    SetSchemaValue(m_ptr, "CNmGraphDefinition__ChildGraphSlot_t", "m_nNodeIdx", true, value);
}
int16_t GCNmGraphDefinition__ChildGraphSlot_t::GetDataSlotIdx() const {
    return GetSchemaValue<int16_t>(m_ptr, "CNmGraphDefinition__ChildGraphSlot_t", "m_dataSlotIdx");
}
void GCNmGraphDefinition__ChildGraphSlot_t::SetDataSlotIdx(int16_t value) {
    SetSchemaValue(m_ptr, "CNmGraphDefinition__ChildGraphSlot_t", "m_dataSlotIdx", true, value);
}
std::string GCNmGraphDefinition__ChildGraphSlot_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCNmGraphDefinition__ChildGraphSlot_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCNmGraphDefinition__ChildGraphSlot_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCNmGraphDefinition__ChildGraphSlot_t>("CNmGraphDefinition__ChildGraphSlot_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("NodeIdx", &GCNmGraphDefinition__ChildGraphSlot_t::GetNodeIdx, &GCNmGraphDefinition__ChildGraphSlot_t::SetNodeIdx)
        .addProperty("DataSlotIdx", &GCNmGraphDefinition__ChildGraphSlot_t::GetDataSlotIdx, &GCNmGraphDefinition__ChildGraphSlot_t::SetDataSlotIdx)
        .addFunction("ToPtr", &GCNmGraphDefinition__ChildGraphSlot_t::ToPtr)
        .addFunction("IsValid", &GCNmGraphDefinition__ChildGraphSlot_t::IsValid)
        .endClass();
}
GCFutureVelocityMetricEvaluator::GCFutureVelocityMetricEvaluator(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCFutureVelocityMetricEvaluator::GCFutureVelocityMetricEvaluator(void *ptr) {
    m_ptr = ptr;
}
float GCFutureVelocityMetricEvaluator::GetDistance() const {
    return GetSchemaValue<float>(m_ptr, "CFutureVelocityMetricEvaluator", "m_flDistance");
}
void GCFutureVelocityMetricEvaluator::SetDistance(float value) {
    SetSchemaValue(m_ptr, "CFutureVelocityMetricEvaluator", "m_flDistance", false, value);
}
float GCFutureVelocityMetricEvaluator::GetStoppingDistance() const {
    return GetSchemaValue<float>(m_ptr, "CFutureVelocityMetricEvaluator", "m_flStoppingDistance");
}
void GCFutureVelocityMetricEvaluator::SetStoppingDistance(float value) {
    SetSchemaValue(m_ptr, "CFutureVelocityMetricEvaluator", "m_flStoppingDistance", false, value);
}
float GCFutureVelocityMetricEvaluator::GetTargetSpeed() const {
    return GetSchemaValue<float>(m_ptr, "CFutureVelocityMetricEvaluator", "m_flTargetSpeed");
}
void GCFutureVelocityMetricEvaluator::SetTargetSpeed(float value) {
    SetSchemaValue(m_ptr, "CFutureVelocityMetricEvaluator", "m_flTargetSpeed", false, value);
}
uint64_t GCFutureVelocityMetricEvaluator::GetMode() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CFutureVelocityMetricEvaluator", "m_eMode");
}
void GCFutureVelocityMetricEvaluator::SetMode(uint64_t value) {
    SetSchemaValue(m_ptr, "CFutureVelocityMetricEvaluator", "m_eMode", false, value);
}
std::string GCFutureVelocityMetricEvaluator::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCFutureVelocityMetricEvaluator::IsValid() {
    return (m_ptr != nullptr);
}
GCMotionMetricEvaluator GCFutureVelocityMetricEvaluator::GetParent() const {
    GCMotionMetricEvaluator value(m_ptr);
    return value;
}
void GCFutureVelocityMetricEvaluator::SetParent(GCMotionMetricEvaluator value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCFutureVelocityMetricEvaluator(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCFutureVelocityMetricEvaluator>("CFutureVelocityMetricEvaluator")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Distance", &GCFutureVelocityMetricEvaluator::GetDistance, &GCFutureVelocityMetricEvaluator::SetDistance)
        .addProperty("StoppingDistance", &GCFutureVelocityMetricEvaluator::GetStoppingDistance, &GCFutureVelocityMetricEvaluator::SetStoppingDistance)
        .addProperty("TargetSpeed", &GCFutureVelocityMetricEvaluator::GetTargetSpeed, &GCFutureVelocityMetricEvaluator::SetTargetSpeed)
        .addProperty("Mode", &GCFutureVelocityMetricEvaluator::GetMode, &GCFutureVelocityMetricEvaluator::SetMode)
        .addProperty("Parent", &GCFutureVelocityMetricEvaluator::GetParent, &GCFutureVelocityMetricEvaluator::SetParent)
        .addFunction("ToPtr", &GCFutureVelocityMetricEvaluator::ToPtr)
        .addFunction("IsValid", &GCFutureVelocityMetricEvaluator::IsValid)
        .endClass();
}
GCParticleProperty::GCParticleProperty(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCParticleProperty::GCParticleProperty(void *ptr) {
    m_ptr = ptr;
}
std::string GCParticleProperty::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCParticleProperty::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCParticleProperty(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCParticleProperty>("CParticleProperty")
        .addConstructor<void (*)(std::string)>()
        .addFunction("ToPtr", &GCParticleProperty::ToPtr)
        .addFunction("IsValid", &GCParticleProperty::IsValid)
        .endClass();
}
GVertexPositionNormal_t::GVertexPositionNormal_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GVertexPositionNormal_t::GVertexPositionNormal_t(void *ptr) {
    m_ptr = ptr;
}
Vector GVertexPositionNormal_t::GetPosition() const {
    return GetSchemaValue<Vector>(m_ptr, "VertexPositionNormal_t", "m_vPosition");
}
void GVertexPositionNormal_t::SetPosition(Vector value) {
    SetSchemaValue(m_ptr, "VertexPositionNormal_t", "m_vPosition", true, value);
}
Vector GVertexPositionNormal_t::GetNormal() const {
    return GetSchemaValue<Vector>(m_ptr, "VertexPositionNormal_t", "m_vNormal");
}
void GVertexPositionNormal_t::SetNormal(Vector value) {
    SetSchemaValue(m_ptr, "VertexPositionNormal_t", "m_vNormal", true, value);
}
std::string GVertexPositionNormal_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GVertexPositionNormal_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassVertexPositionNormal_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GVertexPositionNormal_t>("VertexPositionNormal_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Position", &GVertexPositionNormal_t::GetPosition, &GVertexPositionNormal_t::SetPosition)
        .addProperty("Normal", &GVertexPositionNormal_t::GetNormal, &GVertexPositionNormal_t::SetNormal)
        .addFunction("ToPtr", &GVertexPositionNormal_t::ToPtr)
        .addFunction("IsValid", &GVertexPositionNormal_t::IsValid)
        .endClass();
}
GFeEffectDesc_t::GFeEffectDesc_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GFeEffectDesc_t::GFeEffectDesc_t(void *ptr) {
    m_ptr = ptr;
}
std::string GFeEffectDesc_t::GetName() const {
    return GetSchemaValue<CUtlString>(m_ptr, "FeEffectDesc_t", "sName").Get();
}
void GFeEffectDesc_t::SetName(std::string value) {
    SetSchemaValue(m_ptr, "FeEffectDesc_t", "sName", true, CUtlString(value.c_str()));
}
uint32_t GFeEffectDesc_t::GetNameHash() const {
    return GetSchemaValue<uint32_t>(m_ptr, "FeEffectDesc_t", "nNameHash");
}
void GFeEffectDesc_t::SetNameHash(uint32_t value) {
    SetSchemaValue(m_ptr, "FeEffectDesc_t", "nNameHash", true, value);
}
int32_t GFeEffectDesc_t::GetType() const {
    return GetSchemaValue<int32_t>(m_ptr, "FeEffectDesc_t", "nType");
}
void GFeEffectDesc_t::SetType(int32_t value) {
    SetSchemaValue(m_ptr, "FeEffectDesc_t", "nType", true, value);
}
std::string GFeEffectDesc_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GFeEffectDesc_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassFeEffectDesc_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GFeEffectDesc_t>("FeEffectDesc_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Name", &GFeEffectDesc_t::GetName, &GFeEffectDesc_t::SetName)
        .addProperty("NameHash", &GFeEffectDesc_t::GetNameHash, &GFeEffectDesc_t::SetNameHash)
        .addProperty("Type", &GFeEffectDesc_t::GetType, &GFeEffectDesc_t::SetType)
        .addFunction("ToPtr", &GFeEffectDesc_t::ToPtr)
        .addFunction("IsValid", &GFeEffectDesc_t::IsValid)
        .endClass();
}
GCLODComponentUpdater::GCLODComponentUpdater(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCLODComponentUpdater::GCLODComponentUpdater(void *ptr) {
    m_ptr = ptr;
}
int32_t GCLODComponentUpdater::GetServerLOD() const {
    return GetSchemaValue<int32_t>(m_ptr, "CLODComponentUpdater", "m_nServerLOD");
}
void GCLODComponentUpdater::SetServerLOD(int32_t value) {
    SetSchemaValue(m_ptr, "CLODComponentUpdater", "m_nServerLOD", false, value);
}
std::string GCLODComponentUpdater::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCLODComponentUpdater::IsValid() {
    return (m_ptr != nullptr);
}
GCAnimComponentUpdater GCLODComponentUpdater::GetParent() const {
    GCAnimComponentUpdater value(m_ptr);
    return value;
}
void GCLODComponentUpdater::SetParent(GCAnimComponentUpdater value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCLODComponentUpdater(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCLODComponentUpdater>("CLODComponentUpdater")
        .addConstructor<void (*)(std::string)>()
        .addProperty("ServerLOD", &GCLODComponentUpdater::GetServerLOD, &GCLODComponentUpdater::SetServerLOD)
        .addProperty("Parent", &GCLODComponentUpdater::GetParent, &GCLODComponentUpdater::SetParent)
        .addFunction("ToPtr", &GCLODComponentUpdater::ToPtr)
        .addFunction("IsValid", &GCLODComponentUpdater::IsValid)
        .endClass();
}
GCNmLegacyEvent::GCNmLegacyEvent(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCNmLegacyEvent::GCNmLegacyEvent(void *ptr) {
    m_ptr = ptr;
}
std::string GCNmLegacyEvent::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCNmLegacyEvent::IsValid() {
    return (m_ptr != nullptr);
}
GCNmEvent GCNmLegacyEvent::GetParent() const {
    GCNmEvent value(m_ptr);
    return value;
}
void GCNmLegacyEvent::SetParent(GCNmEvent value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCNmLegacyEvent(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCNmLegacyEvent>("CNmLegacyEvent")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCNmLegacyEvent::GetParent, &GCNmLegacyEvent::SetParent)
        .addFunction("ToPtr", &GCNmLegacyEvent::ToPtr)
        .addFunction("IsValid", &GCNmLegacyEvent::IsValid)
        .endClass();
}
GMaterialParamVector_t::GMaterialParamVector_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GMaterialParamVector_t::GMaterialParamVector_t(void *ptr) {
    m_ptr = ptr;
}
Vector4D GMaterialParamVector_t::GetValue() const {
    return GetSchemaValue<Vector4D>(m_ptr, "MaterialParamVector_t", "m_value");
}
void GMaterialParamVector_t::SetValue(Vector4D value) {
    SetSchemaValue(m_ptr, "MaterialParamVector_t", "m_value", true, value);
}
std::string GMaterialParamVector_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GMaterialParamVector_t::IsValid() {
    return (m_ptr != nullptr);
}
GMaterialParam_t GMaterialParamVector_t::GetParent() const {
    GMaterialParam_t value(m_ptr);
    return value;
}
void GMaterialParamVector_t::SetParent(GMaterialParam_t value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassMaterialParamVector_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GMaterialParamVector_t>("MaterialParamVector_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Value", &GMaterialParamVector_t::GetValue, &GMaterialParamVector_t::SetValue)
        .addProperty("Parent", &GMaterialParamVector_t::GetParent, &GMaterialParamVector_t::SetParent)
        .addFunction("ToPtr", &GMaterialParamVector_t::ToPtr)
        .addFunction("IsValid", &GMaterialParamVector_t::IsValid)
        .endClass();
}
GCMotionGraphGroup::GCMotionGraphGroup(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCMotionGraphGroup::GCMotionGraphGroup(void *ptr) {
    m_ptr = ptr;
}
GCMotionSearchDB GCMotionGraphGroup::GetSearchDB() const {
    GCMotionSearchDB value(GetSchemaPtr(m_ptr, "CMotionGraphGroup", "m_searchDB"));
    return value;
}
void GCMotionGraphGroup::SetSearchDB(GCMotionSearchDB value) {
    SetSchemaValue(m_ptr, "CMotionGraphGroup", "m_searchDB", false, value);
}
std::vector<GCMotionGraphConfig> GCMotionGraphGroup::GetMotionGraphConfigs() const {
    CUtlVector<GCMotionGraphConfig>* vec = GetSchemaValue<CUtlVector<GCMotionGraphConfig>*>(m_ptr, "CMotionGraphGroup", "m_motionGraphConfigs"); std::vector<GCMotionGraphConfig> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCMotionGraphGroup::SetMotionGraphConfigs(std::vector<GCMotionGraphConfig> value) {
    SetSchemaValueCUtlVector<GCMotionGraphConfig>(m_ptr, "CMotionGraphGroup", "m_motionGraphConfigs", false, value);
}
std::vector<int32> GCMotionGraphGroup::GetSampleToConfig() const {
    CUtlVector<int32>* vec = GetSchemaValue<CUtlVector<int32>*>(m_ptr, "CMotionGraphGroup", "m_sampleToConfig"); std::vector<int32> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCMotionGraphGroup::SetSampleToConfig(std::vector<int32> value) {
    SetSchemaValueCUtlVector<int32>(m_ptr, "CMotionGraphGroup", "m_sampleToConfig", false, value);
}
GAnimScriptHandle GCMotionGraphGroup::GetIsActiveScript() const {
    GAnimScriptHandle value(GetSchemaPtr(m_ptr, "CMotionGraphGroup", "m_hIsActiveScript"));
    return value;
}
void GCMotionGraphGroup::SetIsActiveScript(GAnimScriptHandle value) {
    SetSchemaValue(m_ptr, "CMotionGraphGroup", "m_hIsActiveScript", false, value);
}
std::string GCMotionGraphGroup::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCMotionGraphGroup::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCMotionGraphGroup(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCMotionGraphGroup>("CMotionGraphGroup")
        .addConstructor<void (*)(std::string)>()
        .addProperty("SearchDB", &GCMotionGraphGroup::GetSearchDB, &GCMotionGraphGroup::SetSearchDB)
        .addProperty("MotionGraphConfigs", &GCMotionGraphGroup::GetMotionGraphConfigs, &GCMotionGraphGroup::SetMotionGraphConfigs)
        .addProperty("SampleToConfig", &GCMotionGraphGroup::GetSampleToConfig, &GCMotionGraphGroup::SetSampleToConfig)
        .addProperty("IsActiveScript", &GCMotionGraphGroup::GetIsActiveScript, &GCMotionGraphGroup::SetIsActiveScript)
        .addFunction("ToPtr", &GCMotionGraphGroup::ToPtr)
        .addFunction("IsValid", &GCMotionGraphGroup::IsValid)
        .endClass();
}
GHitReactFixedSettings_t::GHitReactFixedSettings_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GHitReactFixedSettings_t::GHitReactFixedSettings_t(void *ptr) {
    m_ptr = ptr;
}
int32_t GHitReactFixedSettings_t::GetWeightListIndex() const {
    return GetSchemaValue<int32_t>(m_ptr, "HitReactFixedSettings_t", "m_nWeightListIndex");
}
void GHitReactFixedSettings_t::SetWeightListIndex(int32_t value) {
    SetSchemaValue(m_ptr, "HitReactFixedSettings_t", "m_nWeightListIndex", true, value);
}
int32_t GHitReactFixedSettings_t::GetEffectedBoneCount() const {
    return GetSchemaValue<int32_t>(m_ptr, "HitReactFixedSettings_t", "m_nEffectedBoneCount");
}
void GHitReactFixedSettings_t::SetEffectedBoneCount(int32_t value) {
    SetSchemaValue(m_ptr, "HitReactFixedSettings_t", "m_nEffectedBoneCount", true, value);
}
float GHitReactFixedSettings_t::GetMaxImpactForce() const {
    return GetSchemaValue<float>(m_ptr, "HitReactFixedSettings_t", "m_flMaxImpactForce");
}
void GHitReactFixedSettings_t::SetMaxImpactForce(float value) {
    SetSchemaValue(m_ptr, "HitReactFixedSettings_t", "m_flMaxImpactForce", true, value);
}
float GHitReactFixedSettings_t::GetMinImpactForce() const {
    return GetSchemaValue<float>(m_ptr, "HitReactFixedSettings_t", "m_flMinImpactForce");
}
void GHitReactFixedSettings_t::SetMinImpactForce(float value) {
    SetSchemaValue(m_ptr, "HitReactFixedSettings_t", "m_flMinImpactForce", true, value);
}
float GHitReactFixedSettings_t::GetWhipImpactScale() const {
    return GetSchemaValue<float>(m_ptr, "HitReactFixedSettings_t", "m_flWhipImpactScale");
}
void GHitReactFixedSettings_t::SetWhipImpactScale(float value) {
    SetSchemaValue(m_ptr, "HitReactFixedSettings_t", "m_flWhipImpactScale", true, value);
}
float GHitReactFixedSettings_t::GetCounterRotationScale() const {
    return GetSchemaValue<float>(m_ptr, "HitReactFixedSettings_t", "m_flCounterRotationScale");
}
void GHitReactFixedSettings_t::SetCounterRotationScale(float value) {
    SetSchemaValue(m_ptr, "HitReactFixedSettings_t", "m_flCounterRotationScale", true, value);
}
float GHitReactFixedSettings_t::GetDistanceFadeScale() const {
    return GetSchemaValue<float>(m_ptr, "HitReactFixedSettings_t", "m_flDistanceFadeScale");
}
void GHitReactFixedSettings_t::SetDistanceFadeScale(float value) {
    SetSchemaValue(m_ptr, "HitReactFixedSettings_t", "m_flDistanceFadeScale", true, value);
}
float GHitReactFixedSettings_t::GetPropagationScale() const {
    return GetSchemaValue<float>(m_ptr, "HitReactFixedSettings_t", "m_flPropagationScale");
}
void GHitReactFixedSettings_t::SetPropagationScale(float value) {
    SetSchemaValue(m_ptr, "HitReactFixedSettings_t", "m_flPropagationScale", true, value);
}
float GHitReactFixedSettings_t::GetWhipDelay() const {
    return GetSchemaValue<float>(m_ptr, "HitReactFixedSettings_t", "m_flWhipDelay");
}
void GHitReactFixedSettings_t::SetWhipDelay(float value) {
    SetSchemaValue(m_ptr, "HitReactFixedSettings_t", "m_flWhipDelay", true, value);
}
float GHitReactFixedSettings_t::GetSpringStrength() const {
    return GetSchemaValue<float>(m_ptr, "HitReactFixedSettings_t", "m_flSpringStrength");
}
void GHitReactFixedSettings_t::SetSpringStrength(float value) {
    SetSchemaValue(m_ptr, "HitReactFixedSettings_t", "m_flSpringStrength", true, value);
}
float GHitReactFixedSettings_t::GetWhipSpringStrength() const {
    return GetSchemaValue<float>(m_ptr, "HitReactFixedSettings_t", "m_flWhipSpringStrength");
}
void GHitReactFixedSettings_t::SetWhipSpringStrength(float value) {
    SetSchemaValue(m_ptr, "HitReactFixedSettings_t", "m_flWhipSpringStrength", true, value);
}
float GHitReactFixedSettings_t::GetMaxAngleRadians() const {
    return GetSchemaValue<float>(m_ptr, "HitReactFixedSettings_t", "m_flMaxAngleRadians");
}
void GHitReactFixedSettings_t::SetMaxAngleRadians(float value) {
    SetSchemaValue(m_ptr, "HitReactFixedSettings_t", "m_flMaxAngleRadians", true, value);
}
int32_t GHitReactFixedSettings_t::GetHipBoneIndex() const {
    return GetSchemaValue<int32_t>(m_ptr, "HitReactFixedSettings_t", "m_nHipBoneIndex");
}
void GHitReactFixedSettings_t::SetHipBoneIndex(int32_t value) {
    SetSchemaValue(m_ptr, "HitReactFixedSettings_t", "m_nHipBoneIndex", true, value);
}
float GHitReactFixedSettings_t::GetHipBoneTranslationScale() const {
    return GetSchemaValue<float>(m_ptr, "HitReactFixedSettings_t", "m_flHipBoneTranslationScale");
}
void GHitReactFixedSettings_t::SetHipBoneTranslationScale(float value) {
    SetSchemaValue(m_ptr, "HitReactFixedSettings_t", "m_flHipBoneTranslationScale", true, value);
}
float GHitReactFixedSettings_t::GetHipDipSpringStrength() const {
    return GetSchemaValue<float>(m_ptr, "HitReactFixedSettings_t", "m_flHipDipSpringStrength");
}
void GHitReactFixedSettings_t::SetHipDipSpringStrength(float value) {
    SetSchemaValue(m_ptr, "HitReactFixedSettings_t", "m_flHipDipSpringStrength", true, value);
}
float GHitReactFixedSettings_t::GetHipDipImpactScale() const {
    return GetSchemaValue<float>(m_ptr, "HitReactFixedSettings_t", "m_flHipDipImpactScale");
}
void GHitReactFixedSettings_t::SetHipDipImpactScale(float value) {
    SetSchemaValue(m_ptr, "HitReactFixedSettings_t", "m_flHipDipImpactScale", true, value);
}
float GHitReactFixedSettings_t::GetHipDipDelay() const {
    return GetSchemaValue<float>(m_ptr, "HitReactFixedSettings_t", "m_flHipDipDelay");
}
void GHitReactFixedSettings_t::SetHipDipDelay(float value) {
    SetSchemaValue(m_ptr, "HitReactFixedSettings_t", "m_flHipDipDelay", true, value);
}
std::string GHitReactFixedSettings_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GHitReactFixedSettings_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassHitReactFixedSettings_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GHitReactFixedSettings_t>("HitReactFixedSettings_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("WeightListIndex", &GHitReactFixedSettings_t::GetWeightListIndex, &GHitReactFixedSettings_t::SetWeightListIndex)
        .addProperty("EffectedBoneCount", &GHitReactFixedSettings_t::GetEffectedBoneCount, &GHitReactFixedSettings_t::SetEffectedBoneCount)
        .addProperty("MaxImpactForce", &GHitReactFixedSettings_t::GetMaxImpactForce, &GHitReactFixedSettings_t::SetMaxImpactForce)
        .addProperty("MinImpactForce", &GHitReactFixedSettings_t::GetMinImpactForce, &GHitReactFixedSettings_t::SetMinImpactForce)
        .addProperty("WhipImpactScale", &GHitReactFixedSettings_t::GetWhipImpactScale, &GHitReactFixedSettings_t::SetWhipImpactScale)
        .addProperty("CounterRotationScale", &GHitReactFixedSettings_t::GetCounterRotationScale, &GHitReactFixedSettings_t::SetCounterRotationScale)
        .addProperty("DistanceFadeScale", &GHitReactFixedSettings_t::GetDistanceFadeScale, &GHitReactFixedSettings_t::SetDistanceFadeScale)
        .addProperty("PropagationScale", &GHitReactFixedSettings_t::GetPropagationScale, &GHitReactFixedSettings_t::SetPropagationScale)
        .addProperty("WhipDelay", &GHitReactFixedSettings_t::GetWhipDelay, &GHitReactFixedSettings_t::SetWhipDelay)
        .addProperty("SpringStrength", &GHitReactFixedSettings_t::GetSpringStrength, &GHitReactFixedSettings_t::SetSpringStrength)
        .addProperty("WhipSpringStrength", &GHitReactFixedSettings_t::GetWhipSpringStrength, &GHitReactFixedSettings_t::SetWhipSpringStrength)
        .addProperty("MaxAngleRadians", &GHitReactFixedSettings_t::GetMaxAngleRadians, &GHitReactFixedSettings_t::SetMaxAngleRadians)
        .addProperty("HipBoneIndex", &GHitReactFixedSettings_t::GetHipBoneIndex, &GHitReactFixedSettings_t::SetHipBoneIndex)
        .addProperty("HipBoneTranslationScale", &GHitReactFixedSettings_t::GetHipBoneTranslationScale, &GHitReactFixedSettings_t::SetHipBoneTranslationScale)
        .addProperty("HipDipSpringStrength", &GHitReactFixedSettings_t::GetHipDipSpringStrength, &GHitReactFixedSettings_t::SetHipDipSpringStrength)
        .addProperty("HipDipImpactScale", &GHitReactFixedSettings_t::GetHipDipImpactScale, &GHitReactFixedSettings_t::SetHipDipImpactScale)
        .addProperty("HipDipDelay", &GHitReactFixedSettings_t::GetHipDipDelay, &GHitReactFixedSettings_t::SetHipDipDelay)
        .addFunction("ToPtr", &GHitReactFixedSettings_t::ToPtr)
        .addFunction("IsValid", &GHitReactFixedSettings_t::IsValid)
        .endClass();
}
GCRootUpdateNode::GCRootUpdateNode(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCRootUpdateNode::GCRootUpdateNode(void *ptr) {
    m_ptr = ptr;
}
std::string GCRootUpdateNode::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCRootUpdateNode::IsValid() {
    return (m_ptr != nullptr);
}
GCUnaryUpdateNode GCRootUpdateNode::GetParent() const {
    GCUnaryUpdateNode value(m_ptr);
    return value;
}
void GCRootUpdateNode::SetParent(GCUnaryUpdateNode value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCRootUpdateNode(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCRootUpdateNode>("CRootUpdateNode")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCRootUpdateNode::GetParent, &GCRootUpdateNode::SetParent)
        .addFunction("ToPtr", &GCRootUpdateNode::ToPtr)
        .addFunction("IsValid", &GCRootUpdateNode::IsValid)
        .endClass();
}
GCAnimMovement::GCAnimMovement(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCAnimMovement::GCAnimMovement(void *ptr) {
    m_ptr = ptr;
}
int32_t GCAnimMovement::GetEndframe() const {
    return GetSchemaValue<int32_t>(m_ptr, "CAnimMovement", "endframe");
}
void GCAnimMovement::SetEndframe(int32_t value) {
    SetSchemaValue(m_ptr, "CAnimMovement", "endframe", false, value);
}
int32_t GCAnimMovement::GetMotionflags() const {
    return GetSchemaValue<int32_t>(m_ptr, "CAnimMovement", "motionflags");
}
void GCAnimMovement::SetMotionflags(int32_t value) {
    SetSchemaValue(m_ptr, "CAnimMovement", "motionflags", false, value);
}
float GCAnimMovement::Get0() const {
    return GetSchemaValue<float>(m_ptr, "CAnimMovement", "v0");
}
void GCAnimMovement::Set0(float value) {
    SetSchemaValue(m_ptr, "CAnimMovement", "v0", false, value);
}
float GCAnimMovement::Get1() const {
    return GetSchemaValue<float>(m_ptr, "CAnimMovement", "v1");
}
void GCAnimMovement::Set1(float value) {
    SetSchemaValue(m_ptr, "CAnimMovement", "v1", false, value);
}
float GCAnimMovement::GetAngle() const {
    return GetSchemaValue<float>(m_ptr, "CAnimMovement", "angle");
}
void GCAnimMovement::SetAngle(float value) {
    SetSchemaValue(m_ptr, "CAnimMovement", "angle", false, value);
}
Vector GCAnimMovement::GetVector() const {
    return GetSchemaValue<Vector>(m_ptr, "CAnimMovement", "vector");
}
void GCAnimMovement::SetVector(Vector value) {
    SetSchemaValue(m_ptr, "CAnimMovement", "vector", false, value);
}
Vector GCAnimMovement::GetPosition() const {
    return GetSchemaValue<Vector>(m_ptr, "CAnimMovement", "position");
}
void GCAnimMovement::SetPosition(Vector value) {
    SetSchemaValue(m_ptr, "CAnimMovement", "position", false, value);
}
std::string GCAnimMovement::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCAnimMovement::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCAnimMovement(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCAnimMovement>("CAnimMovement")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Endframe", &GCAnimMovement::GetEndframe, &GCAnimMovement::SetEndframe)
        .addProperty("Motionflags", &GCAnimMovement::GetMotionflags, &GCAnimMovement::SetMotionflags)
        .addProperty("0", &GCAnimMovement::Get0, &GCAnimMovement::Set0)
        .addProperty("1", &GCAnimMovement::Get1, &GCAnimMovement::Set1)
        .addProperty("Angle", &GCAnimMovement::GetAngle, &GCAnimMovement::SetAngle)
        .addProperty("Vector", &GCAnimMovement::GetVector, &GCAnimMovement::SetVector)
        .addProperty("Position", &GCAnimMovement::GetPosition, &GCAnimMovement::SetPosition)
        .addFunction("ToPtr", &GCAnimMovement::ToPtr)
        .addFunction("IsValid", &GCAnimMovement::IsValid)
        .endClass();
}
GCConstraintSlave::GCConstraintSlave(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCConstraintSlave::GCConstraintSlave(void *ptr) {
    m_ptr = ptr;
}
Quaternion GCConstraintSlave::GetBaseOrientation() const {
    return GetSchemaValue<Quaternion>(m_ptr, "CConstraintSlave", "m_qBaseOrientation");
}
void GCConstraintSlave::SetBaseOrientation(Quaternion value) {
    SetSchemaValue(m_ptr, "CConstraintSlave", "m_qBaseOrientation", false, value);
}
Vector GCConstraintSlave::GetBasePosition() const {
    return GetSchemaValue<Vector>(m_ptr, "CConstraintSlave", "m_vBasePosition");
}
void GCConstraintSlave::SetBasePosition(Vector value) {
    SetSchemaValue(m_ptr, "CConstraintSlave", "m_vBasePosition", false, value);
}
uint32_t GCConstraintSlave::GetBoneHash() const {
    return GetSchemaValue<uint32_t>(m_ptr, "CConstraintSlave", "m_nBoneHash");
}
void GCConstraintSlave::SetBoneHash(uint32_t value) {
    SetSchemaValue(m_ptr, "CConstraintSlave", "m_nBoneHash", false, value);
}
float GCConstraintSlave::GetWeight() const {
    return GetSchemaValue<float>(m_ptr, "CConstraintSlave", "m_flWeight");
}
void GCConstraintSlave::SetWeight(float value) {
    SetSchemaValue(m_ptr, "CConstraintSlave", "m_flWeight", false, value);
}
std::string GCConstraintSlave::GetName() const {
    return GetSchemaValue<CUtlString>(m_ptr, "CConstraintSlave", "m_sName").Get();
}
void GCConstraintSlave::SetName(std::string value) {
    SetSchemaValue(m_ptr, "CConstraintSlave", "m_sName", false, CUtlString(value.c_str()));
}
std::string GCConstraintSlave::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCConstraintSlave::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCConstraintSlave(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCConstraintSlave>("CConstraintSlave")
        .addConstructor<void (*)(std::string)>()
        .addProperty("BaseOrientation", &GCConstraintSlave::GetBaseOrientation, &GCConstraintSlave::SetBaseOrientation)
        .addProperty("BasePosition", &GCConstraintSlave::GetBasePosition, &GCConstraintSlave::SetBasePosition)
        .addProperty("BoneHash", &GCConstraintSlave::GetBoneHash, &GCConstraintSlave::SetBoneHash)
        .addProperty("Weight", &GCConstraintSlave::GetWeight, &GCConstraintSlave::SetWeight)
        .addProperty("Name", &GCConstraintSlave::GetName, &GCConstraintSlave::SetName)
        .addFunction("ToPtr", &GCConstraintSlave::ToPtr)
        .addFunction("IsValid", &GCConstraintSlave::IsValid)
        .endClass();
}
GCSeqBoneMaskList::GCSeqBoneMaskList(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCSeqBoneMaskList::GCSeqBoneMaskList(void *ptr) {
    m_ptr = ptr;
}
CBufferString GCSeqBoneMaskList::GetName() const {
    return GetSchemaValue<CBufferString>(m_ptr, "CSeqBoneMaskList", "m_sName");
}
void GCSeqBoneMaskList::SetName(CBufferString value) {
    SetSchemaValue(m_ptr, "CSeqBoneMaskList", "m_sName", false, value);
}
std::vector<int16> GCSeqBoneMaskList::GetLocalBoneArray() const {
    CUtlVector<int16>* vec = GetSchemaValue<CUtlVector<int16>*>(m_ptr, "CSeqBoneMaskList", "m_nLocalBoneArray"); std::vector<int16> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCSeqBoneMaskList::SetLocalBoneArray(std::vector<int16> value) {
    SetSchemaValueCUtlVector<int16>(m_ptr, "CSeqBoneMaskList", "m_nLocalBoneArray", false, value);
}
std::vector<float32> GCSeqBoneMaskList::GetBoneWeightArray() const {
    CUtlVector<float32>* vec = GetSchemaValue<CUtlVector<float32>*>(m_ptr, "CSeqBoneMaskList", "m_flBoneWeightArray"); std::vector<float32> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCSeqBoneMaskList::SetBoneWeightArray(std::vector<float32> value) {
    SetSchemaValueCUtlVector<float32>(m_ptr, "CSeqBoneMaskList", "m_flBoneWeightArray", false, value);
}
float GCSeqBoneMaskList::GetDefaultMorphCtrlWeight() const {
    return GetSchemaValue<float>(m_ptr, "CSeqBoneMaskList", "m_flDefaultMorphCtrlWeight");
}
void GCSeqBoneMaskList::SetDefaultMorphCtrlWeight(float value) {
    SetSchemaValue(m_ptr, "CSeqBoneMaskList", "m_flDefaultMorphCtrlWeight", false, value);
}
std::string GCSeqBoneMaskList::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCSeqBoneMaskList::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCSeqBoneMaskList(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCSeqBoneMaskList>("CSeqBoneMaskList")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Name", &GCSeqBoneMaskList::GetName, &GCSeqBoneMaskList::SetName)
        .addProperty("LocalBoneArray", &GCSeqBoneMaskList::GetLocalBoneArray, &GCSeqBoneMaskList::SetLocalBoneArray)
        .addProperty("BoneWeightArray", &GCSeqBoneMaskList::GetBoneWeightArray, &GCSeqBoneMaskList::SetBoneWeightArray)
        .addProperty("DefaultMorphCtrlWeight", &GCSeqBoneMaskList::GetDefaultMorphCtrlWeight, &GCSeqBoneMaskList::SetDefaultMorphCtrlWeight)
        .addFunction("ToPtr", &GCSeqBoneMaskList::ToPtr)
        .addFunction("IsValid", &GCSeqBoneMaskList::IsValid)
        .endClass();
}
GPermModelDataAnimatedMaterialAttribute_t::GPermModelDataAnimatedMaterialAttribute_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GPermModelDataAnimatedMaterialAttribute_t::GPermModelDataAnimatedMaterialAttribute_t(void *ptr) {
    m_ptr = ptr;
}
std::string GPermModelDataAnimatedMaterialAttribute_t::GetAttributeName() const {
    return GetSchemaValue<CUtlString>(m_ptr, "PermModelDataAnimatedMaterialAttribute_t", "m_AttributeName").Get();
}
void GPermModelDataAnimatedMaterialAttribute_t::SetAttributeName(std::string value) {
    SetSchemaValue(m_ptr, "PermModelDataAnimatedMaterialAttribute_t", "m_AttributeName", true, CUtlString(value.c_str()));
}
int32_t GPermModelDataAnimatedMaterialAttribute_t::GetNumChannels() const {
    return GetSchemaValue<int32_t>(m_ptr, "PermModelDataAnimatedMaterialAttribute_t", "m_nNumChannels");
}
void GPermModelDataAnimatedMaterialAttribute_t::SetNumChannels(int32_t value) {
    SetSchemaValue(m_ptr, "PermModelDataAnimatedMaterialAttribute_t", "m_nNumChannels", true, value);
}
std::string GPermModelDataAnimatedMaterialAttribute_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GPermModelDataAnimatedMaterialAttribute_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassPermModelDataAnimatedMaterialAttribute_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GPermModelDataAnimatedMaterialAttribute_t>("PermModelDataAnimatedMaterialAttribute_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("AttributeName", &GPermModelDataAnimatedMaterialAttribute_t::GetAttributeName, &GPermModelDataAnimatedMaterialAttribute_t::SetAttributeName)
        .addProperty("NumChannels", &GPermModelDataAnimatedMaterialAttribute_t::GetNumChannels, &GPermModelDataAnimatedMaterialAttribute_t::SetNumChannels)
        .addFunction("ToPtr", &GPermModelDataAnimatedMaterialAttribute_t::ToPtr)
        .addFunction("IsValid", &GPermModelDataAnimatedMaterialAttribute_t::IsValid)
        .endClass();
}
GScriptInfo_t::GScriptInfo_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GScriptInfo_t::GScriptInfo_t(void *ptr) {
    m_ptr = ptr;
}
std::string GScriptInfo_t::GetCode() const {
    return GetSchemaValue<CUtlString>(m_ptr, "ScriptInfo_t", "m_code").Get();
}
void GScriptInfo_t::SetCode(std::string value) {
    SetSchemaValue(m_ptr, "ScriptInfo_t", "m_code", true, CUtlString(value.c_str()));
}
std::vector<GCAnimParamHandle> GScriptInfo_t::GetParamsModified() const {
    CUtlVector<GCAnimParamHandle>* vec = GetSchemaValue<CUtlVector<GCAnimParamHandle>*>(m_ptr, "ScriptInfo_t", "m_paramsModified"); std::vector<GCAnimParamHandle> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GScriptInfo_t::SetParamsModified(std::vector<GCAnimParamHandle> value) {
    SetSchemaValueCUtlVector<GCAnimParamHandle>(m_ptr, "ScriptInfo_t", "m_paramsModified", true, value);
}
std::vector<int32> GScriptInfo_t::GetProxyReadParams() const {
    CUtlVector<int32>* vec = GetSchemaValue<CUtlVector<int32>*>(m_ptr, "ScriptInfo_t", "m_proxyReadParams"); std::vector<int32> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GScriptInfo_t::SetProxyReadParams(std::vector<int32> value) {
    SetSchemaValueCUtlVector<int32>(m_ptr, "ScriptInfo_t", "m_proxyReadParams", true, value);
}
std::vector<int32> GScriptInfo_t::GetProxyWriteParams() const {
    CUtlVector<int32>* vec = GetSchemaValue<CUtlVector<int32>*>(m_ptr, "ScriptInfo_t", "m_proxyWriteParams"); std::vector<int32> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GScriptInfo_t::SetProxyWriteParams(std::vector<int32> value) {
    SetSchemaValueCUtlVector<int32>(m_ptr, "ScriptInfo_t", "m_proxyWriteParams", true, value);
}
uint64_t GScriptInfo_t::GetScriptType() const {
    return GetSchemaValue<uint64_t>(m_ptr, "ScriptInfo_t", "m_eScriptType");
}
void GScriptInfo_t::SetScriptType(uint64_t value) {
    SetSchemaValue(m_ptr, "ScriptInfo_t", "m_eScriptType", true, value);
}
std::string GScriptInfo_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GScriptInfo_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassScriptInfo_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GScriptInfo_t>("ScriptInfo_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Code", &GScriptInfo_t::GetCode, &GScriptInfo_t::SetCode)
        .addProperty("ParamsModified", &GScriptInfo_t::GetParamsModified, &GScriptInfo_t::SetParamsModified)
        .addProperty("ProxyReadParams", &GScriptInfo_t::GetProxyReadParams, &GScriptInfo_t::SetProxyReadParams)
        .addProperty("ProxyWriteParams", &GScriptInfo_t::GetProxyWriteParams, &GScriptInfo_t::SetProxyWriteParams)
        .addProperty("ScriptType", &GScriptInfo_t::GetScriptType, &GScriptInfo_t::SetScriptType)
        .addFunction("ToPtr", &GScriptInfo_t::ToPtr)
        .addFunction("IsValid", &GScriptInfo_t::IsValid)
        .endClass();
}
GVPhysXRange_t::GVPhysXRange_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GVPhysXRange_t::GVPhysXRange_t(void *ptr) {
    m_ptr = ptr;
}
float GVPhysXRange_t::GetMin() const {
    return GetSchemaValue<float>(m_ptr, "VPhysXRange_t", "m_flMin");
}
void GVPhysXRange_t::SetMin(float value) {
    SetSchemaValue(m_ptr, "VPhysXRange_t", "m_flMin", true, value);
}
float GVPhysXRange_t::GetMax() const {
    return GetSchemaValue<float>(m_ptr, "VPhysXRange_t", "m_flMax");
}
void GVPhysXRange_t::SetMax(float value) {
    SetSchemaValue(m_ptr, "VPhysXRange_t", "m_flMax", true, value);
}
std::string GVPhysXRange_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GVPhysXRange_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassVPhysXRange_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GVPhysXRange_t>("VPhysXRange_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Min", &GVPhysXRange_t::GetMin, &GVPhysXRange_t::SetMin)
        .addProperty("Max", &GVPhysXRange_t::GetMax, &GVPhysXRange_t::SetMax)
        .addFunction("ToPtr", &GVPhysXRange_t::ToPtr)
        .addFunction("IsValid", &GVPhysXRange_t::IsValid)
        .endClass();
}
GCJiggleBoneUpdateNode::GCJiggleBoneUpdateNode(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCJiggleBoneUpdateNode::GCJiggleBoneUpdateNode(void *ptr) {
    m_ptr = ptr;
}
GJiggleBoneSettingsList_t GCJiggleBoneUpdateNode::GetOpFixedData() const {
    GJiggleBoneSettingsList_t value(GetSchemaPtr(m_ptr, "CJiggleBoneUpdateNode", "m_opFixedData"));
    return value;
}
void GCJiggleBoneUpdateNode::SetOpFixedData(GJiggleBoneSettingsList_t value) {
    SetSchemaValue(m_ptr, "CJiggleBoneUpdateNode", "m_opFixedData", false, value);
}
std::string GCJiggleBoneUpdateNode::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCJiggleBoneUpdateNode::IsValid() {
    return (m_ptr != nullptr);
}
GCUnaryUpdateNode GCJiggleBoneUpdateNode::GetParent() const {
    GCUnaryUpdateNode value(m_ptr);
    return value;
}
void GCJiggleBoneUpdateNode::SetParent(GCUnaryUpdateNode value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCJiggleBoneUpdateNode(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCJiggleBoneUpdateNode>("CJiggleBoneUpdateNode")
        .addConstructor<void (*)(std::string)>()
        .addProperty("OpFixedData", &GCJiggleBoneUpdateNode::GetOpFixedData, &GCJiggleBoneUpdateNode::SetOpFixedData)
        .addProperty("Parent", &GCJiggleBoneUpdateNode::GetParent, &GCJiggleBoneUpdateNode::SetParent)
        .addFunction("ToPtr", &GCJiggleBoneUpdateNode::ToPtr)
        .addFunction("IsValid", &GCJiggleBoneUpdateNode::IsValid)
        .endClass();
}
GCollisionGroupContext_t::GCollisionGroupContext_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCollisionGroupContext_t::GCollisionGroupContext_t(void *ptr) {
    m_ptr = ptr;
}
int32_t GCollisionGroupContext_t::GetCollisionGroupNumber() const {
    return GetSchemaValue<int32_t>(m_ptr, "CollisionGroupContext_t", "m_nCollisionGroupNumber");
}
void GCollisionGroupContext_t::SetCollisionGroupNumber(int32_t value) {
    SetSchemaValue(m_ptr, "CollisionGroupContext_t", "m_nCollisionGroupNumber", true, value);
}
std::string GCollisionGroupContext_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCollisionGroupContext_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCollisionGroupContext_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCollisionGroupContext_t>("CollisionGroupContext_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("CollisionGroupNumber", &GCollisionGroupContext_t::GetCollisionGroupNumber, &GCollisionGroupContext_t::SetCollisionGroupNumber)
        .addFunction("ToPtr", &GCollisionGroupContext_t::ToPtr)
        .addFunction("IsValid", &GCollisionGroupContext_t::IsValid)
        .endClass();
}
GCAudioPhonemeTag::GCAudioPhonemeTag(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCAudioPhonemeTag::GCAudioPhonemeTag(void *ptr) {
    m_ptr = ptr;
}
float GCAudioPhonemeTag::GetStartTime() const {
    return GetSchemaValue<float>(m_ptr, "CAudioPhonemeTag", "m_flStartTime");
}
void GCAudioPhonemeTag::SetStartTime(float value) {
    SetSchemaValue(m_ptr, "CAudioPhonemeTag", "m_flStartTime", false, value);
}
float GCAudioPhonemeTag::GetEndTime() const {
    return GetSchemaValue<float>(m_ptr, "CAudioPhonemeTag", "m_flEndTime");
}
void GCAudioPhonemeTag::SetEndTime(float value) {
    SetSchemaValue(m_ptr, "CAudioPhonemeTag", "m_flEndTime", false, value);
}
int32_t GCAudioPhonemeTag::GetPhonemeCode() const {
    return GetSchemaValue<int32_t>(m_ptr, "CAudioPhonemeTag", "m_nPhonemeCode");
}
void GCAudioPhonemeTag::SetPhonemeCode(int32_t value) {
    SetSchemaValue(m_ptr, "CAudioPhonemeTag", "m_nPhonemeCode", false, value);
}
std::string GCAudioPhonemeTag::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCAudioPhonemeTag::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCAudioPhonemeTag(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCAudioPhonemeTag>("CAudioPhonemeTag")
        .addConstructor<void (*)(std::string)>()
        .addProperty("StartTime", &GCAudioPhonemeTag::GetStartTime, &GCAudioPhonemeTag::SetStartTime)
        .addProperty("EndTime", &GCAudioPhonemeTag::GetEndTime, &GCAudioPhonemeTag::SetEndTime)
        .addProperty("PhonemeCode", &GCAudioPhonemeTag::GetPhonemeCode, &GCAudioPhonemeTag::SetPhonemeCode)
        .addFunction("ToPtr", &GCAudioPhonemeTag::ToPtr)
        .addFunction("IsValid", &GCAudioPhonemeTag::IsValid)
        .endClass();
}
GCAnimData::GCAnimData(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCAnimData::GCAnimData(void *ptr) {
    m_ptr = ptr;
}
CBufferString GCAnimData::GetName() const {
    return GetSchemaValue<CBufferString>(m_ptr, "CAnimData", "m_name");
}
void GCAnimData::SetName(CBufferString value) {
    SetSchemaValue(m_ptr, "CAnimData", "m_name", false, value);
}
std::vector<GCAnimDesc> GCAnimData::GetAnimArray() const {
    CUtlVector<GCAnimDesc>* vec = GetSchemaValue<CUtlVector<GCAnimDesc>*>(m_ptr, "CAnimData", "m_animArray"); std::vector<GCAnimDesc> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCAnimData::SetAnimArray(std::vector<GCAnimDesc> value) {
    SetSchemaValueCUtlVector<GCAnimDesc>(m_ptr, "CAnimData", "m_animArray", false, value);
}
std::vector<GCAnimDecoder> GCAnimData::GetDecoderArray() const {
    CUtlVector<GCAnimDecoder>* vec = GetSchemaValue<CUtlVector<GCAnimDecoder>*>(m_ptr, "CAnimData", "m_decoderArray"); std::vector<GCAnimDecoder> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCAnimData::SetDecoderArray(std::vector<GCAnimDecoder> value) {
    SetSchemaValueCUtlVector<GCAnimDecoder>(m_ptr, "CAnimData", "m_decoderArray", false, value);
}
int32_t GCAnimData::GetMaxUniqueFrameIndex() const {
    return GetSchemaValue<int32_t>(m_ptr, "CAnimData", "m_nMaxUniqueFrameIndex");
}
void GCAnimData::SetMaxUniqueFrameIndex(int32_t value) {
    SetSchemaValue(m_ptr, "CAnimData", "m_nMaxUniqueFrameIndex", false, value);
}
std::vector<GCAnimFrameSegment> GCAnimData::GetSegmentArray() const {
    CUtlVector<GCAnimFrameSegment>* vec = GetSchemaValue<CUtlVector<GCAnimFrameSegment>*>(m_ptr, "CAnimData", "m_segmentArray"); std::vector<GCAnimFrameSegment> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCAnimData::SetSegmentArray(std::vector<GCAnimFrameSegment> value) {
    SetSchemaValueCUtlVector<GCAnimFrameSegment>(m_ptr, "CAnimData", "m_segmentArray", false, value);
}
std::string GCAnimData::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCAnimData::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCAnimData(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCAnimData>("CAnimData")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Name", &GCAnimData::GetName, &GCAnimData::SetName)
        .addProperty("AnimArray", &GCAnimData::GetAnimArray, &GCAnimData::SetAnimArray)
        .addProperty("DecoderArray", &GCAnimData::GetDecoderArray, &GCAnimData::SetDecoderArray)
        .addProperty("MaxUniqueFrameIndex", &GCAnimData::GetMaxUniqueFrameIndex, &GCAnimData::SetMaxUniqueFrameIndex)
        .addProperty("SegmentArray", &GCAnimData::GetSegmentArray, &GCAnimData::SetSegmentArray)
        .addFunction("ToPtr", &GCAnimData::ToPtr)
        .addFunction("IsValid", &GCAnimData::IsValid)
        .endClass();
}
GSosEditItemInfo_t::GSosEditItemInfo_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GSosEditItemInfo_t::GSosEditItemInfo_t(void *ptr) {
    m_ptr = ptr;
}
uint64_t GSosEditItemInfo_t::GetItemType() const {
    return GetSchemaValue<uint64_t>(m_ptr, "SosEditItemInfo_t", "itemType");
}
void GSosEditItemInfo_t::SetItemType(uint64_t value) {
    SetSchemaValue(m_ptr, "SosEditItemInfo_t", "itemType", true, value);
}
std::string GSosEditItemInfo_t::GetItemName() const {
    return GetSchemaValue<CUtlString>(m_ptr, "SosEditItemInfo_t", "itemName").Get();
}
void GSosEditItemInfo_t::SetItemName(std::string value) {
    SetSchemaValue(m_ptr, "SosEditItemInfo_t", "itemName", true, CUtlString(value.c_str()));
}
std::string GSosEditItemInfo_t::GetItemTypeName() const {
    return GetSchemaValue<CUtlString>(m_ptr, "SosEditItemInfo_t", "itemTypeName").Get();
}
void GSosEditItemInfo_t::SetItemTypeName(std::string value) {
    SetSchemaValue(m_ptr, "SosEditItemInfo_t", "itemTypeName", true, CUtlString(value.c_str()));
}
std::string GSosEditItemInfo_t::GetItemKVString() const {
    return GetSchemaValue<CUtlString>(m_ptr, "SosEditItemInfo_t", "itemKVString").Get();
}
void GSosEditItemInfo_t::SetItemKVString(std::string value) {
    SetSchemaValue(m_ptr, "SosEditItemInfo_t", "itemKVString", true, CUtlString(value.c_str()));
}
Vector2D GSosEditItemInfo_t::GetItemPos() const {
    return GetSchemaValue<Vector2D>(m_ptr, "SosEditItemInfo_t", "itemPos");
}
void GSosEditItemInfo_t::SetItemPos(Vector2D value) {
    SetSchemaValue(m_ptr, "SosEditItemInfo_t", "itemPos", true, value);
}
std::string GSosEditItemInfo_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GSosEditItemInfo_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassSosEditItemInfo_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GSosEditItemInfo_t>("SosEditItemInfo_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("ItemType", &GSosEditItemInfo_t::GetItemType, &GSosEditItemInfo_t::SetItemType)
        .addProperty("ItemName", &GSosEditItemInfo_t::GetItemName, &GSosEditItemInfo_t::SetItemName)
        .addProperty("ItemTypeName", &GSosEditItemInfo_t::GetItemTypeName, &GSosEditItemInfo_t::SetItemTypeName)
        .addProperty("ItemKVString", &GSosEditItemInfo_t::GetItemKVString, &GSosEditItemInfo_t::SetItemKVString)
        .addProperty("ItemPos", &GSosEditItemInfo_t::GetItemPos, &GSosEditItemInfo_t::SetItemPos)
        .addFunction("ToPtr", &GSosEditItemInfo_t::ToPtr)
        .addFunction("IsValid", &GSosEditItemInfo_t::IsValid)
        .endClass();
}
GFeFitInfluence_t::GFeFitInfluence_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GFeFitInfluence_t::GFeFitInfluence_t(void *ptr) {
    m_ptr = ptr;
}
uint32_t GFeFitInfluence_t::GetVertexNode() const {
    return GetSchemaValue<uint32_t>(m_ptr, "FeFitInfluence_t", "nVertexNode");
}
void GFeFitInfluence_t::SetVertexNode(uint32_t value) {
    SetSchemaValue(m_ptr, "FeFitInfluence_t", "nVertexNode", true, value);
}
float GFeFitInfluence_t::GetWeight() const {
    return GetSchemaValue<float>(m_ptr, "FeFitInfluence_t", "flWeight");
}
void GFeFitInfluence_t::SetWeight(float value) {
    SetSchemaValue(m_ptr, "FeFitInfluence_t", "flWeight", true, value);
}
uint32_t GFeFitInfluence_t::GetMatrixNode() const {
    return GetSchemaValue<uint32_t>(m_ptr, "FeFitInfluence_t", "nMatrixNode");
}
void GFeFitInfluence_t::SetMatrixNode(uint32_t value) {
    SetSchemaValue(m_ptr, "FeFitInfluence_t", "nMatrixNode", true, value);
}
std::string GFeFitInfluence_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GFeFitInfluence_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassFeFitInfluence_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GFeFitInfluence_t>("FeFitInfluence_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("VertexNode", &GFeFitInfluence_t::GetVertexNode, &GFeFitInfluence_t::SetVertexNode)
        .addProperty("Weight", &GFeFitInfluence_t::GetWeight, &GFeFitInfluence_t::SetWeight)
        .addProperty("MatrixNode", &GFeFitInfluence_t::GetMatrixNode, &GFeFitInfluence_t::SetMatrixNode)
        .addFunction("ToPtr", &GFeFitInfluence_t::ToPtr)
        .addFunction("IsValid", &GFeFitInfluence_t::IsValid)
        .endClass();
}
GCInputStreamUpdateNode::GCInputStreamUpdateNode(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCInputStreamUpdateNode::GCInputStreamUpdateNode(void *ptr) {
    m_ptr = ptr;
}
std::string GCInputStreamUpdateNode::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCInputStreamUpdateNode::IsValid() {
    return (m_ptr != nullptr);
}
GCLeafUpdateNode GCInputStreamUpdateNode::GetParent() const {
    GCLeafUpdateNode value(m_ptr);
    return value;
}
void GCInputStreamUpdateNode::SetParent(GCLeafUpdateNode value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCInputStreamUpdateNode(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCInputStreamUpdateNode>("CInputStreamUpdateNode")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCInputStreamUpdateNode::GetParent, &GCInputStreamUpdateNode::SetParent)
        .addFunction("ToPtr", &GCInputStreamUpdateNode::ToPtr)
        .addFunction("IsValid", &GCInputStreamUpdateNode::IsValid)
        .endClass();
}
GEventClientPollInput_t::GEventClientPollInput_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GEventClientPollInput_t::GEventClientPollInput_t(void *ptr) {
    m_ptr = ptr;
}
GEngineLoopState_t GEventClientPollInput_t::GetLoopState() const {
    GEngineLoopState_t value(GetSchemaPtr(m_ptr, "EventClientPollInput_t", "m_LoopState"));
    return value;
}
void GEventClientPollInput_t::SetLoopState(GEngineLoopState_t value) {
    SetSchemaValue(m_ptr, "EventClientPollInput_t", "m_LoopState", true, value);
}
float GEventClientPollInput_t::GetRealTime() const {
    return GetSchemaValue<float>(m_ptr, "EventClientPollInput_t", "m_flRealTime");
}
void GEventClientPollInput_t::SetRealTime(float value) {
    SetSchemaValue(m_ptr, "EventClientPollInput_t", "m_flRealTime", true, value);
}
std::string GEventClientPollInput_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GEventClientPollInput_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassEventClientPollInput_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GEventClientPollInput_t>("EventClientPollInput_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("LoopState", &GEventClientPollInput_t::GetLoopState, &GEventClientPollInput_t::SetLoopState)
        .addProperty("RealTime", &GEventClientPollInput_t::GetRealTime, &GEventClientPollInput_t::SetRealTime)
        .addFunction("ToPtr", &GEventClientPollInput_t::ToPtr)
        .addFunction("IsValid", &GEventClientPollInput_t::IsValid)
        .endClass();
}
GFeSimdQuad_t::GFeSimdQuad_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GFeSimdQuad_t::GFeSimdQuad_t(void *ptr) {
    m_ptr = ptr;
}
float GFeSimdQuad_t::Get4Slack() const {
    return GetSchemaValue<float>(m_ptr, "FeSimdQuad_t", "f4Slack");
}
void GFeSimdQuad_t::Set4Slack(float value) {
    SetSchemaValue(m_ptr, "FeSimdQuad_t", "f4Slack", true, value);
}
std::vector<float> GFeSimdQuad_t::Get4Weights() const {
    float* outValue = GetSchemaValue<float*>(m_ptr, "FeSimdQuad_t", "f4Weights"); std::vector<float> ret; for(int i = 0; i < 4; i++) { ret.push_back(outValue[i]); } return ret;
}
void GFeSimdQuad_t::Set4Weights(std::vector<float> value) {
    float* outValue = GetSchemaValue<float*>(m_ptr, "FeSimdQuad_t", "f4Weights"); for(int i = 0; i < 4; i++) { outValue[i] = value[i]; } SetSchemaValue(m_ptr, "FeSimdQuad_t", "f4Weights", true, outValue);
}
std::string GFeSimdQuad_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GFeSimdQuad_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassFeSimdQuad_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GFeSimdQuad_t>("FeSimdQuad_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("4Slack", &GFeSimdQuad_t::Get4Slack, &GFeSimdQuad_t::Set4Slack)
        .addProperty("4Weights", &GFeSimdQuad_t::Get4Weights, &GFeSimdQuad_t::Set4Weights)
        .addFunction("ToPtr", &GFeSimdQuad_t::ToPtr)
        .addFunction("IsValid", &GFeSimdQuad_t::IsValid)
        .endClass();
}
GCEmitTagActionUpdater::GCEmitTagActionUpdater(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCEmitTagActionUpdater::GCEmitTagActionUpdater(void *ptr) {
    m_ptr = ptr;
}
int32_t GCEmitTagActionUpdater::GetTagIndex() const {
    return GetSchemaValue<int32_t>(m_ptr, "CEmitTagActionUpdater", "m_nTagIndex");
}
void GCEmitTagActionUpdater::SetTagIndex(int32_t value) {
    SetSchemaValue(m_ptr, "CEmitTagActionUpdater", "m_nTagIndex", false, value);
}
bool GCEmitTagActionUpdater::GetIsZeroDuration() const {
    return GetSchemaValue<bool>(m_ptr, "CEmitTagActionUpdater", "m_bIsZeroDuration");
}
void GCEmitTagActionUpdater::SetIsZeroDuration(bool value) {
    SetSchemaValue(m_ptr, "CEmitTagActionUpdater", "m_bIsZeroDuration", false, value);
}
std::string GCEmitTagActionUpdater::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCEmitTagActionUpdater::IsValid() {
    return (m_ptr != nullptr);
}
GCAnimActionUpdater GCEmitTagActionUpdater::GetParent() const {
    GCAnimActionUpdater value(m_ptr);
    return value;
}
void GCEmitTagActionUpdater::SetParent(GCAnimActionUpdater value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCEmitTagActionUpdater(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCEmitTagActionUpdater>("CEmitTagActionUpdater")
        .addConstructor<void (*)(std::string)>()
        .addProperty("TagIndex", &GCEmitTagActionUpdater::GetTagIndex, &GCEmitTagActionUpdater::SetTagIndex)
        .addProperty("IsZeroDuration", &GCEmitTagActionUpdater::GetIsZeroDuration, &GCEmitTagActionUpdater::SetIsZeroDuration)
        .addProperty("Parent", &GCEmitTagActionUpdater::GetParent, &GCEmitTagActionUpdater::SetParent)
        .addFunction("ToPtr", &GCEmitTagActionUpdater::ToPtr)
        .addFunction("IsValid", &GCEmitTagActionUpdater::IsValid)
        .endClass();
}
GCAddUpdateNode::GCAddUpdateNode(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCAddUpdateNode::GCAddUpdateNode(void *ptr) {
    m_ptr = ptr;
}
uint64_t GCAddUpdateNode::GetFootMotionTiming() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CAddUpdateNode", "m_footMotionTiming");
}
void GCAddUpdateNode::SetFootMotionTiming(uint64_t value) {
    SetSchemaValue(m_ptr, "CAddUpdateNode", "m_footMotionTiming", false, value);
}
bool GCAddUpdateNode::GetApplyToFootMotion() const {
    return GetSchemaValue<bool>(m_ptr, "CAddUpdateNode", "m_bApplyToFootMotion");
}
void GCAddUpdateNode::SetApplyToFootMotion(bool value) {
    SetSchemaValue(m_ptr, "CAddUpdateNode", "m_bApplyToFootMotion", false, value);
}
bool GCAddUpdateNode::GetApplyChannelsSeparately() const {
    return GetSchemaValue<bool>(m_ptr, "CAddUpdateNode", "m_bApplyChannelsSeparately");
}
void GCAddUpdateNode::SetApplyChannelsSeparately(bool value) {
    SetSchemaValue(m_ptr, "CAddUpdateNode", "m_bApplyChannelsSeparately", false, value);
}
bool GCAddUpdateNode::GetUseModelSpace() const {
    return GetSchemaValue<bool>(m_ptr, "CAddUpdateNode", "m_bUseModelSpace");
}
void GCAddUpdateNode::SetUseModelSpace(bool value) {
    SetSchemaValue(m_ptr, "CAddUpdateNode", "m_bUseModelSpace", false, value);
}
bool GCAddUpdateNode::GetApplyScale() const {
    return GetSchemaValue<bool>(m_ptr, "CAddUpdateNode", "m_bApplyScale");
}
void GCAddUpdateNode::SetApplyScale(bool value) {
    SetSchemaValue(m_ptr, "CAddUpdateNode", "m_bApplyScale", false, value);
}
std::string GCAddUpdateNode::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCAddUpdateNode::IsValid() {
    return (m_ptr != nullptr);
}
GCBinaryUpdateNode GCAddUpdateNode::GetParent() const {
    GCBinaryUpdateNode value(m_ptr);
    return value;
}
void GCAddUpdateNode::SetParent(GCBinaryUpdateNode value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCAddUpdateNode(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCAddUpdateNode>("CAddUpdateNode")
        .addConstructor<void (*)(std::string)>()
        .addProperty("FootMotionTiming", &GCAddUpdateNode::GetFootMotionTiming, &GCAddUpdateNode::SetFootMotionTiming)
        .addProperty("ApplyToFootMotion", &GCAddUpdateNode::GetApplyToFootMotion, &GCAddUpdateNode::SetApplyToFootMotion)
        .addProperty("ApplyChannelsSeparately", &GCAddUpdateNode::GetApplyChannelsSeparately, &GCAddUpdateNode::SetApplyChannelsSeparately)
        .addProperty("UseModelSpace", &GCAddUpdateNode::GetUseModelSpace, &GCAddUpdateNode::SetUseModelSpace)
        .addProperty("ApplyScale", &GCAddUpdateNode::GetApplyScale, &GCAddUpdateNode::SetApplyScale)
        .addProperty("Parent", &GCAddUpdateNode::GetParent, &GCAddUpdateNode::SetParent)
        .addFunction("ToPtr", &GCAddUpdateNode::ToPtr)
        .addFunction("IsValid", &GCAddUpdateNode::IsValid)
        .endClass();
}
GCAnimTagManagerUpdater::GCAnimTagManagerUpdater(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCAnimTagManagerUpdater::GCAnimTagManagerUpdater(void *ptr) {
    m_ptr = ptr;
}
std::string GCAnimTagManagerUpdater::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCAnimTagManagerUpdater::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCAnimTagManagerUpdater(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCAnimTagManagerUpdater>("CAnimTagManagerUpdater")
        .addConstructor<void (*)(std::string)>()
        .addFunction("ToPtr", &GCAnimTagManagerUpdater::ToPtr)
        .addFunction("IsValid", &GCAnimTagManagerUpdater::IsValid)
        .endClass();
}
GSampleCode::GSampleCode(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GSampleCode::GSampleCode(void *ptr) {
    m_ptr = ptr;
}
std::vector<uint8_t> GSampleCode::GetSubCode() const {
    uint8_t* outValue = GetSchemaValue<uint8_t*>(m_ptr, "SampleCode", "m_subCode"); std::vector<uint8_t> ret; for(int i = 0; i < 8; i++) { ret.push_back(outValue[i]); } return ret;
}
void GSampleCode::SetSubCode(std::vector<uint8_t> value) {
    uint8_t* outValue = GetSchemaValue<uint8_t*>(m_ptr, "SampleCode", "m_subCode"); for(int i = 0; i < 8; i++) { outValue[i] = value[i]; } SetSchemaValue(m_ptr, "SampleCode", "m_subCode", false, outValue);
}
std::string GSampleCode::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GSampleCode::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassSampleCode(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GSampleCode>("SampleCode")
        .addConstructor<void (*)(std::string)>()
        .addProperty("SubCode", &GSampleCode::GetSubCode, &GSampleCode::SetSubCode)
        .addFunction("ToPtr", &GSampleCode::ToPtr)
        .addFunction("IsValid", &GSampleCode::IsValid)
        .endClass();
}
GCExpressionActionUpdater::GCExpressionActionUpdater(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCExpressionActionUpdater::GCExpressionActionUpdater(void *ptr) {
    m_ptr = ptr;
}
GCAnimParamHandle GCExpressionActionUpdater::GetParam() const {
    GCAnimParamHandle value(GetSchemaPtr(m_ptr, "CExpressionActionUpdater", "m_hParam"));
    return value;
}
void GCExpressionActionUpdater::SetParam(GCAnimParamHandle value) {
    SetSchemaValue(m_ptr, "CExpressionActionUpdater", "m_hParam", false, value);
}
uint64_t GCExpressionActionUpdater::GetParamType() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CExpressionActionUpdater", "m_eParamType");
}
void GCExpressionActionUpdater::SetParamType(uint64_t value) {
    SetSchemaValue(m_ptr, "CExpressionActionUpdater", "m_eParamType", false, value);
}
GAnimScriptHandle GCExpressionActionUpdater::GetScript() const {
    GAnimScriptHandle value(GetSchemaPtr(m_ptr, "CExpressionActionUpdater", "m_hScript"));
    return value;
}
void GCExpressionActionUpdater::SetScript(GAnimScriptHandle value) {
    SetSchemaValue(m_ptr, "CExpressionActionUpdater", "m_hScript", false, value);
}
std::string GCExpressionActionUpdater::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCExpressionActionUpdater::IsValid() {
    return (m_ptr != nullptr);
}
GCAnimActionUpdater GCExpressionActionUpdater::GetParent() const {
    GCAnimActionUpdater value(m_ptr);
    return value;
}
void GCExpressionActionUpdater::SetParent(GCAnimActionUpdater value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCExpressionActionUpdater(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCExpressionActionUpdater>("CExpressionActionUpdater")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Param", &GCExpressionActionUpdater::GetParam, &GCExpressionActionUpdater::SetParam)
        .addProperty("ParamType", &GCExpressionActionUpdater::GetParamType, &GCExpressionActionUpdater::SetParamType)
        .addProperty("Script", &GCExpressionActionUpdater::GetScript, &GCExpressionActionUpdater::SetScript)
        .addProperty("Parent", &GCExpressionActionUpdater::GetParent, &GCExpressionActionUpdater::SetParent)
        .addFunction("ToPtr", &GCExpressionActionUpdater::ToPtr)
        .addFunction("IsValid", &GCExpressionActionUpdater::IsValid)
        .endClass();
}
GEventClientPostAdvanceTick_t::GEventClientPostAdvanceTick_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GEventClientPostAdvanceTick_t::GEventClientPostAdvanceTick_t(void *ptr) {
    m_ptr = ptr;
}
std::string GEventClientPostAdvanceTick_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GEventClientPostAdvanceTick_t::IsValid() {
    return (m_ptr != nullptr);
}
GEventPostAdvanceTick_t GEventClientPostAdvanceTick_t::GetParent() const {
    GEventPostAdvanceTick_t value(m_ptr);
    return value;
}
void GEventClientPostAdvanceTick_t::SetParent(GEventPostAdvanceTick_t value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassEventClientPostAdvanceTick_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GEventClientPostAdvanceTick_t>("EventClientPostAdvanceTick_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GEventClientPostAdvanceTick_t::GetParent, &GEventClientPostAdvanceTick_t::SetParent)
        .addFunction("ToPtr", &GEventClientPostAdvanceTick_t::ToPtr)
        .addFunction("IsValid", &GEventClientPostAdvanceTick_t::IsValid)
        .endClass();
}
GBoneDemoCaptureSettings_t::GBoneDemoCaptureSettings_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GBoneDemoCaptureSettings_t::GBoneDemoCaptureSettings_t(void *ptr) {
    m_ptr = ptr;
}
std::string GBoneDemoCaptureSettings_t::GetBoneName() const {
    return GetSchemaValue<CUtlString>(m_ptr, "BoneDemoCaptureSettings_t", "m_boneName").Get();
}
void GBoneDemoCaptureSettings_t::SetBoneName(std::string value) {
    SetSchemaValue(m_ptr, "BoneDemoCaptureSettings_t", "m_boneName", true, CUtlString(value.c_str()));
}
float GBoneDemoCaptureSettings_t::GetErrorSplineRotationMax() const {
    return GetSchemaValue<float>(m_ptr, "BoneDemoCaptureSettings_t", "m_flErrorSplineRotationMax");
}
void GBoneDemoCaptureSettings_t::SetErrorSplineRotationMax(float value) {
    SetSchemaValue(m_ptr, "BoneDemoCaptureSettings_t", "m_flErrorSplineRotationMax", true, value);
}
float GBoneDemoCaptureSettings_t::GetErrorSplineTranslationMax() const {
    return GetSchemaValue<float>(m_ptr, "BoneDemoCaptureSettings_t", "m_flErrorSplineTranslationMax");
}
void GBoneDemoCaptureSettings_t::SetErrorSplineTranslationMax(float value) {
    SetSchemaValue(m_ptr, "BoneDemoCaptureSettings_t", "m_flErrorSplineTranslationMax", true, value);
}
float GBoneDemoCaptureSettings_t::GetErrorSplineScaleMax() const {
    return GetSchemaValue<float>(m_ptr, "BoneDemoCaptureSettings_t", "m_flErrorSplineScaleMax");
}
void GBoneDemoCaptureSettings_t::SetErrorSplineScaleMax(float value) {
    SetSchemaValue(m_ptr, "BoneDemoCaptureSettings_t", "m_flErrorSplineScaleMax", true, value);
}
float GBoneDemoCaptureSettings_t::GetErrorQuantizationRotationMax() const {
    return GetSchemaValue<float>(m_ptr, "BoneDemoCaptureSettings_t", "m_flErrorQuantizationRotationMax");
}
void GBoneDemoCaptureSettings_t::SetErrorQuantizationRotationMax(float value) {
    SetSchemaValue(m_ptr, "BoneDemoCaptureSettings_t", "m_flErrorQuantizationRotationMax", true, value);
}
float GBoneDemoCaptureSettings_t::GetErrorQuantizationTranslationMax() const {
    return GetSchemaValue<float>(m_ptr, "BoneDemoCaptureSettings_t", "m_flErrorQuantizationTranslationMax");
}
void GBoneDemoCaptureSettings_t::SetErrorQuantizationTranslationMax(float value) {
    SetSchemaValue(m_ptr, "BoneDemoCaptureSettings_t", "m_flErrorQuantizationTranslationMax", true, value);
}
float GBoneDemoCaptureSettings_t::GetErrorQuantizationScaleMax() const {
    return GetSchemaValue<float>(m_ptr, "BoneDemoCaptureSettings_t", "m_flErrorQuantizationScaleMax");
}
void GBoneDemoCaptureSettings_t::SetErrorQuantizationScaleMax(float value) {
    SetSchemaValue(m_ptr, "BoneDemoCaptureSettings_t", "m_flErrorQuantizationScaleMax", true, value);
}
std::string GBoneDemoCaptureSettings_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GBoneDemoCaptureSettings_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassBoneDemoCaptureSettings_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GBoneDemoCaptureSettings_t>("BoneDemoCaptureSettings_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("BoneName", &GBoneDemoCaptureSettings_t::GetBoneName, &GBoneDemoCaptureSettings_t::SetBoneName)
        .addProperty("ErrorSplineRotationMax", &GBoneDemoCaptureSettings_t::GetErrorSplineRotationMax, &GBoneDemoCaptureSettings_t::SetErrorSplineRotationMax)
        .addProperty("ErrorSplineTranslationMax", &GBoneDemoCaptureSettings_t::GetErrorSplineTranslationMax, &GBoneDemoCaptureSettings_t::SetErrorSplineTranslationMax)
        .addProperty("ErrorSplineScaleMax", &GBoneDemoCaptureSettings_t::GetErrorSplineScaleMax, &GBoneDemoCaptureSettings_t::SetErrorSplineScaleMax)
        .addProperty("ErrorQuantizationRotationMax", &GBoneDemoCaptureSettings_t::GetErrorQuantizationRotationMax, &GBoneDemoCaptureSettings_t::SetErrorQuantizationRotationMax)
        .addProperty("ErrorQuantizationTranslationMax", &GBoneDemoCaptureSettings_t::GetErrorQuantizationTranslationMax, &GBoneDemoCaptureSettings_t::SetErrorQuantizationTranslationMax)
        .addProperty("ErrorQuantizationScaleMax", &GBoneDemoCaptureSettings_t::GetErrorQuantizationScaleMax, &GBoneDemoCaptureSettings_t::SetErrorQuantizationScaleMax)
        .addFunction("ToPtr", &GBoneDemoCaptureSettings_t::ToPtr)
        .addFunction("IsValid", &GBoneDemoCaptureSettings_t::IsValid)
        .endClass();
}
GVPhysXBodyPart_t::GVPhysXBodyPart_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GVPhysXBodyPart_t::GVPhysXBodyPart_t(void *ptr) {
    m_ptr = ptr;
}
uint32_t GVPhysXBodyPart_t::GetFlags() const {
    return GetSchemaValue<uint32_t>(m_ptr, "VPhysXBodyPart_t", "m_nFlags");
}
void GVPhysXBodyPart_t::SetFlags(uint32_t value) {
    SetSchemaValue(m_ptr, "VPhysXBodyPart_t", "m_nFlags", true, value);
}
float GVPhysXBodyPart_t::GetMass() const {
    return GetSchemaValue<float>(m_ptr, "VPhysXBodyPart_t", "m_flMass");
}
void GVPhysXBodyPart_t::SetMass(float value) {
    SetSchemaValue(m_ptr, "VPhysXBodyPart_t", "m_flMass", true, value);
}
GVPhysics2ShapeDef_t GVPhysXBodyPart_t::GetRnShape() const {
    GVPhysics2ShapeDef_t value(GetSchemaPtr(m_ptr, "VPhysXBodyPart_t", "m_rnShape"));
    return value;
}
void GVPhysXBodyPart_t::SetRnShape(GVPhysics2ShapeDef_t value) {
    SetSchemaValue(m_ptr, "VPhysXBodyPart_t", "m_rnShape", true, value);
}
uint16_t GVPhysXBodyPart_t::GetCollisionAttributeIndex() const {
    return GetSchemaValue<uint16_t>(m_ptr, "VPhysXBodyPart_t", "m_nCollisionAttributeIndex");
}
void GVPhysXBodyPart_t::SetCollisionAttributeIndex(uint16_t value) {
    SetSchemaValue(m_ptr, "VPhysXBodyPart_t", "m_nCollisionAttributeIndex", true, value);
}
uint16_t GVPhysXBodyPart_t::GetReserved() const {
    return GetSchemaValue<uint16_t>(m_ptr, "VPhysXBodyPart_t", "m_nReserved");
}
void GVPhysXBodyPart_t::SetReserved(uint16_t value) {
    SetSchemaValue(m_ptr, "VPhysXBodyPart_t", "m_nReserved", true, value);
}
float GVPhysXBodyPart_t::GetInertiaScale() const {
    return GetSchemaValue<float>(m_ptr, "VPhysXBodyPart_t", "m_flInertiaScale");
}
void GVPhysXBodyPart_t::SetInertiaScale(float value) {
    SetSchemaValue(m_ptr, "VPhysXBodyPart_t", "m_flInertiaScale", true, value);
}
float GVPhysXBodyPart_t::GetLinearDamping() const {
    return GetSchemaValue<float>(m_ptr, "VPhysXBodyPart_t", "m_flLinearDamping");
}
void GVPhysXBodyPart_t::SetLinearDamping(float value) {
    SetSchemaValue(m_ptr, "VPhysXBodyPart_t", "m_flLinearDamping", true, value);
}
float GVPhysXBodyPart_t::GetAngularDamping() const {
    return GetSchemaValue<float>(m_ptr, "VPhysXBodyPart_t", "m_flAngularDamping");
}
void GVPhysXBodyPart_t::SetAngularDamping(float value) {
    SetSchemaValue(m_ptr, "VPhysXBodyPart_t", "m_flAngularDamping", true, value);
}
bool GVPhysXBodyPart_t::GetOverrideMassCenter() const {
    return GetSchemaValue<bool>(m_ptr, "VPhysXBodyPart_t", "m_bOverrideMassCenter");
}
void GVPhysXBodyPart_t::SetOverrideMassCenter(bool value) {
    SetSchemaValue(m_ptr, "VPhysXBodyPart_t", "m_bOverrideMassCenter", true, value);
}
Vector GVPhysXBodyPart_t::GetMassCenterOverride() const {
    return GetSchemaValue<Vector>(m_ptr, "VPhysXBodyPart_t", "m_vMassCenterOverride");
}
void GVPhysXBodyPart_t::SetMassCenterOverride(Vector value) {
    SetSchemaValue(m_ptr, "VPhysXBodyPart_t", "m_vMassCenterOverride", true, value);
}
std::string GVPhysXBodyPart_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GVPhysXBodyPart_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassVPhysXBodyPart_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GVPhysXBodyPart_t>("VPhysXBodyPart_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Flags", &GVPhysXBodyPart_t::GetFlags, &GVPhysXBodyPart_t::SetFlags)
        .addProperty("Mass", &GVPhysXBodyPart_t::GetMass, &GVPhysXBodyPart_t::SetMass)
        .addProperty("RnShape", &GVPhysXBodyPart_t::GetRnShape, &GVPhysXBodyPart_t::SetRnShape)
        .addProperty("CollisionAttributeIndex", &GVPhysXBodyPart_t::GetCollisionAttributeIndex, &GVPhysXBodyPart_t::SetCollisionAttributeIndex)
        .addProperty("Reserved", &GVPhysXBodyPart_t::GetReserved, &GVPhysXBodyPart_t::SetReserved)
        .addProperty("InertiaScale", &GVPhysXBodyPart_t::GetInertiaScale, &GVPhysXBodyPart_t::SetInertiaScale)
        .addProperty("LinearDamping", &GVPhysXBodyPart_t::GetLinearDamping, &GVPhysXBodyPart_t::SetLinearDamping)
        .addProperty("AngularDamping", &GVPhysXBodyPart_t::GetAngularDamping, &GVPhysXBodyPart_t::SetAngularDamping)
        .addProperty("OverrideMassCenter", &GVPhysXBodyPart_t::GetOverrideMassCenter, &GVPhysXBodyPart_t::SetOverrideMassCenter)
        .addProperty("MassCenterOverride", &GVPhysXBodyPart_t::GetMassCenterOverride, &GVPhysXBodyPart_t::SetMassCenterOverride)
        .addFunction("ToPtr", &GVPhysXBodyPart_t::ToPtr)
        .addFunction("IsValid", &GVPhysXBodyPart_t::IsValid)
        .endClass();
}
GCDecalInfo::GCDecalInfo(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCDecalInfo::GCDecalInfo(void *ptr) {
    m_ptr = ptr;
}
float GCDecalInfo::GetAnimationScale() const {
    return GetSchemaValue<float>(m_ptr, "CDecalInfo", "m_flAnimationScale");
}
void GCDecalInfo::SetAnimationScale(float value) {
    SetSchemaValue(m_ptr, "CDecalInfo", "m_flAnimationScale", false, value);
}
float GCDecalInfo::GetAnimationLifeSpan() const {
    return GetSchemaValue<float>(m_ptr, "CDecalInfo", "m_flAnimationLifeSpan");
}
void GCDecalInfo::SetAnimationLifeSpan(float value) {
    SetSchemaValue(m_ptr, "CDecalInfo", "m_flAnimationLifeSpan", false, value);
}
float GCDecalInfo::GetPlaceTime() const {
    return GetSchemaValue<float>(m_ptr, "CDecalInfo", "m_flPlaceTime");
}
void GCDecalInfo::SetPlaceTime(float value) {
    SetSchemaValue(m_ptr, "CDecalInfo", "m_flPlaceTime", false, value);
}
float GCDecalInfo::GetFadeStartTime() const {
    return GetSchemaValue<float>(m_ptr, "CDecalInfo", "m_flFadeStartTime");
}
void GCDecalInfo::SetFadeStartTime(float value) {
    SetSchemaValue(m_ptr, "CDecalInfo", "m_flFadeStartTime", false, value);
}
float GCDecalInfo::GetFadeDuration() const {
    return GetSchemaValue<float>(m_ptr, "CDecalInfo", "m_flFadeDuration");
}
void GCDecalInfo::SetFadeDuration(float value) {
    SetSchemaValue(m_ptr, "CDecalInfo", "m_flFadeDuration", false, value);
}
int32_t GCDecalInfo::GetVBSlot() const {
    return GetSchemaValue<int32_t>(m_ptr, "CDecalInfo", "m_nVBSlot");
}
void GCDecalInfo::SetVBSlot(int32_t value) {
    SetSchemaValue(m_ptr, "CDecalInfo", "m_nVBSlot", false, value);
}
int32_t GCDecalInfo::GetBoneIndex() const {
    return GetSchemaValue<int32_t>(m_ptr, "CDecalInfo", "m_nBoneIndex");
}
void GCDecalInfo::SetBoneIndex(int32_t value) {
    SetSchemaValue(m_ptr, "CDecalInfo", "m_nBoneIndex", false, value);
}
Vector GCDecalInfo::GetPosition() const {
    return GetSchemaValue<Vector>(m_ptr, "CDecalInfo", "m_vPosition");
}
void GCDecalInfo::SetPosition(Vector value) {
    SetSchemaValue(m_ptr, "CDecalInfo", "m_vPosition", false, value);
}
float GCDecalInfo::GetBoundingRadiusSqr() const {
    return GetSchemaValue<float>(m_ptr, "CDecalInfo", "m_flBoundingRadiusSqr");
}
void GCDecalInfo::SetBoundingRadiusSqr(float value) {
    SetSchemaValue(m_ptr, "CDecalInfo", "m_flBoundingRadiusSqr", false, value);
}
GCDecalInfo GCDecalInfo::GetNext() const {
    GCDecalInfo value(*GetSchemaValuePtr<void*>(m_ptr, "CDecalInfo", "m_pNext"));
    return value;
}
void GCDecalInfo::SetNext(GCDecalInfo* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Next' is not possible.\n");
}
GCDecalInfo GCDecalInfo::GetPrev() const {
    GCDecalInfo value(*GetSchemaValuePtr<void*>(m_ptr, "CDecalInfo", "m_pPrev"));
    return value;
}
void GCDecalInfo::SetPrev(GCDecalInfo* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Prev' is not possible.\n");
}
int32_t GCDecalInfo::GetDecalMaterialIndex() const {
    return GetSchemaValue<int32_t>(m_ptr, "CDecalInfo", "m_nDecalMaterialIndex");
}
void GCDecalInfo::SetDecalMaterialIndex(int32_t value) {
    SetSchemaValue(m_ptr, "CDecalInfo", "m_nDecalMaterialIndex", false, value);
}
std::string GCDecalInfo::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCDecalInfo::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCDecalInfo(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCDecalInfo>("CDecalInfo")
        .addConstructor<void (*)(std::string)>()
        .addProperty("AnimationScale", &GCDecalInfo::GetAnimationScale, &GCDecalInfo::SetAnimationScale)
        .addProperty("AnimationLifeSpan", &GCDecalInfo::GetAnimationLifeSpan, &GCDecalInfo::SetAnimationLifeSpan)
        .addProperty("PlaceTime", &GCDecalInfo::GetPlaceTime, &GCDecalInfo::SetPlaceTime)
        .addProperty("FadeStartTime", &GCDecalInfo::GetFadeStartTime, &GCDecalInfo::SetFadeStartTime)
        .addProperty("FadeDuration", &GCDecalInfo::GetFadeDuration, &GCDecalInfo::SetFadeDuration)
        .addProperty("VBSlot", &GCDecalInfo::GetVBSlot, &GCDecalInfo::SetVBSlot)
        .addProperty("BoneIndex", &GCDecalInfo::GetBoneIndex, &GCDecalInfo::SetBoneIndex)
        .addProperty("Position", &GCDecalInfo::GetPosition, &GCDecalInfo::SetPosition)
        .addProperty("BoundingRadiusSqr", &GCDecalInfo::GetBoundingRadiusSqr, &GCDecalInfo::SetBoundingRadiusSqr)
        .addProperty("Next", &GCDecalInfo::GetNext, &GCDecalInfo::SetNext)
        .addProperty("Prev", &GCDecalInfo::GetPrev, &GCDecalInfo::SetPrev)
        .addProperty("DecalMaterialIndex", &GCDecalInfo::GetDecalMaterialIndex, &GCDecalInfo::SetDecalMaterialIndex)
        .addFunction("ToPtr", &GCDecalInfo::ToPtr)
        .addFunction("IsValid", &GCDecalInfo::IsValid)
        .endClass();
}
GParticleControlPointConfiguration_t::GParticleControlPointConfiguration_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GParticleControlPointConfiguration_t::GParticleControlPointConfiguration_t(void *ptr) {
    m_ptr = ptr;
}
std::string GParticleControlPointConfiguration_t::GetName() const {
    return GetSchemaValue<CUtlString>(m_ptr, "ParticleControlPointConfiguration_t", "m_name").Get();
}
void GParticleControlPointConfiguration_t::SetName(std::string value) {
    SetSchemaValue(m_ptr, "ParticleControlPointConfiguration_t", "m_name", true, CUtlString(value.c_str()));
}
std::vector<GParticleControlPointDriver_t> GParticleControlPointConfiguration_t::GetDrivers() const {
    CUtlVector<GParticleControlPointDriver_t>* vec = GetSchemaValue<CUtlVector<GParticleControlPointDriver_t>*>(m_ptr, "ParticleControlPointConfiguration_t", "m_drivers"); std::vector<GParticleControlPointDriver_t> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GParticleControlPointConfiguration_t::SetDrivers(std::vector<GParticleControlPointDriver_t> value) {
    SetSchemaValueCUtlVector<GParticleControlPointDriver_t>(m_ptr, "ParticleControlPointConfiguration_t", "m_drivers", true, value);
}
GParticlePreviewState_t GParticleControlPointConfiguration_t::GetPreviewState() const {
    GParticlePreviewState_t value(GetSchemaPtr(m_ptr, "ParticleControlPointConfiguration_t", "m_previewState"));
    return value;
}
void GParticleControlPointConfiguration_t::SetPreviewState(GParticlePreviewState_t value) {
    SetSchemaValue(m_ptr, "ParticleControlPointConfiguration_t", "m_previewState", true, value);
}
std::string GParticleControlPointConfiguration_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GParticleControlPointConfiguration_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassParticleControlPointConfiguration_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GParticleControlPointConfiguration_t>("ParticleControlPointConfiguration_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Name", &GParticleControlPointConfiguration_t::GetName, &GParticleControlPointConfiguration_t::SetName)
        .addProperty("Drivers", &GParticleControlPointConfiguration_t::GetDrivers, &GParticleControlPointConfiguration_t::SetDrivers)
        .addProperty("PreviewState", &GParticleControlPointConfiguration_t::GetPreviewState, &GParticleControlPointConfiguration_t::SetPreviewState)
        .addFunction("ToPtr", &GParticleControlPointConfiguration_t::ToPtr)
        .addFunction("IsValid", &GParticleControlPointConfiguration_t::IsValid)
        .endClass();
}
GVMixUtilityDesc_t::GVMixUtilityDesc_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GVMixUtilityDesc_t::GVMixUtilityDesc_t(void *ptr) {
    m_ptr = ptr;
}
uint64_t GVMixUtilityDesc_t::GetOp() const {
    return GetSchemaValue<uint64_t>(m_ptr, "VMixUtilityDesc_t", "m_nOp");
}
void GVMixUtilityDesc_t::SetOp(uint64_t value) {
    SetSchemaValue(m_ptr, "VMixUtilityDesc_t", "m_nOp", true, value);
}
float GVMixUtilityDesc_t::GetInputPan() const {
    return GetSchemaValue<float>(m_ptr, "VMixUtilityDesc_t", "m_flInputPan");
}
void GVMixUtilityDesc_t::SetInputPan(float value) {
    SetSchemaValue(m_ptr, "VMixUtilityDesc_t", "m_flInputPan", true, value);
}
float GVMixUtilityDesc_t::GetOutputBalance() const {
    return GetSchemaValue<float>(m_ptr, "VMixUtilityDesc_t", "m_flOutputBalance");
}
void GVMixUtilityDesc_t::SetOutputBalance(float value) {
    SetSchemaValue(m_ptr, "VMixUtilityDesc_t", "m_flOutputBalance", true, value);
}
float GVMixUtilityDesc_t::GetFldbOutputGain() const {
    return GetSchemaValue<float>(m_ptr, "VMixUtilityDesc_t", "m_fldbOutputGain");
}
void GVMixUtilityDesc_t::SetFldbOutputGain(float value) {
    SetSchemaValue(m_ptr, "VMixUtilityDesc_t", "m_fldbOutputGain", true, value);
}
bool GVMixUtilityDesc_t::GetBassMono() const {
    return GetSchemaValue<bool>(m_ptr, "VMixUtilityDesc_t", "m_bBassMono");
}
void GVMixUtilityDesc_t::SetBassMono(bool value) {
    SetSchemaValue(m_ptr, "VMixUtilityDesc_t", "m_bBassMono", true, value);
}
float GVMixUtilityDesc_t::GetBassFreq() const {
    return GetSchemaValue<float>(m_ptr, "VMixUtilityDesc_t", "m_flBassFreq");
}
void GVMixUtilityDesc_t::SetBassFreq(float value) {
    SetSchemaValue(m_ptr, "VMixUtilityDesc_t", "m_flBassFreq", true, value);
}
std::string GVMixUtilityDesc_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GVMixUtilityDesc_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassVMixUtilityDesc_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GVMixUtilityDesc_t>("VMixUtilityDesc_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Op", &GVMixUtilityDesc_t::GetOp, &GVMixUtilityDesc_t::SetOp)
        .addProperty("InputPan", &GVMixUtilityDesc_t::GetInputPan, &GVMixUtilityDesc_t::SetInputPan)
        .addProperty("OutputBalance", &GVMixUtilityDesc_t::GetOutputBalance, &GVMixUtilityDesc_t::SetOutputBalance)
        .addProperty("FldbOutputGain", &GVMixUtilityDesc_t::GetFldbOutputGain, &GVMixUtilityDesc_t::SetFldbOutputGain)
        .addProperty("BassMono", &GVMixUtilityDesc_t::GetBassMono, &GVMixUtilityDesc_t::SetBassMono)
        .addProperty("BassFreq", &GVMixUtilityDesc_t::GetBassFreq, &GVMixUtilityDesc_t::SetBassFreq)
        .addFunction("ToPtr", &GVMixUtilityDesc_t::ToPtr)
        .addFunction("IsValid", &GVMixUtilityDesc_t::IsValid)
        .endClass();
}
GCMotionGraphConfig::GCMotionGraphConfig(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCMotionGraphConfig::GCMotionGraphConfig(void *ptr) {
    m_ptr = ptr;
}
std::vector<float> GCMotionGraphConfig::GetParamValues() const {
    float* outValue = GetSchemaValue<float*>(m_ptr, "CMotionGraphConfig", "m_paramValues"); std::vector<float> ret; for(int i = 0; i < 4; i++) { ret.push_back(outValue[i]); } return ret;
}
void GCMotionGraphConfig::SetParamValues(std::vector<float> value) {
    float* outValue = GetSchemaValue<float*>(m_ptr, "CMotionGraphConfig", "m_paramValues"); for(int i = 0; i < 4; i++) { outValue[i] = value[i]; } SetSchemaValue(m_ptr, "CMotionGraphConfig", "m_paramValues", false, outValue);
}
float GCMotionGraphConfig::GetDuration() const {
    return GetSchemaValue<float>(m_ptr, "CMotionGraphConfig", "m_flDuration");
}
void GCMotionGraphConfig::SetDuration(float value) {
    SetSchemaValue(m_ptr, "CMotionGraphConfig", "m_flDuration", false, value);
}
GMotionIndex GCMotionGraphConfig::GetMotionIndex() const {
    GMotionIndex value(GetSchemaPtr(m_ptr, "CMotionGraphConfig", "m_nMotionIndex"));
    return value;
}
void GCMotionGraphConfig::SetMotionIndex(GMotionIndex value) {
    SetSchemaValue(m_ptr, "CMotionGraphConfig", "m_nMotionIndex", false, value);
}
int32_t GCMotionGraphConfig::GetSampleStart() const {
    return GetSchemaValue<int32_t>(m_ptr, "CMotionGraphConfig", "m_nSampleStart");
}
void GCMotionGraphConfig::SetSampleStart(int32_t value) {
    SetSchemaValue(m_ptr, "CMotionGraphConfig", "m_nSampleStart", false, value);
}
int32_t GCMotionGraphConfig::GetSampleCount() const {
    return GetSchemaValue<int32_t>(m_ptr, "CMotionGraphConfig", "m_nSampleCount");
}
void GCMotionGraphConfig::SetSampleCount(int32_t value) {
    SetSchemaValue(m_ptr, "CMotionGraphConfig", "m_nSampleCount", false, value);
}
std::string GCMotionGraphConfig::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCMotionGraphConfig::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCMotionGraphConfig(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCMotionGraphConfig>("CMotionGraphConfig")
        .addConstructor<void (*)(std::string)>()
        .addProperty("ParamValues", &GCMotionGraphConfig::GetParamValues, &GCMotionGraphConfig::SetParamValues)
        .addProperty("Duration", &GCMotionGraphConfig::GetDuration, &GCMotionGraphConfig::SetDuration)
        .addProperty("MotionIndex", &GCMotionGraphConfig::GetMotionIndex, &GCMotionGraphConfig::SetMotionIndex)
        .addProperty("SampleStart", &GCMotionGraphConfig::GetSampleStart, &GCMotionGraphConfig::SetSampleStart)
        .addProperty("SampleCount", &GCMotionGraphConfig::GetSampleCount, &GCMotionGraphConfig::SetSampleCount)
        .addFunction("ToPtr", &GCMotionGraphConfig::ToPtr)
        .addFunction("IsValid", &GCMotionGraphConfig::IsValid)
        .endClass();
}
GCMovementComponentUpdater::GCMovementComponentUpdater(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCMovementComponentUpdater::GCMovementComponentUpdater(void *ptr) {
    m_ptr = ptr;
}
GCAnimInputDamping GCMovementComponentUpdater::GetFacingDamping() const {
    GCAnimInputDamping value(GetSchemaPtr(m_ptr, "CMovementComponentUpdater", "m_facingDamping"));
    return value;
}
void GCMovementComponentUpdater::SetFacingDamping(GCAnimInputDamping value) {
    SetSchemaValue(m_ptr, "CMovementComponentUpdater", "m_facingDamping", false, value);
}
int32_t GCMovementComponentUpdater::GetDefaultMotorIndex() const {
    return GetSchemaValue<int32_t>(m_ptr, "CMovementComponentUpdater", "m_nDefaultMotorIndex");
}
void GCMovementComponentUpdater::SetDefaultMotorIndex(int32_t value) {
    SetSchemaValue(m_ptr, "CMovementComponentUpdater", "m_nDefaultMotorIndex", false, value);
}
float GCMovementComponentUpdater::GetDefaultRunSpeed() const {
    return GetSchemaValue<float>(m_ptr, "CMovementComponentUpdater", "m_flDefaultRunSpeed");
}
void GCMovementComponentUpdater::SetDefaultRunSpeed(float value) {
    SetSchemaValue(m_ptr, "CMovementComponentUpdater", "m_flDefaultRunSpeed", false, value);
}
bool GCMovementComponentUpdater::GetMoveVarsDisabled() const {
    return GetSchemaValue<bool>(m_ptr, "CMovementComponentUpdater", "m_bMoveVarsDisabled");
}
void GCMovementComponentUpdater::SetMoveVarsDisabled(bool value) {
    SetSchemaValue(m_ptr, "CMovementComponentUpdater", "m_bMoveVarsDisabled", false, value);
}
bool GCMovementComponentUpdater::GetNetworkPath() const {
    return GetSchemaValue<bool>(m_ptr, "CMovementComponentUpdater", "m_bNetworkPath");
}
void GCMovementComponentUpdater::SetNetworkPath(bool value) {
    SetSchemaValue(m_ptr, "CMovementComponentUpdater", "m_bNetworkPath", false, value);
}
bool GCMovementComponentUpdater::GetNetworkFacing() const {
    return GetSchemaValue<bool>(m_ptr, "CMovementComponentUpdater", "m_bNetworkFacing");
}
void GCMovementComponentUpdater::SetNetworkFacing(bool value) {
    SetSchemaValue(m_ptr, "CMovementComponentUpdater", "m_bNetworkFacing", false, value);
}
std::vector<GCAnimParamHandle> GCMovementComponentUpdater::GetParamHandles() const {
    GCAnimParamHandle* outValue = GetSchemaValue<GCAnimParamHandle*>(m_ptr, "CMovementComponentUpdater", "m_paramHandles"); std::vector<GCAnimParamHandle> ret; for(int i = 0; i < 30; i++) { ret.push_back(outValue[i]); } return ret;
}
void GCMovementComponentUpdater::SetParamHandles(std::vector<GCAnimParamHandle> value) {
    GCAnimParamHandle* outValue = GetSchemaValue<GCAnimParamHandle*>(m_ptr, "CMovementComponentUpdater", "m_paramHandles"); for(int i = 0; i < 30; i++) { outValue[i] = value[i]; } SetSchemaValue(m_ptr, "CMovementComponentUpdater", "m_paramHandles", false, outValue);
}
std::string GCMovementComponentUpdater::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCMovementComponentUpdater::IsValid() {
    return (m_ptr != nullptr);
}
GCAnimComponentUpdater GCMovementComponentUpdater::GetParent() const {
    GCAnimComponentUpdater value(m_ptr);
    return value;
}
void GCMovementComponentUpdater::SetParent(GCAnimComponentUpdater value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCMovementComponentUpdater(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCMovementComponentUpdater>("CMovementComponentUpdater")
        .addConstructor<void (*)(std::string)>()
        .addProperty("FacingDamping", &GCMovementComponentUpdater::GetFacingDamping, &GCMovementComponentUpdater::SetFacingDamping)
        .addProperty("DefaultMotorIndex", &GCMovementComponentUpdater::GetDefaultMotorIndex, &GCMovementComponentUpdater::SetDefaultMotorIndex)
        .addProperty("DefaultRunSpeed", &GCMovementComponentUpdater::GetDefaultRunSpeed, &GCMovementComponentUpdater::SetDefaultRunSpeed)
        .addProperty("MoveVarsDisabled", &GCMovementComponentUpdater::GetMoveVarsDisabled, &GCMovementComponentUpdater::SetMoveVarsDisabled)
        .addProperty("NetworkPath", &GCMovementComponentUpdater::GetNetworkPath, &GCMovementComponentUpdater::SetNetworkPath)
        .addProperty("NetworkFacing", &GCMovementComponentUpdater::GetNetworkFacing, &GCMovementComponentUpdater::SetNetworkFacing)
        .addProperty("ParamHandles", &GCMovementComponentUpdater::GetParamHandles, &GCMovementComponentUpdater::SetParamHandles)
        .addProperty("Parent", &GCMovementComponentUpdater::GetParent, &GCMovementComponentUpdater::SetParent)
        .addFunction("ToPtr", &GCMovementComponentUpdater::ToPtr)
        .addFunction("IsValid", &GCMovementComponentUpdater::IsValid)
        .endClass();
}
GPointDefinition_t::GPointDefinition_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GPointDefinition_t::GPointDefinition_t(void *ptr) {
    m_ptr = ptr;
}
int32_t GPointDefinition_t::GetControlPoint() const {
    return GetSchemaValue<int32_t>(m_ptr, "PointDefinition_t", "m_nControlPoint");
}
void GPointDefinition_t::SetControlPoint(int32_t value) {
    SetSchemaValue(m_ptr, "PointDefinition_t", "m_nControlPoint", true, value);
}
bool GPointDefinition_t::GetLocalCoords() const {
    return GetSchemaValue<bool>(m_ptr, "PointDefinition_t", "m_bLocalCoords");
}
void GPointDefinition_t::SetLocalCoords(bool value) {
    SetSchemaValue(m_ptr, "PointDefinition_t", "m_bLocalCoords", true, value);
}
Vector GPointDefinition_t::GetOffset() const {
    return GetSchemaValue<Vector>(m_ptr, "PointDefinition_t", "m_vOffset");
}
void GPointDefinition_t::SetOffset(Vector value) {
    SetSchemaValue(m_ptr, "PointDefinition_t", "m_vOffset", true, value);
}
std::string GPointDefinition_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GPointDefinition_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassPointDefinition_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GPointDefinition_t>("PointDefinition_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("ControlPoint", &GPointDefinition_t::GetControlPoint, &GPointDefinition_t::SetControlPoint)
        .addProperty("LocalCoords", &GPointDefinition_t::GetLocalCoords, &GPointDefinition_t::SetLocalCoords)
        .addProperty("Offset", &GPointDefinition_t::GetOffset, &GPointDefinition_t::SetOffset)
        .addFunction("ToPtr", &GPointDefinition_t::ToPtr)
        .addFunction("IsValid", &GPointDefinition_t::IsValid)
        .endClass();
}
GVMixEffectChainDesc_t::GVMixEffectChainDesc_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GVMixEffectChainDesc_t::GVMixEffectChainDesc_t(void *ptr) {
    m_ptr = ptr;
}
float GVMixEffectChainDesc_t::GetCrossfadeTime() const {
    return GetSchemaValue<float>(m_ptr, "VMixEffectChainDesc_t", "m_flCrossfadeTime");
}
void GVMixEffectChainDesc_t::SetCrossfadeTime(float value) {
    SetSchemaValue(m_ptr, "VMixEffectChainDesc_t", "m_flCrossfadeTime", true, value);
}
std::string GVMixEffectChainDesc_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GVMixEffectChainDesc_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassVMixEffectChainDesc_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GVMixEffectChainDesc_t>("VMixEffectChainDesc_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("CrossfadeTime", &GVMixEffectChainDesc_t::GetCrossfadeTime, &GVMixEffectChainDesc_t::SetCrossfadeTime)
        .addFunction("ToPtr", &GVMixEffectChainDesc_t::ToPtr)
        .addFunction("IsValid", &GVMixEffectChainDesc_t::IsValid)
        .endClass();
}
GCHitReactUpdateNode::GCHitReactUpdateNode(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCHitReactUpdateNode::GCHitReactUpdateNode(void *ptr) {
    m_ptr = ptr;
}
GHitReactFixedSettings_t GCHitReactUpdateNode::GetOpFixedSettings() const {
    GHitReactFixedSettings_t value(GetSchemaPtr(m_ptr, "CHitReactUpdateNode", "m_opFixedSettings"));
    return value;
}
void GCHitReactUpdateNode::SetOpFixedSettings(GHitReactFixedSettings_t value) {
    SetSchemaValue(m_ptr, "CHitReactUpdateNode", "m_opFixedSettings", false, value);
}
GCAnimParamHandle GCHitReactUpdateNode::GetTriggerParam() const {
    GCAnimParamHandle value(GetSchemaPtr(m_ptr, "CHitReactUpdateNode", "m_triggerParam"));
    return value;
}
void GCHitReactUpdateNode::SetTriggerParam(GCAnimParamHandle value) {
    SetSchemaValue(m_ptr, "CHitReactUpdateNode", "m_triggerParam", false, value);
}
GCAnimParamHandle GCHitReactUpdateNode::GetHitBoneParam() const {
    GCAnimParamHandle value(GetSchemaPtr(m_ptr, "CHitReactUpdateNode", "m_hitBoneParam"));
    return value;
}
void GCHitReactUpdateNode::SetHitBoneParam(GCAnimParamHandle value) {
    SetSchemaValue(m_ptr, "CHitReactUpdateNode", "m_hitBoneParam", false, value);
}
GCAnimParamHandle GCHitReactUpdateNode::GetHitOffsetParam() const {
    GCAnimParamHandle value(GetSchemaPtr(m_ptr, "CHitReactUpdateNode", "m_hitOffsetParam"));
    return value;
}
void GCHitReactUpdateNode::SetHitOffsetParam(GCAnimParamHandle value) {
    SetSchemaValue(m_ptr, "CHitReactUpdateNode", "m_hitOffsetParam", false, value);
}
GCAnimParamHandle GCHitReactUpdateNode::GetHitDirectionParam() const {
    GCAnimParamHandle value(GetSchemaPtr(m_ptr, "CHitReactUpdateNode", "m_hitDirectionParam"));
    return value;
}
void GCHitReactUpdateNode::SetHitDirectionParam(GCAnimParamHandle value) {
    SetSchemaValue(m_ptr, "CHitReactUpdateNode", "m_hitDirectionParam", false, value);
}
GCAnimParamHandle GCHitReactUpdateNode::GetHitStrengthParam() const {
    GCAnimParamHandle value(GetSchemaPtr(m_ptr, "CHitReactUpdateNode", "m_hitStrengthParam"));
    return value;
}
void GCHitReactUpdateNode::SetHitStrengthParam(GCAnimParamHandle value) {
    SetSchemaValue(m_ptr, "CHitReactUpdateNode", "m_hitStrengthParam", false, value);
}
float GCHitReactUpdateNode::GetMinDelayBetweenHits() const {
    return GetSchemaValue<float>(m_ptr, "CHitReactUpdateNode", "m_flMinDelayBetweenHits");
}
void GCHitReactUpdateNode::SetMinDelayBetweenHits(float value) {
    SetSchemaValue(m_ptr, "CHitReactUpdateNode", "m_flMinDelayBetweenHits", false, value);
}
bool GCHitReactUpdateNode::GetResetChild() const {
    return GetSchemaValue<bool>(m_ptr, "CHitReactUpdateNode", "m_bResetChild");
}
void GCHitReactUpdateNode::SetResetChild(bool value) {
    SetSchemaValue(m_ptr, "CHitReactUpdateNode", "m_bResetChild", false, value);
}
std::string GCHitReactUpdateNode::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCHitReactUpdateNode::IsValid() {
    return (m_ptr != nullptr);
}
GCUnaryUpdateNode GCHitReactUpdateNode::GetParent() const {
    GCUnaryUpdateNode value(m_ptr);
    return value;
}
void GCHitReactUpdateNode::SetParent(GCUnaryUpdateNode value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCHitReactUpdateNode(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCHitReactUpdateNode>("CHitReactUpdateNode")
        .addConstructor<void (*)(std::string)>()
        .addProperty("OpFixedSettings", &GCHitReactUpdateNode::GetOpFixedSettings, &GCHitReactUpdateNode::SetOpFixedSettings)
        .addProperty("TriggerParam", &GCHitReactUpdateNode::GetTriggerParam, &GCHitReactUpdateNode::SetTriggerParam)
        .addProperty("HitBoneParam", &GCHitReactUpdateNode::GetHitBoneParam, &GCHitReactUpdateNode::SetHitBoneParam)
        .addProperty("HitOffsetParam", &GCHitReactUpdateNode::GetHitOffsetParam, &GCHitReactUpdateNode::SetHitOffsetParam)
        .addProperty("HitDirectionParam", &GCHitReactUpdateNode::GetHitDirectionParam, &GCHitReactUpdateNode::SetHitDirectionParam)
        .addProperty("HitStrengthParam", &GCHitReactUpdateNode::GetHitStrengthParam, &GCHitReactUpdateNode::SetHitStrengthParam)
        .addProperty("MinDelayBetweenHits", &GCHitReactUpdateNode::GetMinDelayBetweenHits, &GCHitReactUpdateNode::SetMinDelayBetweenHits)
        .addProperty("ResetChild", &GCHitReactUpdateNode::GetResetChild, &GCHitReactUpdateNode::SetResetChild)
        .addProperty("Parent", &GCHitReactUpdateNode::GetParent, &GCHitReactUpdateNode::SetParent)
        .addFunction("ToPtr", &GCHitReactUpdateNode::ToPtr)
        .addFunction("IsValid", &GCHitReactUpdateNode::IsValid)
        .endClass();
}
GEntInput_t::GEntInput_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GEntInput_t::GEntInput_t(void *ptr) {
    m_ptr = ptr;
}
std::string GEntInput_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GEntInput_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassEntInput_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GEntInput_t>("EntInput_t")
        .addConstructor<void (*)(std::string)>()
        .addFunction("ToPtr", &GEntInput_t::ToPtr)
        .addFunction("IsValid", &GEntInput_t::IsValid)
        .endClass();
}
GCNmVirtualParameterFloatNode::GCNmVirtualParameterFloatNode(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCNmVirtualParameterFloatNode::GCNmVirtualParameterFloatNode(void *ptr) {
    m_ptr = ptr;
}
int16_t GCNmVirtualParameterFloatNode::GetChildNodeIdx() const {
    return GetSchemaValue<int16_t>(m_ptr, "CNmVirtualParameterFloatNode", "m_nChildNodeIdx");
}
void GCNmVirtualParameterFloatNode::SetChildNodeIdx(int16_t value) {
    SetSchemaValue(m_ptr, "CNmVirtualParameterFloatNode", "m_nChildNodeIdx", false, value);
}
std::string GCNmVirtualParameterFloatNode::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCNmVirtualParameterFloatNode::IsValid() {
    return (m_ptr != nullptr);
}
GCNmFloatValueNode GCNmVirtualParameterFloatNode::GetParent() const {
    GCNmFloatValueNode value(m_ptr);
    return value;
}
void GCNmVirtualParameterFloatNode::SetParent(GCNmFloatValueNode value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCNmVirtualParameterFloatNode(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCNmVirtualParameterFloatNode>("CNmVirtualParameterFloatNode")
        .addConstructor<void (*)(std::string)>()
        .addProperty("ChildNodeIdx", &GCNmVirtualParameterFloatNode::GetChildNodeIdx, &GCNmVirtualParameterFloatNode::SetChildNodeIdx)
        .addProperty("Parent", &GCNmVirtualParameterFloatNode::GetParent, &GCNmVirtualParameterFloatNode::SetParent)
        .addFunction("ToPtr", &GCNmVirtualParameterFloatNode::ToPtr)
        .addFunction("IsValid", &GCNmVirtualParameterFloatNode::IsValid)
        .endClass();
}
GCParticleSystemDefinition::GCParticleSystemDefinition(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCParticleSystemDefinition::GCParticleSystemDefinition(void *ptr) {
    m_ptr = ptr;
}
int32_t GCParticleSystemDefinition::GetBehaviorVersion() const {
    return GetSchemaValue<int32_t>(m_ptr, "CParticleSystemDefinition", "m_nBehaviorVersion");
}
void GCParticleSystemDefinition::SetBehaviorVersion(int32_t value) {
    SetSchemaValue(m_ptr, "CParticleSystemDefinition", "m_nBehaviorVersion", false, value);
}
std::vector<GCParticleFunctionPreEmission*> GCParticleSystemDefinition::GetPreEmissionOperators() const {
    CUtlVector<GCParticleFunctionPreEmission*>* vec = GetSchemaValue<CUtlVector<GCParticleFunctionPreEmission*>*>(m_ptr, "CParticleSystemDefinition", "m_PreEmissionOperators"); std::vector<GCParticleFunctionPreEmission*> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCParticleSystemDefinition::SetPreEmissionOperators(std::vector<GCParticleFunctionPreEmission*> value) {
    SetSchemaValueCUtlVector<GCParticleFunctionPreEmission*>(m_ptr, "CParticleSystemDefinition", "m_PreEmissionOperators", false, value);
}
std::vector<GCParticleFunctionEmitter*> GCParticleSystemDefinition::GetEmitters() const {
    CUtlVector<GCParticleFunctionEmitter*>* vec = GetSchemaValue<CUtlVector<GCParticleFunctionEmitter*>*>(m_ptr, "CParticleSystemDefinition", "m_Emitters"); std::vector<GCParticleFunctionEmitter*> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCParticleSystemDefinition::SetEmitters(std::vector<GCParticleFunctionEmitter*> value) {
    SetSchemaValueCUtlVector<GCParticleFunctionEmitter*>(m_ptr, "CParticleSystemDefinition", "m_Emitters", false, value);
}
std::vector<GCParticleFunctionInitializer*> GCParticleSystemDefinition::GetInitializers() const {
    CUtlVector<GCParticleFunctionInitializer*>* vec = GetSchemaValue<CUtlVector<GCParticleFunctionInitializer*>*>(m_ptr, "CParticleSystemDefinition", "m_Initializers"); std::vector<GCParticleFunctionInitializer*> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCParticleSystemDefinition::SetInitializers(std::vector<GCParticleFunctionInitializer*> value) {
    SetSchemaValueCUtlVector<GCParticleFunctionInitializer*>(m_ptr, "CParticleSystemDefinition", "m_Initializers", false, value);
}
std::vector<GCParticleFunctionOperator*> GCParticleSystemDefinition::GetOperators() const {
    CUtlVector<GCParticleFunctionOperator*>* vec = GetSchemaValue<CUtlVector<GCParticleFunctionOperator*>*>(m_ptr, "CParticleSystemDefinition", "m_Operators"); std::vector<GCParticleFunctionOperator*> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCParticleSystemDefinition::SetOperators(std::vector<GCParticleFunctionOperator*> value) {
    SetSchemaValueCUtlVector<GCParticleFunctionOperator*>(m_ptr, "CParticleSystemDefinition", "m_Operators", false, value);
}
std::vector<GCParticleFunctionForce*> GCParticleSystemDefinition::GetForceGenerators() const {
    CUtlVector<GCParticleFunctionForce*>* vec = GetSchemaValue<CUtlVector<GCParticleFunctionForce*>*>(m_ptr, "CParticleSystemDefinition", "m_ForceGenerators"); std::vector<GCParticleFunctionForce*> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCParticleSystemDefinition::SetForceGenerators(std::vector<GCParticleFunctionForce*> value) {
    SetSchemaValueCUtlVector<GCParticleFunctionForce*>(m_ptr, "CParticleSystemDefinition", "m_ForceGenerators", false, value);
}
std::vector<GCParticleFunctionConstraint*> GCParticleSystemDefinition::GetConstraints() const {
    CUtlVector<GCParticleFunctionConstraint*>* vec = GetSchemaValue<CUtlVector<GCParticleFunctionConstraint*>*>(m_ptr, "CParticleSystemDefinition", "m_Constraints"); std::vector<GCParticleFunctionConstraint*> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCParticleSystemDefinition::SetConstraints(std::vector<GCParticleFunctionConstraint*> value) {
    SetSchemaValueCUtlVector<GCParticleFunctionConstraint*>(m_ptr, "CParticleSystemDefinition", "m_Constraints", false, value);
}
std::vector<GCParticleFunctionRenderer*> GCParticleSystemDefinition::GetRenderers() const {
    CUtlVector<GCParticleFunctionRenderer*>* vec = GetSchemaValue<CUtlVector<GCParticleFunctionRenderer*>*>(m_ptr, "CParticleSystemDefinition", "m_Renderers"); std::vector<GCParticleFunctionRenderer*> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCParticleSystemDefinition::SetRenderers(std::vector<GCParticleFunctionRenderer*> value) {
    SetSchemaValueCUtlVector<GCParticleFunctionRenderer*>(m_ptr, "CParticleSystemDefinition", "m_Renderers", false, value);
}
std::vector<GParticleChildrenInfo_t> GCParticleSystemDefinition::GetChildren() const {
    CUtlVector<GParticleChildrenInfo_t>* vec = GetSchemaValue<CUtlVector<GParticleChildrenInfo_t>*>(m_ptr, "CParticleSystemDefinition", "m_Children"); std::vector<GParticleChildrenInfo_t> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCParticleSystemDefinition::SetChildren(std::vector<GParticleChildrenInfo_t> value) {
    SetSchemaValueCUtlVector<GParticleChildrenInfo_t>(m_ptr, "CParticleSystemDefinition", "m_Children", false, value);
}
int32_t GCParticleSystemDefinition::GetFirstMultipleOverride_BackwardCompat() const {
    return GetSchemaValue<int32_t>(m_ptr, "CParticleSystemDefinition", "m_nFirstMultipleOverride_BackwardCompat");
}
void GCParticleSystemDefinition::SetFirstMultipleOverride_BackwardCompat(int32_t value) {
    SetSchemaValue(m_ptr, "CParticleSystemDefinition", "m_nFirstMultipleOverride_BackwardCompat", false, value);
}
int32_t GCParticleSystemDefinition::GetInitialParticles() const {
    return GetSchemaValue<int32_t>(m_ptr, "CParticleSystemDefinition", "m_nInitialParticles");
}
void GCParticleSystemDefinition::SetInitialParticles(int32_t value) {
    SetSchemaValue(m_ptr, "CParticleSystemDefinition", "m_nInitialParticles", false, value);
}
int32_t GCParticleSystemDefinition::GetMaxParticles() const {
    return GetSchemaValue<int32_t>(m_ptr, "CParticleSystemDefinition", "m_nMaxParticles");
}
void GCParticleSystemDefinition::SetMaxParticles(int32_t value) {
    SetSchemaValue(m_ptr, "CParticleSystemDefinition", "m_nMaxParticles", false, value);
}
int32_t GCParticleSystemDefinition::GetGroupID() const {
    return GetSchemaValue<int32_t>(m_ptr, "CParticleSystemDefinition", "m_nGroupID");
}
void GCParticleSystemDefinition::SetGroupID(int32_t value) {
    SetSchemaValue(m_ptr, "CParticleSystemDefinition", "m_nGroupID", false, value);
}
Vector GCParticleSystemDefinition::GetBoundingBoxMin() const {
    return GetSchemaValue<Vector>(m_ptr, "CParticleSystemDefinition", "m_BoundingBoxMin");
}
void GCParticleSystemDefinition::SetBoundingBoxMin(Vector value) {
    SetSchemaValue(m_ptr, "CParticleSystemDefinition", "m_BoundingBoxMin", false, value);
}
Vector GCParticleSystemDefinition::GetBoundingBoxMax() const {
    return GetSchemaValue<Vector>(m_ptr, "CParticleSystemDefinition", "m_BoundingBoxMax");
}
void GCParticleSystemDefinition::SetBoundingBoxMax(Vector value) {
    SetSchemaValue(m_ptr, "CParticleSystemDefinition", "m_BoundingBoxMax", false, value);
}
float GCParticleSystemDefinition::GetDepthSortBias() const {
    return GetSchemaValue<float>(m_ptr, "CParticleSystemDefinition", "m_flDepthSortBias");
}
void GCParticleSystemDefinition::SetDepthSortBias(float value) {
    SetSchemaValue(m_ptr, "CParticleSystemDefinition", "m_flDepthSortBias", false, value);
}
int32_t GCParticleSystemDefinition::GetSortOverridePositionCP() const {
    return GetSchemaValue<int32_t>(m_ptr, "CParticleSystemDefinition", "m_nSortOverridePositionCP");
}
void GCParticleSystemDefinition::SetSortOverridePositionCP(int32_t value) {
    SetSchemaValue(m_ptr, "CParticleSystemDefinition", "m_nSortOverridePositionCP", false, value);
}
bool GCParticleSystemDefinition::GetInfiniteBounds() const {
    return GetSchemaValue<bool>(m_ptr, "CParticleSystemDefinition", "m_bInfiniteBounds");
}
void GCParticleSystemDefinition::SetInfiniteBounds(bool value) {
    SetSchemaValue(m_ptr, "CParticleSystemDefinition", "m_bInfiniteBounds", false, value);
}
bool GCParticleSystemDefinition::GetEnableNamedValues() const {
    return GetSchemaValue<bool>(m_ptr, "CParticleSystemDefinition", "m_bEnableNamedValues");
}
void GCParticleSystemDefinition::SetEnableNamedValues(bool value) {
    SetSchemaValue(m_ptr, "CParticleSystemDefinition", "m_bEnableNamedValues", false, value);
}
std::string GCParticleSystemDefinition::GetNamedValueDomain() const {
    return GetSchemaValue<CUtlString>(m_ptr, "CParticleSystemDefinition", "m_NamedValueDomain").Get();
}
void GCParticleSystemDefinition::SetNamedValueDomain(std::string value) {
    SetSchemaValue(m_ptr, "CParticleSystemDefinition", "m_NamedValueDomain", false, CUtlString(value.c_str()));
}
std::vector<GParticleNamedValueSource_t*> GCParticleSystemDefinition::GetNamedValueLocals() const {
    CUtlVector<GParticleNamedValueSource_t*>* vec = GetSchemaValue<CUtlVector<GParticleNamedValueSource_t*>*>(m_ptr, "CParticleSystemDefinition", "m_NamedValueLocals"); std::vector<GParticleNamedValueSource_t*> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCParticleSystemDefinition::SetNamedValueLocals(std::vector<GParticleNamedValueSource_t*> value) {
    SetSchemaValueCUtlVector<GParticleNamedValueSource_t*>(m_ptr, "CParticleSystemDefinition", "m_NamedValueLocals", false, value);
}
Color GCParticleSystemDefinition::GetConstantColor() const {
    return GetSchemaValue<Color>(m_ptr, "CParticleSystemDefinition", "m_ConstantColor");
}
void GCParticleSystemDefinition::SetConstantColor(Color value) {
    SetSchemaValue(m_ptr, "CParticleSystemDefinition", "m_ConstantColor", false, value);
}
Vector GCParticleSystemDefinition::GetConstantNormal() const {
    return GetSchemaValue<Vector>(m_ptr, "CParticleSystemDefinition", "m_ConstantNormal");
}
void GCParticleSystemDefinition::SetConstantNormal(Vector value) {
    SetSchemaValue(m_ptr, "CParticleSystemDefinition", "m_ConstantNormal", false, value);
}
float GCParticleSystemDefinition::GetConstantRadius() const {
    return GetSchemaValue<float>(m_ptr, "CParticleSystemDefinition", "m_flConstantRadius");
}
void GCParticleSystemDefinition::SetConstantRadius(float value) {
    SetSchemaValue(m_ptr, "CParticleSystemDefinition", "m_flConstantRadius", false, value);
}
float GCParticleSystemDefinition::GetConstantRotation() const {
    return GetSchemaValue<float>(m_ptr, "CParticleSystemDefinition", "m_flConstantRotation");
}
void GCParticleSystemDefinition::SetConstantRotation(float value) {
    SetSchemaValue(m_ptr, "CParticleSystemDefinition", "m_flConstantRotation", false, value);
}
float GCParticleSystemDefinition::GetConstantRotationSpeed() const {
    return GetSchemaValue<float>(m_ptr, "CParticleSystemDefinition", "m_flConstantRotationSpeed");
}
void GCParticleSystemDefinition::SetConstantRotationSpeed(float value) {
    SetSchemaValue(m_ptr, "CParticleSystemDefinition", "m_flConstantRotationSpeed", false, value);
}
float GCParticleSystemDefinition::GetConstantLifespan() const {
    return GetSchemaValue<float>(m_ptr, "CParticleSystemDefinition", "m_flConstantLifespan");
}
void GCParticleSystemDefinition::SetConstantLifespan(float value) {
    SetSchemaValue(m_ptr, "CParticleSystemDefinition", "m_flConstantLifespan", false, value);
}
int32_t GCParticleSystemDefinition::GetConstantSequenceNumber() const {
    return GetSchemaValue<int32_t>(m_ptr, "CParticleSystemDefinition", "m_nConstantSequenceNumber");
}
void GCParticleSystemDefinition::SetConstantSequenceNumber(int32_t value) {
    SetSchemaValue(m_ptr, "CParticleSystemDefinition", "m_nConstantSequenceNumber", false, value);
}
int32_t GCParticleSystemDefinition::GetConstantSequenceNumber1() const {
    return GetSchemaValue<int32_t>(m_ptr, "CParticleSystemDefinition", "m_nConstantSequenceNumber1");
}
void GCParticleSystemDefinition::SetConstantSequenceNumber1(int32_t value) {
    SetSchemaValue(m_ptr, "CParticleSystemDefinition", "m_nConstantSequenceNumber1", false, value);
}
int32_t GCParticleSystemDefinition::GetSnapshotControlPoint() const {
    return GetSchemaValue<int32_t>(m_ptr, "CParticleSystemDefinition", "m_nSnapshotControlPoint");
}
void GCParticleSystemDefinition::SetSnapshotControlPoint(int32_t value) {
    SetSchemaValue(m_ptr, "CParticleSystemDefinition", "m_nSnapshotControlPoint", false, value);
}
float GCParticleSystemDefinition::GetCullRadius() const {
    return GetSchemaValue<float>(m_ptr, "CParticleSystemDefinition", "m_flCullRadius");
}
void GCParticleSystemDefinition::SetCullRadius(float value) {
    SetSchemaValue(m_ptr, "CParticleSystemDefinition", "m_flCullRadius", false, value);
}
float GCParticleSystemDefinition::GetCullFillCost() const {
    return GetSchemaValue<float>(m_ptr, "CParticleSystemDefinition", "m_flCullFillCost");
}
void GCParticleSystemDefinition::SetCullFillCost(float value) {
    SetSchemaValue(m_ptr, "CParticleSystemDefinition", "m_flCullFillCost", false, value);
}
int32_t GCParticleSystemDefinition::GetCullControlPoint() const {
    return GetSchemaValue<int32_t>(m_ptr, "CParticleSystemDefinition", "m_nCullControlPoint");
}
void GCParticleSystemDefinition::SetCullControlPoint(int32_t value) {
    SetSchemaValue(m_ptr, "CParticleSystemDefinition", "m_nCullControlPoint", false, value);
}
int32_t GCParticleSystemDefinition::GetFallbackMaxCount() const {
    return GetSchemaValue<int32_t>(m_ptr, "CParticleSystemDefinition", "m_nFallbackMaxCount");
}
void GCParticleSystemDefinition::SetFallbackMaxCount(int32_t value) {
    SetSchemaValue(m_ptr, "CParticleSystemDefinition", "m_nFallbackMaxCount", false, value);
}
float GCParticleSystemDefinition::GetPreSimulationTime() const {
    return GetSchemaValue<float>(m_ptr, "CParticleSystemDefinition", "m_flPreSimulationTime");
}
void GCParticleSystemDefinition::SetPreSimulationTime(float value) {
    SetSchemaValue(m_ptr, "CParticleSystemDefinition", "m_flPreSimulationTime", false, value);
}
float GCParticleSystemDefinition::GetStopSimulationAfterTime() const {
    return GetSchemaValue<float>(m_ptr, "CParticleSystemDefinition", "m_flStopSimulationAfterTime");
}
void GCParticleSystemDefinition::SetStopSimulationAfterTime(float value) {
    SetSchemaValue(m_ptr, "CParticleSystemDefinition", "m_flStopSimulationAfterTime", false, value);
}
float GCParticleSystemDefinition::GetMaximumTimeStep() const {
    return GetSchemaValue<float>(m_ptr, "CParticleSystemDefinition", "m_flMaximumTimeStep");
}
void GCParticleSystemDefinition::SetMaximumTimeStep(float value) {
    SetSchemaValue(m_ptr, "CParticleSystemDefinition", "m_flMaximumTimeStep", false, value);
}
float GCParticleSystemDefinition::GetMaximumSimTime() const {
    return GetSchemaValue<float>(m_ptr, "CParticleSystemDefinition", "m_flMaximumSimTime");
}
void GCParticleSystemDefinition::SetMaximumSimTime(float value) {
    SetSchemaValue(m_ptr, "CParticleSystemDefinition", "m_flMaximumSimTime", false, value);
}
float GCParticleSystemDefinition::GetMinimumSimTime() const {
    return GetSchemaValue<float>(m_ptr, "CParticleSystemDefinition", "m_flMinimumSimTime");
}
void GCParticleSystemDefinition::SetMinimumSimTime(float value) {
    SetSchemaValue(m_ptr, "CParticleSystemDefinition", "m_flMinimumSimTime", false, value);
}
float GCParticleSystemDefinition::GetMinimumTimeStep() const {
    return GetSchemaValue<float>(m_ptr, "CParticleSystemDefinition", "m_flMinimumTimeStep");
}
void GCParticleSystemDefinition::SetMinimumTimeStep(float value) {
    SetSchemaValue(m_ptr, "CParticleSystemDefinition", "m_flMinimumTimeStep", false, value);
}
int32_t GCParticleSystemDefinition::GetMinimumFrames() const {
    return GetSchemaValue<int32_t>(m_ptr, "CParticleSystemDefinition", "m_nMinimumFrames");
}
void GCParticleSystemDefinition::SetMinimumFrames(int32_t value) {
    SetSchemaValue(m_ptr, "CParticleSystemDefinition", "m_nMinimumFrames", false, value);
}
int32_t GCParticleSystemDefinition::GetMinCPULevel() const {
    return GetSchemaValue<int32_t>(m_ptr, "CParticleSystemDefinition", "m_nMinCPULevel");
}
void GCParticleSystemDefinition::SetMinCPULevel(int32_t value) {
    SetSchemaValue(m_ptr, "CParticleSystemDefinition", "m_nMinCPULevel", false, value);
}
int32_t GCParticleSystemDefinition::GetMinGPULevel() const {
    return GetSchemaValue<int32_t>(m_ptr, "CParticleSystemDefinition", "m_nMinGPULevel");
}
void GCParticleSystemDefinition::SetMinGPULevel(int32_t value) {
    SetSchemaValue(m_ptr, "CParticleSystemDefinition", "m_nMinGPULevel", false, value);
}
float GCParticleSystemDefinition::GetNoDrawTimeToGoToSleep() const {
    return GetSchemaValue<float>(m_ptr, "CParticleSystemDefinition", "m_flNoDrawTimeToGoToSleep");
}
void GCParticleSystemDefinition::SetNoDrawTimeToGoToSleep(float value) {
    SetSchemaValue(m_ptr, "CParticleSystemDefinition", "m_flNoDrawTimeToGoToSleep", false, value);
}
float GCParticleSystemDefinition::GetMaxDrawDistance() const {
    return GetSchemaValue<float>(m_ptr, "CParticleSystemDefinition", "m_flMaxDrawDistance");
}
void GCParticleSystemDefinition::SetMaxDrawDistance(float value) {
    SetSchemaValue(m_ptr, "CParticleSystemDefinition", "m_flMaxDrawDistance", false, value);
}
float GCParticleSystemDefinition::GetStartFadeDistance() const {
    return GetSchemaValue<float>(m_ptr, "CParticleSystemDefinition", "m_flStartFadeDistance");
}
void GCParticleSystemDefinition::SetStartFadeDistance(float value) {
    SetSchemaValue(m_ptr, "CParticleSystemDefinition", "m_flStartFadeDistance", false, value);
}
float GCParticleSystemDefinition::GetMaxCreationDistance() const {
    return GetSchemaValue<float>(m_ptr, "CParticleSystemDefinition", "m_flMaxCreationDistance");
}
void GCParticleSystemDefinition::SetMaxCreationDistance(float value) {
    SetSchemaValue(m_ptr, "CParticleSystemDefinition", "m_flMaxCreationDistance", false, value);
}
int32_t GCParticleSystemDefinition::GetAggregationMinAvailableParticles() const {
    return GetSchemaValue<int32_t>(m_ptr, "CParticleSystemDefinition", "m_nAggregationMinAvailableParticles");
}
void GCParticleSystemDefinition::SetAggregationMinAvailableParticles(int32_t value) {
    SetSchemaValue(m_ptr, "CParticleSystemDefinition", "m_nAggregationMinAvailableParticles", false, value);
}
float GCParticleSystemDefinition::GetAggregateRadius() const {
    return GetSchemaValue<float>(m_ptr, "CParticleSystemDefinition", "m_flAggregateRadius");
}
void GCParticleSystemDefinition::SetAggregateRadius(float value) {
    SetSchemaValue(m_ptr, "CParticleSystemDefinition", "m_flAggregateRadius", false, value);
}
bool GCParticleSystemDefinition::GetShouldBatch() const {
    return GetSchemaValue<bool>(m_ptr, "CParticleSystemDefinition", "m_bShouldBatch");
}
void GCParticleSystemDefinition::SetShouldBatch(bool value) {
    SetSchemaValue(m_ptr, "CParticleSystemDefinition", "m_bShouldBatch", false, value);
}
bool GCParticleSystemDefinition::GetShouldHitboxesFallbackToRenderBounds() const {
    return GetSchemaValue<bool>(m_ptr, "CParticleSystemDefinition", "m_bShouldHitboxesFallbackToRenderBounds");
}
void GCParticleSystemDefinition::SetShouldHitboxesFallbackToRenderBounds(bool value) {
    SetSchemaValue(m_ptr, "CParticleSystemDefinition", "m_bShouldHitboxesFallbackToRenderBounds", false, value);
}
bool GCParticleSystemDefinition::GetShouldHitboxesFallbackToSnapshot() const {
    return GetSchemaValue<bool>(m_ptr, "CParticleSystemDefinition", "m_bShouldHitboxesFallbackToSnapshot");
}
void GCParticleSystemDefinition::SetShouldHitboxesFallbackToSnapshot(bool value) {
    SetSchemaValue(m_ptr, "CParticleSystemDefinition", "m_bShouldHitboxesFallbackToSnapshot", false, value);
}
bool GCParticleSystemDefinition::GetShouldHitboxesFallbackToCollisionHulls() const {
    return GetSchemaValue<bool>(m_ptr, "CParticleSystemDefinition", "m_bShouldHitboxesFallbackToCollisionHulls");
}
void GCParticleSystemDefinition::SetShouldHitboxesFallbackToCollisionHulls(bool value) {
    SetSchemaValue(m_ptr, "CParticleSystemDefinition", "m_bShouldHitboxesFallbackToCollisionHulls", false, value);
}
uint64_t GCParticleSystemDefinition::GetViewModelEffect() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CParticleSystemDefinition", "m_nViewModelEffect");
}
void GCParticleSystemDefinition::SetViewModelEffect(uint64_t value) {
    SetSchemaValue(m_ptr, "CParticleSystemDefinition", "m_nViewModelEffect", false, value);
}
bool GCParticleSystemDefinition::GetScreenSpaceEffect() const {
    return GetSchemaValue<bool>(m_ptr, "CParticleSystemDefinition", "m_bScreenSpaceEffect");
}
void GCParticleSystemDefinition::SetScreenSpaceEffect(bool value) {
    SetSchemaValue(m_ptr, "CParticleSystemDefinition", "m_bScreenSpaceEffect", false, value);
}
std::string GCParticleSystemDefinition::GetTargetLayerID() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CParticleSystemDefinition", "m_pszTargetLayerID").String();
}
void GCParticleSystemDefinition::SetTargetLayerID(std::string value) {
    SetSchemaValue(m_ptr, "CParticleSystemDefinition", "m_pszTargetLayerID", false, CUtlSymbolLarge(value.c_str()));
}
int32_t GCParticleSystemDefinition::GetSkipRenderControlPoint() const {
    return GetSchemaValue<int32_t>(m_ptr, "CParticleSystemDefinition", "m_nSkipRenderControlPoint");
}
void GCParticleSystemDefinition::SetSkipRenderControlPoint(int32_t value) {
    SetSchemaValue(m_ptr, "CParticleSystemDefinition", "m_nSkipRenderControlPoint", false, value);
}
int32_t GCParticleSystemDefinition::GetAllowRenderControlPoint() const {
    return GetSchemaValue<int32_t>(m_ptr, "CParticleSystemDefinition", "m_nAllowRenderControlPoint");
}
void GCParticleSystemDefinition::SetAllowRenderControlPoint(int32_t value) {
    SetSchemaValue(m_ptr, "CParticleSystemDefinition", "m_nAllowRenderControlPoint", false, value);
}
bool GCParticleSystemDefinition::GetShouldSort() const {
    return GetSchemaValue<bool>(m_ptr, "CParticleSystemDefinition", "m_bShouldSort");
}
void GCParticleSystemDefinition::SetShouldSort(bool value) {
    SetSchemaValue(m_ptr, "CParticleSystemDefinition", "m_bShouldSort", false, value);
}
std::vector<GParticleControlPointConfiguration_t> GCParticleSystemDefinition::GetControlPointConfigurations() const {
    CUtlVector<GParticleControlPointConfiguration_t>* vec = GetSchemaValue<CUtlVector<GParticleControlPointConfiguration_t>*>(m_ptr, "CParticleSystemDefinition", "m_controlPointConfigurations"); std::vector<GParticleControlPointConfiguration_t> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCParticleSystemDefinition::SetControlPointConfigurations(std::vector<GParticleControlPointConfiguration_t> value) {
    SetSchemaValueCUtlVector<GParticleControlPointConfiguration_t>(m_ptr, "CParticleSystemDefinition", "m_controlPointConfigurations", false, value);
}
std::string GCParticleSystemDefinition::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCParticleSystemDefinition::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCParticleSystemDefinition(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCParticleSystemDefinition>("CParticleSystemDefinition")
        .addConstructor<void (*)(std::string)>()
        .addProperty("BehaviorVersion", &GCParticleSystemDefinition::GetBehaviorVersion, &GCParticleSystemDefinition::SetBehaviorVersion)
        .addProperty("PreEmissionOperators", &GCParticleSystemDefinition::GetPreEmissionOperators, &GCParticleSystemDefinition::SetPreEmissionOperators)
        .addProperty("Emitters", &GCParticleSystemDefinition::GetEmitters, &GCParticleSystemDefinition::SetEmitters)
        .addProperty("Initializers", &GCParticleSystemDefinition::GetInitializers, &GCParticleSystemDefinition::SetInitializers)
        .addProperty("Operators", &GCParticleSystemDefinition::GetOperators, &GCParticleSystemDefinition::SetOperators)
        .addProperty("ForceGenerators", &GCParticleSystemDefinition::GetForceGenerators, &GCParticleSystemDefinition::SetForceGenerators)
        .addProperty("Constraints", &GCParticleSystemDefinition::GetConstraints, &GCParticleSystemDefinition::SetConstraints)
        .addProperty("Renderers", &GCParticleSystemDefinition::GetRenderers, &GCParticleSystemDefinition::SetRenderers)
        .addProperty("Children", &GCParticleSystemDefinition::GetChildren, &GCParticleSystemDefinition::SetChildren)
        .addProperty("FirstMultipleOverride_BackwardCompat", &GCParticleSystemDefinition::GetFirstMultipleOverride_BackwardCompat, &GCParticleSystemDefinition::SetFirstMultipleOverride_BackwardCompat)
        .addProperty("InitialParticles", &GCParticleSystemDefinition::GetInitialParticles, &GCParticleSystemDefinition::SetInitialParticles)
        .addProperty("MaxParticles", &GCParticleSystemDefinition::GetMaxParticles, &GCParticleSystemDefinition::SetMaxParticles)
        .addProperty("GroupID", &GCParticleSystemDefinition::GetGroupID, &GCParticleSystemDefinition::SetGroupID)
        .addProperty("BoundingBoxMin", &GCParticleSystemDefinition::GetBoundingBoxMin, &GCParticleSystemDefinition::SetBoundingBoxMin)
        .addProperty("BoundingBoxMax", &GCParticleSystemDefinition::GetBoundingBoxMax, &GCParticleSystemDefinition::SetBoundingBoxMax)
        .addProperty("DepthSortBias", &GCParticleSystemDefinition::GetDepthSortBias, &GCParticleSystemDefinition::SetDepthSortBias)
        .addProperty("SortOverridePositionCP", &GCParticleSystemDefinition::GetSortOverridePositionCP, &GCParticleSystemDefinition::SetSortOverridePositionCP)
        .addProperty("InfiniteBounds", &GCParticleSystemDefinition::GetInfiniteBounds, &GCParticleSystemDefinition::SetInfiniteBounds)
        .addProperty("EnableNamedValues", &GCParticleSystemDefinition::GetEnableNamedValues, &GCParticleSystemDefinition::SetEnableNamedValues)
        .addProperty("NamedValueDomain", &GCParticleSystemDefinition::GetNamedValueDomain, &GCParticleSystemDefinition::SetNamedValueDomain)
        .addProperty("NamedValueLocals", &GCParticleSystemDefinition::GetNamedValueLocals, &GCParticleSystemDefinition::SetNamedValueLocals)
        .addProperty("ConstantColor", &GCParticleSystemDefinition::GetConstantColor, &GCParticleSystemDefinition::SetConstantColor)
        .addProperty("ConstantNormal", &GCParticleSystemDefinition::GetConstantNormal, &GCParticleSystemDefinition::SetConstantNormal)
        .addProperty("ConstantRadius", &GCParticleSystemDefinition::GetConstantRadius, &GCParticleSystemDefinition::SetConstantRadius)
        .addProperty("ConstantRotation", &GCParticleSystemDefinition::GetConstantRotation, &GCParticleSystemDefinition::SetConstantRotation)
        .addProperty("ConstantRotationSpeed", &GCParticleSystemDefinition::GetConstantRotationSpeed, &GCParticleSystemDefinition::SetConstantRotationSpeed)
        .addProperty("ConstantLifespan", &GCParticleSystemDefinition::GetConstantLifespan, &GCParticleSystemDefinition::SetConstantLifespan)
        .addProperty("ConstantSequenceNumber", &GCParticleSystemDefinition::GetConstantSequenceNumber, &GCParticleSystemDefinition::SetConstantSequenceNumber)
        .addProperty("ConstantSequenceNumber1", &GCParticleSystemDefinition::GetConstantSequenceNumber1, &GCParticleSystemDefinition::SetConstantSequenceNumber1)
        .addProperty("SnapshotControlPoint", &GCParticleSystemDefinition::GetSnapshotControlPoint, &GCParticleSystemDefinition::SetSnapshotControlPoint)
        .addProperty("CullRadius", &GCParticleSystemDefinition::GetCullRadius, &GCParticleSystemDefinition::SetCullRadius)
        .addProperty("CullFillCost", &GCParticleSystemDefinition::GetCullFillCost, &GCParticleSystemDefinition::SetCullFillCost)
        .addProperty("CullControlPoint", &GCParticleSystemDefinition::GetCullControlPoint, &GCParticleSystemDefinition::SetCullControlPoint)
        .addProperty("FallbackMaxCount", &GCParticleSystemDefinition::GetFallbackMaxCount, &GCParticleSystemDefinition::SetFallbackMaxCount)
        .addProperty("PreSimulationTime", &GCParticleSystemDefinition::GetPreSimulationTime, &GCParticleSystemDefinition::SetPreSimulationTime)
        .addProperty("StopSimulationAfterTime", &GCParticleSystemDefinition::GetStopSimulationAfterTime, &GCParticleSystemDefinition::SetStopSimulationAfterTime)
        .addProperty("MaximumTimeStep", &GCParticleSystemDefinition::GetMaximumTimeStep, &GCParticleSystemDefinition::SetMaximumTimeStep)
        .addProperty("MaximumSimTime", &GCParticleSystemDefinition::GetMaximumSimTime, &GCParticleSystemDefinition::SetMaximumSimTime)
        .addProperty("MinimumSimTime", &GCParticleSystemDefinition::GetMinimumSimTime, &GCParticleSystemDefinition::SetMinimumSimTime)
        .addProperty("MinimumTimeStep", &GCParticleSystemDefinition::GetMinimumTimeStep, &GCParticleSystemDefinition::SetMinimumTimeStep)
        .addProperty("MinimumFrames", &GCParticleSystemDefinition::GetMinimumFrames, &GCParticleSystemDefinition::SetMinimumFrames)
        .addProperty("MinCPULevel", &GCParticleSystemDefinition::GetMinCPULevel, &GCParticleSystemDefinition::SetMinCPULevel)
        .addProperty("MinGPULevel", &GCParticleSystemDefinition::GetMinGPULevel, &GCParticleSystemDefinition::SetMinGPULevel)
        .addProperty("NoDrawTimeToGoToSleep", &GCParticleSystemDefinition::GetNoDrawTimeToGoToSleep, &GCParticleSystemDefinition::SetNoDrawTimeToGoToSleep)
        .addProperty("MaxDrawDistance", &GCParticleSystemDefinition::GetMaxDrawDistance, &GCParticleSystemDefinition::SetMaxDrawDistance)
        .addProperty("StartFadeDistance", &GCParticleSystemDefinition::GetStartFadeDistance, &GCParticleSystemDefinition::SetStartFadeDistance)
        .addProperty("MaxCreationDistance", &GCParticleSystemDefinition::GetMaxCreationDistance, &GCParticleSystemDefinition::SetMaxCreationDistance)
        .addProperty("AggregationMinAvailableParticles", &GCParticleSystemDefinition::GetAggregationMinAvailableParticles, &GCParticleSystemDefinition::SetAggregationMinAvailableParticles)
        .addProperty("AggregateRadius", &GCParticleSystemDefinition::GetAggregateRadius, &GCParticleSystemDefinition::SetAggregateRadius)
        .addProperty("ShouldBatch", &GCParticleSystemDefinition::GetShouldBatch, &GCParticleSystemDefinition::SetShouldBatch)
        .addProperty("ShouldHitboxesFallbackToRenderBounds", &GCParticleSystemDefinition::GetShouldHitboxesFallbackToRenderBounds, &GCParticleSystemDefinition::SetShouldHitboxesFallbackToRenderBounds)
        .addProperty("ShouldHitboxesFallbackToSnapshot", &GCParticleSystemDefinition::GetShouldHitboxesFallbackToSnapshot, &GCParticleSystemDefinition::SetShouldHitboxesFallbackToSnapshot)
        .addProperty("ShouldHitboxesFallbackToCollisionHulls", &GCParticleSystemDefinition::GetShouldHitboxesFallbackToCollisionHulls, &GCParticleSystemDefinition::SetShouldHitboxesFallbackToCollisionHulls)
        .addProperty("ViewModelEffect", &GCParticleSystemDefinition::GetViewModelEffect, &GCParticleSystemDefinition::SetViewModelEffect)
        .addProperty("ScreenSpaceEffect", &GCParticleSystemDefinition::GetScreenSpaceEffect, &GCParticleSystemDefinition::SetScreenSpaceEffect)
        .addProperty("TargetLayerID", &GCParticleSystemDefinition::GetTargetLayerID, &GCParticleSystemDefinition::SetTargetLayerID)
        .addProperty("SkipRenderControlPoint", &GCParticleSystemDefinition::GetSkipRenderControlPoint, &GCParticleSystemDefinition::SetSkipRenderControlPoint)
        .addProperty("AllowRenderControlPoint", &GCParticleSystemDefinition::GetAllowRenderControlPoint, &GCParticleSystemDefinition::SetAllowRenderControlPoint)
        .addProperty("ShouldSort", &GCParticleSystemDefinition::GetShouldSort, &GCParticleSystemDefinition::SetShouldSort)
        .addProperty("ControlPointConfigurations", &GCParticleSystemDefinition::GetControlPointConfigurations, &GCParticleSystemDefinition::SetControlPointConfigurations)
        .addFunction("ToPtr", &GCParticleSystemDefinition::ToPtr)
        .addFunction("IsValid", &GCParticleSystemDefinition::IsValid)
        .endClass();
}
GCVoiceContainerSelector::GCVoiceContainerSelector(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCVoiceContainerSelector::GCVoiceContainerSelector(void *ptr) {
    m_ptr = ptr;
}
uint64_t GCVoiceContainerSelector::GetMode() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CVoiceContainerSelector", "m_mode");
}
void GCVoiceContainerSelector::SetMode(uint64_t value) {
    SetSchemaValue(m_ptr, "CVoiceContainerSelector", "m_mode", false, value);
}
bool GCVoiceContainerSelector::GetRetrigger() const {
    return GetSchemaValue<bool>(m_ptr, "CVoiceContainerSelector", "m_bRetrigger");
}
void GCVoiceContainerSelector::SetRetrigger(bool value) {
    SetSchemaValue(m_ptr, "CVoiceContainerSelector", "m_bRetrigger", false, value);
}
std::string GCVoiceContainerSelector::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCVoiceContainerSelector::IsValid() {
    return (m_ptr != nullptr);
}
GCVoiceContainerBase GCVoiceContainerSelector::GetParent() const {
    GCVoiceContainerBase value(m_ptr);
    return value;
}
void GCVoiceContainerSelector::SetParent(GCVoiceContainerBase value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCVoiceContainerSelector(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCVoiceContainerSelector>("CVoiceContainerSelector")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Mode", &GCVoiceContainerSelector::GetMode, &GCVoiceContainerSelector::SetMode)
        .addProperty("Retrigger", &GCVoiceContainerSelector::GetRetrigger, &GCVoiceContainerSelector::SetRetrigger)
        .addProperty("Parent", &GCVoiceContainerSelector::GetParent, &GCVoiceContainerSelector::SetParent)
        .addFunction("ToPtr", &GCVoiceContainerSelector::ToPtr)
        .addFunction("IsValid", &GCVoiceContainerSelector::IsValid)
        .endClass();
}
GCRegionSVM::GCRegionSVM(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCRegionSVM::GCRegionSVM(void *ptr) {
    m_ptr = ptr;
}
std::vector<GRnPlane_t> GCRegionSVM::GetPlanes() const {
    CUtlVector<GRnPlane_t>* vec = GetSchemaValue<CUtlVector<GRnPlane_t>*>(m_ptr, "CRegionSVM", "m_Planes"); std::vector<GRnPlane_t> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCRegionSVM::SetPlanes(std::vector<GRnPlane_t> value) {
    SetSchemaValueCUtlVector<GRnPlane_t>(m_ptr, "CRegionSVM", "m_Planes", false, value);
}
std::vector<uint32> GCRegionSVM::GetNodes() const {
    CUtlVector<uint32>* vec = GetSchemaValue<CUtlVector<uint32>*>(m_ptr, "CRegionSVM", "m_Nodes"); std::vector<uint32> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCRegionSVM::SetNodes(std::vector<uint32> value) {
    SetSchemaValueCUtlVector<uint32>(m_ptr, "CRegionSVM", "m_Nodes", false, value);
}
std::string GCRegionSVM::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCRegionSVM::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCRegionSVM(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCRegionSVM>("CRegionSVM")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Planes", &GCRegionSVM::GetPlanes, &GCRegionSVM::SetPlanes)
        .addProperty("Nodes", &GCRegionSVM::GetNodes, &GCRegionSVM::SetNodes)
        .addFunction("ToPtr", &GCRegionSVM::ToPtr)
        .addFunction("IsValid", &GCRegionSVM::IsValid)
        .endClass();
}
GCSetParameterActionUpdater::GCSetParameterActionUpdater(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCSetParameterActionUpdater::GCSetParameterActionUpdater(void *ptr) {
    m_ptr = ptr;
}
GCAnimParamHandle GCSetParameterActionUpdater::GetParam() const {
    GCAnimParamHandle value(GetSchemaPtr(m_ptr, "CSetParameterActionUpdater", "m_hParam"));
    return value;
}
void GCSetParameterActionUpdater::SetParam(GCAnimParamHandle value) {
    SetSchemaValue(m_ptr, "CSetParameterActionUpdater", "m_hParam", false, value);
}
std::string GCSetParameterActionUpdater::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCSetParameterActionUpdater::IsValid() {
    return (m_ptr != nullptr);
}
GCAnimActionUpdater GCSetParameterActionUpdater::GetParent() const {
    GCAnimActionUpdater value(m_ptr);
    return value;
}
void GCSetParameterActionUpdater::SetParent(GCAnimActionUpdater value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCSetParameterActionUpdater(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCSetParameterActionUpdater>("CSetParameterActionUpdater")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Param", &GCSetParameterActionUpdater::GetParam, &GCSetParameterActionUpdater::SetParam)
        .addProperty("Parent", &GCSetParameterActionUpdater::GetParent, &GCSetParameterActionUpdater::SetParent)
        .addFunction("ToPtr", &GCSetParameterActionUpdater::ToPtr)
        .addFunction("IsValid", &GCSetParameterActionUpdater::IsValid)
        .endClass();
}
GCAnimUpdateSharedData::GCAnimUpdateSharedData(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCAnimUpdateSharedData::GCAnimUpdateSharedData(void *ptr) {
    m_ptr = ptr;
}
GCAnimGraphSettingsManager GCAnimUpdateSharedData::GetSettings() const {
    GCAnimGraphSettingsManager value(GetSchemaPtr(m_ptr, "CAnimUpdateSharedData", "m_settings"));
    return value;
}
void GCAnimUpdateSharedData::SetSettings(GCAnimGraphSettingsManager value) {
    SetSchemaValue(m_ptr, "CAnimUpdateSharedData", "m_settings", false, value);
}
GCAnimNodePath GCAnimUpdateSharedData::GetRootNodePath() const {
    GCAnimNodePath value(GetSchemaPtr(m_ptr, "CAnimUpdateSharedData", "m_rootNodePath"));
    return value;
}
void GCAnimUpdateSharedData::SetRootNodePath(GCAnimNodePath value) {
    SetSchemaValue(m_ptr, "CAnimUpdateSharedData", "m_rootNodePath", false, value);
}
std::string GCAnimUpdateSharedData::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCAnimUpdateSharedData::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCAnimUpdateSharedData(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCAnimUpdateSharedData>("CAnimUpdateSharedData")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Settings", &GCAnimUpdateSharedData::GetSettings, &GCAnimUpdateSharedData::SetSettings)
        .addProperty("RootNodePath", &GCAnimUpdateSharedData::GetRootNodePath, &GCAnimUpdateSharedData::SetRootNodePath)
        .addFunction("ToPtr", &GCAnimUpdateSharedData::ToPtr)
        .addFunction("IsValid", &GCAnimUpdateSharedData::IsValid)
        .endClass();
}
GEventClientSimulate_t::GEventClientSimulate_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GEventClientSimulate_t::GEventClientSimulate_t(void *ptr) {
    m_ptr = ptr;
}
std::string GEventClientSimulate_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GEventClientSimulate_t::IsValid() {
    return (m_ptr != nullptr);
}
GEventSimulate_t GEventClientSimulate_t::GetParent() const {
    GEventSimulate_t value(m_ptr);
    return value;
}
void GEventClientSimulate_t::SetParent(GEventSimulate_t value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassEventClientSimulate_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GEventClientSimulate_t>("EventClientSimulate_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GEventClientSimulate_t::GetParent, &GEventClientSimulate_t::SetParent)
        .addFunction("ToPtr", &GEventClientSimulate_t::ToPtr)
        .addFunction("IsValid", &GEventClientSimulate_t::IsValid)
        .endClass();
}
GCVoiceContainerAmpedDecayingSineWave::GCVoiceContainerAmpedDecayingSineWave(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCVoiceContainerAmpedDecayingSineWave::GCVoiceContainerAmpedDecayingSineWave(void *ptr) {
    m_ptr = ptr;
}
float GCVoiceContainerAmpedDecayingSineWave::GetGainAmount() const {
    return GetSchemaValue<float>(m_ptr, "CVoiceContainerAmpedDecayingSineWave", "m_flGainAmount");
}
void GCVoiceContainerAmpedDecayingSineWave::SetGainAmount(float value) {
    SetSchemaValue(m_ptr, "CVoiceContainerAmpedDecayingSineWave", "m_flGainAmount", false, value);
}
std::string GCVoiceContainerAmpedDecayingSineWave::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCVoiceContainerAmpedDecayingSineWave::IsValid() {
    return (m_ptr != nullptr);
}
GCVoiceContainerDecayingSineWave GCVoiceContainerAmpedDecayingSineWave::GetParent() const {
    GCVoiceContainerDecayingSineWave value(m_ptr);
    return value;
}
void GCVoiceContainerAmpedDecayingSineWave::SetParent(GCVoiceContainerDecayingSineWave value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCVoiceContainerAmpedDecayingSineWave(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCVoiceContainerAmpedDecayingSineWave>("CVoiceContainerAmpedDecayingSineWave")
        .addConstructor<void (*)(std::string)>()
        .addProperty("GainAmount", &GCVoiceContainerAmpedDecayingSineWave::GetGainAmount, &GCVoiceContainerAmpedDecayingSineWave::SetGainAmount)
        .addProperty("Parent", &GCVoiceContainerAmpedDecayingSineWave::GetParent, &GCVoiceContainerAmpedDecayingSineWave::SetParent)
        .addFunction("ToPtr", &GCVoiceContainerAmpedDecayingSineWave::ToPtr)
        .addFunction("IsValid", &GCVoiceContainerAmpedDecayingSineWave::IsValid)
        .endClass();
}
GClutterTile_t::GClutterTile_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GClutterTile_t::GClutterTile_t(void *ptr) {
    m_ptr = ptr;
}
uint32_t GClutterTile_t::GetFirstInstance() const {
    return GetSchemaValue<uint32_t>(m_ptr, "ClutterTile_t", "m_nFirstInstance");
}
void GClutterTile_t::SetFirstInstance(uint32_t value) {
    SetSchemaValue(m_ptr, "ClutterTile_t", "m_nFirstInstance", true, value);
}
uint32_t GClutterTile_t::GetLastInstance() const {
    return GetSchemaValue<uint32_t>(m_ptr, "ClutterTile_t", "m_nLastInstance");
}
void GClutterTile_t::SetLastInstance(uint32_t value) {
    SetSchemaValue(m_ptr, "ClutterTile_t", "m_nLastInstance", true, value);
}
GAABB_t GClutterTile_t::GetBoundsWs() const {
    GAABB_t value(GetSchemaPtr(m_ptr, "ClutterTile_t", "m_BoundsWs"));
    return value;
}
void GClutterTile_t::SetBoundsWs(GAABB_t value) {
    SetSchemaValue(m_ptr, "ClutterTile_t", "m_BoundsWs", true, value);
}
std::string GClutterTile_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GClutterTile_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassClutterTile_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GClutterTile_t>("ClutterTile_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("FirstInstance", &GClutterTile_t::GetFirstInstance, &GClutterTile_t::SetFirstInstance)
        .addProperty("LastInstance", &GClutterTile_t::GetLastInstance, &GClutterTile_t::SetLastInstance)
        .addProperty("BoundsWs", &GClutterTile_t::GetBoundsWs, &GClutterTile_t::SetBoundsWs)
        .addFunction("ToPtr", &GClutterTile_t::ToPtr)
        .addFunction("IsValid", &GClutterTile_t::IsValid)
        .endClass();
}
GPointDefinitionWithTimeValues_t::GPointDefinitionWithTimeValues_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GPointDefinitionWithTimeValues_t::GPointDefinitionWithTimeValues_t(void *ptr) {
    m_ptr = ptr;
}
float GPointDefinitionWithTimeValues_t::GetTimeDuration() const {
    return GetSchemaValue<float>(m_ptr, "PointDefinitionWithTimeValues_t", "m_flTimeDuration");
}
void GPointDefinitionWithTimeValues_t::SetTimeDuration(float value) {
    SetSchemaValue(m_ptr, "PointDefinitionWithTimeValues_t", "m_flTimeDuration", true, value);
}
std::string GPointDefinitionWithTimeValues_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GPointDefinitionWithTimeValues_t::IsValid() {
    return (m_ptr != nullptr);
}
GPointDefinition_t GPointDefinitionWithTimeValues_t::GetParent() const {
    GPointDefinition_t value(m_ptr);
    return value;
}
void GPointDefinitionWithTimeValues_t::SetParent(GPointDefinition_t value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassPointDefinitionWithTimeValues_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GPointDefinitionWithTimeValues_t>("PointDefinitionWithTimeValues_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("TimeDuration", &GPointDefinitionWithTimeValues_t::GetTimeDuration, &GPointDefinitionWithTimeValues_t::SetTimeDuration)
        .addProperty("Parent", &GPointDefinitionWithTimeValues_t::GetParent, &GPointDefinitionWithTimeValues_t::SetParent)
        .addFunction("ToPtr", &GPointDefinitionWithTimeValues_t::ToPtr)
        .addFunction("IsValid", &GPointDefinitionWithTimeValues_t::IsValid)
        .endClass();
}
GFeVertexMapBuild_t::GFeVertexMapBuild_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GFeVertexMapBuild_t::GFeVertexMapBuild_t(void *ptr) {
    m_ptr = ptr;
}
std::string GFeVertexMapBuild_t::GetVertexMapName() const {
    return GetSchemaValue<CUtlString>(m_ptr, "FeVertexMapBuild_t", "m_VertexMapName").Get();
}
void GFeVertexMapBuild_t::SetVertexMapName(std::string value) {
    SetSchemaValue(m_ptr, "FeVertexMapBuild_t", "m_VertexMapName", true, CUtlString(value.c_str()));
}
uint32_t GFeVertexMapBuild_t::GetNameHash() const {
    return GetSchemaValue<uint32_t>(m_ptr, "FeVertexMapBuild_t", "m_nNameHash");
}
void GFeVertexMapBuild_t::SetNameHash(uint32_t value) {
    SetSchemaValue(m_ptr, "FeVertexMapBuild_t", "m_nNameHash", true, value);
}
Color GFeVertexMapBuild_t::GetColor() const {
    return GetSchemaValue<Color>(m_ptr, "FeVertexMapBuild_t", "m_Color");
}
void GFeVertexMapBuild_t::SetColor(Color value) {
    SetSchemaValue(m_ptr, "FeVertexMapBuild_t", "m_Color", true, value);
}
float GFeVertexMapBuild_t::GetVolumetricSolveStrength() const {
    return GetSchemaValue<float>(m_ptr, "FeVertexMapBuild_t", "m_flVolumetricSolveStrength");
}
void GFeVertexMapBuild_t::SetVolumetricSolveStrength(float value) {
    SetSchemaValue(m_ptr, "FeVertexMapBuild_t", "m_flVolumetricSolveStrength", true, value);
}
int32_t GFeVertexMapBuild_t::GetScaleSourceNode() const {
    return GetSchemaValue<int32_t>(m_ptr, "FeVertexMapBuild_t", "m_nScaleSourceNode");
}
void GFeVertexMapBuild_t::SetScaleSourceNode(int32_t value) {
    SetSchemaValue(m_ptr, "FeVertexMapBuild_t", "m_nScaleSourceNode", true, value);
}
std::vector<float32> GFeVertexMapBuild_t::GetWeights() const {
    CUtlVector<float32>* vec = GetSchemaValue<CUtlVector<float32>*>(m_ptr, "FeVertexMapBuild_t", "m_Weights"); std::vector<float32> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GFeVertexMapBuild_t::SetWeights(std::vector<float32> value) {
    SetSchemaValueCUtlVector<float32>(m_ptr, "FeVertexMapBuild_t", "m_Weights", true, value);
}
std::string GFeVertexMapBuild_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GFeVertexMapBuild_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassFeVertexMapBuild_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GFeVertexMapBuild_t>("FeVertexMapBuild_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("VertexMapName", &GFeVertexMapBuild_t::GetVertexMapName, &GFeVertexMapBuild_t::SetVertexMapName)
        .addProperty("NameHash", &GFeVertexMapBuild_t::GetNameHash, &GFeVertexMapBuild_t::SetNameHash)
        .addProperty("Color", &GFeVertexMapBuild_t::GetColor, &GFeVertexMapBuild_t::SetColor)
        .addProperty("VolumetricSolveStrength", &GFeVertexMapBuild_t::GetVolumetricSolveStrength, &GFeVertexMapBuild_t::SetVolumetricSolveStrength)
        .addProperty("ScaleSourceNode", &GFeVertexMapBuild_t::GetScaleSourceNode, &GFeVertexMapBuild_t::SetScaleSourceNode)
        .addProperty("Weights", &GFeVertexMapBuild_t::GetWeights, &GFeVertexMapBuild_t::SetWeights)
        .addFunction("ToPtr", &GFeVertexMapBuild_t::ToPtr)
        .addFunction("IsValid", &GFeVertexMapBuild_t::IsValid)
        .endClass();
}
GCAnimDesc::GCAnimDesc(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCAnimDesc::GCAnimDesc(void *ptr) {
    m_ptr = ptr;
}
CBufferString GCAnimDesc::GetName() const {
    return GetSchemaValue<CBufferString>(m_ptr, "CAnimDesc", "m_name");
}
void GCAnimDesc::SetName(CBufferString value) {
    SetSchemaValue(m_ptr, "CAnimDesc", "m_name", false, value);
}
GCAnimDesc_Flag GCAnimDesc::GetFlags() const {
    GCAnimDesc_Flag value(GetSchemaPtr(m_ptr, "CAnimDesc", "m_flags"));
    return value;
}
void GCAnimDesc::SetFlags(GCAnimDesc_Flag value) {
    SetSchemaValue(m_ptr, "CAnimDesc", "m_flags", false, value);
}
float GCAnimDesc::GetFps() const {
    return GetSchemaValue<float>(m_ptr, "CAnimDesc", "fps");
}
void GCAnimDesc::SetFps(float value) {
    SetSchemaValue(m_ptr, "CAnimDesc", "fps", false, value);
}
GCAnimEncodedFrames GCAnimDesc::GetData() const {
    GCAnimEncodedFrames value(GetSchemaPtr(m_ptr, "CAnimDesc", "m_Data"));
    return value;
}
void GCAnimDesc::SetData(GCAnimEncodedFrames value) {
    SetSchemaValue(m_ptr, "CAnimDesc", "m_Data", false, value);
}
std::vector<GCAnimMovement> GCAnimDesc::GetMovementArray() const {
    CUtlVector<GCAnimMovement>* vec = GetSchemaValue<CUtlVector<GCAnimMovement>*>(m_ptr, "CAnimDesc", "m_movementArray"); std::vector<GCAnimMovement> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCAnimDesc::SetMovementArray(std::vector<GCAnimMovement> value) {
    SetSchemaValueCUtlVector<GCAnimMovement>(m_ptr, "CAnimDesc", "m_movementArray", false, value);
}
std::vector<GCAnimEventDefinition> GCAnimDesc::GetEventArray() const {
    CUtlVector<GCAnimEventDefinition>* vec = GetSchemaValue<CUtlVector<GCAnimEventDefinition>*>(m_ptr, "CAnimDesc", "m_eventArray"); std::vector<GCAnimEventDefinition> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCAnimDesc::SetEventArray(std::vector<GCAnimEventDefinition> value) {
    SetSchemaValueCUtlVector<GCAnimEventDefinition>(m_ptr, "CAnimDesc", "m_eventArray", false, value);
}
std::vector<GCAnimActivity> GCAnimDesc::GetActivityArray() const {
    CUtlVector<GCAnimActivity>* vec = GetSchemaValue<CUtlVector<GCAnimActivity>*>(m_ptr, "CAnimDesc", "m_activityArray"); std::vector<GCAnimActivity> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCAnimDesc::SetActivityArray(std::vector<GCAnimActivity> value) {
    SetSchemaValueCUtlVector<GCAnimActivity>(m_ptr, "CAnimDesc", "m_activityArray", false, value);
}
std::vector<GCAnimLocalHierarchy> GCAnimDesc::GetHierarchyArray() const {
    CUtlVector<GCAnimLocalHierarchy>* vec = GetSchemaValue<CUtlVector<GCAnimLocalHierarchy>*>(m_ptr, "CAnimDesc", "m_hierarchyArray"); std::vector<GCAnimLocalHierarchy> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCAnimDesc::SetHierarchyArray(std::vector<GCAnimLocalHierarchy> value) {
    SetSchemaValueCUtlVector<GCAnimLocalHierarchy>(m_ptr, "CAnimDesc", "m_hierarchyArray", false, value);
}
float GCAnimDesc::GetFramestalltime() const {
    return GetSchemaValue<float>(m_ptr, "CAnimDesc", "framestalltime");
}
void GCAnimDesc::SetFramestalltime(float value) {
    SetSchemaValue(m_ptr, "CAnimDesc", "framestalltime", false, value);
}
Vector GCAnimDesc::GetRootMin() const {
    return GetSchemaValue<Vector>(m_ptr, "CAnimDesc", "m_vecRootMin");
}
void GCAnimDesc::SetRootMin(Vector value) {
    SetSchemaValue(m_ptr, "CAnimDesc", "m_vecRootMin", false, value);
}
Vector GCAnimDesc::GetRootMax() const {
    return GetSchemaValue<Vector>(m_ptr, "CAnimDesc", "m_vecRootMax");
}
void GCAnimDesc::SetRootMax(Vector value) {
    SetSchemaValue(m_ptr, "CAnimDesc", "m_vecRootMax", false, value);
}
std::vector<Vector> GCAnimDesc::GetBoneWorldMin() const {
    CUtlVector<Vector>* vec = GetSchemaValue<CUtlVector<Vector>*>(m_ptr, "CAnimDesc", "m_vecBoneWorldMin"); std::vector<Vector> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCAnimDesc::SetBoneWorldMin(std::vector<Vector> value) {
    SetSchemaValueCUtlVector<Vector>(m_ptr, "CAnimDesc", "m_vecBoneWorldMin", false, value);
}
std::vector<Vector> GCAnimDesc::GetBoneWorldMax() const {
    CUtlVector<Vector>* vec = GetSchemaValue<CUtlVector<Vector>*>(m_ptr, "CAnimDesc", "m_vecBoneWorldMax"); std::vector<Vector> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCAnimDesc::SetBoneWorldMax(std::vector<Vector> value) {
    SetSchemaValueCUtlVector<Vector>(m_ptr, "CAnimDesc", "m_vecBoneWorldMax", false, value);
}
GCAnimSequenceParams GCAnimDesc::GetSequenceParams() const {
    GCAnimSequenceParams value(GetSchemaPtr(m_ptr, "CAnimDesc", "m_sequenceParams"));
    return value;
}
void GCAnimDesc::SetSequenceParams(GCAnimSequenceParams value) {
    SetSchemaValue(m_ptr, "CAnimDesc", "m_sequenceParams", false, value);
}
std::string GCAnimDesc::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCAnimDesc::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCAnimDesc(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCAnimDesc>("CAnimDesc")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Name", &GCAnimDesc::GetName, &GCAnimDesc::SetName)
        .addProperty("Flags", &GCAnimDesc::GetFlags, &GCAnimDesc::SetFlags)
        .addProperty("Fps", &GCAnimDesc::GetFps, &GCAnimDesc::SetFps)
        .addProperty("Data", &GCAnimDesc::GetData, &GCAnimDesc::SetData)
        .addProperty("MovementArray", &GCAnimDesc::GetMovementArray, &GCAnimDesc::SetMovementArray)
        .addProperty("EventArray", &GCAnimDesc::GetEventArray, &GCAnimDesc::SetEventArray)
        .addProperty("ActivityArray", &GCAnimDesc::GetActivityArray, &GCAnimDesc::SetActivityArray)
        .addProperty("HierarchyArray", &GCAnimDesc::GetHierarchyArray, &GCAnimDesc::SetHierarchyArray)
        .addProperty("Framestalltime", &GCAnimDesc::GetFramestalltime, &GCAnimDesc::SetFramestalltime)
        .addProperty("RootMin", &GCAnimDesc::GetRootMin, &GCAnimDesc::SetRootMin)
        .addProperty("RootMax", &GCAnimDesc::GetRootMax, &GCAnimDesc::SetRootMax)
        .addProperty("BoneWorldMin", &GCAnimDesc::GetBoneWorldMin, &GCAnimDesc::SetBoneWorldMin)
        .addProperty("BoneWorldMax", &GCAnimDesc::GetBoneWorldMax, &GCAnimDesc::SetBoneWorldMax)
        .addProperty("SequenceParams", &GCAnimDesc::GetSequenceParams, &GCAnimDesc::SetSequenceParams)
        .addFunction("ToPtr", &GCAnimDesc::ToPtr)
        .addFunction("IsValid", &GCAnimDesc::IsValid)
        .endClass();
}
GCTwistConstraint::GCTwistConstraint(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCTwistConstraint::GCTwistConstraint(void *ptr) {
    m_ptr = ptr;
}
bool GCTwistConstraint::GetInverse() const {
    return GetSchemaValue<bool>(m_ptr, "CTwistConstraint", "m_bInverse");
}
void GCTwistConstraint::SetInverse(bool value) {
    SetSchemaValue(m_ptr, "CTwistConstraint", "m_bInverse", false, value);
}
Quaternion GCTwistConstraint::GetParentBindRotation() const {
    return GetSchemaValue<Quaternion>(m_ptr, "CTwistConstraint", "m_qParentBindRotation");
}
void GCTwistConstraint::SetParentBindRotation(Quaternion value) {
    SetSchemaValue(m_ptr, "CTwistConstraint", "m_qParentBindRotation", false, value);
}
Quaternion GCTwistConstraint::GetChildBindRotation() const {
    return GetSchemaValue<Quaternion>(m_ptr, "CTwistConstraint", "m_qChildBindRotation");
}
void GCTwistConstraint::SetChildBindRotation(Quaternion value) {
    SetSchemaValue(m_ptr, "CTwistConstraint", "m_qChildBindRotation", false, value);
}
std::string GCTwistConstraint::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCTwistConstraint::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseConstraint GCTwistConstraint::GetParent() const {
    GCBaseConstraint value(m_ptr);
    return value;
}
void GCTwistConstraint::SetParent(GCBaseConstraint value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCTwistConstraint(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCTwistConstraint>("CTwistConstraint")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Inverse", &GCTwistConstraint::GetInverse, &GCTwistConstraint::SetInverse)
        .addProperty("ParentBindRotation", &GCTwistConstraint::GetParentBindRotation, &GCTwistConstraint::SetParentBindRotation)
        .addProperty("ChildBindRotation", &GCTwistConstraint::GetChildBindRotation, &GCTwistConstraint::SetChildBindRotation)
        .addProperty("Parent", &GCTwistConstraint::GetParent, &GCTwistConstraint::SetParent)
        .addFunction("ToPtr", &GCTwistConstraint::ToPtr)
        .addFunction("IsValid", &GCTwistConstraint::IsValid)
        .endClass();
}
GCNewParticleEffect::GCNewParticleEffect(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCNewParticleEffect::GCNewParticleEffect(void *ptr) {
    m_ptr = ptr;
}
GCNewParticleEffect GCNewParticleEffect::GetNext() const {
    GCNewParticleEffect value(*GetSchemaValuePtr<void*>(m_ptr, "CNewParticleEffect", "m_pNext"));
    return value;
}
void GCNewParticleEffect::SetNext(GCNewParticleEffect* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Next' is not possible.\n");
}
GCNewParticleEffect GCNewParticleEffect::GetPrev() const {
    GCNewParticleEffect value(*GetSchemaValuePtr<void*>(m_ptr, "CNewParticleEffect", "m_pPrev"));
    return value;
}
void GCNewParticleEffect::SetPrev(GCNewParticleEffect* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Prev' is not possible.\n");
}
GIParticleCollection GCNewParticleEffect::GetParticles() const {
    GIParticleCollection value(*GetSchemaValuePtr<void*>(m_ptr, "CNewParticleEffect", "m_pParticles"));
    return value;
}
void GCNewParticleEffect::SetParticles(GIParticleCollection* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Particles' is not possible.\n");
}
std::string GCNewParticleEffect::GetDebugName() const {
    return GetSchemaValuePtr<char>(m_ptr, "CNewParticleEffect", "m_pDebugName");
}
void GCNewParticleEffect::SetDebugName(std::string value) {
    WriteSchemaPtrValue(m_ptr, "CNewParticleEffect", "m_pDebugName", false, reinterpret_cast<byte*>(const_cast<char*>(value.c_str())), value.size());
}
Vector GCNewParticleEffect::GetSortOrigin() const {
    return GetSchemaValue<Vector>(m_ptr, "CNewParticleEffect", "m_vSortOrigin");
}
void GCNewParticleEffect::SetSortOrigin(Vector value) {
    SetSchemaValue(m_ptr, "CNewParticleEffect", "m_vSortOrigin", false, value);
}
float GCNewParticleEffect::GetScale() const {
    return GetSchemaValue<float>(m_ptr, "CNewParticleEffect", "m_flScale");
}
void GCNewParticleEffect::SetScale(float value) {
    SetSchemaValue(m_ptr, "CNewParticleEffect", "m_flScale", false, value);
}
GPARTICLE_EHANDLE__ GCNewParticleEffect::GetOwner() const {
    GPARTICLE_EHANDLE__ value(*GetSchemaValuePtr<void*>(m_ptr, "CNewParticleEffect", "m_hOwner"));
    return value;
}
void GCNewParticleEffect::SetOwner(GPARTICLE_EHANDLE__* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Owner' is not possible.\n");
}
GCParticleProperty GCNewParticleEffect::GetOwningParticleProperty() const {
    GCParticleProperty value(*GetSchemaValuePtr<void*>(m_ptr, "CNewParticleEffect", "m_pOwningParticleProperty"));
    return value;
}
void GCNewParticleEffect::SetOwningParticleProperty(GCParticleProperty* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'OwningParticleProperty' is not possible.\n");
}
float GCNewParticleEffect::GetFreezeTransitionStart() const {
    return GetSchemaValue<float>(m_ptr, "CNewParticleEffect", "m_flFreezeTransitionStart");
}
void GCNewParticleEffect::SetFreezeTransitionStart(float value) {
    SetSchemaValue(m_ptr, "CNewParticleEffect", "m_flFreezeTransitionStart", false, value);
}
float GCNewParticleEffect::GetFreezeTransitionDuration() const {
    return GetSchemaValue<float>(m_ptr, "CNewParticleEffect", "m_flFreezeTransitionDuration");
}
void GCNewParticleEffect::SetFreezeTransitionDuration(float value) {
    SetSchemaValue(m_ptr, "CNewParticleEffect", "m_flFreezeTransitionDuration", false, value);
}
float GCNewParticleEffect::GetFreezeTransitionOverride() const {
    return GetSchemaValue<float>(m_ptr, "CNewParticleEffect", "m_flFreezeTransitionOverride");
}
void GCNewParticleEffect::SetFreezeTransitionOverride(float value) {
    SetSchemaValue(m_ptr, "CNewParticleEffect", "m_flFreezeTransitionOverride", false, value);
}
bool GCNewParticleEffect::GetFreezeTransitionActive() const {
    return GetSchemaValue<bool>(m_ptr, "CNewParticleEffect", "m_bFreezeTransitionActive");
}
void GCNewParticleEffect::SetFreezeTransitionActive(bool value) {
    SetSchemaValue(m_ptr, "CNewParticleEffect", "m_bFreezeTransitionActive", false, value);
}
bool GCNewParticleEffect::GetFreezeTargetState() const {
    return GetSchemaValue<bool>(m_ptr, "CNewParticleEffect", "m_bFreezeTargetState");
}
void GCNewParticleEffect::SetFreezeTargetState(bool value) {
    SetSchemaValue(m_ptr, "CNewParticleEffect", "m_bFreezeTargetState", false, value);
}
bool GCNewParticleEffect::GetCanFreeze() const {
    return GetSchemaValue<bool>(m_ptr, "CNewParticleEffect", "m_bCanFreeze");
}
void GCNewParticleEffect::SetCanFreeze(bool value) {
    SetSchemaValue(m_ptr, "CNewParticleEffect", "m_bCanFreeze", false, value);
}
Vector GCNewParticleEffect::GetLastMin() const {
    return GetSchemaValue<Vector>(m_ptr, "CNewParticleEffect", "m_LastMin");
}
void GCNewParticleEffect::SetLastMin(Vector value) {
    SetSchemaValue(m_ptr, "CNewParticleEffect", "m_LastMin", false, value);
}
Vector GCNewParticleEffect::GetLastMax() const {
    return GetSchemaValue<Vector>(m_ptr, "CNewParticleEffect", "m_LastMax");
}
void GCNewParticleEffect::SetLastMax(Vector value) {
    SetSchemaValue(m_ptr, "CNewParticleEffect", "m_LastMax", false, value);
}
int32_t GCNewParticleEffect::GetSplitScreenUser() const {
    return GetSchemaValue<int32_t>(m_ptr, "CNewParticleEffect", "m_nSplitScreenUser");
}
void GCNewParticleEffect::SetSplitScreenUser(int32_t value) {
    SetSchemaValue(m_ptr, "CNewParticleEffect", "m_nSplitScreenUser", false, value);
}
Vector GCNewParticleEffect::GetAggregationCenter() const {
    return GetSchemaValue<Vector>(m_ptr, "CNewParticleEffect", "m_vecAggregationCenter");
}
void GCNewParticleEffect::SetAggregationCenter(Vector value) {
    SetSchemaValue(m_ptr, "CNewParticleEffect", "m_vecAggregationCenter", false, value);
}
int32_t GCNewParticleEffect::GetRefCount() const {
    return GetSchemaValue<int32_t>(m_ptr, "CNewParticleEffect", "m_RefCount");
}
void GCNewParticleEffect::SetRefCount(int32_t value) {
    SetSchemaValue(m_ptr, "CNewParticleEffect", "m_RefCount", false, value);
}
std::string GCNewParticleEffect::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCNewParticleEffect::IsValid() {
    return (m_ptr != nullptr);
}
GIParticleEffect GCNewParticleEffect::GetParent() const {
    GIParticleEffect value(m_ptr);
    return value;
}
void GCNewParticleEffect::SetParent(GIParticleEffect value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCNewParticleEffect(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCNewParticleEffect>("CNewParticleEffect")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Next", &GCNewParticleEffect::GetNext, &GCNewParticleEffect::SetNext)
        .addProperty("Prev", &GCNewParticleEffect::GetPrev, &GCNewParticleEffect::SetPrev)
        .addProperty("Particles", &GCNewParticleEffect::GetParticles, &GCNewParticleEffect::SetParticles)
        .addProperty("DebugName", &GCNewParticleEffect::GetDebugName, &GCNewParticleEffect::SetDebugName)
        .addProperty("SortOrigin", &GCNewParticleEffect::GetSortOrigin, &GCNewParticleEffect::SetSortOrigin)
        .addProperty("Scale", &GCNewParticleEffect::GetScale, &GCNewParticleEffect::SetScale)
        .addProperty("Owner", &GCNewParticleEffect::GetOwner, &GCNewParticleEffect::SetOwner)
        .addProperty("OwningParticleProperty", &GCNewParticleEffect::GetOwningParticleProperty, &GCNewParticleEffect::SetOwningParticleProperty)
        .addProperty("FreezeTransitionStart", &GCNewParticleEffect::GetFreezeTransitionStart, &GCNewParticleEffect::SetFreezeTransitionStart)
        .addProperty("FreezeTransitionDuration", &GCNewParticleEffect::GetFreezeTransitionDuration, &GCNewParticleEffect::SetFreezeTransitionDuration)
        .addProperty("FreezeTransitionOverride", &GCNewParticleEffect::GetFreezeTransitionOverride, &GCNewParticleEffect::SetFreezeTransitionOverride)
        .addProperty("FreezeTransitionActive", &GCNewParticleEffect::GetFreezeTransitionActive, &GCNewParticleEffect::SetFreezeTransitionActive)
        .addProperty("FreezeTargetState", &GCNewParticleEffect::GetFreezeTargetState, &GCNewParticleEffect::SetFreezeTargetState)
        .addProperty("CanFreeze", &GCNewParticleEffect::GetCanFreeze, &GCNewParticleEffect::SetCanFreeze)
        .addProperty("LastMin", &GCNewParticleEffect::GetLastMin, &GCNewParticleEffect::SetLastMin)
        .addProperty("LastMax", &GCNewParticleEffect::GetLastMax, &GCNewParticleEffect::SetLastMax)
        .addProperty("SplitScreenUser", &GCNewParticleEffect::GetSplitScreenUser, &GCNewParticleEffect::SetSplitScreenUser)
        .addProperty("AggregationCenter", &GCNewParticleEffect::GetAggregationCenter, &GCNewParticleEffect::SetAggregationCenter)
        .addProperty("RefCount", &GCNewParticleEffect::GetRefCount, &GCNewParticleEffect::SetRefCount)
        .addProperty("Parent", &GCNewParticleEffect::GetParent, &GCNewParticleEffect::SetParent)
        .addFunction("ToPtr", &GCNewParticleEffect::ToPtr)
        .addFunction("IsValid", &GCNewParticleEffect::IsValid)
        .endClass();
}
GCFeIndexedJiggleBone::GCFeIndexedJiggleBone(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCFeIndexedJiggleBone::GCFeIndexedJiggleBone(void *ptr) {
    m_ptr = ptr;
}
uint32_t GCFeIndexedJiggleBone::GetNode() const {
    return GetSchemaValue<uint32_t>(m_ptr, "CFeIndexedJiggleBone", "m_nNode");
}
void GCFeIndexedJiggleBone::SetNode(uint32_t value) {
    SetSchemaValue(m_ptr, "CFeIndexedJiggleBone", "m_nNode", false, value);
}
uint32_t GCFeIndexedJiggleBone::GetJiggleParent() const {
    return GetSchemaValue<uint32_t>(m_ptr, "CFeIndexedJiggleBone", "m_nJiggleParent");
}
void GCFeIndexedJiggleBone::SetJiggleParent(uint32_t value) {
    SetSchemaValue(m_ptr, "CFeIndexedJiggleBone", "m_nJiggleParent", false, value);
}
GCFeJiggleBone GCFeIndexedJiggleBone::GetJiggleBone() const {
    GCFeJiggleBone value(GetSchemaPtr(m_ptr, "CFeIndexedJiggleBone", "m_jiggleBone"));
    return value;
}
void GCFeIndexedJiggleBone::SetJiggleBone(GCFeJiggleBone value) {
    SetSchemaValue(m_ptr, "CFeIndexedJiggleBone", "m_jiggleBone", false, value);
}
std::string GCFeIndexedJiggleBone::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCFeIndexedJiggleBone::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCFeIndexedJiggleBone(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCFeIndexedJiggleBone>("CFeIndexedJiggleBone")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Node", &GCFeIndexedJiggleBone::GetNode, &GCFeIndexedJiggleBone::SetNode)
        .addProperty("JiggleParent", &GCFeIndexedJiggleBone::GetJiggleParent, &GCFeIndexedJiggleBone::SetJiggleParent)
        .addProperty("JiggleBone", &GCFeIndexedJiggleBone::GetJiggleBone, &GCFeIndexedJiggleBone::SetJiggleBone)
        .addFunction("ToPtr", &GCFeIndexedJiggleBone::ToPtr)
        .addFunction("IsValid", &GCFeIndexedJiggleBone::IsValid)
        .endClass();
}
GCFloatAnimParameter::GCFloatAnimParameter(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCFloatAnimParameter::GCFloatAnimParameter(void *ptr) {
    m_ptr = ptr;
}
float GCFloatAnimParameter::GetDefaultValue() const {
    return GetSchemaValue<float>(m_ptr, "CFloatAnimParameter", "m_fDefaultValue");
}
void GCFloatAnimParameter::SetDefaultValue(float value) {
    SetSchemaValue(m_ptr, "CFloatAnimParameter", "m_fDefaultValue", false, value);
}
float GCFloatAnimParameter::GetMinValue() const {
    return GetSchemaValue<float>(m_ptr, "CFloatAnimParameter", "m_fMinValue");
}
void GCFloatAnimParameter::SetMinValue(float value) {
    SetSchemaValue(m_ptr, "CFloatAnimParameter", "m_fMinValue", false, value);
}
float GCFloatAnimParameter::GetMaxValue() const {
    return GetSchemaValue<float>(m_ptr, "CFloatAnimParameter", "m_fMaxValue");
}
void GCFloatAnimParameter::SetMaxValue(float value) {
    SetSchemaValue(m_ptr, "CFloatAnimParameter", "m_fMaxValue", false, value);
}
bool GCFloatAnimParameter::GetInterpolate() const {
    return GetSchemaValue<bool>(m_ptr, "CFloatAnimParameter", "m_bInterpolate");
}
void GCFloatAnimParameter::SetInterpolate(bool value) {
    SetSchemaValue(m_ptr, "CFloatAnimParameter", "m_bInterpolate", false, value);
}
std::string GCFloatAnimParameter::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCFloatAnimParameter::IsValid() {
    return (m_ptr != nullptr);
}
GCConcreteAnimParameter GCFloatAnimParameter::GetParent() const {
    GCConcreteAnimParameter value(m_ptr);
    return value;
}
void GCFloatAnimParameter::SetParent(GCConcreteAnimParameter value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCFloatAnimParameter(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCFloatAnimParameter>("CFloatAnimParameter")
        .addConstructor<void (*)(std::string)>()
        .addProperty("DefaultValue", &GCFloatAnimParameter::GetDefaultValue, &GCFloatAnimParameter::SetDefaultValue)
        .addProperty("MinValue", &GCFloatAnimParameter::GetMinValue, &GCFloatAnimParameter::SetMinValue)
        .addProperty("MaxValue", &GCFloatAnimParameter::GetMaxValue, &GCFloatAnimParameter::SetMaxValue)
        .addProperty("Interpolate", &GCFloatAnimParameter::GetInterpolate, &GCFloatAnimParameter::SetInterpolate)
        .addProperty("Parent", &GCFloatAnimParameter::GetParent, &GCFloatAnimParameter::SetParent)
        .addFunction("ToPtr", &GCFloatAnimParameter::ToPtr)
        .addFunction("IsValid", &GCFloatAnimParameter::IsValid)
        .endClass();
}
GRnBlendVertex_t::GRnBlendVertex_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GRnBlendVertex_t::GRnBlendVertex_t(void *ptr) {
    m_ptr = ptr;
}
uint16_t GRnBlendVertex_t::GetWeight0() const {
    return GetSchemaValue<uint16_t>(m_ptr, "RnBlendVertex_t", "m_nWeight0");
}
void GRnBlendVertex_t::SetWeight0(uint16_t value) {
    SetSchemaValue(m_ptr, "RnBlendVertex_t", "m_nWeight0", true, value);
}
uint16_t GRnBlendVertex_t::GetIndex0() const {
    return GetSchemaValue<uint16_t>(m_ptr, "RnBlendVertex_t", "m_nIndex0");
}
void GRnBlendVertex_t::SetIndex0(uint16_t value) {
    SetSchemaValue(m_ptr, "RnBlendVertex_t", "m_nIndex0", true, value);
}
uint16_t GRnBlendVertex_t::GetWeight1() const {
    return GetSchemaValue<uint16_t>(m_ptr, "RnBlendVertex_t", "m_nWeight1");
}
void GRnBlendVertex_t::SetWeight1(uint16_t value) {
    SetSchemaValue(m_ptr, "RnBlendVertex_t", "m_nWeight1", true, value);
}
uint16_t GRnBlendVertex_t::GetIndex1() const {
    return GetSchemaValue<uint16_t>(m_ptr, "RnBlendVertex_t", "m_nIndex1");
}
void GRnBlendVertex_t::SetIndex1(uint16_t value) {
    SetSchemaValue(m_ptr, "RnBlendVertex_t", "m_nIndex1", true, value);
}
uint16_t GRnBlendVertex_t::GetWeight2() const {
    return GetSchemaValue<uint16_t>(m_ptr, "RnBlendVertex_t", "m_nWeight2");
}
void GRnBlendVertex_t::SetWeight2(uint16_t value) {
    SetSchemaValue(m_ptr, "RnBlendVertex_t", "m_nWeight2", true, value);
}
uint16_t GRnBlendVertex_t::GetIndex2() const {
    return GetSchemaValue<uint16_t>(m_ptr, "RnBlendVertex_t", "m_nIndex2");
}
void GRnBlendVertex_t::SetIndex2(uint16_t value) {
    SetSchemaValue(m_ptr, "RnBlendVertex_t", "m_nIndex2", true, value);
}
uint16_t GRnBlendVertex_t::GetFlags() const {
    return GetSchemaValue<uint16_t>(m_ptr, "RnBlendVertex_t", "m_nFlags");
}
void GRnBlendVertex_t::SetFlags(uint16_t value) {
    SetSchemaValue(m_ptr, "RnBlendVertex_t", "m_nFlags", true, value);
}
uint16_t GRnBlendVertex_t::GetTargetIndex() const {
    return GetSchemaValue<uint16_t>(m_ptr, "RnBlendVertex_t", "m_nTargetIndex");
}
void GRnBlendVertex_t::SetTargetIndex(uint16_t value) {
    SetSchemaValue(m_ptr, "RnBlendVertex_t", "m_nTargetIndex", true, value);
}
std::string GRnBlendVertex_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GRnBlendVertex_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassRnBlendVertex_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GRnBlendVertex_t>("RnBlendVertex_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Weight0", &GRnBlendVertex_t::GetWeight0, &GRnBlendVertex_t::SetWeight0)
        .addProperty("Index0", &GRnBlendVertex_t::GetIndex0, &GRnBlendVertex_t::SetIndex0)
        .addProperty("Weight1", &GRnBlendVertex_t::GetWeight1, &GRnBlendVertex_t::SetWeight1)
        .addProperty("Index1", &GRnBlendVertex_t::GetIndex1, &GRnBlendVertex_t::SetIndex1)
        .addProperty("Weight2", &GRnBlendVertex_t::GetWeight2, &GRnBlendVertex_t::SetWeight2)
        .addProperty("Index2", &GRnBlendVertex_t::GetIndex2, &GRnBlendVertex_t::SetIndex2)
        .addProperty("Flags", &GRnBlendVertex_t::GetFlags, &GRnBlendVertex_t::SetFlags)
        .addProperty("TargetIndex", &GRnBlendVertex_t::GetTargetIndex, &GRnBlendVertex_t::SetTargetIndex)
        .addFunction("ToPtr", &GRnBlendVertex_t::ToPtr)
        .addFunction("IsValid", &GRnBlendVertex_t::IsValid)
        .endClass();
}
GCVirtualAnimParameter::GCVirtualAnimParameter(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCVirtualAnimParameter::GCVirtualAnimParameter(void *ptr) {
    m_ptr = ptr;
}
std::string GCVirtualAnimParameter::GetExpressionString() const {
    return GetSchemaValue<CUtlString>(m_ptr, "CVirtualAnimParameter", "m_expressionString").Get();
}
void GCVirtualAnimParameter::SetExpressionString(std::string value) {
    SetSchemaValue(m_ptr, "CVirtualAnimParameter", "m_expressionString", false, CUtlString(value.c_str()));
}
uint64_t GCVirtualAnimParameter::GetParamType() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CVirtualAnimParameter", "m_eParamType");
}
void GCVirtualAnimParameter::SetParamType(uint64_t value) {
    SetSchemaValue(m_ptr, "CVirtualAnimParameter", "m_eParamType", false, value);
}
std::string GCVirtualAnimParameter::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCVirtualAnimParameter::IsValid() {
    return (m_ptr != nullptr);
}
GCAnimParameterBase GCVirtualAnimParameter::GetParent() const {
    GCAnimParameterBase value(m_ptr);
    return value;
}
void GCVirtualAnimParameter::SetParent(GCAnimParameterBase value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCVirtualAnimParameter(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCVirtualAnimParameter>("CVirtualAnimParameter")
        .addConstructor<void (*)(std::string)>()
        .addProperty("ExpressionString", &GCVirtualAnimParameter::GetExpressionString, &GCVirtualAnimParameter::SetExpressionString)
        .addProperty("ParamType", &GCVirtualAnimParameter::GetParamType, &GCVirtualAnimParameter::SetParamType)
        .addProperty("Parent", &GCVirtualAnimParameter::GetParent, &GCVirtualAnimParameter::SetParent)
        .addFunction("ToPtr", &GCVirtualAnimParameter::ToPtr)
        .addFunction("IsValid", &GCVirtualAnimParameter::IsValid)
        .endClass();
}
GCHitBoxSetList::GCHitBoxSetList(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCHitBoxSetList::GCHitBoxSetList(void *ptr) {
    m_ptr = ptr;
}
std::vector<GCHitBoxSet> GCHitBoxSetList::GetHitBoxSets() const {
    CUtlVector<GCHitBoxSet>* vec = GetSchemaValue<CUtlVector<GCHitBoxSet>*>(m_ptr, "CHitBoxSetList", "m_HitBoxSets"); std::vector<GCHitBoxSet> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCHitBoxSetList::SetHitBoxSets(std::vector<GCHitBoxSet> value) {
    SetSchemaValueCUtlVector<GCHitBoxSet>(m_ptr, "CHitBoxSetList", "m_HitBoxSets", false, value);
}
std::string GCHitBoxSetList::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCHitBoxSetList::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCHitBoxSetList(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCHitBoxSetList>("CHitBoxSetList")
        .addConstructor<void (*)(std::string)>()
        .addProperty("HitBoxSets", &GCHitBoxSetList::GetHitBoxSets, &GCHitBoxSetList::SetHitBoxSets)
        .addFunction("ToPtr", &GCHitBoxSetList::ToPtr)
        .addFunction("IsValid", &GCHitBoxSetList::IsValid)
        .endClass();
}
GMaterialParamString_t::GMaterialParamString_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GMaterialParamString_t::GMaterialParamString_t(void *ptr) {
    m_ptr = ptr;
}
std::string GMaterialParamString_t::GetValue() const {
    return GetSchemaValue<CUtlString>(m_ptr, "MaterialParamString_t", "m_value").Get();
}
void GMaterialParamString_t::SetValue(std::string value) {
    SetSchemaValue(m_ptr, "MaterialParamString_t", "m_value", true, CUtlString(value.c_str()));
}
std::string GMaterialParamString_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GMaterialParamString_t::IsValid() {
    return (m_ptr != nullptr);
}
GMaterialParam_t GMaterialParamString_t::GetParent() const {
    GMaterialParam_t value(m_ptr);
    return value;
}
void GMaterialParamString_t::SetParent(GMaterialParam_t value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassMaterialParamString_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GMaterialParamString_t>("MaterialParamString_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Value", &GMaterialParamString_t::GetValue, &GMaterialParamString_t::SetValue)
        .addProperty("Parent", &GMaterialParamString_t::GetParent, &GMaterialParamString_t::SetParent)
        .addFunction("ToPtr", &GMaterialParamString_t::ToPtr)
        .addFunction("IsValid", &GMaterialParamString_t::IsValid)
        .endClass();
}
GVsInputSignature_t::GVsInputSignature_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GVsInputSignature_t::GVsInputSignature_t(void *ptr) {
    m_ptr = ptr;
}
std::vector<GVsInputSignatureElement_t> GVsInputSignature_t::GetElems() const {
    CUtlVector<GVsInputSignatureElement_t>* vec = GetSchemaValue<CUtlVector<GVsInputSignatureElement_t>*>(m_ptr, "VsInputSignature_t", "m_elems"); std::vector<GVsInputSignatureElement_t> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GVsInputSignature_t::SetElems(std::vector<GVsInputSignatureElement_t> value) {
    SetSchemaValueCUtlVector<GVsInputSignatureElement_t>(m_ptr, "VsInputSignature_t", "m_elems", true, value);
}
std::string GVsInputSignature_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GVsInputSignature_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassVsInputSignature_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GVsInputSignature_t>("VsInputSignature_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Elems", &GVsInputSignature_t::GetElems, &GVsInputSignature_t::SetElems)
        .addFunction("ToPtr", &GVsInputSignature_t::ToPtr)
        .addFunction("IsValid", &GVsInputSignature_t::IsValid)
        .endClass();
}
GInfoOverlayData_t::GInfoOverlayData_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GInfoOverlayData_t::GInfoOverlayData_t(void *ptr) {
    m_ptr = ptr;
}
matrix3x4_t GInfoOverlayData_t::GetTransform() const {
    return GetSchemaValue<matrix3x4_t>(m_ptr, "InfoOverlayData_t", "m_transform");
}
void GInfoOverlayData_t::SetTransform(matrix3x4_t value) {
    SetSchemaValue(m_ptr, "InfoOverlayData_t", "m_transform", true, value);
}
float GInfoOverlayData_t::GetWidth() const {
    return GetSchemaValue<float>(m_ptr, "InfoOverlayData_t", "m_flWidth");
}
void GInfoOverlayData_t::SetWidth(float value) {
    SetSchemaValue(m_ptr, "InfoOverlayData_t", "m_flWidth", true, value);
}
float GInfoOverlayData_t::GetHeight() const {
    return GetSchemaValue<float>(m_ptr, "InfoOverlayData_t", "m_flHeight");
}
void GInfoOverlayData_t::SetHeight(float value) {
    SetSchemaValue(m_ptr, "InfoOverlayData_t", "m_flHeight", true, value);
}
float GInfoOverlayData_t::GetDepth() const {
    return GetSchemaValue<float>(m_ptr, "InfoOverlayData_t", "m_flDepth");
}
void GInfoOverlayData_t::SetDepth(float value) {
    SetSchemaValue(m_ptr, "InfoOverlayData_t", "m_flDepth", true, value);
}
Vector2D GInfoOverlayData_t::GetUVStart() const {
    return GetSchemaValue<Vector2D>(m_ptr, "InfoOverlayData_t", "m_vUVStart");
}
void GInfoOverlayData_t::SetUVStart(Vector2D value) {
    SetSchemaValue(m_ptr, "InfoOverlayData_t", "m_vUVStart", true, value);
}
Vector2D GInfoOverlayData_t::GetUVEnd() const {
    return GetSchemaValue<Vector2D>(m_ptr, "InfoOverlayData_t", "m_vUVEnd");
}
void GInfoOverlayData_t::SetUVEnd(Vector2D value) {
    SetSchemaValue(m_ptr, "InfoOverlayData_t", "m_vUVEnd", true, value);
}
int32_t GInfoOverlayData_t::GetRenderOrder() const {
    return GetSchemaValue<int32_t>(m_ptr, "InfoOverlayData_t", "m_nRenderOrder");
}
void GInfoOverlayData_t::SetRenderOrder(int32_t value) {
    SetSchemaValue(m_ptr, "InfoOverlayData_t", "m_nRenderOrder", true, value);
}
Vector4D GInfoOverlayData_t::GetTintColor() const {
    return GetSchemaValue<Vector4D>(m_ptr, "InfoOverlayData_t", "m_vTintColor");
}
void GInfoOverlayData_t::SetTintColor(Vector4D value) {
    SetSchemaValue(m_ptr, "InfoOverlayData_t", "m_vTintColor", true, value);
}
int32_t GInfoOverlayData_t::GetSequenceOverride() const {
    return GetSchemaValue<int32_t>(m_ptr, "InfoOverlayData_t", "m_nSequenceOverride");
}
void GInfoOverlayData_t::SetSequenceOverride(int32_t value) {
    SetSchemaValue(m_ptr, "InfoOverlayData_t", "m_nSequenceOverride", true, value);
}
std::string GInfoOverlayData_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GInfoOverlayData_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassInfoOverlayData_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GInfoOverlayData_t>("InfoOverlayData_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Transform", &GInfoOverlayData_t::GetTransform, &GInfoOverlayData_t::SetTransform)
        .addProperty("Width", &GInfoOverlayData_t::GetWidth, &GInfoOverlayData_t::SetWidth)
        .addProperty("Height", &GInfoOverlayData_t::GetHeight, &GInfoOverlayData_t::SetHeight)
        .addProperty("Depth", &GInfoOverlayData_t::GetDepth, &GInfoOverlayData_t::SetDepth)
        .addProperty("UVStart", &GInfoOverlayData_t::GetUVStart, &GInfoOverlayData_t::SetUVStart)
        .addProperty("UVEnd", &GInfoOverlayData_t::GetUVEnd, &GInfoOverlayData_t::SetUVEnd)
        .addProperty("RenderOrder", &GInfoOverlayData_t::GetRenderOrder, &GInfoOverlayData_t::SetRenderOrder)
        .addProperty("TintColor", &GInfoOverlayData_t::GetTintColor, &GInfoOverlayData_t::SetTintColor)
        .addProperty("SequenceOverride", &GInfoOverlayData_t::GetSequenceOverride, &GInfoOverlayData_t::SetSequenceOverride)
        .addFunction("ToPtr", &GInfoOverlayData_t::ToPtr)
        .addFunction("IsValid", &GInfoOverlayData_t::IsValid)
        .endClass();
}
GCastSphereSATParams_t::GCastSphereSATParams_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCastSphereSATParams_t::GCastSphereSATParams_t(void *ptr) {
    m_ptr = ptr;
}
Vector GCastSphereSATParams_t::GetRayStart() const {
    return GetSchemaValue<Vector>(m_ptr, "CastSphereSATParams_t", "m_vRayStart");
}
void GCastSphereSATParams_t::SetRayStart(Vector value) {
    SetSchemaValue(m_ptr, "CastSphereSATParams_t", "m_vRayStart", true, value);
}
Vector GCastSphereSATParams_t::GetRayDelta() const {
    return GetSchemaValue<Vector>(m_ptr, "CastSphereSATParams_t", "m_vRayDelta");
}
void GCastSphereSATParams_t::SetRayDelta(Vector value) {
    SetSchemaValue(m_ptr, "CastSphereSATParams_t", "m_vRayDelta", true, value);
}
float GCastSphereSATParams_t::GetRadius() const {
    return GetSchemaValue<float>(m_ptr, "CastSphereSATParams_t", "m_flRadius");
}
void GCastSphereSATParams_t::SetRadius(float value) {
    SetSchemaValue(m_ptr, "CastSphereSATParams_t", "m_flRadius", true, value);
}
float GCastSphereSATParams_t::GetMaxFraction() const {
    return GetSchemaValue<float>(m_ptr, "CastSphereSATParams_t", "m_flMaxFraction");
}
void GCastSphereSATParams_t::SetMaxFraction(float value) {
    SetSchemaValue(m_ptr, "CastSphereSATParams_t", "m_flMaxFraction", true, value);
}
float GCastSphereSATParams_t::GetScale() const {
    return GetSchemaValue<float>(m_ptr, "CastSphereSATParams_t", "m_flScale");
}
void GCastSphereSATParams_t::SetScale(float value) {
    SetSchemaValue(m_ptr, "CastSphereSATParams_t", "m_flScale", true, value);
}
GRnHull_t GCastSphereSATParams_t::GetHull() const {
    GRnHull_t value(*GetSchemaValuePtr<void*>(m_ptr, "CastSphereSATParams_t", "m_pHull"));
    return value;
}
void GCastSphereSATParams_t::SetHull(GRnHull_t* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Hull' is not possible.\n");
}
std::string GCastSphereSATParams_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCastSphereSATParams_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCastSphereSATParams_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCastSphereSATParams_t>("CastSphereSATParams_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("RayStart", &GCastSphereSATParams_t::GetRayStart, &GCastSphereSATParams_t::SetRayStart)
        .addProperty("RayDelta", &GCastSphereSATParams_t::GetRayDelta, &GCastSphereSATParams_t::SetRayDelta)
        .addProperty("Radius", &GCastSphereSATParams_t::GetRadius, &GCastSphereSATParams_t::SetRadius)
        .addProperty("MaxFraction", &GCastSphereSATParams_t::GetMaxFraction, &GCastSphereSATParams_t::SetMaxFraction)
        .addProperty("Scale", &GCastSphereSATParams_t::GetScale, &GCastSphereSATParams_t::SetScale)
        .addProperty("Hull", &GCastSphereSATParams_t::GetHull, &GCastSphereSATParams_t::SetHull)
        .addFunction("ToPtr", &GCastSphereSATParams_t::ToPtr)
        .addFunction("IsValid", &GCastSphereSATParams_t::IsValid)
        .endClass();
}
GCBindPoseUpdateNode::GCBindPoseUpdateNode(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCBindPoseUpdateNode::GCBindPoseUpdateNode(void *ptr) {
    m_ptr = ptr;
}
std::string GCBindPoseUpdateNode::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCBindPoseUpdateNode::IsValid() {
    return (m_ptr != nullptr);
}
GCLeafUpdateNode GCBindPoseUpdateNode::GetParent() const {
    GCLeafUpdateNode value(m_ptr);
    return value;
}
void GCBindPoseUpdateNode::SetParent(GCLeafUpdateNode value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCBindPoseUpdateNode(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCBindPoseUpdateNode>("CBindPoseUpdateNode")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCBindPoseUpdateNode::GetParent, &GCBindPoseUpdateNode::SetParent)
        .addFunction("ToPtr", &GCBindPoseUpdateNode::ToPtr)
        .addFunction("IsValid", &GCBindPoseUpdateNode::IsValid)
        .endClass();
}
GVMixFreeverbDesc_t::GVMixFreeverbDesc_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GVMixFreeverbDesc_t::GVMixFreeverbDesc_t(void *ptr) {
    m_ptr = ptr;
}
float GVMixFreeverbDesc_t::GetRoomSize() const {
    return GetSchemaValue<float>(m_ptr, "VMixFreeverbDesc_t", "m_flRoomSize");
}
void GVMixFreeverbDesc_t::SetRoomSize(float value) {
    SetSchemaValue(m_ptr, "VMixFreeverbDesc_t", "m_flRoomSize", true, value);
}
float GVMixFreeverbDesc_t::GetDamp() const {
    return GetSchemaValue<float>(m_ptr, "VMixFreeverbDesc_t", "m_flDamp");
}
void GVMixFreeverbDesc_t::SetDamp(float value) {
    SetSchemaValue(m_ptr, "VMixFreeverbDesc_t", "m_flDamp", true, value);
}
float GVMixFreeverbDesc_t::GetWidth() const {
    return GetSchemaValue<float>(m_ptr, "VMixFreeverbDesc_t", "m_flWidth");
}
void GVMixFreeverbDesc_t::SetWidth(float value) {
    SetSchemaValue(m_ptr, "VMixFreeverbDesc_t", "m_flWidth", true, value);
}
float GVMixFreeverbDesc_t::GetLateReflections() const {
    return GetSchemaValue<float>(m_ptr, "VMixFreeverbDesc_t", "m_flLateReflections");
}
void GVMixFreeverbDesc_t::SetLateReflections(float value) {
    SetSchemaValue(m_ptr, "VMixFreeverbDesc_t", "m_flLateReflections", true, value);
}
std::string GVMixFreeverbDesc_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GVMixFreeverbDesc_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassVMixFreeverbDesc_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GVMixFreeverbDesc_t>("VMixFreeverbDesc_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("RoomSize", &GVMixFreeverbDesc_t::GetRoomSize, &GVMixFreeverbDesc_t::SetRoomSize)
        .addProperty("Damp", &GVMixFreeverbDesc_t::GetDamp, &GVMixFreeverbDesc_t::SetDamp)
        .addProperty("Width", &GVMixFreeverbDesc_t::GetWidth, &GVMixFreeverbDesc_t::SetWidth)
        .addProperty("LateReflections", &GVMixFreeverbDesc_t::GetLateReflections, &GVMixFreeverbDesc_t::SetLateReflections)
        .addFunction("ToPtr", &GVMixFreeverbDesc_t::ToPtr)
        .addFunction("IsValid", &GVMixFreeverbDesc_t::IsValid)
        .endClass();
}
GCCurrentVelocityMetricEvaluator::GCCurrentVelocityMetricEvaluator(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCCurrentVelocityMetricEvaluator::GCCurrentVelocityMetricEvaluator(void *ptr) {
    m_ptr = ptr;
}
std::string GCCurrentVelocityMetricEvaluator::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCCurrentVelocityMetricEvaluator::IsValid() {
    return (m_ptr != nullptr);
}
GCMotionMetricEvaluator GCCurrentVelocityMetricEvaluator::GetParent() const {
    GCMotionMetricEvaluator value(m_ptr);
    return value;
}
void GCCurrentVelocityMetricEvaluator::SetParent(GCMotionMetricEvaluator value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCCurrentVelocityMetricEvaluator(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCCurrentVelocityMetricEvaluator>("CCurrentVelocityMetricEvaluator")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCCurrentVelocityMetricEvaluator::GetParent, &GCCurrentVelocityMetricEvaluator::SetParent)
        .addFunction("ToPtr", &GCCurrentVelocityMetricEvaluator::ToPtr)
        .addFunction("IsValid", &GCCurrentVelocityMetricEvaluator::IsValid)
        .endClass();
}
GCVoxelVisibility::GCVoxelVisibility(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCVoxelVisibility::GCVoxelVisibility(void *ptr) {
    m_ptr = ptr;
}
uint32_t GCVoxelVisibility::GetBaseClusterCount() const {
    return GetSchemaValue<uint32_t>(m_ptr, "CVoxelVisibility", "m_nBaseClusterCount");
}
void GCVoxelVisibility::SetBaseClusterCount(uint32_t value) {
    SetSchemaValue(m_ptr, "CVoxelVisibility", "m_nBaseClusterCount", false, value);
}
uint32_t GCVoxelVisibility::GetPVSBytesPerCluster() const {
    return GetSchemaValue<uint32_t>(m_ptr, "CVoxelVisibility", "m_nPVSBytesPerCluster");
}
void GCVoxelVisibility::SetPVSBytesPerCluster(uint32_t value) {
    SetSchemaValue(m_ptr, "CVoxelVisibility", "m_nPVSBytesPerCluster", false, value);
}
Vector GCVoxelVisibility::GetMinBounds() const {
    return GetSchemaValue<Vector>(m_ptr, "CVoxelVisibility", "m_vMinBounds");
}
void GCVoxelVisibility::SetMinBounds(Vector value) {
    SetSchemaValue(m_ptr, "CVoxelVisibility", "m_vMinBounds", false, value);
}
Vector GCVoxelVisibility::GetMaxBounds() const {
    return GetSchemaValue<Vector>(m_ptr, "CVoxelVisibility", "m_vMaxBounds");
}
void GCVoxelVisibility::SetMaxBounds(Vector value) {
    SetSchemaValue(m_ptr, "CVoxelVisibility", "m_vMaxBounds", false, value);
}
float GCVoxelVisibility::GetGridSize() const {
    return GetSchemaValue<float>(m_ptr, "CVoxelVisibility", "m_flGridSize");
}
void GCVoxelVisibility::SetGridSize(float value) {
    SetSchemaValue(m_ptr, "CVoxelVisibility", "m_flGridSize", false, value);
}
uint32_t GCVoxelVisibility::GetSkyVisibilityCluster() const {
    return GetSchemaValue<uint32_t>(m_ptr, "CVoxelVisibility", "m_nSkyVisibilityCluster");
}
void GCVoxelVisibility::SetSkyVisibilityCluster(uint32_t value) {
    SetSchemaValue(m_ptr, "CVoxelVisibility", "m_nSkyVisibilityCluster", false, value);
}
uint32_t GCVoxelVisibility::GetSunVisibilityCluster() const {
    return GetSchemaValue<uint32_t>(m_ptr, "CVoxelVisibility", "m_nSunVisibilityCluster");
}
void GCVoxelVisibility::SetSunVisibilityCluster(uint32_t value) {
    SetSchemaValue(m_ptr, "CVoxelVisibility", "m_nSunVisibilityCluster", false, value);
}
GVoxelVisBlockOffset_t GCVoxelVisibility::GetNodeBlock() const {
    GVoxelVisBlockOffset_t value(GetSchemaPtr(m_ptr, "CVoxelVisibility", "m_NodeBlock"));
    return value;
}
void GCVoxelVisibility::SetNodeBlock(GVoxelVisBlockOffset_t value) {
    SetSchemaValue(m_ptr, "CVoxelVisibility", "m_NodeBlock", false, value);
}
GVoxelVisBlockOffset_t GCVoxelVisibility::GetRegionBlock() const {
    GVoxelVisBlockOffset_t value(GetSchemaPtr(m_ptr, "CVoxelVisibility", "m_RegionBlock"));
    return value;
}
void GCVoxelVisibility::SetRegionBlock(GVoxelVisBlockOffset_t value) {
    SetSchemaValue(m_ptr, "CVoxelVisibility", "m_RegionBlock", false, value);
}
GVoxelVisBlockOffset_t GCVoxelVisibility::GetEnclosedClusterListBlock() const {
    GVoxelVisBlockOffset_t value(GetSchemaPtr(m_ptr, "CVoxelVisibility", "m_EnclosedClusterListBlock"));
    return value;
}
void GCVoxelVisibility::SetEnclosedClusterListBlock(GVoxelVisBlockOffset_t value) {
    SetSchemaValue(m_ptr, "CVoxelVisibility", "m_EnclosedClusterListBlock", false, value);
}
GVoxelVisBlockOffset_t GCVoxelVisibility::GetEnclosedClustersBlock() const {
    GVoxelVisBlockOffset_t value(GetSchemaPtr(m_ptr, "CVoxelVisibility", "m_EnclosedClustersBlock"));
    return value;
}
void GCVoxelVisibility::SetEnclosedClustersBlock(GVoxelVisBlockOffset_t value) {
    SetSchemaValue(m_ptr, "CVoxelVisibility", "m_EnclosedClustersBlock", false, value);
}
GVoxelVisBlockOffset_t GCVoxelVisibility::GetMasksBlock() const {
    GVoxelVisBlockOffset_t value(GetSchemaPtr(m_ptr, "CVoxelVisibility", "m_MasksBlock"));
    return value;
}
void GCVoxelVisibility::SetMasksBlock(GVoxelVisBlockOffset_t value) {
    SetSchemaValue(m_ptr, "CVoxelVisibility", "m_MasksBlock", false, value);
}
GVoxelVisBlockOffset_t GCVoxelVisibility::GetVisBlocks() const {
    GVoxelVisBlockOffset_t value(GetSchemaPtr(m_ptr, "CVoxelVisibility", "m_nVisBlocks"));
    return value;
}
void GCVoxelVisibility::SetVisBlocks(GVoxelVisBlockOffset_t value) {
    SetSchemaValue(m_ptr, "CVoxelVisibility", "m_nVisBlocks", false, value);
}
std::string GCVoxelVisibility::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCVoxelVisibility::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCVoxelVisibility(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCVoxelVisibility>("CVoxelVisibility")
        .addConstructor<void (*)(std::string)>()
        .addProperty("BaseClusterCount", &GCVoxelVisibility::GetBaseClusterCount, &GCVoxelVisibility::SetBaseClusterCount)
        .addProperty("PVSBytesPerCluster", &GCVoxelVisibility::GetPVSBytesPerCluster, &GCVoxelVisibility::SetPVSBytesPerCluster)
        .addProperty("MinBounds", &GCVoxelVisibility::GetMinBounds, &GCVoxelVisibility::SetMinBounds)
        .addProperty("MaxBounds", &GCVoxelVisibility::GetMaxBounds, &GCVoxelVisibility::SetMaxBounds)
        .addProperty("GridSize", &GCVoxelVisibility::GetGridSize, &GCVoxelVisibility::SetGridSize)
        .addProperty("SkyVisibilityCluster", &GCVoxelVisibility::GetSkyVisibilityCluster, &GCVoxelVisibility::SetSkyVisibilityCluster)
        .addProperty("SunVisibilityCluster", &GCVoxelVisibility::GetSunVisibilityCluster, &GCVoxelVisibility::SetSunVisibilityCluster)
        .addProperty("NodeBlock", &GCVoxelVisibility::GetNodeBlock, &GCVoxelVisibility::SetNodeBlock)
        .addProperty("RegionBlock", &GCVoxelVisibility::GetRegionBlock, &GCVoxelVisibility::SetRegionBlock)
        .addProperty("EnclosedClusterListBlock", &GCVoxelVisibility::GetEnclosedClusterListBlock, &GCVoxelVisibility::SetEnclosedClusterListBlock)
        .addProperty("EnclosedClustersBlock", &GCVoxelVisibility::GetEnclosedClustersBlock, &GCVoxelVisibility::SetEnclosedClustersBlock)
        .addProperty("MasksBlock", &GCVoxelVisibility::GetMasksBlock, &GCVoxelVisibility::SetMasksBlock)
        .addProperty("VisBlocks", &GCVoxelVisibility::GetVisBlocks, &GCVoxelVisibility::SetVisBlocks)
        .addFunction("ToPtr", &GCVoxelVisibility::ToPtr)
        .addFunction("IsValid", &GCVoxelVisibility::IsValid)
        .endClass();
}
GSelectedEditItemInfo_t::GSelectedEditItemInfo_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GSelectedEditItemInfo_t::GSelectedEditItemInfo_t(void *ptr) {
    m_ptr = ptr;
}
std::vector<GSosEditItemInfo_t> GSelectedEditItemInfo_t::GetEditItems() const {
    CUtlVector<GSosEditItemInfo_t>* vec = GetSchemaValue<CUtlVector<GSosEditItemInfo_t>*>(m_ptr, "SelectedEditItemInfo_t", "m_EditItems"); std::vector<GSosEditItemInfo_t> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GSelectedEditItemInfo_t::SetEditItems(std::vector<GSosEditItemInfo_t> value) {
    SetSchemaValueCUtlVector<GSosEditItemInfo_t>(m_ptr, "SelectedEditItemInfo_t", "m_EditItems", true, value);
}
std::string GSelectedEditItemInfo_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GSelectedEditItemInfo_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassSelectedEditItemInfo_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GSelectedEditItemInfo_t>("SelectedEditItemInfo_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("EditItems", &GSelectedEditItemInfo_t::GetEditItems, &GSelectedEditItemInfo_t::SetEditItems)
        .addFunction("ToPtr", &GSelectedEditItemInfo_t::ToPtr)
        .addFunction("IsValid", &GSelectedEditItemInfo_t::IsValid)
        .endClass();
}
GChainToSolveData_t::GChainToSolveData_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GChainToSolveData_t::GChainToSolveData_t(void *ptr) {
    m_ptr = ptr;
}
int32_t GChainToSolveData_t::GetChainIndex() const {
    return GetSchemaValue<int32_t>(m_ptr, "ChainToSolveData_t", "m_nChainIndex");
}
void GChainToSolveData_t::SetChainIndex(int32_t value) {
    SetSchemaValue(m_ptr, "ChainToSolveData_t", "m_nChainIndex", true, value);
}
GIKSolverSettings_t GChainToSolveData_t::GetSolverSettings() const {
    GIKSolverSettings_t value(GetSchemaPtr(m_ptr, "ChainToSolveData_t", "m_SolverSettings"));
    return value;
}
void GChainToSolveData_t::SetSolverSettings(GIKSolverSettings_t value) {
    SetSchemaValue(m_ptr, "ChainToSolveData_t", "m_SolverSettings", true, value);
}
GIKTargetSettings_t GChainToSolveData_t::GetTargetSettings() const {
    GIKTargetSettings_t value(GetSchemaPtr(m_ptr, "ChainToSolveData_t", "m_TargetSettings"));
    return value;
}
void GChainToSolveData_t::SetTargetSettings(GIKTargetSettings_t value) {
    SetSchemaValue(m_ptr, "ChainToSolveData_t", "m_TargetSettings", true, value);
}
uint64_t GChainToSolveData_t::GetDebugSetting() const {
    return GetSchemaValue<uint64_t>(m_ptr, "ChainToSolveData_t", "m_DebugSetting");
}
void GChainToSolveData_t::SetDebugSetting(uint64_t value) {
    SetSchemaValue(m_ptr, "ChainToSolveData_t", "m_DebugSetting", true, value);
}
float GChainToSolveData_t::GetDebugNormalizedValue() const {
    return GetSchemaValue<float>(m_ptr, "ChainToSolveData_t", "m_flDebugNormalizedValue");
}
void GChainToSolveData_t::SetDebugNormalizedValue(float value) {
    SetSchemaValue(m_ptr, "ChainToSolveData_t", "m_flDebugNormalizedValue", true, value);
}
Vector GChainToSolveData_t::GetDebugOffset() const {
    return GetSchemaValue<Vector>(m_ptr, "ChainToSolveData_t", "m_vDebugOffset");
}
void GChainToSolveData_t::SetDebugOffset(Vector value) {
    SetSchemaValue(m_ptr, "ChainToSolveData_t", "m_vDebugOffset", true, value);
}
std::string GChainToSolveData_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GChainToSolveData_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassChainToSolveData_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GChainToSolveData_t>("ChainToSolveData_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("ChainIndex", &GChainToSolveData_t::GetChainIndex, &GChainToSolveData_t::SetChainIndex)
        .addProperty("SolverSettings", &GChainToSolveData_t::GetSolverSettings, &GChainToSolveData_t::SetSolverSettings)
        .addProperty("TargetSettings", &GChainToSolveData_t::GetTargetSettings, &GChainToSolveData_t::SetTargetSettings)
        .addProperty("DebugSetting", &GChainToSolveData_t::GetDebugSetting, &GChainToSolveData_t::SetDebugSetting)
        .addProperty("DebugNormalizedValue", &GChainToSolveData_t::GetDebugNormalizedValue, &GChainToSolveData_t::SetDebugNormalizedValue)
        .addProperty("DebugOffset", &GChainToSolveData_t::GetDebugOffset, &GChainToSolveData_t::SetDebugOffset)
        .addFunction("ToPtr", &GChainToSolveData_t::ToPtr)
        .addFunction("IsValid", &GChainToSolveData_t::IsValid)
        .endClass();
}
GCGlowSprite::GCGlowSprite(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCGlowSprite::GCGlowSprite(void *ptr) {
    m_ptr = ptr;
}
Vector GCGlowSprite::GetColor() const {
    return GetSchemaValue<Vector>(m_ptr, "CGlowSprite", "m_vColor");
}
void GCGlowSprite::SetColor(Vector value) {
    SetSchemaValue(m_ptr, "CGlowSprite", "m_vColor", false, value);
}
float GCGlowSprite::GetHorzSize() const {
    return GetSchemaValue<float>(m_ptr, "CGlowSprite", "m_flHorzSize");
}
void GCGlowSprite::SetHorzSize(float value) {
    SetSchemaValue(m_ptr, "CGlowSprite", "m_flHorzSize", false, value);
}
float GCGlowSprite::GetVertSize() const {
    return GetSchemaValue<float>(m_ptr, "CGlowSprite", "m_flVertSize");
}
void GCGlowSprite::SetVertSize(float value) {
    SetSchemaValue(m_ptr, "CGlowSprite", "m_flVertSize", false, value);
}
std::string GCGlowSprite::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCGlowSprite::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCGlowSprite(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCGlowSprite>("CGlowSprite")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Color", &GCGlowSprite::GetColor, &GCGlowSprite::SetColor)
        .addProperty("HorzSize", &GCGlowSprite::GetHorzSize, &GCGlowSprite::SetHorzSize)
        .addProperty("VertSize", &GCGlowSprite::GetVertSize, &GCGlowSprite::SetVertSize)
        .addFunction("ToPtr", &GCGlowSprite::ToPtr)
        .addFunction("IsValid", &GCGlowSprite::IsValid)
        .endClass();
}
GCSSDSMsg_PostLayer::GCSSDSMsg_PostLayer(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCSSDSMsg_PostLayer::GCSSDSMsg_PostLayer(void *ptr) {
    m_ptr = ptr;
}
std::string GCSSDSMsg_PostLayer::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCSSDSMsg_PostLayer::IsValid() {
    return (m_ptr != nullptr);
}
GCSSDSMsg_LayerBase GCSSDSMsg_PostLayer::GetParent() const {
    GCSSDSMsg_LayerBase value(m_ptr);
    return value;
}
void GCSSDSMsg_PostLayer::SetParent(GCSSDSMsg_LayerBase value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCSSDSMsg_PostLayer(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCSSDSMsg_PostLayer>("CSSDSMsg_PostLayer")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCSSDSMsg_PostLayer::GetParent, &GCSSDSMsg_PostLayer::SetParent)
        .addFunction("ToPtr", &GCSSDSMsg_PostLayer::ToPtr)
        .addFunction("IsValid", &GCSSDSMsg_PostLayer::IsValid)
        .endClass();
}
GCAnimBone::GCAnimBone(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCAnimBone::GCAnimBone(void *ptr) {
    m_ptr = ptr;
}
CBufferString GCAnimBone::GetName() const {
    return GetSchemaValue<CBufferString>(m_ptr, "CAnimBone", "m_name");
}
void GCAnimBone::SetName(CBufferString value) {
    SetSchemaValue(m_ptr, "CAnimBone", "m_name", false, value);
}
int32_t GCAnimBone::GetParent() const {
    return GetSchemaValue<int32_t>(m_ptr, "CAnimBone", "m_parent");
}
void GCAnimBone::SetParent(int32_t value) {
    SetSchemaValue(m_ptr, "CAnimBone", "m_parent", false, value);
}
Vector GCAnimBone::GetPos() const {
    return GetSchemaValue<Vector>(m_ptr, "CAnimBone", "m_pos");
}
void GCAnimBone::SetPos(Vector value) {
    SetSchemaValue(m_ptr, "CAnimBone", "m_pos", false, value);
}
float GCAnimBone::GetScale() const {
    return GetSchemaValue<float>(m_ptr, "CAnimBone", "m_scale");
}
void GCAnimBone::SetScale(float value) {
    SetSchemaValue(m_ptr, "CAnimBone", "m_scale", false, value);
}
int32_t GCAnimBone::GetFlags() const {
    return GetSchemaValue<int32_t>(m_ptr, "CAnimBone", "m_flags");
}
void GCAnimBone::SetFlags(int32_t value) {
    SetSchemaValue(m_ptr, "CAnimBone", "m_flags", false, value);
}
std::string GCAnimBone::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCAnimBone::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCAnimBone(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCAnimBone>("CAnimBone")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Name", &GCAnimBone::GetName, &GCAnimBone::SetName)
        .addProperty("Parent", &GCAnimBone::GetParent, &GCAnimBone::SetParent)
        .addProperty("Pos", &GCAnimBone::GetPos, &GCAnimBone::SetPos)
        .addProperty("Scale", &GCAnimBone::GetScale, &GCAnimBone::SetScale)
        .addProperty("Flags", &GCAnimBone::GetFlags, &GCAnimBone::SetFlags)
        .addFunction("ToPtr", &GCAnimBone::ToPtr)
        .addFunction("IsValid", &GCAnimBone::IsValid)
        .endClass();
}
GVPhysXConstraint2_t::GVPhysXConstraint2_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GVPhysXConstraint2_t::GVPhysXConstraint2_t(void *ptr) {
    m_ptr = ptr;
}
uint32_t GVPhysXConstraint2_t::GetFlags() const {
    return GetSchemaValue<uint32_t>(m_ptr, "VPhysXConstraint2_t", "m_nFlags");
}
void GVPhysXConstraint2_t::SetFlags(uint32_t value) {
    SetSchemaValue(m_ptr, "VPhysXConstraint2_t", "m_nFlags", true, value);
}
uint16_t GVPhysXConstraint2_t::GetParent() const {
    return GetSchemaValue<uint16_t>(m_ptr, "VPhysXConstraint2_t", "m_nParent");
}
void GVPhysXConstraint2_t::SetParent(uint16_t value) {
    SetSchemaValue(m_ptr, "VPhysXConstraint2_t", "m_nParent", true, value);
}
uint16_t GVPhysXConstraint2_t::GetChild() const {
    return GetSchemaValue<uint16_t>(m_ptr, "VPhysXConstraint2_t", "m_nChild");
}
void GVPhysXConstraint2_t::SetChild(uint16_t value) {
    SetSchemaValue(m_ptr, "VPhysXConstraint2_t", "m_nChild", true, value);
}
GVPhysXConstraintParams_t GVPhysXConstraint2_t::GetParams() const {
    GVPhysXConstraintParams_t value(GetSchemaPtr(m_ptr, "VPhysXConstraint2_t", "m_params"));
    return value;
}
void GVPhysXConstraint2_t::SetParams(GVPhysXConstraintParams_t value) {
    SetSchemaValue(m_ptr, "VPhysXConstraint2_t", "m_params", true, value);
}
std::string GVPhysXConstraint2_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GVPhysXConstraint2_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassVPhysXConstraint2_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GVPhysXConstraint2_t>("VPhysXConstraint2_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Flags", &GVPhysXConstraint2_t::GetFlags, &GVPhysXConstraint2_t::SetFlags)
        .addProperty("Parent", &GVPhysXConstraint2_t::GetParent, &GVPhysXConstraint2_t::SetParent)
        .addProperty("Child", &GVPhysXConstraint2_t::GetChild, &GVPhysXConstraint2_t::SetChild)
        .addProperty("Params", &GVPhysXConstraint2_t::GetParams, &GVPhysXConstraint2_t::SetParams)
        .addFunction("ToPtr", &GVPhysXConstraint2_t::ToPtr)
        .addFunction("IsValid", &GVPhysXConstraint2_t::IsValid)
        .endClass();
}
GCEditableMotionGraph::GCEditableMotionGraph(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCEditableMotionGraph::GCEditableMotionGraph(void *ptr) {
    m_ptr = ptr;
}
std::string GCEditableMotionGraph::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCEditableMotionGraph::IsValid() {
    return (m_ptr != nullptr);
}
GCMotionGraph GCEditableMotionGraph::GetParent() const {
    GCMotionGraph value(m_ptr);
    return value;
}
void GCEditableMotionGraph::SetParent(GCMotionGraph value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCEditableMotionGraph(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCEditableMotionGraph>("CEditableMotionGraph")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCEditableMotionGraph::GetParent, &GCEditableMotionGraph::SetParent)
        .addFunction("ToPtr", &GCEditableMotionGraph::ToPtr)
        .addFunction("IsValid", &GCEditableMotionGraph::IsValid)
        .endClass();
}
GCAnimKeyData::GCAnimKeyData(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCAnimKeyData::GCAnimKeyData(void *ptr) {
    m_ptr = ptr;
}
CBufferString GCAnimKeyData::GetName() const {
    return GetSchemaValue<CBufferString>(m_ptr, "CAnimKeyData", "m_name");
}
void GCAnimKeyData::SetName(CBufferString value) {
    SetSchemaValue(m_ptr, "CAnimKeyData", "m_name", false, value);
}
std::vector<GCAnimBone> GCAnimKeyData::GetBoneArray() const {
    CUtlVector<GCAnimBone>* vec = GetSchemaValue<CUtlVector<GCAnimBone>*>(m_ptr, "CAnimKeyData", "m_boneArray"); std::vector<GCAnimBone> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCAnimKeyData::SetBoneArray(std::vector<GCAnimBone> value) {
    SetSchemaValueCUtlVector<GCAnimBone>(m_ptr, "CAnimKeyData", "m_boneArray", false, value);
}
std::vector<GCAnimUser> GCAnimKeyData::GetUserArray() const {
    CUtlVector<GCAnimUser>* vec = GetSchemaValue<CUtlVector<GCAnimUser>*>(m_ptr, "CAnimKeyData", "m_userArray"); std::vector<GCAnimUser> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCAnimKeyData::SetUserArray(std::vector<GCAnimUser> value) {
    SetSchemaValueCUtlVector<GCAnimUser>(m_ptr, "CAnimKeyData", "m_userArray", false, value);
}
std::vector<CBufferString> GCAnimKeyData::GetMorphArray() const {
    CUtlVector<CBufferString>* vec = GetSchemaValue<CUtlVector<CBufferString>*>(m_ptr, "CAnimKeyData", "m_morphArray"); std::vector<CBufferString> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCAnimKeyData::SetMorphArray(std::vector<CBufferString> value) {
    SetSchemaValueCUtlVector<CBufferString>(m_ptr, "CAnimKeyData", "m_morphArray", false, value);
}
int32_t GCAnimKeyData::GetChannelElements() const {
    return GetSchemaValue<int32_t>(m_ptr, "CAnimKeyData", "m_nChannelElements");
}
void GCAnimKeyData::SetChannelElements(int32_t value) {
    SetSchemaValue(m_ptr, "CAnimKeyData", "m_nChannelElements", false, value);
}
std::vector<GCAnimDataChannelDesc> GCAnimKeyData::GetDataChannelArray() const {
    CUtlVector<GCAnimDataChannelDesc>* vec = GetSchemaValue<CUtlVector<GCAnimDataChannelDesc>*>(m_ptr, "CAnimKeyData", "m_dataChannelArray"); std::vector<GCAnimDataChannelDesc> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCAnimKeyData::SetDataChannelArray(std::vector<GCAnimDataChannelDesc> value) {
    SetSchemaValueCUtlVector<GCAnimDataChannelDesc>(m_ptr, "CAnimKeyData", "m_dataChannelArray", false, value);
}
std::string GCAnimKeyData::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCAnimKeyData::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCAnimKeyData(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCAnimKeyData>("CAnimKeyData")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Name", &GCAnimKeyData::GetName, &GCAnimKeyData::SetName)
        .addProperty("BoneArray", &GCAnimKeyData::GetBoneArray, &GCAnimKeyData::SetBoneArray)
        .addProperty("UserArray", &GCAnimKeyData::GetUserArray, &GCAnimKeyData::SetUserArray)
        .addProperty("MorphArray", &GCAnimKeyData::GetMorphArray, &GCAnimKeyData::SetMorphArray)
        .addProperty("ChannelElements", &GCAnimKeyData::GetChannelElements, &GCAnimKeyData::SetChannelElements)
        .addProperty("DataChannelArray", &GCAnimKeyData::GetDataChannelArray, &GCAnimKeyData::SetDataChannelArray)
        .addFunction("ToPtr", &GCAnimKeyData::ToPtr)
        .addFunction("IsValid", &GCAnimKeyData::IsValid)
        .endClass();
}
GEventPreDataUpdate_t::GEventPreDataUpdate_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GEventPreDataUpdate_t::GEventPreDataUpdate_t(void *ptr) {
    m_ptr = ptr;
}
int32_t GEventPreDataUpdate_t::GetCount() const {
    return GetSchemaValue<int32_t>(m_ptr, "EventPreDataUpdate_t", "m_nCount");
}
void GEventPreDataUpdate_t::SetCount(int32_t value) {
    SetSchemaValue(m_ptr, "EventPreDataUpdate_t", "m_nCount", true, value);
}
std::string GEventPreDataUpdate_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GEventPreDataUpdate_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassEventPreDataUpdate_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GEventPreDataUpdate_t>("EventPreDataUpdate_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Count", &GEventPreDataUpdate_t::GetCount, &GEventPreDataUpdate_t::SetCount)
        .addFunction("ToPtr", &GEventPreDataUpdate_t::ToPtr)
        .addFunction("IsValid", &GEventPreDataUpdate_t::IsValid)
        .endClass();
}
GWorld_t::GWorld_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GWorld_t::GWorld_t(void *ptr) {
    m_ptr = ptr;
}
GWorldBuilderParams_t GWorld_t::GetBuilderParams() const {
    GWorldBuilderParams_t value(GetSchemaPtr(m_ptr, "World_t", "m_builderParams"));
    return value;
}
void GWorld_t::SetBuilderParams(GWorldBuilderParams_t value) {
    SetSchemaValue(m_ptr, "World_t", "m_builderParams", true, value);
}
std::vector<GNodeData_t> GWorld_t::GetWorldNodes() const {
    CUtlVector<GNodeData_t>* vec = GetSchemaValue<CUtlVector<GNodeData_t>*>(m_ptr, "World_t", "m_worldNodes"); std::vector<GNodeData_t> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GWorld_t::SetWorldNodes(std::vector<GNodeData_t> value) {
    SetSchemaValueCUtlVector<GNodeData_t>(m_ptr, "World_t", "m_worldNodes", true, value);
}
GBakedLightingInfo_t GWorld_t::GetWorldLightingInfo() const {
    GBakedLightingInfo_t value(GetSchemaPtr(m_ptr, "World_t", "m_worldLightingInfo"));
    return value;
}
void GWorld_t::SetWorldLightingInfo(GBakedLightingInfo_t value) {
    SetSchemaValue(m_ptr, "World_t", "m_worldLightingInfo", true, value);
}
std::string GWorld_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GWorld_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassWorld_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GWorld_t>("World_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("BuilderParams", &GWorld_t::GetBuilderParams, &GWorld_t::SetBuilderParams)
        .addProperty("WorldNodes", &GWorld_t::GetWorldNodes, &GWorld_t::SetWorldNodes)
        .addProperty("WorldLightingInfo", &GWorld_t::GetWorldLightingInfo, &GWorld_t::SetWorldLightingInfo)
        .addFunction("ToPtr", &GWorld_t::ToPtr)
        .addFunction("IsValid", &GWorld_t::IsValid)
        .endClass();
}
GCVectorAnimParameter::GCVectorAnimParameter(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCVectorAnimParameter::GCVectorAnimParameter(void *ptr) {
    m_ptr = ptr;
}
Vector GCVectorAnimParameter::GetDefaultValue() const {
    return GetSchemaValue<Vector>(m_ptr, "CVectorAnimParameter", "m_defaultValue");
}
void GCVectorAnimParameter::SetDefaultValue(Vector value) {
    SetSchemaValue(m_ptr, "CVectorAnimParameter", "m_defaultValue", false, value);
}
bool GCVectorAnimParameter::GetInterpolate() const {
    return GetSchemaValue<bool>(m_ptr, "CVectorAnimParameter", "m_bInterpolate");
}
void GCVectorAnimParameter::SetInterpolate(bool value) {
    SetSchemaValue(m_ptr, "CVectorAnimParameter", "m_bInterpolate", false, value);
}
std::string GCVectorAnimParameter::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCVectorAnimParameter::IsValid() {
    return (m_ptr != nullptr);
}
GCConcreteAnimParameter GCVectorAnimParameter::GetParent() const {
    GCConcreteAnimParameter value(m_ptr);
    return value;
}
void GCVectorAnimParameter::SetParent(GCConcreteAnimParameter value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCVectorAnimParameter(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCVectorAnimParameter>("CVectorAnimParameter")
        .addConstructor<void (*)(std::string)>()
        .addProperty("DefaultValue", &GCVectorAnimParameter::GetDefaultValue, &GCVectorAnimParameter::SetDefaultValue)
        .addProperty("Interpolate", &GCVectorAnimParameter::GetInterpolate, &GCVectorAnimParameter::SetInterpolate)
        .addProperty("Parent", &GCVectorAnimParameter::GetParent, &GCVectorAnimParameter::SetParent)
        .addFunction("ToPtr", &GCVectorAnimParameter::ToPtr)
        .addFunction("IsValid", &GCVectorAnimParameter::IsValid)
        .endClass();
}
GCNmControlParameterBoolNode::GCNmControlParameterBoolNode(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCNmControlParameterBoolNode::GCNmControlParameterBoolNode(void *ptr) {
    m_ptr = ptr;
}
std::string GCNmControlParameterBoolNode::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCNmControlParameterBoolNode::IsValid() {
    return (m_ptr != nullptr);
}
GCNmBoolValueNode GCNmControlParameterBoolNode::GetParent() const {
    GCNmBoolValueNode value(m_ptr);
    return value;
}
void GCNmControlParameterBoolNode::SetParent(GCNmBoolValueNode value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCNmControlParameterBoolNode(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCNmControlParameterBoolNode>("CNmControlParameterBoolNode")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCNmControlParameterBoolNode::GetParent, &GCNmControlParameterBoolNode::SetParent)
        .addFunction("ToPtr", &GCNmControlParameterBoolNode::ToPtr)
        .addFunction("IsValid", &GCNmControlParameterBoolNode::IsValid)
        .endClass();
}
GCStateMachineUpdateNode::GCStateMachineUpdateNode(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCStateMachineUpdateNode::GCStateMachineUpdateNode(void *ptr) {
    m_ptr = ptr;
}
GCAnimStateMachineUpdater GCStateMachineUpdateNode::GetStateMachine() const {
    GCAnimStateMachineUpdater value(GetSchemaPtr(m_ptr, "CStateMachineUpdateNode", "m_stateMachine"));
    return value;
}
void GCStateMachineUpdateNode::SetStateMachine(GCAnimStateMachineUpdater value) {
    SetSchemaValue(m_ptr, "CStateMachineUpdateNode", "m_stateMachine", false, value);
}
std::vector<GCStateNodeStateData> GCStateMachineUpdateNode::GetStateData() const {
    CUtlVector<GCStateNodeStateData>* vec = GetSchemaValue<CUtlVector<GCStateNodeStateData>*>(m_ptr, "CStateMachineUpdateNode", "m_stateData"); std::vector<GCStateNodeStateData> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCStateMachineUpdateNode::SetStateData(std::vector<GCStateNodeStateData> value) {
    SetSchemaValueCUtlVector<GCStateNodeStateData>(m_ptr, "CStateMachineUpdateNode", "m_stateData", false, value);
}
std::vector<GCStateNodeTransitionData> GCStateMachineUpdateNode::GetTransitionData() const {
    CUtlVector<GCStateNodeTransitionData>* vec = GetSchemaValue<CUtlVector<GCStateNodeTransitionData>*>(m_ptr, "CStateMachineUpdateNode", "m_transitionData"); std::vector<GCStateNodeTransitionData> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCStateMachineUpdateNode::SetTransitionData(std::vector<GCStateNodeTransitionData> value) {
    SetSchemaValueCUtlVector<GCStateNodeTransitionData>(m_ptr, "CStateMachineUpdateNode", "m_transitionData", false, value);
}
bool GCStateMachineUpdateNode::GetBlockWaningTags() const {
    return GetSchemaValue<bool>(m_ptr, "CStateMachineUpdateNode", "m_bBlockWaningTags");
}
void GCStateMachineUpdateNode::SetBlockWaningTags(bool value) {
    SetSchemaValue(m_ptr, "CStateMachineUpdateNode", "m_bBlockWaningTags", false, value);
}
bool GCStateMachineUpdateNode::GetLockStateWhenWaning() const {
    return GetSchemaValue<bool>(m_ptr, "CStateMachineUpdateNode", "m_bLockStateWhenWaning");
}
void GCStateMachineUpdateNode::SetLockStateWhenWaning(bool value) {
    SetSchemaValue(m_ptr, "CStateMachineUpdateNode", "m_bLockStateWhenWaning", false, value);
}
std::string GCStateMachineUpdateNode::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCStateMachineUpdateNode::IsValid() {
    return (m_ptr != nullptr);
}
GCAnimUpdateNodeBase GCStateMachineUpdateNode::GetParent() const {
    GCAnimUpdateNodeBase value(m_ptr);
    return value;
}
void GCStateMachineUpdateNode::SetParent(GCAnimUpdateNodeBase value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCStateMachineUpdateNode(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCStateMachineUpdateNode>("CStateMachineUpdateNode")
        .addConstructor<void (*)(std::string)>()
        .addProperty("StateMachine", &GCStateMachineUpdateNode::GetStateMachine, &GCStateMachineUpdateNode::SetStateMachine)
        .addProperty("StateData", &GCStateMachineUpdateNode::GetStateData, &GCStateMachineUpdateNode::SetStateData)
        .addProperty("TransitionData", &GCStateMachineUpdateNode::GetTransitionData, &GCStateMachineUpdateNode::SetTransitionData)
        .addProperty("BlockWaningTags", &GCStateMachineUpdateNode::GetBlockWaningTags, &GCStateMachineUpdateNode::SetBlockWaningTags)
        .addProperty("LockStateWhenWaning", &GCStateMachineUpdateNode::GetLockStateWhenWaning, &GCStateMachineUpdateNode::SetLockStateWhenWaning)
        .addProperty("Parent", &GCStateMachineUpdateNode::GetParent, &GCStateMachineUpdateNode::SetParent)
        .addFunction("ToPtr", &GCStateMachineUpdateNode::ToPtr)
        .addFunction("IsValid", &GCStateMachineUpdateNode::IsValid)
        .endClass();
}
GCHitBoxSet::GCHitBoxSet(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCHitBoxSet::GCHitBoxSet(void *ptr) {
    m_ptr = ptr;
}
std::string GCHitBoxSet::GetName() const {
    return GetSchemaValue<CUtlString>(m_ptr, "CHitBoxSet", "m_name").Get();
}
void GCHitBoxSet::SetName(std::string value) {
    SetSchemaValue(m_ptr, "CHitBoxSet", "m_name", false, CUtlString(value.c_str()));
}
uint32_t GCHitBoxSet::GetNameHash() const {
    return GetSchemaValue<uint32_t>(m_ptr, "CHitBoxSet", "m_nNameHash");
}
void GCHitBoxSet::SetNameHash(uint32_t value) {
    SetSchemaValue(m_ptr, "CHitBoxSet", "m_nNameHash", false, value);
}
std::vector<GCHitBox> GCHitBoxSet::GetHitBoxes() const {
    CUtlVector<GCHitBox>* vec = GetSchemaValue<CUtlVector<GCHitBox>*>(m_ptr, "CHitBoxSet", "m_HitBoxes"); std::vector<GCHitBox> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCHitBoxSet::SetHitBoxes(std::vector<GCHitBox> value) {
    SetSchemaValueCUtlVector<GCHitBox>(m_ptr, "CHitBoxSet", "m_HitBoxes", false, value);
}
std::string GCHitBoxSet::GetSourceFilename() const {
    return GetSchemaValue<CUtlString>(m_ptr, "CHitBoxSet", "m_SourceFilename").Get();
}
void GCHitBoxSet::SetSourceFilename(std::string value) {
    SetSchemaValue(m_ptr, "CHitBoxSet", "m_SourceFilename", false, CUtlString(value.c_str()));
}
std::string GCHitBoxSet::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCHitBoxSet::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCHitBoxSet(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCHitBoxSet>("CHitBoxSet")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Name", &GCHitBoxSet::GetName, &GCHitBoxSet::SetName)
        .addProperty("NameHash", &GCHitBoxSet::GetNameHash, &GCHitBoxSet::SetNameHash)
        .addProperty("HitBoxes", &GCHitBoxSet::GetHitBoxes, &GCHitBoxSet::SetHitBoxes)
        .addProperty("SourceFilename", &GCHitBoxSet::GetSourceFilename, &GCHitBoxSet::SetSourceFilename)
        .addFunction("ToPtr", &GCHitBoxSet::ToPtr)
        .addFunction("IsValid", &GCHitBoxSet::IsValid)
        .endClass();
}
GCExampleSchemaVData_PolymorphicDerivedB::GCExampleSchemaVData_PolymorphicDerivedB(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCExampleSchemaVData_PolymorphicDerivedB::GCExampleSchemaVData_PolymorphicDerivedB(void *ptr) {
    m_ptr = ptr;
}
int32_t GCExampleSchemaVData_PolymorphicDerivedB::GetDerivedB() const {
    return GetSchemaValue<int32_t>(m_ptr, "CExampleSchemaVData_PolymorphicDerivedB", "m_nDerivedB");
}
void GCExampleSchemaVData_PolymorphicDerivedB::SetDerivedB(int32_t value) {
    SetSchemaValue(m_ptr, "CExampleSchemaVData_PolymorphicDerivedB", "m_nDerivedB", false, value);
}
std::string GCExampleSchemaVData_PolymorphicDerivedB::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCExampleSchemaVData_PolymorphicDerivedB::IsValid() {
    return (m_ptr != nullptr);
}
GCExampleSchemaVData_PolymorphicBase GCExampleSchemaVData_PolymorphicDerivedB::GetParent() const {
    GCExampleSchemaVData_PolymorphicBase value(m_ptr);
    return value;
}
void GCExampleSchemaVData_PolymorphicDerivedB::SetParent(GCExampleSchemaVData_PolymorphicBase value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCExampleSchemaVData_PolymorphicDerivedB(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCExampleSchemaVData_PolymorphicDerivedB>("CExampleSchemaVData_PolymorphicDerivedB")
        .addConstructor<void (*)(std::string)>()
        .addProperty("DerivedB", &GCExampleSchemaVData_PolymorphicDerivedB::GetDerivedB, &GCExampleSchemaVData_PolymorphicDerivedB::SetDerivedB)
        .addProperty("Parent", &GCExampleSchemaVData_PolymorphicDerivedB::GetParent, &GCExampleSchemaVData_PolymorphicDerivedB::SetParent)
        .addFunction("ToPtr", &GCExampleSchemaVData_PolymorphicDerivedB::ToPtr)
        .addFunction("IsValid", &GCExampleSchemaVData_PolymorphicDerivedB::IsValid)
        .endClass();
}
GFeSimdTri_t::GFeSimdTri_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GFeSimdTri_t::GFeSimdTri_t(void *ptr) {
    m_ptr = ptr;
}
float GFeSimdTri_t::GetW1() const {
    return GetSchemaValue<float>(m_ptr, "FeSimdTri_t", "w1");
}
void GFeSimdTri_t::SetW1(float value) {
    SetSchemaValue(m_ptr, "FeSimdTri_t", "w1", true, value);
}
float GFeSimdTri_t::GetW2() const {
    return GetSchemaValue<float>(m_ptr, "FeSimdTri_t", "w2");
}
void GFeSimdTri_t::SetW2(float value) {
    SetSchemaValue(m_ptr, "FeSimdTri_t", "w2", true, value);
}
float GFeSimdTri_t::Get1x() const {
    return GetSchemaValue<float>(m_ptr, "FeSimdTri_t", "v1x");
}
void GFeSimdTri_t::Set1x(float value) {
    SetSchemaValue(m_ptr, "FeSimdTri_t", "v1x", true, value);
}
std::string GFeSimdTri_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GFeSimdTri_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassFeSimdTri_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GFeSimdTri_t>("FeSimdTri_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("W1", &GFeSimdTri_t::GetW1, &GFeSimdTri_t::SetW1)
        .addProperty("W2", &GFeSimdTri_t::GetW2, &GFeSimdTri_t::SetW2)
        .addProperty("1x", &GFeSimdTri_t::Get1x, &GFeSimdTri_t::Set1x)
        .addFunction("ToPtr", &GFeSimdTri_t::ToPtr)
        .addFunction("IsValid", &GFeSimdTri_t::IsValid)
        .endClass();
}
GPostProcessingResource_t::GPostProcessingResource_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GPostProcessingResource_t::GPostProcessingResource_t(void *ptr) {
    m_ptr = ptr;
}
bool GPostProcessingResource_t::GetHasTonemapParams() const {
    return GetSchemaValue<bool>(m_ptr, "PostProcessingResource_t", "m_bHasTonemapParams");
}
void GPostProcessingResource_t::SetHasTonemapParams(bool value) {
    SetSchemaValue(m_ptr, "PostProcessingResource_t", "m_bHasTonemapParams", true, value);
}
GPostProcessingTonemapParameters_t GPostProcessingResource_t::GetToneMapParams() const {
    GPostProcessingTonemapParameters_t value(GetSchemaPtr(m_ptr, "PostProcessingResource_t", "m_toneMapParams"));
    return value;
}
void GPostProcessingResource_t::SetToneMapParams(GPostProcessingTonemapParameters_t value) {
    SetSchemaValue(m_ptr, "PostProcessingResource_t", "m_toneMapParams", true, value);
}
bool GPostProcessingResource_t::GetHasBloomParams() const {
    return GetSchemaValue<bool>(m_ptr, "PostProcessingResource_t", "m_bHasBloomParams");
}
void GPostProcessingResource_t::SetHasBloomParams(bool value) {
    SetSchemaValue(m_ptr, "PostProcessingResource_t", "m_bHasBloomParams", true, value);
}
GPostProcessingBloomParameters_t GPostProcessingResource_t::GetBloomParams() const {
    GPostProcessingBloomParameters_t value(GetSchemaPtr(m_ptr, "PostProcessingResource_t", "m_bloomParams"));
    return value;
}
void GPostProcessingResource_t::SetBloomParams(GPostProcessingBloomParameters_t value) {
    SetSchemaValue(m_ptr, "PostProcessingResource_t", "m_bloomParams", true, value);
}
bool GPostProcessingResource_t::GetHasVignetteParams() const {
    return GetSchemaValue<bool>(m_ptr, "PostProcessingResource_t", "m_bHasVignetteParams");
}
void GPostProcessingResource_t::SetHasVignetteParams(bool value) {
    SetSchemaValue(m_ptr, "PostProcessingResource_t", "m_bHasVignetteParams", true, value);
}
GPostProcessingVignetteParameters_t GPostProcessingResource_t::GetVignetteParams() const {
    GPostProcessingVignetteParameters_t value(GetSchemaPtr(m_ptr, "PostProcessingResource_t", "m_vignetteParams"));
    return value;
}
void GPostProcessingResource_t::SetVignetteParams(GPostProcessingVignetteParameters_t value) {
    SetSchemaValue(m_ptr, "PostProcessingResource_t", "m_vignetteParams", true, value);
}
bool GPostProcessingResource_t::GetHasLocalContrastParams() const {
    return GetSchemaValue<bool>(m_ptr, "PostProcessingResource_t", "m_bHasLocalContrastParams");
}
void GPostProcessingResource_t::SetHasLocalContrastParams(bool value) {
    SetSchemaValue(m_ptr, "PostProcessingResource_t", "m_bHasLocalContrastParams", true, value);
}
GPostProcessingLocalContrastParameters_t GPostProcessingResource_t::GetLocalConstrastParams() const {
    GPostProcessingLocalContrastParameters_t value(GetSchemaPtr(m_ptr, "PostProcessingResource_t", "m_localConstrastParams"));
    return value;
}
void GPostProcessingResource_t::SetLocalConstrastParams(GPostProcessingLocalContrastParameters_t value) {
    SetSchemaValue(m_ptr, "PostProcessingResource_t", "m_localConstrastParams", true, value);
}
int32_t GPostProcessingResource_t::GetColorCorrectionVolumeDim() const {
    return GetSchemaValue<int32_t>(m_ptr, "PostProcessingResource_t", "m_nColorCorrectionVolumeDim");
}
void GPostProcessingResource_t::SetColorCorrectionVolumeDim(int32_t value) {
    SetSchemaValue(m_ptr, "PostProcessingResource_t", "m_nColorCorrectionVolumeDim", true, value);
}
bool GPostProcessingResource_t::GetHasColorCorrection() const {
    return GetSchemaValue<bool>(m_ptr, "PostProcessingResource_t", "m_bHasColorCorrection");
}
void GPostProcessingResource_t::SetHasColorCorrection(bool value) {
    SetSchemaValue(m_ptr, "PostProcessingResource_t", "m_bHasColorCorrection", true, value);
}
std::string GPostProcessingResource_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GPostProcessingResource_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassPostProcessingResource_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GPostProcessingResource_t>("PostProcessingResource_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("HasTonemapParams", &GPostProcessingResource_t::GetHasTonemapParams, &GPostProcessingResource_t::SetHasTonemapParams)
        .addProperty("ToneMapParams", &GPostProcessingResource_t::GetToneMapParams, &GPostProcessingResource_t::SetToneMapParams)
        .addProperty("HasBloomParams", &GPostProcessingResource_t::GetHasBloomParams, &GPostProcessingResource_t::SetHasBloomParams)
        .addProperty("BloomParams", &GPostProcessingResource_t::GetBloomParams, &GPostProcessingResource_t::SetBloomParams)
        .addProperty("HasVignetteParams", &GPostProcessingResource_t::GetHasVignetteParams, &GPostProcessingResource_t::SetHasVignetteParams)
        .addProperty("VignetteParams", &GPostProcessingResource_t::GetVignetteParams, &GPostProcessingResource_t::SetVignetteParams)
        .addProperty("HasLocalContrastParams", &GPostProcessingResource_t::GetHasLocalContrastParams, &GPostProcessingResource_t::SetHasLocalContrastParams)
        .addProperty("LocalConstrastParams", &GPostProcessingResource_t::GetLocalConstrastParams, &GPostProcessingResource_t::SetLocalConstrastParams)
        .addProperty("ColorCorrectionVolumeDim", &GPostProcessingResource_t::GetColorCorrectionVolumeDim, &GPostProcessingResource_t::SetColorCorrectionVolumeDim)
        .addProperty("HasColorCorrection", &GPostProcessingResource_t::GetHasColorCorrection, &GPostProcessingResource_t::SetHasColorCorrection)
        .addFunction("ToPtr", &GPostProcessingResource_t::ToPtr)
        .addFunction("IsValid", &GPostProcessingResource_t::IsValid)
        .endClass();
}
GCNmStateNode::GCNmStateNode(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCNmStateNode::GCNmStateNode(void *ptr) {
    m_ptr = ptr;
}
int16_t GCNmStateNode::GetChildNodeIdx() const {
    return GetSchemaValue<int16_t>(m_ptr, "CNmStateNode", "m_nChildNodeIdx");
}
void GCNmStateNode::SetChildNodeIdx(int16_t value) {
    SetSchemaValue(m_ptr, "CNmStateNode", "m_nChildNodeIdx", false, value);
}
int16_t GCNmStateNode::GetLayerWeightNodeIdx() const {
    return GetSchemaValue<int16_t>(m_ptr, "CNmStateNode", "m_nLayerWeightNodeIdx");
}
void GCNmStateNode::SetLayerWeightNodeIdx(int16_t value) {
    SetSchemaValue(m_ptr, "CNmStateNode", "m_nLayerWeightNodeIdx", false, value);
}
int16_t GCNmStateNode::GetLayerRootMotionWeightNodeIdx() const {
    return GetSchemaValue<int16_t>(m_ptr, "CNmStateNode", "m_nLayerRootMotionWeightNodeIdx");
}
void GCNmStateNode::SetLayerRootMotionWeightNodeIdx(int16_t value) {
    SetSchemaValue(m_ptr, "CNmStateNode", "m_nLayerRootMotionWeightNodeIdx", false, value);
}
int16_t GCNmStateNode::GetLayerBoneMaskNodeIdx() const {
    return GetSchemaValue<int16_t>(m_ptr, "CNmStateNode", "m_nLayerBoneMaskNodeIdx");
}
void GCNmStateNode::SetLayerBoneMaskNodeIdx(int16_t value) {
    SetSchemaValue(m_ptr, "CNmStateNode", "m_nLayerBoneMaskNodeIdx", false, value);
}
bool GCNmStateNode::GetIsOffState() const {
    return GetSchemaValue<bool>(m_ptr, "CNmStateNode", "m_bIsOffState");
}
void GCNmStateNode::SetIsOffState(bool value) {
    SetSchemaValue(m_ptr, "CNmStateNode", "m_bIsOffState", false, value);
}
std::string GCNmStateNode::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCNmStateNode::IsValid() {
    return (m_ptr != nullptr);
}
GCNmPoseNode GCNmStateNode::GetParent() const {
    GCNmPoseNode value(m_ptr);
    return value;
}
void GCNmStateNode::SetParent(GCNmPoseNode value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCNmStateNode(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCNmStateNode>("CNmStateNode")
        .addConstructor<void (*)(std::string)>()
        .addProperty("ChildNodeIdx", &GCNmStateNode::GetChildNodeIdx, &GCNmStateNode::SetChildNodeIdx)
        .addProperty("LayerWeightNodeIdx", &GCNmStateNode::GetLayerWeightNodeIdx, &GCNmStateNode::SetLayerWeightNodeIdx)
        .addProperty("LayerRootMotionWeightNodeIdx", &GCNmStateNode::GetLayerRootMotionWeightNodeIdx, &GCNmStateNode::SetLayerRootMotionWeightNodeIdx)
        .addProperty("LayerBoneMaskNodeIdx", &GCNmStateNode::GetLayerBoneMaskNodeIdx, &GCNmStateNode::SetLayerBoneMaskNodeIdx)
        .addProperty("IsOffState", &GCNmStateNode::GetIsOffState, &GCNmStateNode::SetIsOffState)
        .addProperty("Parent", &GCNmStateNode::GetParent, &GCNmStateNode::SetParent)
        .addFunction("ToPtr", &GCNmStateNode::ToPtr)
        .addFunction("IsValid", &GCNmStateNode::IsValid)
        .endClass();
}
GNodeData_t::GNodeData_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GNodeData_t::GNodeData_t(void *ptr) {
    m_ptr = ptr;
}
int32_t GNodeData_t::GetParent() const {
    return GetSchemaValue<int32_t>(m_ptr, "NodeData_t", "m_nParent");
}
void GNodeData_t::SetParent(int32_t value) {
    SetSchemaValue(m_ptr, "NodeData_t", "m_nParent", true, value);
}
Vector GNodeData_t::GetOrigin() const {
    return GetSchemaValue<Vector>(m_ptr, "NodeData_t", "m_vOrigin");
}
void GNodeData_t::SetOrigin(Vector value) {
    SetSchemaValue(m_ptr, "NodeData_t", "m_vOrigin", true, value);
}
Vector GNodeData_t::GetMinBounds() const {
    return GetSchemaValue<Vector>(m_ptr, "NodeData_t", "m_vMinBounds");
}
void GNodeData_t::SetMinBounds(Vector value) {
    SetSchemaValue(m_ptr, "NodeData_t", "m_vMinBounds", true, value);
}
Vector GNodeData_t::GetMaxBounds() const {
    return GetSchemaValue<Vector>(m_ptr, "NodeData_t", "m_vMaxBounds");
}
void GNodeData_t::SetMaxBounds(Vector value) {
    SetSchemaValue(m_ptr, "NodeData_t", "m_vMaxBounds", true, value);
}
float GNodeData_t::GetMinimumDistance() const {
    return GetSchemaValue<float>(m_ptr, "NodeData_t", "m_flMinimumDistance");
}
void GNodeData_t::SetMinimumDistance(float value) {
    SetSchemaValue(m_ptr, "NodeData_t", "m_flMinimumDistance", true, value);
}
std::vector<int32> GNodeData_t::GetChildNodeIndices() const {
    CUtlVector<int32>* vec = GetSchemaValue<CUtlVector<int32>*>(m_ptr, "NodeData_t", "m_ChildNodeIndices"); std::vector<int32> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GNodeData_t::SetChildNodeIndices(std::vector<int32> value) {
    SetSchemaValueCUtlVector<int32>(m_ptr, "NodeData_t", "m_ChildNodeIndices", true, value);
}
std::string GNodeData_t::GetWorldNodePrefix() const {
    return GetSchemaValue<CUtlString>(m_ptr, "NodeData_t", "m_worldNodePrefix").Get();
}
void GNodeData_t::SetWorldNodePrefix(std::string value) {
    SetSchemaValue(m_ptr, "NodeData_t", "m_worldNodePrefix", true, CUtlString(value.c_str()));
}
std::string GNodeData_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GNodeData_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassNodeData_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GNodeData_t>("NodeData_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GNodeData_t::GetParent, &GNodeData_t::SetParent)
        .addProperty("Origin", &GNodeData_t::GetOrigin, &GNodeData_t::SetOrigin)
        .addProperty("MinBounds", &GNodeData_t::GetMinBounds, &GNodeData_t::SetMinBounds)
        .addProperty("MaxBounds", &GNodeData_t::GetMaxBounds, &GNodeData_t::SetMaxBounds)
        .addProperty("MinimumDistance", &GNodeData_t::GetMinimumDistance, &GNodeData_t::SetMinimumDistance)
        .addProperty("ChildNodeIndices", &GNodeData_t::GetChildNodeIndices, &GNodeData_t::SetChildNodeIndices)
        .addProperty("WorldNodePrefix", &GNodeData_t::GetWorldNodePrefix, &GNodeData_t::SetWorldNodePrefix)
        .addFunction("ToPtr", &GNodeData_t::ToPtr)
        .addFunction("IsValid", &GNodeData_t::IsValid)
        .endClass();
}
GCTaskStatusAnimTag::GCTaskStatusAnimTag(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCTaskStatusAnimTag::GCTaskStatusAnimTag(void *ptr) {
    m_ptr = ptr;
}
std::string GCTaskStatusAnimTag::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCTaskStatusAnimTag::IsValid() {
    return (m_ptr != nullptr);
}
GCAnimTagBase GCTaskStatusAnimTag::GetParent() const {
    GCAnimTagBase value(m_ptr);
    return value;
}
void GCTaskStatusAnimTag::SetParent(GCAnimTagBase value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCTaskStatusAnimTag(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCTaskStatusAnimTag>("CTaskStatusAnimTag")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCTaskStatusAnimTag::GetParent, &GCTaskStatusAnimTag::SetParent)
        .addFunction("ToPtr", &GCTaskStatusAnimTag::ToPtr)
        .addFunction("IsValid", &GCTaskStatusAnimTag::IsValid)
        .endClass();
}
GCMaterialDrawDescriptor::GCMaterialDrawDescriptor(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCMaterialDrawDescriptor::GCMaterialDrawDescriptor(void *ptr) {
    m_ptr = ptr;
}
float GCMaterialDrawDescriptor::GetUvDensity() const {
    return GetSchemaValue<float>(m_ptr, "CMaterialDrawDescriptor", "m_flUvDensity");
}
void GCMaterialDrawDescriptor::SetUvDensity(float value) {
    SetSchemaValue(m_ptr, "CMaterialDrawDescriptor", "m_flUvDensity", false, value);
}
Vector GCMaterialDrawDescriptor::GetTintColor() const {
    return GetSchemaValue<Vector>(m_ptr, "CMaterialDrawDescriptor", "m_vTintColor");
}
void GCMaterialDrawDescriptor::SetTintColor(Vector value) {
    SetSchemaValue(m_ptr, "CMaterialDrawDescriptor", "m_vTintColor", false, value);
}
float GCMaterialDrawDescriptor::GetAlpha() const {
    return GetSchemaValue<float>(m_ptr, "CMaterialDrawDescriptor", "m_flAlpha");
}
void GCMaterialDrawDescriptor::SetAlpha(float value) {
    SetSchemaValue(m_ptr, "CMaterialDrawDescriptor", "m_flAlpha", false, value);
}
uint32_t GCMaterialDrawDescriptor::GetFirstMeshlet() const {
    return GetSchemaValue<uint32_t>(m_ptr, "CMaterialDrawDescriptor", "m_nFirstMeshlet");
}
void GCMaterialDrawDescriptor::SetFirstMeshlet(uint32_t value) {
    SetSchemaValue(m_ptr, "CMaterialDrawDescriptor", "m_nFirstMeshlet", false, value);
}
uint16_t GCMaterialDrawDescriptor::GetNumMeshlets() const {
    return GetSchemaValue<uint16_t>(m_ptr, "CMaterialDrawDescriptor", "m_nNumMeshlets");
}
void GCMaterialDrawDescriptor::SetNumMeshlets(uint16_t value) {
    SetSchemaValue(m_ptr, "CMaterialDrawDescriptor", "m_nNumMeshlets", false, value);
}
uint64_t GCMaterialDrawDescriptor::GetPrimitiveType() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CMaterialDrawDescriptor", "m_nPrimitiveType");
}
void GCMaterialDrawDescriptor::SetPrimitiveType(uint64_t value) {
    SetSchemaValue(m_ptr, "CMaterialDrawDescriptor", "m_nPrimitiveType", false, value);
}
int32_t GCMaterialDrawDescriptor::GetBaseVertex() const {
    return GetSchemaValue<int32_t>(m_ptr, "CMaterialDrawDescriptor", "m_nBaseVertex");
}
void GCMaterialDrawDescriptor::SetBaseVertex(int32_t value) {
    SetSchemaValue(m_ptr, "CMaterialDrawDescriptor", "m_nBaseVertex", false, value);
}
int32_t GCMaterialDrawDescriptor::GetVertexCount() const {
    return GetSchemaValue<int32_t>(m_ptr, "CMaterialDrawDescriptor", "m_nVertexCount");
}
void GCMaterialDrawDescriptor::SetVertexCount(int32_t value) {
    SetSchemaValue(m_ptr, "CMaterialDrawDescriptor", "m_nVertexCount", false, value);
}
int32_t GCMaterialDrawDescriptor::GetStartIndex() const {
    return GetSchemaValue<int32_t>(m_ptr, "CMaterialDrawDescriptor", "m_nStartIndex");
}
void GCMaterialDrawDescriptor::SetStartIndex(int32_t value) {
    SetSchemaValue(m_ptr, "CMaterialDrawDescriptor", "m_nStartIndex", false, value);
}
int32_t GCMaterialDrawDescriptor::GetIndexCount() const {
    return GetSchemaValue<int32_t>(m_ptr, "CMaterialDrawDescriptor", "m_nIndexCount");
}
void GCMaterialDrawDescriptor::SetIndexCount(int32_t value) {
    SetSchemaValue(m_ptr, "CMaterialDrawDescriptor", "m_nIndexCount", false, value);
}
GCRenderBufferBinding GCMaterialDrawDescriptor::GetIndexBuffer() const {
    GCRenderBufferBinding value(GetSchemaPtr(m_ptr, "CMaterialDrawDescriptor", "m_indexBuffer"));
    return value;
}
void GCMaterialDrawDescriptor::SetIndexBuffer(GCRenderBufferBinding value) {
    SetSchemaValue(m_ptr, "CMaterialDrawDescriptor", "m_indexBuffer", false, value);
}
std::string GCMaterialDrawDescriptor::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCMaterialDrawDescriptor::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCMaterialDrawDescriptor(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCMaterialDrawDescriptor>("CMaterialDrawDescriptor")
        .addConstructor<void (*)(std::string)>()
        .addProperty("UvDensity", &GCMaterialDrawDescriptor::GetUvDensity, &GCMaterialDrawDescriptor::SetUvDensity)
        .addProperty("TintColor", &GCMaterialDrawDescriptor::GetTintColor, &GCMaterialDrawDescriptor::SetTintColor)
        .addProperty("Alpha", &GCMaterialDrawDescriptor::GetAlpha, &GCMaterialDrawDescriptor::SetAlpha)
        .addProperty("FirstMeshlet", &GCMaterialDrawDescriptor::GetFirstMeshlet, &GCMaterialDrawDescriptor::SetFirstMeshlet)
        .addProperty("NumMeshlets", &GCMaterialDrawDescriptor::GetNumMeshlets, &GCMaterialDrawDescriptor::SetNumMeshlets)
        .addProperty("PrimitiveType", &GCMaterialDrawDescriptor::GetPrimitiveType, &GCMaterialDrawDescriptor::SetPrimitiveType)
        .addProperty("BaseVertex", &GCMaterialDrawDescriptor::GetBaseVertex, &GCMaterialDrawDescriptor::SetBaseVertex)
        .addProperty("VertexCount", &GCMaterialDrawDescriptor::GetVertexCount, &GCMaterialDrawDescriptor::SetVertexCount)
        .addProperty("StartIndex", &GCMaterialDrawDescriptor::GetStartIndex, &GCMaterialDrawDescriptor::SetStartIndex)
        .addProperty("IndexCount", &GCMaterialDrawDescriptor::GetIndexCount, &GCMaterialDrawDescriptor::SetIndexCount)
        .addProperty("IndexBuffer", &GCMaterialDrawDescriptor::GetIndexBuffer, &GCMaterialDrawDescriptor::SetIndexBuffer)
        .addFunction("ToPtr", &GCMaterialDrawDescriptor::ToPtr)
        .addFunction("IsValid", &GCMaterialDrawDescriptor::IsValid)
        .endClass();
}
GEventServerProcessNetworking_t::GEventServerProcessNetworking_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GEventServerProcessNetworking_t::GEventServerProcessNetworking_t(void *ptr) {
    m_ptr = ptr;
}
std::string GEventServerProcessNetworking_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GEventServerProcessNetworking_t::IsValid() {
    return (m_ptr != nullptr);
}
GEventSimulate_t GEventServerProcessNetworking_t::GetParent() const {
    GEventSimulate_t value(m_ptr);
    return value;
}
void GEventServerProcessNetworking_t::SetParent(GEventSimulate_t value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassEventServerProcessNetworking_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GEventServerProcessNetworking_t>("EventServerProcessNetworking_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GEventServerProcessNetworking_t::GetParent, &GEventServerProcessNetworking_t::SetParent)
        .addFunction("ToPtr", &GEventServerProcessNetworking_t::ToPtr)
        .addFunction("IsValid", &GEventServerProcessNetworking_t::IsValid)
        .endClass();
}
GCInterpolatedValue::GCInterpolatedValue(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCInterpolatedValue::GCInterpolatedValue(void *ptr) {
    m_ptr = ptr;
}
float GCInterpolatedValue::GetStartTime() const {
    return GetSchemaValue<float>(m_ptr, "CInterpolatedValue", "m_flStartTime");
}
void GCInterpolatedValue::SetStartTime(float value) {
    SetSchemaValue(m_ptr, "CInterpolatedValue", "m_flStartTime", false, value);
}
float GCInterpolatedValue::GetEndTime() const {
    return GetSchemaValue<float>(m_ptr, "CInterpolatedValue", "m_flEndTime");
}
void GCInterpolatedValue::SetEndTime(float value) {
    SetSchemaValue(m_ptr, "CInterpolatedValue", "m_flEndTime", false, value);
}
float GCInterpolatedValue::GetStartValue() const {
    return GetSchemaValue<float>(m_ptr, "CInterpolatedValue", "m_flStartValue");
}
void GCInterpolatedValue::SetStartValue(float value) {
    SetSchemaValue(m_ptr, "CInterpolatedValue", "m_flStartValue", false, value);
}
float GCInterpolatedValue::GetEndValue() const {
    return GetSchemaValue<float>(m_ptr, "CInterpolatedValue", "m_flEndValue");
}
void GCInterpolatedValue::SetEndValue(float value) {
    SetSchemaValue(m_ptr, "CInterpolatedValue", "m_flEndValue", false, value);
}
int32_t GCInterpolatedValue::GetInterpType() const {
    return GetSchemaValue<int32_t>(m_ptr, "CInterpolatedValue", "m_nInterpType");
}
void GCInterpolatedValue::SetInterpType(int32_t value) {
    SetSchemaValue(m_ptr, "CInterpolatedValue", "m_nInterpType", false, value);
}
std::string GCInterpolatedValue::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCInterpolatedValue::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCInterpolatedValue(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCInterpolatedValue>("CInterpolatedValue")
        .addConstructor<void (*)(std::string)>()
        .addProperty("StartTime", &GCInterpolatedValue::GetStartTime, &GCInterpolatedValue::SetStartTime)
        .addProperty("EndTime", &GCInterpolatedValue::GetEndTime, &GCInterpolatedValue::SetEndTime)
        .addProperty("StartValue", &GCInterpolatedValue::GetStartValue, &GCInterpolatedValue::SetStartValue)
        .addProperty("EndValue", &GCInterpolatedValue::GetEndValue, &GCInterpolatedValue::SetEndValue)
        .addProperty("InterpType", &GCInterpolatedValue::GetInterpType, &GCInterpolatedValue::SetInterpType)
        .addFunction("ToPtr", &GCInterpolatedValue::ToPtr)
        .addFunction("IsValid", &GCInterpolatedValue::IsValid)
        .endClass();
}
GCMotionGraphUpdateNode::GCMotionGraphUpdateNode(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCMotionGraphUpdateNode::GCMotionGraphUpdateNode(void *ptr) {
    m_ptr = ptr;
}
std::string GCMotionGraphUpdateNode::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCMotionGraphUpdateNode::IsValid() {
    return (m_ptr != nullptr);
}
GCLeafUpdateNode GCMotionGraphUpdateNode::GetParent() const {
    GCLeafUpdateNode value(m_ptr);
    return value;
}
void GCMotionGraphUpdateNode::SetParent(GCLeafUpdateNode value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCMotionGraphUpdateNode(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCMotionGraphUpdateNode>("CMotionGraphUpdateNode")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCMotionGraphUpdateNode::GetParent, &GCMotionGraphUpdateNode::SetParent)
        .addFunction("ToPtr", &GCMotionGraphUpdateNode::ToPtr)
        .addFunction("IsValid", &GCMotionGraphUpdateNode::IsValid)
        .endClass();
}
GCLookAtUpdateNode::GCLookAtUpdateNode(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCLookAtUpdateNode::GCLookAtUpdateNode(void *ptr) {
    m_ptr = ptr;
}
GLookAtOpFixedSettings_t GCLookAtUpdateNode::GetOpFixedSettings() const {
    GLookAtOpFixedSettings_t value(GetSchemaPtr(m_ptr, "CLookAtUpdateNode", "m_opFixedSettings"));
    return value;
}
void GCLookAtUpdateNode::SetOpFixedSettings(GLookAtOpFixedSettings_t value) {
    SetSchemaValue(m_ptr, "CLookAtUpdateNode", "m_opFixedSettings", false, value);
}
uint64_t GCLookAtUpdateNode::GetTarget() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CLookAtUpdateNode", "m_target");
}
void GCLookAtUpdateNode::SetTarget(uint64_t value) {
    SetSchemaValue(m_ptr, "CLookAtUpdateNode", "m_target", false, value);
}
GCAnimParamHandle GCLookAtUpdateNode::GetParamIndex() const {
    GCAnimParamHandle value(GetSchemaPtr(m_ptr, "CLookAtUpdateNode", "m_paramIndex"));
    return value;
}
void GCLookAtUpdateNode::SetParamIndex(GCAnimParamHandle value) {
    SetSchemaValue(m_ptr, "CLookAtUpdateNode", "m_paramIndex", false, value);
}
GCAnimParamHandle GCLookAtUpdateNode::GetWeightParamIndex() const {
    GCAnimParamHandle value(GetSchemaPtr(m_ptr, "CLookAtUpdateNode", "m_weightParamIndex"));
    return value;
}
void GCLookAtUpdateNode::SetWeightParamIndex(GCAnimParamHandle value) {
    SetSchemaValue(m_ptr, "CLookAtUpdateNode", "m_weightParamIndex", false, value);
}
bool GCLookAtUpdateNode::GetResetChild() const {
    return GetSchemaValue<bool>(m_ptr, "CLookAtUpdateNode", "m_bResetChild");
}
void GCLookAtUpdateNode::SetResetChild(bool value) {
    SetSchemaValue(m_ptr, "CLookAtUpdateNode", "m_bResetChild", false, value);
}
bool GCLookAtUpdateNode::GetLockWhenWaning() const {
    return GetSchemaValue<bool>(m_ptr, "CLookAtUpdateNode", "m_bLockWhenWaning");
}
void GCLookAtUpdateNode::SetLockWhenWaning(bool value) {
    SetSchemaValue(m_ptr, "CLookAtUpdateNode", "m_bLockWhenWaning", false, value);
}
std::string GCLookAtUpdateNode::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCLookAtUpdateNode::IsValid() {
    return (m_ptr != nullptr);
}
GCUnaryUpdateNode GCLookAtUpdateNode::GetParent() const {
    GCUnaryUpdateNode value(m_ptr);
    return value;
}
void GCLookAtUpdateNode::SetParent(GCUnaryUpdateNode value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCLookAtUpdateNode(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCLookAtUpdateNode>("CLookAtUpdateNode")
        .addConstructor<void (*)(std::string)>()
        .addProperty("OpFixedSettings", &GCLookAtUpdateNode::GetOpFixedSettings, &GCLookAtUpdateNode::SetOpFixedSettings)
        .addProperty("Target", &GCLookAtUpdateNode::GetTarget, &GCLookAtUpdateNode::SetTarget)
        .addProperty("ParamIndex", &GCLookAtUpdateNode::GetParamIndex, &GCLookAtUpdateNode::SetParamIndex)
        .addProperty("WeightParamIndex", &GCLookAtUpdateNode::GetWeightParamIndex, &GCLookAtUpdateNode::SetWeightParamIndex)
        .addProperty("ResetChild", &GCLookAtUpdateNode::GetResetChild, &GCLookAtUpdateNode::SetResetChild)
        .addProperty("LockWhenWaning", &GCLookAtUpdateNode::GetLockWhenWaning, &GCLookAtUpdateNode::SetLockWhenWaning)
        .addProperty("Parent", &GCLookAtUpdateNode::GetParent, &GCLookAtUpdateNode::SetParent)
        .addFunction("ToPtr", &GCLookAtUpdateNode::ToPtr)
        .addFunction("IsValid", &GCLookAtUpdateNode::IsValid)
        .endClass();
}
GCFlexController::GCFlexController(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCFlexController::GCFlexController(void *ptr) {
    m_ptr = ptr;
}
std::string GCFlexController::GetName() const {
    return GetSchemaValue<CUtlString>(m_ptr, "CFlexController", "m_szName").Get();
}
void GCFlexController::SetName(std::string value) {
    SetSchemaValue(m_ptr, "CFlexController", "m_szName", false, CUtlString(value.c_str()));
}
std::string GCFlexController::GetType() const {
    return GetSchemaValue<CUtlString>(m_ptr, "CFlexController", "m_szType").Get();
}
void GCFlexController::SetType(std::string value) {
    SetSchemaValue(m_ptr, "CFlexController", "m_szType", false, CUtlString(value.c_str()));
}
float GCFlexController::GetMin() const {
    return GetSchemaValue<float>(m_ptr, "CFlexController", "min");
}
void GCFlexController::SetMin(float value) {
    SetSchemaValue(m_ptr, "CFlexController", "min", false, value);
}
float GCFlexController::GetMax() const {
    return GetSchemaValue<float>(m_ptr, "CFlexController", "max");
}
void GCFlexController::SetMax(float value) {
    SetSchemaValue(m_ptr, "CFlexController", "max", false, value);
}
std::string GCFlexController::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCFlexController::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCFlexController(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCFlexController>("CFlexController")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Name", &GCFlexController::GetName, &GCFlexController::SetName)
        .addProperty("Type", &GCFlexController::GetType, &GCFlexController::SetType)
        .addProperty("Min", &GCFlexController::GetMin, &GCFlexController::SetMin)
        .addProperty("Max", &GCFlexController::GetMax, &GCFlexController::SetMax)
        .addFunction("ToPtr", &GCFlexController::ToPtr)
        .addFunction("IsValid", &GCFlexController::IsValid)
        .endClass();
}
GCExampleSchemaVData_PolymorphicDerivedA::GCExampleSchemaVData_PolymorphicDerivedA(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCExampleSchemaVData_PolymorphicDerivedA::GCExampleSchemaVData_PolymorphicDerivedA(void *ptr) {
    m_ptr = ptr;
}
int32_t GCExampleSchemaVData_PolymorphicDerivedA::GetDerivedA() const {
    return GetSchemaValue<int32_t>(m_ptr, "CExampleSchemaVData_PolymorphicDerivedA", "m_nDerivedA");
}
void GCExampleSchemaVData_PolymorphicDerivedA::SetDerivedA(int32_t value) {
    SetSchemaValue(m_ptr, "CExampleSchemaVData_PolymorphicDerivedA", "m_nDerivedA", false, value);
}
std::string GCExampleSchemaVData_PolymorphicDerivedA::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCExampleSchemaVData_PolymorphicDerivedA::IsValid() {
    return (m_ptr != nullptr);
}
GCExampleSchemaVData_PolymorphicBase GCExampleSchemaVData_PolymorphicDerivedA::GetParent() const {
    GCExampleSchemaVData_PolymorphicBase value(m_ptr);
    return value;
}
void GCExampleSchemaVData_PolymorphicDerivedA::SetParent(GCExampleSchemaVData_PolymorphicBase value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCExampleSchemaVData_PolymorphicDerivedA(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCExampleSchemaVData_PolymorphicDerivedA>("CExampleSchemaVData_PolymorphicDerivedA")
        .addConstructor<void (*)(std::string)>()
        .addProperty("DerivedA", &GCExampleSchemaVData_PolymorphicDerivedA::GetDerivedA, &GCExampleSchemaVData_PolymorphicDerivedA::SetDerivedA)
        .addProperty("Parent", &GCExampleSchemaVData_PolymorphicDerivedA::GetParent, &GCExampleSchemaVData_PolymorphicDerivedA::SetParent)
        .addFunction("ToPtr", &GCExampleSchemaVData_PolymorphicDerivedA::ToPtr)
        .addFunction("IsValid", &GCExampleSchemaVData_PolymorphicDerivedA::IsValid)
        .endClass();
}
GEntityKeyValueData_t::GEntityKeyValueData_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GEntityKeyValueData_t::GEntityKeyValueData_t(void *ptr) {
    m_ptr = ptr;
}
std::vector<GEntityIOConnectionData_t> GEntityKeyValueData_t::GetConnections() const {
    CUtlVector<GEntityIOConnectionData_t>* vec = GetSchemaValue<CUtlVector<GEntityIOConnectionData_t>*>(m_ptr, "EntityKeyValueData_t", "m_connections"); std::vector<GEntityIOConnectionData_t> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GEntityKeyValueData_t::SetConnections(std::vector<GEntityIOConnectionData_t> value) {
    SetSchemaValueCUtlVector<GEntityIOConnectionData_t>(m_ptr, "EntityKeyValueData_t", "m_connections", true, value);
}
std::string GEntityKeyValueData_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GEntityKeyValueData_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassEntityKeyValueData_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GEntityKeyValueData_t>("EntityKeyValueData_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Connections", &GEntityKeyValueData_t::GetConnections, &GEntityKeyValueData_t::SetConnections)
        .addFunction("ToPtr", &GEntityKeyValueData_t::ToPtr)
        .addFunction("IsValid", &GEntityKeyValueData_t::IsValid)
        .endClass();
}
GCFootStride::GCFootStride(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCFootStride::GCFootStride(void *ptr) {
    m_ptr = ptr;
}
GCFootCycleDefinition GCFootStride::GetDefinition() const {
    GCFootCycleDefinition value(GetSchemaPtr(m_ptr, "CFootStride", "m_definition"));
    return value;
}
void GCFootStride::SetDefinition(GCFootCycleDefinition value) {
    SetSchemaValue(m_ptr, "CFootStride", "m_definition", false, value);
}
GCFootTrajectories GCFootStride::GetTrajectories() const {
    GCFootTrajectories value(GetSchemaPtr(m_ptr, "CFootStride", "m_trajectories"));
    return value;
}
void GCFootStride::SetTrajectories(GCFootTrajectories value) {
    SetSchemaValue(m_ptr, "CFootStride", "m_trajectories", false, value);
}
std::string GCFootStride::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCFootStride::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCFootStride(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCFootStride>("CFootStride")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Definition", &GCFootStride::GetDefinition, &GCFootStride::SetDefinition)
        .addProperty("Trajectories", &GCFootStride::GetTrajectories, &GCFootStride::SetTrajectories)
        .addFunction("ToPtr", &GCFootStride::ToPtr)
        .addFunction("IsValid", &GCFootStride::IsValid)
        .endClass();
}
GCAnimationGroup::GCAnimationGroup(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCAnimationGroup::GCAnimationGroup(void *ptr) {
    m_ptr = ptr;
}
uint32_t GCAnimationGroup::GetFlags() const {
    return GetSchemaValue<uint32_t>(m_ptr, "CAnimationGroup", "m_nFlags");
}
void GCAnimationGroup::SetFlags(uint32_t value) {
    SetSchemaValue(m_ptr, "CAnimationGroup", "m_nFlags", false, value);
}
CBufferString GCAnimationGroup::GetName() const {
    return GetSchemaValue<CBufferString>(m_ptr, "CAnimationGroup", "m_name");
}
void GCAnimationGroup::SetName(CBufferString value) {
    SetSchemaValue(m_ptr, "CAnimationGroup", "m_name", false, value);
}
GCAnimKeyData GCAnimationGroup::GetDecodeKey() const {
    GCAnimKeyData value(GetSchemaPtr(m_ptr, "CAnimationGroup", "m_decodeKey"));
    return value;
}
void GCAnimationGroup::SetDecodeKey(GCAnimKeyData value) {
    SetSchemaValue(m_ptr, "CAnimationGroup", "m_decodeKey", false, value);
}
std::vector<CBufferString> GCAnimationGroup::GetScripts() const {
    CUtlVector<CBufferString>* vec = GetSchemaValue<CUtlVector<CBufferString>*>(m_ptr, "CAnimationGroup", "m_szScripts"); std::vector<CBufferString> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCAnimationGroup::SetScripts(std::vector<CBufferString> value) {
    SetSchemaValueCUtlVector<CBufferString>(m_ptr, "CAnimationGroup", "m_szScripts", false, value);
}
std::string GCAnimationGroup::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCAnimationGroup::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCAnimationGroup(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCAnimationGroup>("CAnimationGroup")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Flags", &GCAnimationGroup::GetFlags, &GCAnimationGroup::SetFlags)
        .addProperty("Name", &GCAnimationGroup::GetName, &GCAnimationGroup::SetName)
        .addProperty("DecodeKey", &GCAnimationGroup::GetDecodeKey, &GCAnimationGroup::SetDecodeKey)
        .addProperty("Scripts", &GCAnimationGroup::GetScripts, &GCAnimationGroup::SetScripts)
        .addFunction("ToPtr", &GCAnimationGroup::ToPtr)
        .addFunction("IsValid", &GCAnimationGroup::IsValid)
        .endClass();
}
GCSubtractUpdateNode::GCSubtractUpdateNode(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCSubtractUpdateNode::GCSubtractUpdateNode(void *ptr) {
    m_ptr = ptr;
}
uint64_t GCSubtractUpdateNode::GetFootMotionTiming() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CSubtractUpdateNode", "m_footMotionTiming");
}
void GCSubtractUpdateNode::SetFootMotionTiming(uint64_t value) {
    SetSchemaValue(m_ptr, "CSubtractUpdateNode", "m_footMotionTiming", false, value);
}
bool GCSubtractUpdateNode::GetApplyToFootMotion() const {
    return GetSchemaValue<bool>(m_ptr, "CSubtractUpdateNode", "m_bApplyToFootMotion");
}
void GCSubtractUpdateNode::SetApplyToFootMotion(bool value) {
    SetSchemaValue(m_ptr, "CSubtractUpdateNode", "m_bApplyToFootMotion", false, value);
}
bool GCSubtractUpdateNode::GetApplyChannelsSeparately() const {
    return GetSchemaValue<bool>(m_ptr, "CSubtractUpdateNode", "m_bApplyChannelsSeparately");
}
void GCSubtractUpdateNode::SetApplyChannelsSeparately(bool value) {
    SetSchemaValue(m_ptr, "CSubtractUpdateNode", "m_bApplyChannelsSeparately", false, value);
}
bool GCSubtractUpdateNode::GetUseModelSpace() const {
    return GetSchemaValue<bool>(m_ptr, "CSubtractUpdateNode", "m_bUseModelSpace");
}
void GCSubtractUpdateNode::SetUseModelSpace(bool value) {
    SetSchemaValue(m_ptr, "CSubtractUpdateNode", "m_bUseModelSpace", false, value);
}
std::string GCSubtractUpdateNode::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCSubtractUpdateNode::IsValid() {
    return (m_ptr != nullptr);
}
GCBinaryUpdateNode GCSubtractUpdateNode::GetParent() const {
    GCBinaryUpdateNode value(m_ptr);
    return value;
}
void GCSubtractUpdateNode::SetParent(GCBinaryUpdateNode value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCSubtractUpdateNode(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCSubtractUpdateNode>("CSubtractUpdateNode")
        .addConstructor<void (*)(std::string)>()
        .addProperty("FootMotionTiming", &GCSubtractUpdateNode::GetFootMotionTiming, &GCSubtractUpdateNode::SetFootMotionTiming)
        .addProperty("ApplyToFootMotion", &GCSubtractUpdateNode::GetApplyToFootMotion, &GCSubtractUpdateNode::SetApplyToFootMotion)
        .addProperty("ApplyChannelsSeparately", &GCSubtractUpdateNode::GetApplyChannelsSeparately, &GCSubtractUpdateNode::SetApplyChannelsSeparately)
        .addProperty("UseModelSpace", &GCSubtractUpdateNode::GetUseModelSpace, &GCSubtractUpdateNode::SetUseModelSpace)
        .addProperty("Parent", &GCSubtractUpdateNode::GetParent, &GCSubtractUpdateNode::SetParent)
        .addFunction("ToPtr", &GCSubtractUpdateNode::ToPtr)
        .addFunction("IsValid", &GCSubtractUpdateNode::IsValid)
        .endClass();
}
GFeTaperedCapsuleStretch_t::GFeTaperedCapsuleStretch_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GFeTaperedCapsuleStretch_t::GFeTaperedCapsuleStretch_t(void *ptr) {
    m_ptr = ptr;
}
std::vector<uint16_t> GFeTaperedCapsuleStretch_t::GetNode() const {
    uint16_t* outValue = GetSchemaValue<uint16_t*>(m_ptr, "FeTaperedCapsuleStretch_t", "nNode"); std::vector<uint16_t> ret; for(int i = 0; i < 2; i++) { ret.push_back(outValue[i]); } return ret;
}
void GFeTaperedCapsuleStretch_t::SetNode(std::vector<uint16_t> value) {
    uint16_t* outValue = GetSchemaValue<uint16_t*>(m_ptr, "FeTaperedCapsuleStretch_t", "nNode"); for(int i = 0; i < 2; i++) { outValue[i] = value[i]; } SetSchemaValue(m_ptr, "FeTaperedCapsuleStretch_t", "nNode", true, outValue);
}
uint16_t GFeTaperedCapsuleStretch_t::GetCollisionMask() const {
    return GetSchemaValue<uint16_t>(m_ptr, "FeTaperedCapsuleStretch_t", "nCollisionMask");
}
void GFeTaperedCapsuleStretch_t::SetCollisionMask(uint16_t value) {
    SetSchemaValue(m_ptr, "FeTaperedCapsuleStretch_t", "nCollisionMask", true, value);
}
uint16_t GFeTaperedCapsuleStretch_t::GetDummy() const {
    return GetSchemaValue<uint16_t>(m_ptr, "FeTaperedCapsuleStretch_t", "nDummy");
}
void GFeTaperedCapsuleStretch_t::SetDummy(uint16_t value) {
    SetSchemaValue(m_ptr, "FeTaperedCapsuleStretch_t", "nDummy", true, value);
}
std::vector<float> GFeTaperedCapsuleStretch_t::GetRadius() const {
    float* outValue = GetSchemaValue<float*>(m_ptr, "FeTaperedCapsuleStretch_t", "flRadius"); std::vector<float> ret; for(int i = 0; i < 2; i++) { ret.push_back(outValue[i]); } return ret;
}
void GFeTaperedCapsuleStretch_t::SetRadius(std::vector<float> value) {
    float* outValue = GetSchemaValue<float*>(m_ptr, "FeTaperedCapsuleStretch_t", "flRadius"); for(int i = 0; i < 2; i++) { outValue[i] = value[i]; } SetSchemaValue(m_ptr, "FeTaperedCapsuleStretch_t", "flRadius", true, outValue);
}
std::string GFeTaperedCapsuleStretch_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GFeTaperedCapsuleStretch_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassFeTaperedCapsuleStretch_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GFeTaperedCapsuleStretch_t>("FeTaperedCapsuleStretch_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Node", &GFeTaperedCapsuleStretch_t::GetNode, &GFeTaperedCapsuleStretch_t::SetNode)
        .addProperty("CollisionMask", &GFeTaperedCapsuleStretch_t::GetCollisionMask, &GFeTaperedCapsuleStretch_t::SetCollisionMask)
        .addProperty("Dummy", &GFeTaperedCapsuleStretch_t::GetDummy, &GFeTaperedCapsuleStretch_t::SetDummy)
        .addProperty("Radius", &GFeTaperedCapsuleStretch_t::GetRadius, &GFeTaperedCapsuleStretch_t::SetRadius)
        .addFunction("ToPtr", &GFeTaperedCapsuleStretch_t::ToPtr)
        .addFunction("IsValid", &GFeTaperedCapsuleStretch_t::IsValid)
        .endClass();
}
GWorldNodeOnDiskBufferData_t::GWorldNodeOnDiskBufferData_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GWorldNodeOnDiskBufferData_t::GWorldNodeOnDiskBufferData_t(void *ptr) {
    m_ptr = ptr;
}
int32_t GWorldNodeOnDiskBufferData_t::GetElementCount() const {
    return GetSchemaValue<int32_t>(m_ptr, "WorldNodeOnDiskBufferData_t", "m_nElementCount");
}
void GWorldNodeOnDiskBufferData_t::SetElementCount(int32_t value) {
    SetSchemaValue(m_ptr, "WorldNodeOnDiskBufferData_t", "m_nElementCount", true, value);
}
int32_t GWorldNodeOnDiskBufferData_t::GetElementSizeInBytes() const {
    return GetSchemaValue<int32_t>(m_ptr, "WorldNodeOnDiskBufferData_t", "m_nElementSizeInBytes");
}
void GWorldNodeOnDiskBufferData_t::SetElementSizeInBytes(int32_t value) {
    SetSchemaValue(m_ptr, "WorldNodeOnDiskBufferData_t", "m_nElementSizeInBytes", true, value);
}
std::vector<GRenderInputLayoutField_t> GWorldNodeOnDiskBufferData_t::GetInputLayoutFields() const {
    CUtlVector<GRenderInputLayoutField_t>* vec = GetSchemaValue<CUtlVector<GRenderInputLayoutField_t>*>(m_ptr, "WorldNodeOnDiskBufferData_t", "m_inputLayoutFields"); std::vector<GRenderInputLayoutField_t> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GWorldNodeOnDiskBufferData_t::SetInputLayoutFields(std::vector<GRenderInputLayoutField_t> value) {
    SetSchemaValueCUtlVector<GRenderInputLayoutField_t>(m_ptr, "WorldNodeOnDiskBufferData_t", "m_inputLayoutFields", true, value);
}
std::vector<uint8> GWorldNodeOnDiskBufferData_t::GetData() const {
    CUtlVector<uint8>* vec = GetSchemaValue<CUtlVector<uint8>*>(m_ptr, "WorldNodeOnDiskBufferData_t", "m_pData"); std::vector<uint8> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GWorldNodeOnDiskBufferData_t::SetData(std::vector<uint8> value) {
    SetSchemaValueCUtlVector<uint8>(m_ptr, "WorldNodeOnDiskBufferData_t", "m_pData", true, value);
}
std::string GWorldNodeOnDiskBufferData_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GWorldNodeOnDiskBufferData_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassWorldNodeOnDiskBufferData_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GWorldNodeOnDiskBufferData_t>("WorldNodeOnDiskBufferData_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("ElementCount", &GWorldNodeOnDiskBufferData_t::GetElementCount, &GWorldNodeOnDiskBufferData_t::SetElementCount)
        .addProperty("ElementSizeInBytes", &GWorldNodeOnDiskBufferData_t::GetElementSizeInBytes, &GWorldNodeOnDiskBufferData_t::SetElementSizeInBytes)
        .addProperty("InputLayoutFields", &GWorldNodeOnDiskBufferData_t::GetInputLayoutFields, &GWorldNodeOnDiskBufferData_t::SetInputLayoutFields)
        .addProperty("Data", &GWorldNodeOnDiskBufferData_t::GetData, &GWorldNodeOnDiskBufferData_t::SetData)
        .addFunction("ToPtr", &GWorldNodeOnDiskBufferData_t::ToPtr)
        .addFunction("IsValid", &GWorldNodeOnDiskBufferData_t::IsValid)
        .endClass();
}
GEntComponentInfo_t::GEntComponentInfo_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GEntComponentInfo_t::GEntComponentInfo_t(void *ptr) {
    m_ptr = ptr;
}
std::string GEntComponentInfo_t::GetName() const {
    return GetSchemaValuePtr<char>(m_ptr, "EntComponentInfo_t", "m_pName");
}
void GEntComponentInfo_t::SetName(std::string value) {
    WriteSchemaPtrValue(m_ptr, "EntComponentInfo_t", "m_pName", true, reinterpret_cast<byte*>(const_cast<char*>(value.c_str())), value.size());
}
std::string GEntComponentInfo_t::GetCPPClassname() const {
    return GetSchemaValuePtr<char>(m_ptr, "EntComponentInfo_t", "m_pCPPClassname");
}
void GEntComponentInfo_t::SetCPPClassname(std::string value) {
    WriteSchemaPtrValue(m_ptr, "EntComponentInfo_t", "m_pCPPClassname", true, reinterpret_cast<byte*>(const_cast<char*>(value.c_str())), value.size());
}
std::string GEntComponentInfo_t::GetNetworkDataReferencedDescription() const {
    return GetSchemaValuePtr<char>(m_ptr, "EntComponentInfo_t", "m_pNetworkDataReferencedDescription");
}
void GEntComponentInfo_t::SetNetworkDataReferencedDescription(std::string value) {
    WriteSchemaPtrValue(m_ptr, "EntComponentInfo_t", "m_pNetworkDataReferencedDescription", true, reinterpret_cast<byte*>(const_cast<char*>(value.c_str())), value.size());
}
std::string GEntComponentInfo_t::GetNetworkDataReferencedPtrPropDescription() const {
    return GetSchemaValuePtr<char>(m_ptr, "EntComponentInfo_t", "m_pNetworkDataReferencedPtrPropDescription");
}
void GEntComponentInfo_t::SetNetworkDataReferencedPtrPropDescription(std::string value) {
    WriteSchemaPtrValue(m_ptr, "EntComponentInfo_t", "m_pNetworkDataReferencedPtrPropDescription", true, reinterpret_cast<byte*>(const_cast<char*>(value.c_str())), value.size());
}
int32_t GEntComponentInfo_t::GetRuntimeIndex() const {
    return GetSchemaValue<int32_t>(m_ptr, "EntComponentInfo_t", "m_nRuntimeIndex");
}
void GEntComponentInfo_t::SetRuntimeIndex(int32_t value) {
    SetSchemaValue(m_ptr, "EntComponentInfo_t", "m_nRuntimeIndex", true, value);
}
uint32_t GEntComponentInfo_t::GetFlags() const {
    return GetSchemaValue<uint32_t>(m_ptr, "EntComponentInfo_t", "m_nFlags");
}
void GEntComponentInfo_t::SetFlags(uint32_t value) {
    SetSchemaValue(m_ptr, "EntComponentInfo_t", "m_nFlags", true, value);
}
GCEntityComponentHelper GEntComponentInfo_t::GetBaseClassComponentHelper() const {
    GCEntityComponentHelper value(*GetSchemaValuePtr<void*>(m_ptr, "EntComponentInfo_t", "m_pBaseClassComponentHelper"));
    return value;
}
void GEntComponentInfo_t::SetBaseClassComponentHelper(GCEntityComponentHelper* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'BaseClassComponentHelper' is not possible.\n");
}
std::string GEntComponentInfo_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GEntComponentInfo_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassEntComponentInfo_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GEntComponentInfo_t>("EntComponentInfo_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Name", &GEntComponentInfo_t::GetName, &GEntComponentInfo_t::SetName)
        .addProperty("CPPClassname", &GEntComponentInfo_t::GetCPPClassname, &GEntComponentInfo_t::SetCPPClassname)
        .addProperty("NetworkDataReferencedDescription", &GEntComponentInfo_t::GetNetworkDataReferencedDescription, &GEntComponentInfo_t::SetNetworkDataReferencedDescription)
        .addProperty("NetworkDataReferencedPtrPropDescription", &GEntComponentInfo_t::GetNetworkDataReferencedPtrPropDescription, &GEntComponentInfo_t::SetNetworkDataReferencedPtrPropDescription)
        .addProperty("RuntimeIndex", &GEntComponentInfo_t::GetRuntimeIndex, &GEntComponentInfo_t::SetRuntimeIndex)
        .addProperty("Flags", &GEntComponentInfo_t::GetFlags, &GEntComponentInfo_t::SetFlags)
        .addProperty("BaseClassComponentHelper", &GEntComponentInfo_t::GetBaseClassComponentHelper, &GEntComponentInfo_t::SetBaseClassComponentHelper)
        .addFunction("ToPtr", &GEntComponentInfo_t::ToPtr)
        .addFunction("IsValid", &GEntComponentInfo_t::IsValid)
        .endClass();
}
GCClientGapTypeQueryRegistration::GCClientGapTypeQueryRegistration(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCClientGapTypeQueryRegistration::GCClientGapTypeQueryRegistration(void *ptr) {
    m_ptr = ptr;
}
std::string GCClientGapTypeQueryRegistration::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCClientGapTypeQueryRegistration::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCClientGapTypeQueryRegistration(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCClientGapTypeQueryRegistration>("CClientGapTypeQueryRegistration")
        .addConstructor<void (*)(std::string)>()
        .addFunction("ToPtr", &GCClientGapTypeQueryRegistration::ToPtr)
        .addFunction("IsValid", &GCClientGapTypeQueryRegistration::IsValid)
        .endClass();
}
GCNmVirtualParameterTargetNode::GCNmVirtualParameterTargetNode(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCNmVirtualParameterTargetNode::GCNmVirtualParameterTargetNode(void *ptr) {
    m_ptr = ptr;
}
int16_t GCNmVirtualParameterTargetNode::GetChildNodeIdx() const {
    return GetSchemaValue<int16_t>(m_ptr, "CNmVirtualParameterTargetNode", "m_nChildNodeIdx");
}
void GCNmVirtualParameterTargetNode::SetChildNodeIdx(int16_t value) {
    SetSchemaValue(m_ptr, "CNmVirtualParameterTargetNode", "m_nChildNodeIdx", false, value);
}
std::string GCNmVirtualParameterTargetNode::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCNmVirtualParameterTargetNode::IsValid() {
    return (m_ptr != nullptr);
}
GCNmTargetValueNode GCNmVirtualParameterTargetNode::GetParent() const {
    GCNmTargetValueNode value(m_ptr);
    return value;
}
void GCNmVirtualParameterTargetNode::SetParent(GCNmTargetValueNode value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCNmVirtualParameterTargetNode(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCNmVirtualParameterTargetNode>("CNmVirtualParameterTargetNode")
        .addConstructor<void (*)(std::string)>()
        .addProperty("ChildNodeIdx", &GCNmVirtualParameterTargetNode::GetChildNodeIdx, &GCNmVirtualParameterTargetNode::SetChildNodeIdx)
        .addProperty("Parent", &GCNmVirtualParameterTargetNode::GetParent, &GCNmVirtualParameterTargetNode::SetParent)
        .addFunction("ToPtr", &GCNmVirtualParameterTargetNode::ToPtr)
        .addFunction("IsValid", &GCNmVirtualParameterTargetNode::IsValid)
        .endClass();
}
GCAudioAnimTag::GCAudioAnimTag(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCAudioAnimTag::GCAudioAnimTag(void *ptr) {
    m_ptr = ptr;
}
std::string GCAudioAnimTag::GetClipName() const {
    return GetSchemaValue<CUtlString>(m_ptr, "CAudioAnimTag", "m_clipName").Get();
}
void GCAudioAnimTag::SetClipName(std::string value) {
    SetSchemaValue(m_ptr, "CAudioAnimTag", "m_clipName", false, CUtlString(value.c_str()));
}
std::string GCAudioAnimTag::GetAttachmentName() const {
    return GetSchemaValue<CUtlString>(m_ptr, "CAudioAnimTag", "m_attachmentName").Get();
}
void GCAudioAnimTag::SetAttachmentName(std::string value) {
    SetSchemaValue(m_ptr, "CAudioAnimTag", "m_attachmentName", false, CUtlString(value.c_str()));
}
float GCAudioAnimTag::GetVolume() const {
    return GetSchemaValue<float>(m_ptr, "CAudioAnimTag", "m_flVolume");
}
void GCAudioAnimTag::SetVolume(float value) {
    SetSchemaValue(m_ptr, "CAudioAnimTag", "m_flVolume", false, value);
}
bool GCAudioAnimTag::GetStopWhenTagEnds() const {
    return GetSchemaValue<bool>(m_ptr, "CAudioAnimTag", "m_bStopWhenTagEnds");
}
void GCAudioAnimTag::SetStopWhenTagEnds(bool value) {
    SetSchemaValue(m_ptr, "CAudioAnimTag", "m_bStopWhenTagEnds", false, value);
}
bool GCAudioAnimTag::GetStopWhenGraphEnds() const {
    return GetSchemaValue<bool>(m_ptr, "CAudioAnimTag", "m_bStopWhenGraphEnds");
}
void GCAudioAnimTag::SetStopWhenGraphEnds(bool value) {
    SetSchemaValue(m_ptr, "CAudioAnimTag", "m_bStopWhenGraphEnds", false, value);
}
bool GCAudioAnimTag::GetPlayOnServer() const {
    return GetSchemaValue<bool>(m_ptr, "CAudioAnimTag", "m_bPlayOnServer");
}
void GCAudioAnimTag::SetPlayOnServer(bool value) {
    SetSchemaValue(m_ptr, "CAudioAnimTag", "m_bPlayOnServer", false, value);
}
bool GCAudioAnimTag::GetPlayOnClient() const {
    return GetSchemaValue<bool>(m_ptr, "CAudioAnimTag", "m_bPlayOnClient");
}
void GCAudioAnimTag::SetPlayOnClient(bool value) {
    SetSchemaValue(m_ptr, "CAudioAnimTag", "m_bPlayOnClient", false, value);
}
std::string GCAudioAnimTag::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCAudioAnimTag::IsValid() {
    return (m_ptr != nullptr);
}
GCAnimTagBase GCAudioAnimTag::GetParent() const {
    GCAnimTagBase value(m_ptr);
    return value;
}
void GCAudioAnimTag::SetParent(GCAnimTagBase value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCAudioAnimTag(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCAudioAnimTag>("CAudioAnimTag")
        .addConstructor<void (*)(std::string)>()
        .addProperty("ClipName", &GCAudioAnimTag::GetClipName, &GCAudioAnimTag::SetClipName)
        .addProperty("AttachmentName", &GCAudioAnimTag::GetAttachmentName, &GCAudioAnimTag::SetAttachmentName)
        .addProperty("Volume", &GCAudioAnimTag::GetVolume, &GCAudioAnimTag::SetVolume)
        .addProperty("StopWhenTagEnds", &GCAudioAnimTag::GetStopWhenTagEnds, &GCAudioAnimTag::SetStopWhenTagEnds)
        .addProperty("StopWhenGraphEnds", &GCAudioAnimTag::GetStopWhenGraphEnds, &GCAudioAnimTag::SetStopWhenGraphEnds)
        .addProperty("PlayOnServer", &GCAudioAnimTag::GetPlayOnServer, &GCAudioAnimTag::SetPlayOnServer)
        .addProperty("PlayOnClient", &GCAudioAnimTag::GetPlayOnClient, &GCAudioAnimTag::SetPlayOnClient)
        .addProperty("Parent", &GCAudioAnimTag::GetParent, &GCAudioAnimTag::SetParent)
        .addFunction("ToPtr", &GCAudioAnimTag::ToPtr)
        .addFunction("IsValid", &GCAudioAnimTag::IsValid)
        .endClass();
}
GCRenderMesh::GCRenderMesh(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCRenderMesh::GCRenderMesh(void *ptr) {
    m_ptr = ptr;
}
std::vector<GCBaseConstraint*> GCRenderMesh::GetConstraints() const {
    CUtlVector<GCBaseConstraint*>* vec = GetSchemaValue<CUtlVector<GCBaseConstraint*>*>(m_ptr, "CRenderMesh", "m_constraints"); std::vector<GCBaseConstraint*> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCRenderMesh::SetConstraints(std::vector<GCBaseConstraint*> value) {
    SetSchemaValueCUtlVector<GCBaseConstraint*>(m_ptr, "CRenderMesh", "m_constraints", false, value);
}
GCRenderSkeleton GCRenderMesh::GetSkeleton() const {
    GCRenderSkeleton value(GetSchemaPtr(m_ptr, "CRenderMesh", "m_skeleton"));
    return value;
}
void GCRenderMesh::SetSkeleton(GCRenderSkeleton value) {
    SetSchemaValue(m_ptr, "CRenderMesh", "m_skeleton", false, value);
}
GDynamicMeshDeformParams_t GCRenderMesh::GetMeshDeformParams() const {
    GDynamicMeshDeformParams_t value(GetSchemaPtr(m_ptr, "CRenderMesh", "m_meshDeformParams"));
    return value;
}
void GCRenderMesh::SetMeshDeformParams(GDynamicMeshDeformParams_t value) {
    SetSchemaValue(m_ptr, "CRenderMesh", "m_meshDeformParams", false, value);
}
GCRenderGroom GCRenderMesh::GetGroomData() const {
    GCRenderGroom value(*GetSchemaValuePtr<void*>(m_ptr, "CRenderMesh", "m_pGroomData"));
    return value;
}
void GCRenderMesh::SetGroomData(GCRenderGroom* value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'GroomData' is not possible.\n");
}
std::string GCRenderMesh::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCRenderMesh::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCRenderMesh(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCRenderMesh>("CRenderMesh")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Constraints", &GCRenderMesh::GetConstraints, &GCRenderMesh::SetConstraints)
        .addProperty("Skeleton", &GCRenderMesh::GetSkeleton, &GCRenderMesh::SetSkeleton)
        .addProperty("MeshDeformParams", &GCRenderMesh::GetMeshDeformParams, &GCRenderMesh::SetMeshDeformParams)
        .addProperty("GroomData", &GCRenderMesh::GetGroomData, &GCRenderMesh::SetGroomData)
        .addFunction("ToPtr", &GCRenderMesh::ToPtr)
        .addFunction("IsValid", &GCRenderMesh::IsValid)
        .endClass();
}
Gconstraint_hingeparams_t::Gconstraint_hingeparams_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
Gconstraint_hingeparams_t::Gconstraint_hingeparams_t(void *ptr) {
    m_ptr = ptr;
}
Vector Gconstraint_hingeparams_t::GetWorldPosition() const {
    return GetSchemaValue<Vector>(m_ptr, "constraint_hingeparams_t", "worldPosition");
}
void Gconstraint_hingeparams_t::SetWorldPosition(Vector value) {
    SetSchemaValue(m_ptr, "constraint_hingeparams_t", "worldPosition", true, value);
}
Vector Gconstraint_hingeparams_t::GetWorldAxisDirection() const {
    return GetSchemaValue<Vector>(m_ptr, "constraint_hingeparams_t", "worldAxisDirection");
}
void Gconstraint_hingeparams_t::SetWorldAxisDirection(Vector value) {
    SetSchemaValue(m_ptr, "constraint_hingeparams_t", "worldAxisDirection", true, value);
}
Gconstraint_axislimit_t Gconstraint_hingeparams_t::GetHingeAxis() const {
    Gconstraint_axislimit_t value(GetSchemaPtr(m_ptr, "constraint_hingeparams_t", "hingeAxis"));
    return value;
}
void Gconstraint_hingeparams_t::SetHingeAxis(Gconstraint_axislimit_t value) {
    SetSchemaValue(m_ptr, "constraint_hingeparams_t", "hingeAxis", true, value);
}
Gconstraint_breakableparams_t Gconstraint_hingeparams_t::GetConstraint() const {
    Gconstraint_breakableparams_t value(GetSchemaPtr(m_ptr, "constraint_hingeparams_t", "constraint"));
    return value;
}
void Gconstraint_hingeparams_t::SetConstraint(Gconstraint_breakableparams_t value) {
    SetSchemaValue(m_ptr, "constraint_hingeparams_t", "constraint", true, value);
}
std::string Gconstraint_hingeparams_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool Gconstraint_hingeparams_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassconstraint_hingeparams_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<Gconstraint_hingeparams_t>("constraint_hingeparams_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("WorldPosition", &Gconstraint_hingeparams_t::GetWorldPosition, &Gconstraint_hingeparams_t::SetWorldPosition)
        .addProperty("WorldAxisDirection", &Gconstraint_hingeparams_t::GetWorldAxisDirection, &Gconstraint_hingeparams_t::SetWorldAxisDirection)
        .addProperty("HingeAxis", &Gconstraint_hingeparams_t::GetHingeAxis, &Gconstraint_hingeparams_t::SetHingeAxis)
        .addProperty("Constraint", &Gconstraint_hingeparams_t::GetConstraint, &Gconstraint_hingeparams_t::SetConstraint)
        .addFunction("ToPtr", &Gconstraint_hingeparams_t::ToPtr)
        .addFunction("IsValid", &Gconstraint_hingeparams_t::IsValid)
        .endClass();
}
GNmCompressionSettings_t::GNmCompressionSettings_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GNmCompressionSettings_t::GNmCompressionSettings_t(void *ptr) {
    m_ptr = ptr;
}
GNmCompressionSettings_t GNmCompressionSettings_t::GetTranslationRangeX() const {
    GNmCompressionSettings_t value(GetSchemaPtr(m_ptr, "NmCompressionSettings_t", "m_translationRangeX"));
    return value;
}
void GNmCompressionSettings_t::SetTranslationRangeX(GNmCompressionSettings_t value) {
    SetSchemaValue(m_ptr, "NmCompressionSettings_t", "m_translationRangeX", true, value);
}
GNmCompressionSettings_t GNmCompressionSettings_t::GetTranslationRangeY() const {
    GNmCompressionSettings_t value(GetSchemaPtr(m_ptr, "NmCompressionSettings_t", "m_translationRangeY"));
    return value;
}
void GNmCompressionSettings_t::SetTranslationRangeY(GNmCompressionSettings_t value) {
    SetSchemaValue(m_ptr, "NmCompressionSettings_t", "m_translationRangeY", true, value);
}
GNmCompressionSettings_t GNmCompressionSettings_t::GetTranslationRangeZ() const {
    GNmCompressionSettings_t value(GetSchemaPtr(m_ptr, "NmCompressionSettings_t", "m_translationRangeZ"));
    return value;
}
void GNmCompressionSettings_t::SetTranslationRangeZ(GNmCompressionSettings_t value) {
    SetSchemaValue(m_ptr, "NmCompressionSettings_t", "m_translationRangeZ", true, value);
}
GNmCompressionSettings_t GNmCompressionSettings_t::GetScaleRange() const {
    GNmCompressionSettings_t value(GetSchemaPtr(m_ptr, "NmCompressionSettings_t", "m_scaleRange"));
    return value;
}
void GNmCompressionSettings_t::SetScaleRange(GNmCompressionSettings_t value) {
    SetSchemaValue(m_ptr, "NmCompressionSettings_t", "m_scaleRange", true, value);
}
Quaternion GNmCompressionSettings_t::GetConstantRotation() const {
    return GetSchemaValue<Quaternion>(m_ptr, "NmCompressionSettings_t", "m_constantRotation");
}
void GNmCompressionSettings_t::SetConstantRotation(Quaternion value) {
    SetSchemaValue(m_ptr, "NmCompressionSettings_t", "m_constantRotation", true, value);
}
bool GNmCompressionSettings_t::GetIsRotationStatic() const {
    return GetSchemaValue<bool>(m_ptr, "NmCompressionSettings_t", "m_bIsRotationStatic");
}
void GNmCompressionSettings_t::SetIsRotationStatic(bool value) {
    SetSchemaValue(m_ptr, "NmCompressionSettings_t", "m_bIsRotationStatic", true, value);
}
bool GNmCompressionSettings_t::GetIsTranslationStatic() const {
    return GetSchemaValue<bool>(m_ptr, "NmCompressionSettings_t", "m_bIsTranslationStatic");
}
void GNmCompressionSettings_t::SetIsTranslationStatic(bool value) {
    SetSchemaValue(m_ptr, "NmCompressionSettings_t", "m_bIsTranslationStatic", true, value);
}
bool GNmCompressionSettings_t::GetIsScaleStatic() const {
    return GetSchemaValue<bool>(m_ptr, "NmCompressionSettings_t", "m_bIsScaleStatic");
}
void GNmCompressionSettings_t::SetIsScaleStatic(bool value) {
    SetSchemaValue(m_ptr, "NmCompressionSettings_t", "m_bIsScaleStatic", true, value);
}
std::string GNmCompressionSettings_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GNmCompressionSettings_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassNmCompressionSettings_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GNmCompressionSettings_t>("NmCompressionSettings_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("TranslationRangeX", &GNmCompressionSettings_t::GetTranslationRangeX, &GNmCompressionSettings_t::SetTranslationRangeX)
        .addProperty("TranslationRangeY", &GNmCompressionSettings_t::GetTranslationRangeY, &GNmCompressionSettings_t::SetTranslationRangeY)
        .addProperty("TranslationRangeZ", &GNmCompressionSettings_t::GetTranslationRangeZ, &GNmCompressionSettings_t::SetTranslationRangeZ)
        .addProperty("ScaleRange", &GNmCompressionSettings_t::GetScaleRange, &GNmCompressionSettings_t::SetScaleRange)
        .addProperty("ConstantRotation", &GNmCompressionSettings_t::GetConstantRotation, &GNmCompressionSettings_t::SetConstantRotation)
        .addProperty("IsRotationStatic", &GNmCompressionSettings_t::GetIsRotationStatic, &GNmCompressionSettings_t::SetIsRotationStatic)
        .addProperty("IsTranslationStatic", &GNmCompressionSettings_t::GetIsTranslationStatic, &GNmCompressionSettings_t::SetIsTranslationStatic)
        .addProperty("IsScaleStatic", &GNmCompressionSettings_t::GetIsScaleStatic, &GNmCompressionSettings_t::SetIsScaleStatic)
        .addFunction("ToPtr", &GNmCompressionSettings_t::ToPtr)
        .addFunction("IsValid", &GNmCompressionSettings_t::IsValid)
        .endClass();
}
GCTurnHelperUpdateNode::GCTurnHelperUpdateNode(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCTurnHelperUpdateNode::GCTurnHelperUpdateNode(void *ptr) {
    m_ptr = ptr;
}
uint64_t GCTurnHelperUpdateNode::GetFacingTarget() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CTurnHelperUpdateNode", "m_facingTarget");
}
void GCTurnHelperUpdateNode::SetFacingTarget(uint64_t value) {
    SetSchemaValue(m_ptr, "CTurnHelperUpdateNode", "m_facingTarget", false, value);
}
float GCTurnHelperUpdateNode::GetTurnStartTimeOffset() const {
    return GetSchemaValue<float>(m_ptr, "CTurnHelperUpdateNode", "m_turnStartTimeOffset");
}
void GCTurnHelperUpdateNode::SetTurnStartTimeOffset(float value) {
    SetSchemaValue(m_ptr, "CTurnHelperUpdateNode", "m_turnStartTimeOffset", false, value);
}
float GCTurnHelperUpdateNode::GetTurnDuration() const {
    return GetSchemaValue<float>(m_ptr, "CTurnHelperUpdateNode", "m_turnDuration");
}
void GCTurnHelperUpdateNode::SetTurnDuration(float value) {
    SetSchemaValue(m_ptr, "CTurnHelperUpdateNode", "m_turnDuration", false, value);
}
bool GCTurnHelperUpdateNode::GetMatchChildDuration() const {
    return GetSchemaValue<bool>(m_ptr, "CTurnHelperUpdateNode", "m_bMatchChildDuration");
}
void GCTurnHelperUpdateNode::SetMatchChildDuration(bool value) {
    SetSchemaValue(m_ptr, "CTurnHelperUpdateNode", "m_bMatchChildDuration", false, value);
}
float GCTurnHelperUpdateNode::GetManualTurnOffset() const {
    return GetSchemaValue<float>(m_ptr, "CTurnHelperUpdateNode", "m_manualTurnOffset");
}
void GCTurnHelperUpdateNode::SetManualTurnOffset(float value) {
    SetSchemaValue(m_ptr, "CTurnHelperUpdateNode", "m_manualTurnOffset", false, value);
}
bool GCTurnHelperUpdateNode::GetUseManualTurnOffset() const {
    return GetSchemaValue<bool>(m_ptr, "CTurnHelperUpdateNode", "m_bUseManualTurnOffset");
}
void GCTurnHelperUpdateNode::SetUseManualTurnOffset(bool value) {
    SetSchemaValue(m_ptr, "CTurnHelperUpdateNode", "m_bUseManualTurnOffset", false, value);
}
std::string GCTurnHelperUpdateNode::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCTurnHelperUpdateNode::IsValid() {
    return (m_ptr != nullptr);
}
GCUnaryUpdateNode GCTurnHelperUpdateNode::GetParent() const {
    GCUnaryUpdateNode value(m_ptr);
    return value;
}
void GCTurnHelperUpdateNode::SetParent(GCUnaryUpdateNode value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCTurnHelperUpdateNode(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCTurnHelperUpdateNode>("CTurnHelperUpdateNode")
        .addConstructor<void (*)(std::string)>()
        .addProperty("FacingTarget", &GCTurnHelperUpdateNode::GetFacingTarget, &GCTurnHelperUpdateNode::SetFacingTarget)
        .addProperty("TurnStartTimeOffset", &GCTurnHelperUpdateNode::GetTurnStartTimeOffset, &GCTurnHelperUpdateNode::SetTurnStartTimeOffset)
        .addProperty("TurnDuration", &GCTurnHelperUpdateNode::GetTurnDuration, &GCTurnHelperUpdateNode::SetTurnDuration)
        .addProperty("MatchChildDuration", &GCTurnHelperUpdateNode::GetMatchChildDuration, &GCTurnHelperUpdateNode::SetMatchChildDuration)
        .addProperty("ManualTurnOffset", &GCTurnHelperUpdateNode::GetManualTurnOffset, &GCTurnHelperUpdateNode::SetManualTurnOffset)
        .addProperty("UseManualTurnOffset", &GCTurnHelperUpdateNode::GetUseManualTurnOffset, &GCTurnHelperUpdateNode::SetUseManualTurnOffset)
        .addProperty("Parent", &GCTurnHelperUpdateNode::GetParent, &GCTurnHelperUpdateNode::SetParent)
        .addFunction("ToPtr", &GCTurnHelperUpdateNode::ToPtr)
        .addFunction("IsValid", &GCTurnHelperUpdateNode::IsValid)
        .endClass();
}
GCSosGroupActionTimeLimitSchema::GCSosGroupActionTimeLimitSchema(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCSosGroupActionTimeLimitSchema::GCSosGroupActionTimeLimitSchema(void *ptr) {
    m_ptr = ptr;
}
float GCSosGroupActionTimeLimitSchema::GetMaxDuration() const {
    return GetSchemaValue<float>(m_ptr, "CSosGroupActionTimeLimitSchema", "m_flMaxDuration");
}
void GCSosGroupActionTimeLimitSchema::SetMaxDuration(float value) {
    SetSchemaValue(m_ptr, "CSosGroupActionTimeLimitSchema", "m_flMaxDuration", false, value);
}
std::string GCSosGroupActionTimeLimitSchema::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCSosGroupActionTimeLimitSchema::IsValid() {
    return (m_ptr != nullptr);
}
GCSosGroupActionSchema GCSosGroupActionTimeLimitSchema::GetParent() const {
    GCSosGroupActionSchema value(m_ptr);
    return value;
}
void GCSosGroupActionTimeLimitSchema::SetParent(GCSosGroupActionSchema value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCSosGroupActionTimeLimitSchema(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCSosGroupActionTimeLimitSchema>("CSosGroupActionTimeLimitSchema")
        .addConstructor<void (*)(std::string)>()
        .addProperty("MaxDuration", &GCSosGroupActionTimeLimitSchema::GetMaxDuration, &GCSosGroupActionTimeLimitSchema::SetMaxDuration)
        .addProperty("Parent", &GCSosGroupActionTimeLimitSchema::GetParent, &GCSosGroupActionTimeLimitSchema::SetParent)
        .addFunction("ToPtr", &GCSosGroupActionTimeLimitSchema::ToPtr)
        .addFunction("IsValid", &GCSosGroupActionTimeLimitSchema::IsValid)
        .endClass();
}
GCFollowTargetUpdateNode::GCFollowTargetUpdateNode(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCFollowTargetUpdateNode::GCFollowTargetUpdateNode(void *ptr) {
    m_ptr = ptr;
}
GFollowTargetOpFixedSettings_t GCFollowTargetUpdateNode::GetOpFixedData() const {
    GFollowTargetOpFixedSettings_t value(GetSchemaPtr(m_ptr, "CFollowTargetUpdateNode", "m_opFixedData"));
    return value;
}
void GCFollowTargetUpdateNode::SetOpFixedData(GFollowTargetOpFixedSettings_t value) {
    SetSchemaValue(m_ptr, "CFollowTargetUpdateNode", "m_opFixedData", false, value);
}
GCAnimParamHandle GCFollowTargetUpdateNode::GetParameterPosition() const {
    GCAnimParamHandle value(GetSchemaPtr(m_ptr, "CFollowTargetUpdateNode", "m_hParameterPosition"));
    return value;
}
void GCFollowTargetUpdateNode::SetParameterPosition(GCAnimParamHandle value) {
    SetSchemaValue(m_ptr, "CFollowTargetUpdateNode", "m_hParameterPosition", false, value);
}
GCAnimParamHandle GCFollowTargetUpdateNode::GetParameterOrientation() const {
    GCAnimParamHandle value(GetSchemaPtr(m_ptr, "CFollowTargetUpdateNode", "m_hParameterOrientation"));
    return value;
}
void GCFollowTargetUpdateNode::SetParameterOrientation(GCAnimParamHandle value) {
    SetSchemaValue(m_ptr, "CFollowTargetUpdateNode", "m_hParameterOrientation", false, value);
}
std::string GCFollowTargetUpdateNode::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCFollowTargetUpdateNode::IsValid() {
    return (m_ptr != nullptr);
}
GCUnaryUpdateNode GCFollowTargetUpdateNode::GetParent() const {
    GCUnaryUpdateNode value(m_ptr);
    return value;
}
void GCFollowTargetUpdateNode::SetParent(GCUnaryUpdateNode value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCFollowTargetUpdateNode(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCFollowTargetUpdateNode>("CFollowTargetUpdateNode")
        .addConstructor<void (*)(std::string)>()
        .addProperty("OpFixedData", &GCFollowTargetUpdateNode::GetOpFixedData, &GCFollowTargetUpdateNode::SetOpFixedData)
        .addProperty("ParameterPosition", &GCFollowTargetUpdateNode::GetParameterPosition, &GCFollowTargetUpdateNode::SetParameterPosition)
        .addProperty("ParameterOrientation", &GCFollowTargetUpdateNode::GetParameterOrientation, &GCFollowTargetUpdateNode::SetParameterOrientation)
        .addProperty("Parent", &GCFollowTargetUpdateNode::GetParent, &GCFollowTargetUpdateNode::SetParent)
        .addFunction("ToPtr", &GCFollowTargetUpdateNode::ToPtr)
        .addFunction("IsValid", &GCFollowTargetUpdateNode::IsValid)
        .endClass();
}
GEventClientAdvanceNonRenderedFrame_t::GEventClientAdvanceNonRenderedFrame_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GEventClientAdvanceNonRenderedFrame_t::GEventClientAdvanceNonRenderedFrame_t(void *ptr) {
    m_ptr = ptr;
}
std::string GEventClientAdvanceNonRenderedFrame_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GEventClientAdvanceNonRenderedFrame_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassEventClientAdvanceNonRenderedFrame_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GEventClientAdvanceNonRenderedFrame_t>("EventClientAdvanceNonRenderedFrame_t")
        .addConstructor<void (*)(std::string)>()
        .addFunction("ToPtr", &GEventClientAdvanceNonRenderedFrame_t::ToPtr)
        .addFunction("IsValid", &GEventClientAdvanceNonRenderedFrame_t::IsValid)
        .endClass();
}
GCSosSoundEventGroupListSchema::GCSosSoundEventGroupListSchema(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCSosSoundEventGroupListSchema::GCSosSoundEventGroupListSchema(void *ptr) {
    m_ptr = ptr;
}
std::vector<GCSosSoundEventGroupSchema> GCSosSoundEventGroupListSchema::GetGroupList() const {
    CUtlVector<GCSosSoundEventGroupSchema>* vec = GetSchemaValue<CUtlVector<GCSosSoundEventGroupSchema>*>(m_ptr, "CSosSoundEventGroupListSchema", "m_groupList"); std::vector<GCSosSoundEventGroupSchema> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCSosSoundEventGroupListSchema::SetGroupList(std::vector<GCSosSoundEventGroupSchema> value) {
    SetSchemaValueCUtlVector<GCSosSoundEventGroupSchema>(m_ptr, "CSosSoundEventGroupListSchema", "m_groupList", false, value);
}
std::string GCSosSoundEventGroupListSchema::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCSosSoundEventGroupListSchema::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCSosSoundEventGroupListSchema(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCSosSoundEventGroupListSchema>("CSosSoundEventGroupListSchema")
        .addConstructor<void (*)(std::string)>()
        .addProperty("GroupList", &GCSosSoundEventGroupListSchema::GetGroupList, &GCSosSoundEventGroupListSchema::SetGroupList)
        .addFunction("ToPtr", &GCSosSoundEventGroupListSchema::ToPtr)
        .addFunction("IsValid", &GCSosSoundEventGroupListSchema::IsValid)
        .endClass();
}
GCNmClip::GCNmClip(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCNmClip::GCNmClip(void *ptr) {
    m_ptr = ptr;
}
uint32_t GCNmClip::GetNumFrames() const {
    return GetSchemaValue<uint32_t>(m_ptr, "CNmClip", "m_nNumFrames");
}
void GCNmClip::SetNumFrames(uint32_t value) {
    SetSchemaValue(m_ptr, "CNmClip", "m_nNumFrames", false, value);
}
float GCNmClip::GetDuration() const {
    return GetSchemaValue<float>(m_ptr, "CNmClip", "m_flDuration");
}
void GCNmClip::SetDuration(float value) {
    SetSchemaValue(m_ptr, "CNmClip", "m_flDuration", false, value);
}
std::vector<GNmCompressionSettings_t> GCNmClip::GetTrackCompressionSettings() const {
    CUtlVector<GNmCompressionSettings_t>* vec = GetSchemaValue<CUtlVector<GNmCompressionSettings_t>*>(m_ptr, "CNmClip", "m_trackCompressionSettings"); std::vector<GNmCompressionSettings_t> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCNmClip::SetTrackCompressionSettings(std::vector<GNmCompressionSettings_t> value) {
    SetSchemaValueCUtlVector<GNmCompressionSettings_t>(m_ptr, "CNmClip", "m_trackCompressionSettings", false, value);
}
std::vector<uint32> GCNmClip::GetCompressedPoseOffsets() const {
    CUtlVector<uint32>* vec = GetSchemaValue<CUtlVector<uint32>*>(m_ptr, "CNmClip", "m_compressedPoseOffsets"); std::vector<uint32> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCNmClip::SetCompressedPoseOffsets(std::vector<uint32> value) {
    SetSchemaValueCUtlVector<uint32>(m_ptr, "CNmClip", "m_compressedPoseOffsets", false, value);
}
GCNmSyncTrack GCNmClip::GetSyncTrack() const {
    GCNmSyncTrack value(GetSchemaPtr(m_ptr, "CNmClip", "m_syncTrack"));
    return value;
}
void GCNmClip::SetSyncTrack(GCNmSyncTrack value) {
    SetSchemaValue(m_ptr, "CNmClip", "m_syncTrack", false, value);
}
GCNmRootMotionData GCNmClip::GetRootMotion() const {
    GCNmRootMotionData value(GetSchemaPtr(m_ptr, "CNmClip", "m_rootMotion"));
    return value;
}
void GCNmClip::SetRootMotion(GCNmRootMotionData value) {
    SetSchemaValue(m_ptr, "CNmClip", "m_rootMotion", false, value);
}
bool GCNmClip::GetIsAdditive() const {
    return GetSchemaValue<bool>(m_ptr, "CNmClip", "m_bIsAdditive");
}
void GCNmClip::SetIsAdditive(bool value) {
    SetSchemaValue(m_ptr, "CNmClip", "m_bIsAdditive", false, value);
}
std::string GCNmClip::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCNmClip::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCNmClip(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCNmClip>("CNmClip")
        .addConstructor<void (*)(std::string)>()
        .addProperty("NumFrames", &GCNmClip::GetNumFrames, &GCNmClip::SetNumFrames)
        .addProperty("Duration", &GCNmClip::GetDuration, &GCNmClip::SetDuration)
        .addProperty("TrackCompressionSettings", &GCNmClip::GetTrackCompressionSettings, &GCNmClip::SetTrackCompressionSettings)
        .addProperty("CompressedPoseOffsets", &GCNmClip::GetCompressedPoseOffsets, &GCNmClip::SetCompressedPoseOffsets)
        .addProperty("SyncTrack", &GCNmClip::GetSyncTrack, &GCNmClip::SetSyncTrack)
        .addProperty("RootMotion", &GCNmClip::GetRootMotion, &GCNmClip::SetRootMotion)
        .addProperty("IsAdditive", &GCNmClip::GetIsAdditive, &GCNmClip::SetIsAdditive)
        .addFunction("ToPtr", &GCNmClip::ToPtr)
        .addFunction("IsValid", &GCNmClip::IsValid)
        .endClass();
}
GCFlexDesc::GCFlexDesc(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCFlexDesc::GCFlexDesc(void *ptr) {
    m_ptr = ptr;
}
std::string GCFlexDesc::GetFacs() const {
    return GetSchemaValue<CUtlString>(m_ptr, "CFlexDesc", "m_szFacs").Get();
}
void GCFlexDesc::SetFacs(std::string value) {
    SetSchemaValue(m_ptr, "CFlexDesc", "m_szFacs", false, CUtlString(value.c_str()));
}
std::string GCFlexDesc::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCFlexDesc::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCFlexDesc(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCFlexDesc>("CFlexDesc")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Facs", &GCFlexDesc::GetFacs, &GCFlexDesc::SetFacs)
        .addFunction("ToPtr", &GCFlexDesc::ToPtr)
        .addFunction("IsValid", &GCFlexDesc::IsValid)
        .endClass();
}
GCStateMachineComponentUpdater::GCStateMachineComponentUpdater(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCStateMachineComponentUpdater::GCStateMachineComponentUpdater(void *ptr) {
    m_ptr = ptr;
}
GCAnimStateMachineUpdater GCStateMachineComponentUpdater::GetStateMachine() const {
    GCAnimStateMachineUpdater value(GetSchemaPtr(m_ptr, "CStateMachineComponentUpdater", "m_stateMachine"));
    return value;
}
void GCStateMachineComponentUpdater::SetStateMachine(GCAnimStateMachineUpdater value) {
    SetSchemaValue(m_ptr, "CStateMachineComponentUpdater", "m_stateMachine", false, value);
}
std::string GCStateMachineComponentUpdater::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCStateMachineComponentUpdater::IsValid() {
    return (m_ptr != nullptr);
}
GCAnimComponentUpdater GCStateMachineComponentUpdater::GetParent() const {
    GCAnimComponentUpdater value(m_ptr);
    return value;
}
void GCStateMachineComponentUpdater::SetParent(GCAnimComponentUpdater value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCStateMachineComponentUpdater(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCStateMachineComponentUpdater>("CStateMachineComponentUpdater")
        .addConstructor<void (*)(std::string)>()
        .addProperty("StateMachine", &GCStateMachineComponentUpdater::GetStateMachine, &GCStateMachineComponentUpdater::SetStateMachine)
        .addProperty("Parent", &GCStateMachineComponentUpdater::GetParent, &GCStateMachineComponentUpdater::SetParent)
        .addFunction("ToPtr", &GCStateMachineComponentUpdater::ToPtr)
        .addFunction("IsValid", &GCStateMachineComponentUpdater::IsValid)
        .endClass();
}
GCompMatMutatorCondition_t::GCompMatMutatorCondition_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCompMatMutatorCondition_t::GCompMatMutatorCondition_t(void *ptr) {
    m_ptr = ptr;
}
uint64_t GCompMatMutatorCondition_t::GetMutatorCondition() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CompMatMutatorCondition_t", "m_nMutatorCondition");
}
void GCompMatMutatorCondition_t::SetMutatorCondition(uint64_t value) {
    SetSchemaValue(m_ptr, "CompMatMutatorCondition_t", "m_nMutatorCondition", true, value);
}
std::string GCompMatMutatorCondition_t::GetStrMutatorConditionContainerName() const {
    return GetSchemaValue<CUtlString>(m_ptr, "CompMatMutatorCondition_t", "m_strMutatorConditionContainerName").Get();
}
void GCompMatMutatorCondition_t::SetStrMutatorConditionContainerName(std::string value) {
    SetSchemaValue(m_ptr, "CompMatMutatorCondition_t", "m_strMutatorConditionContainerName", true, CUtlString(value.c_str()));
}
std::string GCompMatMutatorCondition_t::GetStrMutatorConditionContainerVarName() const {
    return GetSchemaValue<CUtlString>(m_ptr, "CompMatMutatorCondition_t", "m_strMutatorConditionContainerVarName").Get();
}
void GCompMatMutatorCondition_t::SetStrMutatorConditionContainerVarName(std::string value) {
    SetSchemaValue(m_ptr, "CompMatMutatorCondition_t", "m_strMutatorConditionContainerVarName", true, CUtlString(value.c_str()));
}
std::string GCompMatMutatorCondition_t::GetStrMutatorConditionContainerVarValue() const {
    return GetSchemaValue<CUtlString>(m_ptr, "CompMatMutatorCondition_t", "m_strMutatorConditionContainerVarValue").Get();
}
void GCompMatMutatorCondition_t::SetStrMutatorConditionContainerVarValue(std::string value) {
    SetSchemaValue(m_ptr, "CompMatMutatorCondition_t", "m_strMutatorConditionContainerVarValue", true, CUtlString(value.c_str()));
}
bool GCompMatMutatorCondition_t::GetPassWhenTrue() const {
    return GetSchemaValue<bool>(m_ptr, "CompMatMutatorCondition_t", "m_bPassWhenTrue");
}
void GCompMatMutatorCondition_t::SetPassWhenTrue(bool value) {
    SetSchemaValue(m_ptr, "CompMatMutatorCondition_t", "m_bPassWhenTrue", true, value);
}
std::string GCompMatMutatorCondition_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCompMatMutatorCondition_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCompMatMutatorCondition_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCompMatMutatorCondition_t>("CompMatMutatorCondition_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("MutatorCondition", &GCompMatMutatorCondition_t::GetMutatorCondition, &GCompMatMutatorCondition_t::SetMutatorCondition)
        .addProperty("StrMutatorConditionContainerName", &GCompMatMutatorCondition_t::GetStrMutatorConditionContainerName, &GCompMatMutatorCondition_t::SetStrMutatorConditionContainerName)
        .addProperty("StrMutatorConditionContainerVarName", &GCompMatMutatorCondition_t::GetStrMutatorConditionContainerVarName, &GCompMatMutatorCondition_t::SetStrMutatorConditionContainerVarName)
        .addProperty("StrMutatorConditionContainerVarValue", &GCompMatMutatorCondition_t::GetStrMutatorConditionContainerVarValue, &GCompMatMutatorCondition_t::SetStrMutatorConditionContainerVarValue)
        .addProperty("PassWhenTrue", &GCompMatMutatorCondition_t::GetPassWhenTrue, &GCompMatMutatorCondition_t::SetPassWhenTrue)
        .addFunction("ToPtr", &GCompMatMutatorCondition_t::ToPtr)
        .addFunction("IsValid", &GCompMatMutatorCondition_t::IsValid)
        .endClass();
}
GFakeEntity_tAPI::GFakeEntity_tAPI(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GFakeEntity_tAPI::GFakeEntity_tAPI(void *ptr) {
    m_ptr = ptr;
}
std::string GFakeEntity_tAPI::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GFakeEntity_tAPI::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassFakeEntity_tAPI(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GFakeEntity_tAPI>("FakeEntity_tAPI")
        .addConstructor<void (*)(std::string)>()
        .addFunction("ToPtr", &GFakeEntity_tAPI::ToPtr)
        .addFunction("IsValid", &GFakeEntity_tAPI::IsValid)
        .endClass();
}
GCBoneConstraintPoseSpaceMorph__Input_t::GCBoneConstraintPoseSpaceMorph__Input_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCBoneConstraintPoseSpaceMorph__Input_t::GCBoneConstraintPoseSpaceMorph__Input_t(void *ptr) {
    m_ptr = ptr;
}
Vector GCBoneConstraintPoseSpaceMorph__Input_t::GetInputValue() const {
    return GetSchemaValue<Vector>(m_ptr, "CBoneConstraintPoseSpaceMorph__Input_t", "m_inputValue");
}
void GCBoneConstraintPoseSpaceMorph__Input_t::SetInputValue(Vector value) {
    SetSchemaValue(m_ptr, "CBoneConstraintPoseSpaceMorph__Input_t", "m_inputValue", true, value);
}
std::vector<float32> GCBoneConstraintPoseSpaceMorph__Input_t::GetOutputWeightList() const {
    CUtlVector<float32>* vec = GetSchemaValue<CUtlVector<float32>*>(m_ptr, "CBoneConstraintPoseSpaceMorph__Input_t", "m_outputWeightList"); std::vector<float32> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCBoneConstraintPoseSpaceMorph__Input_t::SetOutputWeightList(std::vector<float32> value) {
    SetSchemaValueCUtlVector<float32>(m_ptr, "CBoneConstraintPoseSpaceMorph__Input_t", "m_outputWeightList", true, value);
}
std::string GCBoneConstraintPoseSpaceMorph__Input_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCBoneConstraintPoseSpaceMorph__Input_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCBoneConstraintPoseSpaceMorph__Input_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCBoneConstraintPoseSpaceMorph__Input_t>("CBoneConstraintPoseSpaceMorph__Input_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("InputValue", &GCBoneConstraintPoseSpaceMorph__Input_t::GetInputValue, &GCBoneConstraintPoseSpaceMorph__Input_t::SetInputValue)
        .addProperty("OutputWeightList", &GCBoneConstraintPoseSpaceMorph__Input_t::GetOutputWeightList, &GCBoneConstraintPoseSpaceMorph__Input_t::SetOutputWeightList)
        .addFunction("ToPtr", &GCBoneConstraintPoseSpaceMorph__Input_t::ToPtr)
        .addFunction("IsValid", &GCBoneConstraintPoseSpaceMorph__Input_t::IsValid)
        .endClass();
}
GCTwoBoneIKUpdateNode::GCTwoBoneIKUpdateNode(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCTwoBoneIKUpdateNode::GCTwoBoneIKUpdateNode(void *ptr) {
    m_ptr = ptr;
}
GTwoBoneIKSettings_t GCTwoBoneIKUpdateNode::GetOpFixedData() const {
    GTwoBoneIKSettings_t value(GetSchemaPtr(m_ptr, "CTwoBoneIKUpdateNode", "m_opFixedData"));
    return value;
}
void GCTwoBoneIKUpdateNode::SetOpFixedData(GTwoBoneIKSettings_t value) {
    SetSchemaValue(m_ptr, "CTwoBoneIKUpdateNode", "m_opFixedData", false, value);
}
std::string GCTwoBoneIKUpdateNode::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCTwoBoneIKUpdateNode::IsValid() {
    return (m_ptr != nullptr);
}
GCUnaryUpdateNode GCTwoBoneIKUpdateNode::GetParent() const {
    GCUnaryUpdateNode value(m_ptr);
    return value;
}
void GCTwoBoneIKUpdateNode::SetParent(GCUnaryUpdateNode value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCTwoBoneIKUpdateNode(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCTwoBoneIKUpdateNode>("CTwoBoneIKUpdateNode")
        .addConstructor<void (*)(std::string)>()
        .addProperty("OpFixedData", &GCTwoBoneIKUpdateNode::GetOpFixedData, &GCTwoBoneIKUpdateNode::SetOpFixedData)
        .addProperty("Parent", &GCTwoBoneIKUpdateNode::GetParent, &GCTwoBoneIKUpdateNode::SetParent)
        .addFunction("ToPtr", &GCTwoBoneIKUpdateNode::ToPtr)
        .addFunction("IsValid", &GCTwoBoneIKUpdateNode::IsValid)
        .endClass();
}
GVMixDynamicsDesc_t::GVMixDynamicsDesc_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GVMixDynamicsDesc_t::GVMixDynamicsDesc_t(void *ptr) {
    m_ptr = ptr;
}
float GVMixDynamicsDesc_t::GetFldbGain() const {
    return GetSchemaValue<float>(m_ptr, "VMixDynamicsDesc_t", "m_fldbGain");
}
void GVMixDynamicsDesc_t::SetFldbGain(float value) {
    SetSchemaValue(m_ptr, "VMixDynamicsDesc_t", "m_fldbGain", true, value);
}
float GVMixDynamicsDesc_t::GetFldbNoiseGateThreshold() const {
    return GetSchemaValue<float>(m_ptr, "VMixDynamicsDesc_t", "m_fldbNoiseGateThreshold");
}
void GVMixDynamicsDesc_t::SetFldbNoiseGateThreshold(float value) {
    SetSchemaValue(m_ptr, "VMixDynamicsDesc_t", "m_fldbNoiseGateThreshold", true, value);
}
float GVMixDynamicsDesc_t::GetFldbCompressionThreshold() const {
    return GetSchemaValue<float>(m_ptr, "VMixDynamicsDesc_t", "m_fldbCompressionThreshold");
}
void GVMixDynamicsDesc_t::SetFldbCompressionThreshold(float value) {
    SetSchemaValue(m_ptr, "VMixDynamicsDesc_t", "m_fldbCompressionThreshold", true, value);
}
float GVMixDynamicsDesc_t::GetFldbLimiterThreshold() const {
    return GetSchemaValue<float>(m_ptr, "VMixDynamicsDesc_t", "m_fldbLimiterThreshold");
}
void GVMixDynamicsDesc_t::SetFldbLimiterThreshold(float value) {
    SetSchemaValue(m_ptr, "VMixDynamicsDesc_t", "m_fldbLimiterThreshold", true, value);
}
float GVMixDynamicsDesc_t::GetFldbKneeWidth() const {
    return GetSchemaValue<float>(m_ptr, "VMixDynamicsDesc_t", "m_fldbKneeWidth");
}
void GVMixDynamicsDesc_t::SetFldbKneeWidth(float value) {
    SetSchemaValue(m_ptr, "VMixDynamicsDesc_t", "m_fldbKneeWidth", true, value);
}
float GVMixDynamicsDesc_t::GetRatio() const {
    return GetSchemaValue<float>(m_ptr, "VMixDynamicsDesc_t", "m_flRatio");
}
void GVMixDynamicsDesc_t::SetRatio(float value) {
    SetSchemaValue(m_ptr, "VMixDynamicsDesc_t", "m_flRatio", true, value);
}
float GVMixDynamicsDesc_t::GetLimiterRatio() const {
    return GetSchemaValue<float>(m_ptr, "VMixDynamicsDesc_t", "m_flLimiterRatio");
}
void GVMixDynamicsDesc_t::SetLimiterRatio(float value) {
    SetSchemaValue(m_ptr, "VMixDynamicsDesc_t", "m_flLimiterRatio", true, value);
}
float GVMixDynamicsDesc_t::GetAttackTimeMS() const {
    return GetSchemaValue<float>(m_ptr, "VMixDynamicsDesc_t", "m_flAttackTimeMS");
}
void GVMixDynamicsDesc_t::SetAttackTimeMS(float value) {
    SetSchemaValue(m_ptr, "VMixDynamicsDesc_t", "m_flAttackTimeMS", true, value);
}
float GVMixDynamicsDesc_t::GetReleaseTimeMS() const {
    return GetSchemaValue<float>(m_ptr, "VMixDynamicsDesc_t", "m_flReleaseTimeMS");
}
void GVMixDynamicsDesc_t::SetReleaseTimeMS(float value) {
    SetSchemaValue(m_ptr, "VMixDynamicsDesc_t", "m_flReleaseTimeMS", true, value);
}
float GVMixDynamicsDesc_t::GetRMSTimeMS() const {
    return GetSchemaValue<float>(m_ptr, "VMixDynamicsDesc_t", "m_flRMSTimeMS");
}
void GVMixDynamicsDesc_t::SetRMSTimeMS(float value) {
    SetSchemaValue(m_ptr, "VMixDynamicsDesc_t", "m_flRMSTimeMS", true, value);
}
float GVMixDynamicsDesc_t::GetWetMix() const {
    return GetSchemaValue<float>(m_ptr, "VMixDynamicsDesc_t", "m_flWetMix");
}
void GVMixDynamicsDesc_t::SetWetMix(float value) {
    SetSchemaValue(m_ptr, "VMixDynamicsDesc_t", "m_flWetMix", true, value);
}
bool GVMixDynamicsDesc_t::GetPeakMode() const {
    return GetSchemaValue<bool>(m_ptr, "VMixDynamicsDesc_t", "m_bPeakMode");
}
void GVMixDynamicsDesc_t::SetPeakMode(bool value) {
    SetSchemaValue(m_ptr, "VMixDynamicsDesc_t", "m_bPeakMode", true, value);
}
std::string GVMixDynamicsDesc_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GVMixDynamicsDesc_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassVMixDynamicsDesc_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GVMixDynamicsDesc_t>("VMixDynamicsDesc_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("FldbGain", &GVMixDynamicsDesc_t::GetFldbGain, &GVMixDynamicsDesc_t::SetFldbGain)
        .addProperty("FldbNoiseGateThreshold", &GVMixDynamicsDesc_t::GetFldbNoiseGateThreshold, &GVMixDynamicsDesc_t::SetFldbNoiseGateThreshold)
        .addProperty("FldbCompressionThreshold", &GVMixDynamicsDesc_t::GetFldbCompressionThreshold, &GVMixDynamicsDesc_t::SetFldbCompressionThreshold)
        .addProperty("FldbLimiterThreshold", &GVMixDynamicsDesc_t::GetFldbLimiterThreshold, &GVMixDynamicsDesc_t::SetFldbLimiterThreshold)
        .addProperty("FldbKneeWidth", &GVMixDynamicsDesc_t::GetFldbKneeWidth, &GVMixDynamicsDesc_t::SetFldbKneeWidth)
        .addProperty("Ratio", &GVMixDynamicsDesc_t::GetRatio, &GVMixDynamicsDesc_t::SetRatio)
        .addProperty("LimiterRatio", &GVMixDynamicsDesc_t::GetLimiterRatio, &GVMixDynamicsDesc_t::SetLimiterRatio)
        .addProperty("AttackTimeMS", &GVMixDynamicsDesc_t::GetAttackTimeMS, &GVMixDynamicsDesc_t::SetAttackTimeMS)
        .addProperty("ReleaseTimeMS", &GVMixDynamicsDesc_t::GetReleaseTimeMS, &GVMixDynamicsDesc_t::SetReleaseTimeMS)
        .addProperty("RMSTimeMS", &GVMixDynamicsDesc_t::GetRMSTimeMS, &GVMixDynamicsDesc_t::SetRMSTimeMS)
        .addProperty("WetMix", &GVMixDynamicsDesc_t::GetWetMix, &GVMixDynamicsDesc_t::SetWetMix)
        .addProperty("PeakMode", &GVMixDynamicsDesc_t::GetPeakMode, &GVMixDynamicsDesc_t::SetPeakMode)
        .addFunction("ToPtr", &GVMixDynamicsDesc_t::ToPtr)
        .addFunction("IsValid", &GVMixDynamicsDesc_t::IsValid)
        .endClass();
}
GFeVertexMapDesc_t::GFeVertexMapDesc_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GFeVertexMapDesc_t::GFeVertexMapDesc_t(void *ptr) {
    m_ptr = ptr;
}
std::string GFeVertexMapDesc_t::GetName() const {
    return GetSchemaValue<CUtlString>(m_ptr, "FeVertexMapDesc_t", "sName").Get();
}
void GFeVertexMapDesc_t::SetName(std::string value) {
    SetSchemaValue(m_ptr, "FeVertexMapDesc_t", "sName", true, CUtlString(value.c_str()));
}
uint32_t GFeVertexMapDesc_t::GetNameHash() const {
    return GetSchemaValue<uint32_t>(m_ptr, "FeVertexMapDesc_t", "nNameHash");
}
void GFeVertexMapDesc_t::SetNameHash(uint32_t value) {
    SetSchemaValue(m_ptr, "FeVertexMapDesc_t", "nNameHash", true, value);
}
uint32_t GFeVertexMapDesc_t::GetColor() const {
    return GetSchemaValue<uint32_t>(m_ptr, "FeVertexMapDesc_t", "nColor");
}
void GFeVertexMapDesc_t::SetColor(uint32_t value) {
    SetSchemaValue(m_ptr, "FeVertexMapDesc_t", "nColor", true, value);
}
uint32_t GFeVertexMapDesc_t::GetFlags() const {
    return GetSchemaValue<uint32_t>(m_ptr, "FeVertexMapDesc_t", "nFlags");
}
void GFeVertexMapDesc_t::SetFlags(uint32_t value) {
    SetSchemaValue(m_ptr, "FeVertexMapDesc_t", "nFlags", true, value);
}
uint16_t GFeVertexMapDesc_t::GetVertexBase() const {
    return GetSchemaValue<uint16_t>(m_ptr, "FeVertexMapDesc_t", "nVertexBase");
}
void GFeVertexMapDesc_t::SetVertexBase(uint16_t value) {
    SetSchemaValue(m_ptr, "FeVertexMapDesc_t", "nVertexBase", true, value);
}
uint16_t GFeVertexMapDesc_t::GetVertexCount() const {
    return GetSchemaValue<uint16_t>(m_ptr, "FeVertexMapDesc_t", "nVertexCount");
}
void GFeVertexMapDesc_t::SetVertexCount(uint16_t value) {
    SetSchemaValue(m_ptr, "FeVertexMapDesc_t", "nVertexCount", true, value);
}
uint32_t GFeVertexMapDesc_t::GetMapOffset() const {
    return GetSchemaValue<uint32_t>(m_ptr, "FeVertexMapDesc_t", "nMapOffset");
}
void GFeVertexMapDesc_t::SetMapOffset(uint32_t value) {
    SetSchemaValue(m_ptr, "FeVertexMapDesc_t", "nMapOffset", true, value);
}
uint32_t GFeVertexMapDesc_t::GetNodeListOffset() const {
    return GetSchemaValue<uint32_t>(m_ptr, "FeVertexMapDesc_t", "nNodeListOffset");
}
void GFeVertexMapDesc_t::SetNodeListOffset(uint32_t value) {
    SetSchemaValue(m_ptr, "FeVertexMapDesc_t", "nNodeListOffset", true, value);
}
Vector GFeVertexMapDesc_t::GetCenterOfMass() const {
    return GetSchemaValue<Vector>(m_ptr, "FeVertexMapDesc_t", "vCenterOfMass");
}
void GFeVertexMapDesc_t::SetCenterOfMass(Vector value) {
    SetSchemaValue(m_ptr, "FeVertexMapDesc_t", "vCenterOfMass", true, value);
}
float GFeVertexMapDesc_t::GetVolumetricSolveStrength() const {
    return GetSchemaValue<float>(m_ptr, "FeVertexMapDesc_t", "flVolumetricSolveStrength");
}
void GFeVertexMapDesc_t::SetVolumetricSolveStrength(float value) {
    SetSchemaValue(m_ptr, "FeVertexMapDesc_t", "flVolumetricSolveStrength", true, value);
}
int16_t GFeVertexMapDesc_t::GetScaleSourceNode() const {
    return GetSchemaValue<int16_t>(m_ptr, "FeVertexMapDesc_t", "nScaleSourceNode");
}
void GFeVertexMapDesc_t::SetScaleSourceNode(int16_t value) {
    SetSchemaValue(m_ptr, "FeVertexMapDesc_t", "nScaleSourceNode", true, value);
}
uint16_t GFeVertexMapDesc_t::GetNodeListCount() const {
    return GetSchemaValue<uint16_t>(m_ptr, "FeVertexMapDesc_t", "nNodeListCount");
}
void GFeVertexMapDesc_t::SetNodeListCount(uint16_t value) {
    SetSchemaValue(m_ptr, "FeVertexMapDesc_t", "nNodeListCount", true, value);
}
std::string GFeVertexMapDesc_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GFeVertexMapDesc_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassFeVertexMapDesc_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GFeVertexMapDesc_t>("FeVertexMapDesc_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Name", &GFeVertexMapDesc_t::GetName, &GFeVertexMapDesc_t::SetName)
        .addProperty("NameHash", &GFeVertexMapDesc_t::GetNameHash, &GFeVertexMapDesc_t::SetNameHash)
        .addProperty("Color", &GFeVertexMapDesc_t::GetColor, &GFeVertexMapDesc_t::SetColor)
        .addProperty("Flags", &GFeVertexMapDesc_t::GetFlags, &GFeVertexMapDesc_t::SetFlags)
        .addProperty("VertexBase", &GFeVertexMapDesc_t::GetVertexBase, &GFeVertexMapDesc_t::SetVertexBase)
        .addProperty("VertexCount", &GFeVertexMapDesc_t::GetVertexCount, &GFeVertexMapDesc_t::SetVertexCount)
        .addProperty("MapOffset", &GFeVertexMapDesc_t::GetMapOffset, &GFeVertexMapDesc_t::SetMapOffset)
        .addProperty("NodeListOffset", &GFeVertexMapDesc_t::GetNodeListOffset, &GFeVertexMapDesc_t::SetNodeListOffset)
        .addProperty("CenterOfMass", &GFeVertexMapDesc_t::GetCenterOfMass, &GFeVertexMapDesc_t::SetCenterOfMass)
        .addProperty("VolumetricSolveStrength", &GFeVertexMapDesc_t::GetVolumetricSolveStrength, &GFeVertexMapDesc_t::SetVolumetricSolveStrength)
        .addProperty("ScaleSourceNode", &GFeVertexMapDesc_t::GetScaleSourceNode, &GFeVertexMapDesc_t::SetScaleSourceNode)
        .addProperty("NodeListCount", &GFeVertexMapDesc_t::GetNodeListCount, &GFeVertexMapDesc_t::SetNodeListCount)
        .addFunction("ToPtr", &GFeVertexMapDesc_t::ToPtr)
        .addFunction("IsValid", &GFeVertexMapDesc_t::IsValid)
        .endClass();
}
GFeSourceEdge_t::GFeSourceEdge_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GFeSourceEdge_t::GFeSourceEdge_t(void *ptr) {
    m_ptr = ptr;
}
std::vector<uint16_t> GFeSourceEdge_t::GetNode() const {
    uint16_t* outValue = GetSchemaValue<uint16_t*>(m_ptr, "FeSourceEdge_t", "nNode"); std::vector<uint16_t> ret; for(int i = 0; i < 2; i++) { ret.push_back(outValue[i]); } return ret;
}
void GFeSourceEdge_t::SetNode(std::vector<uint16_t> value) {
    uint16_t* outValue = GetSchemaValue<uint16_t*>(m_ptr, "FeSourceEdge_t", "nNode"); for(int i = 0; i < 2; i++) { outValue[i] = value[i]; } SetSchemaValue(m_ptr, "FeSourceEdge_t", "nNode", true, outValue);
}
std::string GFeSourceEdge_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GFeSourceEdge_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassFeSourceEdge_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GFeSourceEdge_t>("FeSourceEdge_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Node", &GFeSourceEdge_t::GetNode, &GFeSourceEdge_t::SetNode)
        .addFunction("ToPtr", &GFeSourceEdge_t::ToPtr)
        .addFunction("IsValid", &GFeSourceEdge_t::IsValid)
        .endClass();
}
GCompositeMaterialEditorPoint_t::GCompositeMaterialEditorPoint_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCompositeMaterialEditorPoint_t::GCompositeMaterialEditorPoint_t(void *ptr) {
    m_ptr = ptr;
}
int32_t GCompositeMaterialEditorPoint_t::GetSequenceIndex() const {
    return GetSchemaValue<int32_t>(m_ptr, "CompositeMaterialEditorPoint_t", "m_nSequenceIndex");
}
void GCompositeMaterialEditorPoint_t::SetSequenceIndex(int32_t value) {
    SetSchemaValue(m_ptr, "CompositeMaterialEditorPoint_t", "m_nSequenceIndex", true, value);
}
float GCompositeMaterialEditorPoint_t::GetCycle() const {
    return GetSchemaValue<float>(m_ptr, "CompositeMaterialEditorPoint_t", "m_flCycle");
}
void GCompositeMaterialEditorPoint_t::SetCycle(float value) {
    SetSchemaValue(m_ptr, "CompositeMaterialEditorPoint_t", "m_flCycle", true, value);
}
bool GCompositeMaterialEditorPoint_t::GetEnableChildModel() const {
    return GetSchemaValue<bool>(m_ptr, "CompositeMaterialEditorPoint_t", "m_bEnableChildModel");
}
void GCompositeMaterialEditorPoint_t::SetEnableChildModel(bool value) {
    SetSchemaValue(m_ptr, "CompositeMaterialEditorPoint_t", "m_bEnableChildModel", true, value);
}
std::vector<GCompositeMaterialAssemblyProcedure_t> GCompositeMaterialEditorPoint_t::GetCompositeMaterialAssemblyProcedures() const {
    CUtlVector<GCompositeMaterialAssemblyProcedure_t>* vec = GetSchemaValue<CUtlVector<GCompositeMaterialAssemblyProcedure_t>*>(m_ptr, "CompositeMaterialEditorPoint_t", "m_vecCompositeMaterialAssemblyProcedures"); std::vector<GCompositeMaterialAssemblyProcedure_t> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCompositeMaterialEditorPoint_t::SetCompositeMaterialAssemblyProcedures(std::vector<GCompositeMaterialAssemblyProcedure_t> value) {
    SetSchemaValueCUtlVector<GCompositeMaterialAssemblyProcedure_t>(m_ptr, "CompositeMaterialEditorPoint_t", "m_vecCompositeMaterialAssemblyProcedures", true, value);
}
std::vector<GCompositeMaterial_t> GCompositeMaterialEditorPoint_t::GetCompositeMaterials() const {
    CUtlVector<GCompositeMaterial_t>* vec = GetSchemaValue<CUtlVector<GCompositeMaterial_t>*>(m_ptr, "CompositeMaterialEditorPoint_t", "m_vecCompositeMaterials"); std::vector<GCompositeMaterial_t> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCompositeMaterialEditorPoint_t::SetCompositeMaterials(std::vector<GCompositeMaterial_t> value) {
    SetSchemaValueCUtlVector<GCompositeMaterial_t>(m_ptr, "CompositeMaterialEditorPoint_t", "m_vecCompositeMaterials", true, value);
}
std::string GCompositeMaterialEditorPoint_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCompositeMaterialEditorPoint_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCompositeMaterialEditorPoint_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCompositeMaterialEditorPoint_t>("CompositeMaterialEditorPoint_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("SequenceIndex", &GCompositeMaterialEditorPoint_t::GetSequenceIndex, &GCompositeMaterialEditorPoint_t::SetSequenceIndex)
        .addProperty("Cycle", &GCompositeMaterialEditorPoint_t::GetCycle, &GCompositeMaterialEditorPoint_t::SetCycle)
        .addProperty("EnableChildModel", &GCompositeMaterialEditorPoint_t::GetEnableChildModel, &GCompositeMaterialEditorPoint_t::SetEnableChildModel)
        .addProperty("CompositeMaterialAssemblyProcedures", &GCompositeMaterialEditorPoint_t::GetCompositeMaterialAssemblyProcedures, &GCompositeMaterialEditorPoint_t::SetCompositeMaterialAssemblyProcedures)
        .addProperty("CompositeMaterials", &GCompositeMaterialEditorPoint_t::GetCompositeMaterials, &GCompositeMaterialEditorPoint_t::SetCompositeMaterials)
        .addFunction("ToPtr", &GCompositeMaterialEditorPoint_t::ToPtr)
        .addFunction("IsValid", &GCompositeMaterialEditorPoint_t::IsValid)
        .endClass();
}
GVPhysXJoint_t::GVPhysXJoint_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GVPhysXJoint_t::GVPhysXJoint_t(void *ptr) {
    m_ptr = ptr;
}
uint16_t GVPhysXJoint_t::GetType() const {
    return GetSchemaValue<uint16_t>(m_ptr, "VPhysXJoint_t", "m_nType");
}
void GVPhysXJoint_t::SetType(uint16_t value) {
    SetSchemaValue(m_ptr, "VPhysXJoint_t", "m_nType", true, value);
}
uint16_t GVPhysXJoint_t::GetBody1() const {
    return GetSchemaValue<uint16_t>(m_ptr, "VPhysXJoint_t", "m_nBody1");
}
void GVPhysXJoint_t::SetBody1(uint16_t value) {
    SetSchemaValue(m_ptr, "VPhysXJoint_t", "m_nBody1", true, value);
}
uint16_t GVPhysXJoint_t::GetBody2() const {
    return GetSchemaValue<uint16_t>(m_ptr, "VPhysXJoint_t", "m_nBody2");
}
void GVPhysXJoint_t::SetBody2(uint16_t value) {
    SetSchemaValue(m_ptr, "VPhysXJoint_t", "m_nBody2", true, value);
}
uint16_t GVPhysXJoint_t::GetFlags() const {
    return GetSchemaValue<uint16_t>(m_ptr, "VPhysXJoint_t", "m_nFlags");
}
void GVPhysXJoint_t::SetFlags(uint16_t value) {
    SetSchemaValue(m_ptr, "VPhysXJoint_t", "m_nFlags", true, value);
}
bool GVPhysXJoint_t::GetEnableCollision() const {
    return GetSchemaValue<bool>(m_ptr, "VPhysXJoint_t", "m_bEnableCollision");
}
void GVPhysXJoint_t::SetEnableCollision(bool value) {
    SetSchemaValue(m_ptr, "VPhysXJoint_t", "m_bEnableCollision", true, value);
}
bool GVPhysXJoint_t::GetEnableLinearLimit() const {
    return GetSchemaValue<bool>(m_ptr, "VPhysXJoint_t", "m_bEnableLinearLimit");
}
void GVPhysXJoint_t::SetEnableLinearLimit(bool value) {
    SetSchemaValue(m_ptr, "VPhysXJoint_t", "m_bEnableLinearLimit", true, value);
}
GVPhysXRange_t GVPhysXJoint_t::GetLinearLimit() const {
    GVPhysXRange_t value(GetSchemaPtr(m_ptr, "VPhysXJoint_t", "m_LinearLimit"));
    return value;
}
void GVPhysXJoint_t::SetLinearLimit(GVPhysXRange_t value) {
    SetSchemaValue(m_ptr, "VPhysXJoint_t", "m_LinearLimit", true, value);
}
bool GVPhysXJoint_t::GetEnableLinearMotor() const {
    return GetSchemaValue<bool>(m_ptr, "VPhysXJoint_t", "m_bEnableLinearMotor");
}
void GVPhysXJoint_t::SetEnableLinearMotor(bool value) {
    SetSchemaValue(m_ptr, "VPhysXJoint_t", "m_bEnableLinearMotor", true, value);
}
Vector GVPhysXJoint_t::GetLinearTargetVelocity() const {
    return GetSchemaValue<Vector>(m_ptr, "VPhysXJoint_t", "m_vLinearTargetVelocity");
}
void GVPhysXJoint_t::SetLinearTargetVelocity(Vector value) {
    SetSchemaValue(m_ptr, "VPhysXJoint_t", "m_vLinearTargetVelocity", true, value);
}
float GVPhysXJoint_t::GetMaxForce() const {
    return GetSchemaValue<float>(m_ptr, "VPhysXJoint_t", "m_flMaxForce");
}
void GVPhysXJoint_t::SetMaxForce(float value) {
    SetSchemaValue(m_ptr, "VPhysXJoint_t", "m_flMaxForce", true, value);
}
bool GVPhysXJoint_t::GetEnableSwingLimit() const {
    return GetSchemaValue<bool>(m_ptr, "VPhysXJoint_t", "m_bEnableSwingLimit");
}
void GVPhysXJoint_t::SetEnableSwingLimit(bool value) {
    SetSchemaValue(m_ptr, "VPhysXJoint_t", "m_bEnableSwingLimit", true, value);
}
GVPhysXRange_t GVPhysXJoint_t::GetSwingLimit() const {
    GVPhysXRange_t value(GetSchemaPtr(m_ptr, "VPhysXJoint_t", "m_SwingLimit"));
    return value;
}
void GVPhysXJoint_t::SetSwingLimit(GVPhysXRange_t value) {
    SetSchemaValue(m_ptr, "VPhysXJoint_t", "m_SwingLimit", true, value);
}
bool GVPhysXJoint_t::GetEnableTwistLimit() const {
    return GetSchemaValue<bool>(m_ptr, "VPhysXJoint_t", "m_bEnableTwistLimit");
}
void GVPhysXJoint_t::SetEnableTwistLimit(bool value) {
    SetSchemaValue(m_ptr, "VPhysXJoint_t", "m_bEnableTwistLimit", true, value);
}
GVPhysXRange_t GVPhysXJoint_t::GetTwistLimit() const {
    GVPhysXRange_t value(GetSchemaPtr(m_ptr, "VPhysXJoint_t", "m_TwistLimit"));
    return value;
}
void GVPhysXJoint_t::SetTwistLimit(GVPhysXRange_t value) {
    SetSchemaValue(m_ptr, "VPhysXJoint_t", "m_TwistLimit", true, value);
}
bool GVPhysXJoint_t::GetEnableAngularMotor() const {
    return GetSchemaValue<bool>(m_ptr, "VPhysXJoint_t", "m_bEnableAngularMotor");
}
void GVPhysXJoint_t::SetEnableAngularMotor(bool value) {
    SetSchemaValue(m_ptr, "VPhysXJoint_t", "m_bEnableAngularMotor", true, value);
}
Vector GVPhysXJoint_t::GetAngularTargetVelocity() const {
    return GetSchemaValue<Vector>(m_ptr, "VPhysXJoint_t", "m_vAngularTargetVelocity");
}
void GVPhysXJoint_t::SetAngularTargetVelocity(Vector value) {
    SetSchemaValue(m_ptr, "VPhysXJoint_t", "m_vAngularTargetVelocity", true, value);
}
float GVPhysXJoint_t::GetMaxTorque() const {
    return GetSchemaValue<float>(m_ptr, "VPhysXJoint_t", "m_flMaxTorque");
}
void GVPhysXJoint_t::SetMaxTorque(float value) {
    SetSchemaValue(m_ptr, "VPhysXJoint_t", "m_flMaxTorque", true, value);
}
float GVPhysXJoint_t::GetLinearFrequency() const {
    return GetSchemaValue<float>(m_ptr, "VPhysXJoint_t", "m_flLinearFrequency");
}
void GVPhysXJoint_t::SetLinearFrequency(float value) {
    SetSchemaValue(m_ptr, "VPhysXJoint_t", "m_flLinearFrequency", true, value);
}
float GVPhysXJoint_t::GetLinearDampingRatio() const {
    return GetSchemaValue<float>(m_ptr, "VPhysXJoint_t", "m_flLinearDampingRatio");
}
void GVPhysXJoint_t::SetLinearDampingRatio(float value) {
    SetSchemaValue(m_ptr, "VPhysXJoint_t", "m_flLinearDampingRatio", true, value);
}
float GVPhysXJoint_t::GetAngularFrequency() const {
    return GetSchemaValue<float>(m_ptr, "VPhysXJoint_t", "m_flAngularFrequency");
}
void GVPhysXJoint_t::SetAngularFrequency(float value) {
    SetSchemaValue(m_ptr, "VPhysXJoint_t", "m_flAngularFrequency", true, value);
}
float GVPhysXJoint_t::GetAngularDampingRatio() const {
    return GetSchemaValue<float>(m_ptr, "VPhysXJoint_t", "m_flAngularDampingRatio");
}
void GVPhysXJoint_t::SetAngularDampingRatio(float value) {
    SetSchemaValue(m_ptr, "VPhysXJoint_t", "m_flAngularDampingRatio", true, value);
}
float GVPhysXJoint_t::GetFriction() const {
    return GetSchemaValue<float>(m_ptr, "VPhysXJoint_t", "m_flFriction");
}
void GVPhysXJoint_t::SetFriction(float value) {
    SetSchemaValue(m_ptr, "VPhysXJoint_t", "m_flFriction", true, value);
}
std::string GVPhysXJoint_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GVPhysXJoint_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassVPhysXJoint_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GVPhysXJoint_t>("VPhysXJoint_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Type", &GVPhysXJoint_t::GetType, &GVPhysXJoint_t::SetType)
        .addProperty("Body1", &GVPhysXJoint_t::GetBody1, &GVPhysXJoint_t::SetBody1)
        .addProperty("Body2", &GVPhysXJoint_t::GetBody2, &GVPhysXJoint_t::SetBody2)
        .addProperty("Flags", &GVPhysXJoint_t::GetFlags, &GVPhysXJoint_t::SetFlags)
        .addProperty("EnableCollision", &GVPhysXJoint_t::GetEnableCollision, &GVPhysXJoint_t::SetEnableCollision)
        .addProperty("EnableLinearLimit", &GVPhysXJoint_t::GetEnableLinearLimit, &GVPhysXJoint_t::SetEnableLinearLimit)
        .addProperty("LinearLimit", &GVPhysXJoint_t::GetLinearLimit, &GVPhysXJoint_t::SetLinearLimit)
        .addProperty("EnableLinearMotor", &GVPhysXJoint_t::GetEnableLinearMotor, &GVPhysXJoint_t::SetEnableLinearMotor)
        .addProperty("LinearTargetVelocity", &GVPhysXJoint_t::GetLinearTargetVelocity, &GVPhysXJoint_t::SetLinearTargetVelocity)
        .addProperty("MaxForce", &GVPhysXJoint_t::GetMaxForce, &GVPhysXJoint_t::SetMaxForce)
        .addProperty("EnableSwingLimit", &GVPhysXJoint_t::GetEnableSwingLimit, &GVPhysXJoint_t::SetEnableSwingLimit)
        .addProperty("SwingLimit", &GVPhysXJoint_t::GetSwingLimit, &GVPhysXJoint_t::SetSwingLimit)
        .addProperty("EnableTwistLimit", &GVPhysXJoint_t::GetEnableTwistLimit, &GVPhysXJoint_t::SetEnableTwistLimit)
        .addProperty("TwistLimit", &GVPhysXJoint_t::GetTwistLimit, &GVPhysXJoint_t::SetTwistLimit)
        .addProperty("EnableAngularMotor", &GVPhysXJoint_t::GetEnableAngularMotor, &GVPhysXJoint_t::SetEnableAngularMotor)
        .addProperty("AngularTargetVelocity", &GVPhysXJoint_t::GetAngularTargetVelocity, &GVPhysXJoint_t::SetAngularTargetVelocity)
        .addProperty("MaxTorque", &GVPhysXJoint_t::GetMaxTorque, &GVPhysXJoint_t::SetMaxTorque)
        .addProperty("LinearFrequency", &GVPhysXJoint_t::GetLinearFrequency, &GVPhysXJoint_t::SetLinearFrequency)
        .addProperty("LinearDampingRatio", &GVPhysXJoint_t::GetLinearDampingRatio, &GVPhysXJoint_t::SetLinearDampingRatio)
        .addProperty("AngularFrequency", &GVPhysXJoint_t::GetAngularFrequency, &GVPhysXJoint_t::SetAngularFrequency)
        .addProperty("AngularDampingRatio", &GVPhysXJoint_t::GetAngularDampingRatio, &GVPhysXJoint_t::SetAngularDampingRatio)
        .addProperty("Friction", &GVPhysXJoint_t::GetFriction, &GVPhysXJoint_t::SetFriction)
        .addFunction("ToPtr", &GVPhysXJoint_t::ToPtr)
        .addFunction("IsValid", &GVPhysXJoint_t::IsValid)
        .endClass();
}
GCBodyGroupSetting::GCBodyGroupSetting(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCBodyGroupSetting::GCBodyGroupSetting(void *ptr) {
    m_ptr = ptr;
}
std::string GCBodyGroupSetting::GetBodyGroupName() const {
    return GetSchemaValue<CUtlString>(m_ptr, "CBodyGroupSetting", "m_BodyGroupName").Get();
}
void GCBodyGroupSetting::SetBodyGroupName(std::string value) {
    SetSchemaValue(m_ptr, "CBodyGroupSetting", "m_BodyGroupName", false, CUtlString(value.c_str()));
}
int32_t GCBodyGroupSetting::GetBodyGroupOption() const {
    return GetSchemaValue<int32_t>(m_ptr, "CBodyGroupSetting", "m_nBodyGroupOption");
}
void GCBodyGroupSetting::SetBodyGroupOption(int32_t value) {
    SetSchemaValue(m_ptr, "CBodyGroupSetting", "m_nBodyGroupOption", false, value);
}
std::string GCBodyGroupSetting::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCBodyGroupSetting::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCBodyGroupSetting(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCBodyGroupSetting>("CBodyGroupSetting")
        .addConstructor<void (*)(std::string)>()
        .addProperty("BodyGroupName", &GCBodyGroupSetting::GetBodyGroupName, &GCBodyGroupSetting::SetBodyGroupName)
        .addProperty("BodyGroupOption", &GCBodyGroupSetting::GetBodyGroupOption, &GCBodyGroupSetting::SetBodyGroupOption)
        .addFunction("ToPtr", &GCBodyGroupSetting::ToPtr)
        .addFunction("IsValid", &GCBodyGroupSetting::IsValid)
        .endClass();
}
GRnSphereDesc_t::GRnSphereDesc_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GRnSphereDesc_t::GRnSphereDesc_t(void *ptr) {
    m_ptr = ptr;
}
std::string GRnSphereDesc_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GRnSphereDesc_t::IsValid() {
    return (m_ptr != nullptr);
}
GRnShapeDesc_t GRnSphereDesc_t::GetParent() const {
    GRnShapeDesc_t value(m_ptr);
    return value;
}
void GRnSphereDesc_t::SetParent(GRnShapeDesc_t value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassRnSphereDesc_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GRnSphereDesc_t>("RnSphereDesc_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GRnSphereDesc_t::GetParent, &GRnSphereDesc_t::SetParent)
        .addFunction("ToPtr", &GRnSphereDesc_t::ToPtr)
        .addFunction("IsValid", &GRnSphereDesc_t::IsValid)
        .endClass();
}
GCNmTarget::GCNmTarget(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCNmTarget::GCNmTarget(void *ptr) {
    m_ptr = ptr;
}
bool GCNmTarget::GetIsBoneTarget() const {
    return GetSchemaValue<bool>(m_ptr, "CNmTarget", "m_bIsBoneTarget");
}
void GCNmTarget::SetIsBoneTarget(bool value) {
    SetSchemaValue(m_ptr, "CNmTarget", "m_bIsBoneTarget", false, value);
}
bool GCNmTarget::GetIsUsingBoneSpaceOffsets() const {
    return GetSchemaValue<bool>(m_ptr, "CNmTarget", "m_bIsUsingBoneSpaceOffsets");
}
void GCNmTarget::SetIsUsingBoneSpaceOffsets(bool value) {
    SetSchemaValue(m_ptr, "CNmTarget", "m_bIsUsingBoneSpaceOffsets", false, value);
}
bool GCNmTarget::GetHasOffsets() const {
    return GetSchemaValue<bool>(m_ptr, "CNmTarget", "m_bHasOffsets");
}
void GCNmTarget::SetHasOffsets(bool value) {
    SetSchemaValue(m_ptr, "CNmTarget", "m_bHasOffsets", false, value);
}
bool GCNmTarget::GetIsSet() const {
    return GetSchemaValue<bool>(m_ptr, "CNmTarget", "m_bIsSet");
}
void GCNmTarget::SetIsSet(bool value) {
    SetSchemaValue(m_ptr, "CNmTarget", "m_bIsSet", false, value);
}
std::string GCNmTarget::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCNmTarget::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCNmTarget(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCNmTarget>("CNmTarget")
        .addConstructor<void (*)(std::string)>()
        .addProperty("IsBoneTarget", &GCNmTarget::GetIsBoneTarget, &GCNmTarget::SetIsBoneTarget)
        .addProperty("IsUsingBoneSpaceOffsets", &GCNmTarget::GetIsUsingBoneSpaceOffsets, &GCNmTarget::SetIsUsingBoneSpaceOffsets)
        .addProperty("HasOffsets", &GCNmTarget::GetHasOffsets, &GCNmTarget::SetHasOffsets)
        .addProperty("IsSet", &GCNmTarget::GetIsSet, &GCNmTarget::SetIsSet)
        .addFunction("ToPtr", &GCNmTarget::ToPtr)
        .addFunction("IsValid", &GCNmTarget::IsValid)
        .endClass();
}