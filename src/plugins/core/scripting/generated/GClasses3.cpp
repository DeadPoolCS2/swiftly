#include "classes.h"

#include "../../../lua/scripting/core.h"
#include "../../../../crashreporter/CallStack.h"
#include "../../../../sdk/entity/CBaseEntity.h"
#include "../../../../sdk/entity/CBasePlayerController.h"
#include "../../../../sdk/entity/CBaseModelEntity.h"
#include "../../../../sdk/entity/CRecipientFilters.h"
#include "../../../../player/PlayerManager.h"

GRnFace_t::GRnFace_t(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GRnFace_t::GRnFace_t(void *ptr) {
    m_ptr = ptr;
}
uint32_t GRnFace_t::GetEdge() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: RnFace_t->Edge(ptr=%p)", m_ptr));
    return GetSchemaValue<uint32_t>(m_ptr, "RnFace_t", "m_nEdge");
}
void GRnFace_t::SetEdge(uint32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: RnFace_t->Edge(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "RnFace_t", "m_nEdge", true, value);
}
void* GRnFace_t::GetPtr() {
    return m_ptr;
}
std::string GRnFace_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GRnFace_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassRnFace_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GRnFace_t>("RnFace_t")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Edge", &GRnFace_t::GetEdge, &GRnFace_t::SetEdge)
        .addFunction("ToPtr", &GRnFace_t::ToPtr)
        .addFunction("IsValid", &GRnFace_t::IsValid)
        .endClass();
}
GEngineLoopState_t::GEngineLoopState_t(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GEngineLoopState_t::GEngineLoopState_t(void *ptr) {
    m_ptr = ptr;
}
int32_t GEngineLoopState_t::GetPlatWindowWidth() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: EngineLoopState_t->PlatWindowWidth(ptr=%p)", m_ptr));
    return GetSchemaValue<int32_t>(m_ptr, "EngineLoopState_t", "m_nPlatWindowWidth");
}
void GEngineLoopState_t::SetPlatWindowWidth(int32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: EngineLoopState_t->PlatWindowWidth(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "EngineLoopState_t", "m_nPlatWindowWidth", true, value);
}
int32_t GEngineLoopState_t::GetPlatWindowHeight() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: EngineLoopState_t->PlatWindowHeight(ptr=%p)", m_ptr));
    return GetSchemaValue<int32_t>(m_ptr, "EngineLoopState_t", "m_nPlatWindowHeight");
}
void GEngineLoopState_t::SetPlatWindowHeight(int32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: EngineLoopState_t->PlatWindowHeight(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "EngineLoopState_t", "m_nPlatWindowHeight", true, value);
}
int32_t GEngineLoopState_t::GetRenderWidth() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: EngineLoopState_t->RenderWidth(ptr=%p)", m_ptr));
    return GetSchemaValue<int32_t>(m_ptr, "EngineLoopState_t", "m_nRenderWidth");
}
void GEngineLoopState_t::SetRenderWidth(int32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: EngineLoopState_t->RenderWidth(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "EngineLoopState_t", "m_nRenderWidth", true, value);
}
int32_t GEngineLoopState_t::GetRenderHeight() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: EngineLoopState_t->RenderHeight(ptr=%p)", m_ptr));
    return GetSchemaValue<int32_t>(m_ptr, "EngineLoopState_t", "m_nRenderHeight");
}
void GEngineLoopState_t::SetRenderHeight(int32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: EngineLoopState_t->RenderHeight(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "EngineLoopState_t", "m_nRenderHeight", true, value);
}
void* GEngineLoopState_t::GetPtr() {
    return m_ptr;
}
std::string GEngineLoopState_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GEngineLoopState_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassEngineLoopState_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GEngineLoopState_t>("EngineLoopState_t")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("PlatWindowWidth", &GEngineLoopState_t::GetPlatWindowWidth, &GEngineLoopState_t::SetPlatWindowWidth)
        .addProperty("PlatWindowHeight", &GEngineLoopState_t::GetPlatWindowHeight, &GEngineLoopState_t::SetPlatWindowHeight)
        .addProperty("RenderWidth", &GEngineLoopState_t::GetRenderWidth, &GEngineLoopState_t::SetRenderWidth)
        .addProperty("RenderHeight", &GEngineLoopState_t::GetRenderHeight, &GEngineLoopState_t::SetRenderHeight)
        .addFunction("ToPtr", &GEngineLoopState_t::ToPtr)
        .addFunction("IsValid", &GEngineLoopState_t::IsValid)
        .endClass();
}
GCNmPoseNode::GCNmPoseNode(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCNmPoseNode::GCNmPoseNode(void *ptr) {
    m_ptr = ptr;
}
void* GCNmPoseNode::GetPtr() {
    return m_ptr;
}
std::string GCNmPoseNode::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCNmPoseNode::IsValid() {
    return (m_ptr != nullptr);
}
GCNmGraphNode GCNmPoseNode::GetParent() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CNmPoseNode::GetParent(ptr=%p)", m_ptr));
    GCNmGraphNode value(m_ptr);
    return value;
}
void GCNmPoseNode::SetParent(GCNmGraphNode value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CNmPoseNode::SetParent(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCNmPoseNode(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCNmPoseNode>("CNmPoseNode")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Parent", &GCNmPoseNode::GetParent, &GCNmPoseNode::SetParent)
        .addFunction("ToPtr", &GCNmPoseNode::ToPtr)
        .addFunction("IsValid", &GCNmPoseNode::IsValid)
        .endClass();
}
GCParticleFunctionConstraint::GCParticleFunctionConstraint(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCParticleFunctionConstraint::GCParticleFunctionConstraint(void *ptr) {
    m_ptr = ptr;
}
void* GCParticleFunctionConstraint::GetPtr() {
    return m_ptr;
}
std::string GCParticleFunctionConstraint::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCParticleFunctionConstraint::IsValid() {
    return (m_ptr != nullptr);
}
GCParticleFunction GCParticleFunctionConstraint::GetParent() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CParticleFunctionConstraint::GetParent(ptr=%p)", m_ptr));
    GCParticleFunction value(m_ptr);
    return value;
}
void GCParticleFunctionConstraint::SetParent(GCParticleFunction value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CParticleFunctionConstraint::SetParent(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCParticleFunctionConstraint(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCParticleFunctionConstraint>("CParticleFunctionConstraint")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Parent", &GCParticleFunctionConstraint::GetParent, &GCParticleFunctionConstraint::SetParent)
        .addFunction("ToPtr", &GCParticleFunctionConstraint::ToPtr)
        .addFunction("IsValid", &GCParticleFunctionConstraint::IsValid)
        .endClass();
}
GCNmStateMachineNode__TransitionDefinition_t::GCNmStateMachineNode__TransitionDefinition_t(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCNmStateMachineNode__TransitionDefinition_t::GCNmStateMachineNode__TransitionDefinition_t(void *ptr) {
    m_ptr = ptr;
}
int16_t GCNmStateMachineNode__TransitionDefinition_t::GetTargetStateIdx() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CNmStateMachineNode__TransitionDefinition_t->TargetStateIdx(ptr=%p)", m_ptr));
    return GetSchemaValue<int16_t>(m_ptr, "CNmStateMachineNode__TransitionDefinition_t", "m_nTargetStateIdx");
}
void GCNmStateMachineNode__TransitionDefinition_t::SetTargetStateIdx(int16_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CNmStateMachineNode__TransitionDefinition_t->TargetStateIdx(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CNmStateMachineNode__TransitionDefinition_t", "m_nTargetStateIdx", true, value);
}
int16_t GCNmStateMachineNode__TransitionDefinition_t::GetConditionNodeIdx() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CNmStateMachineNode__TransitionDefinition_t->ConditionNodeIdx(ptr=%p)", m_ptr));
    return GetSchemaValue<int16_t>(m_ptr, "CNmStateMachineNode__TransitionDefinition_t", "m_nConditionNodeIdx");
}
void GCNmStateMachineNode__TransitionDefinition_t::SetConditionNodeIdx(int16_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CNmStateMachineNode__TransitionDefinition_t->ConditionNodeIdx(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CNmStateMachineNode__TransitionDefinition_t", "m_nConditionNodeIdx", true, value);
}
int16_t GCNmStateMachineNode__TransitionDefinition_t::GetTransitionNodeIdx() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CNmStateMachineNode__TransitionDefinition_t->TransitionNodeIdx(ptr=%p)", m_ptr));
    return GetSchemaValue<int16_t>(m_ptr, "CNmStateMachineNode__TransitionDefinition_t", "m_nTransitionNodeIdx");
}
void GCNmStateMachineNode__TransitionDefinition_t::SetTransitionNodeIdx(int16_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CNmStateMachineNode__TransitionDefinition_t->TransitionNodeIdx(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CNmStateMachineNode__TransitionDefinition_t", "m_nTransitionNodeIdx", true, value);
}
bool GCNmStateMachineNode__TransitionDefinition_t::GetCanBeForced() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CNmStateMachineNode__TransitionDefinition_t->CanBeForced(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "CNmStateMachineNode__TransitionDefinition_t", "m_bCanBeForced");
}
void GCNmStateMachineNode__TransitionDefinition_t::SetCanBeForced(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CNmStateMachineNode__TransitionDefinition_t->CanBeForced(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CNmStateMachineNode__TransitionDefinition_t", "m_bCanBeForced", true, value);
}
void* GCNmStateMachineNode__TransitionDefinition_t::GetPtr() {
    return m_ptr;
}
std::string GCNmStateMachineNode__TransitionDefinition_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCNmStateMachineNode__TransitionDefinition_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCNmStateMachineNode__TransitionDefinition_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCNmStateMachineNode__TransitionDefinition_t>("CNmStateMachineNode__TransitionDefinition_t")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("TargetStateIdx", &GCNmStateMachineNode__TransitionDefinition_t::GetTargetStateIdx, &GCNmStateMachineNode__TransitionDefinition_t::SetTargetStateIdx)
        .addProperty("ConditionNodeIdx", &GCNmStateMachineNode__TransitionDefinition_t::GetConditionNodeIdx, &GCNmStateMachineNode__TransitionDefinition_t::SetConditionNodeIdx)
        .addProperty("TransitionNodeIdx", &GCNmStateMachineNode__TransitionDefinition_t::GetTransitionNodeIdx, &GCNmStateMachineNode__TransitionDefinition_t::SetTransitionNodeIdx)
        .addProperty("CanBeForced", &GCNmStateMachineNode__TransitionDefinition_t::GetCanBeForced, &GCNmStateMachineNode__TransitionDefinition_t::SetCanBeForced)
        .addFunction("ToPtr", &GCNmStateMachineNode__TransitionDefinition_t::ToPtr)
        .addFunction("IsValid", &GCNmStateMachineNode__TransitionDefinition_t::IsValid)
        .endClass();
}
GCAnimAttachment::GCAnimAttachment(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCAnimAttachment::GCAnimAttachment(void *ptr) {
    m_ptr = ptr;
}
std::vector<Vector> GCAnimAttachment::GetInfluenceOffsets() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CAnimAttachment->InfluenceOffsets(ptr=%p,size=3)", m_ptr));
    Vector* outValue = (Vector*)GetSchemaPtr(m_ptr, "CAnimAttachment", "m_influenceOffsets"); std::vector<Vector> ret; for(int i = 0; i < 3; i++) { ret.push_back(outValue[i]); } return ret;
}
void GCAnimAttachment::SetInfluenceOffsets(std::vector<Vector> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CAnimAttachment->InfluenceOffsets(ptr=%p,size=3)", m_ptr));
    if(value.size() != 3) return PLUGIN_PRINT("Schema SDK", "Field 'InfluenceOffsets' needs to have 3 values.\n");
    auto val = GetSchemaValuePtr<Vector>(m_ptr, "CAnimAttachment", "m_influenceOffsets");
    for(size_t i = 0; i < value.size(); i++) val[i] = value[i];
}
std::vector<int32_t> GCAnimAttachment::GetInfluenceIndices() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CAnimAttachment->InfluenceIndices(ptr=%p,size=3)", m_ptr));
    int32_t* outValue = (int32_t*)GetSchemaPtr(m_ptr, "CAnimAttachment", "m_influenceIndices"); std::vector<int32_t> ret; for(int i = 0; i < 3; i++) { ret.push_back(outValue[i]); } return ret;
}
void GCAnimAttachment::SetInfluenceIndices(std::vector<int32_t> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CAnimAttachment->InfluenceIndices(ptr=%p,size=3)", m_ptr));
    if(value.size() != 3) return PLUGIN_PRINT("Schema SDK", "Field 'InfluenceIndices' needs to have 3 values.\n");
    auto val = GetSchemaValuePtr<int32_t>(m_ptr, "CAnimAttachment", "m_influenceIndices");
    for(size_t i = 0; i < value.size(); i++) val[i] = value[i];
}
std::vector<float> GCAnimAttachment::GetInfluenceWeights() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CAnimAttachment->InfluenceWeights(ptr=%p,size=3)", m_ptr));
    float* outValue = (float*)GetSchemaPtr(m_ptr, "CAnimAttachment", "m_influenceWeights"); std::vector<float> ret; for(int i = 0; i < 3; i++) { ret.push_back(outValue[i]); } return ret;
}
void GCAnimAttachment::SetInfluenceWeights(std::vector<float> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CAnimAttachment->InfluenceWeights(ptr=%p,size=3)", m_ptr));
    if(value.size() != 3) return PLUGIN_PRINT("Schema SDK", "Field 'InfluenceWeights' needs to have 3 values.\n");
    auto val = GetSchemaValuePtr<float>(m_ptr, "CAnimAttachment", "m_influenceWeights");
    for(size_t i = 0; i < value.size(); i++) val[i] = value[i];
}
uint32_t GCAnimAttachment::GetNumInfluences() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CAnimAttachment->NumInfluences(ptr=%p)", m_ptr));
    return GetSchemaValue<uint32_t>(m_ptr, "CAnimAttachment", "m_numInfluences");
}
void GCAnimAttachment::SetNumInfluences(uint32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CAnimAttachment->NumInfluences(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CAnimAttachment", "m_numInfluences", false, value);
}
void* GCAnimAttachment::GetPtr() {
    return m_ptr;
}
std::string GCAnimAttachment::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCAnimAttachment::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCAnimAttachment(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCAnimAttachment>("CAnimAttachment")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("InfluenceOffsets", &GCAnimAttachment::GetInfluenceOffsets, &GCAnimAttachment::SetInfluenceOffsets)
        .addProperty("InfluenceIndices", &GCAnimAttachment::GetInfluenceIndices, &GCAnimAttachment::SetInfluenceIndices)
        .addProperty("InfluenceWeights", &GCAnimAttachment::GetInfluenceWeights, &GCAnimAttachment::SetInfluenceWeights)
        .addProperty("NumInfluences", &GCAnimAttachment::GetNumInfluences, &GCAnimAttachment::SetNumInfluences)
        .addFunction("ToPtr", &GCAnimAttachment::ToPtr)
        .addFunction("IsValid", &GCAnimAttachment::IsValid)
        .endClass();
}
GEventSimulate_t::GEventSimulate_t(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GEventSimulate_t::GEventSimulate_t(void *ptr) {
    m_ptr = ptr;
}
GEngineLoopState_t GEventSimulate_t::GetLoopState() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: EventSimulate_t->LoopState(ptr=%p)", m_ptr));
    GEngineLoopState_t value(GetSchemaPtr(m_ptr, "EventSimulate_t", "m_LoopState"));
    return value;
}
void GEventSimulate_t::SetLoopState(GEngineLoopState_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: EventSimulate_t->LoopState(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'LoopState' is not possible.\n");
}
bool GEventSimulate_t::GetFirstTick() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: EventSimulate_t->FirstTick(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "EventSimulate_t", "m_bFirstTick");
}
void GEventSimulate_t::SetFirstTick(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: EventSimulate_t->FirstTick(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "EventSimulate_t", "m_bFirstTick", true, value);
}
bool GEventSimulate_t::GetLastTick() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: EventSimulate_t->LastTick(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "EventSimulate_t", "m_bLastTick");
}
void GEventSimulate_t::SetLastTick(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: EventSimulate_t->LastTick(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "EventSimulate_t", "m_bLastTick", true, value);
}
void* GEventSimulate_t::GetPtr() {
    return m_ptr;
}
std::string GEventSimulate_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GEventSimulate_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassEventSimulate_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GEventSimulate_t>("EventSimulate_t")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("LoopState", &GEventSimulate_t::GetLoopState, &GEventSimulate_t::SetLoopState)
        .addProperty("FirstTick", &GEventSimulate_t::GetFirstTick, &GEventSimulate_t::SetFirstTick)
        .addProperty("LastTick", &GEventSimulate_t::GetLastTick, &GEventSimulate_t::SetLastTick)
        .addFunction("ToPtr", &GEventSimulate_t::ToPtr)
        .addFunction("IsValid", &GEventSimulate_t::IsValid)
        .endClass();
}
GCParticleCollectionRendererFloatInput::GCParticleCollectionRendererFloatInput(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCParticleCollectionRendererFloatInput::GCParticleCollectionRendererFloatInput(void *ptr) {
    m_ptr = ptr;
}
void* GCParticleCollectionRendererFloatInput::GetPtr() {
    return m_ptr;
}
std::string GCParticleCollectionRendererFloatInput::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCParticleCollectionRendererFloatInput::IsValid() {
    return (m_ptr != nullptr);
}
GCParticleCollectionFloatInput GCParticleCollectionRendererFloatInput::GetParent() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CParticleCollectionRendererFloatInput::GetParent(ptr=%p)", m_ptr));
    GCParticleCollectionFloatInput value(m_ptr);
    return value;
}
void GCParticleCollectionRendererFloatInput::SetParent(GCParticleCollectionFloatInput value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CParticleCollectionRendererFloatInput::SetParent(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCParticleCollectionRendererFloatInput(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCParticleCollectionRendererFloatInput>("CParticleCollectionRendererFloatInput")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Parent", &GCParticleCollectionRendererFloatInput::GetParent, &GCParticleCollectionRendererFloatInput::SetParent)
        .addFunction("ToPtr", &GCParticleCollectionRendererFloatInput::ToPtr)
        .addFunction("IsValid", &GCParticleCollectionRendererFloatInput::IsValid)
        .endClass();
}
GModelSkeletonData_t::GModelSkeletonData_t(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GModelSkeletonData_t::GModelSkeletonData_t(void *ptr) {
    m_ptr = ptr;
}
std::vector<CUtlString> GModelSkeletonData_t::GetBoneName() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: ModelSkeletonData_t->BoneName(ptr=%p)", m_ptr));
    CUtlVector<CUtlString>* vec = GetSchemaValue<CUtlVector<CUtlString>*>(m_ptr, "ModelSkeletonData_t", "m_boneName"); std::vector<CUtlString> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GModelSkeletonData_t::SetBoneName(std::vector<CUtlString> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: ModelSkeletonData_t->BoneName(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<CUtlString>(m_ptr, "ModelSkeletonData_t", "m_boneName", true, value);
}
std::vector<int16> GModelSkeletonData_t::GetParent() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: ModelSkeletonData_t->Parent(ptr=%p)", m_ptr));
    CUtlVector<int16>* vec = GetSchemaValue<CUtlVector<int16>*>(m_ptr, "ModelSkeletonData_t", "m_nParent"); std::vector<int16> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GModelSkeletonData_t::SetParent(std::vector<int16> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: ModelSkeletonData_t->Parent(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<int16>(m_ptr, "ModelSkeletonData_t", "m_nParent", true, value);
}
std::vector<float32> GModelSkeletonData_t::GetBoneSphere() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: ModelSkeletonData_t->BoneSphere(ptr=%p)", m_ptr));
    CUtlVector<float32>* vec = GetSchemaValue<CUtlVector<float32>*>(m_ptr, "ModelSkeletonData_t", "m_boneSphere"); std::vector<float32> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GModelSkeletonData_t::SetBoneSphere(std::vector<float32> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: ModelSkeletonData_t->BoneSphere(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<float32>(m_ptr, "ModelSkeletonData_t", "m_boneSphere", true, value);
}
std::vector<uint32> GModelSkeletonData_t::GetFlag() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: ModelSkeletonData_t->Flag(ptr=%p)", m_ptr));
    CUtlVector<uint32>* vec = GetSchemaValue<CUtlVector<uint32>*>(m_ptr, "ModelSkeletonData_t", "m_nFlag"); std::vector<uint32> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GModelSkeletonData_t::SetFlag(std::vector<uint32> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: ModelSkeletonData_t->Flag(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<uint32>(m_ptr, "ModelSkeletonData_t", "m_nFlag", true, value);
}
std::vector<Vector> GModelSkeletonData_t::GetBonePosParent() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: ModelSkeletonData_t->BonePosParent(ptr=%p)", m_ptr));
    CUtlVector<Vector>* vec = GetSchemaValue<CUtlVector<Vector>*>(m_ptr, "ModelSkeletonData_t", "m_bonePosParent"); std::vector<Vector> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GModelSkeletonData_t::SetBonePosParent(std::vector<Vector> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: ModelSkeletonData_t->BonePosParent(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<Vector>(m_ptr, "ModelSkeletonData_t", "m_bonePosParent", true, value);
}
std::vector<float32> GModelSkeletonData_t::GetBoneScaleParent() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: ModelSkeletonData_t->BoneScaleParent(ptr=%p)", m_ptr));
    CUtlVector<float32>* vec = GetSchemaValue<CUtlVector<float32>*>(m_ptr, "ModelSkeletonData_t", "m_boneScaleParent"); std::vector<float32> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GModelSkeletonData_t::SetBoneScaleParent(std::vector<float32> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: ModelSkeletonData_t->BoneScaleParent(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<float32>(m_ptr, "ModelSkeletonData_t", "m_boneScaleParent", true, value);
}
void* GModelSkeletonData_t::GetPtr() {
    return m_ptr;
}
std::string GModelSkeletonData_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GModelSkeletonData_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassModelSkeletonData_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GModelSkeletonData_t>("ModelSkeletonData_t")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("BoneName", &GModelSkeletonData_t::GetBoneName, &GModelSkeletonData_t::SetBoneName)
        .addProperty("Parent", &GModelSkeletonData_t::GetParent, &GModelSkeletonData_t::SetParent)
        .addProperty("BoneSphere", &GModelSkeletonData_t::GetBoneSphere, &GModelSkeletonData_t::SetBoneSphere)
        .addProperty("Flag", &GModelSkeletonData_t::GetFlag, &GModelSkeletonData_t::SetFlag)
        .addProperty("BonePosParent", &GModelSkeletonData_t::GetBonePosParent, &GModelSkeletonData_t::SetBonePosParent)
        .addProperty("BoneScaleParent", &GModelSkeletonData_t::GetBoneScaleParent, &GModelSkeletonData_t::SetBoneScaleParent)
        .addFunction("ToPtr", &GModelSkeletonData_t::ToPtr)
        .addFunction("IsValid", &GModelSkeletonData_t::IsValid)
        .endClass();
}
GEventModInitialized_t::GEventModInitialized_t(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GEventModInitialized_t::GEventModInitialized_t(void *ptr) {
    m_ptr = ptr;
}
void* GEventModInitialized_t::GetPtr() {
    return m_ptr;
}
std::string GEventModInitialized_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GEventModInitialized_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassEventModInitialized_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GEventModInitialized_t>("EventModInitialized_t")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addFunction("ToPtr", &GEventModInitialized_t::ToPtr)
        .addFunction("IsValid", &GEventModInitialized_t::IsValid)
        .endClass();
}
GCParticleTransformInput::GCParticleTransformInput(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCParticleTransformInput::GCParticleTransformInput(void *ptr) {
    m_ptr = ptr;
}
uint64_t GCParticleTransformInput::GetType() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CParticleTransformInput->Type(ptr=%p)", m_ptr));
    return GetSchemaValue<uint64_t>(m_ptr, "CParticleTransformInput", "m_nType");
}
void GCParticleTransformInput::SetType(uint64_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CParticleTransformInput->Type(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CParticleTransformInput", "m_nType", false, value);
}
bool GCParticleTransformInput::GetFollowNamedValue() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CParticleTransformInput->FollowNamedValue(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "CParticleTransformInput", "m_bFollowNamedValue");
}
void GCParticleTransformInput::SetFollowNamedValue(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CParticleTransformInput->FollowNamedValue(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CParticleTransformInput", "m_bFollowNamedValue", false, value);
}
bool GCParticleTransformInput::GetSupportsDisabled() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CParticleTransformInput->SupportsDisabled(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "CParticleTransformInput", "m_bSupportsDisabled");
}
void GCParticleTransformInput::SetSupportsDisabled(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CParticleTransformInput->SupportsDisabled(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CParticleTransformInput", "m_bSupportsDisabled", false, value);
}
bool GCParticleTransformInput::GetUseOrientation() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CParticleTransformInput->UseOrientation(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "CParticleTransformInput", "m_bUseOrientation");
}
void GCParticleTransformInput::SetUseOrientation(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CParticleTransformInput->UseOrientation(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CParticleTransformInput", "m_bUseOrientation", false, value);
}
int32_t GCParticleTransformInput::GetControlPoint() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CParticleTransformInput->ControlPoint(ptr=%p)", m_ptr));
    return GetSchemaValue<int32_t>(m_ptr, "CParticleTransformInput", "m_nControlPoint");
}
void GCParticleTransformInput::SetControlPoint(int32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CParticleTransformInput->ControlPoint(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CParticleTransformInput", "m_nControlPoint", false, value);
}
int32_t GCParticleTransformInput::GetControlPointRangeMax() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CParticleTransformInput->ControlPointRangeMax(ptr=%p)", m_ptr));
    return GetSchemaValue<int32_t>(m_ptr, "CParticleTransformInput", "m_nControlPointRangeMax");
}
void GCParticleTransformInput::SetControlPointRangeMax(int32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CParticleTransformInput->ControlPointRangeMax(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CParticleTransformInput", "m_nControlPointRangeMax", false, value);
}
float GCParticleTransformInput::GetEndCPGrowthTime() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CParticleTransformInput->EndCPGrowthTime(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CParticleTransformInput", "m_flEndCPGrowthTime");
}
void GCParticleTransformInput::SetEndCPGrowthTime(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CParticleTransformInput->EndCPGrowthTime(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CParticleTransformInput", "m_flEndCPGrowthTime", false, value);
}
void* GCParticleTransformInput::GetPtr() {
    return m_ptr;
}
std::string GCParticleTransformInput::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCParticleTransformInput::IsValid() {
    return (m_ptr != nullptr);
}
GCParticleInput GCParticleTransformInput::GetParent() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CParticleTransformInput::GetParent(ptr=%p)", m_ptr));
    GCParticleInput value(m_ptr);
    return value;
}
void GCParticleTransformInput::SetParent(GCParticleInput value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CParticleTransformInput::SetParent(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCParticleTransformInput(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCParticleTransformInput>("CParticleTransformInput")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Type", &GCParticleTransformInput::GetType, &GCParticleTransformInput::SetType)
        .addProperty("FollowNamedValue", &GCParticleTransformInput::GetFollowNamedValue, &GCParticleTransformInput::SetFollowNamedValue)
        .addProperty("SupportsDisabled", &GCParticleTransformInput::GetSupportsDisabled, &GCParticleTransformInput::SetSupportsDisabled)
        .addProperty("UseOrientation", &GCParticleTransformInput::GetUseOrientation, &GCParticleTransformInput::SetUseOrientation)
        .addProperty("ControlPoint", &GCParticleTransformInput::GetControlPoint, &GCParticleTransformInput::SetControlPoint)
        .addProperty("ControlPointRangeMax", &GCParticleTransformInput::GetControlPointRangeMax, &GCParticleTransformInput::SetControlPointRangeMax)
        .addProperty("EndCPGrowthTime", &GCParticleTransformInput::GetEndCPGrowthTime, &GCParticleTransformInput::SetEndCPGrowthTime)
        .addProperty("Parent", &GCParticleTransformInput::GetParent, &GCParticleTransformInput::SetParent)
        .addFunction("ToPtr", &GCParticleTransformInput::ToPtr)
        .addFunction("IsValid", &GCParticleTransformInput::IsValid)
        .endClass();
}
GCParticleVisibilityInputs::GCParticleVisibilityInputs(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCParticleVisibilityInputs::GCParticleVisibilityInputs(void *ptr) {
    m_ptr = ptr;
}
float GCParticleVisibilityInputs::GetCameraBias() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CParticleVisibilityInputs->CameraBias(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CParticleVisibilityInputs", "m_flCameraBias");
}
void GCParticleVisibilityInputs::SetCameraBias(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CParticleVisibilityInputs->CameraBias(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CParticleVisibilityInputs", "m_flCameraBias", false, value);
}
int32_t GCParticleVisibilityInputs::GetCPin() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CParticleVisibilityInputs->CPin(ptr=%p)", m_ptr));
    return GetSchemaValue<int32_t>(m_ptr, "CParticleVisibilityInputs", "m_nCPin");
}
void GCParticleVisibilityInputs::SetCPin(int32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CParticleVisibilityInputs->CPin(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CParticleVisibilityInputs", "m_nCPin", false, value);
}
float GCParticleVisibilityInputs::GetProxyRadius() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CParticleVisibilityInputs->ProxyRadius(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CParticleVisibilityInputs", "m_flProxyRadius");
}
void GCParticleVisibilityInputs::SetProxyRadius(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CParticleVisibilityInputs->ProxyRadius(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CParticleVisibilityInputs", "m_flProxyRadius", false, value);
}
float GCParticleVisibilityInputs::GetInputMin() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CParticleVisibilityInputs->InputMin(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CParticleVisibilityInputs", "m_flInputMin");
}
void GCParticleVisibilityInputs::SetInputMin(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CParticleVisibilityInputs->InputMin(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CParticleVisibilityInputs", "m_flInputMin", false, value);
}
float GCParticleVisibilityInputs::GetInputMax() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CParticleVisibilityInputs->InputMax(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CParticleVisibilityInputs", "m_flInputMax");
}
void GCParticleVisibilityInputs::SetInputMax(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CParticleVisibilityInputs->InputMax(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CParticleVisibilityInputs", "m_flInputMax", false, value);
}
float GCParticleVisibilityInputs::GetInputPixelVisFade() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CParticleVisibilityInputs->InputPixelVisFade(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CParticleVisibilityInputs", "m_flInputPixelVisFade");
}
void GCParticleVisibilityInputs::SetInputPixelVisFade(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CParticleVisibilityInputs->InputPixelVisFade(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CParticleVisibilityInputs", "m_flInputPixelVisFade", false, value);
}
float GCParticleVisibilityInputs::GetNoPixelVisibilityFallback() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CParticleVisibilityInputs->NoPixelVisibilityFallback(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CParticleVisibilityInputs", "m_flNoPixelVisibilityFallback");
}
void GCParticleVisibilityInputs::SetNoPixelVisibilityFallback(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CParticleVisibilityInputs->NoPixelVisibilityFallback(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CParticleVisibilityInputs", "m_flNoPixelVisibilityFallback", false, value);
}
float GCParticleVisibilityInputs::GetDistanceInputMin() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CParticleVisibilityInputs->DistanceInputMin(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CParticleVisibilityInputs", "m_flDistanceInputMin");
}
void GCParticleVisibilityInputs::SetDistanceInputMin(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CParticleVisibilityInputs->DistanceInputMin(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CParticleVisibilityInputs", "m_flDistanceInputMin", false, value);
}
float GCParticleVisibilityInputs::GetDistanceInputMax() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CParticleVisibilityInputs->DistanceInputMax(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CParticleVisibilityInputs", "m_flDistanceInputMax");
}
void GCParticleVisibilityInputs::SetDistanceInputMax(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CParticleVisibilityInputs->DistanceInputMax(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CParticleVisibilityInputs", "m_flDistanceInputMax", false, value);
}
float GCParticleVisibilityInputs::GetDotInputMin() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CParticleVisibilityInputs->DotInputMin(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CParticleVisibilityInputs", "m_flDotInputMin");
}
void GCParticleVisibilityInputs::SetDotInputMin(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CParticleVisibilityInputs->DotInputMin(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CParticleVisibilityInputs", "m_flDotInputMin", false, value);
}
float GCParticleVisibilityInputs::GetDotInputMax() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CParticleVisibilityInputs->DotInputMax(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CParticleVisibilityInputs", "m_flDotInputMax");
}
void GCParticleVisibilityInputs::SetDotInputMax(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CParticleVisibilityInputs->DotInputMax(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CParticleVisibilityInputs", "m_flDotInputMax", false, value);
}
bool GCParticleVisibilityInputs::GetDotCPAngles() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CParticleVisibilityInputs->DotCPAngles(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "CParticleVisibilityInputs", "m_bDotCPAngles");
}
void GCParticleVisibilityInputs::SetDotCPAngles(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CParticleVisibilityInputs->DotCPAngles(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CParticleVisibilityInputs", "m_bDotCPAngles", false, value);
}
bool GCParticleVisibilityInputs::GetDotCameraAngles() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CParticleVisibilityInputs->DotCameraAngles(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "CParticleVisibilityInputs", "m_bDotCameraAngles");
}
void GCParticleVisibilityInputs::SetDotCameraAngles(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CParticleVisibilityInputs->DotCameraAngles(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CParticleVisibilityInputs", "m_bDotCameraAngles", false, value);
}
float GCParticleVisibilityInputs::GetAlphaScaleMin() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CParticleVisibilityInputs->AlphaScaleMin(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CParticleVisibilityInputs", "m_flAlphaScaleMin");
}
void GCParticleVisibilityInputs::SetAlphaScaleMin(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CParticleVisibilityInputs->AlphaScaleMin(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CParticleVisibilityInputs", "m_flAlphaScaleMin", false, value);
}
float GCParticleVisibilityInputs::GetAlphaScaleMax() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CParticleVisibilityInputs->AlphaScaleMax(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CParticleVisibilityInputs", "m_flAlphaScaleMax");
}
void GCParticleVisibilityInputs::SetAlphaScaleMax(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CParticleVisibilityInputs->AlphaScaleMax(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CParticleVisibilityInputs", "m_flAlphaScaleMax", false, value);
}
float GCParticleVisibilityInputs::GetRadiusScaleMin() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CParticleVisibilityInputs->RadiusScaleMin(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CParticleVisibilityInputs", "m_flRadiusScaleMin");
}
void GCParticleVisibilityInputs::SetRadiusScaleMin(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CParticleVisibilityInputs->RadiusScaleMin(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CParticleVisibilityInputs", "m_flRadiusScaleMin", false, value);
}
float GCParticleVisibilityInputs::GetRadiusScaleMax() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CParticleVisibilityInputs->RadiusScaleMax(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CParticleVisibilityInputs", "m_flRadiusScaleMax");
}
void GCParticleVisibilityInputs::SetRadiusScaleMax(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CParticleVisibilityInputs->RadiusScaleMax(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CParticleVisibilityInputs", "m_flRadiusScaleMax", false, value);
}
float GCParticleVisibilityInputs::GetRadiusScaleFOVBase() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CParticleVisibilityInputs->RadiusScaleFOVBase(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CParticleVisibilityInputs", "m_flRadiusScaleFOVBase");
}
void GCParticleVisibilityInputs::SetRadiusScaleFOVBase(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CParticleVisibilityInputs->RadiusScaleFOVBase(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CParticleVisibilityInputs", "m_flRadiusScaleFOVBase", false, value);
}
bool GCParticleVisibilityInputs::GetRightEye() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CParticleVisibilityInputs->RightEye(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "CParticleVisibilityInputs", "m_bRightEye");
}
void GCParticleVisibilityInputs::SetRightEye(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CParticleVisibilityInputs->RightEye(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CParticleVisibilityInputs", "m_bRightEye", false, value);
}
void* GCParticleVisibilityInputs::GetPtr() {
    return m_ptr;
}
std::string GCParticleVisibilityInputs::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCParticleVisibilityInputs::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCParticleVisibilityInputs(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCParticleVisibilityInputs>("CParticleVisibilityInputs")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("CameraBias", &GCParticleVisibilityInputs::GetCameraBias, &GCParticleVisibilityInputs::SetCameraBias)
        .addProperty("CPin", &GCParticleVisibilityInputs::GetCPin, &GCParticleVisibilityInputs::SetCPin)
        .addProperty("ProxyRadius", &GCParticleVisibilityInputs::GetProxyRadius, &GCParticleVisibilityInputs::SetProxyRadius)
        .addProperty("InputMin", &GCParticleVisibilityInputs::GetInputMin, &GCParticleVisibilityInputs::SetInputMin)
        .addProperty("InputMax", &GCParticleVisibilityInputs::GetInputMax, &GCParticleVisibilityInputs::SetInputMax)
        .addProperty("InputPixelVisFade", &GCParticleVisibilityInputs::GetInputPixelVisFade, &GCParticleVisibilityInputs::SetInputPixelVisFade)
        .addProperty("NoPixelVisibilityFallback", &GCParticleVisibilityInputs::GetNoPixelVisibilityFallback, &GCParticleVisibilityInputs::SetNoPixelVisibilityFallback)
        .addProperty("DistanceInputMin", &GCParticleVisibilityInputs::GetDistanceInputMin, &GCParticleVisibilityInputs::SetDistanceInputMin)
        .addProperty("DistanceInputMax", &GCParticleVisibilityInputs::GetDistanceInputMax, &GCParticleVisibilityInputs::SetDistanceInputMax)
        .addProperty("DotInputMin", &GCParticleVisibilityInputs::GetDotInputMin, &GCParticleVisibilityInputs::SetDotInputMin)
        .addProperty("DotInputMax", &GCParticleVisibilityInputs::GetDotInputMax, &GCParticleVisibilityInputs::SetDotInputMax)
        .addProperty("DotCPAngles", &GCParticleVisibilityInputs::GetDotCPAngles, &GCParticleVisibilityInputs::SetDotCPAngles)
        .addProperty("DotCameraAngles", &GCParticleVisibilityInputs::GetDotCameraAngles, &GCParticleVisibilityInputs::SetDotCameraAngles)
        .addProperty("AlphaScaleMin", &GCParticleVisibilityInputs::GetAlphaScaleMin, &GCParticleVisibilityInputs::SetAlphaScaleMin)
        .addProperty("AlphaScaleMax", &GCParticleVisibilityInputs::GetAlphaScaleMax, &GCParticleVisibilityInputs::SetAlphaScaleMax)
        .addProperty("RadiusScaleMin", &GCParticleVisibilityInputs::GetRadiusScaleMin, &GCParticleVisibilityInputs::SetRadiusScaleMin)
        .addProperty("RadiusScaleMax", &GCParticleVisibilityInputs::GetRadiusScaleMax, &GCParticleVisibilityInputs::SetRadiusScaleMax)
        .addProperty("RadiusScaleFOVBase", &GCParticleVisibilityInputs::GetRadiusScaleFOVBase, &GCParticleVisibilityInputs::SetRadiusScaleFOVBase)
        .addProperty("RightEye", &GCParticleVisibilityInputs::GetRightEye, &GCParticleVisibilityInputs::SetRightEye)
        .addFunction("ToPtr", &GCParticleVisibilityInputs::ToPtr)
        .addFunction("IsValid", &GCParticleVisibilityInputs::IsValid)
        .endClass();
}
GMaterialGroup_t::GMaterialGroup_t(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GMaterialGroup_t::GMaterialGroup_t(void *ptr) {
    m_ptr = ptr;
}
std::string GMaterialGroup_t::GetName() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: MaterialGroup_t->Name(ptr=%p)", m_ptr));
    return GetSchemaValue<CUtlString>(m_ptr, "MaterialGroup_t", "m_name").Get();
}
void GMaterialGroup_t::SetName(std::string value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: MaterialGroup_t->Name(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "MaterialGroup_t", "m_name", true, CUtlString(value.c_str()));
}
void* GMaterialGroup_t::GetPtr() {
    return m_ptr;
}
std::string GMaterialGroup_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GMaterialGroup_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassMaterialGroup_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GMaterialGroup_t>("MaterialGroup_t")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Name", &GMaterialGroup_t::GetName, &GMaterialGroup_t::SetName)
        .addFunction("ToPtr", &GMaterialGroup_t::ToPtr)
        .addFunction("IsValid", &GMaterialGroup_t::IsValid)
        .endClass();
}
GCAnimUpdateNodeBase::GCAnimUpdateNodeBase(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCAnimUpdateNodeBase::GCAnimUpdateNodeBase(void *ptr) {
    m_ptr = ptr;
}
GCAnimNodePath GCAnimUpdateNodeBase::GetNodePath() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CAnimUpdateNodeBase->NodePath(ptr=%p)", m_ptr));
    GCAnimNodePath value(GetSchemaPtr(m_ptr, "CAnimUpdateNodeBase", "m_nodePath"));
    return value;
}
void GCAnimUpdateNodeBase::SetNodePath(GCAnimNodePath value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CAnimUpdateNodeBase->NodePath(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'NodePath' is not possible.\n");
}
uint64_t GCAnimUpdateNodeBase::GetNetworkMode() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CAnimUpdateNodeBase->NetworkMode(ptr=%p)", m_ptr));
    return GetSchemaValue<uint64_t>(m_ptr, "CAnimUpdateNodeBase", "m_networkMode");
}
void GCAnimUpdateNodeBase::SetNetworkMode(uint64_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CAnimUpdateNodeBase->NetworkMode(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CAnimUpdateNodeBase", "m_networkMode", false, value);
}
std::string GCAnimUpdateNodeBase::GetName() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CAnimUpdateNodeBase->Name(ptr=%p)", m_ptr));
    return GetSchemaValue<CUtlString>(m_ptr, "CAnimUpdateNodeBase", "m_name").Get();
}
void GCAnimUpdateNodeBase::SetName(std::string value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CAnimUpdateNodeBase->Name(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CAnimUpdateNodeBase", "m_name", false, CUtlString(value.c_str()));
}
void* GCAnimUpdateNodeBase::GetPtr() {
    return m_ptr;
}
std::string GCAnimUpdateNodeBase::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCAnimUpdateNodeBase::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCAnimUpdateNodeBase(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCAnimUpdateNodeBase>("CAnimUpdateNodeBase")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("NodePath", &GCAnimUpdateNodeBase::GetNodePath, &GCAnimUpdateNodeBase::SetNodePath)
        .addProperty("NetworkMode", &GCAnimUpdateNodeBase::GetNetworkMode, &GCAnimUpdateNodeBase::SetNetworkMode)
        .addProperty("Name", &GCAnimUpdateNodeBase::GetName, &GCAnimUpdateNodeBase::SetName)
        .addFunction("ToPtr", &GCAnimUpdateNodeBase::ToPtr)
        .addFunction("IsValid", &GCAnimUpdateNodeBase::IsValid)
        .endClass();
}
GCParticleFunctionRenderer::GCParticleFunctionRenderer(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCParticleFunctionRenderer::GCParticleFunctionRenderer(void *ptr) {
    m_ptr = ptr;
}
GCParticleVisibilityInputs GCParticleFunctionRenderer::GetVisibilityInputs() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CParticleFunctionRenderer->VisibilityInputs(ptr=%p)", m_ptr));
    GCParticleVisibilityInputs value(GetSchemaPtr(m_ptr, "CParticleFunctionRenderer", "VisibilityInputs"));
    return value;
}
void GCParticleFunctionRenderer::SetVisibilityInputs(GCParticleVisibilityInputs value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CParticleFunctionRenderer->VisibilityInputs(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'VisibilityInputs' is not possible.\n");
}
bool GCParticleFunctionRenderer::GetCannotBeRefracted() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CParticleFunctionRenderer->CannotBeRefracted(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "CParticleFunctionRenderer", "m_bCannotBeRefracted");
}
void GCParticleFunctionRenderer::SetCannotBeRefracted(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CParticleFunctionRenderer->CannotBeRefracted(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CParticleFunctionRenderer", "m_bCannotBeRefracted", false, value);
}
bool GCParticleFunctionRenderer::GetSkipRenderingOnMobile() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CParticleFunctionRenderer->SkipRenderingOnMobile(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "CParticleFunctionRenderer", "m_bSkipRenderingOnMobile");
}
void GCParticleFunctionRenderer::SetSkipRenderingOnMobile(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CParticleFunctionRenderer->SkipRenderingOnMobile(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CParticleFunctionRenderer", "m_bSkipRenderingOnMobile", false, value);
}
void* GCParticleFunctionRenderer::GetPtr() {
    return m_ptr;
}
std::string GCParticleFunctionRenderer::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCParticleFunctionRenderer::IsValid() {
    return (m_ptr != nullptr);
}
GCParticleFunction GCParticleFunctionRenderer::GetParent() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CParticleFunctionRenderer::GetParent(ptr=%p)", m_ptr));
    GCParticleFunction value(m_ptr);
    return value;
}
void GCParticleFunctionRenderer::SetParent(GCParticleFunction value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CParticleFunctionRenderer::SetParent(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCParticleFunctionRenderer(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCParticleFunctionRenderer>("CParticleFunctionRenderer")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("VisibilityInputs", &GCParticleFunctionRenderer::GetVisibilityInputs, &GCParticleFunctionRenderer::SetVisibilityInputs)
        .addProperty("CannotBeRefracted", &GCParticleFunctionRenderer::GetCannotBeRefracted, &GCParticleFunctionRenderer::SetCannotBeRefracted)
        .addProperty("SkipRenderingOnMobile", &GCParticleFunctionRenderer::GetSkipRenderingOnMobile, &GCParticleFunctionRenderer::SetSkipRenderingOnMobile)
        .addProperty("Parent", &GCParticleFunctionRenderer::GetParent, &GCParticleFunctionRenderer::SetParent)
        .addFunction("ToPtr", &GCParticleFunctionRenderer::ToPtr)
        .addFunction("IsValid", &GCParticleFunctionRenderer::IsValid)
        .endClass();
}
GCParticleVecInput::GCParticleVecInput(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCParticleVecInput::GCParticleVecInput(void *ptr) {
    m_ptr = ptr;
}
uint64_t GCParticleVecInput::GetType() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CParticleVecInput->Type(ptr=%p)", m_ptr));
    return GetSchemaValue<uint64_t>(m_ptr, "CParticleVecInput", "m_nType");
}
void GCParticleVecInput::SetType(uint64_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CParticleVecInput->Type(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CParticleVecInput", "m_nType", false, value);
}
Vector GCParticleVecInput::GetLiteralValue() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CParticleVecInput->LiteralValue(ptr=%p)", m_ptr));
    return GetSchemaValue<Vector>(m_ptr, "CParticleVecInput", "m_vLiteralValue");
}
void GCParticleVecInput::SetLiteralValue(Vector value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CParticleVecInput->LiteralValue(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CParticleVecInput", "m_vLiteralValue", false, value);
}
Color GCParticleVecInput::GetLiteralColor() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CParticleVecInput->LiteralColor(ptr=%p)", m_ptr));
    return GetSchemaValue<Color>(m_ptr, "CParticleVecInput", "m_LiteralColor");
}
void GCParticleVecInput::SetLiteralColor(Color value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CParticleVecInput->LiteralColor(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CParticleVecInput", "m_LiteralColor", false, value);
}
bool GCParticleVecInput::GetFollowNamedValue() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CParticleVecInput->FollowNamedValue(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "CParticleVecInput", "m_bFollowNamedValue");
}
void GCParticleVecInput::SetFollowNamedValue(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CParticleVecInput->FollowNamedValue(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CParticleVecInput", "m_bFollowNamedValue", false, value);
}
GParticleAttributeIndex_t GCParticleVecInput::GetVectorAttribute() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CParticleVecInput->VectorAttribute(ptr=%p)", m_ptr));
    GParticleAttributeIndex_t value(GetSchemaPtr(m_ptr, "CParticleVecInput", "m_nVectorAttribute"));
    return value;
}
void GCParticleVecInput::SetVectorAttribute(GParticleAttributeIndex_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CParticleVecInput->VectorAttribute(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'VectorAttribute' is not possible.\n");
}
Vector GCParticleVecInput::GetVectorAttributeScale() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CParticleVecInput->VectorAttributeScale(ptr=%p)", m_ptr));
    return GetSchemaValue<Vector>(m_ptr, "CParticleVecInput", "m_vVectorAttributeScale");
}
void GCParticleVecInput::SetVectorAttributeScale(Vector value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CParticleVecInput->VectorAttributeScale(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CParticleVecInput", "m_vVectorAttributeScale", false, value);
}
int32_t GCParticleVecInput::GetControlPoint() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CParticleVecInput->ControlPoint(ptr=%p)", m_ptr));
    return GetSchemaValue<int32_t>(m_ptr, "CParticleVecInput", "m_nControlPoint");
}
void GCParticleVecInput::SetControlPoint(int32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CParticleVecInput->ControlPoint(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CParticleVecInput", "m_nControlPoint", false, value);
}
int32_t GCParticleVecInput::GetDeltaControlPoint() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CParticleVecInput->DeltaControlPoint(ptr=%p)", m_ptr));
    return GetSchemaValue<int32_t>(m_ptr, "CParticleVecInput", "m_nDeltaControlPoint");
}
void GCParticleVecInput::SetDeltaControlPoint(int32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CParticleVecInput->DeltaControlPoint(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CParticleVecInput", "m_nDeltaControlPoint", false, value);
}
Vector GCParticleVecInput::GetCPValueScale() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CParticleVecInput->CPValueScale(ptr=%p)", m_ptr));
    return GetSchemaValue<Vector>(m_ptr, "CParticleVecInput", "m_vCPValueScale");
}
void GCParticleVecInput::SetCPValueScale(Vector value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CParticleVecInput->CPValueScale(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CParticleVecInput", "m_vCPValueScale", false, value);
}
Vector GCParticleVecInput::GetCPRelativePosition() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CParticleVecInput->CPRelativePosition(ptr=%p)", m_ptr));
    return GetSchemaValue<Vector>(m_ptr, "CParticleVecInput", "m_vCPRelativePosition");
}
void GCParticleVecInput::SetCPRelativePosition(Vector value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CParticleVecInput->CPRelativePosition(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CParticleVecInput", "m_vCPRelativePosition", false, value);
}
Vector GCParticleVecInput::GetCPRelativeDir() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CParticleVecInput->CPRelativeDir(ptr=%p)", m_ptr));
    return GetSchemaValue<Vector>(m_ptr, "CParticleVecInput", "m_vCPRelativeDir");
}
void GCParticleVecInput::SetCPRelativeDir(Vector value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CParticleVecInput->CPRelativeDir(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CParticleVecInput", "m_vCPRelativeDir", false, value);
}
GCParticleFloatInput GCParticleVecInput::GetFloatComponentX() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CParticleVecInput->FloatComponentX(ptr=%p)", m_ptr));
    GCParticleFloatInput value(GetSchemaPtr(m_ptr, "CParticleVecInput", "m_FloatComponentX"));
    return value;
}
void GCParticleVecInput::SetFloatComponentX(GCParticleFloatInput value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CParticleVecInput->FloatComponentX(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'FloatComponentX' is not possible.\n");
}
GCParticleFloatInput GCParticleVecInput::GetFloatComponentY() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CParticleVecInput->FloatComponentY(ptr=%p)", m_ptr));
    GCParticleFloatInput value(GetSchemaPtr(m_ptr, "CParticleVecInput", "m_FloatComponentY"));
    return value;
}
void GCParticleVecInput::SetFloatComponentY(GCParticleFloatInput value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CParticleVecInput->FloatComponentY(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'FloatComponentY' is not possible.\n");
}
GCParticleFloatInput GCParticleVecInput::GetFloatComponentZ() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CParticleVecInput->FloatComponentZ(ptr=%p)", m_ptr));
    GCParticleFloatInput value(GetSchemaPtr(m_ptr, "CParticleVecInput", "m_FloatComponentZ"));
    return value;
}
void GCParticleVecInput::SetFloatComponentZ(GCParticleFloatInput value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CParticleVecInput->FloatComponentZ(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'FloatComponentZ' is not possible.\n");
}
GCParticleFloatInput GCParticleVecInput::GetFloatInterp() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CParticleVecInput->FloatInterp(ptr=%p)", m_ptr));
    GCParticleFloatInput value(GetSchemaPtr(m_ptr, "CParticleVecInput", "m_FloatInterp"));
    return value;
}
void GCParticleVecInput::SetFloatInterp(GCParticleFloatInput value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CParticleVecInput->FloatInterp(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'FloatInterp' is not possible.\n");
}
float GCParticleVecInput::GetInterpInput0() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CParticleVecInput->InterpInput0(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CParticleVecInput", "m_flInterpInput0");
}
void GCParticleVecInput::SetInterpInput0(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CParticleVecInput->InterpInput0(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CParticleVecInput", "m_flInterpInput0", false, value);
}
float GCParticleVecInput::GetInterpInput1() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CParticleVecInput->InterpInput1(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CParticleVecInput", "m_flInterpInput1");
}
void GCParticleVecInput::SetInterpInput1(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CParticleVecInput->InterpInput1(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CParticleVecInput", "m_flInterpInput1", false, value);
}
Vector GCParticleVecInput::GetInterpOutput0() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CParticleVecInput->InterpOutput0(ptr=%p)", m_ptr));
    return GetSchemaValue<Vector>(m_ptr, "CParticleVecInput", "m_vInterpOutput0");
}
void GCParticleVecInput::SetInterpOutput0(Vector value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CParticleVecInput->InterpOutput0(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CParticleVecInput", "m_vInterpOutput0", false, value);
}
Vector GCParticleVecInput::GetInterpOutput1() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CParticleVecInput->InterpOutput1(ptr=%p)", m_ptr));
    return GetSchemaValue<Vector>(m_ptr, "CParticleVecInput", "m_vInterpOutput1");
}
void GCParticleVecInput::SetInterpOutput1(Vector value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CParticleVecInput->InterpOutput1(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CParticleVecInput", "m_vInterpOutput1", false, value);
}
Vector GCParticleVecInput::GetRandomMin() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CParticleVecInput->RandomMin(ptr=%p)", m_ptr));
    return GetSchemaValue<Vector>(m_ptr, "CParticleVecInput", "m_vRandomMin");
}
void GCParticleVecInput::SetRandomMin(Vector value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CParticleVecInput->RandomMin(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CParticleVecInput", "m_vRandomMin", false, value);
}
Vector GCParticleVecInput::GetRandomMax() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CParticleVecInput->RandomMax(ptr=%p)", m_ptr));
    return GetSchemaValue<Vector>(m_ptr, "CParticleVecInput", "m_vRandomMax");
}
void GCParticleVecInput::SetRandomMax(Vector value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CParticleVecInput->RandomMax(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CParticleVecInput", "m_vRandomMax", false, value);
}
void* GCParticleVecInput::GetPtr() {
    return m_ptr;
}
std::string GCParticleVecInput::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCParticleVecInput::IsValid() {
    return (m_ptr != nullptr);
}
GCParticleInput GCParticleVecInput::GetParent() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CParticleVecInput::GetParent(ptr=%p)", m_ptr));
    GCParticleInput value(m_ptr);
    return value;
}
void GCParticleVecInput::SetParent(GCParticleInput value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CParticleVecInput::SetParent(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCParticleVecInput(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCParticleVecInput>("CParticleVecInput")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Type", &GCParticleVecInput::GetType, &GCParticleVecInput::SetType)
        .addProperty("LiteralValue", &GCParticleVecInput::GetLiteralValue, &GCParticleVecInput::SetLiteralValue)
        .addProperty("LiteralColor", &GCParticleVecInput::GetLiteralColor, &GCParticleVecInput::SetLiteralColor)
        .addProperty("FollowNamedValue", &GCParticleVecInput::GetFollowNamedValue, &GCParticleVecInput::SetFollowNamedValue)
        .addProperty("VectorAttribute", &GCParticleVecInput::GetVectorAttribute, &GCParticleVecInput::SetVectorAttribute)
        .addProperty("VectorAttributeScale", &GCParticleVecInput::GetVectorAttributeScale, &GCParticleVecInput::SetVectorAttributeScale)
        .addProperty("ControlPoint", &GCParticleVecInput::GetControlPoint, &GCParticleVecInput::SetControlPoint)
        .addProperty("DeltaControlPoint", &GCParticleVecInput::GetDeltaControlPoint, &GCParticleVecInput::SetDeltaControlPoint)
        .addProperty("CPValueScale", &GCParticleVecInput::GetCPValueScale, &GCParticleVecInput::SetCPValueScale)
        .addProperty("CPRelativePosition", &GCParticleVecInput::GetCPRelativePosition, &GCParticleVecInput::SetCPRelativePosition)
        .addProperty("CPRelativeDir", &GCParticleVecInput::GetCPRelativeDir, &GCParticleVecInput::SetCPRelativeDir)
        .addProperty("FloatComponentX", &GCParticleVecInput::GetFloatComponentX, &GCParticleVecInput::SetFloatComponentX)
        .addProperty("FloatComponentY", &GCParticleVecInput::GetFloatComponentY, &GCParticleVecInput::SetFloatComponentY)
        .addProperty("FloatComponentZ", &GCParticleVecInput::GetFloatComponentZ, &GCParticleVecInput::SetFloatComponentZ)
        .addProperty("FloatInterp", &GCParticleVecInput::GetFloatInterp, &GCParticleVecInput::SetFloatInterp)
        .addProperty("InterpInput0", &GCParticleVecInput::GetInterpInput0, &GCParticleVecInput::SetInterpInput0)
        .addProperty("InterpInput1", &GCParticleVecInput::GetInterpInput1, &GCParticleVecInput::SetInterpInput1)
        .addProperty("InterpOutput0", &GCParticleVecInput::GetInterpOutput0, &GCParticleVecInput::SetInterpOutput0)
        .addProperty("InterpOutput1", &GCParticleVecInput::GetInterpOutput1, &GCParticleVecInput::SetInterpOutput1)
        .addProperty("RandomMin", &GCParticleVecInput::GetRandomMin, &GCParticleVecInput::SetRandomMin)
        .addProperty("RandomMax", &GCParticleVecInput::GetRandomMax, &GCParticleVecInput::SetRandomMax)
        .addProperty("Parent", &GCParticleVecInput::GetParent, &GCParticleVecInput::SetParent)
        .addFunction("ToPtr", &GCParticleVecInput::ToPtr)
        .addFunction("IsValid", &GCParticleVecInput::IsValid)
        .endClass();
}
GVPhysXConstraintParams_t::GVPhysXConstraintParams_t(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GVPhysXConstraintParams_t::GVPhysXConstraintParams_t(void *ptr) {
    m_ptr = ptr;
}
int32_t GVPhysXConstraintParams_t::GetType() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: VPhysXConstraintParams_t->Type(ptr=%p)", m_ptr));
    return GetSchemaValue<int32_t>(m_ptr, "VPhysXConstraintParams_t", "m_nType");
}
void GVPhysXConstraintParams_t::SetType(int32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: VPhysXConstraintParams_t->Type(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "VPhysXConstraintParams_t", "m_nType", true, value);
}
int32_t GVPhysXConstraintParams_t::GetTranslateMotion() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: VPhysXConstraintParams_t->TranslateMotion(ptr=%p)", m_ptr));
    return GetSchemaValue<int32_t>(m_ptr, "VPhysXConstraintParams_t", "m_nTranslateMotion");
}
void GVPhysXConstraintParams_t::SetTranslateMotion(int32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: VPhysXConstraintParams_t->TranslateMotion(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "VPhysXConstraintParams_t", "m_nTranslateMotion", true, value);
}
int32_t GVPhysXConstraintParams_t::GetRotateMotion() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: VPhysXConstraintParams_t->RotateMotion(ptr=%p)", m_ptr));
    return GetSchemaValue<int32_t>(m_ptr, "VPhysXConstraintParams_t", "m_nRotateMotion");
}
void GVPhysXConstraintParams_t::SetRotateMotion(int32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: VPhysXConstraintParams_t->RotateMotion(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "VPhysXConstraintParams_t", "m_nRotateMotion", true, value);
}
int32_t GVPhysXConstraintParams_t::GetFlags() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: VPhysXConstraintParams_t->Flags(ptr=%p)", m_ptr));
    return GetSchemaValue<int32_t>(m_ptr, "VPhysXConstraintParams_t", "m_nFlags");
}
void GVPhysXConstraintParams_t::SetFlags(int32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: VPhysXConstraintParams_t->Flags(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "VPhysXConstraintParams_t", "m_nFlags", true, value);
}
std::vector<Vector> GVPhysXConstraintParams_t::GetAnchor() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: VPhysXConstraintParams_t->Anchor(ptr=%p,size=2)", m_ptr));
    Vector* outValue = (Vector*)GetSchemaPtr(m_ptr, "VPhysXConstraintParams_t", "m_anchor"); std::vector<Vector> ret; for(int i = 0; i < 2; i++) { ret.push_back(outValue[i]); } return ret;
}
void GVPhysXConstraintParams_t::SetAnchor(std::vector<Vector> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: VPhysXConstraintParams_t->Anchor(ptr=%p,size=2)", m_ptr));
    if(value.size() != 2) return PLUGIN_PRINT("Schema SDK", "Field 'Anchor' needs to have 2 values.\n");
    auto val = GetSchemaValuePtr<Vector>(m_ptr, "VPhysXConstraintParams_t", "m_anchor");
    for(size_t i = 0; i < value.size(); i++) val[i] = value[i];
}
float GVPhysXConstraintParams_t::GetMaxForce() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: VPhysXConstraintParams_t->MaxForce(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "VPhysXConstraintParams_t", "m_maxForce");
}
void GVPhysXConstraintParams_t::SetMaxForce(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: VPhysXConstraintParams_t->MaxForce(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "VPhysXConstraintParams_t", "m_maxForce", true, value);
}
float GVPhysXConstraintParams_t::GetMaxTorque() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: VPhysXConstraintParams_t->MaxTorque(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "VPhysXConstraintParams_t", "m_maxTorque");
}
void GVPhysXConstraintParams_t::SetMaxTorque(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: VPhysXConstraintParams_t->MaxTorque(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "VPhysXConstraintParams_t", "m_maxTorque", true, value);
}
float GVPhysXConstraintParams_t::GetLinearLimitValue() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: VPhysXConstraintParams_t->LinearLimitValue(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "VPhysXConstraintParams_t", "m_linearLimitValue");
}
void GVPhysXConstraintParams_t::SetLinearLimitValue(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: VPhysXConstraintParams_t->LinearLimitValue(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "VPhysXConstraintParams_t", "m_linearLimitValue", true, value);
}
float GVPhysXConstraintParams_t::GetLinearLimitRestitution() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: VPhysXConstraintParams_t->LinearLimitRestitution(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "VPhysXConstraintParams_t", "m_linearLimitRestitution");
}
void GVPhysXConstraintParams_t::SetLinearLimitRestitution(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: VPhysXConstraintParams_t->LinearLimitRestitution(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "VPhysXConstraintParams_t", "m_linearLimitRestitution", true, value);
}
float GVPhysXConstraintParams_t::GetLinearLimitSpring() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: VPhysXConstraintParams_t->LinearLimitSpring(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "VPhysXConstraintParams_t", "m_linearLimitSpring");
}
void GVPhysXConstraintParams_t::SetLinearLimitSpring(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: VPhysXConstraintParams_t->LinearLimitSpring(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "VPhysXConstraintParams_t", "m_linearLimitSpring", true, value);
}
float GVPhysXConstraintParams_t::GetLinearLimitDamping() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: VPhysXConstraintParams_t->LinearLimitDamping(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "VPhysXConstraintParams_t", "m_linearLimitDamping");
}
void GVPhysXConstraintParams_t::SetLinearLimitDamping(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: VPhysXConstraintParams_t->LinearLimitDamping(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "VPhysXConstraintParams_t", "m_linearLimitDamping", true, value);
}
float GVPhysXConstraintParams_t::GetTwistLowLimitValue() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: VPhysXConstraintParams_t->TwistLowLimitValue(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "VPhysXConstraintParams_t", "m_twistLowLimitValue");
}
void GVPhysXConstraintParams_t::SetTwistLowLimitValue(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: VPhysXConstraintParams_t->TwistLowLimitValue(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "VPhysXConstraintParams_t", "m_twistLowLimitValue", true, value);
}
float GVPhysXConstraintParams_t::GetTwistLowLimitRestitution() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: VPhysXConstraintParams_t->TwistLowLimitRestitution(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "VPhysXConstraintParams_t", "m_twistLowLimitRestitution");
}
void GVPhysXConstraintParams_t::SetTwistLowLimitRestitution(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: VPhysXConstraintParams_t->TwistLowLimitRestitution(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "VPhysXConstraintParams_t", "m_twistLowLimitRestitution", true, value);
}
float GVPhysXConstraintParams_t::GetTwistLowLimitSpring() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: VPhysXConstraintParams_t->TwistLowLimitSpring(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "VPhysXConstraintParams_t", "m_twistLowLimitSpring");
}
void GVPhysXConstraintParams_t::SetTwistLowLimitSpring(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: VPhysXConstraintParams_t->TwistLowLimitSpring(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "VPhysXConstraintParams_t", "m_twistLowLimitSpring", true, value);
}
float GVPhysXConstraintParams_t::GetTwistLowLimitDamping() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: VPhysXConstraintParams_t->TwistLowLimitDamping(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "VPhysXConstraintParams_t", "m_twistLowLimitDamping");
}
void GVPhysXConstraintParams_t::SetTwistLowLimitDamping(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: VPhysXConstraintParams_t->TwistLowLimitDamping(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "VPhysXConstraintParams_t", "m_twistLowLimitDamping", true, value);
}
float GVPhysXConstraintParams_t::GetTwistHighLimitValue() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: VPhysXConstraintParams_t->TwistHighLimitValue(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "VPhysXConstraintParams_t", "m_twistHighLimitValue");
}
void GVPhysXConstraintParams_t::SetTwistHighLimitValue(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: VPhysXConstraintParams_t->TwistHighLimitValue(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "VPhysXConstraintParams_t", "m_twistHighLimitValue", true, value);
}
float GVPhysXConstraintParams_t::GetTwistHighLimitRestitution() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: VPhysXConstraintParams_t->TwistHighLimitRestitution(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "VPhysXConstraintParams_t", "m_twistHighLimitRestitution");
}
void GVPhysXConstraintParams_t::SetTwistHighLimitRestitution(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: VPhysXConstraintParams_t->TwistHighLimitRestitution(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "VPhysXConstraintParams_t", "m_twistHighLimitRestitution", true, value);
}
float GVPhysXConstraintParams_t::GetTwistHighLimitSpring() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: VPhysXConstraintParams_t->TwistHighLimitSpring(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "VPhysXConstraintParams_t", "m_twistHighLimitSpring");
}
void GVPhysXConstraintParams_t::SetTwistHighLimitSpring(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: VPhysXConstraintParams_t->TwistHighLimitSpring(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "VPhysXConstraintParams_t", "m_twistHighLimitSpring", true, value);
}
float GVPhysXConstraintParams_t::GetTwistHighLimitDamping() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: VPhysXConstraintParams_t->TwistHighLimitDamping(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "VPhysXConstraintParams_t", "m_twistHighLimitDamping");
}
void GVPhysXConstraintParams_t::SetTwistHighLimitDamping(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: VPhysXConstraintParams_t->TwistHighLimitDamping(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "VPhysXConstraintParams_t", "m_twistHighLimitDamping", true, value);
}
float GVPhysXConstraintParams_t::GetSwing1LimitValue() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: VPhysXConstraintParams_t->Swing1LimitValue(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "VPhysXConstraintParams_t", "m_swing1LimitValue");
}
void GVPhysXConstraintParams_t::SetSwing1LimitValue(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: VPhysXConstraintParams_t->Swing1LimitValue(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "VPhysXConstraintParams_t", "m_swing1LimitValue", true, value);
}
float GVPhysXConstraintParams_t::GetSwing1LimitRestitution() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: VPhysXConstraintParams_t->Swing1LimitRestitution(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "VPhysXConstraintParams_t", "m_swing1LimitRestitution");
}
void GVPhysXConstraintParams_t::SetSwing1LimitRestitution(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: VPhysXConstraintParams_t->Swing1LimitRestitution(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "VPhysXConstraintParams_t", "m_swing1LimitRestitution", true, value);
}
float GVPhysXConstraintParams_t::GetSwing1LimitSpring() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: VPhysXConstraintParams_t->Swing1LimitSpring(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "VPhysXConstraintParams_t", "m_swing1LimitSpring");
}
void GVPhysXConstraintParams_t::SetSwing1LimitSpring(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: VPhysXConstraintParams_t->Swing1LimitSpring(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "VPhysXConstraintParams_t", "m_swing1LimitSpring", true, value);
}
float GVPhysXConstraintParams_t::GetSwing1LimitDamping() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: VPhysXConstraintParams_t->Swing1LimitDamping(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "VPhysXConstraintParams_t", "m_swing1LimitDamping");
}
void GVPhysXConstraintParams_t::SetSwing1LimitDamping(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: VPhysXConstraintParams_t->Swing1LimitDamping(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "VPhysXConstraintParams_t", "m_swing1LimitDamping", true, value);
}
float GVPhysXConstraintParams_t::GetSwing2LimitValue() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: VPhysXConstraintParams_t->Swing2LimitValue(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "VPhysXConstraintParams_t", "m_swing2LimitValue");
}
void GVPhysXConstraintParams_t::SetSwing2LimitValue(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: VPhysXConstraintParams_t->Swing2LimitValue(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "VPhysXConstraintParams_t", "m_swing2LimitValue", true, value);
}
float GVPhysXConstraintParams_t::GetSwing2LimitRestitution() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: VPhysXConstraintParams_t->Swing2LimitRestitution(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "VPhysXConstraintParams_t", "m_swing2LimitRestitution");
}
void GVPhysXConstraintParams_t::SetSwing2LimitRestitution(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: VPhysXConstraintParams_t->Swing2LimitRestitution(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "VPhysXConstraintParams_t", "m_swing2LimitRestitution", true, value);
}
float GVPhysXConstraintParams_t::GetSwing2LimitSpring() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: VPhysXConstraintParams_t->Swing2LimitSpring(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "VPhysXConstraintParams_t", "m_swing2LimitSpring");
}
void GVPhysXConstraintParams_t::SetSwing2LimitSpring(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: VPhysXConstraintParams_t->Swing2LimitSpring(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "VPhysXConstraintParams_t", "m_swing2LimitSpring", true, value);
}
float GVPhysXConstraintParams_t::GetSwing2LimitDamping() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: VPhysXConstraintParams_t->Swing2LimitDamping(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "VPhysXConstraintParams_t", "m_swing2LimitDamping");
}
void GVPhysXConstraintParams_t::SetSwing2LimitDamping(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: VPhysXConstraintParams_t->Swing2LimitDamping(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "VPhysXConstraintParams_t", "m_swing2LimitDamping", true, value);
}
Vector GVPhysXConstraintParams_t::GetGoalPosition() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: VPhysXConstraintParams_t->GoalPosition(ptr=%p)", m_ptr));
    return GetSchemaValue<Vector>(m_ptr, "VPhysXConstraintParams_t", "m_goalPosition");
}
void GVPhysXConstraintParams_t::SetGoalPosition(Vector value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: VPhysXConstraintParams_t->GoalPosition(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "VPhysXConstraintParams_t", "m_goalPosition", true, value);
}
Vector GVPhysXConstraintParams_t::GetGoalAngularVelocity() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: VPhysXConstraintParams_t->GoalAngularVelocity(ptr=%p)", m_ptr));
    return GetSchemaValue<Vector>(m_ptr, "VPhysXConstraintParams_t", "m_goalAngularVelocity");
}
void GVPhysXConstraintParams_t::SetGoalAngularVelocity(Vector value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: VPhysXConstraintParams_t->GoalAngularVelocity(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "VPhysXConstraintParams_t", "m_goalAngularVelocity", true, value);
}
float GVPhysXConstraintParams_t::GetDriveSpringX() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: VPhysXConstraintParams_t->DriveSpringX(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "VPhysXConstraintParams_t", "m_driveSpringX");
}
void GVPhysXConstraintParams_t::SetDriveSpringX(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: VPhysXConstraintParams_t->DriveSpringX(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "VPhysXConstraintParams_t", "m_driveSpringX", true, value);
}
float GVPhysXConstraintParams_t::GetDriveSpringY() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: VPhysXConstraintParams_t->DriveSpringY(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "VPhysXConstraintParams_t", "m_driveSpringY");
}
void GVPhysXConstraintParams_t::SetDriveSpringY(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: VPhysXConstraintParams_t->DriveSpringY(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "VPhysXConstraintParams_t", "m_driveSpringY", true, value);
}
float GVPhysXConstraintParams_t::GetDriveSpringZ() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: VPhysXConstraintParams_t->DriveSpringZ(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "VPhysXConstraintParams_t", "m_driveSpringZ");
}
void GVPhysXConstraintParams_t::SetDriveSpringZ(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: VPhysXConstraintParams_t->DriveSpringZ(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "VPhysXConstraintParams_t", "m_driveSpringZ", true, value);
}
float GVPhysXConstraintParams_t::GetDriveDampingX() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: VPhysXConstraintParams_t->DriveDampingX(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "VPhysXConstraintParams_t", "m_driveDampingX");
}
void GVPhysXConstraintParams_t::SetDriveDampingX(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: VPhysXConstraintParams_t->DriveDampingX(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "VPhysXConstraintParams_t", "m_driveDampingX", true, value);
}
float GVPhysXConstraintParams_t::GetDriveDampingY() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: VPhysXConstraintParams_t->DriveDampingY(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "VPhysXConstraintParams_t", "m_driveDampingY");
}
void GVPhysXConstraintParams_t::SetDriveDampingY(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: VPhysXConstraintParams_t->DriveDampingY(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "VPhysXConstraintParams_t", "m_driveDampingY", true, value);
}
float GVPhysXConstraintParams_t::GetDriveDampingZ() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: VPhysXConstraintParams_t->DriveDampingZ(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "VPhysXConstraintParams_t", "m_driveDampingZ");
}
void GVPhysXConstraintParams_t::SetDriveDampingZ(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: VPhysXConstraintParams_t->DriveDampingZ(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "VPhysXConstraintParams_t", "m_driveDampingZ", true, value);
}
float GVPhysXConstraintParams_t::GetDriveSpringTwist() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: VPhysXConstraintParams_t->DriveSpringTwist(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "VPhysXConstraintParams_t", "m_driveSpringTwist");
}
void GVPhysXConstraintParams_t::SetDriveSpringTwist(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: VPhysXConstraintParams_t->DriveSpringTwist(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "VPhysXConstraintParams_t", "m_driveSpringTwist", true, value);
}
float GVPhysXConstraintParams_t::GetDriveSpringSwing() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: VPhysXConstraintParams_t->DriveSpringSwing(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "VPhysXConstraintParams_t", "m_driveSpringSwing");
}
void GVPhysXConstraintParams_t::SetDriveSpringSwing(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: VPhysXConstraintParams_t->DriveSpringSwing(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "VPhysXConstraintParams_t", "m_driveSpringSwing", true, value);
}
float GVPhysXConstraintParams_t::GetDriveSpringSlerp() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: VPhysXConstraintParams_t->DriveSpringSlerp(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "VPhysXConstraintParams_t", "m_driveSpringSlerp");
}
void GVPhysXConstraintParams_t::SetDriveSpringSlerp(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: VPhysXConstraintParams_t->DriveSpringSlerp(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "VPhysXConstraintParams_t", "m_driveSpringSlerp", true, value);
}
float GVPhysXConstraintParams_t::GetDriveDampingTwist() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: VPhysXConstraintParams_t->DriveDampingTwist(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "VPhysXConstraintParams_t", "m_driveDampingTwist");
}
void GVPhysXConstraintParams_t::SetDriveDampingTwist(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: VPhysXConstraintParams_t->DriveDampingTwist(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "VPhysXConstraintParams_t", "m_driveDampingTwist", true, value);
}
float GVPhysXConstraintParams_t::GetDriveDampingSwing() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: VPhysXConstraintParams_t->DriveDampingSwing(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "VPhysXConstraintParams_t", "m_driveDampingSwing");
}
void GVPhysXConstraintParams_t::SetDriveDampingSwing(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: VPhysXConstraintParams_t->DriveDampingSwing(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "VPhysXConstraintParams_t", "m_driveDampingSwing", true, value);
}
float GVPhysXConstraintParams_t::GetDriveDampingSlerp() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: VPhysXConstraintParams_t->DriveDampingSlerp(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "VPhysXConstraintParams_t", "m_driveDampingSlerp");
}
void GVPhysXConstraintParams_t::SetDriveDampingSlerp(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: VPhysXConstraintParams_t->DriveDampingSlerp(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "VPhysXConstraintParams_t", "m_driveDampingSlerp", true, value);
}
int32_t GVPhysXConstraintParams_t::GetSolverIterationCount() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: VPhysXConstraintParams_t->SolverIterationCount(ptr=%p)", m_ptr));
    return GetSchemaValue<int32_t>(m_ptr, "VPhysXConstraintParams_t", "m_solverIterationCount");
}
void GVPhysXConstraintParams_t::SetSolverIterationCount(int32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: VPhysXConstraintParams_t->SolverIterationCount(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "VPhysXConstraintParams_t", "m_solverIterationCount", true, value);
}
float GVPhysXConstraintParams_t::GetProjectionLinearTolerance() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: VPhysXConstraintParams_t->ProjectionLinearTolerance(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "VPhysXConstraintParams_t", "m_projectionLinearTolerance");
}
void GVPhysXConstraintParams_t::SetProjectionLinearTolerance(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: VPhysXConstraintParams_t->ProjectionLinearTolerance(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "VPhysXConstraintParams_t", "m_projectionLinearTolerance", true, value);
}
float GVPhysXConstraintParams_t::GetProjectionAngularTolerance() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: VPhysXConstraintParams_t->ProjectionAngularTolerance(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "VPhysXConstraintParams_t", "m_projectionAngularTolerance");
}
void GVPhysXConstraintParams_t::SetProjectionAngularTolerance(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: VPhysXConstraintParams_t->ProjectionAngularTolerance(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "VPhysXConstraintParams_t", "m_projectionAngularTolerance", true, value);
}
void* GVPhysXConstraintParams_t::GetPtr() {
    return m_ptr;
}
std::string GVPhysXConstraintParams_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GVPhysXConstraintParams_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassVPhysXConstraintParams_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GVPhysXConstraintParams_t>("VPhysXConstraintParams_t")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Type", &GVPhysXConstraintParams_t::GetType, &GVPhysXConstraintParams_t::SetType)
        .addProperty("TranslateMotion", &GVPhysXConstraintParams_t::GetTranslateMotion, &GVPhysXConstraintParams_t::SetTranslateMotion)
        .addProperty("RotateMotion", &GVPhysXConstraintParams_t::GetRotateMotion, &GVPhysXConstraintParams_t::SetRotateMotion)
        .addProperty("Flags", &GVPhysXConstraintParams_t::GetFlags, &GVPhysXConstraintParams_t::SetFlags)
        .addProperty("Anchor", &GVPhysXConstraintParams_t::GetAnchor, &GVPhysXConstraintParams_t::SetAnchor)
        .addProperty("MaxForce", &GVPhysXConstraintParams_t::GetMaxForce, &GVPhysXConstraintParams_t::SetMaxForce)
        .addProperty("MaxTorque", &GVPhysXConstraintParams_t::GetMaxTorque, &GVPhysXConstraintParams_t::SetMaxTorque)
        .addProperty("LinearLimitValue", &GVPhysXConstraintParams_t::GetLinearLimitValue, &GVPhysXConstraintParams_t::SetLinearLimitValue)
        .addProperty("LinearLimitRestitution", &GVPhysXConstraintParams_t::GetLinearLimitRestitution, &GVPhysXConstraintParams_t::SetLinearLimitRestitution)
        .addProperty("LinearLimitSpring", &GVPhysXConstraintParams_t::GetLinearLimitSpring, &GVPhysXConstraintParams_t::SetLinearLimitSpring)
        .addProperty("LinearLimitDamping", &GVPhysXConstraintParams_t::GetLinearLimitDamping, &GVPhysXConstraintParams_t::SetLinearLimitDamping)
        .addProperty("TwistLowLimitValue", &GVPhysXConstraintParams_t::GetTwistLowLimitValue, &GVPhysXConstraintParams_t::SetTwistLowLimitValue)
        .addProperty("TwistLowLimitRestitution", &GVPhysXConstraintParams_t::GetTwistLowLimitRestitution, &GVPhysXConstraintParams_t::SetTwistLowLimitRestitution)
        .addProperty("TwistLowLimitSpring", &GVPhysXConstraintParams_t::GetTwistLowLimitSpring, &GVPhysXConstraintParams_t::SetTwistLowLimitSpring)
        .addProperty("TwistLowLimitDamping", &GVPhysXConstraintParams_t::GetTwistLowLimitDamping, &GVPhysXConstraintParams_t::SetTwistLowLimitDamping)
        .addProperty("TwistHighLimitValue", &GVPhysXConstraintParams_t::GetTwistHighLimitValue, &GVPhysXConstraintParams_t::SetTwistHighLimitValue)
        .addProperty("TwistHighLimitRestitution", &GVPhysXConstraintParams_t::GetTwistHighLimitRestitution, &GVPhysXConstraintParams_t::SetTwistHighLimitRestitution)
        .addProperty("TwistHighLimitSpring", &GVPhysXConstraintParams_t::GetTwistHighLimitSpring, &GVPhysXConstraintParams_t::SetTwistHighLimitSpring)
        .addProperty("TwistHighLimitDamping", &GVPhysXConstraintParams_t::GetTwistHighLimitDamping, &GVPhysXConstraintParams_t::SetTwistHighLimitDamping)
        .addProperty("Swing1LimitValue", &GVPhysXConstraintParams_t::GetSwing1LimitValue, &GVPhysXConstraintParams_t::SetSwing1LimitValue)
        .addProperty("Swing1LimitRestitution", &GVPhysXConstraintParams_t::GetSwing1LimitRestitution, &GVPhysXConstraintParams_t::SetSwing1LimitRestitution)
        .addProperty("Swing1LimitSpring", &GVPhysXConstraintParams_t::GetSwing1LimitSpring, &GVPhysXConstraintParams_t::SetSwing1LimitSpring)
        .addProperty("Swing1LimitDamping", &GVPhysXConstraintParams_t::GetSwing1LimitDamping, &GVPhysXConstraintParams_t::SetSwing1LimitDamping)
        .addProperty("Swing2LimitValue", &GVPhysXConstraintParams_t::GetSwing2LimitValue, &GVPhysXConstraintParams_t::SetSwing2LimitValue)
        .addProperty("Swing2LimitRestitution", &GVPhysXConstraintParams_t::GetSwing2LimitRestitution, &GVPhysXConstraintParams_t::SetSwing2LimitRestitution)
        .addProperty("Swing2LimitSpring", &GVPhysXConstraintParams_t::GetSwing2LimitSpring, &GVPhysXConstraintParams_t::SetSwing2LimitSpring)
        .addProperty("Swing2LimitDamping", &GVPhysXConstraintParams_t::GetSwing2LimitDamping, &GVPhysXConstraintParams_t::SetSwing2LimitDamping)
        .addProperty("GoalPosition", &GVPhysXConstraintParams_t::GetGoalPosition, &GVPhysXConstraintParams_t::SetGoalPosition)
        .addProperty("GoalAngularVelocity", &GVPhysXConstraintParams_t::GetGoalAngularVelocity, &GVPhysXConstraintParams_t::SetGoalAngularVelocity)
        .addProperty("DriveSpringX", &GVPhysXConstraintParams_t::GetDriveSpringX, &GVPhysXConstraintParams_t::SetDriveSpringX)
        .addProperty("DriveSpringY", &GVPhysXConstraintParams_t::GetDriveSpringY, &GVPhysXConstraintParams_t::SetDriveSpringY)
        .addProperty("DriveSpringZ", &GVPhysXConstraintParams_t::GetDriveSpringZ, &GVPhysXConstraintParams_t::SetDriveSpringZ)
        .addProperty("DriveDampingX", &GVPhysXConstraintParams_t::GetDriveDampingX, &GVPhysXConstraintParams_t::SetDriveDampingX)
        .addProperty("DriveDampingY", &GVPhysXConstraintParams_t::GetDriveDampingY, &GVPhysXConstraintParams_t::SetDriveDampingY)
        .addProperty("DriveDampingZ", &GVPhysXConstraintParams_t::GetDriveDampingZ, &GVPhysXConstraintParams_t::SetDriveDampingZ)
        .addProperty("DriveSpringTwist", &GVPhysXConstraintParams_t::GetDriveSpringTwist, &GVPhysXConstraintParams_t::SetDriveSpringTwist)
        .addProperty("DriveSpringSwing", &GVPhysXConstraintParams_t::GetDriveSpringSwing, &GVPhysXConstraintParams_t::SetDriveSpringSwing)
        .addProperty("DriveSpringSlerp", &GVPhysXConstraintParams_t::GetDriveSpringSlerp, &GVPhysXConstraintParams_t::SetDriveSpringSlerp)
        .addProperty("DriveDampingTwist", &GVPhysXConstraintParams_t::GetDriveDampingTwist, &GVPhysXConstraintParams_t::SetDriveDampingTwist)
        .addProperty("DriveDampingSwing", &GVPhysXConstraintParams_t::GetDriveDampingSwing, &GVPhysXConstraintParams_t::SetDriveDampingSwing)
        .addProperty("DriveDampingSlerp", &GVPhysXConstraintParams_t::GetDriveDampingSlerp, &GVPhysXConstraintParams_t::SetDriveDampingSlerp)
        .addProperty("SolverIterationCount", &GVPhysXConstraintParams_t::GetSolverIterationCount, &GVPhysXConstraintParams_t::SetSolverIterationCount)
        .addProperty("ProjectionLinearTolerance", &GVPhysXConstraintParams_t::GetProjectionLinearTolerance, &GVPhysXConstraintParams_t::SetProjectionLinearTolerance)
        .addProperty("ProjectionAngularTolerance", &GVPhysXConstraintParams_t::GetProjectionAngularTolerance, &GVPhysXConstraintParams_t::SetProjectionAngularTolerance)
        .addFunction("ToPtr", &GVPhysXConstraintParams_t::ToPtr)
        .addFunction("IsValid", &GVPhysXConstraintParams_t::IsValid)
        .endClass();
}
GCMorphRectData::GCMorphRectData(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCMorphRectData::GCMorphRectData(void *ptr) {
    m_ptr = ptr;
}
int16_t GCMorphRectData::GetXLeftDst() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CMorphRectData->XLeftDst(ptr=%p)", m_ptr));
    return GetSchemaValue<int16_t>(m_ptr, "CMorphRectData", "m_nXLeftDst");
}
void GCMorphRectData::SetXLeftDst(int16_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CMorphRectData->XLeftDst(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CMorphRectData", "m_nXLeftDst", false, value);
}
int16_t GCMorphRectData::GetYTopDst() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CMorphRectData->YTopDst(ptr=%p)", m_ptr));
    return GetSchemaValue<int16_t>(m_ptr, "CMorphRectData", "m_nYTopDst");
}
void GCMorphRectData::SetYTopDst(int16_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CMorphRectData->YTopDst(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CMorphRectData", "m_nYTopDst", false, value);
}
float GCMorphRectData::GetUWidthSrc() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CMorphRectData->UWidthSrc(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CMorphRectData", "m_flUWidthSrc");
}
void GCMorphRectData::SetUWidthSrc(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CMorphRectData->UWidthSrc(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CMorphRectData", "m_flUWidthSrc", false, value);
}
float GCMorphRectData::GetVHeightSrc() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CMorphRectData->VHeightSrc(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CMorphRectData", "m_flVHeightSrc");
}
void GCMorphRectData::SetVHeightSrc(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CMorphRectData->VHeightSrc(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CMorphRectData", "m_flVHeightSrc", false, value);
}
std::vector<GCMorphBundleData> GCMorphRectData::GetBundleDatas() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CMorphRectData->BundleDatas(ptr=%p)", m_ptr));
    CUtlVector<GCMorphBundleData>* vec = GetSchemaValue<CUtlVector<GCMorphBundleData>*>(m_ptr, "CMorphRectData", "m_bundleDatas"); std::vector<GCMorphBundleData> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCMorphRectData::SetBundleDatas(std::vector<GCMorphBundleData> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CMorphRectData->BundleDatas(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<GCMorphBundleData>(m_ptr, "CMorphRectData", "m_bundleDatas", false, value);
}
void* GCMorphRectData::GetPtr() {
    return m_ptr;
}
std::string GCMorphRectData::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCMorphRectData::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCMorphRectData(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCMorphRectData>("CMorphRectData")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("XLeftDst", &GCMorphRectData::GetXLeftDst, &GCMorphRectData::SetXLeftDst)
        .addProperty("YTopDst", &GCMorphRectData::GetYTopDst, &GCMorphRectData::SetYTopDst)
        .addProperty("UWidthSrc", &GCMorphRectData::GetUWidthSrc, &GCMorphRectData::SetUWidthSrc)
        .addProperty("VHeightSrc", &GCMorphRectData::GetVHeightSrc, &GCMorphRectData::SetVHeightSrc)
        .addProperty("BundleDatas", &GCMorphRectData::GetBundleDatas, &GCMorphRectData::SetBundleDatas)
        .addFunction("ToPtr", &GCMorphRectData::ToPtr)
        .addFunction("IsValid", &GCMorphRectData::IsValid)
        .endClass();
}
GEventServerPollNetworking_t::GEventServerPollNetworking_t(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GEventServerPollNetworking_t::GEventServerPollNetworking_t(void *ptr) {
    m_ptr = ptr;
}
void* GEventServerPollNetworking_t::GetPtr() {
    return m_ptr;
}
std::string GEventServerPollNetworking_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GEventServerPollNetworking_t::IsValid() {
    return (m_ptr != nullptr);
}
GEventSimulate_t GEventServerPollNetworking_t::GetParent() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("EventServerPollNetworking_t::GetParent(ptr=%p)", m_ptr));
    GEventSimulate_t value(m_ptr);
    return value;
}
void GEventServerPollNetworking_t::SetParent(GEventSimulate_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("EventServerPollNetworking_t::SetParent(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassEventServerPollNetworking_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GEventServerPollNetworking_t>("EventServerPollNetworking_t")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Parent", &GEventServerPollNetworking_t::GetParent, &GEventServerPollNetworking_t::SetParent)
        .addFunction("ToPtr", &GEventServerPollNetworking_t::ToPtr)
        .addFunction("IsValid", &GEventServerPollNetworking_t::IsValid)
        .endClass();
}
GCDspPresetModifierList::GCDspPresetModifierList(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCDspPresetModifierList::GCDspPresetModifierList(void *ptr) {
    m_ptr = ptr;
}
std::string GCDspPresetModifierList::GetDspName() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CDspPresetModifierList->DspName(ptr=%p)", m_ptr));
    return GetSchemaValue<CUtlString>(m_ptr, "CDspPresetModifierList", "m_dspName").Get();
}
void GCDspPresetModifierList::SetDspName(std::string value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CDspPresetModifierList->DspName(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CDspPresetModifierList", "m_dspName", false, CUtlString(value.c_str()));
}
std::vector<GCDSPMixgroupModifier> GCDspPresetModifierList::GetModifiers() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CDspPresetModifierList->Modifiers(ptr=%p)", m_ptr));
    CUtlVector<GCDSPMixgroupModifier>* vec = GetSchemaValue<CUtlVector<GCDSPMixgroupModifier>*>(m_ptr, "CDspPresetModifierList", "m_modifiers"); std::vector<GCDSPMixgroupModifier> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCDspPresetModifierList::SetModifiers(std::vector<GCDSPMixgroupModifier> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CDspPresetModifierList->Modifiers(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<GCDSPMixgroupModifier>(m_ptr, "CDspPresetModifierList", "m_modifiers", false, value);
}
void* GCDspPresetModifierList::GetPtr() {
    return m_ptr;
}
std::string GCDspPresetModifierList::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCDspPresetModifierList::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCDspPresetModifierList(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCDspPresetModifierList>("CDspPresetModifierList")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("DspName", &GCDspPresetModifierList::GetDspName, &GCDspPresetModifierList::SetDspName)
        .addProperty("Modifiers", &GCDspPresetModifierList::GetModifiers, &GCDspPresetModifierList::SetModifiers)
        .addFunction("ToPtr", &GCDspPresetModifierList::ToPtr)
        .addFunction("IsValid", &GCDspPresetModifierList::IsValid)
        .endClass();
}
GSkeletonDemoDb_t::GSkeletonDemoDb_t(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GSkeletonDemoDb_t::GSkeletonDemoDb_t(void *ptr) {
    m_ptr = ptr;
}
std::vector<GSkeletonAnimCapture_t*> GSkeletonDemoDb_t::GetAnimCaptures() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: SkeletonDemoDb_t->AnimCaptures(ptr=%p)", m_ptr));
    CUtlVector<GSkeletonAnimCapture_t*>* vec = GetSchemaValue<CUtlVector<GSkeletonAnimCapture_t*>*>(m_ptr, "SkeletonDemoDb_t", "m_AnimCaptures"); std::vector<GSkeletonAnimCapture_t*> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GSkeletonDemoDb_t::SetAnimCaptures(std::vector<GSkeletonAnimCapture_t*> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: SkeletonDemoDb_t->AnimCaptures(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<GSkeletonAnimCapture_t*>(m_ptr, "SkeletonDemoDb_t", "m_AnimCaptures", true, value);
}
std::vector<GSkeletonAnimCapture_t> GSkeletonDemoDb_t::GetCameraTrack() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: SkeletonDemoDb_t->CameraTrack(ptr=%p)", m_ptr));
    CUtlVector<GSkeletonAnimCapture_t>* vec = GetSchemaValue<CUtlVector<GSkeletonAnimCapture_t>*>(m_ptr, "SkeletonDemoDb_t", "m_CameraTrack"); std::vector<GSkeletonAnimCapture_t> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GSkeletonDemoDb_t::SetCameraTrack(std::vector<GSkeletonAnimCapture_t> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: SkeletonDemoDb_t->CameraTrack(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<GSkeletonAnimCapture_t>(m_ptr, "SkeletonDemoDb_t", "m_CameraTrack", true, value);
}
float GSkeletonDemoDb_t::GetRecordingTime() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: SkeletonDemoDb_t->RecordingTime(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "SkeletonDemoDb_t", "m_flRecordingTime");
}
void GSkeletonDemoDb_t::SetRecordingTime(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: SkeletonDemoDb_t->RecordingTime(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "SkeletonDemoDb_t", "m_flRecordingTime", true, value);
}
void* GSkeletonDemoDb_t::GetPtr() {
    return m_ptr;
}
std::string GSkeletonDemoDb_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GSkeletonDemoDb_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassSkeletonDemoDb_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GSkeletonDemoDb_t>("SkeletonDemoDb_t")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("AnimCaptures", &GSkeletonDemoDb_t::GetAnimCaptures, &GSkeletonDemoDb_t::SetAnimCaptures)
        .addProperty("CameraTrack", &GSkeletonDemoDb_t::GetCameraTrack, &GSkeletonDemoDb_t::SetCameraTrack)
        .addProperty("RecordingTime", &GSkeletonDemoDb_t::GetRecordingTime, &GSkeletonDemoDb_t::SetRecordingTime)
        .addFunction("ToPtr", &GSkeletonDemoDb_t::ToPtr)
        .addFunction("IsValid", &GSkeletonDemoDb_t::IsValid)
        .endClass();
}
GCRenderGroom::GCRenderGroom(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCRenderGroom::GCRenderGroom(void *ptr) {
    m_ptr = ptr;
}
std::vector<GRenderHairStrandInfo_t> GCRenderGroom::GetHairs() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CRenderGroom->Hairs(ptr=%p)", m_ptr));
    CUtlVector<GRenderHairStrandInfo_t>* vec = GetSchemaValue<CUtlVector<GRenderHairStrandInfo_t>*>(m_ptr, "CRenderGroom", "m_hairs"); std::vector<GRenderHairStrandInfo_t> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCRenderGroom::SetHairs(std::vector<GRenderHairStrandInfo_t> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CRenderGroom->Hairs(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<GRenderHairStrandInfo_t>(m_ptr, "CRenderGroom", "m_hairs", false, value);
}
int32_t GCRenderGroom::GetSegmentsPerHairStrand() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CRenderGroom->SegmentsPerHairStrand(ptr=%p)", m_ptr));
    return GetSchemaValue<int32_t>(m_ptr, "CRenderGroom", "m_nSegmentsPerHairStrand");
}
void GCRenderGroom::SetSegmentsPerHairStrand(int32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CRenderGroom->SegmentsPerHairStrand(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CRenderGroom", "m_nSegmentsPerHairStrand", false, value);
}
int32_t GCRenderGroom::GetGuideHairCount() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CRenderGroom->GuideHairCount(ptr=%p)", m_ptr));
    return GetSchemaValue<int32_t>(m_ptr, "CRenderGroom", "m_nGuideHairCount");
}
void GCRenderGroom::SetGuideHairCount(int32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CRenderGroom->GuideHairCount(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CRenderGroom", "m_nGuideHairCount", false, value);
}
int32_t GCRenderGroom::GetHairCount() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CRenderGroom->HairCount(ptr=%p)", m_ptr));
    return GetSchemaValue<int32_t>(m_ptr, "CRenderGroom", "m_nHairCount");
}
void GCRenderGroom::SetHairCount(int32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CRenderGroom->HairCount(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CRenderGroom", "m_nHairCount", false, value);
}
int32_t GCRenderGroom::GetGroomGroupID() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CRenderGroom->GroomGroupID(ptr=%p)", m_ptr));
    return GetSchemaValue<int32_t>(m_ptr, "CRenderGroom", "m_nGroomGroupID");
}
void GCRenderGroom::SetGroomGroupID(int32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CRenderGroom->GroomGroupID(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CRenderGroom", "m_nGroomGroupID", false, value);
}
int32_t GCRenderGroom::GetAttachBoneIdx() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CRenderGroom->AttachBoneIdx(ptr=%p)", m_ptr));
    return GetSchemaValue<int32_t>(m_ptr, "CRenderGroom", "m_nAttachBoneIdx");
}
void GCRenderGroom::SetAttachBoneIdx(int32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CRenderGroom->AttachBoneIdx(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CRenderGroom", "m_nAttachBoneIdx", false, value);
}
int32_t GCRenderGroom::GetAttachMeshIdx() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CRenderGroom->AttachMeshIdx(ptr=%p)", m_ptr));
    return GetSchemaValue<int32_t>(m_ptr, "CRenderGroom", "m_nAttachMeshIdx");
}
void GCRenderGroom::SetAttachMeshIdx(int32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CRenderGroom->AttachMeshIdx(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CRenderGroom", "m_nAttachMeshIdx", false, value);
}
int32_t GCRenderGroom::GetAttachMeshDrawCallIdx() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CRenderGroom->AttachMeshDrawCallIdx(ptr=%p)", m_ptr));
    return GetSchemaValue<int32_t>(m_ptr, "CRenderGroom", "m_nAttachMeshDrawCallIdx");
}
void GCRenderGroom::SetAttachMeshDrawCallIdx(int32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CRenderGroom->AttachMeshDrawCallIdx(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CRenderGroom", "m_nAttachMeshDrawCallIdx", false, value);
}
float GCRenderGroom::GetSumOfAllHairLengths() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CRenderGroom->SumOfAllHairLengths(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CRenderGroom", "m_flSumOfAllHairLengths");
}
void GCRenderGroom::SetSumOfAllHairLengths(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CRenderGroom->SumOfAllHairLengths(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CRenderGroom", "m_flSumOfAllHairLengths", false, value);
}
bool GCRenderGroom::GetEnableSimulation() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CRenderGroom->EnableSimulation(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "CRenderGroom", "m_bEnableSimulation");
}
void GCRenderGroom::SetEnableSimulation(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CRenderGroom->EnableSimulation(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CRenderGroom", "m_bEnableSimulation", false, value);
}
void* GCRenderGroom::GetPtr() {
    return m_ptr;
}
std::string GCRenderGroom::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCRenderGroom::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCRenderGroom(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCRenderGroom>("CRenderGroom")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Hairs", &GCRenderGroom::GetHairs, &GCRenderGroom::SetHairs)
        .addProperty("SegmentsPerHairStrand", &GCRenderGroom::GetSegmentsPerHairStrand, &GCRenderGroom::SetSegmentsPerHairStrand)
        .addProperty("GuideHairCount", &GCRenderGroom::GetGuideHairCount, &GCRenderGroom::SetGuideHairCount)
        .addProperty("HairCount", &GCRenderGroom::GetHairCount, &GCRenderGroom::SetHairCount)
        .addProperty("GroomGroupID", &GCRenderGroom::GetGroomGroupID, &GCRenderGroom::SetGroomGroupID)
        .addProperty("AttachBoneIdx", &GCRenderGroom::GetAttachBoneIdx, &GCRenderGroom::SetAttachBoneIdx)
        .addProperty("AttachMeshIdx", &GCRenderGroom::GetAttachMeshIdx, &GCRenderGroom::SetAttachMeshIdx)
        .addProperty("AttachMeshDrawCallIdx", &GCRenderGroom::GetAttachMeshDrawCallIdx, &GCRenderGroom::SetAttachMeshDrawCallIdx)
        .addProperty("SumOfAllHairLengths", &GCRenderGroom::GetSumOfAllHairLengths, &GCRenderGroom::SetSumOfAllHairLengths)
        .addProperty("EnableSimulation", &GCRenderGroom::GetEnableSimulation, &GCRenderGroom::SetEnableSimulation)
        .addFunction("ToPtr", &GCRenderGroom::ToPtr)
        .addFunction("IsValid", &GCRenderGroom::IsValid)
        .endClass();
}
GCUnaryUpdateNode::GCUnaryUpdateNode(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCUnaryUpdateNode::GCUnaryUpdateNode(void *ptr) {
    m_ptr = ptr;
}
GCAnimUpdateNodeRef GCUnaryUpdateNode::GetChildNode() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CUnaryUpdateNode->ChildNode(ptr=%p)", m_ptr));
    GCAnimUpdateNodeRef value(GetSchemaPtr(m_ptr, "CUnaryUpdateNode", "m_pChildNode"));
    return value;
}
void GCUnaryUpdateNode::SetChildNode(GCAnimUpdateNodeRef value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CUnaryUpdateNode->ChildNode(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'ChildNode' is not possible.\n");
}
void* GCUnaryUpdateNode::GetPtr() {
    return m_ptr;
}
std::string GCUnaryUpdateNode::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCUnaryUpdateNode::IsValid() {
    return (m_ptr != nullptr);
}
GCAnimUpdateNodeBase GCUnaryUpdateNode::GetParent() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CUnaryUpdateNode::GetParent(ptr=%p)", m_ptr));
    GCAnimUpdateNodeBase value(m_ptr);
    return value;
}
void GCUnaryUpdateNode::SetParent(GCAnimUpdateNodeBase value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CUnaryUpdateNode::SetParent(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCUnaryUpdateNode(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCUnaryUpdateNode>("CUnaryUpdateNode")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("ChildNode", &GCUnaryUpdateNode::GetChildNode, &GCUnaryUpdateNode::SetChildNode)
        .addProperty("Parent", &GCUnaryUpdateNode::GetParent, &GCUnaryUpdateNode::SetParent)
        .addFunction("ToPtr", &GCUnaryUpdateNode::ToPtr)
        .addFunction("IsValid", &GCUnaryUpdateNode::IsValid)
        .endClass();
}
GCBlendCurve::GCBlendCurve(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCBlendCurve::GCBlendCurve(void *ptr) {
    m_ptr = ptr;
}
float GCBlendCurve::GetControlPoint1() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CBlendCurve->ControlPoint1(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CBlendCurve", "m_flControlPoint1");
}
void GCBlendCurve::SetControlPoint1(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CBlendCurve->ControlPoint1(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CBlendCurve", "m_flControlPoint1", false, value);
}
float GCBlendCurve::GetControlPoint2() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CBlendCurve->ControlPoint2(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CBlendCurve", "m_flControlPoint2");
}
void GCBlendCurve::SetControlPoint2(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CBlendCurve->ControlPoint2(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CBlendCurve", "m_flControlPoint2", false, value);
}
void* GCBlendCurve::GetPtr() {
    return m_ptr;
}
std::string GCBlendCurve::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCBlendCurve::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCBlendCurve(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCBlendCurve>("CBlendCurve")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("ControlPoint1", &GCBlendCurve::GetControlPoint1, &GCBlendCurve::SetControlPoint1)
        .addProperty("ControlPoint2", &GCBlendCurve::GetControlPoint2, &GCBlendCurve::SetControlPoint2)
        .addFunction("ToPtr", &GCBlendCurve::ToPtr)
        .addFunction("IsValid", &GCBlendCurve::IsValid)
        .endClass();
}
GChangeAccessorFieldPathIndex_t::GChangeAccessorFieldPathIndex_t(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GChangeAccessorFieldPathIndex_t::GChangeAccessorFieldPathIndex_t(void *ptr) {
    m_ptr = ptr;
}
int16_t GChangeAccessorFieldPathIndex_t::GetValue() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: ChangeAccessorFieldPathIndex_t->Value(ptr=%p)", m_ptr));
    return GetSchemaValue<int16_t>(m_ptr, "ChangeAccessorFieldPathIndex_t", "m_Value");
}
void GChangeAccessorFieldPathIndex_t::SetValue(int16_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: ChangeAccessorFieldPathIndex_t->Value(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "ChangeAccessorFieldPathIndex_t", "m_Value", true, value);
}
void* GChangeAccessorFieldPathIndex_t::GetPtr() {
    return m_ptr;
}
std::string GChangeAccessorFieldPathIndex_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GChangeAccessorFieldPathIndex_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassChangeAccessorFieldPathIndex_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GChangeAccessorFieldPathIndex_t>("ChangeAccessorFieldPathIndex_t")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Value", &GChangeAccessorFieldPathIndex_t::GetValue, &GChangeAccessorFieldPathIndex_t::SetValue)
        .addFunction("ToPtr", &GChangeAccessorFieldPathIndex_t::ToPtr)
        .addFunction("IsValid", &GChangeAccessorFieldPathIndex_t::IsValid)
        .endClass();
}
GFeKelagerBend2_t::GFeKelagerBend2_t(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GFeKelagerBend2_t::GFeKelagerBend2_t(void *ptr) {
    m_ptr = ptr;
}
std::vector<float> GFeKelagerBend2_t::GetWeight() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FeKelagerBend2_t->Weight(ptr=%p,size=3)", m_ptr));
    float* outValue = (float*)GetSchemaPtr(m_ptr, "FeKelagerBend2_t", "flWeight"); std::vector<float> ret; for(int i = 0; i < 3; i++) { ret.push_back(outValue[i]); } return ret;
}
void GFeKelagerBend2_t::SetWeight(std::vector<float> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FeKelagerBend2_t->Weight(ptr=%p,size=3)", m_ptr));
    if(value.size() != 3) return PLUGIN_PRINT("Schema SDK", "Field 'Weight' needs to have 3 values.\n");
    auto val = GetSchemaValuePtr<float>(m_ptr, "FeKelagerBend2_t", "flWeight");
    for(size_t i = 0; i < value.size(); i++) val[i] = value[i];
}
float GFeKelagerBend2_t::GetHeight0() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FeKelagerBend2_t->Height0(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "FeKelagerBend2_t", "flHeight0");
}
void GFeKelagerBend2_t::SetHeight0(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FeKelagerBend2_t->Height0(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "FeKelagerBend2_t", "flHeight0", true, value);
}
std::vector<uint16_t> GFeKelagerBend2_t::GetNode() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FeKelagerBend2_t->Node(ptr=%p,size=3)", m_ptr));
    uint16_t* outValue = (uint16_t*)GetSchemaPtr(m_ptr, "FeKelagerBend2_t", "nNode"); std::vector<uint16_t> ret; for(int i = 0; i < 3; i++) { ret.push_back(outValue[i]); } return ret;
}
void GFeKelagerBend2_t::SetNode(std::vector<uint16_t> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FeKelagerBend2_t->Node(ptr=%p,size=3)", m_ptr));
    if(value.size() != 3) return PLUGIN_PRINT("Schema SDK", "Field 'Node' needs to have 3 values.\n");
    auto val = GetSchemaValuePtr<uint16_t>(m_ptr, "FeKelagerBend2_t", "nNode");
    for(size_t i = 0; i < value.size(); i++) val[i] = value[i];
}
uint16_t GFeKelagerBend2_t::GetReserved() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FeKelagerBend2_t->Reserved(ptr=%p)", m_ptr));
    return GetSchemaValue<uint16_t>(m_ptr, "FeKelagerBend2_t", "nReserved");
}
void GFeKelagerBend2_t::SetReserved(uint16_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FeKelagerBend2_t->Reserved(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "FeKelagerBend2_t", "nReserved", true, value);
}
void* GFeKelagerBend2_t::GetPtr() {
    return m_ptr;
}
std::string GFeKelagerBend2_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GFeKelagerBend2_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassFeKelagerBend2_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GFeKelagerBend2_t>("FeKelagerBend2_t")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Weight", &GFeKelagerBend2_t::GetWeight, &GFeKelagerBend2_t::SetWeight)
        .addProperty("Height0", &GFeKelagerBend2_t::GetHeight0, &GFeKelagerBend2_t::SetHeight0)
        .addProperty("Node", &GFeKelagerBend2_t::GetNode, &GFeKelagerBend2_t::SetNode)
        .addProperty("Reserved", &GFeKelagerBend2_t::GetReserved, &GFeKelagerBend2_t::SetReserved)
        .addFunction("ToPtr", &GFeKelagerBend2_t::ToPtr)
        .addFunction("IsValid", &GFeKelagerBend2_t::IsValid)
        .endClass();
}
GCMorphSetData::GCMorphSetData(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCMorphSetData::GCMorphSetData(void *ptr) {
    m_ptr = ptr;
}
int32_t GCMorphSetData::GetWidth() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CMorphSetData->Width(ptr=%p)", m_ptr));
    return GetSchemaValue<int32_t>(m_ptr, "CMorphSetData", "m_nWidth");
}
void GCMorphSetData::SetWidth(int32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CMorphSetData->Width(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CMorphSetData", "m_nWidth", false, value);
}
int32_t GCMorphSetData::GetHeight() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CMorphSetData->Height(ptr=%p)", m_ptr));
    return GetSchemaValue<int32_t>(m_ptr, "CMorphSetData", "m_nHeight");
}
void GCMorphSetData::SetHeight(int32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CMorphSetData->Height(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CMorphSetData", "m_nHeight", false, value);
}
std::vector<MorphBundleType_t> GCMorphSetData::GetBundleTypes() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CMorphSetData->BundleTypes(ptr=%p)", m_ptr));
    CUtlVector<MorphBundleType_t>* vec = GetSchemaValue<CUtlVector<MorphBundleType_t>*>(m_ptr, "CMorphSetData", "m_bundleTypes"); std::vector<MorphBundleType_t> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCMorphSetData::SetBundleTypes(std::vector<MorphBundleType_t> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CMorphSetData->BundleTypes(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<MorphBundleType_t>(m_ptr, "CMorphSetData", "m_bundleTypes", false, value);
}
std::vector<GCMorphData> GCMorphSetData::GetMorphDatas() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CMorphSetData->MorphDatas(ptr=%p)", m_ptr));
    CUtlVector<GCMorphData>* vec = GetSchemaValue<CUtlVector<GCMorphData>*>(m_ptr, "CMorphSetData", "m_morphDatas"); std::vector<GCMorphData> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCMorphSetData::SetMorphDatas(std::vector<GCMorphData> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CMorphSetData->MorphDatas(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<GCMorphData>(m_ptr, "CMorphSetData", "m_morphDatas", false, value);
}
std::vector<GCFlexDesc> GCMorphSetData::GetFlexDesc() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CMorphSetData->FlexDesc(ptr=%p)", m_ptr));
    CUtlVector<GCFlexDesc>* vec = GetSchemaValue<CUtlVector<GCFlexDesc>*>(m_ptr, "CMorphSetData", "m_FlexDesc"); std::vector<GCFlexDesc> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCMorphSetData::SetFlexDesc(std::vector<GCFlexDesc> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CMorphSetData->FlexDesc(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<GCFlexDesc>(m_ptr, "CMorphSetData", "m_FlexDesc", false, value);
}
std::vector<GCFlexController> GCMorphSetData::GetFlexControllers() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CMorphSetData->FlexControllers(ptr=%p)", m_ptr));
    CUtlVector<GCFlexController>* vec = GetSchemaValue<CUtlVector<GCFlexController>*>(m_ptr, "CMorphSetData", "m_FlexControllers"); std::vector<GCFlexController> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCMorphSetData::SetFlexControllers(std::vector<GCFlexController> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CMorphSetData->FlexControllers(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<GCFlexController>(m_ptr, "CMorphSetData", "m_FlexControllers", false, value);
}
std::vector<GCFlexRule> GCMorphSetData::GetFlexRules() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CMorphSetData->FlexRules(ptr=%p)", m_ptr));
    CUtlVector<GCFlexRule>* vec = GetSchemaValue<CUtlVector<GCFlexRule>*>(m_ptr, "CMorphSetData", "m_FlexRules"); std::vector<GCFlexRule> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCMorphSetData::SetFlexRules(std::vector<GCFlexRule> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CMorphSetData->FlexRules(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<GCFlexRule>(m_ptr, "CMorphSetData", "m_FlexRules", false, value);
}
void* GCMorphSetData::GetPtr() {
    return m_ptr;
}
std::string GCMorphSetData::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCMorphSetData::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCMorphSetData(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCMorphSetData>("CMorphSetData")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Width", &GCMorphSetData::GetWidth, &GCMorphSetData::SetWidth)
        .addProperty("Height", &GCMorphSetData::GetHeight, &GCMorphSetData::SetHeight)
        .addProperty("BundleTypes", &GCMorphSetData::GetBundleTypes, &GCMorphSetData::SetBundleTypes)
        .addProperty("MorphDatas", &GCMorphSetData::GetMorphDatas, &GCMorphSetData::SetMorphDatas)
        .addProperty("FlexDesc", &GCMorphSetData::GetFlexDesc, &GCMorphSetData::SetFlexDesc)
        .addProperty("FlexControllers", &GCMorphSetData::GetFlexControllers, &GCMorphSetData::SetFlexControllers)
        .addProperty("FlexRules", &GCMorphSetData::GetFlexRules, &GCMorphSetData::SetFlexRules)
        .addFunction("ToPtr", &GCMorphSetData::ToPtr)
        .addFunction("IsValid", &GCMorphSetData::IsValid)
        .endClass();
}
GCBinaryUpdateNode::GCBinaryUpdateNode(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCBinaryUpdateNode::GCBinaryUpdateNode(void *ptr) {
    m_ptr = ptr;
}
GCAnimUpdateNodeRef GCBinaryUpdateNode::GetChild1() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CBinaryUpdateNode->Child1(ptr=%p)", m_ptr));
    GCAnimUpdateNodeRef value(GetSchemaPtr(m_ptr, "CBinaryUpdateNode", "m_pChild1"));
    return value;
}
void GCBinaryUpdateNode::SetChild1(GCAnimUpdateNodeRef value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CBinaryUpdateNode->Child1(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Child1' is not possible.\n");
}
GCAnimUpdateNodeRef GCBinaryUpdateNode::GetChild2() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CBinaryUpdateNode->Child2(ptr=%p)", m_ptr));
    GCAnimUpdateNodeRef value(GetSchemaPtr(m_ptr, "CBinaryUpdateNode", "m_pChild2"));
    return value;
}
void GCBinaryUpdateNode::SetChild2(GCAnimUpdateNodeRef value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CBinaryUpdateNode->Child2(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Child2' is not possible.\n");
}
uint64_t GCBinaryUpdateNode::GetTimingBehavior() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CBinaryUpdateNode->TimingBehavior(ptr=%p)", m_ptr));
    return GetSchemaValue<uint64_t>(m_ptr, "CBinaryUpdateNode", "m_timingBehavior");
}
void GCBinaryUpdateNode::SetTimingBehavior(uint64_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CBinaryUpdateNode->TimingBehavior(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CBinaryUpdateNode", "m_timingBehavior", false, value);
}
float GCBinaryUpdateNode::GetTimingBlend() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CBinaryUpdateNode->TimingBlend(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CBinaryUpdateNode", "m_flTimingBlend");
}
void GCBinaryUpdateNode::SetTimingBlend(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CBinaryUpdateNode->TimingBlend(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CBinaryUpdateNode", "m_flTimingBlend", false, value);
}
bool GCBinaryUpdateNode::GetResetChild1() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CBinaryUpdateNode->ResetChild1(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "CBinaryUpdateNode", "m_bResetChild1");
}
void GCBinaryUpdateNode::SetResetChild1(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CBinaryUpdateNode->ResetChild1(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CBinaryUpdateNode", "m_bResetChild1", false, value);
}
bool GCBinaryUpdateNode::GetResetChild2() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CBinaryUpdateNode->ResetChild2(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "CBinaryUpdateNode", "m_bResetChild2");
}
void GCBinaryUpdateNode::SetResetChild2(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CBinaryUpdateNode->ResetChild2(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CBinaryUpdateNode", "m_bResetChild2", false, value);
}
void* GCBinaryUpdateNode::GetPtr() {
    return m_ptr;
}
std::string GCBinaryUpdateNode::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCBinaryUpdateNode::IsValid() {
    return (m_ptr != nullptr);
}
GCAnimUpdateNodeBase GCBinaryUpdateNode::GetParent() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CBinaryUpdateNode::GetParent(ptr=%p)", m_ptr));
    GCAnimUpdateNodeBase value(m_ptr);
    return value;
}
void GCBinaryUpdateNode::SetParent(GCAnimUpdateNodeBase value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CBinaryUpdateNode::SetParent(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCBinaryUpdateNode(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCBinaryUpdateNode>("CBinaryUpdateNode")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Child1", &GCBinaryUpdateNode::GetChild1, &GCBinaryUpdateNode::SetChild1)
        .addProperty("Child2", &GCBinaryUpdateNode::GetChild2, &GCBinaryUpdateNode::SetChild2)
        .addProperty("TimingBehavior", &GCBinaryUpdateNode::GetTimingBehavior, &GCBinaryUpdateNode::SetTimingBehavior)
        .addProperty("TimingBlend", &GCBinaryUpdateNode::GetTimingBlend, &GCBinaryUpdateNode::SetTimingBlend)
        .addProperty("ResetChild1", &GCBinaryUpdateNode::GetResetChild1, &GCBinaryUpdateNode::SetResetChild1)
        .addProperty("ResetChild2", &GCBinaryUpdateNode::GetResetChild2, &GCBinaryUpdateNode::SetResetChild2)
        .addProperty("Parent", &GCBinaryUpdateNode::GetParent, &GCBinaryUpdateNode::SetParent)
        .addFunction("ToPtr", &GCBinaryUpdateNode::ToPtr)
        .addFunction("IsValid", &GCBinaryUpdateNode::IsValid)
        .endClass();
}
Gconstraint_axislimit_t::Gconstraint_axislimit_t(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
Gconstraint_axislimit_t::Gconstraint_axislimit_t(void *ptr) {
    m_ptr = ptr;
}
float Gconstraint_axislimit_t::GetMinRotation() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: constraint_axislimit_t->MinRotation(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "constraint_axislimit_t", "flMinRotation");
}
void Gconstraint_axislimit_t::SetMinRotation(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: constraint_axislimit_t->MinRotation(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "constraint_axislimit_t", "flMinRotation", true, value);
}
float Gconstraint_axislimit_t::GetMaxRotation() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: constraint_axislimit_t->MaxRotation(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "constraint_axislimit_t", "flMaxRotation");
}
void Gconstraint_axislimit_t::SetMaxRotation(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: constraint_axislimit_t->MaxRotation(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "constraint_axislimit_t", "flMaxRotation", true, value);
}
float Gconstraint_axislimit_t::GetMotorTargetAngSpeed() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: constraint_axislimit_t->MotorTargetAngSpeed(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "constraint_axislimit_t", "flMotorTargetAngSpeed");
}
void Gconstraint_axislimit_t::SetMotorTargetAngSpeed(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: constraint_axislimit_t->MotorTargetAngSpeed(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "constraint_axislimit_t", "flMotorTargetAngSpeed", true, value);
}
float Gconstraint_axislimit_t::GetMotorMaxTorque() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: constraint_axislimit_t->MotorMaxTorque(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "constraint_axislimit_t", "flMotorMaxTorque");
}
void Gconstraint_axislimit_t::SetMotorMaxTorque(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: constraint_axislimit_t->MotorMaxTorque(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "constraint_axislimit_t", "flMotorMaxTorque", true, value);
}
void* Gconstraint_axislimit_t::GetPtr() {
    return m_ptr;
}
std::string Gconstraint_axislimit_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool Gconstraint_axislimit_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassconstraint_axislimit_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<Gconstraint_axislimit_t>("constraint_axislimit_t")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("MinRotation", &Gconstraint_axislimit_t::GetMinRotation, &Gconstraint_axislimit_t::SetMinRotation)
        .addProperty("MaxRotation", &Gconstraint_axislimit_t::GetMaxRotation, &Gconstraint_axislimit_t::SetMaxRotation)
        .addProperty("MotorTargetAngSpeed", &Gconstraint_axislimit_t::GetMotorTargetAngSpeed, &Gconstraint_axislimit_t::SetMotorTargetAngSpeed)
        .addProperty("MotorMaxTorque", &Gconstraint_axislimit_t::GetMotorMaxTorque, &Gconstraint_axislimit_t::SetMotorMaxTorque)
        .addFunction("ToPtr", &Gconstraint_axislimit_t::ToPtr)
        .addFunction("IsValid", &Gconstraint_axislimit_t::IsValid)
        .endClass();
}
GFuseFunctionIndex_t::GFuseFunctionIndex_t(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GFuseFunctionIndex_t::GFuseFunctionIndex_t(void *ptr) {
    m_ptr = ptr;
}
uint16_t GFuseFunctionIndex_t::GetValue() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FuseFunctionIndex_t->Value(ptr=%p)", m_ptr));
    return GetSchemaValue<uint16_t>(m_ptr, "FuseFunctionIndex_t", "m_Value");
}
void GFuseFunctionIndex_t::SetValue(uint16_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FuseFunctionIndex_t->Value(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "FuseFunctionIndex_t", "m_Value", true, value);
}
void* GFuseFunctionIndex_t::GetPtr() {
    return m_ptr;
}
std::string GFuseFunctionIndex_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GFuseFunctionIndex_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassFuseFunctionIndex_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GFuseFunctionIndex_t>("FuseFunctionIndex_t")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Value", &GFuseFunctionIndex_t::GetValue, &GFuseFunctionIndex_t::SetValue)
        .addFunction("ToPtr", &GFuseFunctionIndex_t::ToPtr)
        .addFunction("IsValid", &GFuseFunctionIndex_t::IsValid)
        .endClass();
}
GCGeneralSpin::GCGeneralSpin(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCGeneralSpin::GCGeneralSpin(void *ptr) {
    m_ptr = ptr;
}
int32_t GCGeneralSpin::GetSpinRateDegrees() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CGeneralSpin->SpinRateDegrees(ptr=%p)", m_ptr));
    return GetSchemaValue<int32_t>(m_ptr, "CGeneralSpin", "m_nSpinRateDegrees");
}
void GCGeneralSpin::SetSpinRateDegrees(int32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CGeneralSpin->SpinRateDegrees(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CGeneralSpin", "m_nSpinRateDegrees", false, value);
}
int32_t GCGeneralSpin::GetSpinRateMinDegrees() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CGeneralSpin->SpinRateMinDegrees(ptr=%p)", m_ptr));
    return GetSchemaValue<int32_t>(m_ptr, "CGeneralSpin", "m_nSpinRateMinDegrees");
}
void GCGeneralSpin::SetSpinRateMinDegrees(int32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CGeneralSpin->SpinRateMinDegrees(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CGeneralSpin", "m_nSpinRateMinDegrees", false, value);
}
float GCGeneralSpin::GetSpinRateStopTime() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CGeneralSpin->SpinRateStopTime(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CGeneralSpin", "m_fSpinRateStopTime");
}
void GCGeneralSpin::SetSpinRateStopTime(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CGeneralSpin->SpinRateStopTime(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CGeneralSpin", "m_fSpinRateStopTime", false, value);
}
void* GCGeneralSpin::GetPtr() {
    return m_ptr;
}
std::string GCGeneralSpin::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCGeneralSpin::IsValid() {
    return (m_ptr != nullptr);
}
GCParticleFunctionOperator GCGeneralSpin::GetParent() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CGeneralSpin::GetParent(ptr=%p)", m_ptr));
    GCParticleFunctionOperator value(m_ptr);
    return value;
}
void GCGeneralSpin::SetParent(GCParticleFunctionOperator value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CGeneralSpin::SetParent(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCGeneralSpin(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCGeneralSpin>("CGeneralSpin")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("SpinRateDegrees", &GCGeneralSpin::GetSpinRateDegrees, &GCGeneralSpin::SetSpinRateDegrees)
        .addProperty("SpinRateMinDegrees", &GCGeneralSpin::GetSpinRateMinDegrees, &GCGeneralSpin::SetSpinRateMinDegrees)
        .addProperty("SpinRateStopTime", &GCGeneralSpin::GetSpinRateStopTime, &GCGeneralSpin::SetSpinRateStopTime)
        .addProperty("Parent", &GCGeneralSpin::GetParent, &GCGeneralSpin::SetParent)
        .addFunction("ToPtr", &GCGeneralSpin::ToPtr)
        .addFunction("IsValid", &GCGeneralSpin::IsValid)
        .endClass();
}
GCFeJiggleBone::GCFeJiggleBone(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCFeJiggleBone::GCFeJiggleBone(void *ptr) {
    m_ptr = ptr;
}
uint32_t GCFeJiggleBone::GetFlags() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CFeJiggleBone->Flags(ptr=%p)", m_ptr));
    return GetSchemaValue<uint32_t>(m_ptr, "CFeJiggleBone", "m_nFlags");
}
void GCFeJiggleBone::SetFlags(uint32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CFeJiggleBone->Flags(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CFeJiggleBone", "m_nFlags", false, value);
}
float GCFeJiggleBone::GetLength() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CFeJiggleBone->Length(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CFeJiggleBone", "m_flLength");
}
void GCFeJiggleBone::SetLength(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CFeJiggleBone->Length(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CFeJiggleBone", "m_flLength", false, value);
}
float GCFeJiggleBone::GetTipMass() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CFeJiggleBone->TipMass(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CFeJiggleBone", "m_flTipMass");
}
void GCFeJiggleBone::SetTipMass(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CFeJiggleBone->TipMass(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CFeJiggleBone", "m_flTipMass", false, value);
}
float GCFeJiggleBone::GetYawStiffness() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CFeJiggleBone->YawStiffness(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CFeJiggleBone", "m_flYawStiffness");
}
void GCFeJiggleBone::SetYawStiffness(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CFeJiggleBone->YawStiffness(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CFeJiggleBone", "m_flYawStiffness", false, value);
}
float GCFeJiggleBone::GetYawDamping() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CFeJiggleBone->YawDamping(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CFeJiggleBone", "m_flYawDamping");
}
void GCFeJiggleBone::SetYawDamping(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CFeJiggleBone->YawDamping(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CFeJiggleBone", "m_flYawDamping", false, value);
}
float GCFeJiggleBone::GetPitchStiffness() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CFeJiggleBone->PitchStiffness(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CFeJiggleBone", "m_flPitchStiffness");
}
void GCFeJiggleBone::SetPitchStiffness(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CFeJiggleBone->PitchStiffness(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CFeJiggleBone", "m_flPitchStiffness", false, value);
}
float GCFeJiggleBone::GetPitchDamping() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CFeJiggleBone->PitchDamping(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CFeJiggleBone", "m_flPitchDamping");
}
void GCFeJiggleBone::SetPitchDamping(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CFeJiggleBone->PitchDamping(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CFeJiggleBone", "m_flPitchDamping", false, value);
}
float GCFeJiggleBone::GetAlongStiffness() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CFeJiggleBone->AlongStiffness(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CFeJiggleBone", "m_flAlongStiffness");
}
void GCFeJiggleBone::SetAlongStiffness(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CFeJiggleBone->AlongStiffness(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CFeJiggleBone", "m_flAlongStiffness", false, value);
}
float GCFeJiggleBone::GetAlongDamping() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CFeJiggleBone->AlongDamping(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CFeJiggleBone", "m_flAlongDamping");
}
void GCFeJiggleBone::SetAlongDamping(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CFeJiggleBone->AlongDamping(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CFeJiggleBone", "m_flAlongDamping", false, value);
}
float GCFeJiggleBone::GetAngleLimit() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CFeJiggleBone->AngleLimit(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CFeJiggleBone", "m_flAngleLimit");
}
void GCFeJiggleBone::SetAngleLimit(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CFeJiggleBone->AngleLimit(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CFeJiggleBone", "m_flAngleLimit", false, value);
}
float GCFeJiggleBone::GetMinYaw() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CFeJiggleBone->MinYaw(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CFeJiggleBone", "m_flMinYaw");
}
void GCFeJiggleBone::SetMinYaw(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CFeJiggleBone->MinYaw(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CFeJiggleBone", "m_flMinYaw", false, value);
}
float GCFeJiggleBone::GetMaxYaw() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CFeJiggleBone->MaxYaw(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CFeJiggleBone", "m_flMaxYaw");
}
void GCFeJiggleBone::SetMaxYaw(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CFeJiggleBone->MaxYaw(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CFeJiggleBone", "m_flMaxYaw", false, value);
}
float GCFeJiggleBone::GetYawFriction() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CFeJiggleBone->YawFriction(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CFeJiggleBone", "m_flYawFriction");
}
void GCFeJiggleBone::SetYawFriction(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CFeJiggleBone->YawFriction(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CFeJiggleBone", "m_flYawFriction", false, value);
}
float GCFeJiggleBone::GetYawBounce() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CFeJiggleBone->YawBounce(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CFeJiggleBone", "m_flYawBounce");
}
void GCFeJiggleBone::SetYawBounce(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CFeJiggleBone->YawBounce(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CFeJiggleBone", "m_flYawBounce", false, value);
}
float GCFeJiggleBone::GetMinPitch() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CFeJiggleBone->MinPitch(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CFeJiggleBone", "m_flMinPitch");
}
void GCFeJiggleBone::SetMinPitch(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CFeJiggleBone->MinPitch(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CFeJiggleBone", "m_flMinPitch", false, value);
}
float GCFeJiggleBone::GetMaxPitch() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CFeJiggleBone->MaxPitch(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CFeJiggleBone", "m_flMaxPitch");
}
void GCFeJiggleBone::SetMaxPitch(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CFeJiggleBone->MaxPitch(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CFeJiggleBone", "m_flMaxPitch", false, value);
}
float GCFeJiggleBone::GetPitchFriction() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CFeJiggleBone->PitchFriction(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CFeJiggleBone", "m_flPitchFriction");
}
void GCFeJiggleBone::SetPitchFriction(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CFeJiggleBone->PitchFriction(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CFeJiggleBone", "m_flPitchFriction", false, value);
}
float GCFeJiggleBone::GetPitchBounce() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CFeJiggleBone->PitchBounce(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CFeJiggleBone", "m_flPitchBounce");
}
void GCFeJiggleBone::SetPitchBounce(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CFeJiggleBone->PitchBounce(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CFeJiggleBone", "m_flPitchBounce", false, value);
}
float GCFeJiggleBone::GetBaseMass() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CFeJiggleBone->BaseMass(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CFeJiggleBone", "m_flBaseMass");
}
void GCFeJiggleBone::SetBaseMass(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CFeJiggleBone->BaseMass(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CFeJiggleBone", "m_flBaseMass", false, value);
}
float GCFeJiggleBone::GetBaseStiffness() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CFeJiggleBone->BaseStiffness(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CFeJiggleBone", "m_flBaseStiffness");
}
void GCFeJiggleBone::SetBaseStiffness(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CFeJiggleBone->BaseStiffness(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CFeJiggleBone", "m_flBaseStiffness", false, value);
}
float GCFeJiggleBone::GetBaseDamping() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CFeJiggleBone->BaseDamping(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CFeJiggleBone", "m_flBaseDamping");
}
void GCFeJiggleBone::SetBaseDamping(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CFeJiggleBone->BaseDamping(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CFeJiggleBone", "m_flBaseDamping", false, value);
}
float GCFeJiggleBone::GetBaseMinLeft() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CFeJiggleBone->BaseMinLeft(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CFeJiggleBone", "m_flBaseMinLeft");
}
void GCFeJiggleBone::SetBaseMinLeft(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CFeJiggleBone->BaseMinLeft(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CFeJiggleBone", "m_flBaseMinLeft", false, value);
}
float GCFeJiggleBone::GetBaseMaxLeft() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CFeJiggleBone->BaseMaxLeft(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CFeJiggleBone", "m_flBaseMaxLeft");
}
void GCFeJiggleBone::SetBaseMaxLeft(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CFeJiggleBone->BaseMaxLeft(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CFeJiggleBone", "m_flBaseMaxLeft", false, value);
}
float GCFeJiggleBone::GetBaseLeftFriction() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CFeJiggleBone->BaseLeftFriction(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CFeJiggleBone", "m_flBaseLeftFriction");
}
void GCFeJiggleBone::SetBaseLeftFriction(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CFeJiggleBone->BaseLeftFriction(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CFeJiggleBone", "m_flBaseLeftFriction", false, value);
}
float GCFeJiggleBone::GetBaseMinUp() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CFeJiggleBone->BaseMinUp(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CFeJiggleBone", "m_flBaseMinUp");
}
void GCFeJiggleBone::SetBaseMinUp(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CFeJiggleBone->BaseMinUp(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CFeJiggleBone", "m_flBaseMinUp", false, value);
}
float GCFeJiggleBone::GetBaseMaxUp() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CFeJiggleBone->BaseMaxUp(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CFeJiggleBone", "m_flBaseMaxUp");
}
void GCFeJiggleBone::SetBaseMaxUp(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CFeJiggleBone->BaseMaxUp(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CFeJiggleBone", "m_flBaseMaxUp", false, value);
}
float GCFeJiggleBone::GetBaseUpFriction() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CFeJiggleBone->BaseUpFriction(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CFeJiggleBone", "m_flBaseUpFriction");
}
void GCFeJiggleBone::SetBaseUpFriction(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CFeJiggleBone->BaseUpFriction(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CFeJiggleBone", "m_flBaseUpFriction", false, value);
}
float GCFeJiggleBone::GetBaseMinForward() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CFeJiggleBone->BaseMinForward(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CFeJiggleBone", "m_flBaseMinForward");
}
void GCFeJiggleBone::SetBaseMinForward(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CFeJiggleBone->BaseMinForward(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CFeJiggleBone", "m_flBaseMinForward", false, value);
}
float GCFeJiggleBone::GetBaseMaxForward() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CFeJiggleBone->BaseMaxForward(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CFeJiggleBone", "m_flBaseMaxForward");
}
void GCFeJiggleBone::SetBaseMaxForward(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CFeJiggleBone->BaseMaxForward(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CFeJiggleBone", "m_flBaseMaxForward", false, value);
}
float GCFeJiggleBone::GetBaseForwardFriction() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CFeJiggleBone->BaseForwardFriction(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CFeJiggleBone", "m_flBaseForwardFriction");
}
void GCFeJiggleBone::SetBaseForwardFriction(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CFeJiggleBone->BaseForwardFriction(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CFeJiggleBone", "m_flBaseForwardFriction", false, value);
}
float GCFeJiggleBone::GetRadius0() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CFeJiggleBone->Radius0(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CFeJiggleBone", "m_flRadius0");
}
void GCFeJiggleBone::SetRadius0(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CFeJiggleBone->Radius0(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CFeJiggleBone", "m_flRadius0", false, value);
}
float GCFeJiggleBone::GetRadius1() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CFeJiggleBone->Radius1(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CFeJiggleBone", "m_flRadius1");
}
void GCFeJiggleBone::SetRadius1(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CFeJiggleBone->Radius1(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CFeJiggleBone", "m_flRadius1", false, value);
}
Vector GCFeJiggleBone::GetPoint0() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CFeJiggleBone->Point0(ptr=%p)", m_ptr));
    return GetSchemaValue<Vector>(m_ptr, "CFeJiggleBone", "m_vPoint0");
}
void GCFeJiggleBone::SetPoint0(Vector value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CFeJiggleBone->Point0(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CFeJiggleBone", "m_vPoint0", false, value);
}
Vector GCFeJiggleBone::GetPoint1() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CFeJiggleBone->Point1(ptr=%p)", m_ptr));
    return GetSchemaValue<Vector>(m_ptr, "CFeJiggleBone", "m_vPoint1");
}
void GCFeJiggleBone::SetPoint1(Vector value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CFeJiggleBone->Point1(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CFeJiggleBone", "m_vPoint1", false, value);
}
uint16_t GCFeJiggleBone::GetCollisionMask() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CFeJiggleBone->CollisionMask(ptr=%p)", m_ptr));
    return GetSchemaValue<uint16_t>(m_ptr, "CFeJiggleBone", "m_nCollisionMask");
}
void GCFeJiggleBone::SetCollisionMask(uint16_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CFeJiggleBone->CollisionMask(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CFeJiggleBone", "m_nCollisionMask", false, value);
}
void* GCFeJiggleBone::GetPtr() {
    return m_ptr;
}
std::string GCFeJiggleBone::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCFeJiggleBone::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCFeJiggleBone(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCFeJiggleBone>("CFeJiggleBone")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Flags", &GCFeJiggleBone::GetFlags, &GCFeJiggleBone::SetFlags)
        .addProperty("Length", &GCFeJiggleBone::GetLength, &GCFeJiggleBone::SetLength)
        .addProperty("TipMass", &GCFeJiggleBone::GetTipMass, &GCFeJiggleBone::SetTipMass)
        .addProperty("YawStiffness", &GCFeJiggleBone::GetYawStiffness, &GCFeJiggleBone::SetYawStiffness)
        .addProperty("YawDamping", &GCFeJiggleBone::GetYawDamping, &GCFeJiggleBone::SetYawDamping)
        .addProperty("PitchStiffness", &GCFeJiggleBone::GetPitchStiffness, &GCFeJiggleBone::SetPitchStiffness)
        .addProperty("PitchDamping", &GCFeJiggleBone::GetPitchDamping, &GCFeJiggleBone::SetPitchDamping)
        .addProperty("AlongStiffness", &GCFeJiggleBone::GetAlongStiffness, &GCFeJiggleBone::SetAlongStiffness)
        .addProperty("AlongDamping", &GCFeJiggleBone::GetAlongDamping, &GCFeJiggleBone::SetAlongDamping)
        .addProperty("AngleLimit", &GCFeJiggleBone::GetAngleLimit, &GCFeJiggleBone::SetAngleLimit)
        .addProperty("MinYaw", &GCFeJiggleBone::GetMinYaw, &GCFeJiggleBone::SetMinYaw)
        .addProperty("MaxYaw", &GCFeJiggleBone::GetMaxYaw, &GCFeJiggleBone::SetMaxYaw)
        .addProperty("YawFriction", &GCFeJiggleBone::GetYawFriction, &GCFeJiggleBone::SetYawFriction)
        .addProperty("YawBounce", &GCFeJiggleBone::GetYawBounce, &GCFeJiggleBone::SetYawBounce)
        .addProperty("MinPitch", &GCFeJiggleBone::GetMinPitch, &GCFeJiggleBone::SetMinPitch)
        .addProperty("MaxPitch", &GCFeJiggleBone::GetMaxPitch, &GCFeJiggleBone::SetMaxPitch)
        .addProperty("PitchFriction", &GCFeJiggleBone::GetPitchFriction, &GCFeJiggleBone::SetPitchFriction)
        .addProperty("PitchBounce", &GCFeJiggleBone::GetPitchBounce, &GCFeJiggleBone::SetPitchBounce)
        .addProperty("BaseMass", &GCFeJiggleBone::GetBaseMass, &GCFeJiggleBone::SetBaseMass)
        .addProperty("BaseStiffness", &GCFeJiggleBone::GetBaseStiffness, &GCFeJiggleBone::SetBaseStiffness)
        .addProperty("BaseDamping", &GCFeJiggleBone::GetBaseDamping, &GCFeJiggleBone::SetBaseDamping)
        .addProperty("BaseMinLeft", &GCFeJiggleBone::GetBaseMinLeft, &GCFeJiggleBone::SetBaseMinLeft)
        .addProperty("BaseMaxLeft", &GCFeJiggleBone::GetBaseMaxLeft, &GCFeJiggleBone::SetBaseMaxLeft)
        .addProperty("BaseLeftFriction", &GCFeJiggleBone::GetBaseLeftFriction, &GCFeJiggleBone::SetBaseLeftFriction)
        .addProperty("BaseMinUp", &GCFeJiggleBone::GetBaseMinUp, &GCFeJiggleBone::SetBaseMinUp)
        .addProperty("BaseMaxUp", &GCFeJiggleBone::GetBaseMaxUp, &GCFeJiggleBone::SetBaseMaxUp)
        .addProperty("BaseUpFriction", &GCFeJiggleBone::GetBaseUpFriction, &GCFeJiggleBone::SetBaseUpFriction)
        .addProperty("BaseMinForward", &GCFeJiggleBone::GetBaseMinForward, &GCFeJiggleBone::SetBaseMinForward)
        .addProperty("BaseMaxForward", &GCFeJiggleBone::GetBaseMaxForward, &GCFeJiggleBone::SetBaseMaxForward)
        .addProperty("BaseForwardFriction", &GCFeJiggleBone::GetBaseForwardFriction, &GCFeJiggleBone::SetBaseForwardFriction)
        .addProperty("Radius0", &GCFeJiggleBone::GetRadius0, &GCFeJiggleBone::SetRadius0)
        .addProperty("Radius1", &GCFeJiggleBone::GetRadius1, &GCFeJiggleBone::SetRadius1)
        .addProperty("Point0", &GCFeJiggleBone::GetPoint0, &GCFeJiggleBone::SetPoint0)
        .addProperty("Point1", &GCFeJiggleBone::GetPoint1, &GCFeJiggleBone::SetPoint1)
        .addProperty("CollisionMask", &GCFeJiggleBone::GetCollisionMask, &GCFeJiggleBone::SetCollisionMask)
        .addFunction("ToPtr", &GCFeJiggleBone::ToPtr)
        .addFunction("IsValid", &GCFeJiggleBone::IsValid)
        .endClass();
}
GCGlowOverlay::GCGlowOverlay(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCGlowOverlay::GCGlowOverlay(void *ptr) {
    m_ptr = ptr;
}
Vector GCGlowOverlay::GetPos() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CGlowOverlay->Pos(ptr=%p)", m_ptr));
    return GetSchemaValue<Vector>(m_ptr, "CGlowOverlay", "m_vPos");
}
void GCGlowOverlay::SetPos(Vector value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CGlowOverlay->Pos(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CGlowOverlay", "m_vPos", false, value);
}
bool GCGlowOverlay::GetDirectional() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CGlowOverlay->Directional(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "CGlowOverlay", "m_bDirectional");
}
void GCGlowOverlay::SetDirectional(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CGlowOverlay->Directional(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CGlowOverlay", "m_bDirectional", false, value);
}
Vector GCGlowOverlay::GetDirection() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CGlowOverlay->Direction(ptr=%p)", m_ptr));
    return GetSchemaValue<Vector>(m_ptr, "CGlowOverlay", "m_vDirection");
}
void GCGlowOverlay::SetDirection(Vector value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CGlowOverlay->Direction(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CGlowOverlay", "m_vDirection", false, value);
}
bool GCGlowOverlay::GetInSky() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CGlowOverlay->InSky(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "CGlowOverlay", "m_bInSky");
}
void GCGlowOverlay::SetInSky(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CGlowOverlay->InSky(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CGlowOverlay", "m_bInSky", false, value);
}
float GCGlowOverlay::GetSkyObstructionScale() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CGlowOverlay->SkyObstructionScale(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CGlowOverlay", "m_skyObstructionScale");
}
void GCGlowOverlay::SetSkyObstructionScale(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CGlowOverlay->SkyObstructionScale(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CGlowOverlay", "m_skyObstructionScale", false, value);
}
std::vector<GCGlowSprite> GCGlowOverlay::GetSprites() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CGlowOverlay->Sprites(ptr=%p,size=4)", m_ptr));
    GCGlowSprite* outValue = (GCGlowSprite*)GetSchemaPtr(m_ptr, "CGlowOverlay", "m_Sprites"); std::vector<GCGlowSprite> ret; for(int i = 0; i < 4; i++) { ret.push_back(outValue[i]); } return ret;
}
void GCGlowOverlay::SetSprites(std::vector<GCGlowSprite> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CGlowOverlay->Sprites(ptr=%p,size=4)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Sprites' is not possible.\n");
}
int32_t GCGlowOverlay::GetSprites1() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CGlowOverlay->Sprites1(ptr=%p)", m_ptr));
    return GetSchemaValue<int32_t>(m_ptr, "CGlowOverlay", "m_nSprites");
}
void GCGlowOverlay::SetSprites1(int32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CGlowOverlay->Sprites1(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CGlowOverlay", "m_nSprites", false, value);
}
float GCGlowOverlay::GetProxyRadius() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CGlowOverlay->ProxyRadius(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CGlowOverlay", "m_flProxyRadius");
}
void GCGlowOverlay::SetProxyRadius(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CGlowOverlay->ProxyRadius(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CGlowOverlay", "m_flProxyRadius", false, value);
}
float GCGlowOverlay::GetHDRColorScale() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CGlowOverlay->HDRColorScale(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CGlowOverlay", "m_flHDRColorScale");
}
void GCGlowOverlay::SetHDRColorScale(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CGlowOverlay->HDRColorScale(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CGlowOverlay", "m_flHDRColorScale", false, value);
}
float GCGlowOverlay::GetGlowObstructionScale() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CGlowOverlay->GlowObstructionScale(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CGlowOverlay", "m_flGlowObstructionScale");
}
void GCGlowOverlay::SetGlowObstructionScale(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CGlowOverlay->GlowObstructionScale(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CGlowOverlay", "m_flGlowObstructionScale", false, value);
}
bool GCGlowOverlay::GetCacheGlowObstruction() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CGlowOverlay->CacheGlowObstruction(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "CGlowOverlay", "m_bCacheGlowObstruction");
}
void GCGlowOverlay::SetCacheGlowObstruction(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CGlowOverlay->CacheGlowObstruction(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CGlowOverlay", "m_bCacheGlowObstruction", false, value);
}
bool GCGlowOverlay::GetCacheSkyObstruction() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CGlowOverlay->CacheSkyObstruction(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "CGlowOverlay", "m_bCacheSkyObstruction");
}
void GCGlowOverlay::SetCacheSkyObstruction(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CGlowOverlay->CacheSkyObstruction(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CGlowOverlay", "m_bCacheSkyObstruction", false, value);
}
int16_t GCGlowOverlay::GetActivated() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CGlowOverlay->Activated(ptr=%p)", m_ptr));
    return GetSchemaValue<int16_t>(m_ptr, "CGlowOverlay", "m_bActivated");
}
void GCGlowOverlay::SetActivated(int16_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CGlowOverlay->Activated(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CGlowOverlay", "m_bActivated", false, value);
}
uint16_t GCGlowOverlay::GetListIndex() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CGlowOverlay->ListIndex(ptr=%p)", m_ptr));
    return GetSchemaValue<uint16_t>(m_ptr, "CGlowOverlay", "m_ListIndex");
}
void GCGlowOverlay::SetListIndex(uint16_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CGlowOverlay->ListIndex(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CGlowOverlay", "m_ListIndex", false, value);
}
int32_t GCGlowOverlay::GetQueryHandle() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CGlowOverlay->QueryHandle(ptr=%p)", m_ptr));
    return GetSchemaValue<int32_t>(m_ptr, "CGlowOverlay", "m_queryHandle");
}
void GCGlowOverlay::SetQueryHandle(int32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CGlowOverlay->QueryHandle(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CGlowOverlay", "m_queryHandle", false, value);
}
void* GCGlowOverlay::GetPtr() {
    return m_ptr;
}
std::string GCGlowOverlay::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCGlowOverlay::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCGlowOverlay(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCGlowOverlay>("CGlowOverlay")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Pos", &GCGlowOverlay::GetPos, &GCGlowOverlay::SetPos)
        .addProperty("Directional", &GCGlowOverlay::GetDirectional, &GCGlowOverlay::SetDirectional)
        .addProperty("Direction", &GCGlowOverlay::GetDirection, &GCGlowOverlay::SetDirection)
        .addProperty("InSky", &GCGlowOverlay::GetInSky, &GCGlowOverlay::SetInSky)
        .addProperty("SkyObstructionScale", &GCGlowOverlay::GetSkyObstructionScale, &GCGlowOverlay::SetSkyObstructionScale)
        .addProperty("Sprites", &GCGlowOverlay::GetSprites, &GCGlowOverlay::SetSprites)
        .addProperty("Sprites1", &GCGlowOverlay::GetSprites1, &GCGlowOverlay::SetSprites1)
        .addProperty("ProxyRadius", &GCGlowOverlay::GetProxyRadius, &GCGlowOverlay::SetProxyRadius)
        .addProperty("HDRColorScale", &GCGlowOverlay::GetHDRColorScale, &GCGlowOverlay::SetHDRColorScale)
        .addProperty("GlowObstructionScale", &GCGlowOverlay::GetGlowObstructionScale, &GCGlowOverlay::SetGlowObstructionScale)
        .addProperty("CacheGlowObstruction", &GCGlowOverlay::GetCacheGlowObstruction, &GCGlowOverlay::SetCacheGlowObstruction)
        .addProperty("CacheSkyObstruction", &GCGlowOverlay::GetCacheSkyObstruction, &GCGlowOverlay::SetCacheSkyObstruction)
        .addProperty("Activated", &GCGlowOverlay::GetActivated, &GCGlowOverlay::SetActivated)
        .addProperty("ListIndex", &GCGlowOverlay::GetListIndex, &GCGlowOverlay::SetListIndex)
        .addProperty("QueryHandle", &GCGlowOverlay::GetQueryHandle, &GCGlowOverlay::SetQueryHandle)
        .addFunction("ToPtr", &GCGlowOverlay::ToPtr)
        .addFunction("IsValid", &GCGlowOverlay::IsValid)
        .endClass();
}
GTextureControls_t::GTextureControls_t(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GTextureControls_t::GTextureControls_t(void *ptr) {
    m_ptr = ptr;
}
GCParticleCollectionRendererFloatInput GTextureControls_t::GetFinalTextureScaleU() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: TextureControls_t->FinalTextureScaleU(ptr=%p)", m_ptr));
    GCParticleCollectionRendererFloatInput value(GetSchemaPtr(m_ptr, "TextureControls_t", "m_flFinalTextureScaleU"));
    return value;
}
void GTextureControls_t::SetFinalTextureScaleU(GCParticleCollectionRendererFloatInput value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: TextureControls_t->FinalTextureScaleU(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'FinalTextureScaleU' is not possible.\n");
}
GCParticleCollectionRendererFloatInput GTextureControls_t::GetFinalTextureScaleV() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: TextureControls_t->FinalTextureScaleV(ptr=%p)", m_ptr));
    GCParticleCollectionRendererFloatInput value(GetSchemaPtr(m_ptr, "TextureControls_t", "m_flFinalTextureScaleV"));
    return value;
}
void GTextureControls_t::SetFinalTextureScaleV(GCParticleCollectionRendererFloatInput value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: TextureControls_t->FinalTextureScaleV(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'FinalTextureScaleV' is not possible.\n");
}
GCParticleCollectionRendererFloatInput GTextureControls_t::GetFinalTextureOffsetU() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: TextureControls_t->FinalTextureOffsetU(ptr=%p)", m_ptr));
    GCParticleCollectionRendererFloatInput value(GetSchemaPtr(m_ptr, "TextureControls_t", "m_flFinalTextureOffsetU"));
    return value;
}
void GTextureControls_t::SetFinalTextureOffsetU(GCParticleCollectionRendererFloatInput value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: TextureControls_t->FinalTextureOffsetU(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'FinalTextureOffsetU' is not possible.\n");
}
GCParticleCollectionRendererFloatInput GTextureControls_t::GetFinalTextureOffsetV() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: TextureControls_t->FinalTextureOffsetV(ptr=%p)", m_ptr));
    GCParticleCollectionRendererFloatInput value(GetSchemaPtr(m_ptr, "TextureControls_t", "m_flFinalTextureOffsetV"));
    return value;
}
void GTextureControls_t::SetFinalTextureOffsetV(GCParticleCollectionRendererFloatInput value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: TextureControls_t->FinalTextureOffsetV(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'FinalTextureOffsetV' is not possible.\n");
}
GCParticleCollectionRendererFloatInput GTextureControls_t::GetFinalTextureUVRotation() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: TextureControls_t->FinalTextureUVRotation(ptr=%p)", m_ptr));
    GCParticleCollectionRendererFloatInput value(GetSchemaPtr(m_ptr, "TextureControls_t", "m_flFinalTextureUVRotation"));
    return value;
}
void GTextureControls_t::SetFinalTextureUVRotation(GCParticleCollectionRendererFloatInput value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: TextureControls_t->FinalTextureUVRotation(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'FinalTextureUVRotation' is not possible.\n");
}
GCParticleCollectionRendererFloatInput GTextureControls_t::GetZoomScale() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: TextureControls_t->ZoomScale(ptr=%p)", m_ptr));
    GCParticleCollectionRendererFloatInput value(GetSchemaPtr(m_ptr, "TextureControls_t", "m_flZoomScale"));
    return value;
}
void GTextureControls_t::SetZoomScale(GCParticleCollectionRendererFloatInput value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: TextureControls_t->ZoomScale(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'ZoomScale' is not possible.\n");
}
GCParticleCollectionRendererFloatInput GTextureControls_t::GetDistortion() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: TextureControls_t->Distortion(ptr=%p)", m_ptr));
    GCParticleCollectionRendererFloatInput value(GetSchemaPtr(m_ptr, "TextureControls_t", "m_flDistortion"));
    return value;
}
void GTextureControls_t::SetDistortion(GCParticleCollectionRendererFloatInput value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: TextureControls_t->Distortion(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Distortion' is not possible.\n");
}
bool GTextureControls_t::GetRandomizeOffsets() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: TextureControls_t->RandomizeOffsets(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "TextureControls_t", "m_bRandomizeOffsets");
}
void GTextureControls_t::SetRandomizeOffsets(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: TextureControls_t->RandomizeOffsets(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "TextureControls_t", "m_bRandomizeOffsets", true, value);
}
bool GTextureControls_t::GetClampUVs() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: TextureControls_t->ClampUVs(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "TextureControls_t", "m_bClampUVs");
}
void GTextureControls_t::SetClampUVs(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: TextureControls_t->ClampUVs(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "TextureControls_t", "m_bClampUVs", true, value);
}
uint64_t GTextureControls_t::GetPerParticleBlend() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: TextureControls_t->PerParticleBlend(ptr=%p)", m_ptr));
    return GetSchemaValue<uint64_t>(m_ptr, "TextureControls_t", "m_nPerParticleBlend");
}
void GTextureControls_t::SetPerParticleBlend(uint64_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: TextureControls_t->PerParticleBlend(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "TextureControls_t", "m_nPerParticleBlend", true, value);
}
uint64_t GTextureControls_t::GetPerParticleScale() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: TextureControls_t->PerParticleScale(ptr=%p)", m_ptr));
    return GetSchemaValue<uint64_t>(m_ptr, "TextureControls_t", "m_nPerParticleScale");
}
void GTextureControls_t::SetPerParticleScale(uint64_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: TextureControls_t->PerParticleScale(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "TextureControls_t", "m_nPerParticleScale", true, value);
}
uint64_t GTextureControls_t::GetPerParticleOffsetU() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: TextureControls_t->PerParticleOffsetU(ptr=%p)", m_ptr));
    return GetSchemaValue<uint64_t>(m_ptr, "TextureControls_t", "m_nPerParticleOffsetU");
}
void GTextureControls_t::SetPerParticleOffsetU(uint64_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: TextureControls_t->PerParticleOffsetU(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "TextureControls_t", "m_nPerParticleOffsetU", true, value);
}
uint64_t GTextureControls_t::GetPerParticleOffsetV() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: TextureControls_t->PerParticleOffsetV(ptr=%p)", m_ptr));
    return GetSchemaValue<uint64_t>(m_ptr, "TextureControls_t", "m_nPerParticleOffsetV");
}
void GTextureControls_t::SetPerParticleOffsetV(uint64_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: TextureControls_t->PerParticleOffsetV(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "TextureControls_t", "m_nPerParticleOffsetV", true, value);
}
uint64_t GTextureControls_t::GetPerParticleRotation() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: TextureControls_t->PerParticleRotation(ptr=%p)", m_ptr));
    return GetSchemaValue<uint64_t>(m_ptr, "TextureControls_t", "m_nPerParticleRotation");
}
void GTextureControls_t::SetPerParticleRotation(uint64_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: TextureControls_t->PerParticleRotation(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "TextureControls_t", "m_nPerParticleRotation", true, value);
}
uint64_t GTextureControls_t::GetPerParticleZoom() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: TextureControls_t->PerParticleZoom(ptr=%p)", m_ptr));
    return GetSchemaValue<uint64_t>(m_ptr, "TextureControls_t", "m_nPerParticleZoom");
}
void GTextureControls_t::SetPerParticleZoom(uint64_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: TextureControls_t->PerParticleZoom(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "TextureControls_t", "m_nPerParticleZoom", true, value);
}
uint64_t GTextureControls_t::GetPerParticleDistortion() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: TextureControls_t->PerParticleDistortion(ptr=%p)", m_ptr));
    return GetSchemaValue<uint64_t>(m_ptr, "TextureControls_t", "m_nPerParticleDistortion");
}
void GTextureControls_t::SetPerParticleDistortion(uint64_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: TextureControls_t->PerParticleDistortion(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "TextureControls_t", "m_nPerParticleDistortion", true, value);
}
void* GTextureControls_t::GetPtr() {
    return m_ptr;
}
std::string GTextureControls_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GTextureControls_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassTextureControls_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GTextureControls_t>("TextureControls_t")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("FinalTextureScaleU", &GTextureControls_t::GetFinalTextureScaleU, &GTextureControls_t::SetFinalTextureScaleU)
        .addProperty("FinalTextureScaleV", &GTextureControls_t::GetFinalTextureScaleV, &GTextureControls_t::SetFinalTextureScaleV)
        .addProperty("FinalTextureOffsetU", &GTextureControls_t::GetFinalTextureOffsetU, &GTextureControls_t::SetFinalTextureOffsetU)
        .addProperty("FinalTextureOffsetV", &GTextureControls_t::GetFinalTextureOffsetV, &GTextureControls_t::SetFinalTextureOffsetV)
        .addProperty("FinalTextureUVRotation", &GTextureControls_t::GetFinalTextureUVRotation, &GTextureControls_t::SetFinalTextureUVRotation)
        .addProperty("ZoomScale", &GTextureControls_t::GetZoomScale, &GTextureControls_t::SetZoomScale)
        .addProperty("Distortion", &GTextureControls_t::GetDistortion, &GTextureControls_t::SetDistortion)
        .addProperty("RandomizeOffsets", &GTextureControls_t::GetRandomizeOffsets, &GTextureControls_t::SetRandomizeOffsets)
        .addProperty("ClampUVs", &GTextureControls_t::GetClampUVs, &GTextureControls_t::SetClampUVs)
        .addProperty("PerParticleBlend", &GTextureControls_t::GetPerParticleBlend, &GTextureControls_t::SetPerParticleBlend)
        .addProperty("PerParticleScale", &GTextureControls_t::GetPerParticleScale, &GTextureControls_t::SetPerParticleScale)
        .addProperty("PerParticleOffsetU", &GTextureControls_t::GetPerParticleOffsetU, &GTextureControls_t::SetPerParticleOffsetU)
        .addProperty("PerParticleOffsetV", &GTextureControls_t::GetPerParticleOffsetV, &GTextureControls_t::SetPerParticleOffsetV)
        .addProperty("PerParticleRotation", &GTextureControls_t::GetPerParticleRotation, &GTextureControls_t::SetPerParticleRotation)
        .addProperty("PerParticleZoom", &GTextureControls_t::GetPerParticleZoom, &GTextureControls_t::SetPerParticleZoom)
        .addProperty("PerParticleDistortion", &GTextureControls_t::GetPerParticleDistortion, &GTextureControls_t::SetPerParticleDistortion)
        .addFunction("ToPtr", &GTextureControls_t::ToPtr)
        .addFunction("IsValid", &GTextureControls_t::IsValid)
        .endClass();
}
GCParticleModelInput::GCParticleModelInput(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCParticleModelInput::GCParticleModelInput(void *ptr) {
    m_ptr = ptr;
}
uint64_t GCParticleModelInput::GetType() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CParticleModelInput->Type(ptr=%p)", m_ptr));
    return GetSchemaValue<uint64_t>(m_ptr, "CParticleModelInput", "m_nType");
}
void GCParticleModelInput::SetType(uint64_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CParticleModelInput->Type(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CParticleModelInput", "m_nType", false, value);
}
int32_t GCParticleModelInput::GetControlPoint() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CParticleModelInput->ControlPoint(ptr=%p)", m_ptr));
    return GetSchemaValue<int32_t>(m_ptr, "CParticleModelInput", "m_nControlPoint");
}
void GCParticleModelInput::SetControlPoint(int32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CParticleModelInput->ControlPoint(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CParticleModelInput", "m_nControlPoint", false, value);
}
void* GCParticleModelInput::GetPtr() {
    return m_ptr;
}
std::string GCParticleModelInput::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCParticleModelInput::IsValid() {
    return (m_ptr != nullptr);
}
GCParticleInput GCParticleModelInput::GetParent() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CParticleModelInput::GetParent(ptr=%p)", m_ptr));
    GCParticleInput value(m_ptr);
    return value;
}
void GCParticleModelInput::SetParent(GCParticleInput value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CParticleModelInput::SetParent(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCParticleModelInput(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCParticleModelInput>("CParticleModelInput")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Type", &GCParticleModelInput::GetType, &GCParticleModelInput::SetType)
        .addProperty("ControlPoint", &GCParticleModelInput::GetControlPoint, &GCParticleModelInput::SetControlPoint)
        .addProperty("Parent", &GCParticleModelInput::GetParent, &GCParticleModelInput::SetParent)
        .addFunction("ToPtr", &GCParticleModelInput::ToPtr)
        .addFunction("IsValid", &GCParticleModelInput::IsValid)
        .endClass();
}
GCNmPassthroughNode::GCNmPassthroughNode(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCNmPassthroughNode::GCNmPassthroughNode(void *ptr) {
    m_ptr = ptr;
}
int16_t GCNmPassthroughNode::GetChildNodeIdx() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CNmPassthroughNode->ChildNodeIdx(ptr=%p)", m_ptr));
    return GetSchemaValue<int16_t>(m_ptr, "CNmPassthroughNode", "m_nChildNodeIdx");
}
void GCNmPassthroughNode::SetChildNodeIdx(int16_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CNmPassthroughNode->ChildNodeIdx(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CNmPassthroughNode", "m_nChildNodeIdx", false, value);
}
void* GCNmPassthroughNode::GetPtr() {
    return m_ptr;
}
std::string GCNmPassthroughNode::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCNmPassthroughNode::IsValid() {
    return (m_ptr != nullptr);
}
GCNmPoseNode GCNmPassthroughNode::GetParent() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CNmPassthroughNode::GetParent(ptr=%p)", m_ptr));
    GCNmPoseNode value(m_ptr);
    return value;
}
void GCNmPassthroughNode::SetParent(GCNmPoseNode value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CNmPassthroughNode::SetParent(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCNmPassthroughNode(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCNmPassthroughNode>("CNmPassthroughNode")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("ChildNodeIdx", &GCNmPassthroughNode::GetChildNodeIdx, &GCNmPassthroughNode::SetChildNodeIdx)
        .addProperty("Parent", &GCNmPassthroughNode::GetParent, &GCNmPassthroughNode::SetParent)
        .addFunction("ToPtr", &GCNmPassthroughNode::ToPtr)
        .addFunction("IsValid", &GCNmPassthroughNode::IsValid)
        .endClass();
}
GCAnimDecoder::GCAnimDecoder(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCAnimDecoder::GCAnimDecoder(void *ptr) {
    m_ptr = ptr;
}
int32_t GCAnimDecoder::GetVersion() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CAnimDecoder->Version(ptr=%p)", m_ptr));
    return GetSchemaValue<int32_t>(m_ptr, "CAnimDecoder", "m_nVersion");
}
void GCAnimDecoder::SetVersion(int32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CAnimDecoder->Version(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CAnimDecoder", "m_nVersion", false, value);
}
int32_t GCAnimDecoder::GetType() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CAnimDecoder->Type(ptr=%p)", m_ptr));
    return GetSchemaValue<int32_t>(m_ptr, "CAnimDecoder", "m_nType");
}
void GCAnimDecoder::SetType(int32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CAnimDecoder->Type(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CAnimDecoder", "m_nType", false, value);
}
void* GCAnimDecoder::GetPtr() {
    return m_ptr;
}
std::string GCAnimDecoder::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCAnimDecoder::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCAnimDecoder(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCAnimDecoder>("CAnimDecoder")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Version", &GCAnimDecoder::GetVersion, &GCAnimDecoder::SetVersion)
        .addProperty("Type", &GCAnimDecoder::GetType, &GCAnimDecoder::SetType)
        .addFunction("ToPtr", &GCAnimDecoder::ToPtr)
        .addFunction("IsValid", &GCAnimDecoder::IsValid)
        .endClass();
}
GNmPercent_t::GNmPercent_t(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GNmPercent_t::GNmPercent_t(void *ptr) {
    m_ptr = ptr;
}
float GNmPercent_t::GetValue() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: NmPercent_t->Value(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "NmPercent_t", "m_flValue");
}
void GNmPercent_t::SetValue(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: NmPercent_t->Value(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "NmPercent_t", "m_flValue", true, value);
}
void* GNmPercent_t::GetPtr() {
    return m_ptr;
}
std::string GNmPercent_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GNmPercent_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassNmPercent_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GNmPercent_t>("NmPercent_t")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Value", &GNmPercent_t::GetValue, &GNmPercent_t::SetValue)
        .addFunction("ToPtr", &GNmPercent_t::ToPtr)
        .addFunction("IsValid", &GNmPercent_t::IsValid)
        .endClass();
}
GEventProfileStorageAvailable_t::GEventProfileStorageAvailable_t(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GEventProfileStorageAvailable_t::GEventProfileStorageAvailable_t(void *ptr) {
    m_ptr = ptr;
}
int32_t GEventProfileStorageAvailable_t::GetSplitScreenSlot() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: EventProfileStorageAvailable_t->SplitScreenSlot(ptr=%p)", m_ptr));
    return GetSchemaValue<int32_t>(m_ptr, "EventProfileStorageAvailable_t", "m_nSplitScreenSlot");
}
void GEventProfileStorageAvailable_t::SetSplitScreenSlot(int32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: EventProfileStorageAvailable_t->SplitScreenSlot(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "EventProfileStorageAvailable_t", "m_nSplitScreenSlot", true, value);
}
void* GEventProfileStorageAvailable_t::GetPtr() {
    return m_ptr;
}
std::string GEventProfileStorageAvailable_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GEventProfileStorageAvailable_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassEventProfileStorageAvailable_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GEventProfileStorageAvailable_t>("EventProfileStorageAvailable_t")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("SplitScreenSlot", &GEventProfileStorageAvailable_t::GetSplitScreenSlot, &GEventProfileStorageAvailable_t::SetSplitScreenSlot)
        .addFunction("ToPtr", &GEventProfileStorageAvailable_t::ToPtr)
        .addFunction("IsValid", &GEventProfileStorageAvailable_t::IsValid)
        .endClass();
}
GCVoiceContainerBase::GCVoiceContainerBase(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCVoiceContainerBase::GCVoiceContainerBase(void *ptr) {
    m_ptr = ptr;
}
bool GCVoiceContainerBase::GetHideAnalyzers() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CVoiceContainerBase->HideAnalyzers(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "CVoiceContainerBase", "m_bHideAnalyzers");
}
void GCVoiceContainerBase::SetHideAnalyzers(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CVoiceContainerBase->HideAnalyzers(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CVoiceContainerBase", "m_bHideAnalyzers", false, value);
}
std::vector<GCVoiceContainerAnalysisBase*> GCVoiceContainerBase::GetAnalysisContainers() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CVoiceContainerBase->AnalysisContainers(ptr=%p)", m_ptr));
    CUtlVector<GCVoiceContainerAnalysisBase*>* vec = GetSchemaValue<CUtlVector<GCVoiceContainerAnalysisBase*>*>(m_ptr, "CVoiceContainerBase", "m_analysisContainers"); std::vector<GCVoiceContainerAnalysisBase*> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCVoiceContainerBase::SetAnalysisContainers(std::vector<GCVoiceContainerAnalysisBase*> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CVoiceContainerBase->AnalysisContainers(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<GCVoiceContainerAnalysisBase*>(m_ptr, "CVoiceContainerBase", "m_analysisContainers", false, value);
}
void* GCVoiceContainerBase::GetPtr() {
    return m_ptr;
}
std::string GCVoiceContainerBase::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCVoiceContainerBase::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCVoiceContainerBase(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCVoiceContainerBase>("CVoiceContainerBase")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("HideAnalyzers", &GCVoiceContainerBase::GetHideAnalyzers, &GCVoiceContainerBase::SetHideAnalyzers)
        .addProperty("AnalysisContainers", &GCVoiceContainerBase::GetAnalysisContainers, &GCVoiceContainerBase::SetAnalysisContainers)
        .addFunction("ToPtr", &GCVoiceContainerBase::ToPtr)
        .addFunction("IsValid", &GCVoiceContainerBase::IsValid)
        .endClass();
}
GCPerParticleVecInput::GCPerParticleVecInput(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCPerParticleVecInput::GCPerParticleVecInput(void *ptr) {
    m_ptr = ptr;
}
void* GCPerParticleVecInput::GetPtr() {
    return m_ptr;
}
std::string GCPerParticleVecInput::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCPerParticleVecInput::IsValid() {
    return (m_ptr != nullptr);
}
GCParticleVecInput GCPerParticleVecInput::GetParent() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CPerParticleVecInput::GetParent(ptr=%p)", m_ptr));
    GCParticleVecInput value(m_ptr);
    return value;
}
void GCPerParticleVecInput::SetParent(GCParticleVecInput value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CPerParticleVecInput::SetParent(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCPerParticleVecInput(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCPerParticleVecInput>("CPerParticleVecInput")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Parent", &GCPerParticleVecInput::GetParent, &GCPerParticleVecInput::SetParent)
        .addFunction("ToPtr", &GCPerParticleVecInput::ToPtr)
        .addFunction("IsValid", &GCPerParticleVecInput::IsValid)
        .endClass();
}
GCBoneMaskUpdateNode::GCBoneMaskUpdateNode(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCBoneMaskUpdateNode::GCBoneMaskUpdateNode(void *ptr) {
    m_ptr = ptr;
}
int32_t GCBoneMaskUpdateNode::GetWeightListIndex() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CBoneMaskUpdateNode->WeightListIndex(ptr=%p)", m_ptr));
    return GetSchemaValue<int32_t>(m_ptr, "CBoneMaskUpdateNode", "m_nWeightListIndex");
}
void GCBoneMaskUpdateNode::SetWeightListIndex(int32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CBoneMaskUpdateNode->WeightListIndex(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CBoneMaskUpdateNode", "m_nWeightListIndex", false, value);
}
float GCBoneMaskUpdateNode::GetRootMotionBlend() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CBoneMaskUpdateNode->RootMotionBlend(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CBoneMaskUpdateNode", "m_flRootMotionBlend");
}
void GCBoneMaskUpdateNode::SetRootMotionBlend(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CBoneMaskUpdateNode->RootMotionBlend(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CBoneMaskUpdateNode", "m_flRootMotionBlend", false, value);
}
uint64_t GCBoneMaskUpdateNode::GetBlendSpace() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CBoneMaskUpdateNode->BlendSpace(ptr=%p)", m_ptr));
    return GetSchemaValue<uint64_t>(m_ptr, "CBoneMaskUpdateNode", "m_blendSpace");
}
void GCBoneMaskUpdateNode::SetBlendSpace(uint64_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CBoneMaskUpdateNode->BlendSpace(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CBoneMaskUpdateNode", "m_blendSpace", false, value);
}
uint64_t GCBoneMaskUpdateNode::GetFootMotionTiming() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CBoneMaskUpdateNode->FootMotionTiming(ptr=%p)", m_ptr));
    return GetSchemaValue<uint64_t>(m_ptr, "CBoneMaskUpdateNode", "m_footMotionTiming");
}
void GCBoneMaskUpdateNode::SetFootMotionTiming(uint64_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CBoneMaskUpdateNode->FootMotionTiming(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CBoneMaskUpdateNode", "m_footMotionTiming", false, value);
}
bool GCBoneMaskUpdateNode::GetUseBlendScale() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CBoneMaskUpdateNode->UseBlendScale(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "CBoneMaskUpdateNode", "m_bUseBlendScale");
}
void GCBoneMaskUpdateNode::SetUseBlendScale(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CBoneMaskUpdateNode->UseBlendScale(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CBoneMaskUpdateNode", "m_bUseBlendScale", false, value);
}
uint64_t GCBoneMaskUpdateNode::GetBlendValueSource() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CBoneMaskUpdateNode->BlendValueSource(ptr=%p)", m_ptr));
    return GetSchemaValue<uint64_t>(m_ptr, "CBoneMaskUpdateNode", "m_blendValueSource");
}
void GCBoneMaskUpdateNode::SetBlendValueSource(uint64_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CBoneMaskUpdateNode->BlendValueSource(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CBoneMaskUpdateNode", "m_blendValueSource", false, value);
}
GCAnimParamHandle GCBoneMaskUpdateNode::GetBlendParameter() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CBoneMaskUpdateNode->BlendParameter(ptr=%p)", m_ptr));
    GCAnimParamHandle value(GetSchemaPtr(m_ptr, "CBoneMaskUpdateNode", "m_hBlendParameter"));
    return value;
}
void GCBoneMaskUpdateNode::SetBlendParameter(GCAnimParamHandle value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CBoneMaskUpdateNode->BlendParameter(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'BlendParameter' is not possible.\n");
}
void* GCBoneMaskUpdateNode::GetPtr() {
    return m_ptr;
}
std::string GCBoneMaskUpdateNode::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCBoneMaskUpdateNode::IsValid() {
    return (m_ptr != nullptr);
}
GCBinaryUpdateNode GCBoneMaskUpdateNode::GetParent() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CBoneMaskUpdateNode::GetParent(ptr=%p)", m_ptr));
    GCBinaryUpdateNode value(m_ptr);
    return value;
}
void GCBoneMaskUpdateNode::SetParent(GCBinaryUpdateNode value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CBoneMaskUpdateNode::SetParent(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCBoneMaskUpdateNode(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCBoneMaskUpdateNode>("CBoneMaskUpdateNode")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("WeightListIndex", &GCBoneMaskUpdateNode::GetWeightListIndex, &GCBoneMaskUpdateNode::SetWeightListIndex)
        .addProperty("RootMotionBlend", &GCBoneMaskUpdateNode::GetRootMotionBlend, &GCBoneMaskUpdateNode::SetRootMotionBlend)
        .addProperty("BlendSpace", &GCBoneMaskUpdateNode::GetBlendSpace, &GCBoneMaskUpdateNode::SetBlendSpace)
        .addProperty("FootMotionTiming", &GCBoneMaskUpdateNode::GetFootMotionTiming, &GCBoneMaskUpdateNode::SetFootMotionTiming)
        .addProperty("UseBlendScale", &GCBoneMaskUpdateNode::GetUseBlendScale, &GCBoneMaskUpdateNode::SetUseBlendScale)
        .addProperty("BlendValueSource", &GCBoneMaskUpdateNode::GetBlendValueSource, &GCBoneMaskUpdateNode::SetBlendValueSource)
        .addProperty("BlendParameter", &GCBoneMaskUpdateNode::GetBlendParameter, &GCBoneMaskUpdateNode::SetBlendParameter)
        .addProperty("Parent", &GCBoneMaskUpdateNode::GetParent, &GCBoneMaskUpdateNode::SetParent)
        .addFunction("ToPtr", &GCBoneMaskUpdateNode::ToPtr)
        .addFunction("IsValid", &GCBoneMaskUpdateNode::IsValid)
        .endClass();
}
GConfigIndex::GConfigIndex(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GConfigIndex::GConfigIndex(void *ptr) {
    m_ptr = ptr;
}
uint16_t GConfigIndex::GetGroup() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: ConfigIndex->Group(ptr=%p)", m_ptr));
    return GetSchemaValue<uint16_t>(m_ptr, "ConfigIndex", "m_nGroup");
}
void GConfigIndex::SetGroup(uint16_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: ConfigIndex->Group(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "ConfigIndex", "m_nGroup", false, value);
}
uint16_t GConfigIndex::GetConfig() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: ConfigIndex->Config(ptr=%p)", m_ptr));
    return GetSchemaValue<uint16_t>(m_ptr, "ConfigIndex", "m_nConfig");
}
void GConfigIndex::SetConfig(uint16_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: ConfigIndex->Config(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "ConfigIndex", "m_nConfig", false, value);
}
void* GConfigIndex::GetPtr() {
    return m_ptr;
}
std::string GConfigIndex::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GConfigIndex::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassConfigIndex(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GConfigIndex>("ConfigIndex")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Group", &GConfigIndex::GetGroup, &GConfigIndex::SetGroup)
        .addProperty("Config", &GConfigIndex::GetConfig, &GConfigIndex::SetConfig)
        .addFunction("ToPtr", &GConfigIndex::ToPtr)
        .addFunction("IsValid", &GConfigIndex::IsValid)
        .endClass();
}
GFeSimdRodConstraint_t::GFeSimdRodConstraint_t(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GFeSimdRodConstraint_t::GFeSimdRodConstraint_t(void *ptr) {
    m_ptr = ptr;
}
float GFeSimdRodConstraint_t::Get4MaxDist() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FeSimdRodConstraint_t->4MaxDist(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "FeSimdRodConstraint_t", "f4MaxDist");
}
void GFeSimdRodConstraint_t::Set4MaxDist(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FeSimdRodConstraint_t->4MaxDist(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "FeSimdRodConstraint_t", "f4MaxDist", true, value);
}
float GFeSimdRodConstraint_t::Get4MinDist() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FeSimdRodConstraint_t->4MinDist(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "FeSimdRodConstraint_t", "f4MinDist");
}
void GFeSimdRodConstraint_t::Set4MinDist(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FeSimdRodConstraint_t->4MinDist(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "FeSimdRodConstraint_t", "f4MinDist", true, value);
}
float GFeSimdRodConstraint_t::Get4Weight0() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FeSimdRodConstraint_t->4Weight0(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "FeSimdRodConstraint_t", "f4Weight0");
}
void GFeSimdRodConstraint_t::Set4Weight0(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FeSimdRodConstraint_t->4Weight0(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "FeSimdRodConstraint_t", "f4Weight0", true, value);
}
float GFeSimdRodConstraint_t::Get4RelaxationFactor() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FeSimdRodConstraint_t->4RelaxationFactor(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "FeSimdRodConstraint_t", "f4RelaxationFactor");
}
void GFeSimdRodConstraint_t::Set4RelaxationFactor(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FeSimdRodConstraint_t->4RelaxationFactor(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "FeSimdRodConstraint_t", "f4RelaxationFactor", true, value);
}
void* GFeSimdRodConstraint_t::GetPtr() {
    return m_ptr;
}
std::string GFeSimdRodConstraint_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GFeSimdRodConstraint_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassFeSimdRodConstraint_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GFeSimdRodConstraint_t>("FeSimdRodConstraint_t")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("4MaxDist", &GFeSimdRodConstraint_t::Get4MaxDist, &GFeSimdRodConstraint_t::Set4MaxDist)
        .addProperty("4MinDist", &GFeSimdRodConstraint_t::Get4MinDist, &GFeSimdRodConstraint_t::Set4MinDist)
        .addProperty("4Weight0", &GFeSimdRodConstraint_t::Get4Weight0, &GFeSimdRodConstraint_t::Set4Weight0)
        .addProperty("4RelaxationFactor", &GFeSimdRodConstraint_t::Get4RelaxationFactor, &GFeSimdRodConstraint_t::Set4RelaxationFactor)
        .addFunction("ToPtr", &GFeSimdRodConstraint_t::ToPtr)
        .addFunction("IsValid", &GFeSimdRodConstraint_t::IsValid)
        .endClass();
}
GCSSDSMsg_EndFrame::GCSSDSMsg_EndFrame(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCSSDSMsg_EndFrame::GCSSDSMsg_EndFrame(void *ptr) {
    m_ptr = ptr;
}
std::vector<GCSSDSEndFrameViewInfo> GCSSDSMsg_EndFrame::GetViews() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CSSDSMsg_EndFrame->Views(ptr=%p)", m_ptr));
    CUtlVector<GCSSDSEndFrameViewInfo>* vec = GetSchemaValue<CUtlVector<GCSSDSEndFrameViewInfo>*>(m_ptr, "CSSDSMsg_EndFrame", "m_Views"); std::vector<GCSSDSEndFrameViewInfo> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCSSDSMsg_EndFrame::SetViews(std::vector<GCSSDSEndFrameViewInfo> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CSSDSMsg_EndFrame->Views(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<GCSSDSEndFrameViewInfo>(m_ptr, "CSSDSMsg_EndFrame", "m_Views", false, value);
}
void* GCSSDSMsg_EndFrame::GetPtr() {
    return m_ptr;
}
std::string GCSSDSMsg_EndFrame::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCSSDSMsg_EndFrame::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCSSDSMsg_EndFrame(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCSSDSMsg_EndFrame>("CSSDSMsg_EndFrame")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Views", &GCSSDSMsg_EndFrame::GetViews, &GCSSDSMsg_EndFrame::SetViews)
        .addFunction("ToPtr", &GCSSDSMsg_EndFrame::ToPtr)
        .addFunction("IsValid", &GCSSDSMsg_EndFrame::IsValid)
        .endClass();
}
GSkeletonBoneBounds_t::GSkeletonBoneBounds_t(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GSkeletonBoneBounds_t::GSkeletonBoneBounds_t(void *ptr) {
    m_ptr = ptr;
}
Vector GSkeletonBoneBounds_t::GetCenter() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: SkeletonBoneBounds_t->Center(ptr=%p)", m_ptr));
    return GetSchemaValue<Vector>(m_ptr, "SkeletonBoneBounds_t", "m_vecCenter");
}
void GSkeletonBoneBounds_t::SetCenter(Vector value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: SkeletonBoneBounds_t->Center(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "SkeletonBoneBounds_t", "m_vecCenter", true, value);
}
Vector GSkeletonBoneBounds_t::GetSize() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: SkeletonBoneBounds_t->Size(ptr=%p)", m_ptr));
    return GetSchemaValue<Vector>(m_ptr, "SkeletonBoneBounds_t", "m_vecSize");
}
void GSkeletonBoneBounds_t::SetSize(Vector value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: SkeletonBoneBounds_t->Size(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "SkeletonBoneBounds_t", "m_vecSize", true, value);
}
void* GSkeletonBoneBounds_t::GetPtr() {
    return m_ptr;
}
std::string GSkeletonBoneBounds_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GSkeletonBoneBounds_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassSkeletonBoneBounds_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GSkeletonBoneBounds_t>("SkeletonBoneBounds_t")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Center", &GSkeletonBoneBounds_t::GetCenter, &GSkeletonBoneBounds_t::SetCenter)
        .addProperty("Size", &GSkeletonBoneBounds_t::GetSize, &GSkeletonBoneBounds_t::SetSize)
        .addFunction("ToPtr", &GSkeletonBoneBounds_t::ToPtr)
        .addFunction("IsValid", &GSkeletonBoneBounds_t::IsValid)
        .endClass();
}
GCDSPMixgroupModifier::GCDSPMixgroupModifier(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCDSPMixgroupModifier::GCDSPMixgroupModifier(void *ptr) {
    m_ptr = ptr;
}
std::string GCDSPMixgroupModifier::GetMixgroup() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CDSPMixgroupModifier->Mixgroup(ptr=%p)", m_ptr));
    return GetSchemaValue<CUtlString>(m_ptr, "CDSPMixgroupModifier", "m_mixgroup").Get();
}
void GCDSPMixgroupModifier::SetMixgroup(std::string value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CDSPMixgroupModifier->Mixgroup(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CDSPMixgroupModifier", "m_mixgroup", false, CUtlString(value.c_str()));
}
float GCDSPMixgroupModifier::GetModifier() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CDSPMixgroupModifier->Modifier(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CDSPMixgroupModifier", "m_flModifier");
}
void GCDSPMixgroupModifier::SetModifier(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CDSPMixgroupModifier->Modifier(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CDSPMixgroupModifier", "m_flModifier", false, value);
}
float GCDSPMixgroupModifier::GetModifierMin() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CDSPMixgroupModifier->ModifierMin(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CDSPMixgroupModifier", "m_flModifierMin");
}
void GCDSPMixgroupModifier::SetModifierMin(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CDSPMixgroupModifier->ModifierMin(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CDSPMixgroupModifier", "m_flModifierMin", false, value);
}
float GCDSPMixgroupModifier::GetSourceModifier() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CDSPMixgroupModifier->SourceModifier(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CDSPMixgroupModifier", "m_flSourceModifier");
}
void GCDSPMixgroupModifier::SetSourceModifier(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CDSPMixgroupModifier->SourceModifier(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CDSPMixgroupModifier", "m_flSourceModifier", false, value);
}
float GCDSPMixgroupModifier::GetSourceModifierMin() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CDSPMixgroupModifier->SourceModifierMin(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CDSPMixgroupModifier", "m_flSourceModifierMin");
}
void GCDSPMixgroupModifier::SetSourceModifierMin(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CDSPMixgroupModifier->SourceModifierMin(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CDSPMixgroupModifier", "m_flSourceModifierMin", false, value);
}
float GCDSPMixgroupModifier::GetListenerReverbModifierWhenSourceReverbIsActive() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CDSPMixgroupModifier->ListenerReverbModifierWhenSourceReverbIsActive(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CDSPMixgroupModifier", "m_flListenerReverbModifierWhenSourceReverbIsActive");
}
void GCDSPMixgroupModifier::SetListenerReverbModifierWhenSourceReverbIsActive(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CDSPMixgroupModifier->ListenerReverbModifierWhenSourceReverbIsActive(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CDSPMixgroupModifier", "m_flListenerReverbModifierWhenSourceReverbIsActive", false, value);
}
void* GCDSPMixgroupModifier::GetPtr() {
    return m_ptr;
}
std::string GCDSPMixgroupModifier::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCDSPMixgroupModifier::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCDSPMixgroupModifier(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCDSPMixgroupModifier>("CDSPMixgroupModifier")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Mixgroup", &GCDSPMixgroupModifier::GetMixgroup, &GCDSPMixgroupModifier::SetMixgroup)
        .addProperty("Modifier", &GCDSPMixgroupModifier::GetModifier, &GCDSPMixgroupModifier::SetModifier)
        .addProperty("ModifierMin", &GCDSPMixgroupModifier::GetModifierMin, &GCDSPMixgroupModifier::SetModifierMin)
        .addProperty("SourceModifier", &GCDSPMixgroupModifier::GetSourceModifier, &GCDSPMixgroupModifier::SetSourceModifier)
        .addProperty("SourceModifierMin", &GCDSPMixgroupModifier::GetSourceModifierMin, &GCDSPMixgroupModifier::SetSourceModifierMin)
        .addProperty("ListenerReverbModifierWhenSourceReverbIsActive", &GCDSPMixgroupModifier::GetListenerReverbModifierWhenSourceReverbIsActive, &GCDSPMixgroupModifier::SetListenerReverbModifierWhenSourceReverbIsActive)
        .addFunction("ToPtr", &GCDSPMixgroupModifier::ToPtr)
        .addFunction("IsValid", &GCDSPMixgroupModifier::IsValid)
        .endClass();
}
GCBoneConstraintBase::GCBoneConstraintBase(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCBoneConstraintBase::GCBoneConstraintBase(void *ptr) {
    m_ptr = ptr;
}
void* GCBoneConstraintBase::GetPtr() {
    return m_ptr;
}
std::string GCBoneConstraintBase::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCBoneConstraintBase::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCBoneConstraintBase(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCBoneConstraintBase>("CBoneConstraintBase")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addFunction("ToPtr", &GCBoneConstraintBase::ToPtr)
        .addFunction("IsValid", &GCBoneConstraintBase::IsValid)
        .endClass();
}
GEventAdvanceTick_t::GEventAdvanceTick_t(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GEventAdvanceTick_t::GEventAdvanceTick_t(void *ptr) {
    m_ptr = ptr;
}
int32_t GEventAdvanceTick_t::GetCurrentTick() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: EventAdvanceTick_t->CurrentTick(ptr=%p)", m_ptr));
    return GetSchemaValue<int32_t>(m_ptr, "EventAdvanceTick_t", "m_nCurrentTick");
}
void GEventAdvanceTick_t::SetCurrentTick(int32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: EventAdvanceTick_t->CurrentTick(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "EventAdvanceTick_t", "m_nCurrentTick", true, value);
}
int32_t GEventAdvanceTick_t::GetCurrentTickThisFrame() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: EventAdvanceTick_t->CurrentTickThisFrame(ptr=%p)", m_ptr));
    return GetSchemaValue<int32_t>(m_ptr, "EventAdvanceTick_t", "m_nCurrentTickThisFrame");
}
void GEventAdvanceTick_t::SetCurrentTickThisFrame(int32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: EventAdvanceTick_t->CurrentTickThisFrame(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "EventAdvanceTick_t", "m_nCurrentTickThisFrame", true, value);
}
int32_t GEventAdvanceTick_t::GetTotalTicksThisFrame() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: EventAdvanceTick_t->TotalTicksThisFrame(ptr=%p)", m_ptr));
    return GetSchemaValue<int32_t>(m_ptr, "EventAdvanceTick_t", "m_nTotalTicksThisFrame");
}
void GEventAdvanceTick_t::SetTotalTicksThisFrame(int32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: EventAdvanceTick_t->TotalTicksThisFrame(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "EventAdvanceTick_t", "m_nTotalTicksThisFrame", true, value);
}
int32_t GEventAdvanceTick_t::GetTotalTicks() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: EventAdvanceTick_t->TotalTicks(ptr=%p)", m_ptr));
    return GetSchemaValue<int32_t>(m_ptr, "EventAdvanceTick_t", "m_nTotalTicks");
}
void GEventAdvanceTick_t::SetTotalTicks(int32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: EventAdvanceTick_t->TotalTicks(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "EventAdvanceTick_t", "m_nTotalTicks", true, value);
}
void* GEventAdvanceTick_t::GetPtr() {
    return m_ptr;
}
std::string GEventAdvanceTick_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GEventAdvanceTick_t::IsValid() {
    return (m_ptr != nullptr);
}
GEventSimulate_t GEventAdvanceTick_t::GetParent() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("EventAdvanceTick_t::GetParent(ptr=%p)", m_ptr));
    GEventSimulate_t value(m_ptr);
    return value;
}
void GEventAdvanceTick_t::SetParent(GEventSimulate_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("EventAdvanceTick_t::SetParent(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassEventAdvanceTick_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GEventAdvanceTick_t>("EventAdvanceTick_t")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("CurrentTick", &GEventAdvanceTick_t::GetCurrentTick, &GEventAdvanceTick_t::SetCurrentTick)
        .addProperty("CurrentTickThisFrame", &GEventAdvanceTick_t::GetCurrentTickThisFrame, &GEventAdvanceTick_t::SetCurrentTickThisFrame)
        .addProperty("TotalTicksThisFrame", &GEventAdvanceTick_t::GetTotalTicksThisFrame, &GEventAdvanceTick_t::SetTotalTicksThisFrame)
        .addProperty("TotalTicks", &GEventAdvanceTick_t::GetTotalTicks, &GEventAdvanceTick_t::SetTotalTicks)
        .addProperty("Parent", &GEventAdvanceTick_t::GetParent, &GEventAdvanceTick_t::SetParent)
        .addFunction("ToPtr", &GEventAdvanceTick_t::ToPtr)
        .addFunction("IsValid", &GEventAdvanceTick_t::IsValid)
        .endClass();
}
GMotionIndex::GMotionIndex(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GMotionIndex::GMotionIndex(void *ptr) {
    m_ptr = ptr;
}
uint16_t GMotionIndex::GetGroup() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: MotionIndex->Group(ptr=%p)", m_ptr));
    return GetSchemaValue<uint16_t>(m_ptr, "MotionIndex", "m_nGroup");
}
void GMotionIndex::SetGroup(uint16_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: MotionIndex->Group(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "MotionIndex", "m_nGroup", false, value);
}
uint16_t GMotionIndex::GetMotion() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: MotionIndex->Motion(ptr=%p)", m_ptr));
    return GetSchemaValue<uint16_t>(m_ptr, "MotionIndex", "m_nMotion");
}
void GMotionIndex::SetMotion(uint16_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: MotionIndex->Motion(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "MotionIndex", "m_nMotion", false, value);
}
void* GMotionIndex::GetPtr() {
    return m_ptr;
}
std::string GMotionIndex::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GMotionIndex::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassMotionIndex(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GMotionIndex>("MotionIndex")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Group", &GMotionIndex::GetGroup, &GMotionIndex::SetGroup)
        .addProperty("Motion", &GMotionIndex::GetMotion, &GMotionIndex::SetMotion)
        .addFunction("ToPtr", &GMotionIndex::ToPtr)
        .addFunction("IsValid", &GMotionIndex::IsValid)
        .endClass();
}
GCAnimBoneDifference::GCAnimBoneDifference(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCAnimBoneDifference::GCAnimBoneDifference(void *ptr) {
    m_ptr = ptr;
}
Vector GCAnimBoneDifference::GetPosError() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CAnimBoneDifference->PosError(ptr=%p)", m_ptr));
    return GetSchemaValue<Vector>(m_ptr, "CAnimBoneDifference", "m_posError");
}
void GCAnimBoneDifference::SetPosError(Vector value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CAnimBoneDifference->PosError(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CAnimBoneDifference", "m_posError", false, value);
}
bool GCAnimBoneDifference::GetHasRotation() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CAnimBoneDifference->HasRotation(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "CAnimBoneDifference", "m_bHasRotation");
}
void GCAnimBoneDifference::SetHasRotation(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CAnimBoneDifference->HasRotation(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CAnimBoneDifference", "m_bHasRotation", false, value);
}
bool GCAnimBoneDifference::GetHasMovement() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CAnimBoneDifference->HasMovement(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "CAnimBoneDifference", "m_bHasMovement");
}
void GCAnimBoneDifference::SetHasMovement(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CAnimBoneDifference->HasMovement(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CAnimBoneDifference", "m_bHasMovement", false, value);
}
void* GCAnimBoneDifference::GetPtr() {
    return m_ptr;
}
std::string GCAnimBoneDifference::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCAnimBoneDifference::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCAnimBoneDifference(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCAnimBoneDifference>("CAnimBoneDifference")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("PosError", &GCAnimBoneDifference::GetPosError, &GCAnimBoneDifference::SetPosError)
        .addProperty("HasRotation", &GCAnimBoneDifference::GetHasRotation, &GCAnimBoneDifference::SetHasRotation)
        .addProperty("HasMovement", &GCAnimBoneDifference::GetHasMovement, &GCAnimBoneDifference::SetHasMovement)
        .addFunction("ToPtr", &GCAnimBoneDifference::ToPtr)
        .addFunction("IsValid", &GCAnimBoneDifference::IsValid)
        .endClass();
}
GCFootDefinition::GCFootDefinition(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCFootDefinition::GCFootDefinition(void *ptr) {
    m_ptr = ptr;
}
std::string GCFootDefinition::GetName() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CFootDefinition->Name(ptr=%p)", m_ptr));
    return GetSchemaValue<CUtlString>(m_ptr, "CFootDefinition", "m_name").Get();
}
void GCFootDefinition::SetName(std::string value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CFootDefinition->Name(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CFootDefinition", "m_name", false, CUtlString(value.c_str()));
}
std::string GCFootDefinition::GetAnkleBoneName() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CFootDefinition->AnkleBoneName(ptr=%p)", m_ptr));
    return GetSchemaValue<CUtlString>(m_ptr, "CFootDefinition", "m_ankleBoneName").Get();
}
void GCFootDefinition::SetAnkleBoneName(std::string value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CFootDefinition->AnkleBoneName(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CFootDefinition", "m_ankleBoneName", false, CUtlString(value.c_str()));
}
std::string GCFootDefinition::GetToeBoneName() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CFootDefinition->ToeBoneName(ptr=%p)", m_ptr));
    return GetSchemaValue<CUtlString>(m_ptr, "CFootDefinition", "m_toeBoneName").Get();
}
void GCFootDefinition::SetToeBoneName(std::string value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CFootDefinition->ToeBoneName(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CFootDefinition", "m_toeBoneName", false, CUtlString(value.c_str()));
}
Vector GCFootDefinition::GetBallOffset() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CFootDefinition->BallOffset(ptr=%p)", m_ptr));
    return GetSchemaValue<Vector>(m_ptr, "CFootDefinition", "m_vBallOffset");
}
void GCFootDefinition::SetBallOffset(Vector value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CFootDefinition->BallOffset(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CFootDefinition", "m_vBallOffset", false, value);
}
Vector GCFootDefinition::GetHeelOffset() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CFootDefinition->HeelOffset(ptr=%p)", m_ptr));
    return GetSchemaValue<Vector>(m_ptr, "CFootDefinition", "m_vHeelOffset");
}
void GCFootDefinition::SetHeelOffset(Vector value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CFootDefinition->HeelOffset(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CFootDefinition", "m_vHeelOffset", false, value);
}
float GCFootDefinition::GetFootLength() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CFootDefinition->FootLength(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CFootDefinition", "m_flFootLength");
}
void GCFootDefinition::SetFootLength(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CFootDefinition->FootLength(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CFootDefinition", "m_flFootLength", false, value);
}
float GCFootDefinition::GetBindPoseDirectionMS() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CFootDefinition->BindPoseDirectionMS(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CFootDefinition", "m_flBindPoseDirectionMS");
}
void GCFootDefinition::SetBindPoseDirectionMS(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CFootDefinition->BindPoseDirectionMS(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CFootDefinition", "m_flBindPoseDirectionMS", false, value);
}
float GCFootDefinition::GetTraceHeight() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CFootDefinition->TraceHeight(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CFootDefinition", "m_flTraceHeight");
}
void GCFootDefinition::SetTraceHeight(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CFootDefinition->TraceHeight(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CFootDefinition", "m_flTraceHeight", false, value);
}
float GCFootDefinition::GetTraceRadius() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CFootDefinition->TraceRadius(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CFootDefinition", "m_flTraceRadius");
}
void GCFootDefinition::SetTraceRadius(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CFootDefinition->TraceRadius(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CFootDefinition", "m_flTraceRadius", false, value);
}
void* GCFootDefinition::GetPtr() {
    return m_ptr;
}
std::string GCFootDefinition::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCFootDefinition::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCFootDefinition(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCFootDefinition>("CFootDefinition")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Name", &GCFootDefinition::GetName, &GCFootDefinition::SetName)
        .addProperty("AnkleBoneName", &GCFootDefinition::GetAnkleBoneName, &GCFootDefinition::SetAnkleBoneName)
        .addProperty("ToeBoneName", &GCFootDefinition::GetToeBoneName, &GCFootDefinition::SetToeBoneName)
        .addProperty("BallOffset", &GCFootDefinition::GetBallOffset, &GCFootDefinition::SetBallOffset)
        .addProperty("HeelOffset", &GCFootDefinition::GetHeelOffset, &GCFootDefinition::SetHeelOffset)
        .addProperty("FootLength", &GCFootDefinition::GetFootLength, &GCFootDefinition::SetFootLength)
        .addProperty("BindPoseDirectionMS", &GCFootDefinition::GetBindPoseDirectionMS, &GCFootDefinition::SetBindPoseDirectionMS)
        .addProperty("TraceHeight", &GCFootDefinition::GetTraceHeight, &GCFootDefinition::SetTraceHeight)
        .addProperty("TraceRadius", &GCFootDefinition::GetTraceRadius, &GCFootDefinition::SetTraceRadius)
        .addFunction("ToPtr", &GCFootDefinition::ToPtr)
        .addFunction("IsValid", &GCFootDefinition::IsValid)
        .endClass();
}
GCFootCycle::GCFootCycle(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCFootCycle::GCFootCycle(void *ptr) {
    m_ptr = ptr;
}
void* GCFootCycle::GetPtr() {
    return m_ptr;
}
std::string GCFootCycle::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCFootCycle::IsValid() {
    return (m_ptr != nullptr);
}
GCCycleBase GCFootCycle::GetParent() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CFootCycle::GetParent(ptr=%p)", m_ptr));
    GCCycleBase value(m_ptr);
    return value;
}
void GCFootCycle::SetParent(GCCycleBase value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CFootCycle::SetParent(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCFootCycle(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCFootCycle>("CFootCycle")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Parent", &GCFootCycle::GetParent, &GCFootCycle::SetParent)
        .addFunction("ToPtr", &GCFootCycle::ToPtr)
        .addFunction("IsValid", &GCFootCycle::IsValid)
        .endClass();
}
GCMotionDataSet::GCMotionDataSet(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCMotionDataSet::GCMotionDataSet(void *ptr) {
    m_ptr = ptr;
}
std::vector<GCMotionGraphGroup> GCMotionDataSet::GetGroups() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CMotionDataSet->Groups(ptr=%p)", m_ptr));
    CUtlVector<GCMotionGraphGroup>* vec = GetSchemaValue<CUtlVector<GCMotionGraphGroup>*>(m_ptr, "CMotionDataSet", "m_groups"); std::vector<GCMotionGraphGroup> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCMotionDataSet::SetGroups(std::vector<GCMotionGraphGroup> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CMotionDataSet->Groups(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<GCMotionGraphGroup>(m_ptr, "CMotionDataSet", "m_groups", false, value);
}
int32_t GCMotionDataSet::GetDimensionCount() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CMotionDataSet->DimensionCount(ptr=%p)", m_ptr));
    return GetSchemaValue<int32_t>(m_ptr, "CMotionDataSet", "m_nDimensionCount");
}
void GCMotionDataSet::SetDimensionCount(int32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CMotionDataSet->DimensionCount(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CMotionDataSet", "m_nDimensionCount", false, value);
}
void* GCMotionDataSet::GetPtr() {
    return m_ptr;
}
std::string GCMotionDataSet::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCMotionDataSet::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCMotionDataSet(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCMotionDataSet>("CMotionDataSet")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Groups", &GCMotionDataSet::GetGroups, &GCMotionDataSet::SetGroups)
        .addProperty("DimensionCount", &GCMotionDataSet::GetDimensionCount, &GCMotionDataSet::SetDimensionCount)
        .addFunction("ToPtr", &GCMotionDataSet::ToPtr)
        .addFunction("IsValid", &GCMotionDataSet::IsValid)
        .endClass();
}
GCVPhysXSurfacePropertiesList::GCVPhysXSurfacePropertiesList(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCVPhysXSurfacePropertiesList::GCVPhysXSurfacePropertiesList(void *ptr) {
    m_ptr = ptr;
}
std::vector<GCPhysSurfaceProperties*> GCVPhysXSurfacePropertiesList::GetSurfacePropertiesList() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CVPhysXSurfacePropertiesList->SurfacePropertiesList(ptr=%p)", m_ptr));
    CUtlVector<GCPhysSurfaceProperties*>* vec = GetSchemaValue<CUtlVector<GCPhysSurfaceProperties*>*>(m_ptr, "CVPhysXSurfacePropertiesList", "m_surfacePropertiesList"); std::vector<GCPhysSurfaceProperties*> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCVPhysXSurfacePropertiesList::SetSurfacePropertiesList(std::vector<GCPhysSurfaceProperties*> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CVPhysXSurfacePropertiesList->SurfacePropertiesList(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<GCPhysSurfaceProperties*>(m_ptr, "CVPhysXSurfacePropertiesList", "m_surfacePropertiesList", false, value);
}
void* GCVPhysXSurfacePropertiesList::GetPtr() {
    return m_ptr;
}
std::string GCVPhysXSurfacePropertiesList::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCVPhysXSurfacePropertiesList::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCVPhysXSurfacePropertiesList(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCVPhysXSurfacePropertiesList>("CVPhysXSurfacePropertiesList")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("SurfacePropertiesList", &GCVPhysXSurfacePropertiesList::GetSurfacePropertiesList, &GCVPhysXSurfacePropertiesList::SetSurfacePropertiesList)
        .addFunction("ToPtr", &GCVPhysXSurfacePropertiesList::ToPtr)
        .addFunction("IsValid", &GCVPhysXSurfacePropertiesList::IsValid)
        .endClass();
}
GCParticleFunctionEmitter::GCParticleFunctionEmitter(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCParticleFunctionEmitter::GCParticleFunctionEmitter(void *ptr) {
    m_ptr = ptr;
}
int32_t GCParticleFunctionEmitter::GetEmitterIndex() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CParticleFunctionEmitter->EmitterIndex(ptr=%p)", m_ptr));
    return GetSchemaValue<int32_t>(m_ptr, "CParticleFunctionEmitter", "m_nEmitterIndex");
}
void GCParticleFunctionEmitter::SetEmitterIndex(int32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CParticleFunctionEmitter->EmitterIndex(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CParticleFunctionEmitter", "m_nEmitterIndex", false, value);
}
void* GCParticleFunctionEmitter::GetPtr() {
    return m_ptr;
}
std::string GCParticleFunctionEmitter::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCParticleFunctionEmitter::IsValid() {
    return (m_ptr != nullptr);
}
GCParticleFunction GCParticleFunctionEmitter::GetParent() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CParticleFunctionEmitter::GetParent(ptr=%p)", m_ptr));
    GCParticleFunction value(m_ptr);
    return value;
}
void GCParticleFunctionEmitter::SetParent(GCParticleFunction value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CParticleFunctionEmitter::SetParent(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCParticleFunctionEmitter(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCParticleFunctionEmitter>("CParticleFunctionEmitter")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("EmitterIndex", &GCParticleFunctionEmitter::GetEmitterIndex, &GCParticleFunctionEmitter::SetEmitterIndex)
        .addProperty("Parent", &GCParticleFunctionEmitter::GetParent, &GCParticleFunctionEmitter::SetParent)
        .addFunction("ToPtr", &GCParticleFunctionEmitter::ToPtr)
        .addFunction("IsValid", &GCParticleFunctionEmitter::IsValid)
        .endClass();
}
GVMixFilterDesc_t::GVMixFilterDesc_t(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GVMixFilterDesc_t::GVMixFilterDesc_t(void *ptr) {
    m_ptr = ptr;
}
uint64_t GVMixFilterDesc_t::GetFilterType() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: VMixFilterDesc_t->FilterType(ptr=%p)", m_ptr));
    return GetSchemaValue<uint64_t>(m_ptr, "VMixFilterDesc_t", "m_nFilterType");
}
void GVMixFilterDesc_t::SetFilterType(uint64_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: VMixFilterDesc_t->FilterType(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "VMixFilterDesc_t", "m_nFilterType", true, value);
}
uint64_t GVMixFilterDesc_t::GetFilterSlope() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: VMixFilterDesc_t->FilterSlope(ptr=%p)", m_ptr));
    return GetSchemaValue<uint64_t>(m_ptr, "VMixFilterDesc_t", "m_nFilterSlope");
}
void GVMixFilterDesc_t::SetFilterSlope(uint64_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: VMixFilterDesc_t->FilterSlope(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "VMixFilterDesc_t", "m_nFilterSlope", true, value);
}
bool GVMixFilterDesc_t::GetEnabled() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: VMixFilterDesc_t->Enabled(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "VMixFilterDesc_t", "m_bEnabled");
}
void GVMixFilterDesc_t::SetEnabled(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: VMixFilterDesc_t->Enabled(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "VMixFilterDesc_t", "m_bEnabled", true, value);
}
float GVMixFilterDesc_t::GetFldbGain() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: VMixFilterDesc_t->FldbGain(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "VMixFilterDesc_t", "m_fldbGain");
}
void GVMixFilterDesc_t::SetFldbGain(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: VMixFilterDesc_t->FldbGain(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "VMixFilterDesc_t", "m_fldbGain", true, value);
}
float GVMixFilterDesc_t::GetCutoffFreq() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: VMixFilterDesc_t->CutoffFreq(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "VMixFilterDesc_t", "m_flCutoffFreq");
}
void GVMixFilterDesc_t::SetCutoffFreq(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: VMixFilterDesc_t->CutoffFreq(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "VMixFilterDesc_t", "m_flCutoffFreq", true, value);
}
float GVMixFilterDesc_t::GetQ() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: VMixFilterDesc_t->Q(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "VMixFilterDesc_t", "m_flQ");
}
void GVMixFilterDesc_t::SetQ(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: VMixFilterDesc_t->Q(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "VMixFilterDesc_t", "m_flQ", true, value);
}
void* GVMixFilterDesc_t::GetPtr() {
    return m_ptr;
}
std::string GVMixFilterDesc_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GVMixFilterDesc_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassVMixFilterDesc_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GVMixFilterDesc_t>("VMixFilterDesc_t")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("FilterType", &GVMixFilterDesc_t::GetFilterType, &GVMixFilterDesc_t::SetFilterType)
        .addProperty("FilterSlope", &GVMixFilterDesc_t::GetFilterSlope, &GVMixFilterDesc_t::SetFilterSlope)
        .addProperty("Enabled", &GVMixFilterDesc_t::GetEnabled, &GVMixFilterDesc_t::SetEnabled)
        .addProperty("FldbGain", &GVMixFilterDesc_t::GetFldbGain, &GVMixFilterDesc_t::SetFldbGain)
        .addProperty("CutoffFreq", &GVMixFilterDesc_t::GetCutoffFreq, &GVMixFilterDesc_t::SetCutoffFreq)
        .addProperty("Q", &GVMixFilterDesc_t::GetQ, &GVMixFilterDesc_t::SetQ)
        .addFunction("ToPtr", &GVMixFilterDesc_t::ToPtr)
        .addFunction("IsValid", &GVMixFilterDesc_t::IsValid)
        .endClass();
}
GCBaseConstraint::GCBaseConstraint(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCBaseConstraint::GCBaseConstraint(void *ptr) {
    m_ptr = ptr;
}
std::string GCBaseConstraint::GetName() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CBaseConstraint->Name(ptr=%p)", m_ptr));
    return GetSchemaValue<CUtlString>(m_ptr, "CBaseConstraint", "m_name").Get();
}
void GCBaseConstraint::SetName(std::string value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CBaseConstraint->Name(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CBaseConstraint", "m_name", false, CUtlString(value.c_str()));
}
Vector GCBaseConstraint::GetUpVector() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CBaseConstraint->UpVector(ptr=%p)", m_ptr));
    return GetSchemaValue<Vector>(m_ptr, "CBaseConstraint", "m_vUpVector");
}
void GCBaseConstraint::SetUpVector(Vector value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CBaseConstraint->UpVector(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CBaseConstraint", "m_vUpVector", false, value);
}
std::vector<GCConstraintSlave> GCBaseConstraint::GetSlaves() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CBaseConstraint->Slaves(ptr=%p)", m_ptr));
    CUtlVector<GCConstraintSlave>* vec = GetSchemaValue<CUtlVector<GCConstraintSlave>*>(m_ptr, "CBaseConstraint", "m_slaves"); std::vector<GCConstraintSlave> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCBaseConstraint::SetSlaves(std::vector<GCConstraintSlave> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CBaseConstraint->Slaves(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<GCConstraintSlave>(m_ptr, "CBaseConstraint", "m_slaves", false, value);
}
std::vector<GCConstraintTarget> GCBaseConstraint::GetTargets() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CBaseConstraint->Targets(ptr=%p)", m_ptr));
    CUtlVector<GCConstraintTarget>* vec = GetSchemaValue<CUtlVector<GCConstraintTarget>*>(m_ptr, "CBaseConstraint", "m_targets"); std::vector<GCConstraintTarget> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCBaseConstraint::SetTargets(std::vector<GCConstraintTarget> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CBaseConstraint->Targets(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<GCConstraintTarget>(m_ptr, "CBaseConstraint", "m_targets", false, value);
}
void* GCBaseConstraint::GetPtr() {
    return m_ptr;
}
std::string GCBaseConstraint::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCBaseConstraint::IsValid() {
    return (m_ptr != nullptr);
}
GCBoneConstraintBase GCBaseConstraint::GetParent() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CBaseConstraint::GetParent(ptr=%p)", m_ptr));
    GCBoneConstraintBase value(m_ptr);
    return value;
}
void GCBaseConstraint::SetParent(GCBoneConstraintBase value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CBaseConstraint::SetParent(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCBaseConstraint(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCBaseConstraint>("CBaseConstraint")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Name", &GCBaseConstraint::GetName, &GCBaseConstraint::SetName)
        .addProperty("UpVector", &GCBaseConstraint::GetUpVector, &GCBaseConstraint::SetUpVector)
        .addProperty("Slaves", &GCBaseConstraint::GetSlaves, &GCBaseConstraint::SetSlaves)
        .addProperty("Targets", &GCBaseConstraint::GetTargets, &GCBaseConstraint::SetTargets)
        .addProperty("Parent", &GCBaseConstraint::GetParent, &GCBaseConstraint::SetParent)
        .addFunction("ToPtr", &GCBaseConstraint::ToPtr)
        .addFunction("IsValid", &GCBaseConstraint::IsValid)
        .endClass();
}
GCParticleMassCalculationParameters::GCParticleMassCalculationParameters(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCParticleMassCalculationParameters::GCParticleMassCalculationParameters(void *ptr) {
    m_ptr = ptr;
}
uint64_t GCParticleMassCalculationParameters::GetMassMode() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CParticleMassCalculationParameters->MassMode(ptr=%p)", m_ptr));
    return GetSchemaValue<uint64_t>(m_ptr, "CParticleMassCalculationParameters", "m_nMassMode");
}
void GCParticleMassCalculationParameters::SetMassMode(uint64_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CParticleMassCalculationParameters->MassMode(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CParticleMassCalculationParameters", "m_nMassMode", false, value);
}
GCPerParticleFloatInput GCParticleMassCalculationParameters::GetRadius() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CParticleMassCalculationParameters->Radius(ptr=%p)", m_ptr));
    GCPerParticleFloatInput value(GetSchemaPtr(m_ptr, "CParticleMassCalculationParameters", "m_flRadius"));
    return value;
}
void GCParticleMassCalculationParameters::SetRadius(GCPerParticleFloatInput value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CParticleMassCalculationParameters->Radius(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Radius' is not possible.\n");
}
GCPerParticleFloatInput GCParticleMassCalculationParameters::GetNominalRadius() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CParticleMassCalculationParameters->NominalRadius(ptr=%p)", m_ptr));
    GCPerParticleFloatInput value(GetSchemaPtr(m_ptr, "CParticleMassCalculationParameters", "m_flNominalRadius"));
    return value;
}
void GCParticleMassCalculationParameters::SetNominalRadius(GCPerParticleFloatInput value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CParticleMassCalculationParameters->NominalRadius(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'NominalRadius' is not possible.\n");
}
GCPerParticleFloatInput GCParticleMassCalculationParameters::GetScale() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CParticleMassCalculationParameters->Scale(ptr=%p)", m_ptr));
    GCPerParticleFloatInput value(GetSchemaPtr(m_ptr, "CParticleMassCalculationParameters", "m_flScale"));
    return value;
}
void GCParticleMassCalculationParameters::SetScale(GCPerParticleFloatInput value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CParticleMassCalculationParameters->Scale(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Scale' is not possible.\n");
}
void* GCParticleMassCalculationParameters::GetPtr() {
    return m_ptr;
}
std::string GCParticleMassCalculationParameters::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCParticleMassCalculationParameters::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCParticleMassCalculationParameters(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCParticleMassCalculationParameters>("CParticleMassCalculationParameters")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("MassMode", &GCParticleMassCalculationParameters::GetMassMode, &GCParticleMassCalculationParameters::SetMassMode)
        .addProperty("Radius", &GCParticleMassCalculationParameters::GetRadius, &GCParticleMassCalculationParameters::SetRadius)
        .addProperty("NominalRadius", &GCParticleMassCalculationParameters::GetNominalRadius, &GCParticleMassCalculationParameters::SetNominalRadius)
        .addProperty("Scale", &GCParticleMassCalculationParameters::GetScale, &GCParticleMassCalculationParameters::SetScale)
        .addFunction("ToPtr", &GCParticleMassCalculationParameters::ToPtr)
        .addFunction("IsValid", &GCParticleMassCalculationParameters::IsValid)
        .endClass();
}
GAnimParamID::GAnimParamID(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GAnimParamID::GAnimParamID(void *ptr) {
    m_ptr = ptr;
}
uint32_t GAnimParamID::GetId() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: AnimParamID->Id(ptr=%p)", m_ptr));
    return GetSchemaValue<uint32_t>(m_ptr, "AnimParamID", "m_id");
}
void GAnimParamID::SetId(uint32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: AnimParamID->Id(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "AnimParamID", "m_id", false, value);
}
void* GAnimParamID::GetPtr() {
    return m_ptr;
}
std::string GAnimParamID::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GAnimParamID::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassAnimParamID(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GAnimParamID>("AnimParamID")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Id", &GAnimParamID::GetId, &GAnimParamID::SetId)
        .addFunction("ToPtr", &GAnimParamID::ToPtr)
        .addFunction("IsValid", &GAnimParamID::IsValid)
        .endClass();
}
GCTransitionUpdateData::GCTransitionUpdateData(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCTransitionUpdateData::GCTransitionUpdateData(void *ptr) {
    m_ptr = ptr;
}
uint32_t GCTransitionUpdateData::GetSrcStateIndex() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CTransitionUpdateData->SrcStateIndex(ptr=%p)", m_ptr));
    return GetSchemaValue<uint32_t>(m_ptr, "CTransitionUpdateData", "m_srcStateIndex");
}
void GCTransitionUpdateData::SetSrcStateIndex(uint32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CTransitionUpdateData->SrcStateIndex(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CTransitionUpdateData", "m_srcStateIndex", false, value);
}
uint32_t GCTransitionUpdateData::GetDestStateIndex() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CTransitionUpdateData->DestStateIndex(ptr=%p)", m_ptr));
    return GetSchemaValue<uint32_t>(m_ptr, "CTransitionUpdateData", "m_destStateIndex");
}
void GCTransitionUpdateData::SetDestStateIndex(uint32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CTransitionUpdateData->DestStateIndex(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CTransitionUpdateData", "m_destStateIndex", false, value);
}
void* GCTransitionUpdateData::GetPtr() {
    return m_ptr;
}
std::string GCTransitionUpdateData::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCTransitionUpdateData::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCTransitionUpdateData(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCTransitionUpdateData>("CTransitionUpdateData")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("SrcStateIndex", &GCTransitionUpdateData::GetSrcStateIndex, &GCTransitionUpdateData::SetSrcStateIndex)
        .addProperty("DestStateIndex", &GCTransitionUpdateData::GetDestStateIndex, &GCTransitionUpdateData::SetDestStateIndex)
        .addFunction("ToPtr", &GCTransitionUpdateData::ToPtr)
        .addFunction("IsValid", &GCTransitionUpdateData::IsValid)
        .endClass();
}
GManifestTestResource_t::GManifestTestResource_t(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GManifestTestResource_t::GManifestTestResource_t(void *ptr) {
    m_ptr = ptr;
}
std::string GManifestTestResource_t::GetName() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: ManifestTestResource_t->Name(ptr=%p)", m_ptr));
    return GetSchemaValue<CUtlString>(m_ptr, "ManifestTestResource_t", "m_name").Get();
}
void GManifestTestResource_t::SetName(std::string value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: ManifestTestResource_t->Name(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "ManifestTestResource_t", "m_name", true, CUtlString(value.c_str()));
}
void* GManifestTestResource_t::GetPtr() {
    return m_ptr;
}
std::string GManifestTestResource_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GManifestTestResource_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassManifestTestResource_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GManifestTestResource_t>("ManifestTestResource_t")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Name", &GManifestTestResource_t::GetName, &GManifestTestResource_t::SetName)
        .addFunction("ToPtr", &GManifestTestResource_t::ToPtr)
        .addFunction("IsValid", &GManifestTestResource_t::IsValid)
        .endClass();
}
GFootPinningPoseOpFixedData_t::GFootPinningPoseOpFixedData_t(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GFootPinningPoseOpFixedData_t::GFootPinningPoseOpFixedData_t(void *ptr) {
    m_ptr = ptr;
}
std::vector<GFootFixedData_t> GFootPinningPoseOpFixedData_t::GetFootInfo() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FootPinningPoseOpFixedData_t->FootInfo(ptr=%p)", m_ptr));
    CUtlVector<GFootFixedData_t>* vec = GetSchemaValue<CUtlVector<GFootFixedData_t>*>(m_ptr, "FootPinningPoseOpFixedData_t", "m_footInfo"); std::vector<GFootFixedData_t> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GFootPinningPoseOpFixedData_t::SetFootInfo(std::vector<GFootFixedData_t> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FootPinningPoseOpFixedData_t->FootInfo(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<GFootFixedData_t>(m_ptr, "FootPinningPoseOpFixedData_t", "m_footInfo", true, value);
}
float GFootPinningPoseOpFixedData_t::GetBlendTime() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FootPinningPoseOpFixedData_t->BlendTime(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "FootPinningPoseOpFixedData_t", "m_flBlendTime");
}
void GFootPinningPoseOpFixedData_t::SetBlendTime(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FootPinningPoseOpFixedData_t->BlendTime(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "FootPinningPoseOpFixedData_t", "m_flBlendTime", true, value);
}
float GFootPinningPoseOpFixedData_t::GetLockBreakDistance() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FootPinningPoseOpFixedData_t->LockBreakDistance(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "FootPinningPoseOpFixedData_t", "m_flLockBreakDistance");
}
void GFootPinningPoseOpFixedData_t::SetLockBreakDistance(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FootPinningPoseOpFixedData_t->LockBreakDistance(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "FootPinningPoseOpFixedData_t", "m_flLockBreakDistance", true, value);
}
float GFootPinningPoseOpFixedData_t::GetMaxLegTwist() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FootPinningPoseOpFixedData_t->MaxLegTwist(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "FootPinningPoseOpFixedData_t", "m_flMaxLegTwist");
}
void GFootPinningPoseOpFixedData_t::SetMaxLegTwist(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FootPinningPoseOpFixedData_t->MaxLegTwist(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "FootPinningPoseOpFixedData_t", "m_flMaxLegTwist", true, value);
}
int32_t GFootPinningPoseOpFixedData_t::GetHipBoneIndex() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FootPinningPoseOpFixedData_t->HipBoneIndex(ptr=%p)", m_ptr));
    return GetSchemaValue<int32_t>(m_ptr, "FootPinningPoseOpFixedData_t", "m_nHipBoneIndex");
}
void GFootPinningPoseOpFixedData_t::SetHipBoneIndex(int32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FootPinningPoseOpFixedData_t->HipBoneIndex(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "FootPinningPoseOpFixedData_t", "m_nHipBoneIndex", true, value);
}
bool GFootPinningPoseOpFixedData_t::GetApplyLegTwistLimits() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FootPinningPoseOpFixedData_t->ApplyLegTwistLimits(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "FootPinningPoseOpFixedData_t", "m_bApplyLegTwistLimits");
}
void GFootPinningPoseOpFixedData_t::SetApplyLegTwistLimits(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FootPinningPoseOpFixedData_t->ApplyLegTwistLimits(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "FootPinningPoseOpFixedData_t", "m_bApplyLegTwistLimits", true, value);
}
bool GFootPinningPoseOpFixedData_t::GetApplyFootRotationLimits() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FootPinningPoseOpFixedData_t->ApplyFootRotationLimits(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "FootPinningPoseOpFixedData_t", "m_bApplyFootRotationLimits");
}
void GFootPinningPoseOpFixedData_t::SetApplyFootRotationLimits(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FootPinningPoseOpFixedData_t->ApplyFootRotationLimits(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "FootPinningPoseOpFixedData_t", "m_bApplyFootRotationLimits", true, value);
}
void* GFootPinningPoseOpFixedData_t::GetPtr() {
    return m_ptr;
}
std::string GFootPinningPoseOpFixedData_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GFootPinningPoseOpFixedData_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassFootPinningPoseOpFixedData_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GFootPinningPoseOpFixedData_t>("FootPinningPoseOpFixedData_t")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("FootInfo", &GFootPinningPoseOpFixedData_t::GetFootInfo, &GFootPinningPoseOpFixedData_t::SetFootInfo)
        .addProperty("BlendTime", &GFootPinningPoseOpFixedData_t::GetBlendTime, &GFootPinningPoseOpFixedData_t::SetBlendTime)
        .addProperty("LockBreakDistance", &GFootPinningPoseOpFixedData_t::GetLockBreakDistance, &GFootPinningPoseOpFixedData_t::SetLockBreakDistance)
        .addProperty("MaxLegTwist", &GFootPinningPoseOpFixedData_t::GetMaxLegTwist, &GFootPinningPoseOpFixedData_t::SetMaxLegTwist)
        .addProperty("HipBoneIndex", &GFootPinningPoseOpFixedData_t::GetHipBoneIndex, &GFootPinningPoseOpFixedData_t::SetHipBoneIndex)
        .addProperty("ApplyLegTwistLimits", &GFootPinningPoseOpFixedData_t::GetApplyLegTwistLimits, &GFootPinningPoseOpFixedData_t::SetApplyLegTwistLimits)
        .addProperty("ApplyFootRotationLimits", &GFootPinningPoseOpFixedData_t::GetApplyFootRotationLimits, &GFootPinningPoseOpFixedData_t::SetApplyFootRotationLimits)
        .addFunction("ToPtr", &GFootPinningPoseOpFixedData_t::ToPtr)
        .addFunction("IsValid", &GFootPinningPoseOpFixedData_t::IsValid)
        .endClass();
}
GCFootPinningUpdateNode::GCFootPinningUpdateNode(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCFootPinningUpdateNode::GCFootPinningUpdateNode(void *ptr) {
    m_ptr = ptr;
}
GFootPinningPoseOpFixedData_t GCFootPinningUpdateNode::GetPoseOpFixedData() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CFootPinningUpdateNode->PoseOpFixedData(ptr=%p)", m_ptr));
    GFootPinningPoseOpFixedData_t value(GetSchemaPtr(m_ptr, "CFootPinningUpdateNode", "m_poseOpFixedData"));
    return value;
}
void GCFootPinningUpdateNode::SetPoseOpFixedData(GFootPinningPoseOpFixedData_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CFootPinningUpdateNode->PoseOpFixedData(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'PoseOpFixedData' is not possible.\n");
}
uint64_t GCFootPinningUpdateNode::GetTimingSource() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CFootPinningUpdateNode->TimingSource(ptr=%p)", m_ptr));
    return GetSchemaValue<uint64_t>(m_ptr, "CFootPinningUpdateNode", "m_eTimingSource");
}
void GCFootPinningUpdateNode::SetTimingSource(uint64_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CFootPinningUpdateNode->TimingSource(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CFootPinningUpdateNode", "m_eTimingSource", false, value);
}
std::vector<GCAnimParamHandle> GCFootPinningUpdateNode::GetParams() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CFootPinningUpdateNode->Params(ptr=%p)", m_ptr));
    CUtlVector<GCAnimParamHandle>* vec = GetSchemaValue<CUtlVector<GCAnimParamHandle>*>(m_ptr, "CFootPinningUpdateNode", "m_params"); std::vector<GCAnimParamHandle> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCFootPinningUpdateNode::SetParams(std::vector<GCAnimParamHandle> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CFootPinningUpdateNode->Params(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<GCAnimParamHandle>(m_ptr, "CFootPinningUpdateNode", "m_params", false, value);
}
bool GCFootPinningUpdateNode::GetResetChild() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CFootPinningUpdateNode->ResetChild(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "CFootPinningUpdateNode", "m_bResetChild");
}
void GCFootPinningUpdateNode::SetResetChild(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CFootPinningUpdateNode->ResetChild(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CFootPinningUpdateNode", "m_bResetChild", false, value);
}
void* GCFootPinningUpdateNode::GetPtr() {
    return m_ptr;
}
std::string GCFootPinningUpdateNode::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCFootPinningUpdateNode::IsValid() {
    return (m_ptr != nullptr);
}
GCUnaryUpdateNode GCFootPinningUpdateNode::GetParent() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CFootPinningUpdateNode::GetParent(ptr=%p)", m_ptr));
    GCUnaryUpdateNode value(m_ptr);
    return value;
}
void GCFootPinningUpdateNode::SetParent(GCUnaryUpdateNode value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CFootPinningUpdateNode::SetParent(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCFootPinningUpdateNode(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCFootPinningUpdateNode>("CFootPinningUpdateNode")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("PoseOpFixedData", &GCFootPinningUpdateNode::GetPoseOpFixedData, &GCFootPinningUpdateNode::SetPoseOpFixedData)
        .addProperty("TimingSource", &GCFootPinningUpdateNode::GetTimingSource, &GCFootPinningUpdateNode::SetTimingSource)
        .addProperty("Params", &GCFootPinningUpdateNode::GetParams, &GCFootPinningUpdateNode::SetParams)
        .addProperty("ResetChild", &GCFootPinningUpdateNode::GetResetChild, &GCFootPinningUpdateNode::SetResetChild)
        .addProperty("Parent", &GCFootPinningUpdateNode::GetParent, &GCFootPinningUpdateNode::SetParent)
        .addFunction("ToPtr", &GCFootPinningUpdateNode::ToPtr)
        .addFunction("IsValid", &GCFootPinningUpdateNode::IsValid)
        .endClass();
}
GCLeafUpdateNode::GCLeafUpdateNode(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCLeafUpdateNode::GCLeafUpdateNode(void *ptr) {
    m_ptr = ptr;
}
void* GCLeafUpdateNode::GetPtr() {
    return m_ptr;
}
std::string GCLeafUpdateNode::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCLeafUpdateNode::IsValid() {
    return (m_ptr != nullptr);
}
GCAnimUpdateNodeBase GCLeafUpdateNode::GetParent() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CLeafUpdateNode::GetParent(ptr=%p)", m_ptr));
    GCAnimUpdateNodeBase value(m_ptr);
    return value;
}
void GCLeafUpdateNode::SetParent(GCAnimUpdateNodeBase value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CLeafUpdateNode::SetParent(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCLeafUpdateNode(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCLeafUpdateNode>("CLeafUpdateNode")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Parent", &GCLeafUpdateNode::GetParent, &GCLeafUpdateNode::SetParent)
        .addFunction("ToPtr", &GCLeafUpdateNode::ToPtr)
        .addFunction("IsValid", &GCLeafUpdateNode::IsValid)
        .endClass();
}
GCAnimMotorUpdaterBase::GCAnimMotorUpdaterBase(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCAnimMotorUpdaterBase::GCAnimMotorUpdaterBase(void *ptr) {
    m_ptr = ptr;
}
std::string GCAnimMotorUpdaterBase::GetName() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CAnimMotorUpdaterBase->Name(ptr=%p)", m_ptr));
    return GetSchemaValue<CUtlString>(m_ptr, "CAnimMotorUpdaterBase", "m_name").Get();
}
void GCAnimMotorUpdaterBase::SetName(std::string value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CAnimMotorUpdaterBase->Name(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CAnimMotorUpdaterBase", "m_name", false, CUtlString(value.c_str()));
}
bool GCAnimMotorUpdaterBase::GetDefault() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CAnimMotorUpdaterBase->Default(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "CAnimMotorUpdaterBase", "m_bDefault");
}
void GCAnimMotorUpdaterBase::SetDefault(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CAnimMotorUpdaterBase->Default(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CAnimMotorUpdaterBase", "m_bDefault", false, value);
}
void* GCAnimMotorUpdaterBase::GetPtr() {
    return m_ptr;
}
std::string GCAnimMotorUpdaterBase::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCAnimMotorUpdaterBase::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCAnimMotorUpdaterBase(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCAnimMotorUpdaterBase>("CAnimMotorUpdaterBase")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Name", &GCAnimMotorUpdaterBase::GetName, &GCAnimMotorUpdaterBase::SetName)
        .addProperty("Default", &GCAnimMotorUpdaterBase::GetDefault, &GCAnimMotorUpdaterBase::SetDefault)
        .addFunction("ToPtr", &GCAnimMotorUpdaterBase::ToPtr)
        .addFunction("IsValid", &GCAnimMotorUpdaterBase::IsValid)
        .endClass();
}
GRnMesh_t::GRnMesh_t(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GRnMesh_t::GRnMesh_t(void *ptr) {
    m_ptr = ptr;
}
Vector GRnMesh_t::GetMin() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: RnMesh_t->Min(ptr=%p)", m_ptr));
    return GetSchemaValue<Vector>(m_ptr, "RnMesh_t", "m_vMin");
}
void GRnMesh_t::SetMin(Vector value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: RnMesh_t->Min(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "RnMesh_t", "m_vMin", true, value);
}
Vector GRnMesh_t::GetMax() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: RnMesh_t->Max(ptr=%p)", m_ptr));
    return GetSchemaValue<Vector>(m_ptr, "RnMesh_t", "m_vMax");
}
void GRnMesh_t::SetMax(Vector value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: RnMesh_t->Max(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "RnMesh_t", "m_vMax", true, value);
}
std::vector<GRnNode_t> GRnMesh_t::GetNodes() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: RnMesh_t->Nodes(ptr=%p)", m_ptr));
    CUtlVector<GRnNode_t>* vec = GetSchemaValue<CUtlVector<GRnNode_t>*>(m_ptr, "RnMesh_t", "m_Nodes"); std::vector<GRnNode_t> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GRnMesh_t::SetNodes(std::vector<GRnNode_t> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: RnMesh_t->Nodes(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<GRnNode_t>(m_ptr, "RnMesh_t", "m_Nodes", true, value);
}
std::vector<GRnTriangle_t> GRnMesh_t::GetTriangles() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: RnMesh_t->Triangles(ptr=%p)", m_ptr));
    CUtlVector<GRnTriangle_t>* vec = GetSchemaValue<CUtlVector<GRnTriangle_t>*>(m_ptr, "RnMesh_t", "m_Triangles"); std::vector<GRnTriangle_t> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GRnMesh_t::SetTriangles(std::vector<GRnTriangle_t> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: RnMesh_t->Triangles(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<GRnTriangle_t>(m_ptr, "RnMesh_t", "m_Triangles", true, value);
}
std::vector<GRnWing_t> GRnMesh_t::GetWings() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: RnMesh_t->Wings(ptr=%p)", m_ptr));
    CUtlVector<GRnWing_t>* vec = GetSchemaValue<CUtlVector<GRnWing_t>*>(m_ptr, "RnMesh_t", "m_Wings"); std::vector<GRnWing_t> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GRnMesh_t::SetWings(std::vector<GRnWing_t> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: RnMesh_t->Wings(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<GRnWing_t>(m_ptr, "RnMesh_t", "m_Wings", true, value);
}
std::vector<uint8> GRnMesh_t::GetMaterials() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: RnMesh_t->Materials(ptr=%p)", m_ptr));
    CUtlVector<uint8>* vec = GetSchemaValue<CUtlVector<uint8>*>(m_ptr, "RnMesh_t", "m_Materials"); std::vector<uint8> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GRnMesh_t::SetMaterials(std::vector<uint8> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: RnMesh_t->Materials(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<uint8>(m_ptr, "RnMesh_t", "m_Materials", true, value);
}
Vector GRnMesh_t::GetOrthographicAreas() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: RnMesh_t->OrthographicAreas(ptr=%p)", m_ptr));
    return GetSchemaValue<Vector>(m_ptr, "RnMesh_t", "m_vOrthographicAreas");
}
void GRnMesh_t::SetOrthographicAreas(Vector value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: RnMesh_t->OrthographicAreas(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "RnMesh_t", "m_vOrthographicAreas", true, value);
}
uint32_t GRnMesh_t::GetFlags() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: RnMesh_t->Flags(ptr=%p)", m_ptr));
    return GetSchemaValue<uint32_t>(m_ptr, "RnMesh_t", "m_nFlags");
}
void GRnMesh_t::SetFlags(uint32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: RnMesh_t->Flags(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "RnMesh_t", "m_nFlags", true, value);
}
uint32_t GRnMesh_t::GetDebugFlags() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: RnMesh_t->DebugFlags(ptr=%p)", m_ptr));
    return GetSchemaValue<uint32_t>(m_ptr, "RnMesh_t", "m_nDebugFlags");
}
void GRnMesh_t::SetDebugFlags(uint32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: RnMesh_t->DebugFlags(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "RnMesh_t", "m_nDebugFlags", true, value);
}
void* GRnMesh_t::GetPtr() {
    return m_ptr;
}
std::string GRnMesh_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GRnMesh_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassRnMesh_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GRnMesh_t>("RnMesh_t")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Min", &GRnMesh_t::GetMin, &GRnMesh_t::SetMin)
        .addProperty("Max", &GRnMesh_t::GetMax, &GRnMesh_t::SetMax)
        .addProperty("Nodes", &GRnMesh_t::GetNodes, &GRnMesh_t::SetNodes)
        .addProperty("Triangles", &GRnMesh_t::GetTriangles, &GRnMesh_t::SetTriangles)
        .addProperty("Wings", &GRnMesh_t::GetWings, &GRnMesh_t::SetWings)
        .addProperty("Materials", &GRnMesh_t::GetMaterials, &GRnMesh_t::SetMaterials)
        .addProperty("OrthographicAreas", &GRnMesh_t::GetOrthographicAreas, &GRnMesh_t::SetOrthographicAreas)
        .addProperty("Flags", &GRnMesh_t::GetFlags, &GRnMesh_t::SetFlags)
        .addProperty("DebugFlags", &GRnMesh_t::GetDebugFlags, &GRnMesh_t::SetDebugFlags)
        .addFunction("ToPtr", &GRnMesh_t::ToPtr)
        .addFunction("IsValid", &GRnMesh_t::IsValid)
        .endClass();
}
GCModelConfigElement::GCModelConfigElement(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCModelConfigElement::GCModelConfigElement(void *ptr) {
    m_ptr = ptr;
}
std::string GCModelConfigElement::GetElementName() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CModelConfigElement->ElementName(ptr=%p)", m_ptr));
    return GetSchemaValue<CUtlString>(m_ptr, "CModelConfigElement", "m_ElementName").Get();
}
void GCModelConfigElement::SetElementName(std::string value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CModelConfigElement->ElementName(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CModelConfigElement", "m_ElementName", false, CUtlString(value.c_str()));
}
std::vector<GCModelConfigElement*> GCModelConfigElement::GetNestedElements() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CModelConfigElement->NestedElements(ptr=%p)", m_ptr));
    CUtlVector<GCModelConfigElement*>* vec = GetSchemaValue<CUtlVector<GCModelConfigElement*>*>(m_ptr, "CModelConfigElement", "m_NestedElements"); std::vector<GCModelConfigElement*> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCModelConfigElement::SetNestedElements(std::vector<GCModelConfigElement*> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CModelConfigElement->NestedElements(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<GCModelConfigElement*>(m_ptr, "CModelConfigElement", "m_NestedElements", false, value);
}
void* GCModelConfigElement::GetPtr() {
    return m_ptr;
}
std::string GCModelConfigElement::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCModelConfigElement::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCModelConfigElement(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCModelConfigElement>("CModelConfigElement")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("ElementName", &GCModelConfigElement::GetElementName, &GCModelConfigElement::SetElementName)
        .addProperty("NestedElements", &GCModelConfigElement::GetNestedElements, &GCModelConfigElement::SetNestedElements)
        .addFunction("ToPtr", &GCModelConfigElement::ToPtr)
        .addFunction("IsValid", &GCModelConfigElement::IsValid)
        .endClass();
}
GVPhysXAggregateData_t::GVPhysXAggregateData_t(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GVPhysXAggregateData_t::GVPhysXAggregateData_t(void *ptr) {
    m_ptr = ptr;
}
uint16_t GVPhysXAggregateData_t::GetFlags() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: VPhysXAggregateData_t->Flags(ptr=%p)", m_ptr));
    return GetSchemaValue<uint16_t>(m_ptr, "VPhysXAggregateData_t", "m_nFlags");
}
void GVPhysXAggregateData_t::SetFlags(uint16_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: VPhysXAggregateData_t->Flags(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "VPhysXAggregateData_t", "m_nFlags", true, value);
}
uint16_t GVPhysXAggregateData_t::GetRefCounter() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: VPhysXAggregateData_t->RefCounter(ptr=%p)", m_ptr));
    return GetSchemaValue<uint16_t>(m_ptr, "VPhysXAggregateData_t", "m_nRefCounter");
}
void GVPhysXAggregateData_t::SetRefCounter(uint16_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: VPhysXAggregateData_t->RefCounter(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "VPhysXAggregateData_t", "m_nRefCounter", true, value);
}
std::vector<uint32> GVPhysXAggregateData_t::GetBonesHash() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: VPhysXAggregateData_t->BonesHash(ptr=%p)", m_ptr));
    CUtlVector<uint32>* vec = GetSchemaValue<CUtlVector<uint32>*>(m_ptr, "VPhysXAggregateData_t", "m_bonesHash"); std::vector<uint32> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GVPhysXAggregateData_t::SetBonesHash(std::vector<uint32> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: VPhysXAggregateData_t->BonesHash(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<uint32>(m_ptr, "VPhysXAggregateData_t", "m_bonesHash", true, value);
}
std::vector<CUtlString> GVPhysXAggregateData_t::GetBoneNames() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: VPhysXAggregateData_t->BoneNames(ptr=%p)", m_ptr));
    CUtlVector<CUtlString>* vec = GetSchemaValue<CUtlVector<CUtlString>*>(m_ptr, "VPhysXAggregateData_t", "m_boneNames"); std::vector<CUtlString> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GVPhysXAggregateData_t::SetBoneNames(std::vector<CUtlString> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: VPhysXAggregateData_t->BoneNames(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<CUtlString>(m_ptr, "VPhysXAggregateData_t", "m_boneNames", true, value);
}
std::vector<uint16> GVPhysXAggregateData_t::GetIndexNames() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: VPhysXAggregateData_t->IndexNames(ptr=%p)", m_ptr));
    CUtlVector<uint16>* vec = GetSchemaValue<CUtlVector<uint16>*>(m_ptr, "VPhysXAggregateData_t", "m_indexNames"); std::vector<uint16> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GVPhysXAggregateData_t::SetIndexNames(std::vector<uint16> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: VPhysXAggregateData_t->IndexNames(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<uint16>(m_ptr, "VPhysXAggregateData_t", "m_indexNames", true, value);
}
std::vector<uint16> GVPhysXAggregateData_t::GetIndexHash() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: VPhysXAggregateData_t->IndexHash(ptr=%p)", m_ptr));
    CUtlVector<uint16>* vec = GetSchemaValue<CUtlVector<uint16>*>(m_ptr, "VPhysXAggregateData_t", "m_indexHash"); std::vector<uint16> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GVPhysXAggregateData_t::SetIndexHash(std::vector<uint16> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: VPhysXAggregateData_t->IndexHash(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<uint16>(m_ptr, "VPhysXAggregateData_t", "m_indexHash", true, value);
}
std::vector<GVPhysXBodyPart_t> GVPhysXAggregateData_t::GetParts() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: VPhysXAggregateData_t->Parts(ptr=%p)", m_ptr));
    CUtlVector<GVPhysXBodyPart_t>* vec = GetSchemaValue<CUtlVector<GVPhysXBodyPart_t>*>(m_ptr, "VPhysXAggregateData_t", "m_parts"); std::vector<GVPhysXBodyPart_t> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GVPhysXAggregateData_t::SetParts(std::vector<GVPhysXBodyPart_t> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: VPhysXAggregateData_t->Parts(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<GVPhysXBodyPart_t>(m_ptr, "VPhysXAggregateData_t", "m_parts", true, value);
}
std::vector<GVPhysXConstraint2_t> GVPhysXAggregateData_t::GetConstraints2() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: VPhysXAggregateData_t->Constraints2(ptr=%p)", m_ptr));
    CUtlVector<GVPhysXConstraint2_t>* vec = GetSchemaValue<CUtlVector<GVPhysXConstraint2_t>*>(m_ptr, "VPhysXAggregateData_t", "m_constraints2"); std::vector<GVPhysXConstraint2_t> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GVPhysXAggregateData_t::SetConstraints2(std::vector<GVPhysXConstraint2_t> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: VPhysXAggregateData_t->Constraints2(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<GVPhysXConstraint2_t>(m_ptr, "VPhysXAggregateData_t", "m_constraints2", true, value);
}
std::vector<GVPhysXJoint_t> GVPhysXAggregateData_t::GetJoints() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: VPhysXAggregateData_t->Joints(ptr=%p)", m_ptr));
    CUtlVector<GVPhysXJoint_t>* vec = GetSchemaValue<CUtlVector<GVPhysXJoint_t>*>(m_ptr, "VPhysXAggregateData_t", "m_joints"); std::vector<GVPhysXJoint_t> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GVPhysXAggregateData_t::SetJoints(std::vector<GVPhysXJoint_t> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: VPhysXAggregateData_t->Joints(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<GVPhysXJoint_t>(m_ptr, "VPhysXAggregateData_t", "m_joints", true, value);
}
GPhysFeModelDesc_t GVPhysXAggregateData_t::GetFeModel() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: VPhysXAggregateData_t->FeModel(ptr=%p)", m_ptr));
    GPhysFeModelDesc_t value(*(void**)GetSchemaPtr(m_ptr, "VPhysXAggregateData_t", "m_pFeModel"));
    return value;
}
void GVPhysXAggregateData_t::SetFeModel(GPhysFeModelDesc_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: VPhysXAggregateData_t->FeModel(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "VPhysXAggregateData_t","m_pFeModel", true, (char*)value.GetPtr());
}
std::vector<uint16> GVPhysXAggregateData_t::GetBoneParents() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: VPhysXAggregateData_t->BoneParents(ptr=%p)", m_ptr));
    CUtlVector<uint16>* vec = GetSchemaValue<CUtlVector<uint16>*>(m_ptr, "VPhysXAggregateData_t", "m_boneParents"); std::vector<uint16> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GVPhysXAggregateData_t::SetBoneParents(std::vector<uint16> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: VPhysXAggregateData_t->BoneParents(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<uint16>(m_ptr, "VPhysXAggregateData_t", "m_boneParents", true, value);
}
std::vector<uint32> GVPhysXAggregateData_t::GetSurfacePropertyHashes() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: VPhysXAggregateData_t->SurfacePropertyHashes(ptr=%p)", m_ptr));
    CUtlVector<uint32>* vec = GetSchemaValue<CUtlVector<uint32>*>(m_ptr, "VPhysXAggregateData_t", "m_surfacePropertyHashes"); std::vector<uint32> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GVPhysXAggregateData_t::SetSurfacePropertyHashes(std::vector<uint32> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: VPhysXAggregateData_t->SurfacePropertyHashes(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<uint32>(m_ptr, "VPhysXAggregateData_t", "m_surfacePropertyHashes", true, value);
}
std::vector<GVPhysXCollisionAttributes_t> GVPhysXAggregateData_t::GetCollisionAttributes() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: VPhysXAggregateData_t->CollisionAttributes(ptr=%p)", m_ptr));
    CUtlVector<GVPhysXCollisionAttributes_t>* vec = GetSchemaValue<CUtlVector<GVPhysXCollisionAttributes_t>*>(m_ptr, "VPhysXAggregateData_t", "m_collisionAttributes"); std::vector<GVPhysXCollisionAttributes_t> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GVPhysXAggregateData_t::SetCollisionAttributes(std::vector<GVPhysXCollisionAttributes_t> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: VPhysXAggregateData_t->CollisionAttributes(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<GVPhysXCollisionAttributes_t>(m_ptr, "VPhysXAggregateData_t", "m_collisionAttributes", true, value);
}
std::vector<CUtlString> GVPhysXAggregateData_t::GetDebugPartNames() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: VPhysXAggregateData_t->DebugPartNames(ptr=%p)", m_ptr));
    CUtlVector<CUtlString>* vec = GetSchemaValue<CUtlVector<CUtlString>*>(m_ptr, "VPhysXAggregateData_t", "m_debugPartNames"); std::vector<CUtlString> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GVPhysXAggregateData_t::SetDebugPartNames(std::vector<CUtlString> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: VPhysXAggregateData_t->DebugPartNames(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<CUtlString>(m_ptr, "VPhysXAggregateData_t", "m_debugPartNames", true, value);
}
std::string GVPhysXAggregateData_t::GetEmbeddedKeyvalues() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: VPhysXAggregateData_t->EmbeddedKeyvalues(ptr=%p)", m_ptr));
    return GetSchemaValue<CUtlString>(m_ptr, "VPhysXAggregateData_t", "m_embeddedKeyvalues").Get();
}
void GVPhysXAggregateData_t::SetEmbeddedKeyvalues(std::string value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: VPhysXAggregateData_t->EmbeddedKeyvalues(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "VPhysXAggregateData_t", "m_embeddedKeyvalues", true, CUtlString(value.c_str()));
}
void* GVPhysXAggregateData_t::GetPtr() {
    return m_ptr;
}
std::string GVPhysXAggregateData_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GVPhysXAggregateData_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassVPhysXAggregateData_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GVPhysXAggregateData_t>("VPhysXAggregateData_t")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Flags", &GVPhysXAggregateData_t::GetFlags, &GVPhysXAggregateData_t::SetFlags)
        .addProperty("RefCounter", &GVPhysXAggregateData_t::GetRefCounter, &GVPhysXAggregateData_t::SetRefCounter)
        .addProperty("BonesHash", &GVPhysXAggregateData_t::GetBonesHash, &GVPhysXAggregateData_t::SetBonesHash)
        .addProperty("BoneNames", &GVPhysXAggregateData_t::GetBoneNames, &GVPhysXAggregateData_t::SetBoneNames)
        .addProperty("IndexNames", &GVPhysXAggregateData_t::GetIndexNames, &GVPhysXAggregateData_t::SetIndexNames)
        .addProperty("IndexHash", &GVPhysXAggregateData_t::GetIndexHash, &GVPhysXAggregateData_t::SetIndexHash)
        .addProperty("Parts", &GVPhysXAggregateData_t::GetParts, &GVPhysXAggregateData_t::SetParts)
        .addProperty("Constraints2", &GVPhysXAggregateData_t::GetConstraints2, &GVPhysXAggregateData_t::SetConstraints2)
        .addProperty("Joints", &GVPhysXAggregateData_t::GetJoints, &GVPhysXAggregateData_t::SetJoints)
        .addProperty("FeModel", &GVPhysXAggregateData_t::GetFeModel, &GVPhysXAggregateData_t::SetFeModel)
        .addProperty("BoneParents", &GVPhysXAggregateData_t::GetBoneParents, &GVPhysXAggregateData_t::SetBoneParents)
        .addProperty("SurfacePropertyHashes", &GVPhysXAggregateData_t::GetSurfacePropertyHashes, &GVPhysXAggregateData_t::SetSurfacePropertyHashes)
        .addProperty("CollisionAttributes", &GVPhysXAggregateData_t::GetCollisionAttributes, &GVPhysXAggregateData_t::SetCollisionAttributes)
        .addProperty("DebugPartNames", &GVPhysXAggregateData_t::GetDebugPartNames, &GVPhysXAggregateData_t::SetDebugPartNames)
        .addProperty("EmbeddedKeyvalues", &GVPhysXAggregateData_t::GetEmbeddedKeyvalues, &GVPhysXAggregateData_t::SetEmbeddedKeyvalues)
        .addFunction("ToPtr", &GVPhysXAggregateData_t::ToPtr)
        .addFunction("IsValid", &GVPhysXAggregateData_t::IsValid)
        .endClass();
}
GCSequenceUpdateNode::GCSequenceUpdateNode(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCSequenceUpdateNode::GCSequenceUpdateNode(void *ptr) {
    m_ptr = ptr;
}
GCParamSpanUpdater GCSequenceUpdateNode::GetParamSpans() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CSequenceUpdateNode->ParamSpans(ptr=%p)", m_ptr));
    GCParamSpanUpdater value(GetSchemaPtr(m_ptr, "CSequenceUpdateNode", "m_paramSpans"));
    return value;
}
void GCSequenceUpdateNode::SetParamSpans(GCParamSpanUpdater value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CSequenceUpdateNode->ParamSpans(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'ParamSpans' is not possible.\n");
}
std::vector<GTagSpan_t> GCSequenceUpdateNode::GetTags() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CSequenceUpdateNode->Tags(ptr=%p)", m_ptr));
    CUtlVector<GTagSpan_t>* vec = GetSchemaValue<CUtlVector<GTagSpan_t>*>(m_ptr, "CSequenceUpdateNode", "m_tags"); std::vector<GTagSpan_t> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCSequenceUpdateNode::SetTags(std::vector<GTagSpan_t> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CSequenceUpdateNode->Tags(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<GTagSpan_t>(m_ptr, "CSequenceUpdateNode", "m_tags", false, value);
}
float GCSequenceUpdateNode::GetPlaybackSpeed() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CSequenceUpdateNode->PlaybackSpeed(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CSequenceUpdateNode", "m_playbackSpeed");
}
void GCSequenceUpdateNode::SetPlaybackSpeed(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CSequenceUpdateNode->PlaybackSpeed(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CSequenceUpdateNode", "m_playbackSpeed", false, value);
}
float GCSequenceUpdateNode::GetDuration() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CSequenceUpdateNode->Duration(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CSequenceUpdateNode", "m_duration");
}
void GCSequenceUpdateNode::SetDuration(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CSequenceUpdateNode->Duration(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CSequenceUpdateNode", "m_duration", false, value);
}
bool GCSequenceUpdateNode::GetLoop() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CSequenceUpdateNode->Loop(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "CSequenceUpdateNode", "m_bLoop");
}
void GCSequenceUpdateNode::SetLoop(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CSequenceUpdateNode->Loop(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CSequenceUpdateNode", "m_bLoop", false, value);
}
void* GCSequenceUpdateNode::GetPtr() {
    return m_ptr;
}
std::string GCSequenceUpdateNode::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCSequenceUpdateNode::IsValid() {
    return (m_ptr != nullptr);
}
GCLeafUpdateNode GCSequenceUpdateNode::GetParent() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CSequenceUpdateNode::GetParent(ptr=%p)", m_ptr));
    GCLeafUpdateNode value(m_ptr);
    return value;
}
void GCSequenceUpdateNode::SetParent(GCLeafUpdateNode value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CSequenceUpdateNode::SetParent(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCSequenceUpdateNode(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCSequenceUpdateNode>("CSequenceUpdateNode")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("ParamSpans", &GCSequenceUpdateNode::GetParamSpans, &GCSequenceUpdateNode::SetParamSpans)
        .addProperty("Tags", &GCSequenceUpdateNode::GetTags, &GCSequenceUpdateNode::SetTags)
        .addProperty("PlaybackSpeed", &GCSequenceUpdateNode::GetPlaybackSpeed, &GCSequenceUpdateNode::SetPlaybackSpeed)
        .addProperty("Duration", &GCSequenceUpdateNode::GetDuration, &GCSequenceUpdateNode::SetDuration)
        .addProperty("Loop", &GCSequenceUpdateNode::GetLoop, &GCSequenceUpdateNode::SetLoop)
        .addProperty("Parent", &GCSequenceUpdateNode::GetParent, &GCSequenceUpdateNode::SetParent)
        .addFunction("ToPtr", &GCSequenceUpdateNode::ToPtr)
        .addFunction("IsValid", &GCSequenceUpdateNode::IsValid)
        .endClass();
}
GCModelConfigElement_Command::GCModelConfigElement_Command(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCModelConfigElement_Command::GCModelConfigElement_Command(void *ptr) {
    m_ptr = ptr;
}
std::string GCModelConfigElement_Command::GetCommand() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CModelConfigElement_Command->Command(ptr=%p)", m_ptr));
    return GetSchemaValue<CUtlString>(m_ptr, "CModelConfigElement_Command", "m_Command").Get();
}
void GCModelConfigElement_Command::SetCommand(std::string value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CModelConfigElement_Command->Command(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CModelConfigElement_Command", "m_Command", false, CUtlString(value.c_str()));
}
void* GCModelConfigElement_Command::GetPtr() {
    return m_ptr;
}
std::string GCModelConfigElement_Command::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCModelConfigElement_Command::IsValid() {
    return (m_ptr != nullptr);
}
GCModelConfigElement GCModelConfigElement_Command::GetParent() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CModelConfigElement_Command::GetParent(ptr=%p)", m_ptr));
    GCModelConfigElement value(m_ptr);
    return value;
}
void GCModelConfigElement_Command::SetParent(GCModelConfigElement value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CModelConfigElement_Command::SetParent(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCModelConfigElement_Command(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCModelConfigElement_Command>("CModelConfigElement_Command")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Command", &GCModelConfigElement_Command::GetCommand, &GCModelConfigElement_Command::SetCommand)
        .addProperty("Parent", &GCModelConfigElement_Command::GetParent, &GCModelConfigElement_Command::SetParent)
        .addFunction("ToPtr", &GCModelConfigElement_Command::ToPtr)
        .addFunction("IsValid", &GCModelConfigElement_Command::IsValid)
        .endClass();
}
GCAnimParameterBase::GCAnimParameterBase(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCAnimParameterBase::GCAnimParameterBase(void *ptr) {
    m_ptr = ptr;
}
std::string GCAnimParameterBase::GetComment() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CAnimParameterBase->Comment(ptr=%p)", m_ptr));
    return GetSchemaValue<CUtlString>(m_ptr, "CAnimParameterBase", "m_sComment").Get();
}
void GCAnimParameterBase::SetComment(std::string value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CAnimParameterBase->Comment(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CAnimParameterBase", "m_sComment", false, CUtlString(value.c_str()));
}
std::string GCAnimParameterBase::GetGroup() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CAnimParameterBase->Group(ptr=%p)", m_ptr));
    return GetSchemaValue<CUtlString>(m_ptr, "CAnimParameterBase", "m_group").Get();
}
void GCAnimParameterBase::SetGroup(std::string value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CAnimParameterBase->Group(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CAnimParameterBase", "m_group", false, CUtlString(value.c_str()));
}
GAnimParamID GCAnimParameterBase::GetId() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CAnimParameterBase->Id(ptr=%p)", m_ptr));
    GAnimParamID value(GetSchemaPtr(m_ptr, "CAnimParameterBase", "m_id"));
    return value;
}
void GCAnimParameterBase::SetId(GAnimParamID value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CAnimParameterBase->Id(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Id' is not possible.\n");
}
std::string GCAnimParameterBase::GetComponentName() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CAnimParameterBase->ComponentName(ptr=%p)", m_ptr));
    return GetSchemaValue<CUtlString>(m_ptr, "CAnimParameterBase", "m_componentName").Get();
}
void GCAnimParameterBase::SetComponentName(std::string value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CAnimParameterBase->ComponentName(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CAnimParameterBase", "m_componentName", false, CUtlString(value.c_str()));
}
bool GCAnimParameterBase::GetNetworkingRequested() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CAnimParameterBase->NetworkingRequested(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "CAnimParameterBase", "m_bNetworkingRequested");
}
void GCAnimParameterBase::SetNetworkingRequested(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CAnimParameterBase->NetworkingRequested(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CAnimParameterBase", "m_bNetworkingRequested", false, value);
}
bool GCAnimParameterBase::GetIsReferenced() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CAnimParameterBase->IsReferenced(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "CAnimParameterBase", "m_bIsReferenced");
}
void GCAnimParameterBase::SetIsReferenced(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CAnimParameterBase->IsReferenced(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CAnimParameterBase", "m_bIsReferenced", false, value);
}
void* GCAnimParameterBase::GetPtr() {
    return m_ptr;
}
std::string GCAnimParameterBase::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCAnimParameterBase::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCAnimParameterBase(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCAnimParameterBase>("CAnimParameterBase")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Comment", &GCAnimParameterBase::GetComment, &GCAnimParameterBase::SetComment)
        .addProperty("Group", &GCAnimParameterBase::GetGroup, &GCAnimParameterBase::SetGroup)
        .addProperty("Id", &GCAnimParameterBase::GetId, &GCAnimParameterBase::SetId)
        .addProperty("ComponentName", &GCAnimParameterBase::GetComponentName, &GCAnimParameterBase::SetComponentName)
        .addProperty("NetworkingRequested", &GCAnimParameterBase::GetNetworkingRequested, &GCAnimParameterBase::SetNetworkingRequested)
        .addProperty("IsReferenced", &GCAnimParameterBase::GetIsReferenced, &GCAnimParameterBase::SetIsReferenced)
        .addFunction("ToPtr", &GCAnimParameterBase::ToPtr)
        .addFunction("IsValid", &GCAnimParameterBase::IsValid)
        .endClass();
}
GCompositeMaterialInputLooseVariable_t::GCompositeMaterialInputLooseVariable_t(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCompositeMaterialInputLooseVariable_t::GCompositeMaterialInputLooseVariable_t(void *ptr) {
    m_ptr = ptr;
}
std::string GCompositeMaterialInputLooseVariable_t::GetStrName() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CompositeMaterialInputLooseVariable_t->StrName(ptr=%p)", m_ptr));
    return GetSchemaValue<CUtlString>(m_ptr, "CompositeMaterialInputLooseVariable_t", "m_strName").Get();
}
void GCompositeMaterialInputLooseVariable_t::SetStrName(std::string value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CompositeMaterialInputLooseVariable_t->StrName(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CompositeMaterialInputLooseVariable_t", "m_strName", true, CUtlString(value.c_str()));
}
bool GCompositeMaterialInputLooseVariable_t::GetExposeExternally() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CompositeMaterialInputLooseVariable_t->ExposeExternally(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "CompositeMaterialInputLooseVariable_t", "m_bExposeExternally");
}
void GCompositeMaterialInputLooseVariable_t::SetExposeExternally(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CompositeMaterialInputLooseVariable_t->ExposeExternally(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CompositeMaterialInputLooseVariable_t", "m_bExposeExternally", true, value);
}
std::string GCompositeMaterialInputLooseVariable_t::GetStrExposedFriendlyName() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CompositeMaterialInputLooseVariable_t->StrExposedFriendlyName(ptr=%p)", m_ptr));
    return GetSchemaValue<CUtlString>(m_ptr, "CompositeMaterialInputLooseVariable_t", "m_strExposedFriendlyName").Get();
}
void GCompositeMaterialInputLooseVariable_t::SetStrExposedFriendlyName(std::string value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CompositeMaterialInputLooseVariable_t->StrExposedFriendlyName(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CompositeMaterialInputLooseVariable_t", "m_strExposedFriendlyName", true, CUtlString(value.c_str()));
}
std::string GCompositeMaterialInputLooseVariable_t::GetStrExposedFriendlyGroupName() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CompositeMaterialInputLooseVariable_t->StrExposedFriendlyGroupName(ptr=%p)", m_ptr));
    return GetSchemaValue<CUtlString>(m_ptr, "CompositeMaterialInputLooseVariable_t", "m_strExposedFriendlyGroupName").Get();
}
void GCompositeMaterialInputLooseVariable_t::SetStrExposedFriendlyGroupName(std::string value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CompositeMaterialInputLooseVariable_t->StrExposedFriendlyGroupName(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CompositeMaterialInputLooseVariable_t", "m_strExposedFriendlyGroupName", true, CUtlString(value.c_str()));
}
bool GCompositeMaterialInputLooseVariable_t::GetExposedVariableIsFixedRange() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CompositeMaterialInputLooseVariable_t->ExposedVariableIsFixedRange(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "CompositeMaterialInputLooseVariable_t", "m_bExposedVariableIsFixedRange");
}
void GCompositeMaterialInputLooseVariable_t::SetExposedVariableIsFixedRange(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CompositeMaterialInputLooseVariable_t->ExposedVariableIsFixedRange(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CompositeMaterialInputLooseVariable_t", "m_bExposedVariableIsFixedRange", true, value);
}
std::string GCompositeMaterialInputLooseVariable_t::GetStrExposedVisibleWhenTrue() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CompositeMaterialInputLooseVariable_t->StrExposedVisibleWhenTrue(ptr=%p)", m_ptr));
    return GetSchemaValue<CUtlString>(m_ptr, "CompositeMaterialInputLooseVariable_t", "m_strExposedVisibleWhenTrue").Get();
}
void GCompositeMaterialInputLooseVariable_t::SetStrExposedVisibleWhenTrue(std::string value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CompositeMaterialInputLooseVariable_t->StrExposedVisibleWhenTrue(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CompositeMaterialInputLooseVariable_t", "m_strExposedVisibleWhenTrue", true, CUtlString(value.c_str()));
}
std::string GCompositeMaterialInputLooseVariable_t::GetStrExposedHiddenWhenTrue() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CompositeMaterialInputLooseVariable_t->StrExposedHiddenWhenTrue(ptr=%p)", m_ptr));
    return GetSchemaValue<CUtlString>(m_ptr, "CompositeMaterialInputLooseVariable_t", "m_strExposedHiddenWhenTrue").Get();
}
void GCompositeMaterialInputLooseVariable_t::SetStrExposedHiddenWhenTrue(std::string value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CompositeMaterialInputLooseVariable_t->StrExposedHiddenWhenTrue(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CompositeMaterialInputLooseVariable_t", "m_strExposedHiddenWhenTrue", true, CUtlString(value.c_str()));
}
uint64_t GCompositeMaterialInputLooseVariable_t::GetVariableType() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CompositeMaterialInputLooseVariable_t->VariableType(ptr=%p)", m_ptr));
    return GetSchemaValue<uint64_t>(m_ptr, "CompositeMaterialInputLooseVariable_t", "m_nVariableType");
}
void GCompositeMaterialInputLooseVariable_t::SetVariableType(uint64_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CompositeMaterialInputLooseVariable_t->VariableType(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CompositeMaterialInputLooseVariable_t", "m_nVariableType", true, value);
}
bool GCompositeMaterialInputLooseVariable_t::GetValueBoolean() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CompositeMaterialInputLooseVariable_t->ValueBoolean(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "CompositeMaterialInputLooseVariable_t", "m_bValueBoolean");
}
void GCompositeMaterialInputLooseVariable_t::SetValueBoolean(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CompositeMaterialInputLooseVariable_t->ValueBoolean(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CompositeMaterialInputLooseVariable_t", "m_bValueBoolean", true, value);
}
int32_t GCompositeMaterialInputLooseVariable_t::GetValueIntX() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CompositeMaterialInputLooseVariable_t->ValueIntX(ptr=%p)", m_ptr));
    return GetSchemaValue<int32_t>(m_ptr, "CompositeMaterialInputLooseVariable_t", "m_nValueIntX");
}
void GCompositeMaterialInputLooseVariable_t::SetValueIntX(int32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CompositeMaterialInputLooseVariable_t->ValueIntX(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CompositeMaterialInputLooseVariable_t", "m_nValueIntX", true, value);
}
int32_t GCompositeMaterialInputLooseVariable_t::GetValueIntY() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CompositeMaterialInputLooseVariable_t->ValueIntY(ptr=%p)", m_ptr));
    return GetSchemaValue<int32_t>(m_ptr, "CompositeMaterialInputLooseVariable_t", "m_nValueIntY");
}
void GCompositeMaterialInputLooseVariable_t::SetValueIntY(int32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CompositeMaterialInputLooseVariable_t->ValueIntY(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CompositeMaterialInputLooseVariable_t", "m_nValueIntY", true, value);
}
int32_t GCompositeMaterialInputLooseVariable_t::GetValueIntZ() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CompositeMaterialInputLooseVariable_t->ValueIntZ(ptr=%p)", m_ptr));
    return GetSchemaValue<int32_t>(m_ptr, "CompositeMaterialInputLooseVariable_t", "m_nValueIntZ");
}
void GCompositeMaterialInputLooseVariable_t::SetValueIntZ(int32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CompositeMaterialInputLooseVariable_t->ValueIntZ(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CompositeMaterialInputLooseVariable_t", "m_nValueIntZ", true, value);
}
int32_t GCompositeMaterialInputLooseVariable_t::GetValueIntW() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CompositeMaterialInputLooseVariable_t->ValueIntW(ptr=%p)", m_ptr));
    return GetSchemaValue<int32_t>(m_ptr, "CompositeMaterialInputLooseVariable_t", "m_nValueIntW");
}
void GCompositeMaterialInputLooseVariable_t::SetValueIntW(int32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CompositeMaterialInputLooseVariable_t->ValueIntW(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CompositeMaterialInputLooseVariable_t", "m_nValueIntW", true, value);
}
bool GCompositeMaterialInputLooseVariable_t::GetHasFloatBounds() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CompositeMaterialInputLooseVariable_t->HasFloatBounds(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "CompositeMaterialInputLooseVariable_t", "m_bHasFloatBounds");
}
void GCompositeMaterialInputLooseVariable_t::SetHasFloatBounds(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CompositeMaterialInputLooseVariable_t->HasFloatBounds(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CompositeMaterialInputLooseVariable_t", "m_bHasFloatBounds", true, value);
}
float GCompositeMaterialInputLooseVariable_t::GetValueFloatX() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CompositeMaterialInputLooseVariable_t->ValueFloatX(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CompositeMaterialInputLooseVariable_t", "m_flValueFloatX");
}
void GCompositeMaterialInputLooseVariable_t::SetValueFloatX(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CompositeMaterialInputLooseVariable_t->ValueFloatX(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CompositeMaterialInputLooseVariable_t", "m_flValueFloatX", true, value);
}
float GCompositeMaterialInputLooseVariable_t::GetValueFloatX_Min() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CompositeMaterialInputLooseVariable_t->ValueFloatX_Min(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CompositeMaterialInputLooseVariable_t", "m_flValueFloatX_Min");
}
void GCompositeMaterialInputLooseVariable_t::SetValueFloatX_Min(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CompositeMaterialInputLooseVariable_t->ValueFloatX_Min(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CompositeMaterialInputLooseVariable_t", "m_flValueFloatX_Min", true, value);
}
float GCompositeMaterialInputLooseVariable_t::GetValueFloatX_Max() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CompositeMaterialInputLooseVariable_t->ValueFloatX_Max(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CompositeMaterialInputLooseVariable_t", "m_flValueFloatX_Max");
}
void GCompositeMaterialInputLooseVariable_t::SetValueFloatX_Max(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CompositeMaterialInputLooseVariable_t->ValueFloatX_Max(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CompositeMaterialInputLooseVariable_t", "m_flValueFloatX_Max", true, value);
}
float GCompositeMaterialInputLooseVariable_t::GetValueFloatY() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CompositeMaterialInputLooseVariable_t->ValueFloatY(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CompositeMaterialInputLooseVariable_t", "m_flValueFloatY");
}
void GCompositeMaterialInputLooseVariable_t::SetValueFloatY(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CompositeMaterialInputLooseVariable_t->ValueFloatY(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CompositeMaterialInputLooseVariable_t", "m_flValueFloatY", true, value);
}
float GCompositeMaterialInputLooseVariable_t::GetValueFloatY_Min() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CompositeMaterialInputLooseVariable_t->ValueFloatY_Min(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CompositeMaterialInputLooseVariable_t", "m_flValueFloatY_Min");
}
void GCompositeMaterialInputLooseVariable_t::SetValueFloatY_Min(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CompositeMaterialInputLooseVariable_t->ValueFloatY_Min(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CompositeMaterialInputLooseVariable_t", "m_flValueFloatY_Min", true, value);
}
float GCompositeMaterialInputLooseVariable_t::GetValueFloatY_Max() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CompositeMaterialInputLooseVariable_t->ValueFloatY_Max(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CompositeMaterialInputLooseVariable_t", "m_flValueFloatY_Max");
}
void GCompositeMaterialInputLooseVariable_t::SetValueFloatY_Max(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CompositeMaterialInputLooseVariable_t->ValueFloatY_Max(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CompositeMaterialInputLooseVariable_t", "m_flValueFloatY_Max", true, value);
}
float GCompositeMaterialInputLooseVariable_t::GetValueFloatZ() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CompositeMaterialInputLooseVariable_t->ValueFloatZ(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CompositeMaterialInputLooseVariable_t", "m_flValueFloatZ");
}
void GCompositeMaterialInputLooseVariable_t::SetValueFloatZ(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CompositeMaterialInputLooseVariable_t->ValueFloatZ(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CompositeMaterialInputLooseVariable_t", "m_flValueFloatZ", true, value);
}
float GCompositeMaterialInputLooseVariable_t::GetValueFloatZ_Min() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CompositeMaterialInputLooseVariable_t->ValueFloatZ_Min(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CompositeMaterialInputLooseVariable_t", "m_flValueFloatZ_Min");
}
void GCompositeMaterialInputLooseVariable_t::SetValueFloatZ_Min(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CompositeMaterialInputLooseVariable_t->ValueFloatZ_Min(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CompositeMaterialInputLooseVariable_t", "m_flValueFloatZ_Min", true, value);
}
float GCompositeMaterialInputLooseVariable_t::GetValueFloatZ_Max() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CompositeMaterialInputLooseVariable_t->ValueFloatZ_Max(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CompositeMaterialInputLooseVariable_t", "m_flValueFloatZ_Max");
}
void GCompositeMaterialInputLooseVariable_t::SetValueFloatZ_Max(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CompositeMaterialInputLooseVariable_t->ValueFloatZ_Max(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CompositeMaterialInputLooseVariable_t", "m_flValueFloatZ_Max", true, value);
}
float GCompositeMaterialInputLooseVariable_t::GetValueFloatW() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CompositeMaterialInputLooseVariable_t->ValueFloatW(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CompositeMaterialInputLooseVariable_t", "m_flValueFloatW");
}
void GCompositeMaterialInputLooseVariable_t::SetValueFloatW(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CompositeMaterialInputLooseVariable_t->ValueFloatW(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CompositeMaterialInputLooseVariable_t", "m_flValueFloatW", true, value);
}
float GCompositeMaterialInputLooseVariable_t::GetValueFloatW_Min() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CompositeMaterialInputLooseVariable_t->ValueFloatW_Min(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CompositeMaterialInputLooseVariable_t", "m_flValueFloatW_Min");
}
void GCompositeMaterialInputLooseVariable_t::SetValueFloatW_Min(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CompositeMaterialInputLooseVariable_t->ValueFloatW_Min(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CompositeMaterialInputLooseVariable_t", "m_flValueFloatW_Min", true, value);
}
float GCompositeMaterialInputLooseVariable_t::GetValueFloatW_Max() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CompositeMaterialInputLooseVariable_t->ValueFloatW_Max(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CompositeMaterialInputLooseVariable_t", "m_flValueFloatW_Max");
}
void GCompositeMaterialInputLooseVariable_t::SetValueFloatW_Max(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CompositeMaterialInputLooseVariable_t->ValueFloatW_Max(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CompositeMaterialInputLooseVariable_t", "m_flValueFloatW_Max", true, value);
}
Color GCompositeMaterialInputLooseVariable_t::GetCValueColor4() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CompositeMaterialInputLooseVariable_t->CValueColor4(ptr=%p)", m_ptr));
    return GetSchemaValue<Color>(m_ptr, "CompositeMaterialInputLooseVariable_t", "m_cValueColor4");
}
void GCompositeMaterialInputLooseVariable_t::SetCValueColor4(Color value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CompositeMaterialInputLooseVariable_t->CValueColor4(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CompositeMaterialInputLooseVariable_t", "m_cValueColor4", true, value);
}
uint64_t GCompositeMaterialInputLooseVariable_t::GetValueSystemVar() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CompositeMaterialInputLooseVariable_t->ValueSystemVar(ptr=%p)", m_ptr));
    return GetSchemaValue<uint64_t>(m_ptr, "CompositeMaterialInputLooseVariable_t", "m_nValueSystemVar");
}
void GCompositeMaterialInputLooseVariable_t::SetValueSystemVar(uint64_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CompositeMaterialInputLooseVariable_t->ValueSystemVar(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CompositeMaterialInputLooseVariable_t", "m_nValueSystemVar", true, value);
}
std::string GCompositeMaterialInputLooseVariable_t::GetStrTextureContentAssetPath() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CompositeMaterialInputLooseVariable_t->StrTextureContentAssetPath(ptr=%p)", m_ptr));
    return GetSchemaValue<CUtlString>(m_ptr, "CompositeMaterialInputLooseVariable_t", "m_strTextureContentAssetPath").Get();
}
void GCompositeMaterialInputLooseVariable_t::SetStrTextureContentAssetPath(std::string value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CompositeMaterialInputLooseVariable_t->StrTextureContentAssetPath(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CompositeMaterialInputLooseVariable_t", "m_strTextureContentAssetPath", true, CUtlString(value.c_str()));
}
std::string GCompositeMaterialInputLooseVariable_t::GetStrTextureCompilationVtexTemplate() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CompositeMaterialInputLooseVariable_t->StrTextureCompilationVtexTemplate(ptr=%p)", m_ptr));
    return GetSchemaValue<CUtlString>(m_ptr, "CompositeMaterialInputLooseVariable_t", "m_strTextureCompilationVtexTemplate").Get();
}
void GCompositeMaterialInputLooseVariable_t::SetStrTextureCompilationVtexTemplate(std::string value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CompositeMaterialInputLooseVariable_t->StrTextureCompilationVtexTemplate(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CompositeMaterialInputLooseVariable_t", "m_strTextureCompilationVtexTemplate", true, CUtlString(value.c_str()));
}
uint64_t GCompositeMaterialInputLooseVariable_t::GetTextureType() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CompositeMaterialInputLooseVariable_t->TextureType(ptr=%p)", m_ptr));
    return GetSchemaValue<uint64_t>(m_ptr, "CompositeMaterialInputLooseVariable_t", "m_nTextureType");
}
void GCompositeMaterialInputLooseVariable_t::SetTextureType(uint64_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CompositeMaterialInputLooseVariable_t->TextureType(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CompositeMaterialInputLooseVariable_t", "m_nTextureType", true, value);
}
std::string GCompositeMaterialInputLooseVariable_t::GetStrString() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CompositeMaterialInputLooseVariable_t->StrString(ptr=%p)", m_ptr));
    return GetSchemaValue<CUtlString>(m_ptr, "CompositeMaterialInputLooseVariable_t", "m_strString").Get();
}
void GCompositeMaterialInputLooseVariable_t::SetStrString(std::string value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CompositeMaterialInputLooseVariable_t->StrString(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CompositeMaterialInputLooseVariable_t", "m_strString", true, CUtlString(value.c_str()));
}
std::string GCompositeMaterialInputLooseVariable_t::GetStrPanoramaPanelPath() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CompositeMaterialInputLooseVariable_t->StrPanoramaPanelPath(ptr=%p)", m_ptr));
    return GetSchemaValue<CUtlString>(m_ptr, "CompositeMaterialInputLooseVariable_t", "m_strPanoramaPanelPath").Get();
}
void GCompositeMaterialInputLooseVariable_t::SetStrPanoramaPanelPath(std::string value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CompositeMaterialInputLooseVariable_t->StrPanoramaPanelPath(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CompositeMaterialInputLooseVariable_t", "m_strPanoramaPanelPath", true, CUtlString(value.c_str()));
}
int32_t GCompositeMaterialInputLooseVariable_t::GetPanoramaRenderRes() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CompositeMaterialInputLooseVariable_t->PanoramaRenderRes(ptr=%p)", m_ptr));
    return GetSchemaValue<int32_t>(m_ptr, "CompositeMaterialInputLooseVariable_t", "m_nPanoramaRenderRes");
}
void GCompositeMaterialInputLooseVariable_t::SetPanoramaRenderRes(int32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CompositeMaterialInputLooseVariable_t->PanoramaRenderRes(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CompositeMaterialInputLooseVariable_t", "m_nPanoramaRenderRes", true, value);
}
void* GCompositeMaterialInputLooseVariable_t::GetPtr() {
    return m_ptr;
}
std::string GCompositeMaterialInputLooseVariable_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCompositeMaterialInputLooseVariable_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCompositeMaterialInputLooseVariable_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCompositeMaterialInputLooseVariable_t>("CompositeMaterialInputLooseVariable_t")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("StrName", &GCompositeMaterialInputLooseVariable_t::GetStrName, &GCompositeMaterialInputLooseVariable_t::SetStrName)
        .addProperty("ExposeExternally", &GCompositeMaterialInputLooseVariable_t::GetExposeExternally, &GCompositeMaterialInputLooseVariable_t::SetExposeExternally)
        .addProperty("StrExposedFriendlyName", &GCompositeMaterialInputLooseVariable_t::GetStrExposedFriendlyName, &GCompositeMaterialInputLooseVariable_t::SetStrExposedFriendlyName)
        .addProperty("StrExposedFriendlyGroupName", &GCompositeMaterialInputLooseVariable_t::GetStrExposedFriendlyGroupName, &GCompositeMaterialInputLooseVariable_t::SetStrExposedFriendlyGroupName)
        .addProperty("ExposedVariableIsFixedRange", &GCompositeMaterialInputLooseVariable_t::GetExposedVariableIsFixedRange, &GCompositeMaterialInputLooseVariable_t::SetExposedVariableIsFixedRange)
        .addProperty("StrExposedVisibleWhenTrue", &GCompositeMaterialInputLooseVariable_t::GetStrExposedVisibleWhenTrue, &GCompositeMaterialInputLooseVariable_t::SetStrExposedVisibleWhenTrue)
        .addProperty("StrExposedHiddenWhenTrue", &GCompositeMaterialInputLooseVariable_t::GetStrExposedHiddenWhenTrue, &GCompositeMaterialInputLooseVariable_t::SetStrExposedHiddenWhenTrue)
        .addProperty("VariableType", &GCompositeMaterialInputLooseVariable_t::GetVariableType, &GCompositeMaterialInputLooseVariable_t::SetVariableType)
        .addProperty("ValueBoolean", &GCompositeMaterialInputLooseVariable_t::GetValueBoolean, &GCompositeMaterialInputLooseVariable_t::SetValueBoolean)
        .addProperty("ValueIntX", &GCompositeMaterialInputLooseVariable_t::GetValueIntX, &GCompositeMaterialInputLooseVariable_t::SetValueIntX)
        .addProperty("ValueIntY", &GCompositeMaterialInputLooseVariable_t::GetValueIntY, &GCompositeMaterialInputLooseVariable_t::SetValueIntY)
        .addProperty("ValueIntZ", &GCompositeMaterialInputLooseVariable_t::GetValueIntZ, &GCompositeMaterialInputLooseVariable_t::SetValueIntZ)
        .addProperty("ValueIntW", &GCompositeMaterialInputLooseVariable_t::GetValueIntW, &GCompositeMaterialInputLooseVariable_t::SetValueIntW)
        .addProperty("HasFloatBounds", &GCompositeMaterialInputLooseVariable_t::GetHasFloatBounds, &GCompositeMaterialInputLooseVariable_t::SetHasFloatBounds)
        .addProperty("ValueFloatX", &GCompositeMaterialInputLooseVariable_t::GetValueFloatX, &GCompositeMaterialInputLooseVariable_t::SetValueFloatX)
        .addProperty("ValueFloatX_Min", &GCompositeMaterialInputLooseVariable_t::GetValueFloatX_Min, &GCompositeMaterialInputLooseVariable_t::SetValueFloatX_Min)
        .addProperty("ValueFloatX_Max", &GCompositeMaterialInputLooseVariable_t::GetValueFloatX_Max, &GCompositeMaterialInputLooseVariable_t::SetValueFloatX_Max)
        .addProperty("ValueFloatY", &GCompositeMaterialInputLooseVariable_t::GetValueFloatY, &GCompositeMaterialInputLooseVariable_t::SetValueFloatY)
        .addProperty("ValueFloatY_Min", &GCompositeMaterialInputLooseVariable_t::GetValueFloatY_Min, &GCompositeMaterialInputLooseVariable_t::SetValueFloatY_Min)
        .addProperty("ValueFloatY_Max", &GCompositeMaterialInputLooseVariable_t::GetValueFloatY_Max, &GCompositeMaterialInputLooseVariable_t::SetValueFloatY_Max)
        .addProperty("ValueFloatZ", &GCompositeMaterialInputLooseVariable_t::GetValueFloatZ, &GCompositeMaterialInputLooseVariable_t::SetValueFloatZ)
        .addProperty("ValueFloatZ_Min", &GCompositeMaterialInputLooseVariable_t::GetValueFloatZ_Min, &GCompositeMaterialInputLooseVariable_t::SetValueFloatZ_Min)
        .addProperty("ValueFloatZ_Max", &GCompositeMaterialInputLooseVariable_t::GetValueFloatZ_Max, &GCompositeMaterialInputLooseVariable_t::SetValueFloatZ_Max)
        .addProperty("ValueFloatW", &GCompositeMaterialInputLooseVariable_t::GetValueFloatW, &GCompositeMaterialInputLooseVariable_t::SetValueFloatW)
        .addProperty("ValueFloatW_Min", &GCompositeMaterialInputLooseVariable_t::GetValueFloatW_Min, &GCompositeMaterialInputLooseVariable_t::SetValueFloatW_Min)
        .addProperty("ValueFloatW_Max", &GCompositeMaterialInputLooseVariable_t::GetValueFloatW_Max, &GCompositeMaterialInputLooseVariable_t::SetValueFloatW_Max)
        .addProperty("CValueColor4", &GCompositeMaterialInputLooseVariable_t::GetCValueColor4, &GCompositeMaterialInputLooseVariable_t::SetCValueColor4)
        .addProperty("ValueSystemVar", &GCompositeMaterialInputLooseVariable_t::GetValueSystemVar, &GCompositeMaterialInputLooseVariable_t::SetValueSystemVar)
        .addProperty("StrTextureContentAssetPath", &GCompositeMaterialInputLooseVariable_t::GetStrTextureContentAssetPath, &GCompositeMaterialInputLooseVariable_t::SetStrTextureContentAssetPath)
        .addProperty("StrTextureCompilationVtexTemplate", &GCompositeMaterialInputLooseVariable_t::GetStrTextureCompilationVtexTemplate, &GCompositeMaterialInputLooseVariable_t::SetStrTextureCompilationVtexTemplate)
        .addProperty("TextureType", &GCompositeMaterialInputLooseVariable_t::GetTextureType, &GCompositeMaterialInputLooseVariable_t::SetTextureType)
        .addProperty("StrString", &GCompositeMaterialInputLooseVariable_t::GetStrString, &GCompositeMaterialInputLooseVariable_t::SetStrString)
        .addProperty("StrPanoramaPanelPath", &GCompositeMaterialInputLooseVariable_t::GetStrPanoramaPanelPath, &GCompositeMaterialInputLooseVariable_t::SetStrPanoramaPanelPath)
        .addProperty("PanoramaRenderRes", &GCompositeMaterialInputLooseVariable_t::GetPanoramaRenderRes, &GCompositeMaterialInputLooseVariable_t::SetPanoramaRenderRes)
        .addFunction("ToPtr", &GCompositeMaterialInputLooseVariable_t::ToPtr)
        .addFunction("IsValid", &GCompositeMaterialInputLooseVariable_t::IsValid)
        .endClass();
}
GVecInputMaterialVariable_t::GVecInputMaterialVariable_t(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GVecInputMaterialVariable_t::GVecInputMaterialVariable_t(void *ptr) {
    m_ptr = ptr;
}
std::string GVecInputMaterialVariable_t::GetStrVariable() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: VecInputMaterialVariable_t->StrVariable(ptr=%p)", m_ptr));
    return GetSchemaValue<CUtlString>(m_ptr, "VecInputMaterialVariable_t", "m_strVariable").Get();
}
void GVecInputMaterialVariable_t::SetStrVariable(std::string value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: VecInputMaterialVariable_t->StrVariable(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "VecInputMaterialVariable_t", "m_strVariable", true, CUtlString(value.c_str()));
}
void* GVecInputMaterialVariable_t::GetPtr() {
    return m_ptr;
}
std::string GVecInputMaterialVariable_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GVecInputMaterialVariable_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassVecInputMaterialVariable_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GVecInputMaterialVariable_t>("VecInputMaterialVariable_t")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("StrVariable", &GVecInputMaterialVariable_t::GetStrVariable, &GVecInputMaterialVariable_t::SetStrVariable)
        .addFunction("ToPtr", &GVecInputMaterialVariable_t::ToPtr)
        .addFunction("IsValid", &GVecInputMaterialVariable_t::IsValid)
        .endClass();
}
GCCachedPose::GCCachedPose(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCCachedPose::GCCachedPose(void *ptr) {
    m_ptr = ptr;
}
std::vector<float32> GCCachedPose::GetMorphWeights() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CCachedPose->MorphWeights(ptr=%p)", m_ptr));
    CUtlVector<float32>* vec = GetSchemaValue<CUtlVector<float32>*>(m_ptr, "CCachedPose", "m_morphWeights"); std::vector<float32> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCCachedPose::SetMorphWeights(std::vector<float32> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CCachedPose->MorphWeights(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<float32>(m_ptr, "CCachedPose", "m_morphWeights", false, value);
}
float GCCachedPose::GetCycle() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CCachedPose->Cycle(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CCachedPose", "m_flCycle");
}
void GCCachedPose::SetCycle(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CCachedPose->Cycle(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CCachedPose", "m_flCycle", false, value);
}
void* GCCachedPose::GetPtr() {
    return m_ptr;
}
std::string GCCachedPose::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCCachedPose::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCCachedPose(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCCachedPose>("CCachedPose")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("MorphWeights", &GCCachedPose::GetMorphWeights, &GCCachedPose::SetMorphWeights)
        .addProperty("Cycle", &GCCachedPose::GetCycle, &GCCachedPose::SetCycle)
        .addFunction("ToPtr", &GCCachedPose::ToPtr)
        .addFunction("IsValid", &GCCachedPose::IsValid)
        .endClass();
}
GCAnimGraphSettingsGroup::GCAnimGraphSettingsGroup(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCAnimGraphSettingsGroup::GCAnimGraphSettingsGroup(void *ptr) {
    m_ptr = ptr;
}
void* GCAnimGraphSettingsGroup::GetPtr() {
    return m_ptr;
}
std::string GCAnimGraphSettingsGroup::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCAnimGraphSettingsGroup::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCAnimGraphSettingsGroup(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCAnimGraphSettingsGroup>("CAnimGraphSettingsGroup")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addFunction("ToPtr", &GCAnimGraphSettingsGroup::ToPtr)
        .addFunction("IsValid", &GCAnimGraphSettingsGroup::IsValid)
        .endClass();
}
GCModelConfig::GCModelConfig(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCModelConfig::GCModelConfig(void *ptr) {
    m_ptr = ptr;
}
std::string GCModelConfig::GetConfigName() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CModelConfig->ConfigName(ptr=%p)", m_ptr));
    return GetSchemaValue<CUtlString>(m_ptr, "CModelConfig", "m_ConfigName").Get();
}
void GCModelConfig::SetConfigName(std::string value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CModelConfig->ConfigName(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CModelConfig", "m_ConfigName", false, CUtlString(value.c_str()));
}
std::vector<GCModelConfigElement*> GCModelConfig::GetElements() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CModelConfig->Elements(ptr=%p)", m_ptr));
    CUtlVector<GCModelConfigElement*>* vec = GetSchemaValue<CUtlVector<GCModelConfigElement*>*>(m_ptr, "CModelConfig", "m_Elements"); std::vector<GCModelConfigElement*> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCModelConfig::SetElements(std::vector<GCModelConfigElement*> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CModelConfig->Elements(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<GCModelConfigElement*>(m_ptr, "CModelConfig", "m_Elements", false, value);
}
bool GCModelConfig::GetTopLevel() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CModelConfig->TopLevel(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "CModelConfig", "m_bTopLevel");
}
void GCModelConfig::SetTopLevel(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CModelConfig->TopLevel(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CModelConfig", "m_bTopLevel", false, value);
}
void* GCModelConfig::GetPtr() {
    return m_ptr;
}
std::string GCModelConfig::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCModelConfig::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCModelConfig(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCModelConfig>("CModelConfig")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("ConfigName", &GCModelConfig::GetConfigName, &GCModelConfig::SetConfigName)
        .addProperty("Elements", &GCModelConfig::GetElements, &GCModelConfig::SetElements)
        .addProperty("TopLevel", &GCModelConfig::GetTopLevel, &GCModelConfig::SetTopLevel)
        .addFunction("ToPtr", &GCModelConfig::ToPtr)
        .addFunction("IsValid", &GCModelConfig::IsValid)
        .endClass();
}
GFootLockPoseOpFixedSettings::GFootLockPoseOpFixedSettings(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GFootLockPoseOpFixedSettings::GFootLockPoseOpFixedSettings(void *ptr) {
    m_ptr = ptr;
}
std::vector<GFootFixedData_t> GFootLockPoseOpFixedSettings::GetFootInfo() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FootLockPoseOpFixedSettings->FootInfo(ptr=%p)", m_ptr));
    CUtlVector<GFootFixedData_t>* vec = GetSchemaValue<CUtlVector<GFootFixedData_t>*>(m_ptr, "FootLockPoseOpFixedSettings", "m_footInfo"); std::vector<GFootFixedData_t> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GFootLockPoseOpFixedSettings::SetFootInfo(std::vector<GFootFixedData_t> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FootLockPoseOpFixedSettings->FootInfo(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<GFootFixedData_t>(m_ptr, "FootLockPoseOpFixedSettings", "m_footInfo", false, value);
}
GCAnimInputDamping GFootLockPoseOpFixedSettings::GetHipDampingSettings() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FootLockPoseOpFixedSettings->HipDampingSettings(ptr=%p)", m_ptr));
    GCAnimInputDamping value(GetSchemaPtr(m_ptr, "FootLockPoseOpFixedSettings", "m_hipDampingSettings"));
    return value;
}
void GFootLockPoseOpFixedSettings::SetHipDampingSettings(GCAnimInputDamping value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FootLockPoseOpFixedSettings->HipDampingSettings(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'HipDampingSettings' is not possible.\n");
}
int32_t GFootLockPoseOpFixedSettings::GetHipBoneIndex() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FootLockPoseOpFixedSettings->HipBoneIndex(ptr=%p)", m_ptr));
    return GetSchemaValue<int32_t>(m_ptr, "FootLockPoseOpFixedSettings", "m_nHipBoneIndex");
}
void GFootLockPoseOpFixedSettings::SetHipBoneIndex(int32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FootLockPoseOpFixedSettings->HipBoneIndex(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "FootLockPoseOpFixedSettings", "m_nHipBoneIndex", false, value);
}
uint64_t GFootLockPoseOpFixedSettings::GetIkSolverType() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FootLockPoseOpFixedSettings->IkSolverType(ptr=%p)", m_ptr));
    return GetSchemaValue<uint64_t>(m_ptr, "FootLockPoseOpFixedSettings", "m_ikSolverType");
}
void GFootLockPoseOpFixedSettings::SetIkSolverType(uint64_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FootLockPoseOpFixedSettings->IkSolverType(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "FootLockPoseOpFixedSettings", "m_ikSolverType", false, value);
}
bool GFootLockPoseOpFixedSettings::GetApplyTilt() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FootLockPoseOpFixedSettings->ApplyTilt(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "FootLockPoseOpFixedSettings", "m_bApplyTilt");
}
void GFootLockPoseOpFixedSettings::SetApplyTilt(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FootLockPoseOpFixedSettings->ApplyTilt(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "FootLockPoseOpFixedSettings", "m_bApplyTilt", false, value);
}
bool GFootLockPoseOpFixedSettings::GetApplyHipDrop() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FootLockPoseOpFixedSettings->ApplyHipDrop(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "FootLockPoseOpFixedSettings", "m_bApplyHipDrop");
}
void GFootLockPoseOpFixedSettings::SetApplyHipDrop(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FootLockPoseOpFixedSettings->ApplyHipDrop(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "FootLockPoseOpFixedSettings", "m_bApplyHipDrop", false, value);
}
bool GFootLockPoseOpFixedSettings::GetAlwaysUseFallbackHinge() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FootLockPoseOpFixedSettings->AlwaysUseFallbackHinge(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "FootLockPoseOpFixedSettings", "m_bAlwaysUseFallbackHinge");
}
void GFootLockPoseOpFixedSettings::SetAlwaysUseFallbackHinge(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FootLockPoseOpFixedSettings->AlwaysUseFallbackHinge(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "FootLockPoseOpFixedSettings", "m_bAlwaysUseFallbackHinge", false, value);
}
bool GFootLockPoseOpFixedSettings::GetApplyFootRotationLimits() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FootLockPoseOpFixedSettings->ApplyFootRotationLimits(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "FootLockPoseOpFixedSettings", "m_bApplyFootRotationLimits");
}
void GFootLockPoseOpFixedSettings::SetApplyFootRotationLimits(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FootLockPoseOpFixedSettings->ApplyFootRotationLimits(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "FootLockPoseOpFixedSettings", "m_bApplyFootRotationLimits", false, value);
}
bool GFootLockPoseOpFixedSettings::GetApplyLegTwistLimits() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FootLockPoseOpFixedSettings->ApplyLegTwistLimits(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "FootLockPoseOpFixedSettings", "m_bApplyLegTwistLimits");
}
void GFootLockPoseOpFixedSettings::SetApplyLegTwistLimits(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FootLockPoseOpFixedSettings->ApplyLegTwistLimits(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "FootLockPoseOpFixedSettings", "m_bApplyLegTwistLimits", false, value);
}
float GFootLockPoseOpFixedSettings::GetMaxFootHeight() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FootLockPoseOpFixedSettings->MaxFootHeight(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "FootLockPoseOpFixedSettings", "m_flMaxFootHeight");
}
void GFootLockPoseOpFixedSettings::SetMaxFootHeight(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FootLockPoseOpFixedSettings->MaxFootHeight(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "FootLockPoseOpFixedSettings", "m_flMaxFootHeight", false, value);
}
float GFootLockPoseOpFixedSettings::GetExtensionScale() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FootLockPoseOpFixedSettings->ExtensionScale(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "FootLockPoseOpFixedSettings", "m_flExtensionScale");
}
void GFootLockPoseOpFixedSettings::SetExtensionScale(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FootLockPoseOpFixedSettings->ExtensionScale(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "FootLockPoseOpFixedSettings", "m_flExtensionScale", false, value);
}
float GFootLockPoseOpFixedSettings::GetMaxLegTwist() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FootLockPoseOpFixedSettings->MaxLegTwist(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "FootLockPoseOpFixedSettings", "m_flMaxLegTwist");
}
void GFootLockPoseOpFixedSettings::SetMaxLegTwist(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FootLockPoseOpFixedSettings->MaxLegTwist(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "FootLockPoseOpFixedSettings", "m_flMaxLegTwist", false, value);
}
bool GFootLockPoseOpFixedSettings::GetEnableLockBreaking() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FootLockPoseOpFixedSettings->EnableLockBreaking(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "FootLockPoseOpFixedSettings", "m_bEnableLockBreaking");
}
void GFootLockPoseOpFixedSettings::SetEnableLockBreaking(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FootLockPoseOpFixedSettings->EnableLockBreaking(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "FootLockPoseOpFixedSettings", "m_bEnableLockBreaking", false, value);
}
float GFootLockPoseOpFixedSettings::GetLockBreakTolerance() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FootLockPoseOpFixedSettings->LockBreakTolerance(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "FootLockPoseOpFixedSettings", "m_flLockBreakTolerance");
}
void GFootLockPoseOpFixedSettings::SetLockBreakTolerance(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FootLockPoseOpFixedSettings->LockBreakTolerance(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "FootLockPoseOpFixedSettings", "m_flLockBreakTolerance", false, value);
}
float GFootLockPoseOpFixedSettings::GetLockBlendTime() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FootLockPoseOpFixedSettings->LockBlendTime(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "FootLockPoseOpFixedSettings", "m_flLockBlendTime");
}
void GFootLockPoseOpFixedSettings::SetLockBlendTime(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FootLockPoseOpFixedSettings->LockBlendTime(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "FootLockPoseOpFixedSettings", "m_flLockBlendTime", false, value);
}
bool GFootLockPoseOpFixedSettings::GetEnableStretching() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FootLockPoseOpFixedSettings->EnableStretching(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "FootLockPoseOpFixedSettings", "m_bEnableStretching");
}
void GFootLockPoseOpFixedSettings::SetEnableStretching(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FootLockPoseOpFixedSettings->EnableStretching(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "FootLockPoseOpFixedSettings", "m_bEnableStretching", false, value);
}
float GFootLockPoseOpFixedSettings::GetMaxStretchAmount() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FootLockPoseOpFixedSettings->MaxStretchAmount(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "FootLockPoseOpFixedSettings", "m_flMaxStretchAmount");
}
void GFootLockPoseOpFixedSettings::SetMaxStretchAmount(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FootLockPoseOpFixedSettings->MaxStretchAmount(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "FootLockPoseOpFixedSettings", "m_flMaxStretchAmount", false, value);
}
float GFootLockPoseOpFixedSettings::GetStretchExtensionScale() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FootLockPoseOpFixedSettings->StretchExtensionScale(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "FootLockPoseOpFixedSettings", "m_flStretchExtensionScale");
}
void GFootLockPoseOpFixedSettings::SetStretchExtensionScale(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FootLockPoseOpFixedSettings->StretchExtensionScale(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "FootLockPoseOpFixedSettings", "m_flStretchExtensionScale", false, value);
}
void* GFootLockPoseOpFixedSettings::GetPtr() {
    return m_ptr;
}
std::string GFootLockPoseOpFixedSettings::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GFootLockPoseOpFixedSettings::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassFootLockPoseOpFixedSettings(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GFootLockPoseOpFixedSettings>("FootLockPoseOpFixedSettings")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("FootInfo", &GFootLockPoseOpFixedSettings::GetFootInfo, &GFootLockPoseOpFixedSettings::SetFootInfo)
        .addProperty("HipDampingSettings", &GFootLockPoseOpFixedSettings::GetHipDampingSettings, &GFootLockPoseOpFixedSettings::SetHipDampingSettings)
        .addProperty("HipBoneIndex", &GFootLockPoseOpFixedSettings::GetHipBoneIndex, &GFootLockPoseOpFixedSettings::SetHipBoneIndex)
        .addProperty("IkSolverType", &GFootLockPoseOpFixedSettings::GetIkSolverType, &GFootLockPoseOpFixedSettings::SetIkSolverType)
        .addProperty("ApplyTilt", &GFootLockPoseOpFixedSettings::GetApplyTilt, &GFootLockPoseOpFixedSettings::SetApplyTilt)
        .addProperty("ApplyHipDrop", &GFootLockPoseOpFixedSettings::GetApplyHipDrop, &GFootLockPoseOpFixedSettings::SetApplyHipDrop)
        .addProperty("AlwaysUseFallbackHinge", &GFootLockPoseOpFixedSettings::GetAlwaysUseFallbackHinge, &GFootLockPoseOpFixedSettings::SetAlwaysUseFallbackHinge)
        .addProperty("ApplyFootRotationLimits", &GFootLockPoseOpFixedSettings::GetApplyFootRotationLimits, &GFootLockPoseOpFixedSettings::SetApplyFootRotationLimits)
        .addProperty("ApplyLegTwistLimits", &GFootLockPoseOpFixedSettings::GetApplyLegTwistLimits, &GFootLockPoseOpFixedSettings::SetApplyLegTwistLimits)
        .addProperty("MaxFootHeight", &GFootLockPoseOpFixedSettings::GetMaxFootHeight, &GFootLockPoseOpFixedSettings::SetMaxFootHeight)
        .addProperty("ExtensionScale", &GFootLockPoseOpFixedSettings::GetExtensionScale, &GFootLockPoseOpFixedSettings::SetExtensionScale)
        .addProperty("MaxLegTwist", &GFootLockPoseOpFixedSettings::GetMaxLegTwist, &GFootLockPoseOpFixedSettings::SetMaxLegTwist)
        .addProperty("EnableLockBreaking", &GFootLockPoseOpFixedSettings::GetEnableLockBreaking, &GFootLockPoseOpFixedSettings::SetEnableLockBreaking)
        .addProperty("LockBreakTolerance", &GFootLockPoseOpFixedSettings::GetLockBreakTolerance, &GFootLockPoseOpFixedSettings::SetLockBreakTolerance)
        .addProperty("LockBlendTime", &GFootLockPoseOpFixedSettings::GetLockBlendTime, &GFootLockPoseOpFixedSettings::SetLockBlendTime)
        .addProperty("EnableStretching", &GFootLockPoseOpFixedSettings::GetEnableStretching, &GFootLockPoseOpFixedSettings::SetEnableStretching)
        .addProperty("MaxStretchAmount", &GFootLockPoseOpFixedSettings::GetMaxStretchAmount, &GFootLockPoseOpFixedSettings::SetMaxStretchAmount)
        .addProperty("StretchExtensionScale", &GFootLockPoseOpFixedSettings::GetStretchExtensionScale, &GFootLockPoseOpFixedSettings::SetStretchExtensionScale)
        .addFunction("ToPtr", &GFootLockPoseOpFixedSettings::ToPtr)
        .addFunction("IsValid", &GFootLockPoseOpFixedSettings::IsValid)
        .endClass();
}
GCFlexRule::GCFlexRule(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCFlexRule::GCFlexRule(void *ptr) {
    m_ptr = ptr;
}
int32_t GCFlexRule::GetFlex() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CFlexRule->Flex(ptr=%p)", m_ptr));
    return GetSchemaValue<int32_t>(m_ptr, "CFlexRule", "m_nFlex");
}
void GCFlexRule::SetFlex(int32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CFlexRule->Flex(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CFlexRule", "m_nFlex", false, value);
}
std::vector<GCFlexOp> GCFlexRule::GetFlexOps() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CFlexRule->FlexOps(ptr=%p)", m_ptr));
    CUtlVector<GCFlexOp>* vec = GetSchemaValue<CUtlVector<GCFlexOp>*>(m_ptr, "CFlexRule", "m_FlexOps"); std::vector<GCFlexOp> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCFlexRule::SetFlexOps(std::vector<GCFlexOp> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CFlexRule->FlexOps(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<GCFlexOp>(m_ptr, "CFlexRule", "m_FlexOps", false, value);
}
void* GCFlexRule::GetPtr() {
    return m_ptr;
}
std::string GCFlexRule::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCFlexRule::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCFlexRule(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCFlexRule>("CFlexRule")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Flex", &GCFlexRule::GetFlex, &GCFlexRule::SetFlex)
        .addProperty("FlexOps", &GCFlexRule::GetFlexOps, &GCFlexRule::SetFlexOps)
        .addFunction("ToPtr", &GCFlexRule::ToPtr)
        .addFunction("IsValid", &GCFlexRule::IsValid)
        .endClass();
}
GCSosGroupActionSetSoundeventParameterSchema::GCSosGroupActionSetSoundeventParameterSchema(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCSosGroupActionSetSoundeventParameterSchema::GCSosGroupActionSetSoundeventParameterSchema(void *ptr) {
    m_ptr = ptr;
}
int32_t GCSosGroupActionSetSoundeventParameterSchema::GetMaxCount() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CSosGroupActionSetSoundeventParameterSchema->MaxCount(ptr=%p)", m_ptr));
    return GetSchemaValue<int32_t>(m_ptr, "CSosGroupActionSetSoundeventParameterSchema", "m_nMaxCount");
}
void GCSosGroupActionSetSoundeventParameterSchema::SetMaxCount(int32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CSosGroupActionSetSoundeventParameterSchema->MaxCount(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CSosGroupActionSetSoundeventParameterSchema", "m_nMaxCount", false, value);
}
float GCSosGroupActionSetSoundeventParameterSchema::GetMinValue() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CSosGroupActionSetSoundeventParameterSchema->MinValue(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CSosGroupActionSetSoundeventParameterSchema", "m_flMinValue");
}
void GCSosGroupActionSetSoundeventParameterSchema::SetMinValue(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CSosGroupActionSetSoundeventParameterSchema->MinValue(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CSosGroupActionSetSoundeventParameterSchema", "m_flMinValue", false, value);
}
float GCSosGroupActionSetSoundeventParameterSchema::GetMaxValue() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CSosGroupActionSetSoundeventParameterSchema->MaxValue(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CSosGroupActionSetSoundeventParameterSchema", "m_flMaxValue");
}
void GCSosGroupActionSetSoundeventParameterSchema::SetMaxValue(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CSosGroupActionSetSoundeventParameterSchema->MaxValue(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CSosGroupActionSetSoundeventParameterSchema", "m_flMaxValue", false, value);
}
std::string GCSosGroupActionSetSoundeventParameterSchema::GetOpvarName() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CSosGroupActionSetSoundeventParameterSchema->OpvarName(ptr=%p)", m_ptr));
    return GetSchemaValue<CUtlString>(m_ptr, "CSosGroupActionSetSoundeventParameterSchema", "m_opvarName").Get();
}
void GCSosGroupActionSetSoundeventParameterSchema::SetOpvarName(std::string value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CSosGroupActionSetSoundeventParameterSchema->OpvarName(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CSosGroupActionSetSoundeventParameterSchema", "m_opvarName", false, CUtlString(value.c_str()));
}
uint64_t GCSosGroupActionSetSoundeventParameterSchema::GetSortType() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CSosGroupActionSetSoundeventParameterSchema->SortType(ptr=%p)", m_ptr));
    return GetSchemaValue<uint64_t>(m_ptr, "CSosGroupActionSetSoundeventParameterSchema", "m_nSortType");
}
void GCSosGroupActionSetSoundeventParameterSchema::SetSortType(uint64_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CSosGroupActionSetSoundeventParameterSchema->SortType(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CSosGroupActionSetSoundeventParameterSchema", "m_nSortType", false, value);
}
void* GCSosGroupActionSetSoundeventParameterSchema::GetPtr() {
    return m_ptr;
}
std::string GCSosGroupActionSetSoundeventParameterSchema::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCSosGroupActionSetSoundeventParameterSchema::IsValid() {
    return (m_ptr != nullptr);
}
GCSosGroupActionSchema GCSosGroupActionSetSoundeventParameterSchema::GetParent() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CSosGroupActionSetSoundeventParameterSchema::GetParent(ptr=%p)", m_ptr));
    GCSosGroupActionSchema value(m_ptr);
    return value;
}
void GCSosGroupActionSetSoundeventParameterSchema::SetParent(GCSosGroupActionSchema value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CSosGroupActionSetSoundeventParameterSchema::SetParent(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCSosGroupActionSetSoundeventParameterSchema(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCSosGroupActionSetSoundeventParameterSchema>("CSosGroupActionSetSoundeventParameterSchema")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("MaxCount", &GCSosGroupActionSetSoundeventParameterSchema::GetMaxCount, &GCSosGroupActionSetSoundeventParameterSchema::SetMaxCount)
        .addProperty("MinValue", &GCSosGroupActionSetSoundeventParameterSchema::GetMinValue, &GCSosGroupActionSetSoundeventParameterSchema::SetMinValue)
        .addProperty("MaxValue", &GCSosGroupActionSetSoundeventParameterSchema::GetMaxValue, &GCSosGroupActionSetSoundeventParameterSchema::SetMaxValue)
        .addProperty("OpvarName", &GCSosGroupActionSetSoundeventParameterSchema::GetOpvarName, &GCSosGroupActionSetSoundeventParameterSchema::SetOpvarName)
        .addProperty("SortType", &GCSosGroupActionSetSoundeventParameterSchema::GetSortType, &GCSosGroupActionSetSoundeventParameterSchema::SetSortType)
        .addProperty("Parent", &GCSosGroupActionSetSoundeventParameterSchema::GetParent, &GCSosGroupActionSetSoundeventParameterSchema::SetParent)
        .addFunction("ToPtr", &GCSosGroupActionSetSoundeventParameterSchema::ToPtr)
        .addFunction("IsValid", &GCSosGroupActionSetSoundeventParameterSchema::IsValid)
        .endClass();
}
GCStepsRemainingMetricEvaluator::GCStepsRemainingMetricEvaluator(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCStepsRemainingMetricEvaluator::GCStepsRemainingMetricEvaluator(void *ptr) {
    m_ptr = ptr;
}
std::vector<int32> GCStepsRemainingMetricEvaluator::GetFootIndices() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CStepsRemainingMetricEvaluator->FootIndices(ptr=%p)", m_ptr));
    CUtlVector<int32>* vec = GetSchemaValue<CUtlVector<int32>*>(m_ptr, "CStepsRemainingMetricEvaluator", "m_footIndices"); std::vector<int32> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCStepsRemainingMetricEvaluator::SetFootIndices(std::vector<int32> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CStepsRemainingMetricEvaluator->FootIndices(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<int32>(m_ptr, "CStepsRemainingMetricEvaluator", "m_footIndices", false, value);
}
float GCStepsRemainingMetricEvaluator::GetMinStepsRemaining() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CStepsRemainingMetricEvaluator->MinStepsRemaining(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CStepsRemainingMetricEvaluator", "m_flMinStepsRemaining");
}
void GCStepsRemainingMetricEvaluator::SetMinStepsRemaining(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CStepsRemainingMetricEvaluator->MinStepsRemaining(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CStepsRemainingMetricEvaluator", "m_flMinStepsRemaining", false, value);
}
void* GCStepsRemainingMetricEvaluator::GetPtr() {
    return m_ptr;
}
std::string GCStepsRemainingMetricEvaluator::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCStepsRemainingMetricEvaluator::IsValid() {
    return (m_ptr != nullptr);
}
GCMotionMetricEvaluator GCStepsRemainingMetricEvaluator::GetParent() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CStepsRemainingMetricEvaluator::GetParent(ptr=%p)", m_ptr));
    GCMotionMetricEvaluator value(m_ptr);
    return value;
}
void GCStepsRemainingMetricEvaluator::SetParent(GCMotionMetricEvaluator value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CStepsRemainingMetricEvaluator::SetParent(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCStepsRemainingMetricEvaluator(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCStepsRemainingMetricEvaluator>("CStepsRemainingMetricEvaluator")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("FootIndices", &GCStepsRemainingMetricEvaluator::GetFootIndices, &GCStepsRemainingMetricEvaluator::SetFootIndices)
        .addProperty("MinStepsRemaining", &GCStepsRemainingMetricEvaluator::GetMinStepsRemaining, &GCStepsRemainingMetricEvaluator::SetMinStepsRemaining)
        .addProperty("Parent", &GCStepsRemainingMetricEvaluator::GetParent, &GCStepsRemainingMetricEvaluator::SetParent)
        .addFunction("ToPtr", &GCStepsRemainingMetricEvaluator::ToPtr)
        .addFunction("IsValid", &GCStepsRemainingMetricEvaluator::IsValid)
        .endClass();
}
GNmCompressionSettings_t__QuantizationRange_t::GNmCompressionSettings_t__QuantizationRange_t(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GNmCompressionSettings_t__QuantizationRange_t::GNmCompressionSettings_t__QuantizationRange_t(void *ptr) {
    m_ptr = ptr;
}
float GNmCompressionSettings_t__QuantizationRange_t::GetRangeStart() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: NmCompressionSettings_t__QuantizationRange_t->RangeStart(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "NmCompressionSettings_t__QuantizationRange_t", "m_flRangeStart");
}
void GNmCompressionSettings_t__QuantizationRange_t::SetRangeStart(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: NmCompressionSettings_t__QuantizationRange_t->RangeStart(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "NmCompressionSettings_t__QuantizationRange_t", "m_flRangeStart", true, value);
}
float GNmCompressionSettings_t__QuantizationRange_t::GetRangeLength() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: NmCompressionSettings_t__QuantizationRange_t->RangeLength(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "NmCompressionSettings_t__QuantizationRange_t", "m_flRangeLength");
}
void GNmCompressionSettings_t__QuantizationRange_t::SetRangeLength(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: NmCompressionSettings_t__QuantizationRange_t->RangeLength(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "NmCompressionSettings_t__QuantizationRange_t", "m_flRangeLength", true, value);
}
void* GNmCompressionSettings_t__QuantizationRange_t::GetPtr() {
    return m_ptr;
}
std::string GNmCompressionSettings_t__QuantizationRange_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GNmCompressionSettings_t__QuantizationRange_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassNmCompressionSettings_t__QuantizationRange_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GNmCompressionSettings_t__QuantizationRange_t>("NmCompressionSettings_t__QuantizationRange_t")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("RangeStart", &GNmCompressionSettings_t__QuantizationRange_t::GetRangeStart, &GNmCompressionSettings_t__QuantizationRange_t::SetRangeStart)
        .addProperty("RangeLength", &GNmCompressionSettings_t__QuantizationRange_t::GetRangeLength, &GNmCompressionSettings_t__QuantizationRange_t::SetRangeLength)
        .addFunction("ToPtr", &GNmCompressionSettings_t__QuantizationRange_t::ToPtr)
        .addFunction("IsValid", &GNmCompressionSettings_t__QuantizationRange_t::IsValid)
        .endClass();
}
GCAnimParameterManagerUpdater::GCAnimParameterManagerUpdater(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCAnimParameterManagerUpdater::GCAnimParameterManagerUpdater(void *ptr) {
    m_ptr = ptr;
}
std::vector<GCAnimParamHandle> GCAnimParameterManagerUpdater::GetIndexToHandle() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CAnimParameterManagerUpdater->IndexToHandle(ptr=%p)", m_ptr));
    CUtlVector<GCAnimParamHandle>* vec = GetSchemaValue<CUtlVector<GCAnimParamHandle>*>(m_ptr, "CAnimParameterManagerUpdater", "m_indexToHandle"); std::vector<GCAnimParamHandle> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCAnimParameterManagerUpdater::SetIndexToHandle(std::vector<GCAnimParamHandle> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CAnimParameterManagerUpdater->IndexToHandle(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<GCAnimParamHandle>(m_ptr, "CAnimParameterManagerUpdater", "m_indexToHandle", false, value);
}
void* GCAnimParameterManagerUpdater::GetPtr() {
    return m_ptr;
}
std::string GCAnimParameterManagerUpdater::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCAnimParameterManagerUpdater::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCAnimParameterManagerUpdater(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCAnimParameterManagerUpdater>("CAnimParameterManagerUpdater")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("IndexToHandle", &GCAnimParameterManagerUpdater::GetIndexToHandle, &GCAnimParameterManagerUpdater::SetIndexToHandle)
        .addFunction("ToPtr", &GCAnimParameterManagerUpdater::ToPtr)
        .addFunction("IsValid", &GCAnimParameterManagerUpdater::IsValid)
        .endClass();
}
GCModelConfigElement_RandomColor::GCModelConfigElement_RandomColor(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCModelConfigElement_RandomColor::GCModelConfigElement_RandomColor(void *ptr) {
    m_ptr = ptr;
}
void* GCModelConfigElement_RandomColor::GetPtr() {
    return m_ptr;
}
std::string GCModelConfigElement_RandomColor::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCModelConfigElement_RandomColor::IsValid() {
    return (m_ptr != nullptr);
}
GCModelConfigElement GCModelConfigElement_RandomColor::GetParent() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CModelConfigElement_RandomColor::GetParent(ptr=%p)", m_ptr));
    GCModelConfigElement value(m_ptr);
    return value;
}
void GCModelConfigElement_RandomColor::SetParent(GCModelConfigElement value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CModelConfigElement_RandomColor::SetParent(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCModelConfigElement_RandomColor(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCModelConfigElement_RandomColor>("CModelConfigElement_RandomColor")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Parent", &GCModelConfigElement_RandomColor::GetParent, &GCModelConfigElement_RandomColor::SetParent)
        .addFunction("ToPtr", &GCModelConfigElement_RandomColor::ToPtr)
        .addFunction("IsValid", &GCModelConfigElement_RandomColor::IsValid)
        .endClass();
}
GCMotionNode::GCMotionNode(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCMotionNode::GCMotionNode(void *ptr) {
    m_ptr = ptr;
}
std::string GCMotionNode::GetName() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CMotionNode->Name(ptr=%p)", m_ptr));
    return GetSchemaValue<CUtlString>(m_ptr, "CMotionNode", "m_name").Get();
}
void GCMotionNode::SetName(std::string value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CMotionNode->Name(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CMotionNode", "m_name", false, CUtlString(value.c_str()));
}
GAnimNodeID GCMotionNode::GetId() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CMotionNode->Id(ptr=%p)", m_ptr));
    GAnimNodeID value(GetSchemaPtr(m_ptr, "CMotionNode", "m_id"));
    return value;
}
void GCMotionNode::SetId(GAnimNodeID value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CMotionNode->Id(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Id' is not possible.\n");
}
void* GCMotionNode::GetPtr() {
    return m_ptr;
}
std::string GCMotionNode::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCMotionNode::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCMotionNode(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCMotionNode>("CMotionNode")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Name", &GCMotionNode::GetName, &GCMotionNode::SetName)
        .addProperty("Id", &GCMotionNode::GetId, &GCMotionNode::SetId)
        .addFunction("ToPtr", &GCMotionNode::ToPtr)
        .addFunction("IsValid", &GCMotionNode::IsValid)
        .endClass();
}
GCAnimTagBase::GCAnimTagBase(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCAnimTagBase::GCAnimTagBase(void *ptr) {
    m_ptr = ptr;
}
std::string GCAnimTagBase::GetComment() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CAnimTagBase->Comment(ptr=%p)", m_ptr));
    return GetSchemaValue<CUtlString>(m_ptr, "CAnimTagBase", "m_sComment").Get();
}
void GCAnimTagBase::SetComment(std::string value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CAnimTagBase->Comment(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CAnimTagBase", "m_sComment", false, CUtlString(value.c_str()));
}
GAnimTagID GCAnimTagBase::GetTagID() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CAnimTagBase->TagID(ptr=%p)", m_ptr));
    GAnimTagID value(GetSchemaPtr(m_ptr, "CAnimTagBase", "m_tagID"));
    return value;
}
void GCAnimTagBase::SetTagID(GAnimTagID value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CAnimTagBase->TagID(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'TagID' is not possible.\n");
}
bool GCAnimTagBase::GetIsReferenced() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CAnimTagBase->IsReferenced(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "CAnimTagBase", "m_bIsReferenced");
}
void GCAnimTagBase::SetIsReferenced(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CAnimTagBase->IsReferenced(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CAnimTagBase", "m_bIsReferenced", false, value);
}
void* GCAnimTagBase::GetPtr() {
    return m_ptr;
}
std::string GCAnimTagBase::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCAnimTagBase::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCAnimTagBase(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCAnimTagBase>("CAnimTagBase")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Comment", &GCAnimTagBase::GetComment, &GCAnimTagBase::SetComment)
        .addProperty("TagID", &GCAnimTagBase::GetTagID, &GCAnimTagBase::SetTagID)
        .addProperty("IsReferenced", &GCAnimTagBase::GetIsReferenced, &GCAnimTagBase::SetIsReferenced)
        .addFunction("ToPtr", &GCAnimTagBase::ToPtr)
        .addFunction("IsValid", &GCAnimTagBase::IsValid)
        .endClass();
}
GAnimComponentID::GAnimComponentID(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GAnimComponentID::GAnimComponentID(void *ptr) {
    m_ptr = ptr;
}
uint32_t GAnimComponentID::GetId() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: AnimComponentID->Id(ptr=%p)", m_ptr));
    return GetSchemaValue<uint32_t>(m_ptr, "AnimComponentID", "m_id");
}
void GAnimComponentID::SetId(uint32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: AnimComponentID->Id(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "AnimComponentID", "m_id", false, value);
}
void* GAnimComponentID::GetPtr() {
    return m_ptr;
}
std::string GAnimComponentID::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GAnimComponentID::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassAnimComponentID(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GAnimComponentID>("AnimComponentID")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Id", &GAnimComponentID::GetId, &GAnimComponentID::SetId)
        .addFunction("ToPtr", &GAnimComponentID::ToPtr)
        .addFunction("IsValid", &GAnimComponentID::IsValid)
        .endClass();
}
GCAnimLocalHierarchy::GCAnimLocalHierarchy(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCAnimLocalHierarchy::GCAnimLocalHierarchy(void *ptr) {
    m_ptr = ptr;
}
int32_t GCAnimLocalHierarchy::GetStartFrame() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CAnimLocalHierarchy->StartFrame(ptr=%p)", m_ptr));
    return GetSchemaValue<int32_t>(m_ptr, "CAnimLocalHierarchy", "m_nStartFrame");
}
void GCAnimLocalHierarchy::SetStartFrame(int32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CAnimLocalHierarchy->StartFrame(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CAnimLocalHierarchy", "m_nStartFrame", false, value);
}
int32_t GCAnimLocalHierarchy::GetPeakFrame() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CAnimLocalHierarchy->PeakFrame(ptr=%p)", m_ptr));
    return GetSchemaValue<int32_t>(m_ptr, "CAnimLocalHierarchy", "m_nPeakFrame");
}
void GCAnimLocalHierarchy::SetPeakFrame(int32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CAnimLocalHierarchy->PeakFrame(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CAnimLocalHierarchy", "m_nPeakFrame", false, value);
}
int32_t GCAnimLocalHierarchy::GetTailFrame() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CAnimLocalHierarchy->TailFrame(ptr=%p)", m_ptr));
    return GetSchemaValue<int32_t>(m_ptr, "CAnimLocalHierarchy", "m_nTailFrame");
}
void GCAnimLocalHierarchy::SetTailFrame(int32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CAnimLocalHierarchy->TailFrame(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CAnimLocalHierarchy", "m_nTailFrame", false, value);
}
int32_t GCAnimLocalHierarchy::GetEndFrame() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CAnimLocalHierarchy->EndFrame(ptr=%p)", m_ptr));
    return GetSchemaValue<int32_t>(m_ptr, "CAnimLocalHierarchy", "m_nEndFrame");
}
void GCAnimLocalHierarchy::SetEndFrame(int32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CAnimLocalHierarchy->EndFrame(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CAnimLocalHierarchy", "m_nEndFrame", false, value);
}
void* GCAnimLocalHierarchy::GetPtr() {
    return m_ptr;
}
std::string GCAnimLocalHierarchy::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCAnimLocalHierarchy::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCAnimLocalHierarchy(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCAnimLocalHierarchy>("CAnimLocalHierarchy")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("StartFrame", &GCAnimLocalHierarchy::GetStartFrame, &GCAnimLocalHierarchy::SetStartFrame)
        .addProperty("PeakFrame", &GCAnimLocalHierarchy::GetPeakFrame, &GCAnimLocalHierarchy::SetPeakFrame)
        .addProperty("TailFrame", &GCAnimLocalHierarchy::GetTailFrame, &GCAnimLocalHierarchy::SetTailFrame)
        .addProperty("EndFrame", &GCAnimLocalHierarchy::GetEndFrame, &GCAnimLocalHierarchy::SetEndFrame)
        .addFunction("ToPtr", &GCAnimLocalHierarchy::ToPtr)
        .addFunction("IsValid", &GCAnimLocalHierarchy::IsValid)
        .endClass();
}
GRnShapeDesc_t::GRnShapeDesc_t(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GRnShapeDesc_t::GRnShapeDesc_t(void *ptr) {
    m_ptr = ptr;
}
uint32_t GRnShapeDesc_t::GetCollisionAttributeIndex() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: RnShapeDesc_t->CollisionAttributeIndex(ptr=%p)", m_ptr));
    return GetSchemaValue<uint32_t>(m_ptr, "RnShapeDesc_t", "m_nCollisionAttributeIndex");
}
void GRnShapeDesc_t::SetCollisionAttributeIndex(uint32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: RnShapeDesc_t->CollisionAttributeIndex(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "RnShapeDesc_t", "m_nCollisionAttributeIndex", true, value);
}
uint32_t GRnShapeDesc_t::GetSurfacePropertyIndex() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: RnShapeDesc_t->SurfacePropertyIndex(ptr=%p)", m_ptr));
    return GetSchemaValue<uint32_t>(m_ptr, "RnShapeDesc_t", "m_nSurfacePropertyIndex");
}
void GRnShapeDesc_t::SetSurfacePropertyIndex(uint32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: RnShapeDesc_t->SurfacePropertyIndex(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "RnShapeDesc_t", "m_nSurfacePropertyIndex", true, value);
}
std::string GRnShapeDesc_t::GetUserFriendlyName() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: RnShapeDesc_t->UserFriendlyName(ptr=%p)", m_ptr));
    return GetSchemaValue<CUtlString>(m_ptr, "RnShapeDesc_t", "m_UserFriendlyName").Get();
}
void GRnShapeDesc_t::SetUserFriendlyName(std::string value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: RnShapeDesc_t->UserFriendlyName(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "RnShapeDesc_t", "m_UserFriendlyName", true, CUtlString(value.c_str()));
}
void* GRnShapeDesc_t::GetPtr() {
    return m_ptr;
}
std::string GRnShapeDesc_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GRnShapeDesc_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassRnShapeDesc_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GRnShapeDesc_t>("RnShapeDesc_t")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("CollisionAttributeIndex", &GRnShapeDesc_t::GetCollisionAttributeIndex, &GRnShapeDesc_t::SetCollisionAttributeIndex)
        .addProperty("SurfacePropertyIndex", &GRnShapeDesc_t::GetSurfacePropertyIndex, &GRnShapeDesc_t::SetSurfacePropertyIndex)
        .addProperty("UserFriendlyName", &GRnShapeDesc_t::GetUserFriendlyName, &GRnShapeDesc_t::SetUserFriendlyName)
        .addFunction("ToPtr", &GRnShapeDesc_t::ToPtr)
        .addFunction("IsValid", &GRnShapeDesc_t::IsValid)
        .endClass();
}
GCBoneConstraintPoseSpaceBone__Input_t::GCBoneConstraintPoseSpaceBone__Input_t(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCBoneConstraintPoseSpaceBone__Input_t::GCBoneConstraintPoseSpaceBone__Input_t(void *ptr) {
    m_ptr = ptr;
}
Vector GCBoneConstraintPoseSpaceBone__Input_t::GetInputValue() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CBoneConstraintPoseSpaceBone__Input_t->InputValue(ptr=%p)", m_ptr));
    return GetSchemaValue<Vector>(m_ptr, "CBoneConstraintPoseSpaceBone__Input_t", "m_inputValue");
}
void GCBoneConstraintPoseSpaceBone__Input_t::SetInputValue(Vector value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CBoneConstraintPoseSpaceBone__Input_t->InputValue(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CBoneConstraintPoseSpaceBone__Input_t", "m_inputValue", true, value);
}
void* GCBoneConstraintPoseSpaceBone__Input_t::GetPtr() {
    return m_ptr;
}
std::string GCBoneConstraintPoseSpaceBone__Input_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCBoneConstraintPoseSpaceBone__Input_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCBoneConstraintPoseSpaceBone__Input_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCBoneConstraintPoseSpaceBone__Input_t>("CBoneConstraintPoseSpaceBone__Input_t")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("InputValue", &GCBoneConstraintPoseSpaceBone__Input_t::GetInputValue, &GCBoneConstraintPoseSpaceBone__Input_t::SetInputValue)
        .addFunction("ToPtr", &GCBoneConstraintPoseSpaceBone__Input_t::ToPtr)
        .addFunction("IsValid", &GCBoneConstraintPoseSpaceBone__Input_t::IsValid)
        .endClass();
}
GCModelConfigElement_SetRenderColor::GCModelConfigElement_SetRenderColor(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCModelConfigElement_SetRenderColor::GCModelConfigElement_SetRenderColor(void *ptr) {
    m_ptr = ptr;
}
Color GCModelConfigElement_SetRenderColor::GetColor() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CModelConfigElement_SetRenderColor->Color(ptr=%p)", m_ptr));
    return GetSchemaValue<Color>(m_ptr, "CModelConfigElement_SetRenderColor", "m_Color");
}
void GCModelConfigElement_SetRenderColor::SetColor(Color value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CModelConfigElement_SetRenderColor->Color(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CModelConfigElement_SetRenderColor", "m_Color", false, value);
}
void* GCModelConfigElement_SetRenderColor::GetPtr() {
    return m_ptr;
}
std::string GCModelConfigElement_SetRenderColor::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCModelConfigElement_SetRenderColor::IsValid() {
    return (m_ptr != nullptr);
}
GCModelConfigElement GCModelConfigElement_SetRenderColor::GetParent() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CModelConfigElement_SetRenderColor::GetParent(ptr=%p)", m_ptr));
    GCModelConfigElement value(m_ptr);
    return value;
}
void GCModelConfigElement_SetRenderColor::SetParent(GCModelConfigElement value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CModelConfigElement_SetRenderColor::SetParent(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCModelConfigElement_SetRenderColor(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCModelConfigElement_SetRenderColor>("CModelConfigElement_SetRenderColor")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Color", &GCModelConfigElement_SetRenderColor::GetColor, &GCModelConfigElement_SetRenderColor::SetColor)
        .addProperty("Parent", &GCModelConfigElement_SetRenderColor::GetParent, &GCModelConfigElement_SetRenderColor::SetParent)
        .addFunction("ToPtr", &GCModelConfigElement_SetRenderColor::ToPtr)
        .addFunction("IsValid", &GCModelConfigElement_SetRenderColor::IsValid)
        .endClass();
}
GPhysSoftbodyDesc_t::GPhysSoftbodyDesc_t(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GPhysSoftbodyDesc_t::GPhysSoftbodyDesc_t(void *ptr) {
    m_ptr = ptr;
}
std::vector<uint32> GPhysSoftbodyDesc_t::GetParticleBoneHash() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: PhysSoftbodyDesc_t->ParticleBoneHash(ptr=%p)", m_ptr));
    CUtlVector<uint32>* vec = GetSchemaValue<CUtlVector<uint32>*>(m_ptr, "PhysSoftbodyDesc_t", "m_ParticleBoneHash"); std::vector<uint32> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GPhysSoftbodyDesc_t::SetParticleBoneHash(std::vector<uint32> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: PhysSoftbodyDesc_t->ParticleBoneHash(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<uint32>(m_ptr, "PhysSoftbodyDesc_t", "m_ParticleBoneHash", true, value);
}
std::vector<GRnSoftbodyParticle_t> GPhysSoftbodyDesc_t::GetParticles() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: PhysSoftbodyDesc_t->Particles(ptr=%p)", m_ptr));
    CUtlVector<GRnSoftbodyParticle_t>* vec = GetSchemaValue<CUtlVector<GRnSoftbodyParticle_t>*>(m_ptr, "PhysSoftbodyDesc_t", "m_Particles"); std::vector<GRnSoftbodyParticle_t> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GPhysSoftbodyDesc_t::SetParticles(std::vector<GRnSoftbodyParticle_t> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: PhysSoftbodyDesc_t->Particles(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<GRnSoftbodyParticle_t>(m_ptr, "PhysSoftbodyDesc_t", "m_Particles", true, value);
}
std::vector<GRnSoftbodySpring_t> GPhysSoftbodyDesc_t::GetSprings() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: PhysSoftbodyDesc_t->Springs(ptr=%p)", m_ptr));
    CUtlVector<GRnSoftbodySpring_t>* vec = GetSchemaValue<CUtlVector<GRnSoftbodySpring_t>*>(m_ptr, "PhysSoftbodyDesc_t", "m_Springs"); std::vector<GRnSoftbodySpring_t> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GPhysSoftbodyDesc_t::SetSprings(std::vector<GRnSoftbodySpring_t> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: PhysSoftbodyDesc_t->Springs(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<GRnSoftbodySpring_t>(m_ptr, "PhysSoftbodyDesc_t", "m_Springs", true, value);
}
std::vector<GRnSoftbodyCapsule_t> GPhysSoftbodyDesc_t::GetCapsules() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: PhysSoftbodyDesc_t->Capsules(ptr=%p)", m_ptr));
    CUtlVector<GRnSoftbodyCapsule_t>* vec = GetSchemaValue<CUtlVector<GRnSoftbodyCapsule_t>*>(m_ptr, "PhysSoftbodyDesc_t", "m_Capsules"); std::vector<GRnSoftbodyCapsule_t> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GPhysSoftbodyDesc_t::SetCapsules(std::vector<GRnSoftbodyCapsule_t> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: PhysSoftbodyDesc_t->Capsules(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<GRnSoftbodyCapsule_t>(m_ptr, "PhysSoftbodyDesc_t", "m_Capsules", true, value);
}
std::vector<CUtlString> GPhysSoftbodyDesc_t::GetParticleBoneName() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: PhysSoftbodyDesc_t->ParticleBoneName(ptr=%p)", m_ptr));
    CUtlVector<CUtlString>* vec = GetSchemaValue<CUtlVector<CUtlString>*>(m_ptr, "PhysSoftbodyDesc_t", "m_ParticleBoneName"); std::vector<CUtlString> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GPhysSoftbodyDesc_t::SetParticleBoneName(std::vector<CUtlString> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: PhysSoftbodyDesc_t->ParticleBoneName(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<CUtlString>(m_ptr, "PhysSoftbodyDesc_t", "m_ParticleBoneName", true, value);
}
void* GPhysSoftbodyDesc_t::GetPtr() {
    return m_ptr;
}
std::string GPhysSoftbodyDesc_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GPhysSoftbodyDesc_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassPhysSoftbodyDesc_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GPhysSoftbodyDesc_t>("PhysSoftbodyDesc_t")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("ParticleBoneHash", &GPhysSoftbodyDesc_t::GetParticleBoneHash, &GPhysSoftbodyDesc_t::SetParticleBoneHash)
        .addProperty("Particles", &GPhysSoftbodyDesc_t::GetParticles, &GPhysSoftbodyDesc_t::SetParticles)
        .addProperty("Springs", &GPhysSoftbodyDesc_t::GetSprings, &GPhysSoftbodyDesc_t::SetSprings)
        .addProperty("Capsules", &GPhysSoftbodyDesc_t::GetCapsules, &GPhysSoftbodyDesc_t::SetCapsules)
        .addProperty("ParticleBoneName", &GPhysSoftbodyDesc_t::GetParticleBoneName, &GPhysSoftbodyDesc_t::SetParticleBoneName)
        .addFunction("ToPtr", &GPhysSoftbodyDesc_t::ToPtr)
        .addFunction("IsValid", &GPhysSoftbodyDesc_t::IsValid)
        .endClass();
}
GVMapResourceData_t::GVMapResourceData_t(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GVMapResourceData_t::GVMapResourceData_t(void *ptr) {
    m_ptr = ptr;
}
void* GVMapResourceData_t::GetPtr() {
    return m_ptr;
}
std::string GVMapResourceData_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GVMapResourceData_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassVMapResourceData_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GVMapResourceData_t>("VMapResourceData_t")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addFunction("ToPtr", &GVMapResourceData_t::ToPtr)
        .addFunction("IsValid", &GVMapResourceData_t::IsValid)
        .endClass();
}
GFeCtrlSoftOffset_t::GFeCtrlSoftOffset_t(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GFeCtrlSoftOffset_t::GFeCtrlSoftOffset_t(void *ptr) {
    m_ptr = ptr;
}
uint16_t GFeCtrlSoftOffset_t::GetCtrlParent() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FeCtrlSoftOffset_t->CtrlParent(ptr=%p)", m_ptr));
    return GetSchemaValue<uint16_t>(m_ptr, "FeCtrlSoftOffset_t", "nCtrlParent");
}
void GFeCtrlSoftOffset_t::SetCtrlParent(uint16_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FeCtrlSoftOffset_t->CtrlParent(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "FeCtrlSoftOffset_t", "nCtrlParent", true, value);
}
uint16_t GFeCtrlSoftOffset_t::GetCtrlChild() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FeCtrlSoftOffset_t->CtrlChild(ptr=%p)", m_ptr));
    return GetSchemaValue<uint16_t>(m_ptr, "FeCtrlSoftOffset_t", "nCtrlChild");
}
void GFeCtrlSoftOffset_t::SetCtrlChild(uint16_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FeCtrlSoftOffset_t->CtrlChild(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "FeCtrlSoftOffset_t", "nCtrlChild", true, value);
}
Vector GFeCtrlSoftOffset_t::GetOffset() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FeCtrlSoftOffset_t->Offset(ptr=%p)", m_ptr));
    return GetSchemaValue<Vector>(m_ptr, "FeCtrlSoftOffset_t", "vOffset");
}
void GFeCtrlSoftOffset_t::SetOffset(Vector value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FeCtrlSoftOffset_t->Offset(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "FeCtrlSoftOffset_t", "vOffset", true, value);
}
float GFeCtrlSoftOffset_t::GetAlpha() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FeCtrlSoftOffset_t->Alpha(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "FeCtrlSoftOffset_t", "flAlpha");
}
void GFeCtrlSoftOffset_t::SetAlpha(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FeCtrlSoftOffset_t->Alpha(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "FeCtrlSoftOffset_t", "flAlpha", true, value);
}
void* GFeCtrlSoftOffset_t::GetPtr() {
    return m_ptr;
}
std::string GFeCtrlSoftOffset_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GFeCtrlSoftOffset_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassFeCtrlSoftOffset_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GFeCtrlSoftOffset_t>("FeCtrlSoftOffset_t")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("CtrlParent", &GFeCtrlSoftOffset_t::GetCtrlParent, &GFeCtrlSoftOffset_t::SetCtrlParent)
        .addProperty("CtrlChild", &GFeCtrlSoftOffset_t::GetCtrlChild, &GFeCtrlSoftOffset_t::SetCtrlChild)
        .addProperty("Offset", &GFeCtrlSoftOffset_t::GetOffset, &GFeCtrlSoftOffset_t::SetOffset)
        .addProperty("Alpha", &GFeCtrlSoftOffset_t::GetAlpha, &GFeCtrlSoftOffset_t::SetAlpha)
        .addFunction("ToPtr", &GFeCtrlSoftOffset_t::ToPtr)
        .addFunction("IsValid", &GFeCtrlSoftOffset_t::IsValid)
        .endClass();
}
GCMorphBundleData::GCMorphBundleData(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCMorphBundleData::GCMorphBundleData(void *ptr) {
    m_ptr = ptr;
}
float GCMorphBundleData::GetULeftSrc() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CMorphBundleData->ULeftSrc(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CMorphBundleData", "m_flULeftSrc");
}
void GCMorphBundleData::SetULeftSrc(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CMorphBundleData->ULeftSrc(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CMorphBundleData", "m_flULeftSrc", false, value);
}
float GCMorphBundleData::GetVTopSrc() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CMorphBundleData->VTopSrc(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CMorphBundleData", "m_flVTopSrc");
}
void GCMorphBundleData::SetVTopSrc(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CMorphBundleData->VTopSrc(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CMorphBundleData", "m_flVTopSrc", false, value);
}
std::vector<float32> GCMorphBundleData::GetOffsets() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CMorphBundleData->Offsets(ptr=%p)", m_ptr));
    CUtlVector<float32>* vec = GetSchemaValue<CUtlVector<float32>*>(m_ptr, "CMorphBundleData", "m_offsets"); std::vector<float32> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCMorphBundleData::SetOffsets(std::vector<float32> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CMorphBundleData->Offsets(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<float32>(m_ptr, "CMorphBundleData", "m_offsets", false, value);
}
std::vector<float32> GCMorphBundleData::GetRanges() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CMorphBundleData->Ranges(ptr=%p)", m_ptr));
    CUtlVector<float32>* vec = GetSchemaValue<CUtlVector<float32>*>(m_ptr, "CMorphBundleData", "m_ranges"); std::vector<float32> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCMorphBundleData::SetRanges(std::vector<float32> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CMorphBundleData->Ranges(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<float32>(m_ptr, "CMorphBundleData", "m_ranges", false, value);
}
void* GCMorphBundleData::GetPtr() {
    return m_ptr;
}
std::string GCMorphBundleData::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCMorphBundleData::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCMorphBundleData(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCMorphBundleData>("CMorphBundleData")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("ULeftSrc", &GCMorphBundleData::GetULeftSrc, &GCMorphBundleData::SetULeftSrc)
        .addProperty("VTopSrc", &GCMorphBundleData::GetVTopSrc, &GCMorphBundleData::SetVTopSrc)
        .addProperty("Offsets", &GCMorphBundleData::GetOffsets, &GCMorphBundleData::SetOffsets)
        .addProperty("Ranges", &GCMorphBundleData::GetRanges, &GCMorphBundleData::SetRanges)
        .addFunction("ToPtr", &GCMorphBundleData::ToPtr)
        .addFunction("IsValid", &GCMorphBundleData::IsValid)
        .endClass();
}
GCNmBoneMask::GCNmBoneMask(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCNmBoneMask::GCNmBoneMask(void *ptr) {
    m_ptr = ptr;
}
GCNmBoneMask GCNmBoneMask::GetWeightInfo() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CNmBoneMask->WeightInfo(ptr=%p)", m_ptr));
    GCNmBoneMask value(GetSchemaPtr(m_ptr, "CNmBoneMask", "m_weightInfo"));
    return value;
}
void GCNmBoneMask::SetWeightInfo(GCNmBoneMask value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CNmBoneMask->WeightInfo(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'WeightInfo' is not possible.\n");
}
std::vector<float32> GCNmBoneMask::GetWeights() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CNmBoneMask->Weights(ptr=%p)", m_ptr));
    CUtlVector<float32>* vec = GetSchemaValue<CUtlVector<float32>*>(m_ptr, "CNmBoneMask", "m_weights"); std::vector<float32> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCNmBoneMask::SetWeights(std::vector<float32> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CNmBoneMask->Weights(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<float32>(m_ptr, "CNmBoneMask", "m_weights", false, value);
}
void* GCNmBoneMask::GetPtr() {
    return m_ptr;
}
std::string GCNmBoneMask::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCNmBoneMask::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCNmBoneMask(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCNmBoneMask>("CNmBoneMask")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("WeightInfo", &GCNmBoneMask::GetWeightInfo, &GCNmBoneMask::SetWeightInfo)
        .addProperty("Weights", &GCNmBoneMask::GetWeights, &GCNmBoneMask::SetWeights)
        .addFunction("ToPtr", &GCNmBoneMask::ToPtr)
        .addFunction("IsValid", &GCNmBoneMask::IsValid)
        .endClass();
}
GCAudioEmphasisSample::GCAudioEmphasisSample(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCAudioEmphasisSample::GCAudioEmphasisSample(void *ptr) {
    m_ptr = ptr;
}
float GCAudioEmphasisSample::GetTime() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CAudioEmphasisSample->Time(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CAudioEmphasisSample", "m_flTime");
}
void GCAudioEmphasisSample::SetTime(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CAudioEmphasisSample->Time(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CAudioEmphasisSample", "m_flTime", false, value);
}
float GCAudioEmphasisSample::GetValue() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CAudioEmphasisSample->Value(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CAudioEmphasisSample", "m_flValue");
}
void GCAudioEmphasisSample::SetValue(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CAudioEmphasisSample->Value(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CAudioEmphasisSample", "m_flValue", false, value);
}
void* GCAudioEmphasisSample::GetPtr() {
    return m_ptr;
}
std::string GCAudioEmphasisSample::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCAudioEmphasisSample::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCAudioEmphasisSample(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCAudioEmphasisSample>("CAudioEmphasisSample")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Time", &GCAudioEmphasisSample::GetTime, &GCAudioEmphasisSample::SetTime)
        .addProperty("Value", &GCAudioEmphasisSample::GetValue, &GCAudioEmphasisSample::SetValue)
        .addFunction("ToPtr", &GCAudioEmphasisSample::ToPtr)
        .addFunction("IsValid", &GCAudioEmphasisSample::IsValid)
        .endClass();
}
GCNmFrameSnapEvent::GCNmFrameSnapEvent(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCNmFrameSnapEvent::GCNmFrameSnapEvent(void *ptr) {
    m_ptr = ptr;
}
uint64_t GCNmFrameSnapEvent::GetFrameSnapMode() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CNmFrameSnapEvent->FrameSnapMode(ptr=%p)", m_ptr));
    return GetSchemaValue<uint64_t>(m_ptr, "CNmFrameSnapEvent", "m_frameSnapMode");
}
void GCNmFrameSnapEvent::SetFrameSnapMode(uint64_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CNmFrameSnapEvent->FrameSnapMode(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CNmFrameSnapEvent", "m_frameSnapMode", false, value);
}
void* GCNmFrameSnapEvent::GetPtr() {
    return m_ptr;
}
std::string GCNmFrameSnapEvent::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCNmFrameSnapEvent::IsValid() {
    return (m_ptr != nullptr);
}
GCNmEvent GCNmFrameSnapEvent::GetParent() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CNmFrameSnapEvent::GetParent(ptr=%p)", m_ptr));
    GCNmEvent value(m_ptr);
    return value;
}
void GCNmFrameSnapEvent::SetParent(GCNmEvent value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CNmFrameSnapEvent::SetParent(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCNmFrameSnapEvent(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCNmFrameSnapEvent>("CNmFrameSnapEvent")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("FrameSnapMode", &GCNmFrameSnapEvent::GetFrameSnapMode, &GCNmFrameSnapEvent::SetFrameSnapMode)
        .addProperty("Parent", &GCNmFrameSnapEvent::GetParent, &GCNmFrameSnapEvent::SetParent)
        .addFunction("ToPtr", &GCNmFrameSnapEvent::ToPtr)
        .addFunction("IsValid", &GCNmFrameSnapEvent::IsValid)
        .endClass();
}
GCJumpHelperUpdateNode::GCJumpHelperUpdateNode(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCJumpHelperUpdateNode::GCJumpHelperUpdateNode(void *ptr) {
    m_ptr = ptr;
}
GCAnimParamHandle GCJumpHelperUpdateNode::GetTargetParam() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CJumpHelperUpdateNode->TargetParam(ptr=%p)", m_ptr));
    GCAnimParamHandle value(GetSchemaPtr(m_ptr, "CJumpHelperUpdateNode", "m_hTargetParam"));
    return value;
}
void GCJumpHelperUpdateNode::SetTargetParam(GCAnimParamHandle value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CJumpHelperUpdateNode->TargetParam(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'TargetParam' is not possible.\n");
}
Vector GCJumpHelperUpdateNode::GetOriginalJumpMovement() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CJumpHelperUpdateNode->OriginalJumpMovement(ptr=%p)", m_ptr));
    return GetSchemaValue<Vector>(m_ptr, "CJumpHelperUpdateNode", "m_flOriginalJumpMovement");
}
void GCJumpHelperUpdateNode::SetOriginalJumpMovement(Vector value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CJumpHelperUpdateNode->OriginalJumpMovement(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CJumpHelperUpdateNode", "m_flOriginalJumpMovement", false, value);
}
float GCJumpHelperUpdateNode::GetOriginalJumpDuration() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CJumpHelperUpdateNode->OriginalJumpDuration(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CJumpHelperUpdateNode", "m_flOriginalJumpDuration");
}
void GCJumpHelperUpdateNode::SetOriginalJumpDuration(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CJumpHelperUpdateNode->OriginalJumpDuration(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CJumpHelperUpdateNode", "m_flOriginalJumpDuration", false, value);
}
float GCJumpHelperUpdateNode::GetJumpStartCycle() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CJumpHelperUpdateNode->JumpStartCycle(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CJumpHelperUpdateNode", "m_flJumpStartCycle");
}
void GCJumpHelperUpdateNode::SetJumpStartCycle(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CJumpHelperUpdateNode->JumpStartCycle(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CJumpHelperUpdateNode", "m_flJumpStartCycle", false, value);
}
float GCJumpHelperUpdateNode::GetJumpEndCycle() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CJumpHelperUpdateNode->JumpEndCycle(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CJumpHelperUpdateNode", "m_flJumpEndCycle");
}
void GCJumpHelperUpdateNode::SetJumpEndCycle(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CJumpHelperUpdateNode->JumpEndCycle(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CJumpHelperUpdateNode", "m_flJumpEndCycle", false, value);
}
uint64_t GCJumpHelperUpdateNode::GetCorrectionMethod() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CJumpHelperUpdateNode->CorrectionMethod(ptr=%p)", m_ptr));
    return GetSchemaValue<uint64_t>(m_ptr, "CJumpHelperUpdateNode", "m_eCorrectionMethod");
}
void GCJumpHelperUpdateNode::SetCorrectionMethod(uint64_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CJumpHelperUpdateNode->CorrectionMethod(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CJumpHelperUpdateNode", "m_eCorrectionMethod", false, value);
}
std::vector<bool> GCJumpHelperUpdateNode::GetTranslationAxis() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CJumpHelperUpdateNode->TranslationAxis(ptr=%p,size=3)", m_ptr));
    bool* outValue = (bool*)GetSchemaPtr(m_ptr, "CJumpHelperUpdateNode", "m_bTranslationAxis"); std::vector<bool> ret; for(int i = 0; i < 3; i++) { ret.push_back(outValue[i]); } return ret;
}
void GCJumpHelperUpdateNode::SetTranslationAxis(std::vector<bool> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CJumpHelperUpdateNode->TranslationAxis(ptr=%p,size=3)", m_ptr));
    if(value.size() != 3) return PLUGIN_PRINT("Schema SDK", "Field 'TranslationAxis' needs to have 3 values.\n");
    auto val = GetSchemaValuePtr<bool>(m_ptr, "CJumpHelperUpdateNode", "m_bTranslationAxis");
    for(size_t i = 0; i < value.size(); i++) val[i] = value[i];
}
bool GCJumpHelperUpdateNode::GetScaleSpeed() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CJumpHelperUpdateNode->ScaleSpeed(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "CJumpHelperUpdateNode", "m_bScaleSpeed");
}
void GCJumpHelperUpdateNode::SetScaleSpeed(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CJumpHelperUpdateNode->ScaleSpeed(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CJumpHelperUpdateNode", "m_bScaleSpeed", false, value);
}
void* GCJumpHelperUpdateNode::GetPtr() {
    return m_ptr;
}
std::string GCJumpHelperUpdateNode::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCJumpHelperUpdateNode::IsValid() {
    return (m_ptr != nullptr);
}
GCSequenceUpdateNode GCJumpHelperUpdateNode::GetParent() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CJumpHelperUpdateNode::GetParent(ptr=%p)", m_ptr));
    GCSequenceUpdateNode value(m_ptr);
    return value;
}
void GCJumpHelperUpdateNode::SetParent(GCSequenceUpdateNode value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CJumpHelperUpdateNode::SetParent(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCJumpHelperUpdateNode(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCJumpHelperUpdateNode>("CJumpHelperUpdateNode")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("TargetParam", &GCJumpHelperUpdateNode::GetTargetParam, &GCJumpHelperUpdateNode::SetTargetParam)
        .addProperty("OriginalJumpMovement", &GCJumpHelperUpdateNode::GetOriginalJumpMovement, &GCJumpHelperUpdateNode::SetOriginalJumpMovement)
        .addProperty("OriginalJumpDuration", &GCJumpHelperUpdateNode::GetOriginalJumpDuration, &GCJumpHelperUpdateNode::SetOriginalJumpDuration)
        .addProperty("JumpStartCycle", &GCJumpHelperUpdateNode::GetJumpStartCycle, &GCJumpHelperUpdateNode::SetJumpStartCycle)
        .addProperty("JumpEndCycle", &GCJumpHelperUpdateNode::GetJumpEndCycle, &GCJumpHelperUpdateNode::SetJumpEndCycle)
        .addProperty("CorrectionMethod", &GCJumpHelperUpdateNode::GetCorrectionMethod, &GCJumpHelperUpdateNode::SetCorrectionMethod)
        .addProperty("TranslationAxis", &GCJumpHelperUpdateNode::GetTranslationAxis, &GCJumpHelperUpdateNode::SetTranslationAxis)
        .addProperty("ScaleSpeed", &GCJumpHelperUpdateNode::GetScaleSpeed, &GCJumpHelperUpdateNode::SetScaleSpeed)
        .addProperty("Parent", &GCJumpHelperUpdateNode::GetParent, &GCJumpHelperUpdateNode::SetParent)
        .addFunction("ToPtr", &GCJumpHelperUpdateNode::ToPtr)
        .addFunction("IsValid", &GCJumpHelperUpdateNode::IsValid)
        .endClass();
}
GSolveIKChainPoseOpFixedSettings_t::GSolveIKChainPoseOpFixedSettings_t(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GSolveIKChainPoseOpFixedSettings_t::GSolveIKChainPoseOpFixedSettings_t(void *ptr) {
    m_ptr = ptr;
}
std::vector<GChainToSolveData_t> GSolveIKChainPoseOpFixedSettings_t::GetChainsToSolveData() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: SolveIKChainPoseOpFixedSettings_t->ChainsToSolveData(ptr=%p)", m_ptr));
    CUtlVector<GChainToSolveData_t>* vec = GetSchemaValue<CUtlVector<GChainToSolveData_t>*>(m_ptr, "SolveIKChainPoseOpFixedSettings_t", "m_ChainsToSolveData"); std::vector<GChainToSolveData_t> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GSolveIKChainPoseOpFixedSettings_t::SetChainsToSolveData(std::vector<GChainToSolveData_t> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: SolveIKChainPoseOpFixedSettings_t->ChainsToSolveData(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<GChainToSolveData_t>(m_ptr, "SolveIKChainPoseOpFixedSettings_t", "m_ChainsToSolveData", true, value);
}
bool GSolveIKChainPoseOpFixedSettings_t::GetMatchTargetOrientation() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: SolveIKChainPoseOpFixedSettings_t->MatchTargetOrientation(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "SolveIKChainPoseOpFixedSettings_t", "m_bMatchTargetOrientation");
}
void GSolveIKChainPoseOpFixedSettings_t::SetMatchTargetOrientation(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: SolveIKChainPoseOpFixedSettings_t->MatchTargetOrientation(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "SolveIKChainPoseOpFixedSettings_t", "m_bMatchTargetOrientation", true, value);
}
void* GSolveIKChainPoseOpFixedSettings_t::GetPtr() {
    return m_ptr;
}
std::string GSolveIKChainPoseOpFixedSettings_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GSolveIKChainPoseOpFixedSettings_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassSolveIKChainPoseOpFixedSettings_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GSolveIKChainPoseOpFixedSettings_t>("SolveIKChainPoseOpFixedSettings_t")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("ChainsToSolveData", &GSolveIKChainPoseOpFixedSettings_t::GetChainsToSolveData, &GSolveIKChainPoseOpFixedSettings_t::SetChainsToSolveData)
        .addProperty("MatchTargetOrientation", &GSolveIKChainPoseOpFixedSettings_t::GetMatchTargetOrientation, &GSolveIKChainPoseOpFixedSettings_t::SetMatchTargetOrientation)
        .addFunction("ToPtr", &GSolveIKChainPoseOpFixedSettings_t::ToPtr)
        .addFunction("IsValid", &GSolveIKChainPoseOpFixedSettings_t::IsValid)
        .endClass();
}
GCMaterialAttributeAnimTag::GCMaterialAttributeAnimTag(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCMaterialAttributeAnimTag::GCMaterialAttributeAnimTag(void *ptr) {
    m_ptr = ptr;
}
std::string GCMaterialAttributeAnimTag::GetAttributeName() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CMaterialAttributeAnimTag->AttributeName(ptr=%p)", m_ptr));
    return GetSchemaValue<CUtlString>(m_ptr, "CMaterialAttributeAnimTag", "m_AttributeName").Get();
}
void GCMaterialAttributeAnimTag::SetAttributeName(std::string value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CMaterialAttributeAnimTag->AttributeName(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CMaterialAttributeAnimTag", "m_AttributeName", false, CUtlString(value.c_str()));
}
uint64_t GCMaterialAttributeAnimTag::GetAttributeType() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CMaterialAttributeAnimTag->AttributeType(ptr=%p)", m_ptr));
    return GetSchemaValue<uint64_t>(m_ptr, "CMaterialAttributeAnimTag", "m_AttributeType");
}
void GCMaterialAttributeAnimTag::SetAttributeType(uint64_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CMaterialAttributeAnimTag->AttributeType(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CMaterialAttributeAnimTag", "m_AttributeType", false, value);
}
float GCMaterialAttributeAnimTag::GetValue() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CMaterialAttributeAnimTag->Value(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CMaterialAttributeAnimTag", "m_flValue");
}
void GCMaterialAttributeAnimTag::SetValue(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CMaterialAttributeAnimTag->Value(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CMaterialAttributeAnimTag", "m_flValue", false, value);
}
Color GCMaterialAttributeAnimTag::GetColor() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CMaterialAttributeAnimTag->Color(ptr=%p)", m_ptr));
    return GetSchemaValue<Color>(m_ptr, "CMaterialAttributeAnimTag", "m_Color");
}
void GCMaterialAttributeAnimTag::SetColor(Color value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CMaterialAttributeAnimTag->Color(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CMaterialAttributeAnimTag", "m_Color", false, value);
}
void* GCMaterialAttributeAnimTag::GetPtr() {
    return m_ptr;
}
std::string GCMaterialAttributeAnimTag::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCMaterialAttributeAnimTag::IsValid() {
    return (m_ptr != nullptr);
}
GCAnimTagBase GCMaterialAttributeAnimTag::GetParent() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CMaterialAttributeAnimTag::GetParent(ptr=%p)", m_ptr));
    GCAnimTagBase value(m_ptr);
    return value;
}
void GCMaterialAttributeAnimTag::SetParent(GCAnimTagBase value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CMaterialAttributeAnimTag::SetParent(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCMaterialAttributeAnimTag(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCMaterialAttributeAnimTag>("CMaterialAttributeAnimTag")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("AttributeName", &GCMaterialAttributeAnimTag::GetAttributeName, &GCMaterialAttributeAnimTag::SetAttributeName)
        .addProperty("AttributeType", &GCMaterialAttributeAnimTag::GetAttributeType, &GCMaterialAttributeAnimTag::SetAttributeType)
        .addProperty("Value", &GCMaterialAttributeAnimTag::GetValue, &GCMaterialAttributeAnimTag::SetValue)
        .addProperty("Color", &GCMaterialAttributeAnimTag::GetColor, &GCMaterialAttributeAnimTag::SetColor)
        .addProperty("Parent", &GCMaterialAttributeAnimTag::GetParent, &GCMaterialAttributeAnimTag::SetParent)
        .addFunction("ToPtr", &GCMaterialAttributeAnimTag::ToPtr)
        .addFunction("IsValid", &GCMaterialAttributeAnimTag::IsValid)
        .endClass();
}
GCAnimComponentUpdater::GCAnimComponentUpdater(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCAnimComponentUpdater::GCAnimComponentUpdater(void *ptr) {
    m_ptr = ptr;
}
std::string GCAnimComponentUpdater::GetName() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CAnimComponentUpdater->Name(ptr=%p)", m_ptr));
    return GetSchemaValue<CUtlString>(m_ptr, "CAnimComponentUpdater", "m_name").Get();
}
void GCAnimComponentUpdater::SetName(std::string value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CAnimComponentUpdater->Name(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CAnimComponentUpdater", "m_name", false, CUtlString(value.c_str()));
}
GAnimComponentID GCAnimComponentUpdater::GetId() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CAnimComponentUpdater->Id(ptr=%p)", m_ptr));
    GAnimComponentID value(GetSchemaPtr(m_ptr, "CAnimComponentUpdater", "m_id"));
    return value;
}
void GCAnimComponentUpdater::SetId(GAnimComponentID value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CAnimComponentUpdater->Id(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Id' is not possible.\n");
}
uint64_t GCAnimComponentUpdater::GetNetworkMode() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CAnimComponentUpdater->NetworkMode(ptr=%p)", m_ptr));
    return GetSchemaValue<uint64_t>(m_ptr, "CAnimComponentUpdater", "m_networkMode");
}
void GCAnimComponentUpdater::SetNetworkMode(uint64_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CAnimComponentUpdater->NetworkMode(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CAnimComponentUpdater", "m_networkMode", false, value);
}
bool GCAnimComponentUpdater::GetStartEnabled() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CAnimComponentUpdater->StartEnabled(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "CAnimComponentUpdater", "m_bStartEnabled");
}
void GCAnimComponentUpdater::SetStartEnabled(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CAnimComponentUpdater->StartEnabled(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CAnimComponentUpdater", "m_bStartEnabled", false, value);
}
void* GCAnimComponentUpdater::GetPtr() {
    return m_ptr;
}
std::string GCAnimComponentUpdater::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCAnimComponentUpdater::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCAnimComponentUpdater(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCAnimComponentUpdater>("CAnimComponentUpdater")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Name", &GCAnimComponentUpdater::GetName, &GCAnimComponentUpdater::SetName)
        .addProperty("Id", &GCAnimComponentUpdater::GetId, &GCAnimComponentUpdater::SetId)
        .addProperty("NetworkMode", &GCAnimComponentUpdater::GetNetworkMode, &GCAnimComponentUpdater::SetNetworkMode)
        .addProperty("StartEnabled", &GCAnimComponentUpdater::GetStartEnabled, &GCAnimComponentUpdater::SetStartEnabled)
        .addFunction("ToPtr", &GCAnimComponentUpdater::ToPtr)
        .addFunction("IsValid", &GCAnimComponentUpdater::IsValid)
        .endClass();
}
GCReplicationParameters::GCReplicationParameters(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCReplicationParameters::GCReplicationParameters(void *ptr) {
    m_ptr = ptr;
}
uint64_t GCReplicationParameters::GetReplicationMode() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CReplicationParameters->ReplicationMode(ptr=%p)", m_ptr));
    return GetSchemaValue<uint64_t>(m_ptr, "CReplicationParameters", "m_nReplicationMode");
}
void GCReplicationParameters::SetReplicationMode(uint64_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CReplicationParameters->ReplicationMode(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CReplicationParameters", "m_nReplicationMode", false, value);
}
bool GCReplicationParameters::GetScaleChildParticleRadii() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CReplicationParameters->ScaleChildParticleRadii(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "CReplicationParameters", "m_bScaleChildParticleRadii");
}
void GCReplicationParameters::SetScaleChildParticleRadii(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CReplicationParameters->ScaleChildParticleRadii(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CReplicationParameters", "m_bScaleChildParticleRadii", false, value);
}
GCParticleCollectionFloatInput GCReplicationParameters::GetMinRandomRadiusScale() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CReplicationParameters->MinRandomRadiusScale(ptr=%p)", m_ptr));
    GCParticleCollectionFloatInput value(GetSchemaPtr(m_ptr, "CReplicationParameters", "m_flMinRandomRadiusScale"));
    return value;
}
void GCReplicationParameters::SetMinRandomRadiusScale(GCParticleCollectionFloatInput value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CReplicationParameters->MinRandomRadiusScale(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'MinRandomRadiusScale' is not possible.\n");
}
GCParticleCollectionFloatInput GCReplicationParameters::GetMaxRandomRadiusScale() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CReplicationParameters->MaxRandomRadiusScale(ptr=%p)", m_ptr));
    GCParticleCollectionFloatInput value(GetSchemaPtr(m_ptr, "CReplicationParameters", "m_flMaxRandomRadiusScale"));
    return value;
}
void GCReplicationParameters::SetMaxRandomRadiusScale(GCParticleCollectionFloatInput value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CReplicationParameters->MaxRandomRadiusScale(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'MaxRandomRadiusScale' is not possible.\n");
}
GCParticleCollectionFloatInput GCReplicationParameters::GetModellingScale() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CReplicationParameters->ModellingScale(ptr=%p)", m_ptr));
    GCParticleCollectionFloatInput value(GetSchemaPtr(m_ptr, "CReplicationParameters", "m_flModellingScale"));
    return value;
}
void GCReplicationParameters::SetModellingScale(GCParticleCollectionFloatInput value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CReplicationParameters->ModellingScale(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'ModellingScale' is not possible.\n");
}
void* GCReplicationParameters::GetPtr() {
    return m_ptr;
}
std::string GCReplicationParameters::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCReplicationParameters::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCReplicationParameters(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCReplicationParameters>("CReplicationParameters")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("ReplicationMode", &GCReplicationParameters::GetReplicationMode, &GCReplicationParameters::SetReplicationMode)
        .addProperty("ScaleChildParticleRadii", &GCReplicationParameters::GetScaleChildParticleRadii, &GCReplicationParameters::SetScaleChildParticleRadii)
        .addProperty("MinRandomRadiusScale", &GCReplicationParameters::GetMinRandomRadiusScale, &GCReplicationParameters::SetMinRandomRadiusScale)
        .addProperty("MaxRandomRadiusScale", &GCReplicationParameters::GetMaxRandomRadiusScale, &GCReplicationParameters::SetMaxRandomRadiusScale)
        .addProperty("ModellingScale", &GCReplicationParameters::GetModellingScale, &GCReplicationParameters::SetModellingScale)
        .addFunction("ToPtr", &GCReplicationParameters::ToPtr)
        .addFunction("IsValid", &GCReplicationParameters::IsValid)
        .endClass();
}
GVMixEnvelopeDesc_t::GVMixEnvelopeDesc_t(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GVMixEnvelopeDesc_t::GVMixEnvelopeDesc_t(void *ptr) {
    m_ptr = ptr;
}
float GVMixEnvelopeDesc_t::GetAttackTimeMS() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: VMixEnvelopeDesc_t->AttackTimeMS(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "VMixEnvelopeDesc_t", "m_flAttackTimeMS");
}
void GVMixEnvelopeDesc_t::SetAttackTimeMS(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: VMixEnvelopeDesc_t->AttackTimeMS(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "VMixEnvelopeDesc_t", "m_flAttackTimeMS", true, value);
}
float GVMixEnvelopeDesc_t::GetHoldTimeMS() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: VMixEnvelopeDesc_t->HoldTimeMS(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "VMixEnvelopeDesc_t", "m_flHoldTimeMS");
}
void GVMixEnvelopeDesc_t::SetHoldTimeMS(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: VMixEnvelopeDesc_t->HoldTimeMS(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "VMixEnvelopeDesc_t", "m_flHoldTimeMS", true, value);
}
float GVMixEnvelopeDesc_t::GetReleaseTimeMS() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: VMixEnvelopeDesc_t->ReleaseTimeMS(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "VMixEnvelopeDesc_t", "m_flReleaseTimeMS");
}
void GVMixEnvelopeDesc_t::SetReleaseTimeMS(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: VMixEnvelopeDesc_t->ReleaseTimeMS(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "VMixEnvelopeDesc_t", "m_flReleaseTimeMS", true, value);
}
void* GVMixEnvelopeDesc_t::GetPtr() {
    return m_ptr;
}
std::string GVMixEnvelopeDesc_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GVMixEnvelopeDesc_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassVMixEnvelopeDesc_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GVMixEnvelopeDesc_t>("VMixEnvelopeDesc_t")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("AttackTimeMS", &GVMixEnvelopeDesc_t::GetAttackTimeMS, &GVMixEnvelopeDesc_t::SetAttackTimeMS)
        .addProperty("HoldTimeMS", &GVMixEnvelopeDesc_t::GetHoldTimeMS, &GVMixEnvelopeDesc_t::SetHoldTimeMS)
        .addProperty("ReleaseTimeMS", &GVMixEnvelopeDesc_t::GetReleaseTimeMS, &GVMixEnvelopeDesc_t::SetReleaseTimeMS)
        .addFunction("ToPtr", &GVMixEnvelopeDesc_t::ToPtr)
        .addFunction("IsValid", &GVMixEnvelopeDesc_t::IsValid)
        .endClass();
}
GCNmValueNode::GCNmValueNode(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCNmValueNode::GCNmValueNode(void *ptr) {
    m_ptr = ptr;
}
void* GCNmValueNode::GetPtr() {
    return m_ptr;
}
std::string GCNmValueNode::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCNmValueNode::IsValid() {
    return (m_ptr != nullptr);
}
GCNmGraphNode GCNmValueNode::GetParent() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CNmValueNode::GetParent(ptr=%p)", m_ptr));
    GCNmGraphNode value(m_ptr);
    return value;
}
void GCNmValueNode::SetParent(GCNmGraphNode value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CNmValueNode::SetParent(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCNmValueNode(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCNmValueNode>("CNmValueNode")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Parent", &GCNmValueNode::GetParent, &GCNmValueNode::SetParent)
        .addFunction("ToPtr", &GCNmValueNode::ToPtr)
        .addFunction("IsValid", &GCNmValueNode::IsValid)
        .endClass();
}
GCFollowPathUpdateNode::GCFollowPathUpdateNode(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCFollowPathUpdateNode::GCFollowPathUpdateNode(void *ptr) {
    m_ptr = ptr;
}
float GCFollowPathUpdateNode::GetBlendOutTime() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CFollowPathUpdateNode->BlendOutTime(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CFollowPathUpdateNode", "m_flBlendOutTime");
}
void GCFollowPathUpdateNode::SetBlendOutTime(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CFollowPathUpdateNode->BlendOutTime(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CFollowPathUpdateNode", "m_flBlendOutTime", false, value);
}
bool GCFollowPathUpdateNode::GetBlockNonPathMovement() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CFollowPathUpdateNode->BlockNonPathMovement(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "CFollowPathUpdateNode", "m_bBlockNonPathMovement");
}
void GCFollowPathUpdateNode::SetBlockNonPathMovement(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CFollowPathUpdateNode->BlockNonPathMovement(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CFollowPathUpdateNode", "m_bBlockNonPathMovement", false, value);
}
bool GCFollowPathUpdateNode::GetStopFeetAtGoal() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CFollowPathUpdateNode->StopFeetAtGoal(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "CFollowPathUpdateNode", "m_bStopFeetAtGoal");
}
void GCFollowPathUpdateNode::SetStopFeetAtGoal(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CFollowPathUpdateNode->StopFeetAtGoal(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CFollowPathUpdateNode", "m_bStopFeetAtGoal", false, value);
}
bool GCFollowPathUpdateNode::GetScaleSpeed() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CFollowPathUpdateNode->ScaleSpeed(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "CFollowPathUpdateNode", "m_bScaleSpeed");
}
void GCFollowPathUpdateNode::SetScaleSpeed(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CFollowPathUpdateNode->ScaleSpeed(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CFollowPathUpdateNode", "m_bScaleSpeed", false, value);
}
float GCFollowPathUpdateNode::GetScale() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CFollowPathUpdateNode->Scale(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CFollowPathUpdateNode", "m_flScale");
}
void GCFollowPathUpdateNode::SetScale(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CFollowPathUpdateNode->Scale(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CFollowPathUpdateNode", "m_flScale", false, value);
}
float GCFollowPathUpdateNode::GetMinAngle() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CFollowPathUpdateNode->MinAngle(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CFollowPathUpdateNode", "m_flMinAngle");
}
void GCFollowPathUpdateNode::SetMinAngle(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CFollowPathUpdateNode->MinAngle(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CFollowPathUpdateNode", "m_flMinAngle", false, value);
}
float GCFollowPathUpdateNode::GetMaxAngle() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CFollowPathUpdateNode->MaxAngle(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CFollowPathUpdateNode", "m_flMaxAngle");
}
void GCFollowPathUpdateNode::SetMaxAngle(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CFollowPathUpdateNode->MaxAngle(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CFollowPathUpdateNode", "m_flMaxAngle", false, value);
}
float GCFollowPathUpdateNode::GetSpeedScaleBlending() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CFollowPathUpdateNode->SpeedScaleBlending(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CFollowPathUpdateNode", "m_flSpeedScaleBlending");
}
void GCFollowPathUpdateNode::SetSpeedScaleBlending(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CFollowPathUpdateNode->SpeedScaleBlending(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CFollowPathUpdateNode", "m_flSpeedScaleBlending", false, value);
}
GCAnimInputDamping GCFollowPathUpdateNode::GetTurnDamping() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CFollowPathUpdateNode->TurnDamping(ptr=%p)", m_ptr));
    GCAnimInputDamping value(GetSchemaPtr(m_ptr, "CFollowPathUpdateNode", "m_turnDamping"));
    return value;
}
void GCFollowPathUpdateNode::SetTurnDamping(GCAnimInputDamping value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CFollowPathUpdateNode->TurnDamping(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'TurnDamping' is not possible.\n");
}
uint64_t GCFollowPathUpdateNode::GetFacingTarget() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CFollowPathUpdateNode->FacingTarget(ptr=%p)", m_ptr));
    return GetSchemaValue<uint64_t>(m_ptr, "CFollowPathUpdateNode", "m_facingTarget");
}
void GCFollowPathUpdateNode::SetFacingTarget(uint64_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CFollowPathUpdateNode->FacingTarget(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CFollowPathUpdateNode", "m_facingTarget", false, value);
}
GCAnimParamHandle GCFollowPathUpdateNode::GetParam() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CFollowPathUpdateNode->Param(ptr=%p)", m_ptr));
    GCAnimParamHandle value(GetSchemaPtr(m_ptr, "CFollowPathUpdateNode", "m_hParam"));
    return value;
}
void GCFollowPathUpdateNode::SetParam(GCAnimParamHandle value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CFollowPathUpdateNode->Param(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Param' is not possible.\n");
}
float GCFollowPathUpdateNode::GetTurnToFaceOffset() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CFollowPathUpdateNode->TurnToFaceOffset(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CFollowPathUpdateNode", "m_flTurnToFaceOffset");
}
void GCFollowPathUpdateNode::SetTurnToFaceOffset(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CFollowPathUpdateNode->TurnToFaceOffset(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CFollowPathUpdateNode", "m_flTurnToFaceOffset", false, value);
}
bool GCFollowPathUpdateNode::GetTurnToFace() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CFollowPathUpdateNode->TurnToFace(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "CFollowPathUpdateNode", "m_bTurnToFace");
}
void GCFollowPathUpdateNode::SetTurnToFace(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CFollowPathUpdateNode->TurnToFace(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CFollowPathUpdateNode", "m_bTurnToFace", false, value);
}
void* GCFollowPathUpdateNode::GetPtr() {
    return m_ptr;
}
std::string GCFollowPathUpdateNode::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCFollowPathUpdateNode::IsValid() {
    return (m_ptr != nullptr);
}
GCUnaryUpdateNode GCFollowPathUpdateNode::GetParent() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CFollowPathUpdateNode::GetParent(ptr=%p)", m_ptr));
    GCUnaryUpdateNode value(m_ptr);
    return value;
}
void GCFollowPathUpdateNode::SetParent(GCUnaryUpdateNode value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CFollowPathUpdateNode::SetParent(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCFollowPathUpdateNode(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCFollowPathUpdateNode>("CFollowPathUpdateNode")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("BlendOutTime", &GCFollowPathUpdateNode::GetBlendOutTime, &GCFollowPathUpdateNode::SetBlendOutTime)
        .addProperty("BlockNonPathMovement", &GCFollowPathUpdateNode::GetBlockNonPathMovement, &GCFollowPathUpdateNode::SetBlockNonPathMovement)
        .addProperty("StopFeetAtGoal", &GCFollowPathUpdateNode::GetStopFeetAtGoal, &GCFollowPathUpdateNode::SetStopFeetAtGoal)
        .addProperty("ScaleSpeed", &GCFollowPathUpdateNode::GetScaleSpeed, &GCFollowPathUpdateNode::SetScaleSpeed)
        .addProperty("Scale", &GCFollowPathUpdateNode::GetScale, &GCFollowPathUpdateNode::SetScale)
        .addProperty("MinAngle", &GCFollowPathUpdateNode::GetMinAngle, &GCFollowPathUpdateNode::SetMinAngle)
        .addProperty("MaxAngle", &GCFollowPathUpdateNode::GetMaxAngle, &GCFollowPathUpdateNode::SetMaxAngle)
        .addProperty("SpeedScaleBlending", &GCFollowPathUpdateNode::GetSpeedScaleBlending, &GCFollowPathUpdateNode::SetSpeedScaleBlending)
        .addProperty("TurnDamping", &GCFollowPathUpdateNode::GetTurnDamping, &GCFollowPathUpdateNode::SetTurnDamping)
        .addProperty("FacingTarget", &GCFollowPathUpdateNode::GetFacingTarget, &GCFollowPathUpdateNode::SetFacingTarget)
        .addProperty("Param", &GCFollowPathUpdateNode::GetParam, &GCFollowPathUpdateNode::SetParam)
        .addProperty("TurnToFaceOffset", &GCFollowPathUpdateNode::GetTurnToFaceOffset, &GCFollowPathUpdateNode::SetTurnToFaceOffset)
        .addProperty("TurnToFace", &GCFollowPathUpdateNode::GetTurnToFace, &GCFollowPathUpdateNode::SetTurnToFace)
        .addProperty("Parent", &GCFollowPathUpdateNode::GetParent, &GCFollowPathUpdateNode::SetParent)
        .addFunction("ToPtr", &GCFollowPathUpdateNode::ToPtr)
        .addFunction("IsValid", &GCFollowPathUpdateNode::IsValid)
        .endClass();
}
GEventClientPostSimulate_t::GEventClientPostSimulate_t(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GEventClientPostSimulate_t::GEventClientPostSimulate_t(void *ptr) {
    m_ptr = ptr;
}
void* GEventClientPostSimulate_t::GetPtr() {
    return m_ptr;
}
std::string GEventClientPostSimulate_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GEventClientPostSimulate_t::IsValid() {
    return (m_ptr != nullptr);
}
GEventSimulate_t GEventClientPostSimulate_t::GetParent() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("EventClientPostSimulate_t::GetParent(ptr=%p)", m_ptr));
    GEventSimulate_t value(m_ptr);
    return value;
}
void GEventClientPostSimulate_t::SetParent(GEventSimulate_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("EventClientPostSimulate_t::SetParent(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassEventClientPostSimulate_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GEventClientPostSimulate_t>("EventClientPostSimulate_t")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Parent", &GEventClientPostSimulate_t::GetParent, &GEventClientPostSimulate_t::SetParent)
        .addFunction("ToPtr", &GEventClientPostSimulate_t::ToPtr)
        .addFunction("IsValid", &GEventClientPostSimulate_t::IsValid)
        .endClass();
}
GAABB_t::GAABB_t(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GAABB_t::GAABB_t(void *ptr) {
    m_ptr = ptr;
}
Vector GAABB_t::GetMinBounds() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: AABB_t->MinBounds(ptr=%p)", m_ptr));
    return GetSchemaValue<Vector>(m_ptr, "AABB_t", "m_vMinBounds");
}
void GAABB_t::SetMinBounds(Vector value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: AABB_t->MinBounds(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "AABB_t", "m_vMinBounds", true, value);
}
Vector GAABB_t::GetMaxBounds() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: AABB_t->MaxBounds(ptr=%p)", m_ptr));
    return GetSchemaValue<Vector>(m_ptr, "AABB_t", "m_vMaxBounds");
}
void GAABB_t::SetMaxBounds(Vector value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: AABB_t->MaxBounds(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "AABB_t", "m_vMaxBounds", true, value);
}
void* GAABB_t::GetPtr() {
    return m_ptr;
}
std::string GAABB_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GAABB_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassAABB_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GAABB_t>("AABB_t")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("MinBounds", &GAABB_t::GetMinBounds, &GAABB_t::SetMinBounds)
        .addProperty("MaxBounds", &GAABB_t::GetMaxBounds, &GAABB_t::SetMaxBounds)
        .addFunction("ToPtr", &GAABB_t::ToPtr)
        .addFunction("IsValid", &GAABB_t::IsValid)
        .endClass();
}
GFeNodeBase_t::GFeNodeBase_t(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GFeNodeBase_t::GFeNodeBase_t(void *ptr) {
    m_ptr = ptr;
}
uint16_t GFeNodeBase_t::GetNode() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FeNodeBase_t->Node(ptr=%p)", m_ptr));
    return GetSchemaValue<uint16_t>(m_ptr, "FeNodeBase_t", "nNode");
}
void GFeNodeBase_t::SetNode(uint16_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FeNodeBase_t->Node(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "FeNodeBase_t", "nNode", true, value);
}
std::vector<uint16_t> GFeNodeBase_t::GetDummy() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FeNodeBase_t->Dummy(ptr=%p,size=3)", m_ptr));
    uint16_t* outValue = (uint16_t*)GetSchemaPtr(m_ptr, "FeNodeBase_t", "nDummy"); std::vector<uint16_t> ret; for(int i = 0; i < 3; i++) { ret.push_back(outValue[i]); } return ret;
}
void GFeNodeBase_t::SetDummy(std::vector<uint16_t> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FeNodeBase_t->Dummy(ptr=%p,size=3)", m_ptr));
    if(value.size() != 3) return PLUGIN_PRINT("Schema SDK", "Field 'Dummy' needs to have 3 values.\n");
    auto val = GetSchemaValuePtr<uint16_t>(m_ptr, "FeNodeBase_t", "nDummy");
    for(size_t i = 0; i < value.size(); i++) val[i] = value[i];
}
uint16_t GFeNodeBase_t::GetNodeX0() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FeNodeBase_t->NodeX0(ptr=%p)", m_ptr));
    return GetSchemaValue<uint16_t>(m_ptr, "FeNodeBase_t", "nNodeX0");
}
void GFeNodeBase_t::SetNodeX0(uint16_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FeNodeBase_t->NodeX0(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "FeNodeBase_t", "nNodeX0", true, value);
}
uint16_t GFeNodeBase_t::GetNodeX1() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FeNodeBase_t->NodeX1(ptr=%p)", m_ptr));
    return GetSchemaValue<uint16_t>(m_ptr, "FeNodeBase_t", "nNodeX1");
}
void GFeNodeBase_t::SetNodeX1(uint16_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FeNodeBase_t->NodeX1(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "FeNodeBase_t", "nNodeX1", true, value);
}
uint16_t GFeNodeBase_t::GetNodeY0() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FeNodeBase_t->NodeY0(ptr=%p)", m_ptr));
    return GetSchemaValue<uint16_t>(m_ptr, "FeNodeBase_t", "nNodeY0");
}
void GFeNodeBase_t::SetNodeY0(uint16_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FeNodeBase_t->NodeY0(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "FeNodeBase_t", "nNodeY0", true, value);
}
uint16_t GFeNodeBase_t::GetNodeY1() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FeNodeBase_t->NodeY1(ptr=%p)", m_ptr));
    return GetSchemaValue<uint16_t>(m_ptr, "FeNodeBase_t", "nNodeY1");
}
void GFeNodeBase_t::SetNodeY1(uint16_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FeNodeBase_t->NodeY1(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "FeNodeBase_t", "nNodeY1", true, value);
}
void* GFeNodeBase_t::GetPtr() {
    return m_ptr;
}
std::string GFeNodeBase_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GFeNodeBase_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassFeNodeBase_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GFeNodeBase_t>("FeNodeBase_t")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Node", &GFeNodeBase_t::GetNode, &GFeNodeBase_t::SetNode)
        .addProperty("Dummy", &GFeNodeBase_t::GetDummy, &GFeNodeBase_t::SetDummy)
        .addProperty("NodeX0", &GFeNodeBase_t::GetNodeX0, &GFeNodeBase_t::SetNodeX0)
        .addProperty("NodeX1", &GFeNodeBase_t::GetNodeX1, &GFeNodeBase_t::SetNodeX1)
        .addProperty("NodeY0", &GFeNodeBase_t::GetNodeY0, &GFeNodeBase_t::SetNodeY0)
        .addProperty("NodeY1", &GFeNodeBase_t::GetNodeY1, &GFeNodeBase_t::SetNodeY1)
        .addFunction("ToPtr", &GFeNodeBase_t::ToPtr)
        .addFunction("IsValid", &GFeNodeBase_t::IsValid)
        .endClass();
}
GModelBoneFlexDriverControl_t::GModelBoneFlexDriverControl_t(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GModelBoneFlexDriverControl_t::GModelBoneFlexDriverControl_t(void *ptr) {
    m_ptr = ptr;
}
uint64_t GModelBoneFlexDriverControl_t::GetBoneComponent() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: ModelBoneFlexDriverControl_t->BoneComponent(ptr=%p)", m_ptr));
    return GetSchemaValue<uint64_t>(m_ptr, "ModelBoneFlexDriverControl_t", "m_nBoneComponent");
}
void GModelBoneFlexDriverControl_t::SetBoneComponent(uint64_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: ModelBoneFlexDriverControl_t->BoneComponent(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "ModelBoneFlexDriverControl_t", "m_nBoneComponent", true, value);
}
std::string GModelBoneFlexDriverControl_t::GetFlexController() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: ModelBoneFlexDriverControl_t->FlexController(ptr=%p)", m_ptr));
    return GetSchemaValue<CUtlString>(m_ptr, "ModelBoneFlexDriverControl_t", "m_flexController").Get();
}
void GModelBoneFlexDriverControl_t::SetFlexController(std::string value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: ModelBoneFlexDriverControl_t->FlexController(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "ModelBoneFlexDriverControl_t", "m_flexController", true, CUtlString(value.c_str()));
}
uint32_t GModelBoneFlexDriverControl_t::GetFlexControllerToken() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: ModelBoneFlexDriverControl_t->FlexControllerToken(ptr=%p)", m_ptr));
    return GetSchemaValue<uint32_t>(m_ptr, "ModelBoneFlexDriverControl_t", "m_flexControllerToken");
}
void GModelBoneFlexDriverControl_t::SetFlexControllerToken(uint32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: ModelBoneFlexDriverControl_t->FlexControllerToken(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "ModelBoneFlexDriverControl_t", "m_flexControllerToken", true, value);
}
float GModelBoneFlexDriverControl_t::GetMin() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: ModelBoneFlexDriverControl_t->Min(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "ModelBoneFlexDriverControl_t", "m_flMin");
}
void GModelBoneFlexDriverControl_t::SetMin(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: ModelBoneFlexDriverControl_t->Min(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "ModelBoneFlexDriverControl_t", "m_flMin", true, value);
}
float GModelBoneFlexDriverControl_t::GetMax() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: ModelBoneFlexDriverControl_t->Max(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "ModelBoneFlexDriverControl_t", "m_flMax");
}
void GModelBoneFlexDriverControl_t::SetMax(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: ModelBoneFlexDriverControl_t->Max(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "ModelBoneFlexDriverControl_t", "m_flMax", true, value);
}
void* GModelBoneFlexDriverControl_t::GetPtr() {
    return m_ptr;
}
std::string GModelBoneFlexDriverControl_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GModelBoneFlexDriverControl_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassModelBoneFlexDriverControl_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GModelBoneFlexDriverControl_t>("ModelBoneFlexDriverControl_t")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("BoneComponent", &GModelBoneFlexDriverControl_t::GetBoneComponent, &GModelBoneFlexDriverControl_t::SetBoneComponent)
        .addProperty("FlexController", &GModelBoneFlexDriverControl_t::GetFlexController, &GModelBoneFlexDriverControl_t::SetFlexController)
        .addProperty("FlexControllerToken", &GModelBoneFlexDriverControl_t::GetFlexControllerToken, &GModelBoneFlexDriverControl_t::SetFlexControllerToken)
        .addProperty("Min", &GModelBoneFlexDriverControl_t::GetMin, &GModelBoneFlexDriverControl_t::SetMin)
        .addProperty("Max", &GModelBoneFlexDriverControl_t::GetMax, &GModelBoneFlexDriverControl_t::SetMax)
        .addFunction("ToPtr", &GModelBoneFlexDriverControl_t::ToPtr)
        .addFunction("IsValid", &GModelBoneFlexDriverControl_t::IsValid)
        .endClass();
}
GPostProcessingVignetteParameters_t::GPostProcessingVignetteParameters_t(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GPostProcessingVignetteParameters_t::GPostProcessingVignetteParameters_t(void *ptr) {
    m_ptr = ptr;
}
float GPostProcessingVignetteParameters_t::GetVignetteStrength() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: PostProcessingVignetteParameters_t->VignetteStrength(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "PostProcessingVignetteParameters_t", "m_flVignetteStrength");
}
void GPostProcessingVignetteParameters_t::SetVignetteStrength(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: PostProcessingVignetteParameters_t->VignetteStrength(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "PostProcessingVignetteParameters_t", "m_flVignetteStrength", true, value);
}
Vector2D GPostProcessingVignetteParameters_t::GetCenter() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: PostProcessingVignetteParameters_t->Center(ptr=%p)", m_ptr));
    return GetSchemaValue<Vector2D>(m_ptr, "PostProcessingVignetteParameters_t", "m_vCenter");
}
void GPostProcessingVignetteParameters_t::SetCenter(Vector2D value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: PostProcessingVignetteParameters_t->Center(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "PostProcessingVignetteParameters_t", "m_vCenter", true, value);
}
float GPostProcessingVignetteParameters_t::GetRadius() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: PostProcessingVignetteParameters_t->Radius(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "PostProcessingVignetteParameters_t", "m_flRadius");
}
void GPostProcessingVignetteParameters_t::SetRadius(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: PostProcessingVignetteParameters_t->Radius(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "PostProcessingVignetteParameters_t", "m_flRadius", true, value);
}
float GPostProcessingVignetteParameters_t::GetRoundness() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: PostProcessingVignetteParameters_t->Roundness(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "PostProcessingVignetteParameters_t", "m_flRoundness");
}
void GPostProcessingVignetteParameters_t::SetRoundness(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: PostProcessingVignetteParameters_t->Roundness(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "PostProcessingVignetteParameters_t", "m_flRoundness", true, value);
}
float GPostProcessingVignetteParameters_t::GetFeather() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: PostProcessingVignetteParameters_t->Feather(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "PostProcessingVignetteParameters_t", "m_flFeather");
}
void GPostProcessingVignetteParameters_t::SetFeather(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: PostProcessingVignetteParameters_t->Feather(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "PostProcessingVignetteParameters_t", "m_flFeather", true, value);
}
Vector GPostProcessingVignetteParameters_t::GetColorTint() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: PostProcessingVignetteParameters_t->ColorTint(ptr=%p)", m_ptr));
    return GetSchemaValue<Vector>(m_ptr, "PostProcessingVignetteParameters_t", "m_vColorTint");
}
void GPostProcessingVignetteParameters_t::SetColorTint(Vector value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: PostProcessingVignetteParameters_t->ColorTint(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "PostProcessingVignetteParameters_t", "m_vColorTint", true, value);
}
void* GPostProcessingVignetteParameters_t::GetPtr() {
    return m_ptr;
}
std::string GPostProcessingVignetteParameters_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GPostProcessingVignetteParameters_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassPostProcessingVignetteParameters_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GPostProcessingVignetteParameters_t>("PostProcessingVignetteParameters_t")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("VignetteStrength", &GPostProcessingVignetteParameters_t::GetVignetteStrength, &GPostProcessingVignetteParameters_t::SetVignetteStrength)
        .addProperty("Center", &GPostProcessingVignetteParameters_t::GetCenter, &GPostProcessingVignetteParameters_t::SetCenter)
        .addProperty("Radius", &GPostProcessingVignetteParameters_t::GetRadius, &GPostProcessingVignetteParameters_t::SetRadius)
        .addProperty("Roundness", &GPostProcessingVignetteParameters_t::GetRoundness, &GPostProcessingVignetteParameters_t::SetRoundness)
        .addProperty("Feather", &GPostProcessingVignetteParameters_t::GetFeather, &GPostProcessingVignetteParameters_t::SetFeather)
        .addProperty("ColorTint", &GPostProcessingVignetteParameters_t::GetColorTint, &GPostProcessingVignetteParameters_t::SetColorTint)
        .addFunction("ToPtr", &GPostProcessingVignetteParameters_t::ToPtr)
        .addFunction("IsValid", &GPostProcessingVignetteParameters_t::IsValid)
        .endClass();
}
GConstantInfo_t::GConstantInfo_t(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GConstantInfo_t::GConstantInfo_t(void *ptr) {
    m_ptr = ptr;
}
std::string GConstantInfo_t::GetName() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: ConstantInfo_t->Name(ptr=%p)", m_ptr));
    return GetSchemaValue<CUtlString>(m_ptr, "ConstantInfo_t", "m_name").Get();
}
void GConstantInfo_t::SetName(std::string value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: ConstantInfo_t->Name(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "ConstantInfo_t", "m_name", true, CUtlString(value.c_str()));
}
uint32_t GConstantInfo_t::GetNameToken() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: ConstantInfo_t->NameToken(ptr=%p)", m_ptr));
    return GetSchemaValue<CUtlStringToken>(m_ptr, "ConstantInfo_t", "m_nameToken").m_nHashCode;
}
void GConstantInfo_t::SetNameToken(uint32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: ConstantInfo_t->NameToken(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "ConstantInfo_t", "m_nameToken", true, CUtlStringToken(value));
}
float GConstantInfo_t::GetValue() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: ConstantInfo_t->Value(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "ConstantInfo_t", "m_flValue");
}
void GConstantInfo_t::SetValue(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: ConstantInfo_t->Value(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "ConstantInfo_t", "m_flValue", true, value);
}
void* GConstantInfo_t::GetPtr() {
    return m_ptr;
}
std::string GConstantInfo_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GConstantInfo_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassConstantInfo_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GConstantInfo_t>("ConstantInfo_t")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Name", &GConstantInfo_t::GetName, &GConstantInfo_t::SetName)
        .addProperty("NameToken", &GConstantInfo_t::GetNameToken, &GConstantInfo_t::SetNameToken)
        .addProperty("Value", &GConstantInfo_t::GetValue, &GConstantInfo_t::SetValue)
        .addFunction("ToPtr", &GConstantInfo_t::ToPtr)
        .addFunction("IsValid", &GConstantInfo_t::IsValid)
        .endClass();
}
GFuseVariableIndex_t::GFuseVariableIndex_t(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GFuseVariableIndex_t::GFuseVariableIndex_t(void *ptr) {
    m_ptr = ptr;
}
uint16_t GFuseVariableIndex_t::GetValue() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FuseVariableIndex_t->Value(ptr=%p)", m_ptr));
    return GetSchemaValue<uint16_t>(m_ptr, "FuseVariableIndex_t", "m_Value");
}
void GFuseVariableIndex_t::SetValue(uint16_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FuseVariableIndex_t->Value(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "FuseVariableIndex_t", "m_Value", true, value);
}
void* GFuseVariableIndex_t::GetPtr() {
    return m_ptr;
}
std::string GFuseVariableIndex_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GFuseVariableIndex_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassFuseVariableIndex_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GFuseVariableIndex_t>("FuseVariableIndex_t")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Value", &GFuseVariableIndex_t::GetValue, &GFuseVariableIndex_t::SetValue)
        .addFunction("ToPtr", &GFuseVariableIndex_t::ToPtr)
        .addFunction("IsValid", &GFuseVariableIndex_t::IsValid)
        .endClass();
}
GIParticleEffect::GIParticleEffect(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GIParticleEffect::GIParticleEffect(void *ptr) {
    m_ptr = ptr;
}
void* GIParticleEffect::GetPtr() {
    return m_ptr;
}
std::string GIParticleEffect::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GIParticleEffect::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassIParticleEffect(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GIParticleEffect>("IParticleEffect")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addFunction("ToPtr", &GIParticleEffect::ToPtr)
        .addFunction("IsValid", &GIParticleEffect::IsValid)
        .endClass();
}
GCStopAtGoalUpdateNode::GCStopAtGoalUpdateNode(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCStopAtGoalUpdateNode::GCStopAtGoalUpdateNode(void *ptr) {
    m_ptr = ptr;
}
float GCStopAtGoalUpdateNode::GetOuterRadius() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CStopAtGoalUpdateNode->OuterRadius(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CStopAtGoalUpdateNode", "m_flOuterRadius");
}
void GCStopAtGoalUpdateNode::SetOuterRadius(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CStopAtGoalUpdateNode->OuterRadius(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CStopAtGoalUpdateNode", "m_flOuterRadius", false, value);
}
float GCStopAtGoalUpdateNode::GetInnerRadius() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CStopAtGoalUpdateNode->InnerRadius(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CStopAtGoalUpdateNode", "m_flInnerRadius");
}
void GCStopAtGoalUpdateNode::SetInnerRadius(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CStopAtGoalUpdateNode->InnerRadius(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CStopAtGoalUpdateNode", "m_flInnerRadius", false, value);
}
float GCStopAtGoalUpdateNode::GetMaxScale() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CStopAtGoalUpdateNode->MaxScale(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CStopAtGoalUpdateNode", "m_flMaxScale");
}
void GCStopAtGoalUpdateNode::SetMaxScale(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CStopAtGoalUpdateNode->MaxScale(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CStopAtGoalUpdateNode", "m_flMaxScale", false, value);
}
float GCStopAtGoalUpdateNode::GetMinScale() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CStopAtGoalUpdateNode->MinScale(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CStopAtGoalUpdateNode", "m_flMinScale");
}
void GCStopAtGoalUpdateNode::SetMinScale(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CStopAtGoalUpdateNode->MinScale(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CStopAtGoalUpdateNode", "m_flMinScale", false, value);
}
GCAnimInputDamping GCStopAtGoalUpdateNode::GetDamping() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CStopAtGoalUpdateNode->Damping(ptr=%p)", m_ptr));
    GCAnimInputDamping value(GetSchemaPtr(m_ptr, "CStopAtGoalUpdateNode", "m_damping"));
    return value;
}
void GCStopAtGoalUpdateNode::SetDamping(GCAnimInputDamping value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CStopAtGoalUpdateNode->Damping(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Damping' is not possible.\n");
}
void* GCStopAtGoalUpdateNode::GetPtr() {
    return m_ptr;
}
std::string GCStopAtGoalUpdateNode::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCStopAtGoalUpdateNode::IsValid() {
    return (m_ptr != nullptr);
}
GCUnaryUpdateNode GCStopAtGoalUpdateNode::GetParent() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CStopAtGoalUpdateNode::GetParent(ptr=%p)", m_ptr));
    GCUnaryUpdateNode value(m_ptr);
    return value;
}
void GCStopAtGoalUpdateNode::SetParent(GCUnaryUpdateNode value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CStopAtGoalUpdateNode::SetParent(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCStopAtGoalUpdateNode(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCStopAtGoalUpdateNode>("CStopAtGoalUpdateNode")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("OuterRadius", &GCStopAtGoalUpdateNode::GetOuterRadius, &GCStopAtGoalUpdateNode::SetOuterRadius)
        .addProperty("InnerRadius", &GCStopAtGoalUpdateNode::GetInnerRadius, &GCStopAtGoalUpdateNode::SetInnerRadius)
        .addProperty("MaxScale", &GCStopAtGoalUpdateNode::GetMaxScale, &GCStopAtGoalUpdateNode::SetMaxScale)
        .addProperty("MinScale", &GCStopAtGoalUpdateNode::GetMinScale, &GCStopAtGoalUpdateNode::SetMinScale)
        .addProperty("Damping", &GCStopAtGoalUpdateNode::GetDamping, &GCStopAtGoalUpdateNode::SetDamping)
        .addProperty("Parent", &GCStopAtGoalUpdateNode::GetParent, &GCStopAtGoalUpdateNode::SetParent)
        .addFunction("ToPtr", &GCStopAtGoalUpdateNode::ToPtr)
        .addFunction("IsValid", &GCStopAtGoalUpdateNode::IsValid)
        .endClass();
}
GCSequenceGroupData::GCSequenceGroupData(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCSequenceGroupData::GCSequenceGroupData(void *ptr) {
    m_ptr = ptr;
}
uint32_t GCSequenceGroupData::GetFlags() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CSequenceGroupData->Flags(ptr=%p)", m_ptr));
    return GetSchemaValue<uint32_t>(m_ptr, "CSequenceGroupData", "m_nFlags");
}
void GCSequenceGroupData::SetFlags(uint32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CSequenceGroupData->Flags(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CSequenceGroupData", "m_nFlags", false, value);
}
std::vector<GCSeqS1SeqDesc> GCSequenceGroupData::GetLocalS1SeqDescArray() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CSequenceGroupData->LocalS1SeqDescArray(ptr=%p)", m_ptr));
    CUtlVector<GCSeqS1SeqDesc>* vec = GetSchemaValue<CUtlVector<GCSeqS1SeqDesc>*>(m_ptr, "CSequenceGroupData", "m_localS1SeqDescArray"); std::vector<GCSeqS1SeqDesc> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCSequenceGroupData::SetLocalS1SeqDescArray(std::vector<GCSeqS1SeqDesc> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CSequenceGroupData->LocalS1SeqDescArray(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<GCSeqS1SeqDesc>(m_ptr, "CSequenceGroupData", "m_localS1SeqDescArray", false, value);
}
std::vector<GCSeqS1SeqDesc> GCSequenceGroupData::GetLocalMultiSeqDescArray() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CSequenceGroupData->LocalMultiSeqDescArray(ptr=%p)", m_ptr));
    CUtlVector<GCSeqS1SeqDesc>* vec = GetSchemaValue<CUtlVector<GCSeqS1SeqDesc>*>(m_ptr, "CSequenceGroupData", "m_localMultiSeqDescArray"); std::vector<GCSeqS1SeqDesc> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCSequenceGroupData::SetLocalMultiSeqDescArray(std::vector<GCSeqS1SeqDesc> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CSequenceGroupData->LocalMultiSeqDescArray(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<GCSeqS1SeqDesc>(m_ptr, "CSequenceGroupData", "m_localMultiSeqDescArray", false, value);
}
std::vector<GCSeqSynthAnimDesc> GCSequenceGroupData::GetLocalSynthAnimDescArray() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CSequenceGroupData->LocalSynthAnimDescArray(ptr=%p)", m_ptr));
    CUtlVector<GCSeqSynthAnimDesc>* vec = GetSchemaValue<CUtlVector<GCSeqSynthAnimDesc>*>(m_ptr, "CSequenceGroupData", "m_localSynthAnimDescArray"); std::vector<GCSeqSynthAnimDesc> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCSequenceGroupData::SetLocalSynthAnimDescArray(std::vector<GCSeqSynthAnimDesc> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CSequenceGroupData->LocalSynthAnimDescArray(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<GCSeqSynthAnimDesc>(m_ptr, "CSequenceGroupData", "m_localSynthAnimDescArray", false, value);
}
std::vector<GCSeqCmdSeqDesc> GCSequenceGroupData::GetLocalCmdSeqDescArray() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CSequenceGroupData->LocalCmdSeqDescArray(ptr=%p)", m_ptr));
    CUtlVector<GCSeqCmdSeqDesc>* vec = GetSchemaValue<CUtlVector<GCSeqCmdSeqDesc>*>(m_ptr, "CSequenceGroupData", "m_localCmdSeqDescArray"); std::vector<GCSeqCmdSeqDesc> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCSequenceGroupData::SetLocalCmdSeqDescArray(std::vector<GCSeqCmdSeqDesc> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CSequenceGroupData->LocalCmdSeqDescArray(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<GCSeqCmdSeqDesc>(m_ptr, "CSequenceGroupData", "m_localCmdSeqDescArray", false, value);
}
std::vector<GCSeqBoneMaskList> GCSequenceGroupData::GetLocalBoneMaskArray() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CSequenceGroupData->LocalBoneMaskArray(ptr=%p)", m_ptr));
    CUtlVector<GCSeqBoneMaskList>* vec = GetSchemaValue<CUtlVector<GCSeqBoneMaskList>*>(m_ptr, "CSequenceGroupData", "m_localBoneMaskArray"); std::vector<GCSeqBoneMaskList> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCSequenceGroupData::SetLocalBoneMaskArray(std::vector<GCSeqBoneMaskList> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CSequenceGroupData->LocalBoneMaskArray(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<GCSeqBoneMaskList>(m_ptr, "CSequenceGroupData", "m_localBoneMaskArray", false, value);
}
std::vector<GCSeqScaleSet> GCSequenceGroupData::GetLocalScaleSetArray() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CSequenceGroupData->LocalScaleSetArray(ptr=%p)", m_ptr));
    CUtlVector<GCSeqScaleSet>* vec = GetSchemaValue<CUtlVector<GCSeqScaleSet>*>(m_ptr, "CSequenceGroupData", "m_localScaleSetArray"); std::vector<GCSeqScaleSet> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCSequenceGroupData::SetLocalScaleSetArray(std::vector<GCSeqScaleSet> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CSequenceGroupData->LocalScaleSetArray(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<GCSeqScaleSet>(m_ptr, "CSequenceGroupData", "m_localScaleSetArray", false, value);
}
std::vector<GCSeqPoseParamDesc> GCSequenceGroupData::GetLocalPoseParamArray() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CSequenceGroupData->LocalPoseParamArray(ptr=%p)", m_ptr));
    CUtlVector<GCSeqPoseParamDesc>* vec = GetSchemaValue<CUtlVector<GCSeqPoseParamDesc>*>(m_ptr, "CSequenceGroupData", "m_localPoseParamArray"); std::vector<GCSeqPoseParamDesc> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCSequenceGroupData::SetLocalPoseParamArray(std::vector<GCSeqPoseParamDesc> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CSequenceGroupData->LocalPoseParamArray(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<GCSeqPoseParamDesc>(m_ptr, "CSequenceGroupData", "m_localPoseParamArray", false, value);
}
std::vector<GCSeqIKLock> GCSequenceGroupData::GetLocalIKAutoplayLockArray() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CSequenceGroupData->LocalIKAutoplayLockArray(ptr=%p)", m_ptr));
    CUtlVector<GCSeqIKLock>* vec = GetSchemaValue<CUtlVector<GCSeqIKLock>*>(m_ptr, "CSequenceGroupData", "m_localIKAutoplayLockArray"); std::vector<GCSeqIKLock> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCSequenceGroupData::SetLocalIKAutoplayLockArray(std::vector<GCSeqIKLock> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CSequenceGroupData->LocalIKAutoplayLockArray(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<GCSeqIKLock>(m_ptr, "CSequenceGroupData", "m_localIKAutoplayLockArray", false, value);
}
void* GCSequenceGroupData::GetPtr() {
    return m_ptr;
}
std::string GCSequenceGroupData::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCSequenceGroupData::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCSequenceGroupData(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCSequenceGroupData>("CSequenceGroupData")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Flags", &GCSequenceGroupData::GetFlags, &GCSequenceGroupData::SetFlags)
        .addProperty("LocalS1SeqDescArray", &GCSequenceGroupData::GetLocalS1SeqDescArray, &GCSequenceGroupData::SetLocalS1SeqDescArray)
        .addProperty("LocalMultiSeqDescArray", &GCSequenceGroupData::GetLocalMultiSeqDescArray, &GCSequenceGroupData::SetLocalMultiSeqDescArray)
        .addProperty("LocalSynthAnimDescArray", &GCSequenceGroupData::GetLocalSynthAnimDescArray, &GCSequenceGroupData::SetLocalSynthAnimDescArray)
        .addProperty("LocalCmdSeqDescArray", &GCSequenceGroupData::GetLocalCmdSeqDescArray, &GCSequenceGroupData::SetLocalCmdSeqDescArray)
        .addProperty("LocalBoneMaskArray", &GCSequenceGroupData::GetLocalBoneMaskArray, &GCSequenceGroupData::SetLocalBoneMaskArray)
        .addProperty("LocalScaleSetArray", &GCSequenceGroupData::GetLocalScaleSetArray, &GCSequenceGroupData::SetLocalScaleSetArray)
        .addProperty("LocalPoseParamArray", &GCSequenceGroupData::GetLocalPoseParamArray, &GCSequenceGroupData::SetLocalPoseParamArray)
        .addProperty("LocalIKAutoplayLockArray", &GCSequenceGroupData::GetLocalIKAutoplayLockArray, &GCSequenceGroupData::SetLocalIKAutoplayLockArray)
        .addFunction("ToPtr", &GCSequenceGroupData::ToPtr)
        .addFunction("IsValid", &GCSequenceGroupData::IsValid)
        .endClass();
}
GParticleNamedValueConfiguration_t::GParticleNamedValueConfiguration_t(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GParticleNamedValueConfiguration_t::GParticleNamedValueConfiguration_t(void *ptr) {
    m_ptr = ptr;
}
std::string GParticleNamedValueConfiguration_t::GetConfigName() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: ParticleNamedValueConfiguration_t->ConfigName(ptr=%p)", m_ptr));
    return GetSchemaValue<CUtlString>(m_ptr, "ParticleNamedValueConfiguration_t", "m_ConfigName").Get();
}
void GParticleNamedValueConfiguration_t::SetConfigName(std::string value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: ParticleNamedValueConfiguration_t->ConfigName(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "ParticleNamedValueConfiguration_t", "m_ConfigName", true, CUtlString(value.c_str()));
}
uint64_t GParticleNamedValueConfiguration_t::GetAttachType() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: ParticleNamedValueConfiguration_t->AttachType(ptr=%p)", m_ptr));
    return GetSchemaValue<uint64_t>(m_ptr, "ParticleNamedValueConfiguration_t", "m_iAttachType");
}
void GParticleNamedValueConfiguration_t::SetAttachType(uint64_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: ParticleNamedValueConfiguration_t->AttachType(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "ParticleNamedValueConfiguration_t", "m_iAttachType", true, value);
}
std::string GParticleNamedValueConfiguration_t::GetBoundEntityPath() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: ParticleNamedValueConfiguration_t->BoundEntityPath(ptr=%p)", m_ptr));
    return GetSchemaValue<CUtlString>(m_ptr, "ParticleNamedValueConfiguration_t", "m_BoundEntityPath").Get();
}
void GParticleNamedValueConfiguration_t::SetBoundEntityPath(std::string value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: ParticleNamedValueConfiguration_t->BoundEntityPath(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "ParticleNamedValueConfiguration_t", "m_BoundEntityPath", true, CUtlString(value.c_str()));
}
std::string GParticleNamedValueConfiguration_t::GetStrEntityScope() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: ParticleNamedValueConfiguration_t->StrEntityScope(ptr=%p)", m_ptr));
    return GetSchemaValue<CUtlString>(m_ptr, "ParticleNamedValueConfiguration_t", "m_strEntityScope").Get();
}
void GParticleNamedValueConfiguration_t::SetStrEntityScope(std::string value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: ParticleNamedValueConfiguration_t->StrEntityScope(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "ParticleNamedValueConfiguration_t", "m_strEntityScope", true, CUtlString(value.c_str()));
}
std::string GParticleNamedValueConfiguration_t::GetStrAttachmentName() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: ParticleNamedValueConfiguration_t->StrAttachmentName(ptr=%p)", m_ptr));
    return GetSchemaValue<CUtlString>(m_ptr, "ParticleNamedValueConfiguration_t", "m_strAttachmentName").Get();
}
void GParticleNamedValueConfiguration_t::SetStrAttachmentName(std::string value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: ParticleNamedValueConfiguration_t->StrAttachmentName(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "ParticleNamedValueConfiguration_t", "m_strAttachmentName", true, CUtlString(value.c_str()));
}
void* GParticleNamedValueConfiguration_t::GetPtr() {
    return m_ptr;
}
std::string GParticleNamedValueConfiguration_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GParticleNamedValueConfiguration_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassParticleNamedValueConfiguration_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GParticleNamedValueConfiguration_t>("ParticleNamedValueConfiguration_t")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("ConfigName", &GParticleNamedValueConfiguration_t::GetConfigName, &GParticleNamedValueConfiguration_t::SetConfigName)
        .addProperty("AttachType", &GParticleNamedValueConfiguration_t::GetAttachType, &GParticleNamedValueConfiguration_t::SetAttachType)
        .addProperty("BoundEntityPath", &GParticleNamedValueConfiguration_t::GetBoundEntityPath, &GParticleNamedValueConfiguration_t::SetBoundEntityPath)
        .addProperty("StrEntityScope", &GParticleNamedValueConfiguration_t::GetStrEntityScope, &GParticleNamedValueConfiguration_t::SetStrEntityScope)
        .addProperty("StrAttachmentName", &GParticleNamedValueConfiguration_t::GetStrAttachmentName, &GParticleNamedValueConfiguration_t::SetStrAttachmentName)
        .addFunction("ToPtr", &GParticleNamedValueConfiguration_t::ToPtr)
        .addFunction("IsValid", &GParticleNamedValueConfiguration_t::IsValid)
        .endClass();
}
GCAnimSkeleton::GCAnimSkeleton(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCAnimSkeleton::GCAnimSkeleton(void *ptr) {
    m_ptr = ptr;
}
std::vector<CUtlString> GCAnimSkeleton::GetBoneNames() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CAnimSkeleton->BoneNames(ptr=%p)", m_ptr));
    CUtlVector<CUtlString>* vec = GetSchemaValue<CUtlVector<CUtlString>*>(m_ptr, "CAnimSkeleton", "m_boneNames"); std::vector<CUtlString> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCAnimSkeleton::SetBoneNames(std::vector<CUtlString> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CAnimSkeleton->BoneNames(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<CUtlString>(m_ptr, "CAnimSkeleton", "m_boneNames", false, value);
}
std::vector<int32> GCAnimSkeleton::GetParents() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CAnimSkeleton->Parents(ptr=%p)", m_ptr));
    CUtlVector<int32>* vec = GetSchemaValue<CUtlVector<int32>*>(m_ptr, "CAnimSkeleton", "m_parents"); std::vector<int32> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCAnimSkeleton::SetParents(std::vector<int32> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CAnimSkeleton->Parents(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<int32>(m_ptr, "CAnimSkeleton", "m_parents", false, value);
}
std::vector<GCAnimFoot> GCAnimSkeleton::GetFeet() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CAnimSkeleton->Feet(ptr=%p)", m_ptr));
    CUtlVector<GCAnimFoot>* vec = GetSchemaValue<CUtlVector<GCAnimFoot>*>(m_ptr, "CAnimSkeleton", "m_feet"); std::vector<GCAnimFoot> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCAnimSkeleton::SetFeet(std::vector<GCAnimFoot> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CAnimSkeleton->Feet(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<GCAnimFoot>(m_ptr, "CAnimSkeleton", "m_feet", false, value);
}
std::vector<CUtlString> GCAnimSkeleton::GetMorphNames() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CAnimSkeleton->MorphNames(ptr=%p)", m_ptr));
    CUtlVector<CUtlString>* vec = GetSchemaValue<CUtlVector<CUtlString>*>(m_ptr, "CAnimSkeleton", "m_morphNames"); std::vector<CUtlString> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCAnimSkeleton::SetMorphNames(std::vector<CUtlString> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CAnimSkeleton->MorphNames(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<CUtlString>(m_ptr, "CAnimSkeleton", "m_morphNames", false, value);
}
std::vector<int32> GCAnimSkeleton::GetLodBoneCounts() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CAnimSkeleton->LodBoneCounts(ptr=%p)", m_ptr));
    CUtlVector<int32>* vec = GetSchemaValue<CUtlVector<int32>*>(m_ptr, "CAnimSkeleton", "m_lodBoneCounts"); std::vector<int32> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCAnimSkeleton::SetLodBoneCounts(std::vector<int32> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CAnimSkeleton->LodBoneCounts(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<int32>(m_ptr, "CAnimSkeleton", "m_lodBoneCounts", false, value);
}
void* GCAnimSkeleton::GetPtr() {
    return m_ptr;
}
std::string GCAnimSkeleton::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCAnimSkeleton::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCAnimSkeleton(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCAnimSkeleton>("CAnimSkeleton")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("BoneNames", &GCAnimSkeleton::GetBoneNames, &GCAnimSkeleton::SetBoneNames)
        .addProperty("Parents", &GCAnimSkeleton::GetParents, &GCAnimSkeleton::SetParents)
        .addProperty("Feet", &GCAnimSkeleton::GetFeet, &GCAnimSkeleton::SetFeet)
        .addProperty("MorphNames", &GCAnimSkeleton::GetMorphNames, &GCAnimSkeleton::SetMorphNames)
        .addProperty("LodBoneCounts", &GCAnimSkeleton::GetLodBoneCounts, &GCAnimSkeleton::SetLodBoneCounts)
        .addFunction("ToPtr", &GCAnimSkeleton::ToPtr)
        .addFunction("IsValid", &GCAnimSkeleton::IsValid)
        .endClass();
}
GCAnimationGraphVisualizerPrimitiveBase::GCAnimationGraphVisualizerPrimitiveBase(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCAnimationGraphVisualizerPrimitiveBase::GCAnimationGraphVisualizerPrimitiveBase(void *ptr) {
    m_ptr = ptr;
}
uint64_t GCAnimationGraphVisualizerPrimitiveBase::GetType() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CAnimationGraphVisualizerPrimitiveBase->Type(ptr=%p)", m_ptr));
    return GetSchemaValue<uint64_t>(m_ptr, "CAnimationGraphVisualizerPrimitiveBase", "m_Type");
}
void GCAnimationGraphVisualizerPrimitiveBase::SetType(uint64_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CAnimationGraphVisualizerPrimitiveBase->Type(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CAnimationGraphVisualizerPrimitiveBase", "m_Type", false, value);
}
std::vector<GAnimNodeID> GCAnimationGraphVisualizerPrimitiveBase::GetOwningAnimNodePaths() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CAnimationGraphVisualizerPrimitiveBase->OwningAnimNodePaths(ptr=%p,size=11)", m_ptr));
    GAnimNodeID* outValue = (GAnimNodeID*)GetSchemaPtr(m_ptr, "CAnimationGraphVisualizerPrimitiveBase", "m_OwningAnimNodePaths"); std::vector<GAnimNodeID> ret; for(int i = 0; i < 11; i++) { ret.push_back(outValue[i]); } return ret;
}
void GCAnimationGraphVisualizerPrimitiveBase::SetOwningAnimNodePaths(std::vector<GAnimNodeID> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CAnimationGraphVisualizerPrimitiveBase->OwningAnimNodePaths(ptr=%p,size=11)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'OwningAnimNodePaths' is not possible.\n");
}
int32_t GCAnimationGraphVisualizerPrimitiveBase::GetOwningAnimNodePathCount() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CAnimationGraphVisualizerPrimitiveBase->OwningAnimNodePathCount(ptr=%p)", m_ptr));
    return GetSchemaValue<int32_t>(m_ptr, "CAnimationGraphVisualizerPrimitiveBase", "m_nOwningAnimNodePathCount");
}
void GCAnimationGraphVisualizerPrimitiveBase::SetOwningAnimNodePathCount(int32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CAnimationGraphVisualizerPrimitiveBase->OwningAnimNodePathCount(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CAnimationGraphVisualizerPrimitiveBase", "m_nOwningAnimNodePathCount", false, value);
}
void* GCAnimationGraphVisualizerPrimitiveBase::GetPtr() {
    return m_ptr;
}
std::string GCAnimationGraphVisualizerPrimitiveBase::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCAnimationGraphVisualizerPrimitiveBase::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCAnimationGraphVisualizerPrimitiveBase(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCAnimationGraphVisualizerPrimitiveBase>("CAnimationGraphVisualizerPrimitiveBase")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Type", &GCAnimationGraphVisualizerPrimitiveBase::GetType, &GCAnimationGraphVisualizerPrimitiveBase::SetType)
        .addProperty("OwningAnimNodePaths", &GCAnimationGraphVisualizerPrimitiveBase::GetOwningAnimNodePaths, &GCAnimationGraphVisualizerPrimitiveBase::SetOwningAnimNodePaths)
        .addProperty("OwningAnimNodePathCount", &GCAnimationGraphVisualizerPrimitiveBase::GetOwningAnimNodePathCount, &GCAnimationGraphVisualizerPrimitiveBase::SetOwningAnimNodePathCount)
        .addFunction("ToPtr", &GCAnimationGraphVisualizerPrimitiveBase::ToPtr)
        .addFunction("IsValid", &GCAnimationGraphVisualizerPrimitiveBase::IsValid)
        .endClass();
}
GCBodyGroupAnimTag::GCBodyGroupAnimTag(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCBodyGroupAnimTag::GCBodyGroupAnimTag(void *ptr) {
    m_ptr = ptr;
}
int32_t GCBodyGroupAnimTag::GetPriority() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CBodyGroupAnimTag->Priority(ptr=%p)", m_ptr));
    return GetSchemaValue<int32_t>(m_ptr, "CBodyGroupAnimTag", "m_nPriority");
}
void GCBodyGroupAnimTag::SetPriority(int32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CBodyGroupAnimTag->Priority(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CBodyGroupAnimTag", "m_nPriority", false, value);
}
std::vector<GCBodyGroupSetting> GCBodyGroupAnimTag::GetBodyGroupSettings() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CBodyGroupAnimTag->BodyGroupSettings(ptr=%p)", m_ptr));
    CUtlVector<GCBodyGroupSetting>* vec = GetSchemaValue<CUtlVector<GCBodyGroupSetting>*>(m_ptr, "CBodyGroupAnimTag", "m_bodyGroupSettings"); std::vector<GCBodyGroupSetting> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCBodyGroupAnimTag::SetBodyGroupSettings(std::vector<GCBodyGroupSetting> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CBodyGroupAnimTag->BodyGroupSettings(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<GCBodyGroupSetting>(m_ptr, "CBodyGroupAnimTag", "m_bodyGroupSettings", false, value);
}
void* GCBodyGroupAnimTag::GetPtr() {
    return m_ptr;
}
std::string GCBodyGroupAnimTag::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCBodyGroupAnimTag::IsValid() {
    return (m_ptr != nullptr);
}
GCAnimTagBase GCBodyGroupAnimTag::GetParent() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CBodyGroupAnimTag::GetParent(ptr=%p)", m_ptr));
    GCAnimTagBase value(m_ptr);
    return value;
}
void GCBodyGroupAnimTag::SetParent(GCAnimTagBase value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CBodyGroupAnimTag::SetParent(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCBodyGroupAnimTag(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCBodyGroupAnimTag>("CBodyGroupAnimTag")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Priority", &GCBodyGroupAnimTag::GetPriority, &GCBodyGroupAnimTag::SetPriority)
        .addProperty("BodyGroupSettings", &GCBodyGroupAnimTag::GetBodyGroupSettings, &GCBodyGroupAnimTag::SetBodyGroupSettings)
        .addProperty("Parent", &GCBodyGroupAnimTag::GetParent, &GCBodyGroupAnimTag::SetParent)
        .addFunction("ToPtr", &GCBodyGroupAnimTag::ToPtr)
        .addFunction("IsValid", &GCBodyGroupAnimTag::IsValid)
        .endClass();
}
GFeAxialEdgeBend_t::GFeAxialEdgeBend_t(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GFeAxialEdgeBend_t::GFeAxialEdgeBend_t(void *ptr) {
    m_ptr = ptr;
}
float GFeAxialEdgeBend_t::GetTe() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FeAxialEdgeBend_t->Te(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "FeAxialEdgeBend_t", "te");
}
void GFeAxialEdgeBend_t::SetTe(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FeAxialEdgeBend_t->Te(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "FeAxialEdgeBend_t", "te", true, value);
}
float GFeAxialEdgeBend_t::GetTv() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FeAxialEdgeBend_t->Tv(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "FeAxialEdgeBend_t", "tv");
}
void GFeAxialEdgeBend_t::SetTv(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FeAxialEdgeBend_t->Tv(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "FeAxialEdgeBend_t", "tv", true, value);
}
float GFeAxialEdgeBend_t::GetDist() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FeAxialEdgeBend_t->Dist(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "FeAxialEdgeBend_t", "flDist");
}
void GFeAxialEdgeBend_t::SetDist(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FeAxialEdgeBend_t->Dist(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "FeAxialEdgeBend_t", "flDist", true, value);
}
std::vector<float> GFeAxialEdgeBend_t::GetWeight() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FeAxialEdgeBend_t->Weight(ptr=%p,size=4)", m_ptr));
    float* outValue = (float*)GetSchemaPtr(m_ptr, "FeAxialEdgeBend_t", "flWeight"); std::vector<float> ret; for(int i = 0; i < 4; i++) { ret.push_back(outValue[i]); } return ret;
}
void GFeAxialEdgeBend_t::SetWeight(std::vector<float> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FeAxialEdgeBend_t->Weight(ptr=%p,size=4)", m_ptr));
    if(value.size() != 4) return PLUGIN_PRINT("Schema SDK", "Field 'Weight' needs to have 4 values.\n");
    auto val = GetSchemaValuePtr<float>(m_ptr, "FeAxialEdgeBend_t", "flWeight");
    for(size_t i = 0; i < value.size(); i++) val[i] = value[i];
}
std::vector<uint16_t> GFeAxialEdgeBend_t::GetNode() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FeAxialEdgeBend_t->Node(ptr=%p,size=6)", m_ptr));
    uint16_t* outValue = (uint16_t*)GetSchemaPtr(m_ptr, "FeAxialEdgeBend_t", "nNode"); std::vector<uint16_t> ret; for(int i = 0; i < 6; i++) { ret.push_back(outValue[i]); } return ret;
}
void GFeAxialEdgeBend_t::SetNode(std::vector<uint16_t> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FeAxialEdgeBend_t->Node(ptr=%p,size=6)", m_ptr));
    if(value.size() != 6) return PLUGIN_PRINT("Schema SDK", "Field 'Node' needs to have 6 values.\n");
    auto val = GetSchemaValuePtr<uint16_t>(m_ptr, "FeAxialEdgeBend_t", "nNode");
    for(size_t i = 0; i < value.size(); i++) val[i] = value[i];
}
void* GFeAxialEdgeBend_t::GetPtr() {
    return m_ptr;
}
std::string GFeAxialEdgeBend_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GFeAxialEdgeBend_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassFeAxialEdgeBend_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GFeAxialEdgeBend_t>("FeAxialEdgeBend_t")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Te", &GFeAxialEdgeBend_t::GetTe, &GFeAxialEdgeBend_t::SetTe)
        .addProperty("Tv", &GFeAxialEdgeBend_t::GetTv, &GFeAxialEdgeBend_t::SetTv)
        .addProperty("Dist", &GFeAxialEdgeBend_t::GetDist, &GFeAxialEdgeBend_t::SetDist)
        .addProperty("Weight", &GFeAxialEdgeBend_t::GetWeight, &GFeAxialEdgeBend_t::SetWeight)
        .addProperty("Node", &GFeAxialEdgeBend_t::GetNode, &GFeAxialEdgeBend_t::SetNode)
        .addFunction("ToPtr", &GFeAxialEdgeBend_t::ToPtr)
        .addFunction("IsValid", &GFeAxialEdgeBend_t::IsValid)
        .endClass();
}
GParamSpanSample_t::GParamSpanSample_t(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GParamSpanSample_t::GParamSpanSample_t(void *ptr) {
    m_ptr = ptr;
}
float GParamSpanSample_t::GetCycle() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: ParamSpanSample_t->Cycle(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "ParamSpanSample_t", "m_flCycle");
}
void GParamSpanSample_t::SetCycle(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: ParamSpanSample_t->Cycle(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "ParamSpanSample_t", "m_flCycle", true, value);
}
void* GParamSpanSample_t::GetPtr() {
    return m_ptr;
}
std::string GParamSpanSample_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GParamSpanSample_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassParamSpanSample_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GParamSpanSample_t>("ParamSpanSample_t")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Cycle", &GParamSpanSample_t::GetCycle, &GParamSpanSample_t::SetCycle)
        .addFunction("ToPtr", &GParamSpanSample_t::ToPtr)
        .addFunction("IsValid", &GParamSpanSample_t::IsValid)
        .endClass();
}
GFunctionInfo_t::GFunctionInfo_t(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GFunctionInfo_t::GFunctionInfo_t(void *ptr) {
    m_ptr = ptr;
}
std::string GFunctionInfo_t::GetName() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FunctionInfo_t->Name(ptr=%p)", m_ptr));
    return GetSchemaValue<CUtlString>(m_ptr, "FunctionInfo_t", "m_name").Get();
}
void GFunctionInfo_t::SetName(std::string value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FunctionInfo_t->Name(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "FunctionInfo_t", "m_name", true, CUtlString(value.c_str()));
}
uint32_t GFunctionInfo_t::GetNameToken() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FunctionInfo_t->NameToken(ptr=%p)", m_ptr));
    return GetSchemaValue<CUtlStringToken>(m_ptr, "FunctionInfo_t", "m_nameToken").m_nHashCode;
}
void GFunctionInfo_t::SetNameToken(uint32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FunctionInfo_t->NameToken(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "FunctionInfo_t", "m_nameToken", true, CUtlStringToken(value));
}
int32_t GFunctionInfo_t::GetParamCount() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FunctionInfo_t->ParamCount(ptr=%p)", m_ptr));
    return GetSchemaValue<int32_t>(m_ptr, "FunctionInfo_t", "m_nParamCount");
}
void GFunctionInfo_t::SetParamCount(int32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FunctionInfo_t->ParamCount(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "FunctionInfo_t", "m_nParamCount", true, value);
}
GFuseFunctionIndex_t GFunctionInfo_t::GetIndex() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FunctionInfo_t->Index(ptr=%p)", m_ptr));
    GFuseFunctionIndex_t value(GetSchemaPtr(m_ptr, "FunctionInfo_t", "m_nIndex"));
    return value;
}
void GFunctionInfo_t::SetIndex(GFuseFunctionIndex_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FunctionInfo_t->Index(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Index' is not possible.\n");
}
bool GFunctionInfo_t::GetIsPure() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FunctionInfo_t->IsPure(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "FunctionInfo_t", "m_bIsPure");
}
void GFunctionInfo_t::SetIsPure(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FunctionInfo_t->IsPure(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "FunctionInfo_t", "m_bIsPure", true, value);
}
void* GFunctionInfo_t::GetPtr() {
    return m_ptr;
}
std::string GFunctionInfo_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GFunctionInfo_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassFunctionInfo_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GFunctionInfo_t>("FunctionInfo_t")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Name", &GFunctionInfo_t::GetName, &GFunctionInfo_t::SetName)
        .addProperty("NameToken", &GFunctionInfo_t::GetNameToken, &GFunctionInfo_t::SetNameToken)
        .addProperty("ParamCount", &GFunctionInfo_t::GetParamCount, &GFunctionInfo_t::SetParamCount)
        .addProperty("Index", &GFunctionInfo_t::GetIndex, &GFunctionInfo_t::SetIndex)
        .addProperty("IsPure", &GFunctionInfo_t::GetIsPure, &GFunctionInfo_t::SetIsPure)
        .addFunction("ToPtr", &GFunctionInfo_t::ToPtr)
        .addFunction("IsValid", &GFunctionInfo_t::IsValid)
        .endClass();
}
GFourQuaternions::GFourQuaternions(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GFourQuaternions::GFourQuaternions(void *ptr) {
    m_ptr = ptr;
}
float GFourQuaternions::GetX() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FourQuaternions->X(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "FourQuaternions", "x");
}
void GFourQuaternions::SetX(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FourQuaternions->X(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "FourQuaternions", "x", false, value);
}
float GFourQuaternions::GetY() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FourQuaternions->Y(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "FourQuaternions", "y");
}
void GFourQuaternions::SetY(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FourQuaternions->Y(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "FourQuaternions", "y", false, value);
}
float GFourQuaternions::GetZ() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FourQuaternions->Z(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "FourQuaternions", "z");
}
void GFourQuaternions::SetZ(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FourQuaternions->Z(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "FourQuaternions", "z", false, value);
}
float GFourQuaternions::GetW() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FourQuaternions->W(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "FourQuaternions", "w");
}
void GFourQuaternions::SetW(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FourQuaternions->W(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "FourQuaternions", "w", false, value);
}
void* GFourQuaternions::GetPtr() {
    return m_ptr;
}
std::string GFourQuaternions::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GFourQuaternions::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassFourQuaternions(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GFourQuaternions>("FourQuaternions")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("X", &GFourQuaternions::GetX, &GFourQuaternions::SetX)
        .addProperty("Y", &GFourQuaternions::GetY, &GFourQuaternions::SetY)
        .addProperty("Z", &GFourQuaternions::GetZ, &GFourQuaternions::SetZ)
        .addProperty("W", &GFourQuaternions::GetW, &GFourQuaternions::SetW)
        .addFunction("ToPtr", &GFourQuaternions::ToPtr)
        .addFunction("IsValid", &GFourQuaternions::IsValid)
        .endClass();
}
GSkeletonAnimCapture_t__FrameStamp_t::GSkeletonAnimCapture_t__FrameStamp_t(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GSkeletonAnimCapture_t__FrameStamp_t::GSkeletonAnimCapture_t__FrameStamp_t(void *ptr) {
    m_ptr = ptr;
}
float GSkeletonAnimCapture_t__FrameStamp_t::GetTime() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: SkeletonAnimCapture_t__FrameStamp_t->Time(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "SkeletonAnimCapture_t__FrameStamp_t", "m_flTime");
}
void GSkeletonAnimCapture_t__FrameStamp_t::SetTime(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: SkeletonAnimCapture_t__FrameStamp_t->Time(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "SkeletonAnimCapture_t__FrameStamp_t", "m_flTime", true, value);
}
float GSkeletonAnimCapture_t__FrameStamp_t::GetEntitySimTime() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: SkeletonAnimCapture_t__FrameStamp_t->EntitySimTime(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "SkeletonAnimCapture_t__FrameStamp_t", "m_flEntitySimTime");
}
void GSkeletonAnimCapture_t__FrameStamp_t::SetEntitySimTime(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: SkeletonAnimCapture_t__FrameStamp_t->EntitySimTime(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "SkeletonAnimCapture_t__FrameStamp_t", "m_flEntitySimTime", true, value);
}
bool GSkeletonAnimCapture_t__FrameStamp_t::GetTeleportTick() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: SkeletonAnimCapture_t__FrameStamp_t->TeleportTick(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "SkeletonAnimCapture_t__FrameStamp_t", "m_bTeleportTick");
}
void GSkeletonAnimCapture_t__FrameStamp_t::SetTeleportTick(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: SkeletonAnimCapture_t__FrameStamp_t->TeleportTick(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "SkeletonAnimCapture_t__FrameStamp_t", "m_bTeleportTick", true, value);
}
bool GSkeletonAnimCapture_t__FrameStamp_t::GetPredicted() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: SkeletonAnimCapture_t__FrameStamp_t->Predicted(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "SkeletonAnimCapture_t__FrameStamp_t", "m_bPredicted");
}
void GSkeletonAnimCapture_t__FrameStamp_t::SetPredicted(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: SkeletonAnimCapture_t__FrameStamp_t->Predicted(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "SkeletonAnimCapture_t__FrameStamp_t", "m_bPredicted", true, value);
}
float GSkeletonAnimCapture_t__FrameStamp_t::GetCurTime() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: SkeletonAnimCapture_t__FrameStamp_t->CurTime(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "SkeletonAnimCapture_t__FrameStamp_t", "m_flCurTime");
}
void GSkeletonAnimCapture_t__FrameStamp_t::SetCurTime(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: SkeletonAnimCapture_t__FrameStamp_t->CurTime(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "SkeletonAnimCapture_t__FrameStamp_t", "m_flCurTime", true, value);
}
float GSkeletonAnimCapture_t__FrameStamp_t::GetRealTime() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: SkeletonAnimCapture_t__FrameStamp_t->RealTime(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "SkeletonAnimCapture_t__FrameStamp_t", "m_flRealTime");
}
void GSkeletonAnimCapture_t__FrameStamp_t::SetRealTime(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: SkeletonAnimCapture_t__FrameStamp_t->RealTime(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "SkeletonAnimCapture_t__FrameStamp_t", "m_flRealTime", true, value);
}
int32_t GSkeletonAnimCapture_t__FrameStamp_t::GetFrameCount() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: SkeletonAnimCapture_t__FrameStamp_t->FrameCount(ptr=%p)", m_ptr));
    return GetSchemaValue<int32_t>(m_ptr, "SkeletonAnimCapture_t__FrameStamp_t", "m_nFrameCount");
}
void GSkeletonAnimCapture_t__FrameStamp_t::SetFrameCount(int32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: SkeletonAnimCapture_t__FrameStamp_t->FrameCount(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "SkeletonAnimCapture_t__FrameStamp_t", "m_nFrameCount", true, value);
}
int32_t GSkeletonAnimCapture_t__FrameStamp_t::GetTickCount() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: SkeletonAnimCapture_t__FrameStamp_t->TickCount(ptr=%p)", m_ptr));
    return GetSchemaValue<int32_t>(m_ptr, "SkeletonAnimCapture_t__FrameStamp_t", "m_nTickCount");
}
void GSkeletonAnimCapture_t__FrameStamp_t::SetTickCount(int32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: SkeletonAnimCapture_t__FrameStamp_t->TickCount(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "SkeletonAnimCapture_t__FrameStamp_t", "m_nTickCount", true, value);
}
void* GSkeletonAnimCapture_t__FrameStamp_t::GetPtr() {
    return m_ptr;
}
std::string GSkeletonAnimCapture_t__FrameStamp_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GSkeletonAnimCapture_t__FrameStamp_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassSkeletonAnimCapture_t__FrameStamp_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GSkeletonAnimCapture_t__FrameStamp_t>("SkeletonAnimCapture_t__FrameStamp_t")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Time", &GSkeletonAnimCapture_t__FrameStamp_t::GetTime, &GSkeletonAnimCapture_t__FrameStamp_t::SetTime)
        .addProperty("EntitySimTime", &GSkeletonAnimCapture_t__FrameStamp_t::GetEntitySimTime, &GSkeletonAnimCapture_t__FrameStamp_t::SetEntitySimTime)
        .addProperty("TeleportTick", &GSkeletonAnimCapture_t__FrameStamp_t::GetTeleportTick, &GSkeletonAnimCapture_t__FrameStamp_t::SetTeleportTick)
        .addProperty("Predicted", &GSkeletonAnimCapture_t__FrameStamp_t::GetPredicted, &GSkeletonAnimCapture_t__FrameStamp_t::SetPredicted)
        .addProperty("CurTime", &GSkeletonAnimCapture_t__FrameStamp_t::GetCurTime, &GSkeletonAnimCapture_t__FrameStamp_t::SetCurTime)
        .addProperty("RealTime", &GSkeletonAnimCapture_t__FrameStamp_t::GetRealTime, &GSkeletonAnimCapture_t__FrameStamp_t::SetRealTime)
        .addProperty("FrameCount", &GSkeletonAnimCapture_t__FrameStamp_t::GetFrameCount, &GSkeletonAnimCapture_t__FrameStamp_t::SetFrameCount)
        .addProperty("TickCount", &GSkeletonAnimCapture_t__FrameStamp_t::GetTickCount, &GSkeletonAnimCapture_t__FrameStamp_t::SetTickCount)
        .addFunction("ToPtr", &GSkeletonAnimCapture_t__FrameStamp_t::ToPtr)
        .addFunction("IsValid", &GSkeletonAnimCapture_t__FrameStamp_t::IsValid)
        .endClass();
}
GCSeqAutoLayerFlag::GCSeqAutoLayerFlag(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCSeqAutoLayerFlag::GCSeqAutoLayerFlag(void *ptr) {
    m_ptr = ptr;
}
bool GCSeqAutoLayerFlag::GetPost() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CSeqAutoLayerFlag->Post(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "CSeqAutoLayerFlag", "m_bPost");
}
void GCSeqAutoLayerFlag::SetPost(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CSeqAutoLayerFlag->Post(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CSeqAutoLayerFlag", "m_bPost", false, value);
}
bool GCSeqAutoLayerFlag::GetSpline() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CSeqAutoLayerFlag->Spline(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "CSeqAutoLayerFlag", "m_bSpline");
}
void GCSeqAutoLayerFlag::SetSpline(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CSeqAutoLayerFlag->Spline(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CSeqAutoLayerFlag", "m_bSpline", false, value);
}
bool GCSeqAutoLayerFlag::GetXFade() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CSeqAutoLayerFlag->XFade(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "CSeqAutoLayerFlag", "m_bXFade");
}
void GCSeqAutoLayerFlag::SetXFade(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CSeqAutoLayerFlag->XFade(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CSeqAutoLayerFlag", "m_bXFade", false, value);
}
bool GCSeqAutoLayerFlag::GetNoBlend() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CSeqAutoLayerFlag->NoBlend(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "CSeqAutoLayerFlag", "m_bNoBlend");
}
void GCSeqAutoLayerFlag::SetNoBlend(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CSeqAutoLayerFlag->NoBlend(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CSeqAutoLayerFlag", "m_bNoBlend", false, value);
}
bool GCSeqAutoLayerFlag::GetLocal() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CSeqAutoLayerFlag->Local(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "CSeqAutoLayerFlag", "m_bLocal");
}
void GCSeqAutoLayerFlag::SetLocal(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CSeqAutoLayerFlag->Local(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CSeqAutoLayerFlag", "m_bLocal", false, value);
}
bool GCSeqAutoLayerFlag::GetPose() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CSeqAutoLayerFlag->Pose(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "CSeqAutoLayerFlag", "m_bPose");
}
void GCSeqAutoLayerFlag::SetPose(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CSeqAutoLayerFlag->Pose(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CSeqAutoLayerFlag", "m_bPose", false, value);
}
bool GCSeqAutoLayerFlag::GetFetchFrame() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CSeqAutoLayerFlag->FetchFrame(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "CSeqAutoLayerFlag", "m_bFetchFrame");
}
void GCSeqAutoLayerFlag::SetFetchFrame(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CSeqAutoLayerFlag->FetchFrame(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CSeqAutoLayerFlag", "m_bFetchFrame", false, value);
}
bool GCSeqAutoLayerFlag::GetSubtract() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CSeqAutoLayerFlag->Subtract(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "CSeqAutoLayerFlag", "m_bSubtract");
}
void GCSeqAutoLayerFlag::SetSubtract(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CSeqAutoLayerFlag->Subtract(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CSeqAutoLayerFlag", "m_bSubtract", false, value);
}
void* GCSeqAutoLayerFlag::GetPtr() {
    return m_ptr;
}
std::string GCSeqAutoLayerFlag::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCSeqAutoLayerFlag::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCSeqAutoLayerFlag(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCSeqAutoLayerFlag>("CSeqAutoLayerFlag")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Post", &GCSeqAutoLayerFlag::GetPost, &GCSeqAutoLayerFlag::SetPost)
        .addProperty("Spline", &GCSeqAutoLayerFlag::GetSpline, &GCSeqAutoLayerFlag::SetSpline)
        .addProperty("XFade", &GCSeqAutoLayerFlag::GetXFade, &GCSeqAutoLayerFlag::SetXFade)
        .addProperty("NoBlend", &GCSeqAutoLayerFlag::GetNoBlend, &GCSeqAutoLayerFlag::SetNoBlend)
        .addProperty("Local", &GCSeqAutoLayerFlag::GetLocal, &GCSeqAutoLayerFlag::SetLocal)
        .addProperty("Pose", &GCSeqAutoLayerFlag::GetPose, &GCSeqAutoLayerFlag::SetPose)
        .addProperty("FetchFrame", &GCSeqAutoLayerFlag::GetFetchFrame, &GCSeqAutoLayerFlag::SetFetchFrame)
        .addProperty("Subtract", &GCSeqAutoLayerFlag::GetSubtract, &GCSeqAutoLayerFlag::SetSubtract)
        .addFunction("ToPtr", &GCSeqAutoLayerFlag::ToPtr)
        .addFunction("IsValid", &GCSeqAutoLayerFlag::IsValid)
        .endClass();
}
GParamSpan_t::GParamSpan_t(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GParamSpan_t::GParamSpan_t(void *ptr) {
    m_ptr = ptr;
}
std::vector<GParamSpanSample_t> GParamSpan_t::GetSamples() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: ParamSpan_t->Samples(ptr=%p)", m_ptr));
    CUtlVector<GParamSpanSample_t>* vec = GetSchemaValue<CUtlVector<GParamSpanSample_t>*>(m_ptr, "ParamSpan_t", "m_samples"); std::vector<GParamSpanSample_t> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GParamSpan_t::SetSamples(std::vector<GParamSpanSample_t> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: ParamSpan_t->Samples(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<GParamSpanSample_t>(m_ptr, "ParamSpan_t", "m_samples", true, value);
}
GCAnimParamHandle GParamSpan_t::GetParam() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: ParamSpan_t->Param(ptr=%p)", m_ptr));
    GCAnimParamHandle value(GetSchemaPtr(m_ptr, "ParamSpan_t", "m_hParam"));
    return value;
}
void GParamSpan_t::SetParam(GCAnimParamHandle value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: ParamSpan_t->Param(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Param' is not possible.\n");
}
uint64_t GParamSpan_t::GetParamType() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: ParamSpan_t->ParamType(ptr=%p)", m_ptr));
    return GetSchemaValue<uint64_t>(m_ptr, "ParamSpan_t", "m_eParamType");
}
void GParamSpan_t::SetParamType(uint64_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: ParamSpan_t->ParamType(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "ParamSpan_t", "m_eParamType", true, value);
}
float GParamSpan_t::GetStartCycle() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: ParamSpan_t->StartCycle(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "ParamSpan_t", "m_flStartCycle");
}
void GParamSpan_t::SetStartCycle(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: ParamSpan_t->StartCycle(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "ParamSpan_t", "m_flStartCycle", true, value);
}
float GParamSpan_t::GetEndCycle() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: ParamSpan_t->EndCycle(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "ParamSpan_t", "m_flEndCycle");
}
void GParamSpan_t::SetEndCycle(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: ParamSpan_t->EndCycle(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "ParamSpan_t", "m_flEndCycle", true, value);
}
void* GParamSpan_t::GetPtr() {
    return m_ptr;
}
std::string GParamSpan_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GParamSpan_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassParamSpan_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GParamSpan_t>("ParamSpan_t")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Samples", &GParamSpan_t::GetSamples, &GParamSpan_t::SetSamples)
        .addProperty("Param", &GParamSpan_t::GetParam, &GParamSpan_t::SetParam)
        .addProperty("ParamType", &GParamSpan_t::GetParamType, &GParamSpan_t::SetParamType)
        .addProperty("StartCycle", &GParamSpan_t::GetStartCycle, &GParamSpan_t::SetStartCycle)
        .addProperty("EndCycle", &GParamSpan_t::GetEndCycle, &GParamSpan_t::SetEndCycle)
        .addFunction("ToPtr", &GParamSpan_t::ToPtr)
        .addFunction("IsValid", &GParamSpan_t::IsValid)
        .endClass();
}
GCNmBoolValueNode::GCNmBoolValueNode(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCNmBoolValueNode::GCNmBoolValueNode(void *ptr) {
    m_ptr = ptr;
}
void* GCNmBoolValueNode::GetPtr() {
    return m_ptr;
}
std::string GCNmBoolValueNode::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCNmBoolValueNode::IsValid() {
    return (m_ptr != nullptr);
}
GCNmValueNode GCNmBoolValueNode::GetParent() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CNmBoolValueNode::GetParent(ptr=%p)", m_ptr));
    GCNmValueNode value(m_ptr);
    return value;
}
void GCNmBoolValueNode::SetParent(GCNmValueNode value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CNmBoolValueNode::SetParent(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCNmBoolValueNode(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCNmBoolValueNode>("CNmBoolValueNode")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Parent", &GCNmBoolValueNode::GetParent, &GCNmBoolValueNode::SetParent)
        .addFunction("ToPtr", &GCNmBoolValueNode::ToPtr)
        .addFunction("IsValid", &GCNmBoolValueNode::IsValid)
        .endClass();
}
GRenderInputLayoutField_t::GRenderInputLayoutField_t(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GRenderInputLayoutField_t::GRenderInputLayoutField_t(void *ptr) {
    m_ptr = ptr;
}
std::vector<uint32_t> GRenderInputLayoutField_t::GetSemanticName() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: RenderInputLayoutField_t->SemanticName(ptr=%p,size=32)", m_ptr));
    uint32_t* outValue = (uint32_t*)GetSchemaPtr(m_ptr, "RenderInputLayoutField_t", "m_pSemanticName"); std::vector<uint32_t> ret; for(int i = 0; i < 32; i++) { ret.push_back(outValue[i]); } return ret;
}
void GRenderInputLayoutField_t::SetSemanticName(std::vector<uint32_t> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: RenderInputLayoutField_t->SemanticName(ptr=%p,size=32)", m_ptr));
    if(value.size() != 32) return PLUGIN_PRINT("Schema SDK", "Field 'SemanticName' needs to have 32 values.\n");
    auto val = GetSchemaValuePtr<uint32_t>(m_ptr, "RenderInputLayoutField_t", "m_pSemanticName");
    for(size_t i = 0; i < value.size(); i++) val[i] = value[i];
}
int32_t GRenderInputLayoutField_t::GetSemanticIndex() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: RenderInputLayoutField_t->SemanticIndex(ptr=%p)", m_ptr));
    return GetSchemaValue<int32_t>(m_ptr, "RenderInputLayoutField_t", "m_nSemanticIndex");
}
void GRenderInputLayoutField_t::SetSemanticIndex(int32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: RenderInputLayoutField_t->SemanticIndex(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "RenderInputLayoutField_t", "m_nSemanticIndex", true, value);
}
uint32_t GRenderInputLayoutField_t::GetFormat() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: RenderInputLayoutField_t->Format(ptr=%p)", m_ptr));
    return GetSchemaValue<uint32_t>(m_ptr, "RenderInputLayoutField_t", "m_Format");
}
void GRenderInputLayoutField_t::SetFormat(uint32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: RenderInputLayoutField_t->Format(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "RenderInputLayoutField_t", "m_Format", true, value);
}
int32_t GRenderInputLayoutField_t::GetOffset() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: RenderInputLayoutField_t->Offset(ptr=%p)", m_ptr));
    return GetSchemaValue<int32_t>(m_ptr, "RenderInputLayoutField_t", "m_nOffset");
}
void GRenderInputLayoutField_t::SetOffset(int32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: RenderInputLayoutField_t->Offset(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "RenderInputLayoutField_t", "m_nOffset", true, value);
}
int32_t GRenderInputLayoutField_t::GetSlot() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: RenderInputLayoutField_t->Slot(ptr=%p)", m_ptr));
    return GetSchemaValue<int32_t>(m_ptr, "RenderInputLayoutField_t", "m_nSlot");
}
void GRenderInputLayoutField_t::SetSlot(int32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: RenderInputLayoutField_t->Slot(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "RenderInputLayoutField_t", "m_nSlot", true, value);
}
uint64_t GRenderInputLayoutField_t::GetSlotType() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: RenderInputLayoutField_t->SlotType(ptr=%p)", m_ptr));
    return GetSchemaValue<uint64_t>(m_ptr, "RenderInputLayoutField_t", "m_nSlotType");
}
void GRenderInputLayoutField_t::SetSlotType(uint64_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: RenderInputLayoutField_t->SlotType(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "RenderInputLayoutField_t", "m_nSlotType", true, value);
}
int32_t GRenderInputLayoutField_t::GetInstanceStepRate() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: RenderInputLayoutField_t->InstanceStepRate(ptr=%p)", m_ptr));
    return GetSchemaValue<int32_t>(m_ptr, "RenderInputLayoutField_t", "m_nInstanceStepRate");
}
void GRenderInputLayoutField_t::SetInstanceStepRate(int32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: RenderInputLayoutField_t->InstanceStepRate(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "RenderInputLayoutField_t", "m_nInstanceStepRate", true, value);
}
void* GRenderInputLayoutField_t::GetPtr() {
    return m_ptr;
}
std::string GRenderInputLayoutField_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GRenderInputLayoutField_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassRenderInputLayoutField_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GRenderInputLayoutField_t>("RenderInputLayoutField_t")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("SemanticName", &GRenderInputLayoutField_t::GetSemanticName, &GRenderInputLayoutField_t::SetSemanticName)
        .addProperty("SemanticIndex", &GRenderInputLayoutField_t::GetSemanticIndex, &GRenderInputLayoutField_t::SetSemanticIndex)
        .addProperty("Format", &GRenderInputLayoutField_t::GetFormat, &GRenderInputLayoutField_t::SetFormat)
        .addProperty("Offset", &GRenderInputLayoutField_t::GetOffset, &GRenderInputLayoutField_t::SetOffset)
        .addProperty("Slot", &GRenderInputLayoutField_t::GetSlot, &GRenderInputLayoutField_t::SetSlot)
        .addProperty("SlotType", &GRenderInputLayoutField_t::GetSlotType, &GRenderInputLayoutField_t::SetSlotType)
        .addProperty("InstanceStepRate", &GRenderInputLayoutField_t::GetInstanceStepRate, &GRenderInputLayoutField_t::SetInstanceStepRate)
        .addFunction("ToPtr", &GRenderInputLayoutField_t::ToPtr)
        .addFunction("IsValid", &GRenderInputLayoutField_t::IsValid)
        .endClass();
}
GCCPPScriptComponentUpdater::GCCPPScriptComponentUpdater(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCCPPScriptComponentUpdater::GCCPPScriptComponentUpdater(void *ptr) {
    m_ptr = ptr;
}
void* GCCPPScriptComponentUpdater::GetPtr() {
    return m_ptr;
}
std::string GCCPPScriptComponentUpdater::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCCPPScriptComponentUpdater::IsValid() {
    return (m_ptr != nullptr);
}
GCAnimComponentUpdater GCCPPScriptComponentUpdater::GetParent() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CCPPScriptComponentUpdater::GetParent(ptr=%p)", m_ptr));
    GCAnimComponentUpdater value(m_ptr);
    return value;
}
void GCCPPScriptComponentUpdater::SetParent(GCAnimComponentUpdater value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CCPPScriptComponentUpdater::SetParent(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCCPPScriptComponentUpdater(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCCPPScriptComponentUpdater>("CCPPScriptComponentUpdater")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Parent", &GCCPPScriptComponentUpdater::GetParent, &GCCPPScriptComponentUpdater::SetParent)
        .addFunction("ToPtr", &GCCPPScriptComponentUpdater::ToPtr)
        .addFunction("IsValid", &GCCPPScriptComponentUpdater::IsValid)
        .endClass();
}
GCDampedValueComponentUpdater::GCDampedValueComponentUpdater(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCDampedValueComponentUpdater::GCDampedValueComponentUpdater(void *ptr) {
    m_ptr = ptr;
}
std::vector<GCDampedValueUpdateItem> GCDampedValueComponentUpdater::GetItems() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CDampedValueComponentUpdater->Items(ptr=%p)", m_ptr));
    CUtlVector<GCDampedValueUpdateItem>* vec = GetSchemaValue<CUtlVector<GCDampedValueUpdateItem>*>(m_ptr, "CDampedValueComponentUpdater", "m_items"); std::vector<GCDampedValueUpdateItem> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCDampedValueComponentUpdater::SetItems(std::vector<GCDampedValueUpdateItem> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CDampedValueComponentUpdater->Items(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<GCDampedValueUpdateItem>(m_ptr, "CDampedValueComponentUpdater", "m_items", false, value);
}
void* GCDampedValueComponentUpdater::GetPtr() {
    return m_ptr;
}
std::string GCDampedValueComponentUpdater::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCDampedValueComponentUpdater::IsValid() {
    return (m_ptr != nullptr);
}
GCAnimComponentUpdater GCDampedValueComponentUpdater::GetParent() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CDampedValueComponentUpdater::GetParent(ptr=%p)", m_ptr));
    GCAnimComponentUpdater value(m_ptr);
    return value;
}
void GCDampedValueComponentUpdater::SetParent(GCAnimComponentUpdater value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CDampedValueComponentUpdater::SetParent(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCDampedValueComponentUpdater(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCDampedValueComponentUpdater>("CDampedValueComponentUpdater")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Items", &GCDampedValueComponentUpdater::GetItems, &GCDampedValueComponentUpdater::SetItems)
        .addProperty("Parent", &GCDampedValueComponentUpdater::GetParent, &GCDampedValueComponentUpdater::SetParent)
        .addFunction("ToPtr", &GCDampedValueComponentUpdater::ToPtr)
        .addFunction("IsValid", &GCDampedValueComponentUpdater::IsValid)
        .endClass();
}
GCSeqPoseSetting::GCSeqPoseSetting(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCSeqPoseSetting::GCSeqPoseSetting(void *ptr) {
    m_ptr = ptr;
}
float GCSeqPoseSetting::GetValue() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CSeqPoseSetting->Value(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CSeqPoseSetting", "m_flValue");
}
void GCSeqPoseSetting::SetValue(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CSeqPoseSetting->Value(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CSeqPoseSetting", "m_flValue", false, value);
}
bool GCSeqPoseSetting::GetX() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CSeqPoseSetting->X(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "CSeqPoseSetting", "m_bX");
}
void GCSeqPoseSetting::SetX(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CSeqPoseSetting->X(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CSeqPoseSetting", "m_bX", false, value);
}
bool GCSeqPoseSetting::GetY() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CSeqPoseSetting->Y(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "CSeqPoseSetting", "m_bY");
}
void GCSeqPoseSetting::SetY(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CSeqPoseSetting->Y(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CSeqPoseSetting", "m_bY", false, value);
}
bool GCSeqPoseSetting::GetZ() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CSeqPoseSetting->Z(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "CSeqPoseSetting", "m_bZ");
}
void GCSeqPoseSetting::SetZ(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CSeqPoseSetting->Z(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CSeqPoseSetting", "m_bZ", false, value);
}
int32_t GCSeqPoseSetting::GetType() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CSeqPoseSetting->Type(ptr=%p)", m_ptr));
    return GetSchemaValue<int32_t>(m_ptr, "CSeqPoseSetting", "m_eType");
}
void GCSeqPoseSetting::SetType(int32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CSeqPoseSetting->Type(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CSeqPoseSetting", "m_eType", false, value);
}
void* GCSeqPoseSetting::GetPtr() {
    return m_ptr;
}
std::string GCSeqPoseSetting::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCSeqPoseSetting::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCSeqPoseSetting(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCSeqPoseSetting>("CSeqPoseSetting")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Value", &GCSeqPoseSetting::GetValue, &GCSeqPoseSetting::SetValue)
        .addProperty("X", &GCSeqPoseSetting::GetX, &GCSeqPoseSetting::SetX)
        .addProperty("Y", &GCSeqPoseSetting::GetY, &GCSeqPoseSetting::SetY)
        .addProperty("Z", &GCSeqPoseSetting::GetZ, &GCSeqPoseSetting::SetZ)
        .addProperty("Type", &GCSeqPoseSetting::GetType, &GCSeqPoseSetting::SetType)
        .addFunction("ToPtr", &GCSeqPoseSetting::ToPtr)
        .addFunction("IsValid", &GCSeqPoseSetting::IsValid)
        .endClass();
}
GRenderHairStrandInfo_t::GRenderHairStrandInfo_t(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GRenderHairStrandInfo_t::GRenderHairStrandInfo_t(void *ptr) {
    m_ptr = ptr;
}
std::vector<uint32_t> GRenderHairStrandInfo_t::GetGuideHairIndices_nSurfaceTriIndex() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: RenderHairStrandInfo_t->GuideHairIndices_nSurfaceTriIndex(ptr=%p,size=2)", m_ptr));
    uint32_t* outValue = (uint32_t*)GetSchemaPtr(m_ptr, "RenderHairStrandInfo_t", "m_nGuideHairIndices_nSurfaceTriIndex"); std::vector<uint32_t> ret; for(int i = 0; i < 2; i++) { ret.push_back(outValue[i]); } return ret;
}
void GRenderHairStrandInfo_t::SetGuideHairIndices_nSurfaceTriIndex(std::vector<uint32_t> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: RenderHairStrandInfo_t->GuideHairIndices_nSurfaceTriIndex(ptr=%p,size=2)", m_ptr));
    if(value.size() != 2) return PLUGIN_PRINT("Schema SDK", "Field 'GuideHairIndices_nSurfaceTriIndex' needs to have 2 values.\n");
    auto val = GetSchemaValuePtr<uint32_t>(m_ptr, "RenderHairStrandInfo_t", "m_nGuideHairIndices_nSurfaceTriIndex");
    for(size_t i = 0; i < value.size(); i++) val[i] = value[i];
}
std::vector<uint16_t> GRenderHairStrandInfo_t::GetGuideBary_vBaseBary() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: RenderHairStrandInfo_t->GuideBary_vBaseBary(ptr=%p,size=4)", m_ptr));
    uint16_t* outValue = (uint16_t*)GetSchemaPtr(m_ptr, "RenderHairStrandInfo_t", "m_vGuideBary_vBaseBary"); std::vector<uint16_t> ret; for(int i = 0; i < 4; i++) { ret.push_back(outValue[i]); } return ret;
}
void GRenderHairStrandInfo_t::SetGuideBary_vBaseBary(std::vector<uint16_t> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: RenderHairStrandInfo_t->GuideBary_vBaseBary(ptr=%p,size=4)", m_ptr));
    if(value.size() != 4) return PLUGIN_PRINT("Schema SDK", "Field 'GuideBary_vBaseBary' needs to have 4 values.\n");
    auto val = GetSchemaValuePtr<uint16_t>(m_ptr, "RenderHairStrandInfo_t", "m_vGuideBary_vBaseBary");
    for(size_t i = 0; i < value.size(); i++) val[i] = value[i];
}
std::vector<uint16_t> GRenderHairStrandInfo_t::GetRootOffset_flLengthScale() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: RenderHairStrandInfo_t->RootOffset_flLengthScale(ptr=%p,size=4)", m_ptr));
    uint16_t* outValue = (uint16_t*)GetSchemaPtr(m_ptr, "RenderHairStrandInfo_t", "m_vRootOffset_flLengthScale"); std::vector<uint16_t> ret; for(int i = 0; i < 4; i++) { ret.push_back(outValue[i]); } return ret;
}
void GRenderHairStrandInfo_t::SetRootOffset_flLengthScale(std::vector<uint16_t> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: RenderHairStrandInfo_t->RootOffset_flLengthScale(ptr=%p,size=4)", m_ptr));
    if(value.size() != 4) return PLUGIN_PRINT("Schema SDK", "Field 'RootOffset_flLengthScale' needs to have 4 values.\n");
    auto val = GetSchemaValuePtr<uint16_t>(m_ptr, "RenderHairStrandInfo_t", "m_vRootOffset_flLengthScale");
    for(size_t i = 0; i < value.size(); i++) val[i] = value[i];
}
std::vector<uint16_t> GRenderHairStrandInfo_t::GetPackedBaseUv() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: RenderHairStrandInfo_t->PackedBaseUv(ptr=%p,size=2)", m_ptr));
    uint16_t* outValue = (uint16_t*)GetSchemaPtr(m_ptr, "RenderHairStrandInfo_t", "m_nPackedBaseUv"); std::vector<uint16_t> ret; for(int i = 0; i < 2; i++) { ret.push_back(outValue[i]); } return ret;
}
void GRenderHairStrandInfo_t::SetPackedBaseUv(std::vector<uint16_t> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: RenderHairStrandInfo_t->PackedBaseUv(ptr=%p,size=2)", m_ptr));
    if(value.size() != 2) return PLUGIN_PRINT("Schema SDK", "Field 'PackedBaseUv' needs to have 2 values.\n");
    auto val = GetSchemaValuePtr<uint16_t>(m_ptr, "RenderHairStrandInfo_t", "m_nPackedBaseUv");
    for(size_t i = 0; i < value.size(); i++) val[i] = value[i];
}
uint32_t GRenderHairStrandInfo_t::GetPackedSurfaceNormalOs() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: RenderHairStrandInfo_t->PackedSurfaceNormalOs(ptr=%p)", m_ptr));
    return GetSchemaValue<uint32_t>(m_ptr, "RenderHairStrandInfo_t", "m_nPackedSurfaceNormalOs");
}
void GRenderHairStrandInfo_t::SetPackedSurfaceNormalOs(uint32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: RenderHairStrandInfo_t->PackedSurfaceNormalOs(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "RenderHairStrandInfo_t", "m_nPackedSurfaceNormalOs", true, value);
}
uint32_t GRenderHairStrandInfo_t::GetPackedSurfaceTangentOs() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: RenderHairStrandInfo_t->PackedSurfaceTangentOs(ptr=%p)", m_ptr));
    return GetSchemaValue<uint32_t>(m_ptr, "RenderHairStrandInfo_t", "m_nPackedSurfaceTangentOs");
}
void GRenderHairStrandInfo_t::SetPackedSurfaceTangentOs(uint32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: RenderHairStrandInfo_t->PackedSurfaceTangentOs(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "RenderHairStrandInfo_t", "m_nPackedSurfaceTangentOs", true, value);
}
void* GRenderHairStrandInfo_t::GetPtr() {
    return m_ptr;
}
std::string GRenderHairStrandInfo_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GRenderHairStrandInfo_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassRenderHairStrandInfo_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GRenderHairStrandInfo_t>("RenderHairStrandInfo_t")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("GuideHairIndices_nSurfaceTriIndex", &GRenderHairStrandInfo_t::GetGuideHairIndices_nSurfaceTriIndex, &GRenderHairStrandInfo_t::SetGuideHairIndices_nSurfaceTriIndex)
        .addProperty("GuideBary_vBaseBary", &GRenderHairStrandInfo_t::GetGuideBary_vBaseBary, &GRenderHairStrandInfo_t::SetGuideBary_vBaseBary)
        .addProperty("RootOffset_flLengthScale", &GRenderHairStrandInfo_t::GetRootOffset_flLengthScale, &GRenderHairStrandInfo_t::SetRootOffset_flLengthScale)
        .addProperty("PackedBaseUv", &GRenderHairStrandInfo_t::GetPackedBaseUv, &GRenderHairStrandInfo_t::SetPackedBaseUv)
        .addProperty("PackedSurfaceNormalOs", &GRenderHairStrandInfo_t::GetPackedSurfaceNormalOs, &GRenderHairStrandInfo_t::SetPackedSurfaceNormalOs)
        .addProperty("PackedSurfaceTangentOs", &GRenderHairStrandInfo_t::GetPackedSurfaceTangentOs, &GRenderHairStrandInfo_t::SetPackedSurfaceTangentOs)
        .addFunction("ToPtr", &GRenderHairStrandInfo_t::ToPtr)
        .addFunction("IsValid", &GRenderHairStrandInfo_t::IsValid)
        .endClass();
}
GCExampleSchemaVData_Monomorphic::GCExampleSchemaVData_Monomorphic(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCExampleSchemaVData_Monomorphic::GCExampleSchemaVData_Monomorphic(void *ptr) {
    m_ptr = ptr;
}
int32_t GCExampleSchemaVData_Monomorphic::GetExample1() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CExampleSchemaVData_Monomorphic->Example1(ptr=%p)", m_ptr));
    return GetSchemaValue<int32_t>(m_ptr, "CExampleSchemaVData_Monomorphic", "m_nExample1");
}
void GCExampleSchemaVData_Monomorphic::SetExample1(int32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CExampleSchemaVData_Monomorphic->Example1(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CExampleSchemaVData_Monomorphic", "m_nExample1", false, value);
}
int32_t GCExampleSchemaVData_Monomorphic::GetExample2() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CExampleSchemaVData_Monomorphic->Example2(ptr=%p)", m_ptr));
    return GetSchemaValue<int32_t>(m_ptr, "CExampleSchemaVData_Monomorphic", "m_nExample2");
}
void GCExampleSchemaVData_Monomorphic::SetExample2(int32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CExampleSchemaVData_Monomorphic->Example2(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CExampleSchemaVData_Monomorphic", "m_nExample2", false, value);
}
void* GCExampleSchemaVData_Monomorphic::GetPtr() {
    return m_ptr;
}
std::string GCExampleSchemaVData_Monomorphic::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCExampleSchemaVData_Monomorphic::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCExampleSchemaVData_Monomorphic(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCExampleSchemaVData_Monomorphic>("CExampleSchemaVData_Monomorphic")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Example1", &GCExampleSchemaVData_Monomorphic::GetExample1, &GCExampleSchemaVData_Monomorphic::SetExample1)
        .addProperty("Example2", &GCExampleSchemaVData_Monomorphic::GetExample2, &GCExampleSchemaVData_Monomorphic::SetExample2)
        .addFunction("ToPtr", &GCExampleSchemaVData_Monomorphic::ToPtr)
        .addFunction("IsValid", &GCExampleSchemaVData_Monomorphic::IsValid)
        .endClass();
}
GCPlayerSprayDecalRenderHelper::GCPlayerSprayDecalRenderHelper(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCPlayerSprayDecalRenderHelper::GCPlayerSprayDecalRenderHelper(void *ptr) {
    m_ptr = ptr;
}
void* GCPlayerSprayDecalRenderHelper::GetPtr() {
    return m_ptr;
}
std::string GCPlayerSprayDecalRenderHelper::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCPlayerSprayDecalRenderHelper::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCPlayerSprayDecalRenderHelper(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCPlayerSprayDecalRenderHelper>("CPlayerSprayDecalRenderHelper")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addFunction("ToPtr", &GCPlayerSprayDecalRenderHelper::ToPtr)
        .addFunction("IsValid", &GCPlayerSprayDecalRenderHelper::IsValid)
        .endClass();
}
GFeTaperedCapsuleRigid_t::GFeTaperedCapsuleRigid_t(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GFeTaperedCapsuleRigid_t::GFeTaperedCapsuleRigid_t(void *ptr) {
    m_ptr = ptr;
}
std::vector<float> GFeTaperedCapsuleRigid_t::GetSphere() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FeTaperedCapsuleRigid_t->Sphere(ptr=%p,size=2)", m_ptr));
    float* outValue = (float*)GetSchemaPtr(m_ptr, "FeTaperedCapsuleRigid_t", "vSphere"); std::vector<float> ret; for(int i = 0; i < 2; i++) { ret.push_back(outValue[i]); } return ret;
}
void GFeTaperedCapsuleRigid_t::SetSphere(std::vector<float> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FeTaperedCapsuleRigid_t->Sphere(ptr=%p,size=2)", m_ptr));
    if(value.size() != 2) return PLUGIN_PRINT("Schema SDK", "Field 'Sphere' needs to have 2 values.\n");
    auto val = GetSchemaValuePtr<float>(m_ptr, "FeTaperedCapsuleRigid_t", "vSphere");
    for(size_t i = 0; i < value.size(); i++) val[i] = value[i];
}
uint16_t GFeTaperedCapsuleRigid_t::GetNode() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FeTaperedCapsuleRigid_t->Node(ptr=%p)", m_ptr));
    return GetSchemaValue<uint16_t>(m_ptr, "FeTaperedCapsuleRigid_t", "nNode");
}
void GFeTaperedCapsuleRigid_t::SetNode(uint16_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FeTaperedCapsuleRigid_t->Node(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "FeTaperedCapsuleRigid_t", "nNode", true, value);
}
uint16_t GFeTaperedCapsuleRigid_t::GetCollisionMask() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FeTaperedCapsuleRigid_t->CollisionMask(ptr=%p)", m_ptr));
    return GetSchemaValue<uint16_t>(m_ptr, "FeTaperedCapsuleRigid_t", "nCollisionMask");
}
void GFeTaperedCapsuleRigid_t::SetCollisionMask(uint16_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FeTaperedCapsuleRigid_t->CollisionMask(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "FeTaperedCapsuleRigid_t", "nCollisionMask", true, value);
}
uint16_t GFeTaperedCapsuleRigid_t::GetVertexMapIndex() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FeTaperedCapsuleRigid_t->VertexMapIndex(ptr=%p)", m_ptr));
    return GetSchemaValue<uint16_t>(m_ptr, "FeTaperedCapsuleRigid_t", "nVertexMapIndex");
}
void GFeTaperedCapsuleRigid_t::SetVertexMapIndex(uint16_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FeTaperedCapsuleRigid_t->VertexMapIndex(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "FeTaperedCapsuleRigid_t", "nVertexMapIndex", true, value);
}
uint16_t GFeTaperedCapsuleRigid_t::GetFlags() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FeTaperedCapsuleRigid_t->Flags(ptr=%p)", m_ptr));
    return GetSchemaValue<uint16_t>(m_ptr, "FeTaperedCapsuleRigid_t", "nFlags");
}
void GFeTaperedCapsuleRigid_t::SetFlags(uint16_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FeTaperedCapsuleRigid_t->Flags(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "FeTaperedCapsuleRigid_t", "nFlags", true, value);
}
void* GFeTaperedCapsuleRigid_t::GetPtr() {
    return m_ptr;
}
std::string GFeTaperedCapsuleRigid_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GFeTaperedCapsuleRigid_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassFeTaperedCapsuleRigid_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GFeTaperedCapsuleRigid_t>("FeTaperedCapsuleRigid_t")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Sphere", &GFeTaperedCapsuleRigid_t::GetSphere, &GFeTaperedCapsuleRigid_t::SetSphere)
        .addProperty("Node", &GFeTaperedCapsuleRigid_t::GetNode, &GFeTaperedCapsuleRigid_t::SetNode)
        .addProperty("CollisionMask", &GFeTaperedCapsuleRigid_t::GetCollisionMask, &GFeTaperedCapsuleRigid_t::SetCollisionMask)
        .addProperty("VertexMapIndex", &GFeTaperedCapsuleRigid_t::GetVertexMapIndex, &GFeTaperedCapsuleRigid_t::SetVertexMapIndex)
        .addProperty("Flags", &GFeTaperedCapsuleRigid_t::GetFlags, &GFeTaperedCapsuleRigid_t::SetFlags)
        .addFunction("ToPtr", &GFeTaperedCapsuleRigid_t::ToPtr)
        .addFunction("IsValid", &GFeTaperedCapsuleRigid_t::IsValid)
        .endClass();
}
GCChoiceUpdateNode::GCChoiceUpdateNode(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCChoiceUpdateNode::GCChoiceUpdateNode(void *ptr) {
    m_ptr = ptr;
}
std::vector<GCAnimUpdateNodeRef> GCChoiceUpdateNode::GetChildren() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CChoiceUpdateNode->Children(ptr=%p)", m_ptr));
    CUtlVector<GCAnimUpdateNodeRef>* vec = GetSchemaValue<CUtlVector<GCAnimUpdateNodeRef>*>(m_ptr, "CChoiceUpdateNode", "m_children"); std::vector<GCAnimUpdateNodeRef> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCChoiceUpdateNode::SetChildren(std::vector<GCAnimUpdateNodeRef> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CChoiceUpdateNode->Children(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<GCAnimUpdateNodeRef>(m_ptr, "CChoiceUpdateNode", "m_children", false, value);
}
std::vector<float32> GCChoiceUpdateNode::GetWeights() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CChoiceUpdateNode->Weights(ptr=%p)", m_ptr));
    CUtlVector<float32>* vec = GetSchemaValue<CUtlVector<float32>*>(m_ptr, "CChoiceUpdateNode", "m_weights"); std::vector<float32> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCChoiceUpdateNode::SetWeights(std::vector<float32> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CChoiceUpdateNode->Weights(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<float32>(m_ptr, "CChoiceUpdateNode", "m_weights", false, value);
}
std::vector<float32> GCChoiceUpdateNode::GetBlendTimes() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CChoiceUpdateNode->BlendTimes(ptr=%p)", m_ptr));
    CUtlVector<float32>* vec = GetSchemaValue<CUtlVector<float32>*>(m_ptr, "CChoiceUpdateNode", "m_blendTimes"); std::vector<float32> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCChoiceUpdateNode::SetBlendTimes(std::vector<float32> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CChoiceUpdateNode->BlendTimes(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<float32>(m_ptr, "CChoiceUpdateNode", "m_blendTimes", false, value);
}
uint64_t GCChoiceUpdateNode::GetChoiceMethod() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CChoiceUpdateNode->ChoiceMethod(ptr=%p)", m_ptr));
    return GetSchemaValue<uint64_t>(m_ptr, "CChoiceUpdateNode", "m_choiceMethod");
}
void GCChoiceUpdateNode::SetChoiceMethod(uint64_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CChoiceUpdateNode->ChoiceMethod(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CChoiceUpdateNode", "m_choiceMethod", false, value);
}
uint64_t GCChoiceUpdateNode::GetChoiceChangeMethod() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CChoiceUpdateNode->ChoiceChangeMethod(ptr=%p)", m_ptr));
    return GetSchemaValue<uint64_t>(m_ptr, "CChoiceUpdateNode", "m_choiceChangeMethod");
}
void GCChoiceUpdateNode::SetChoiceChangeMethod(uint64_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CChoiceUpdateNode->ChoiceChangeMethod(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CChoiceUpdateNode", "m_choiceChangeMethod", false, value);
}
uint64_t GCChoiceUpdateNode::GetBlendMethod() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CChoiceUpdateNode->BlendMethod(ptr=%p)", m_ptr));
    return GetSchemaValue<uint64_t>(m_ptr, "CChoiceUpdateNode", "m_blendMethod");
}
void GCChoiceUpdateNode::SetBlendMethod(uint64_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CChoiceUpdateNode->BlendMethod(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CChoiceUpdateNode", "m_blendMethod", false, value);
}
float GCChoiceUpdateNode::GetBlendTime() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CChoiceUpdateNode->BlendTime(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CChoiceUpdateNode", "m_blendTime");
}
void GCChoiceUpdateNode::SetBlendTime(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CChoiceUpdateNode->BlendTime(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CChoiceUpdateNode", "m_blendTime", false, value);
}
bool GCChoiceUpdateNode::GetCrossFade() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CChoiceUpdateNode->CrossFade(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "CChoiceUpdateNode", "m_bCrossFade");
}
void GCChoiceUpdateNode::SetCrossFade(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CChoiceUpdateNode->CrossFade(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CChoiceUpdateNode", "m_bCrossFade", false, value);
}
bool GCChoiceUpdateNode::GetResetChosen() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CChoiceUpdateNode->ResetChosen(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "CChoiceUpdateNode", "m_bResetChosen");
}
void GCChoiceUpdateNode::SetResetChosen(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CChoiceUpdateNode->ResetChosen(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CChoiceUpdateNode", "m_bResetChosen", false, value);
}
bool GCChoiceUpdateNode::GetDontResetSameSelection() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CChoiceUpdateNode->DontResetSameSelection(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "CChoiceUpdateNode", "m_bDontResetSameSelection");
}
void GCChoiceUpdateNode::SetDontResetSameSelection(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CChoiceUpdateNode->DontResetSameSelection(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CChoiceUpdateNode", "m_bDontResetSameSelection", false, value);
}
void* GCChoiceUpdateNode::GetPtr() {
    return m_ptr;
}
std::string GCChoiceUpdateNode::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCChoiceUpdateNode::IsValid() {
    return (m_ptr != nullptr);
}
GCAnimUpdateNodeBase GCChoiceUpdateNode::GetParent() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CChoiceUpdateNode::GetParent(ptr=%p)", m_ptr));
    GCAnimUpdateNodeBase value(m_ptr);
    return value;
}
void GCChoiceUpdateNode::SetParent(GCAnimUpdateNodeBase value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CChoiceUpdateNode::SetParent(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCChoiceUpdateNode(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCChoiceUpdateNode>("CChoiceUpdateNode")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Children", &GCChoiceUpdateNode::GetChildren, &GCChoiceUpdateNode::SetChildren)
        .addProperty("Weights", &GCChoiceUpdateNode::GetWeights, &GCChoiceUpdateNode::SetWeights)
        .addProperty("BlendTimes", &GCChoiceUpdateNode::GetBlendTimes, &GCChoiceUpdateNode::SetBlendTimes)
        .addProperty("ChoiceMethod", &GCChoiceUpdateNode::GetChoiceMethod, &GCChoiceUpdateNode::SetChoiceMethod)
        .addProperty("ChoiceChangeMethod", &GCChoiceUpdateNode::GetChoiceChangeMethod, &GCChoiceUpdateNode::SetChoiceChangeMethod)
        .addProperty("BlendMethod", &GCChoiceUpdateNode::GetBlendMethod, &GCChoiceUpdateNode::SetBlendMethod)
        .addProperty("BlendTime", &GCChoiceUpdateNode::GetBlendTime, &GCChoiceUpdateNode::SetBlendTime)
        .addProperty("CrossFade", &GCChoiceUpdateNode::GetCrossFade, &GCChoiceUpdateNode::SetCrossFade)
        .addProperty("ResetChosen", &GCChoiceUpdateNode::GetResetChosen, &GCChoiceUpdateNode::SetResetChosen)
        .addProperty("DontResetSameSelection", &GCChoiceUpdateNode::GetDontResetSameSelection, &GCChoiceUpdateNode::SetDontResetSameSelection)
        .addProperty("Parent", &GCChoiceUpdateNode::GetParent, &GCChoiceUpdateNode::SetParent)
        .addFunction("ToPtr", &GCChoiceUpdateNode::ToPtr)
        .addFunction("IsValid", &GCChoiceUpdateNode::IsValid)
        .endClass();
}
GIKSolverSettings_t::GIKSolverSettings_t(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GIKSolverSettings_t::GIKSolverSettings_t(void *ptr) {
    m_ptr = ptr;
}
uint64_t GIKSolverSettings_t::GetSolverType() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: IKSolverSettings_t->SolverType(ptr=%p)", m_ptr));
    return GetSchemaValue<uint64_t>(m_ptr, "IKSolverSettings_t", "m_SolverType");
}
void GIKSolverSettings_t::SetSolverType(uint64_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: IKSolverSettings_t->SolverType(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "IKSolverSettings_t", "m_SolverType", true, value);
}
int32_t GIKSolverSettings_t::GetNumIterations() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: IKSolverSettings_t->NumIterations(ptr=%p)", m_ptr));
    return GetSchemaValue<int32_t>(m_ptr, "IKSolverSettings_t", "m_nNumIterations");
}
void GIKSolverSettings_t::SetNumIterations(int32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: IKSolverSettings_t->NumIterations(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "IKSolverSettings_t", "m_nNumIterations", true, value);
}
void* GIKSolverSettings_t::GetPtr() {
    return m_ptr;
}
std::string GIKSolverSettings_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GIKSolverSettings_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassIKSolverSettings_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GIKSolverSettings_t>("IKSolverSettings_t")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("SolverType", &GIKSolverSettings_t::GetSolverType, &GIKSolverSettings_t::SetSolverType)
        .addProperty("NumIterations", &GIKSolverSettings_t::GetNumIterations, &GIKSolverSettings_t::SetNumIterations)
        .addFunction("ToPtr", &GIKSolverSettings_t::ToPtr)
        .addFunction("IsValid", &GIKSolverSettings_t::IsValid)
        .endClass();
}
GCNmLayerBlendNode::GCNmLayerBlendNode(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCNmLayerBlendNode::GCNmLayerBlendNode(void *ptr) {
    m_ptr = ptr;
}
int16_t GCNmLayerBlendNode::GetBaseNodeIdx() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CNmLayerBlendNode->BaseNodeIdx(ptr=%p)", m_ptr));
    return GetSchemaValue<int16_t>(m_ptr, "CNmLayerBlendNode", "m_nBaseNodeIdx");
}
void GCNmLayerBlendNode::SetBaseNodeIdx(int16_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CNmLayerBlendNode->BaseNodeIdx(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CNmLayerBlendNode", "m_nBaseNodeIdx", false, value);
}
bool GCNmLayerBlendNode::GetOnlySampleBaseRootMotion() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CNmLayerBlendNode->OnlySampleBaseRootMotion(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "CNmLayerBlendNode", "m_bOnlySampleBaseRootMotion");
}
void GCNmLayerBlendNode::SetOnlySampleBaseRootMotion(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CNmLayerBlendNode->OnlySampleBaseRootMotion(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CNmLayerBlendNode", "m_bOnlySampleBaseRootMotion", false, value);
}
void* GCNmLayerBlendNode::GetPtr() {
    return m_ptr;
}
std::string GCNmLayerBlendNode::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCNmLayerBlendNode::IsValid() {
    return (m_ptr != nullptr);
}
GCNmPoseNode GCNmLayerBlendNode::GetParent() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CNmLayerBlendNode::GetParent(ptr=%p)", m_ptr));
    GCNmPoseNode value(m_ptr);
    return value;
}
void GCNmLayerBlendNode::SetParent(GCNmPoseNode value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CNmLayerBlendNode::SetParent(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCNmLayerBlendNode(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCNmLayerBlendNode>("CNmLayerBlendNode")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("BaseNodeIdx", &GCNmLayerBlendNode::GetBaseNodeIdx, &GCNmLayerBlendNode::SetBaseNodeIdx)
        .addProperty("OnlySampleBaseRootMotion", &GCNmLayerBlendNode::GetOnlySampleBaseRootMotion, &GCNmLayerBlendNode::SetOnlySampleBaseRootMotion)
        .addProperty("Parent", &GCNmLayerBlendNode::GetParent, &GCNmLayerBlendNode::SetParent)
        .addFunction("ToPtr", &GCNmLayerBlendNode::ToPtr)
        .addFunction("IsValid", &GCNmLayerBlendNode::IsValid)
        .endClass();
}
GCRandomNumberGeneratorParameters::GCRandomNumberGeneratorParameters(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCRandomNumberGeneratorParameters::GCRandomNumberGeneratorParameters(void *ptr) {
    m_ptr = ptr;
}
bool GCRandomNumberGeneratorParameters::GetDistributeEvenly() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CRandomNumberGeneratorParameters->DistributeEvenly(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "CRandomNumberGeneratorParameters", "m_bDistributeEvenly");
}
void GCRandomNumberGeneratorParameters::SetDistributeEvenly(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CRandomNumberGeneratorParameters->DistributeEvenly(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CRandomNumberGeneratorParameters", "m_bDistributeEvenly", false, value);
}
int32_t GCRandomNumberGeneratorParameters::GetSeed() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CRandomNumberGeneratorParameters->Seed(ptr=%p)", m_ptr));
    return GetSchemaValue<int32_t>(m_ptr, "CRandomNumberGeneratorParameters", "m_nSeed");
}
void GCRandomNumberGeneratorParameters::SetSeed(int32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CRandomNumberGeneratorParameters->Seed(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CRandomNumberGeneratorParameters", "m_nSeed", false, value);
}
void* GCRandomNumberGeneratorParameters::GetPtr() {
    return m_ptr;
}
std::string GCRandomNumberGeneratorParameters::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCRandomNumberGeneratorParameters::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCRandomNumberGeneratorParameters(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCRandomNumberGeneratorParameters>("CRandomNumberGeneratorParameters")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("DistributeEvenly", &GCRandomNumberGeneratorParameters::GetDistributeEvenly, &GCRandomNumberGeneratorParameters::SetDistributeEvenly)
        .addProperty("Seed", &GCRandomNumberGeneratorParameters::GetSeed, &GCRandomNumberGeneratorParameters::SetSeed)
        .addFunction("ToPtr", &GCRandomNumberGeneratorParameters::ToPtr)
        .addFunction("IsValid", &GCRandomNumberGeneratorParameters::IsValid)
        .endClass();
}
GAnimationDecodeDebugDumpElement_t::GAnimationDecodeDebugDumpElement_t(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GAnimationDecodeDebugDumpElement_t::GAnimationDecodeDebugDumpElement_t(void *ptr) {
    m_ptr = ptr;
}
int32_t GAnimationDecodeDebugDumpElement_t::GetEntityIndex() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: AnimationDecodeDebugDumpElement_t->EntityIndex(ptr=%p)", m_ptr));
    return GetSchemaValue<int32_t>(m_ptr, "AnimationDecodeDebugDumpElement_t", "m_nEntityIndex");
}
void GAnimationDecodeDebugDumpElement_t::SetEntityIndex(int32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: AnimationDecodeDebugDumpElement_t->EntityIndex(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "AnimationDecodeDebugDumpElement_t", "m_nEntityIndex", true, value);
}
std::string GAnimationDecodeDebugDumpElement_t::GetModelName() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: AnimationDecodeDebugDumpElement_t->ModelName(ptr=%p)", m_ptr));
    return GetSchemaValue<CUtlString>(m_ptr, "AnimationDecodeDebugDumpElement_t", "m_modelName").Get();
}
void GAnimationDecodeDebugDumpElement_t::SetModelName(std::string value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: AnimationDecodeDebugDumpElement_t->ModelName(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "AnimationDecodeDebugDumpElement_t", "m_modelName", true, CUtlString(value.c_str()));
}
std::vector<CUtlString> GAnimationDecodeDebugDumpElement_t::GetPoseParams() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: AnimationDecodeDebugDumpElement_t->PoseParams(ptr=%p)", m_ptr));
    CUtlVector<CUtlString>* vec = GetSchemaValue<CUtlVector<CUtlString>*>(m_ptr, "AnimationDecodeDebugDumpElement_t", "m_poseParams"); std::vector<CUtlString> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GAnimationDecodeDebugDumpElement_t::SetPoseParams(std::vector<CUtlString> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: AnimationDecodeDebugDumpElement_t->PoseParams(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<CUtlString>(m_ptr, "AnimationDecodeDebugDumpElement_t", "m_poseParams", true, value);
}
std::vector<CUtlString> GAnimationDecodeDebugDumpElement_t::GetDecodeOps() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: AnimationDecodeDebugDumpElement_t->DecodeOps(ptr=%p)", m_ptr));
    CUtlVector<CUtlString>* vec = GetSchemaValue<CUtlVector<CUtlString>*>(m_ptr, "AnimationDecodeDebugDumpElement_t", "m_decodeOps"); std::vector<CUtlString> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GAnimationDecodeDebugDumpElement_t::SetDecodeOps(std::vector<CUtlString> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: AnimationDecodeDebugDumpElement_t->DecodeOps(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<CUtlString>(m_ptr, "AnimationDecodeDebugDumpElement_t", "m_decodeOps", true, value);
}
std::vector<CUtlString> GAnimationDecodeDebugDumpElement_t::GetInternalOps() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: AnimationDecodeDebugDumpElement_t->InternalOps(ptr=%p)", m_ptr));
    CUtlVector<CUtlString>* vec = GetSchemaValue<CUtlVector<CUtlString>*>(m_ptr, "AnimationDecodeDebugDumpElement_t", "m_internalOps"); std::vector<CUtlString> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GAnimationDecodeDebugDumpElement_t::SetInternalOps(std::vector<CUtlString> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: AnimationDecodeDebugDumpElement_t->InternalOps(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<CUtlString>(m_ptr, "AnimationDecodeDebugDumpElement_t", "m_internalOps", true, value);
}
std::vector<CUtlString> GAnimationDecodeDebugDumpElement_t::GetDecodedAnims() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: AnimationDecodeDebugDumpElement_t->DecodedAnims(ptr=%p)", m_ptr));
    CUtlVector<CUtlString>* vec = GetSchemaValue<CUtlVector<CUtlString>*>(m_ptr, "AnimationDecodeDebugDumpElement_t", "m_decodedAnims"); std::vector<CUtlString> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GAnimationDecodeDebugDumpElement_t::SetDecodedAnims(std::vector<CUtlString> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: AnimationDecodeDebugDumpElement_t->DecodedAnims(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<CUtlString>(m_ptr, "AnimationDecodeDebugDumpElement_t", "m_decodedAnims", true, value);
}
void* GAnimationDecodeDebugDumpElement_t::GetPtr() {
    return m_ptr;
}
std::string GAnimationDecodeDebugDumpElement_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GAnimationDecodeDebugDumpElement_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassAnimationDecodeDebugDumpElement_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GAnimationDecodeDebugDumpElement_t>("AnimationDecodeDebugDumpElement_t")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("EntityIndex", &GAnimationDecodeDebugDumpElement_t::GetEntityIndex, &GAnimationDecodeDebugDumpElement_t::SetEntityIndex)
        .addProperty("ModelName", &GAnimationDecodeDebugDumpElement_t::GetModelName, &GAnimationDecodeDebugDumpElement_t::SetModelName)
        .addProperty("PoseParams", &GAnimationDecodeDebugDumpElement_t::GetPoseParams, &GAnimationDecodeDebugDumpElement_t::SetPoseParams)
        .addProperty("DecodeOps", &GAnimationDecodeDebugDumpElement_t::GetDecodeOps, &GAnimationDecodeDebugDumpElement_t::SetDecodeOps)
        .addProperty("InternalOps", &GAnimationDecodeDebugDumpElement_t::GetInternalOps, &GAnimationDecodeDebugDumpElement_t::SetInternalOps)
        .addProperty("DecodedAnims", &GAnimationDecodeDebugDumpElement_t::GetDecodedAnims, &GAnimationDecodeDebugDumpElement_t::SetDecodedAnims)
        .addFunction("ToPtr", &GAnimationDecodeDebugDumpElement_t::ToPtr)
        .addFunction("IsValid", &GAnimationDecodeDebugDumpElement_t::IsValid)
        .endClass();
}
GCNmFloatValueNode::GCNmFloatValueNode(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCNmFloatValueNode::GCNmFloatValueNode(void *ptr) {
    m_ptr = ptr;
}
void* GCNmFloatValueNode::GetPtr() {
    return m_ptr;
}
std::string GCNmFloatValueNode::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCNmFloatValueNode::IsValid() {
    return (m_ptr != nullptr);
}
GCNmValueNode GCNmFloatValueNode::GetParent() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CNmFloatValueNode::GetParent(ptr=%p)", m_ptr));
    GCNmValueNode value(m_ptr);
    return value;
}
void GCNmFloatValueNode::SetParent(GCNmValueNode value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CNmFloatValueNode::SetParent(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCNmFloatValueNode(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCNmFloatValueNode>("CNmFloatValueNode")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Parent", &GCNmFloatValueNode::GetParent, &GCNmFloatValueNode::SetParent)
        .addFunction("ToPtr", &GCNmFloatValueNode::ToPtr)
        .addFunction("IsValid", &GCNmFloatValueNode::IsValid)
        .endClass();
}
GCSSDSMsg_LayerBase::GCSSDSMsg_LayerBase(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCSSDSMsg_LayerBase::GCSSDSMsg_LayerBase(void *ptr) {
    m_ptr = ptr;
}
GSceneViewId_t GCSSDSMsg_LayerBase::GetViewId() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CSSDSMsg_LayerBase->ViewId(ptr=%p)", m_ptr));
    GSceneViewId_t value(GetSchemaPtr(m_ptr, "CSSDSMsg_LayerBase", "m_viewId"));
    return value;
}
void GCSSDSMsg_LayerBase::SetViewId(GSceneViewId_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CSSDSMsg_LayerBase->ViewId(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'ViewId' is not possible.\n");
}
std::string GCSSDSMsg_LayerBase::GetViewName() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CSSDSMsg_LayerBase->ViewName(ptr=%p)", m_ptr));
    return GetSchemaValue<CUtlString>(m_ptr, "CSSDSMsg_LayerBase", "m_ViewName").Get();
}
void GCSSDSMsg_LayerBase::SetViewName(std::string value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CSSDSMsg_LayerBase->ViewName(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CSSDSMsg_LayerBase", "m_ViewName", false, CUtlString(value.c_str()));
}
int32_t GCSSDSMsg_LayerBase::GetLayerIndex() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CSSDSMsg_LayerBase->LayerIndex(ptr=%p)", m_ptr));
    return GetSchemaValue<int32_t>(m_ptr, "CSSDSMsg_LayerBase", "m_nLayerIndex");
}
void GCSSDSMsg_LayerBase::SetLayerIndex(int32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CSSDSMsg_LayerBase->LayerIndex(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CSSDSMsg_LayerBase", "m_nLayerIndex", false, value);
}
uint64_t GCSSDSMsg_LayerBase::GetLayerId() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CSSDSMsg_LayerBase->LayerId(ptr=%p)", m_ptr));
    return GetSchemaValue<uint64_t>(m_ptr, "CSSDSMsg_LayerBase", "m_nLayerId");
}
void GCSSDSMsg_LayerBase::SetLayerId(uint64_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CSSDSMsg_LayerBase->LayerId(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CSSDSMsg_LayerBase", "m_nLayerId", false, value);
}
std::string GCSSDSMsg_LayerBase::GetLayerName() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CSSDSMsg_LayerBase->LayerName(ptr=%p)", m_ptr));
    return GetSchemaValue<CUtlString>(m_ptr, "CSSDSMsg_LayerBase", "m_LayerName").Get();
}
void GCSSDSMsg_LayerBase::SetLayerName(std::string value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CSSDSMsg_LayerBase->LayerName(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CSSDSMsg_LayerBase", "m_LayerName", false, CUtlString(value.c_str()));
}
std::string GCSSDSMsg_LayerBase::GetDisplayText() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CSSDSMsg_LayerBase->DisplayText(ptr=%p)", m_ptr));
    return GetSchemaValue<CUtlString>(m_ptr, "CSSDSMsg_LayerBase", "m_displayText").Get();
}
void GCSSDSMsg_LayerBase::SetDisplayText(std::string value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CSSDSMsg_LayerBase->DisplayText(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CSSDSMsg_LayerBase", "m_displayText", false, CUtlString(value.c_str()));
}
void* GCSSDSMsg_LayerBase::GetPtr() {
    return m_ptr;
}
std::string GCSSDSMsg_LayerBase::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCSSDSMsg_LayerBase::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCSSDSMsg_LayerBase(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCSSDSMsg_LayerBase>("CSSDSMsg_LayerBase")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("ViewId", &GCSSDSMsg_LayerBase::GetViewId, &GCSSDSMsg_LayerBase::SetViewId)
        .addProperty("ViewName", &GCSSDSMsg_LayerBase::GetViewName, &GCSSDSMsg_LayerBase::SetViewName)
        .addProperty("LayerIndex", &GCSSDSMsg_LayerBase::GetLayerIndex, &GCSSDSMsg_LayerBase::SetLayerIndex)
        .addProperty("LayerId", &GCSSDSMsg_LayerBase::GetLayerId, &GCSSDSMsg_LayerBase::SetLayerId)
        .addProperty("LayerName", &GCSSDSMsg_LayerBase::GetLayerName, &GCSSDSMsg_LayerBase::SetLayerName)
        .addProperty("DisplayText", &GCSSDSMsg_LayerBase::GetDisplayText, &GCSSDSMsg_LayerBase::SetDisplayText)
        .addFunction("ToPtr", &GCSSDSMsg_LayerBase::ToPtr)
        .addFunction("IsValid", &GCSSDSMsg_LayerBase::IsValid)
        .endClass();
}
GCSosGroupActionSoundeventClusterSchema::GCSosGroupActionSoundeventClusterSchema(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCSosGroupActionSoundeventClusterSchema::GCSosGroupActionSoundeventClusterSchema(void *ptr) {
    m_ptr = ptr;
}
int32_t GCSosGroupActionSoundeventClusterSchema::GetMinNearby() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CSosGroupActionSoundeventClusterSchema->MinNearby(ptr=%p)", m_ptr));
    return GetSchemaValue<int32_t>(m_ptr, "CSosGroupActionSoundeventClusterSchema", "m_nMinNearby");
}
void GCSosGroupActionSoundeventClusterSchema::SetMinNearby(int32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CSosGroupActionSoundeventClusterSchema->MinNearby(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CSosGroupActionSoundeventClusterSchema", "m_nMinNearby", false, value);
}
float GCSosGroupActionSoundeventClusterSchema::GetClusterEpsilon() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CSosGroupActionSoundeventClusterSchema->ClusterEpsilon(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CSosGroupActionSoundeventClusterSchema", "m_flClusterEpsilon");
}
void GCSosGroupActionSoundeventClusterSchema::SetClusterEpsilon(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CSosGroupActionSoundeventClusterSchema->ClusterEpsilon(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CSosGroupActionSoundeventClusterSchema", "m_flClusterEpsilon", false, value);
}
std::string GCSosGroupActionSoundeventClusterSchema::GetShouldPlayOpvar() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CSosGroupActionSoundeventClusterSchema->ShouldPlayOpvar(ptr=%p)", m_ptr));
    return GetSchemaValue<CUtlString>(m_ptr, "CSosGroupActionSoundeventClusterSchema", "m_shouldPlayOpvar").Get();
}
void GCSosGroupActionSoundeventClusterSchema::SetShouldPlayOpvar(std::string value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CSosGroupActionSoundeventClusterSchema->ShouldPlayOpvar(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CSosGroupActionSoundeventClusterSchema", "m_shouldPlayOpvar", false, CUtlString(value.c_str()));
}
std::string GCSosGroupActionSoundeventClusterSchema::GetShouldPlayClusterChild() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CSosGroupActionSoundeventClusterSchema->ShouldPlayClusterChild(ptr=%p)", m_ptr));
    return GetSchemaValue<CUtlString>(m_ptr, "CSosGroupActionSoundeventClusterSchema", "m_shouldPlayClusterChild").Get();
}
void GCSosGroupActionSoundeventClusterSchema::SetShouldPlayClusterChild(std::string value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CSosGroupActionSoundeventClusterSchema->ShouldPlayClusterChild(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CSosGroupActionSoundeventClusterSchema", "m_shouldPlayClusterChild", false, CUtlString(value.c_str()));
}
std::string GCSosGroupActionSoundeventClusterSchema::GetClusterSizeOpvar() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CSosGroupActionSoundeventClusterSchema->ClusterSizeOpvar(ptr=%p)", m_ptr));
    return GetSchemaValue<CUtlString>(m_ptr, "CSosGroupActionSoundeventClusterSchema", "m_clusterSizeOpvar").Get();
}
void GCSosGroupActionSoundeventClusterSchema::SetClusterSizeOpvar(std::string value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CSosGroupActionSoundeventClusterSchema->ClusterSizeOpvar(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CSosGroupActionSoundeventClusterSchema", "m_clusterSizeOpvar", false, CUtlString(value.c_str()));
}
std::string GCSosGroupActionSoundeventClusterSchema::GetGroupBoundingBoxMinsOpvar() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CSosGroupActionSoundeventClusterSchema->GroupBoundingBoxMinsOpvar(ptr=%p)", m_ptr));
    return GetSchemaValue<CUtlString>(m_ptr, "CSosGroupActionSoundeventClusterSchema", "m_groupBoundingBoxMinsOpvar").Get();
}
void GCSosGroupActionSoundeventClusterSchema::SetGroupBoundingBoxMinsOpvar(std::string value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CSosGroupActionSoundeventClusterSchema->GroupBoundingBoxMinsOpvar(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CSosGroupActionSoundeventClusterSchema", "m_groupBoundingBoxMinsOpvar", false, CUtlString(value.c_str()));
}
std::string GCSosGroupActionSoundeventClusterSchema::GetGroupBoundingBoxMaxsOpvar() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CSosGroupActionSoundeventClusterSchema->GroupBoundingBoxMaxsOpvar(ptr=%p)", m_ptr));
    return GetSchemaValue<CUtlString>(m_ptr, "CSosGroupActionSoundeventClusterSchema", "m_groupBoundingBoxMaxsOpvar").Get();
}
void GCSosGroupActionSoundeventClusterSchema::SetGroupBoundingBoxMaxsOpvar(std::string value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CSosGroupActionSoundeventClusterSchema->GroupBoundingBoxMaxsOpvar(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CSosGroupActionSoundeventClusterSchema", "m_groupBoundingBoxMaxsOpvar", false, CUtlString(value.c_str()));
}
void* GCSosGroupActionSoundeventClusterSchema::GetPtr() {
    return m_ptr;
}
std::string GCSosGroupActionSoundeventClusterSchema::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCSosGroupActionSoundeventClusterSchema::IsValid() {
    return (m_ptr != nullptr);
}
GCSosGroupActionSchema GCSosGroupActionSoundeventClusterSchema::GetParent() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CSosGroupActionSoundeventClusterSchema::GetParent(ptr=%p)", m_ptr));
    GCSosGroupActionSchema value(m_ptr);
    return value;
}
void GCSosGroupActionSoundeventClusterSchema::SetParent(GCSosGroupActionSchema value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CSosGroupActionSoundeventClusterSchema::SetParent(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCSosGroupActionSoundeventClusterSchema(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCSosGroupActionSoundeventClusterSchema>("CSosGroupActionSoundeventClusterSchema")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("MinNearby", &GCSosGroupActionSoundeventClusterSchema::GetMinNearby, &GCSosGroupActionSoundeventClusterSchema::SetMinNearby)
        .addProperty("ClusterEpsilon", &GCSosGroupActionSoundeventClusterSchema::GetClusterEpsilon, &GCSosGroupActionSoundeventClusterSchema::SetClusterEpsilon)
        .addProperty("ShouldPlayOpvar", &GCSosGroupActionSoundeventClusterSchema::GetShouldPlayOpvar, &GCSosGroupActionSoundeventClusterSchema::SetShouldPlayOpvar)
        .addProperty("ShouldPlayClusterChild", &GCSosGroupActionSoundeventClusterSchema::GetShouldPlayClusterChild, &GCSosGroupActionSoundeventClusterSchema::SetShouldPlayClusterChild)
        .addProperty("ClusterSizeOpvar", &GCSosGroupActionSoundeventClusterSchema::GetClusterSizeOpvar, &GCSosGroupActionSoundeventClusterSchema::SetClusterSizeOpvar)
        .addProperty("GroupBoundingBoxMinsOpvar", &GCSosGroupActionSoundeventClusterSchema::GetGroupBoundingBoxMinsOpvar, &GCSosGroupActionSoundeventClusterSchema::SetGroupBoundingBoxMinsOpvar)
        .addProperty("GroupBoundingBoxMaxsOpvar", &GCSosGroupActionSoundeventClusterSchema::GetGroupBoundingBoxMaxsOpvar, &GCSosGroupActionSoundeventClusterSchema::SetGroupBoundingBoxMaxsOpvar)
        .addProperty("Parent", &GCSosGroupActionSoundeventClusterSchema::GetParent, &GCSosGroupActionSoundeventClusterSchema::SetParent)
        .addFunction("ToPtr", &GCSosGroupActionSoundeventClusterSchema::ToPtr)
        .addFunction("IsValid", &GCSosGroupActionSoundeventClusterSchema::IsValid)
        .endClass();
}
GCAnimationGraphVisualizerAxis::GCAnimationGraphVisualizerAxis(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCAnimationGraphVisualizerAxis::GCAnimationGraphVisualizerAxis(void *ptr) {
    m_ptr = ptr;
}
float GCAnimationGraphVisualizerAxis::GetAxisSize() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CAnimationGraphVisualizerAxis->AxisSize(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CAnimationGraphVisualizerAxis", "m_flAxisSize");
}
void GCAnimationGraphVisualizerAxis::SetAxisSize(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CAnimationGraphVisualizerAxis->AxisSize(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CAnimationGraphVisualizerAxis", "m_flAxisSize", false, value);
}
void* GCAnimationGraphVisualizerAxis::GetPtr() {
    return m_ptr;
}
std::string GCAnimationGraphVisualizerAxis::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCAnimationGraphVisualizerAxis::IsValid() {
    return (m_ptr != nullptr);
}
GCAnimationGraphVisualizerPrimitiveBase GCAnimationGraphVisualizerAxis::GetParent() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CAnimationGraphVisualizerAxis::GetParent(ptr=%p)", m_ptr));
    GCAnimationGraphVisualizerPrimitiveBase value(m_ptr);
    return value;
}
void GCAnimationGraphVisualizerAxis::SetParent(GCAnimationGraphVisualizerPrimitiveBase value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CAnimationGraphVisualizerAxis::SetParent(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCAnimationGraphVisualizerAxis(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCAnimationGraphVisualizerAxis>("CAnimationGraphVisualizerAxis")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("AxisSize", &GCAnimationGraphVisualizerAxis::GetAxisSize, &GCAnimationGraphVisualizerAxis::SetAxisSize)
        .addProperty("Parent", &GCAnimationGraphVisualizerAxis::GetParent, &GCAnimationGraphVisualizerAxis::SetParent)
        .addFunction("ToPtr", &GCAnimationGraphVisualizerAxis::ToPtr)
        .addFunction("IsValid", &GCAnimationGraphVisualizerAxis::IsValid)
        .endClass();
}
GMaterialResourceData_t::GMaterialResourceData_t(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GMaterialResourceData_t::GMaterialResourceData_t(void *ptr) {
    m_ptr = ptr;
}
std::string GMaterialResourceData_t::GetMaterialName() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: MaterialResourceData_t->MaterialName(ptr=%p)", m_ptr));
    return GetSchemaValue<CUtlString>(m_ptr, "MaterialResourceData_t", "m_materialName").Get();
}
void GMaterialResourceData_t::SetMaterialName(std::string value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: MaterialResourceData_t->MaterialName(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "MaterialResourceData_t", "m_materialName", true, CUtlString(value.c_str()));
}
std::string GMaterialResourceData_t::GetShaderName() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: MaterialResourceData_t->ShaderName(ptr=%p)", m_ptr));
    return GetSchemaValue<CUtlString>(m_ptr, "MaterialResourceData_t", "m_shaderName").Get();
}
void GMaterialResourceData_t::SetShaderName(std::string value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: MaterialResourceData_t->ShaderName(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "MaterialResourceData_t", "m_shaderName", true, CUtlString(value.c_str()));
}
std::vector<GMaterialParamInt_t> GMaterialResourceData_t::GetIntParams() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: MaterialResourceData_t->IntParams(ptr=%p)", m_ptr));
    CUtlVector<GMaterialParamInt_t>* vec = GetSchemaValue<CUtlVector<GMaterialParamInt_t>*>(m_ptr, "MaterialResourceData_t", "m_intParams"); std::vector<GMaterialParamInt_t> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GMaterialResourceData_t::SetIntParams(std::vector<GMaterialParamInt_t> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: MaterialResourceData_t->IntParams(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<GMaterialParamInt_t>(m_ptr, "MaterialResourceData_t", "m_intParams", true, value);
}
std::vector<GMaterialParamFloat_t> GMaterialResourceData_t::GetFloatParams() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: MaterialResourceData_t->FloatParams(ptr=%p)", m_ptr));
    CUtlVector<GMaterialParamFloat_t>* vec = GetSchemaValue<CUtlVector<GMaterialParamFloat_t>*>(m_ptr, "MaterialResourceData_t", "m_floatParams"); std::vector<GMaterialParamFloat_t> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GMaterialResourceData_t::SetFloatParams(std::vector<GMaterialParamFloat_t> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: MaterialResourceData_t->FloatParams(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<GMaterialParamFloat_t>(m_ptr, "MaterialResourceData_t", "m_floatParams", true, value);
}
std::vector<GMaterialParamVector_t> GMaterialResourceData_t::GetVectorParams() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: MaterialResourceData_t->VectorParams(ptr=%p)", m_ptr));
    CUtlVector<GMaterialParamVector_t>* vec = GetSchemaValue<CUtlVector<GMaterialParamVector_t>*>(m_ptr, "MaterialResourceData_t", "m_vectorParams"); std::vector<GMaterialParamVector_t> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GMaterialResourceData_t::SetVectorParams(std::vector<GMaterialParamVector_t> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: MaterialResourceData_t->VectorParams(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<GMaterialParamVector_t>(m_ptr, "MaterialResourceData_t", "m_vectorParams", true, value);
}
std::vector<GMaterialParamTexture_t> GMaterialResourceData_t::GetTextureParams() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: MaterialResourceData_t->TextureParams(ptr=%p)", m_ptr));
    CUtlVector<GMaterialParamTexture_t>* vec = GetSchemaValue<CUtlVector<GMaterialParamTexture_t>*>(m_ptr, "MaterialResourceData_t", "m_textureParams"); std::vector<GMaterialParamTexture_t> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GMaterialResourceData_t::SetTextureParams(std::vector<GMaterialParamTexture_t> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: MaterialResourceData_t->TextureParams(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<GMaterialParamTexture_t>(m_ptr, "MaterialResourceData_t", "m_textureParams", true, value);
}
std::vector<GMaterialParamBuffer_t> GMaterialResourceData_t::GetDynamicParams() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: MaterialResourceData_t->DynamicParams(ptr=%p)", m_ptr));
    CUtlVector<GMaterialParamBuffer_t>* vec = GetSchemaValue<CUtlVector<GMaterialParamBuffer_t>*>(m_ptr, "MaterialResourceData_t", "m_dynamicParams"); std::vector<GMaterialParamBuffer_t> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GMaterialResourceData_t::SetDynamicParams(std::vector<GMaterialParamBuffer_t> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: MaterialResourceData_t->DynamicParams(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<GMaterialParamBuffer_t>(m_ptr, "MaterialResourceData_t", "m_dynamicParams", true, value);
}
std::vector<GMaterialParamBuffer_t> GMaterialResourceData_t::GetDynamicTextureParams() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: MaterialResourceData_t->DynamicTextureParams(ptr=%p)", m_ptr));
    CUtlVector<GMaterialParamBuffer_t>* vec = GetSchemaValue<CUtlVector<GMaterialParamBuffer_t>*>(m_ptr, "MaterialResourceData_t", "m_dynamicTextureParams"); std::vector<GMaterialParamBuffer_t> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GMaterialResourceData_t::SetDynamicTextureParams(std::vector<GMaterialParamBuffer_t> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: MaterialResourceData_t->DynamicTextureParams(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<GMaterialParamBuffer_t>(m_ptr, "MaterialResourceData_t", "m_dynamicTextureParams", true, value);
}
std::vector<GMaterialParamInt_t> GMaterialResourceData_t::GetIntAttributes() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: MaterialResourceData_t->IntAttributes(ptr=%p)", m_ptr));
    CUtlVector<GMaterialParamInt_t>* vec = GetSchemaValue<CUtlVector<GMaterialParamInt_t>*>(m_ptr, "MaterialResourceData_t", "m_intAttributes"); std::vector<GMaterialParamInt_t> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GMaterialResourceData_t::SetIntAttributes(std::vector<GMaterialParamInt_t> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: MaterialResourceData_t->IntAttributes(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<GMaterialParamInt_t>(m_ptr, "MaterialResourceData_t", "m_intAttributes", true, value);
}
std::vector<GMaterialParamFloat_t> GMaterialResourceData_t::GetFloatAttributes() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: MaterialResourceData_t->FloatAttributes(ptr=%p)", m_ptr));
    CUtlVector<GMaterialParamFloat_t>* vec = GetSchemaValue<CUtlVector<GMaterialParamFloat_t>*>(m_ptr, "MaterialResourceData_t", "m_floatAttributes"); std::vector<GMaterialParamFloat_t> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GMaterialResourceData_t::SetFloatAttributes(std::vector<GMaterialParamFloat_t> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: MaterialResourceData_t->FloatAttributes(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<GMaterialParamFloat_t>(m_ptr, "MaterialResourceData_t", "m_floatAttributes", true, value);
}
std::vector<GMaterialParamVector_t> GMaterialResourceData_t::GetVectorAttributes() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: MaterialResourceData_t->VectorAttributes(ptr=%p)", m_ptr));
    CUtlVector<GMaterialParamVector_t>* vec = GetSchemaValue<CUtlVector<GMaterialParamVector_t>*>(m_ptr, "MaterialResourceData_t", "m_vectorAttributes"); std::vector<GMaterialParamVector_t> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GMaterialResourceData_t::SetVectorAttributes(std::vector<GMaterialParamVector_t> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: MaterialResourceData_t->VectorAttributes(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<GMaterialParamVector_t>(m_ptr, "MaterialResourceData_t", "m_vectorAttributes", true, value);
}
std::vector<GMaterialParamTexture_t> GMaterialResourceData_t::GetTextureAttributes() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: MaterialResourceData_t->TextureAttributes(ptr=%p)", m_ptr));
    CUtlVector<GMaterialParamTexture_t>* vec = GetSchemaValue<CUtlVector<GMaterialParamTexture_t>*>(m_ptr, "MaterialResourceData_t", "m_textureAttributes"); std::vector<GMaterialParamTexture_t> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GMaterialResourceData_t::SetTextureAttributes(std::vector<GMaterialParamTexture_t> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: MaterialResourceData_t->TextureAttributes(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<GMaterialParamTexture_t>(m_ptr, "MaterialResourceData_t", "m_textureAttributes", true, value);
}
std::vector<GMaterialParamString_t> GMaterialResourceData_t::GetStringAttributes() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: MaterialResourceData_t->StringAttributes(ptr=%p)", m_ptr));
    CUtlVector<GMaterialParamString_t>* vec = GetSchemaValue<CUtlVector<GMaterialParamString_t>*>(m_ptr, "MaterialResourceData_t", "m_stringAttributes"); std::vector<GMaterialParamString_t> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GMaterialResourceData_t::SetStringAttributes(std::vector<GMaterialParamString_t> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: MaterialResourceData_t->StringAttributes(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<GMaterialParamString_t>(m_ptr, "MaterialResourceData_t", "m_stringAttributes", true, value);
}
std::vector<CUtlString> GMaterialResourceData_t::GetRenderAttributesUsed() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: MaterialResourceData_t->RenderAttributesUsed(ptr=%p)", m_ptr));
    CUtlVector<CUtlString>* vec = GetSchemaValue<CUtlVector<CUtlString>*>(m_ptr, "MaterialResourceData_t", "m_renderAttributesUsed"); std::vector<CUtlString> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GMaterialResourceData_t::SetRenderAttributesUsed(std::vector<CUtlString> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: MaterialResourceData_t->RenderAttributesUsed(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<CUtlString>(m_ptr, "MaterialResourceData_t", "m_renderAttributesUsed", true, value);
}
void* GMaterialResourceData_t::GetPtr() {
    return m_ptr;
}
std::string GMaterialResourceData_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GMaterialResourceData_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassMaterialResourceData_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GMaterialResourceData_t>("MaterialResourceData_t")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("MaterialName", &GMaterialResourceData_t::GetMaterialName, &GMaterialResourceData_t::SetMaterialName)
        .addProperty("ShaderName", &GMaterialResourceData_t::GetShaderName, &GMaterialResourceData_t::SetShaderName)
        .addProperty("IntParams", &GMaterialResourceData_t::GetIntParams, &GMaterialResourceData_t::SetIntParams)
        .addProperty("FloatParams", &GMaterialResourceData_t::GetFloatParams, &GMaterialResourceData_t::SetFloatParams)
        .addProperty("VectorParams", &GMaterialResourceData_t::GetVectorParams, &GMaterialResourceData_t::SetVectorParams)
        .addProperty("TextureParams", &GMaterialResourceData_t::GetTextureParams, &GMaterialResourceData_t::SetTextureParams)
        .addProperty("DynamicParams", &GMaterialResourceData_t::GetDynamicParams, &GMaterialResourceData_t::SetDynamicParams)
        .addProperty("DynamicTextureParams", &GMaterialResourceData_t::GetDynamicTextureParams, &GMaterialResourceData_t::SetDynamicTextureParams)
        .addProperty("IntAttributes", &GMaterialResourceData_t::GetIntAttributes, &GMaterialResourceData_t::SetIntAttributes)
        .addProperty("FloatAttributes", &GMaterialResourceData_t::GetFloatAttributes, &GMaterialResourceData_t::SetFloatAttributes)
        .addProperty("VectorAttributes", &GMaterialResourceData_t::GetVectorAttributes, &GMaterialResourceData_t::SetVectorAttributes)
        .addProperty("TextureAttributes", &GMaterialResourceData_t::GetTextureAttributes, &GMaterialResourceData_t::SetTextureAttributes)
        .addProperty("StringAttributes", &GMaterialResourceData_t::GetStringAttributes, &GMaterialResourceData_t::SetStringAttributes)
        .addProperty("RenderAttributesUsed", &GMaterialResourceData_t::GetRenderAttributesUsed, &GMaterialResourceData_t::SetRenderAttributesUsed)
        .addFunction("ToPtr", &GMaterialResourceData_t::ToPtr)
        .addFunction("IsValid", &GMaterialResourceData_t::IsValid)
        .endClass();
}
GBlendItem_t::GBlendItem_t(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GBlendItem_t::GBlendItem_t(void *ptr) {
    m_ptr = ptr;
}
std::vector<GTagSpan_t> GBlendItem_t::GetTags() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: BlendItem_t->Tags(ptr=%p)", m_ptr));
    CUtlVector<GTagSpan_t>* vec = GetSchemaValue<CUtlVector<GTagSpan_t>*>(m_ptr, "BlendItem_t", "m_tags"); std::vector<GTagSpan_t> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GBlendItem_t::SetTags(std::vector<GTagSpan_t> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: BlendItem_t->Tags(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<GTagSpan_t>(m_ptr, "BlendItem_t", "m_tags", true, value);
}
GCAnimUpdateNodeRef GBlendItem_t::GetChild() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: BlendItem_t->Child(ptr=%p)", m_ptr));
    GCAnimUpdateNodeRef value(GetSchemaPtr(m_ptr, "BlendItem_t", "m_pChild"));
    return value;
}
void GBlendItem_t::SetChild(GCAnimUpdateNodeRef value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: BlendItem_t->Child(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Child' is not possible.\n");
}
Vector2D GBlendItem_t::GetPos() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: BlendItem_t->Pos(ptr=%p)", m_ptr));
    return GetSchemaValue<Vector2D>(m_ptr, "BlendItem_t", "m_vPos");
}
void GBlendItem_t::SetPos(Vector2D value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: BlendItem_t->Pos(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "BlendItem_t", "m_vPos", true, value);
}
float GBlendItem_t::GetDuration() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: BlendItem_t->Duration(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "BlendItem_t", "m_flDuration");
}
void GBlendItem_t::SetDuration(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: BlendItem_t->Duration(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "BlendItem_t", "m_flDuration", true, value);
}
bool GBlendItem_t::GetUseCustomDuration() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: BlendItem_t->UseCustomDuration(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "BlendItem_t", "m_bUseCustomDuration");
}
void GBlendItem_t::SetUseCustomDuration(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: BlendItem_t->UseCustomDuration(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "BlendItem_t", "m_bUseCustomDuration", true, value);
}
void* GBlendItem_t::GetPtr() {
    return m_ptr;
}
std::string GBlendItem_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GBlendItem_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassBlendItem_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GBlendItem_t>("BlendItem_t")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Tags", &GBlendItem_t::GetTags, &GBlendItem_t::SetTags)
        .addProperty("Child", &GBlendItem_t::GetChild, &GBlendItem_t::SetChild)
        .addProperty("Pos", &GBlendItem_t::GetPos, &GBlendItem_t::SetPos)
        .addProperty("Duration", &GBlendItem_t::GetDuration, &GBlendItem_t::SetDuration)
        .addProperty("UseCustomDuration", &GBlendItem_t::GetUseCustomDuration, &GBlendItem_t::SetUseCustomDuration)
        .addFunction("ToPtr", &GBlendItem_t::ToPtr)
        .addFunction("IsValid", &GBlendItem_t::IsValid)
        .endClass();
}
GCVoiceContainerAnalysisBase::GCVoiceContainerAnalysisBase(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCVoiceContainerAnalysisBase::GCVoiceContainerAnalysisBase(void *ptr) {
    m_ptr = ptr;
}
bool GCVoiceContainerAnalysisBase::GetRegenerateCurveOnCompile() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CVoiceContainerAnalysisBase->RegenerateCurveOnCompile(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "CVoiceContainerAnalysisBase", "m_bRegenerateCurveOnCompile");
}
void GCVoiceContainerAnalysisBase::SetRegenerateCurveOnCompile(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CVoiceContainerAnalysisBase->RegenerateCurveOnCompile(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CVoiceContainerAnalysisBase", "m_bRegenerateCurveOnCompile", false, value);
}
void* GCVoiceContainerAnalysisBase::GetPtr() {
    return m_ptr;
}
std::string GCVoiceContainerAnalysisBase::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCVoiceContainerAnalysisBase::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCVoiceContainerAnalysisBase(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCVoiceContainerAnalysisBase>("CVoiceContainerAnalysisBase")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("RegenerateCurveOnCompile", &GCVoiceContainerAnalysisBase::GetRegenerateCurveOnCompile, &GCVoiceContainerAnalysisBase::SetRegenerateCurveOnCompile)
        .addFunction("ToPtr", &GCVoiceContainerAnalysisBase::ToPtr)
        .addFunction("IsValid", &GCVoiceContainerAnalysisBase::IsValid)
        .endClass();
}
GCSosGroupActionLimitSchema::GCSosGroupActionLimitSchema(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCSosGroupActionLimitSchema::GCSosGroupActionLimitSchema(void *ptr) {
    m_ptr = ptr;
}
int32_t GCSosGroupActionLimitSchema::GetMaxCount() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CSosGroupActionLimitSchema->MaxCount(ptr=%p)", m_ptr));
    return GetSchemaValue<int32_t>(m_ptr, "CSosGroupActionLimitSchema", "m_nMaxCount");
}
void GCSosGroupActionLimitSchema::SetMaxCount(int32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CSosGroupActionLimitSchema->MaxCount(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CSosGroupActionLimitSchema", "m_nMaxCount", false, value);
}
uint64_t GCSosGroupActionLimitSchema::GetStopType() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CSosGroupActionLimitSchema->StopType(ptr=%p)", m_ptr));
    return GetSchemaValue<uint64_t>(m_ptr, "CSosGroupActionLimitSchema", "m_nStopType");
}
void GCSosGroupActionLimitSchema::SetStopType(uint64_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CSosGroupActionLimitSchema->StopType(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CSosGroupActionLimitSchema", "m_nStopType", false, value);
}
uint64_t GCSosGroupActionLimitSchema::GetSortType() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CSosGroupActionLimitSchema->SortType(ptr=%p)", m_ptr));
    return GetSchemaValue<uint64_t>(m_ptr, "CSosGroupActionLimitSchema", "m_nSortType");
}
void GCSosGroupActionLimitSchema::SetSortType(uint64_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CSosGroupActionLimitSchema->SortType(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CSosGroupActionLimitSchema", "m_nSortType", false, value);
}
void* GCSosGroupActionLimitSchema::GetPtr() {
    return m_ptr;
}
std::string GCSosGroupActionLimitSchema::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCSosGroupActionLimitSchema::IsValid() {
    return (m_ptr != nullptr);
}
GCSosGroupActionSchema GCSosGroupActionLimitSchema::GetParent() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CSosGroupActionLimitSchema::GetParent(ptr=%p)", m_ptr));
    GCSosGroupActionSchema value(m_ptr);
    return value;
}
void GCSosGroupActionLimitSchema::SetParent(GCSosGroupActionSchema value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CSosGroupActionLimitSchema::SetParent(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCSosGroupActionLimitSchema(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCSosGroupActionLimitSchema>("CSosGroupActionLimitSchema")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("MaxCount", &GCSosGroupActionLimitSchema::GetMaxCount, &GCSosGroupActionLimitSchema::SetMaxCount)
        .addProperty("StopType", &GCSosGroupActionLimitSchema::GetStopType, &GCSosGroupActionLimitSchema::SetStopType)
        .addProperty("SortType", &GCSosGroupActionLimitSchema::GetSortType, &GCSosGroupActionLimitSchema::SetSortType)
        .addProperty("Parent", &GCSosGroupActionLimitSchema::GetParent, &GCSosGroupActionLimitSchema::SetParent)
        .addFunction("ToPtr", &GCSosGroupActionLimitSchema::ToPtr)
        .addFunction("IsValid", &GCSosGroupActionLimitSchema::IsValid)
        .endClass();
}
GFeWeightedNode_t::GFeWeightedNode_t(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GFeWeightedNode_t::GFeWeightedNode_t(void *ptr) {
    m_ptr = ptr;
}
uint16_t GFeWeightedNode_t::GetNode() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FeWeightedNode_t->Node(ptr=%p)", m_ptr));
    return GetSchemaValue<uint16_t>(m_ptr, "FeWeightedNode_t", "nNode");
}
void GFeWeightedNode_t::SetNode(uint16_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FeWeightedNode_t->Node(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "FeWeightedNode_t", "nNode", true, value);
}
uint16_t GFeWeightedNode_t::GetWeight() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FeWeightedNode_t->Weight(ptr=%p)", m_ptr));
    return GetSchemaValue<uint16_t>(m_ptr, "FeWeightedNode_t", "nWeight");
}
void GFeWeightedNode_t::SetWeight(uint16_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FeWeightedNode_t->Weight(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "FeWeightedNode_t", "nWeight", true, value);
}
void* GFeWeightedNode_t::GetPtr() {
    return m_ptr;
}
std::string GFeWeightedNode_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GFeWeightedNode_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassFeWeightedNode_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GFeWeightedNode_t>("FeWeightedNode_t")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Node", &GFeWeightedNode_t::GetNode, &GFeWeightedNode_t::SetNode)
        .addProperty("Weight", &GFeWeightedNode_t::GetWeight, &GFeWeightedNode_t::SetWeight)
        .addFunction("ToPtr", &GFeWeightedNode_t::ToPtr)
        .addFunction("IsValid", &GFeWeightedNode_t::IsValid)
        .endClass();
}
GCLookComponentUpdater::GCLookComponentUpdater(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCLookComponentUpdater::GCLookComponentUpdater(void *ptr) {
    m_ptr = ptr;
}
GCAnimParamHandle GCLookComponentUpdater::GetLookHeading() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CLookComponentUpdater->LookHeading(ptr=%p)", m_ptr));
    GCAnimParamHandle value(GetSchemaPtr(m_ptr, "CLookComponentUpdater", "m_hLookHeading"));
    return value;
}
void GCLookComponentUpdater::SetLookHeading(GCAnimParamHandle value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CLookComponentUpdater->LookHeading(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'LookHeading' is not possible.\n");
}
GCAnimParamHandle GCLookComponentUpdater::GetLookHeadingVelocity() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CLookComponentUpdater->LookHeadingVelocity(ptr=%p)", m_ptr));
    GCAnimParamHandle value(GetSchemaPtr(m_ptr, "CLookComponentUpdater", "m_hLookHeadingVelocity"));
    return value;
}
void GCLookComponentUpdater::SetLookHeadingVelocity(GCAnimParamHandle value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CLookComponentUpdater->LookHeadingVelocity(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'LookHeadingVelocity' is not possible.\n");
}
GCAnimParamHandle GCLookComponentUpdater::GetLookPitch() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CLookComponentUpdater->LookPitch(ptr=%p)", m_ptr));
    GCAnimParamHandle value(GetSchemaPtr(m_ptr, "CLookComponentUpdater", "m_hLookPitch"));
    return value;
}
void GCLookComponentUpdater::SetLookPitch(GCAnimParamHandle value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CLookComponentUpdater->LookPitch(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'LookPitch' is not possible.\n");
}
GCAnimParamHandle GCLookComponentUpdater::GetLookDistance() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CLookComponentUpdater->LookDistance(ptr=%p)", m_ptr));
    GCAnimParamHandle value(GetSchemaPtr(m_ptr, "CLookComponentUpdater", "m_hLookDistance"));
    return value;
}
void GCLookComponentUpdater::SetLookDistance(GCAnimParamHandle value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CLookComponentUpdater->LookDistance(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'LookDistance' is not possible.\n");
}
GCAnimParamHandle GCLookComponentUpdater::GetLookDirection() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CLookComponentUpdater->LookDirection(ptr=%p)", m_ptr));
    GCAnimParamHandle value(GetSchemaPtr(m_ptr, "CLookComponentUpdater", "m_hLookDirection"));
    return value;
}
void GCLookComponentUpdater::SetLookDirection(GCAnimParamHandle value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CLookComponentUpdater->LookDirection(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'LookDirection' is not possible.\n");
}
GCAnimParamHandle GCLookComponentUpdater::GetLookTarget() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CLookComponentUpdater->LookTarget(ptr=%p)", m_ptr));
    GCAnimParamHandle value(GetSchemaPtr(m_ptr, "CLookComponentUpdater", "m_hLookTarget"));
    return value;
}
void GCLookComponentUpdater::SetLookTarget(GCAnimParamHandle value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CLookComponentUpdater->LookTarget(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'LookTarget' is not possible.\n");
}
GCAnimParamHandle GCLookComponentUpdater::GetLookTargetWorldSpace() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CLookComponentUpdater->LookTargetWorldSpace(ptr=%p)", m_ptr));
    GCAnimParamHandle value(GetSchemaPtr(m_ptr, "CLookComponentUpdater", "m_hLookTargetWorldSpace"));
    return value;
}
void GCLookComponentUpdater::SetLookTargetWorldSpace(GCAnimParamHandle value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CLookComponentUpdater->LookTargetWorldSpace(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'LookTargetWorldSpace' is not possible.\n");
}
bool GCLookComponentUpdater::GetNetworkLookTarget() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CLookComponentUpdater->NetworkLookTarget(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "CLookComponentUpdater", "m_bNetworkLookTarget");
}
void GCLookComponentUpdater::SetNetworkLookTarget(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CLookComponentUpdater->NetworkLookTarget(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CLookComponentUpdater", "m_bNetworkLookTarget", false, value);
}
void* GCLookComponentUpdater::GetPtr() {
    return m_ptr;
}
std::string GCLookComponentUpdater::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCLookComponentUpdater::IsValid() {
    return (m_ptr != nullptr);
}
GCAnimComponentUpdater GCLookComponentUpdater::GetParent() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CLookComponentUpdater::GetParent(ptr=%p)", m_ptr));
    GCAnimComponentUpdater value(m_ptr);
    return value;
}
void GCLookComponentUpdater::SetParent(GCAnimComponentUpdater value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CLookComponentUpdater::SetParent(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCLookComponentUpdater(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCLookComponentUpdater>("CLookComponentUpdater")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("LookHeading", &GCLookComponentUpdater::GetLookHeading, &GCLookComponentUpdater::SetLookHeading)
        .addProperty("LookHeadingVelocity", &GCLookComponentUpdater::GetLookHeadingVelocity, &GCLookComponentUpdater::SetLookHeadingVelocity)
        .addProperty("LookPitch", &GCLookComponentUpdater::GetLookPitch, &GCLookComponentUpdater::SetLookPitch)
        .addProperty("LookDistance", &GCLookComponentUpdater::GetLookDistance, &GCLookComponentUpdater::SetLookDistance)
        .addProperty("LookDirection", &GCLookComponentUpdater::GetLookDirection, &GCLookComponentUpdater::SetLookDirection)
        .addProperty("LookTarget", &GCLookComponentUpdater::GetLookTarget, &GCLookComponentUpdater::SetLookTarget)
        .addProperty("LookTargetWorldSpace", &GCLookComponentUpdater::GetLookTargetWorldSpace, &GCLookComponentUpdater::SetLookTargetWorldSpace)
        .addProperty("NetworkLookTarget", &GCLookComponentUpdater::GetNetworkLookTarget, &GCLookComponentUpdater::SetNetworkLookTarget)
        .addProperty("Parent", &GCLookComponentUpdater::GetParent, &GCLookComponentUpdater::SetParent)
        .addFunction("ToPtr", &GCLookComponentUpdater::ToPtr)
        .addFunction("IsValid", &GCLookComponentUpdater::IsValid)
        .endClass();
}
GCCycleControlUpdateNode::GCCycleControlUpdateNode(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCCycleControlUpdateNode::GCCycleControlUpdateNode(void *ptr) {
    m_ptr = ptr;
}
uint64_t GCCycleControlUpdateNode::GetValueSource() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CCycleControlUpdateNode->ValueSource(ptr=%p)", m_ptr));
    return GetSchemaValue<uint64_t>(m_ptr, "CCycleControlUpdateNode", "m_valueSource");
}
void GCCycleControlUpdateNode::SetValueSource(uint64_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CCycleControlUpdateNode->ValueSource(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CCycleControlUpdateNode", "m_valueSource", false, value);
}
GCAnimParamHandle GCCycleControlUpdateNode::GetParamIndex() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CCycleControlUpdateNode->ParamIndex(ptr=%p)", m_ptr));
    GCAnimParamHandle value(GetSchemaPtr(m_ptr, "CCycleControlUpdateNode", "m_paramIndex"));
    return value;
}
void GCCycleControlUpdateNode::SetParamIndex(GCAnimParamHandle value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CCycleControlUpdateNode->ParamIndex(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'ParamIndex' is not possible.\n");
}
void* GCCycleControlUpdateNode::GetPtr() {
    return m_ptr;
}
std::string GCCycleControlUpdateNode::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCCycleControlUpdateNode::IsValid() {
    return (m_ptr != nullptr);
}
GCUnaryUpdateNode GCCycleControlUpdateNode::GetParent() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CCycleControlUpdateNode::GetParent(ptr=%p)", m_ptr));
    GCUnaryUpdateNode value(m_ptr);
    return value;
}
void GCCycleControlUpdateNode::SetParent(GCUnaryUpdateNode value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CCycleControlUpdateNode::SetParent(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCCycleControlUpdateNode(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCCycleControlUpdateNode>("CCycleControlUpdateNode")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("ValueSource", &GCCycleControlUpdateNode::GetValueSource, &GCCycleControlUpdateNode::SetValueSource)
        .addProperty("ParamIndex", &GCCycleControlUpdateNode::GetParamIndex, &GCCycleControlUpdateNode::SetParamIndex)
        .addProperty("Parent", &GCCycleControlUpdateNode::GetParent, &GCCycleControlUpdateNode::SetParent)
        .addFunction("ToPtr", &GCCycleControlUpdateNode::ToPtr)
        .addFunction("IsValid", &GCCycleControlUpdateNode::IsValid)
        .endClass();
}
GCNetworkVarChainer::GCNetworkVarChainer(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCNetworkVarChainer::GCNetworkVarChainer(void *ptr) {
    m_ptr = ptr;
}
GChangeAccessorFieldPathIndex_t GCNetworkVarChainer::GetPathIndex() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CNetworkVarChainer->PathIndex(ptr=%p)", m_ptr));
    GChangeAccessorFieldPathIndex_t value(GetSchemaPtr(m_ptr, "CNetworkVarChainer", "m_PathIndex"));
    return value;
}
void GCNetworkVarChainer::SetPathIndex(GChangeAccessorFieldPathIndex_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CNetworkVarChainer->PathIndex(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'PathIndex' is not possible.\n");
}
void* GCNetworkVarChainer::GetPtr() {
    return m_ptr;
}
std::string GCNetworkVarChainer::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCNetworkVarChainer::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCNetworkVarChainer(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCNetworkVarChainer>("CNetworkVarChainer")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("PathIndex", &GCNetworkVarChainer::GetPathIndex, &GCNetworkVarChainer::SetPathIndex)
        .addFunction("ToPtr", &GCNetworkVarChainer::ToPtr)
        .addFunction("IsValid", &GCNetworkVarChainer::IsValid)
        .endClass();
}
GRnTriangle_t::GRnTriangle_t(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GRnTriangle_t::GRnTriangle_t(void *ptr) {
    m_ptr = ptr;
}
std::vector<int32_t> GRnTriangle_t::GetIndex() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: RnTriangle_t->Index(ptr=%p,size=3)", m_ptr));
    int32_t* outValue = (int32_t*)GetSchemaPtr(m_ptr, "RnTriangle_t", "m_nIndex"); std::vector<int32_t> ret; for(int i = 0; i < 3; i++) { ret.push_back(outValue[i]); } return ret;
}
void GRnTriangle_t::SetIndex(std::vector<int32_t> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: RnTriangle_t->Index(ptr=%p,size=3)", m_ptr));
    if(value.size() != 3) return PLUGIN_PRINT("Schema SDK", "Field 'Index' needs to have 3 values.\n");
    auto val = GetSchemaValuePtr<int32_t>(m_ptr, "RnTriangle_t", "m_nIndex");
    for(size_t i = 0; i < value.size(); i++) val[i] = value[i];
}
void* GRnTriangle_t::GetPtr() {
    return m_ptr;
}
std::string GRnTriangle_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GRnTriangle_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassRnTriangle_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GRnTriangle_t>("RnTriangle_t")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Index", &GRnTriangle_t::GetIndex, &GRnTriangle_t::SetIndex)
        .addFunction("ToPtr", &GRnTriangle_t::ToPtr)
        .addFunction("IsValid", &GRnTriangle_t::IsValid)
        .endClass();
}
GCNmVectorValueNode::GCNmVectorValueNode(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCNmVectorValueNode::GCNmVectorValueNode(void *ptr) {
    m_ptr = ptr;
}
void* GCNmVectorValueNode::GetPtr() {
    return m_ptr;
}
std::string GCNmVectorValueNode::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCNmVectorValueNode::IsValid() {
    return (m_ptr != nullptr);
}
GCNmValueNode GCNmVectorValueNode::GetParent() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CNmVectorValueNode::GetParent(ptr=%p)", m_ptr));
    GCNmValueNode value(m_ptr);
    return value;
}
void GCNmVectorValueNode::SetParent(GCNmValueNode value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CNmVectorValueNode::SetParent(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCNmVectorValueNode(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCNmVectorValueNode>("CNmVectorValueNode")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Parent", &GCNmVectorValueNode::GetParent, &GCNmVectorValueNode::SetParent)
        .addFunction("ToPtr", &GCNmVectorValueNode::ToPtr)
        .addFunction("IsValid", &GCNmVectorValueNode::IsValid)
        .endClass();
}
GCSeqSeqDescFlag::GCSeqSeqDescFlag(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCSeqSeqDescFlag::GCSeqSeqDescFlag(void *ptr) {
    m_ptr = ptr;
}
bool GCSeqSeqDescFlag::GetLooping() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CSeqSeqDescFlag->Looping(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "CSeqSeqDescFlag", "m_bLooping");
}
void GCSeqSeqDescFlag::SetLooping(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CSeqSeqDescFlag->Looping(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CSeqSeqDescFlag", "m_bLooping", false, value);
}
bool GCSeqSeqDescFlag::GetSnap() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CSeqSeqDescFlag->Snap(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "CSeqSeqDescFlag", "m_bSnap");
}
void GCSeqSeqDescFlag::SetSnap(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CSeqSeqDescFlag->Snap(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CSeqSeqDescFlag", "m_bSnap", false, value);
}
bool GCSeqSeqDescFlag::GetAutoplay() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CSeqSeqDescFlag->Autoplay(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "CSeqSeqDescFlag", "m_bAutoplay");
}
void GCSeqSeqDescFlag::SetAutoplay(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CSeqSeqDescFlag->Autoplay(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CSeqSeqDescFlag", "m_bAutoplay", false, value);
}
bool GCSeqSeqDescFlag::GetPost() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CSeqSeqDescFlag->Post(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "CSeqSeqDescFlag", "m_bPost");
}
void GCSeqSeqDescFlag::SetPost(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CSeqSeqDescFlag->Post(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CSeqSeqDescFlag", "m_bPost", false, value);
}
bool GCSeqSeqDescFlag::GetHidden() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CSeqSeqDescFlag->Hidden(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "CSeqSeqDescFlag", "m_bHidden");
}
void GCSeqSeqDescFlag::SetHidden(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CSeqSeqDescFlag->Hidden(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CSeqSeqDescFlag", "m_bHidden", false, value);
}
bool GCSeqSeqDescFlag::GetMulti() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CSeqSeqDescFlag->Multi(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "CSeqSeqDescFlag", "m_bMulti");
}
void GCSeqSeqDescFlag::SetMulti(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CSeqSeqDescFlag->Multi(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CSeqSeqDescFlag", "m_bMulti", false, value);
}
bool GCSeqSeqDescFlag::GetLegacyDelta() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CSeqSeqDescFlag->LegacyDelta(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "CSeqSeqDescFlag", "m_bLegacyDelta");
}
void GCSeqSeqDescFlag::SetLegacyDelta(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CSeqSeqDescFlag->LegacyDelta(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CSeqSeqDescFlag", "m_bLegacyDelta", false, value);
}
bool GCSeqSeqDescFlag::GetLegacyWorldspace() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CSeqSeqDescFlag->LegacyWorldspace(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "CSeqSeqDescFlag", "m_bLegacyWorldspace");
}
void GCSeqSeqDescFlag::SetLegacyWorldspace(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CSeqSeqDescFlag->LegacyWorldspace(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CSeqSeqDescFlag", "m_bLegacyWorldspace", false, value);
}
bool GCSeqSeqDescFlag::GetLegacyCyclepose() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CSeqSeqDescFlag->LegacyCyclepose(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "CSeqSeqDescFlag", "m_bLegacyCyclepose");
}
void GCSeqSeqDescFlag::SetLegacyCyclepose(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CSeqSeqDescFlag->LegacyCyclepose(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CSeqSeqDescFlag", "m_bLegacyCyclepose", false, value);
}
bool GCSeqSeqDescFlag::GetLegacyRealtime() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CSeqSeqDescFlag->LegacyRealtime(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "CSeqSeqDescFlag", "m_bLegacyRealtime");
}
void GCSeqSeqDescFlag::SetLegacyRealtime(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CSeqSeqDescFlag->LegacyRealtime(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CSeqSeqDescFlag", "m_bLegacyRealtime", false, value);
}
bool GCSeqSeqDescFlag::GetModelDoc() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CSeqSeqDescFlag->ModelDoc(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "CSeqSeqDescFlag", "m_bModelDoc");
}
void GCSeqSeqDescFlag::SetModelDoc(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CSeqSeqDescFlag->ModelDoc(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CSeqSeqDescFlag", "m_bModelDoc", false, value);
}
void* GCSeqSeqDescFlag::GetPtr() {
    return m_ptr;
}
std::string GCSeqSeqDescFlag::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCSeqSeqDescFlag::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCSeqSeqDescFlag(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCSeqSeqDescFlag>("CSeqSeqDescFlag")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Looping", &GCSeqSeqDescFlag::GetLooping, &GCSeqSeqDescFlag::SetLooping)
        .addProperty("Snap", &GCSeqSeqDescFlag::GetSnap, &GCSeqSeqDescFlag::SetSnap)
        .addProperty("Autoplay", &GCSeqSeqDescFlag::GetAutoplay, &GCSeqSeqDescFlag::SetAutoplay)
        .addProperty("Post", &GCSeqSeqDescFlag::GetPost, &GCSeqSeqDescFlag::SetPost)
        .addProperty("Hidden", &GCSeqSeqDescFlag::GetHidden, &GCSeqSeqDescFlag::SetHidden)
        .addProperty("Multi", &GCSeqSeqDescFlag::GetMulti, &GCSeqSeqDescFlag::SetMulti)
        .addProperty("LegacyDelta", &GCSeqSeqDescFlag::GetLegacyDelta, &GCSeqSeqDescFlag::SetLegacyDelta)
        .addProperty("LegacyWorldspace", &GCSeqSeqDescFlag::GetLegacyWorldspace, &GCSeqSeqDescFlag::SetLegacyWorldspace)
        .addProperty("LegacyCyclepose", &GCSeqSeqDescFlag::GetLegacyCyclepose, &GCSeqSeqDescFlag::SetLegacyCyclepose)
        .addProperty("LegacyRealtime", &GCSeqSeqDescFlag::GetLegacyRealtime, &GCSeqSeqDescFlag::SetLegacyRealtime)
        .addProperty("ModelDoc", &GCSeqSeqDescFlag::GetModelDoc, &GCSeqSeqDescFlag::SetModelDoc)
        .addFunction("ToPtr", &GCSeqSeqDescFlag::ToPtr)
        .addFunction("IsValid", &GCSeqSeqDescFlag::IsValid)
        .endClass();
}
GAimCameraOpFixedSettings_t::GAimCameraOpFixedSettings_t(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GAimCameraOpFixedSettings_t::GAimCameraOpFixedSettings_t(void *ptr) {
    m_ptr = ptr;
}
int32_t GAimCameraOpFixedSettings_t::GetChainIndex() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: AimCameraOpFixedSettings_t->ChainIndex(ptr=%p)", m_ptr));
    return GetSchemaValue<int32_t>(m_ptr, "AimCameraOpFixedSettings_t", "m_nChainIndex");
}
void GAimCameraOpFixedSettings_t::SetChainIndex(int32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: AimCameraOpFixedSettings_t->ChainIndex(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "AimCameraOpFixedSettings_t", "m_nChainIndex", true, value);
}
int32_t GAimCameraOpFixedSettings_t::GetCameraJointIndex() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: AimCameraOpFixedSettings_t->CameraJointIndex(ptr=%p)", m_ptr));
    return GetSchemaValue<int32_t>(m_ptr, "AimCameraOpFixedSettings_t", "m_nCameraJointIndex");
}
void GAimCameraOpFixedSettings_t::SetCameraJointIndex(int32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: AimCameraOpFixedSettings_t->CameraJointIndex(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "AimCameraOpFixedSettings_t", "m_nCameraJointIndex", true, value);
}
int32_t GAimCameraOpFixedSettings_t::GetPelvisJointIndex() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: AimCameraOpFixedSettings_t->PelvisJointIndex(ptr=%p)", m_ptr));
    return GetSchemaValue<int32_t>(m_ptr, "AimCameraOpFixedSettings_t", "m_nPelvisJointIndex");
}
void GAimCameraOpFixedSettings_t::SetPelvisJointIndex(int32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: AimCameraOpFixedSettings_t->PelvisJointIndex(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "AimCameraOpFixedSettings_t", "m_nPelvisJointIndex", true, value);
}
int32_t GAimCameraOpFixedSettings_t::GetClavicleLeftJointIndex() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: AimCameraOpFixedSettings_t->ClavicleLeftJointIndex(ptr=%p)", m_ptr));
    return GetSchemaValue<int32_t>(m_ptr, "AimCameraOpFixedSettings_t", "m_nClavicleLeftJointIndex");
}
void GAimCameraOpFixedSettings_t::SetClavicleLeftJointIndex(int32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: AimCameraOpFixedSettings_t->ClavicleLeftJointIndex(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "AimCameraOpFixedSettings_t", "m_nClavicleLeftJointIndex", true, value);
}
int32_t GAimCameraOpFixedSettings_t::GetClavicleRightJointIndex() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: AimCameraOpFixedSettings_t->ClavicleRightJointIndex(ptr=%p)", m_ptr));
    return GetSchemaValue<int32_t>(m_ptr, "AimCameraOpFixedSettings_t", "m_nClavicleRightJointIndex");
}
void GAimCameraOpFixedSettings_t::SetClavicleRightJointIndex(int32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: AimCameraOpFixedSettings_t->ClavicleRightJointIndex(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "AimCameraOpFixedSettings_t", "m_nClavicleRightJointIndex", true, value);
}
int32_t GAimCameraOpFixedSettings_t::GetDepenetrationJointIndex() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: AimCameraOpFixedSettings_t->DepenetrationJointIndex(ptr=%p)", m_ptr));
    return GetSchemaValue<int32_t>(m_ptr, "AimCameraOpFixedSettings_t", "m_nDepenetrationJointIndex");
}
void GAimCameraOpFixedSettings_t::SetDepenetrationJointIndex(int32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: AimCameraOpFixedSettings_t->DepenetrationJointIndex(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "AimCameraOpFixedSettings_t", "m_nDepenetrationJointIndex", true, value);
}
std::vector<int32> GAimCameraOpFixedSettings_t::GetPropJoints() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: AimCameraOpFixedSettings_t->PropJoints(ptr=%p)", m_ptr));
    CUtlVector<int32>* vec = GetSchemaValue<CUtlVector<int32>*>(m_ptr, "AimCameraOpFixedSettings_t", "m_propJoints"); std::vector<int32> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GAimCameraOpFixedSettings_t::SetPropJoints(std::vector<int32> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: AimCameraOpFixedSettings_t->PropJoints(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<int32>(m_ptr, "AimCameraOpFixedSettings_t", "m_propJoints", true, value);
}
void* GAimCameraOpFixedSettings_t::GetPtr() {
    return m_ptr;
}
std::string GAimCameraOpFixedSettings_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GAimCameraOpFixedSettings_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassAimCameraOpFixedSettings_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GAimCameraOpFixedSettings_t>("AimCameraOpFixedSettings_t")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("ChainIndex", &GAimCameraOpFixedSettings_t::GetChainIndex, &GAimCameraOpFixedSettings_t::SetChainIndex)
        .addProperty("CameraJointIndex", &GAimCameraOpFixedSettings_t::GetCameraJointIndex, &GAimCameraOpFixedSettings_t::SetCameraJointIndex)
        .addProperty("PelvisJointIndex", &GAimCameraOpFixedSettings_t::GetPelvisJointIndex, &GAimCameraOpFixedSettings_t::SetPelvisJointIndex)
        .addProperty("ClavicleLeftJointIndex", &GAimCameraOpFixedSettings_t::GetClavicleLeftJointIndex, &GAimCameraOpFixedSettings_t::SetClavicleLeftJointIndex)
        .addProperty("ClavicleRightJointIndex", &GAimCameraOpFixedSettings_t::GetClavicleRightJointIndex, &GAimCameraOpFixedSettings_t::SetClavicleRightJointIndex)
        .addProperty("DepenetrationJointIndex", &GAimCameraOpFixedSettings_t::GetDepenetrationJointIndex, &GAimCameraOpFixedSettings_t::SetDepenetrationJointIndex)
        .addProperty("PropJoints", &GAimCameraOpFixedSettings_t::GetPropJoints, &GAimCameraOpFixedSettings_t::SetPropJoints)
        .addFunction("ToPtr", &GAimCameraOpFixedSettings_t::ToPtr)
        .addFunction("IsValid", &GAimCameraOpFixedSettings_t::IsValid)
        .endClass();
}
GCParticleRemapFloatInput::GCParticleRemapFloatInput(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCParticleRemapFloatInput::GCParticleRemapFloatInput(void *ptr) {
    m_ptr = ptr;
}
void* GCParticleRemapFloatInput::GetPtr() {
    return m_ptr;
}
std::string GCParticleRemapFloatInput::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCParticleRemapFloatInput::IsValid() {
    return (m_ptr != nullptr);
}
GCParticleFloatInput GCParticleRemapFloatInput::GetParent() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CParticleRemapFloatInput::GetParent(ptr=%p)", m_ptr));
    GCParticleFloatInput value(m_ptr);
    return value;
}
void GCParticleRemapFloatInput::SetParent(GCParticleFloatInput value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CParticleRemapFloatInput::SetParent(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCParticleRemapFloatInput(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCParticleRemapFloatInput>("CParticleRemapFloatInput")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Parent", &GCParticleRemapFloatInput::GetParent, &GCParticleRemapFloatInput::SetParent)
        .addFunction("ToPtr", &GCParticleRemapFloatInput::ToPtr)
        .addFunction("IsValid", &GCParticleRemapFloatInput::IsValid)
        .endClass();
}
GBaseSceneObjectOverride_t::GBaseSceneObjectOverride_t(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GBaseSceneObjectOverride_t::GBaseSceneObjectOverride_t(void *ptr) {
    m_ptr = ptr;
}
uint32_t GBaseSceneObjectOverride_t::GetSceneObjectIndex() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: BaseSceneObjectOverride_t->SceneObjectIndex(ptr=%p)", m_ptr));
    return GetSchemaValue<uint32_t>(m_ptr, "BaseSceneObjectOverride_t", "m_nSceneObjectIndex");
}
void GBaseSceneObjectOverride_t::SetSceneObjectIndex(uint32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: BaseSceneObjectOverride_t->SceneObjectIndex(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "BaseSceneObjectOverride_t", "m_nSceneObjectIndex", true, value);
}
void* GBaseSceneObjectOverride_t::GetPtr() {
    return m_ptr;
}
std::string GBaseSceneObjectOverride_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GBaseSceneObjectOverride_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassBaseSceneObjectOverride_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GBaseSceneObjectOverride_t>("BaseSceneObjectOverride_t")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("SceneObjectIndex", &GBaseSceneObjectOverride_t::GetSceneObjectIndex, &GBaseSceneObjectOverride_t::SetSceneObjectIndex)
        .addFunction("ToPtr", &GBaseSceneObjectOverride_t::ToPtr)
        .addFunction("IsValid", &GBaseSceneObjectOverride_t::IsValid)
        .endClass();
}
GCConcreteAnimParameter::GCConcreteAnimParameter(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCConcreteAnimParameter::GCConcreteAnimParameter(void *ptr) {
    m_ptr = ptr;
}
uint64_t GCConcreteAnimParameter::GetPreviewButton() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CConcreteAnimParameter->PreviewButton(ptr=%p)", m_ptr));
    return GetSchemaValue<uint64_t>(m_ptr, "CConcreteAnimParameter", "m_previewButton");
}
void GCConcreteAnimParameter::SetPreviewButton(uint64_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CConcreteAnimParameter->PreviewButton(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CConcreteAnimParameter", "m_previewButton", false, value);
}
uint64_t GCConcreteAnimParameter::GetNetworkSetting() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CConcreteAnimParameter->NetworkSetting(ptr=%p)", m_ptr));
    return GetSchemaValue<uint64_t>(m_ptr, "CConcreteAnimParameter", "m_eNetworkSetting");
}
void GCConcreteAnimParameter::SetNetworkSetting(uint64_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CConcreteAnimParameter->NetworkSetting(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CConcreteAnimParameter", "m_eNetworkSetting", false, value);
}
bool GCConcreteAnimParameter::GetUseMostRecentValue() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CConcreteAnimParameter->UseMostRecentValue(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "CConcreteAnimParameter", "m_bUseMostRecentValue");
}
void GCConcreteAnimParameter::SetUseMostRecentValue(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CConcreteAnimParameter->UseMostRecentValue(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CConcreteAnimParameter", "m_bUseMostRecentValue", false, value);
}
bool GCConcreteAnimParameter::GetAutoReset() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CConcreteAnimParameter->AutoReset(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "CConcreteAnimParameter", "m_bAutoReset");
}
void GCConcreteAnimParameter::SetAutoReset(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CConcreteAnimParameter->AutoReset(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CConcreteAnimParameter", "m_bAutoReset", false, value);
}
bool GCConcreteAnimParameter::GetGameWritable() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CConcreteAnimParameter->GameWritable(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "CConcreteAnimParameter", "m_bGameWritable");
}
void GCConcreteAnimParameter::SetGameWritable(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CConcreteAnimParameter->GameWritable(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CConcreteAnimParameter", "m_bGameWritable", false, value);
}
bool GCConcreteAnimParameter::GetGraphWritable() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CConcreteAnimParameter->GraphWritable(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "CConcreteAnimParameter", "m_bGraphWritable");
}
void GCConcreteAnimParameter::SetGraphWritable(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CConcreteAnimParameter->GraphWritable(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CConcreteAnimParameter", "m_bGraphWritable", false, value);
}
void* GCConcreteAnimParameter::GetPtr() {
    return m_ptr;
}
std::string GCConcreteAnimParameter::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCConcreteAnimParameter::IsValid() {
    return (m_ptr != nullptr);
}
GCAnimParameterBase GCConcreteAnimParameter::GetParent() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CConcreteAnimParameter::GetParent(ptr=%p)", m_ptr));
    GCAnimParameterBase value(m_ptr);
    return value;
}
void GCConcreteAnimParameter::SetParent(GCAnimParameterBase value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CConcreteAnimParameter::SetParent(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCConcreteAnimParameter(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCConcreteAnimParameter>("CConcreteAnimParameter")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("PreviewButton", &GCConcreteAnimParameter::GetPreviewButton, &GCConcreteAnimParameter::SetPreviewButton)
        .addProperty("NetworkSetting", &GCConcreteAnimParameter::GetNetworkSetting, &GCConcreteAnimParameter::SetNetworkSetting)
        .addProperty("UseMostRecentValue", &GCConcreteAnimParameter::GetUseMostRecentValue, &GCConcreteAnimParameter::SetUseMostRecentValue)
        .addProperty("AutoReset", &GCConcreteAnimParameter::GetAutoReset, &GCConcreteAnimParameter::SetAutoReset)
        .addProperty("GameWritable", &GCConcreteAnimParameter::GetGameWritable, &GCConcreteAnimParameter::SetGameWritable)
        .addProperty("GraphWritable", &GCConcreteAnimParameter::GetGraphWritable, &GCConcreteAnimParameter::SetGraphWritable)
        .addProperty("Parent", &GCConcreteAnimParameter::GetParent, &GCConcreteAnimParameter::SetParent)
        .addFunction("ToPtr", &GCConcreteAnimParameter::ToPtr)
        .addFunction("IsValid", &GCConcreteAnimParameter::IsValid)
        .endClass();
}
GFeAnimStrayRadius_t::GFeAnimStrayRadius_t(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GFeAnimStrayRadius_t::GFeAnimStrayRadius_t(void *ptr) {
    m_ptr = ptr;
}
std::vector<uint16_t> GFeAnimStrayRadius_t::GetNode() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FeAnimStrayRadius_t->Node(ptr=%p,size=2)", m_ptr));
    uint16_t* outValue = (uint16_t*)GetSchemaPtr(m_ptr, "FeAnimStrayRadius_t", "nNode"); std::vector<uint16_t> ret; for(int i = 0; i < 2; i++) { ret.push_back(outValue[i]); } return ret;
}
void GFeAnimStrayRadius_t::SetNode(std::vector<uint16_t> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FeAnimStrayRadius_t->Node(ptr=%p,size=2)", m_ptr));
    if(value.size() != 2) return PLUGIN_PRINT("Schema SDK", "Field 'Node' needs to have 2 values.\n");
    auto val = GetSchemaValuePtr<uint16_t>(m_ptr, "FeAnimStrayRadius_t", "nNode");
    for(size_t i = 0; i < value.size(); i++) val[i] = value[i];
}
float GFeAnimStrayRadius_t::GetMaxDist() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FeAnimStrayRadius_t->MaxDist(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "FeAnimStrayRadius_t", "flMaxDist");
}
void GFeAnimStrayRadius_t::SetMaxDist(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FeAnimStrayRadius_t->MaxDist(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "FeAnimStrayRadius_t", "flMaxDist", true, value);
}
float GFeAnimStrayRadius_t::GetRelaxationFactor() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FeAnimStrayRadius_t->RelaxationFactor(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "FeAnimStrayRadius_t", "flRelaxationFactor");
}
void GFeAnimStrayRadius_t::SetRelaxationFactor(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FeAnimStrayRadius_t->RelaxationFactor(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "FeAnimStrayRadius_t", "flRelaxationFactor", true, value);
}
void* GFeAnimStrayRadius_t::GetPtr() {
    return m_ptr;
}
std::string GFeAnimStrayRadius_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GFeAnimStrayRadius_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassFeAnimStrayRadius_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GFeAnimStrayRadius_t>("FeAnimStrayRadius_t")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Node", &GFeAnimStrayRadius_t::GetNode, &GFeAnimStrayRadius_t::SetNode)
        .addProperty("MaxDist", &GFeAnimStrayRadius_t::GetMaxDist, &GFeAnimStrayRadius_t::SetMaxDist)
        .addProperty("RelaxationFactor", &GFeAnimStrayRadius_t::GetRelaxationFactor, &GFeAnimStrayRadius_t::SetRelaxationFactor)
        .addFunction("ToPtr", &GFeAnimStrayRadius_t::ToPtr)
        .addFunction("IsValid", &GFeAnimStrayRadius_t::IsValid)
        .endClass();
}
GModelReference_t::GModelReference_t(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GModelReference_t::GModelReference_t(void *ptr) {
    m_ptr = ptr;
}
float GModelReference_t::GetRelativeProbabilityOfSpawn() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: ModelReference_t->RelativeProbabilityOfSpawn(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "ModelReference_t", "m_flRelativeProbabilityOfSpawn");
}
void GModelReference_t::SetRelativeProbabilityOfSpawn(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: ModelReference_t->RelativeProbabilityOfSpawn(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "ModelReference_t", "m_flRelativeProbabilityOfSpawn", true, value);
}
void* GModelReference_t::GetPtr() {
    return m_ptr;
}
std::string GModelReference_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GModelReference_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassModelReference_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GModelReference_t>("ModelReference_t")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("RelativeProbabilityOfSpawn", &GModelReference_t::GetRelativeProbabilityOfSpawn, &GModelReference_t::SetRelativeProbabilityOfSpawn)
        .addFunction("ToPtr", &GModelReference_t::ToPtr)
        .addFunction("IsValid", &GModelReference_t::IsValid)
        .endClass();
}
GRnCapsuleDesc_t::GRnCapsuleDesc_t(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GRnCapsuleDesc_t::GRnCapsuleDesc_t(void *ptr) {
    m_ptr = ptr;
}
GRnCapsule_t GRnCapsuleDesc_t::GetCapsule() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: RnCapsuleDesc_t->Capsule(ptr=%p)", m_ptr));
    GRnCapsule_t value(GetSchemaPtr(m_ptr, "RnCapsuleDesc_t", "m_Capsule"));
    return value;
}
void GRnCapsuleDesc_t::SetCapsule(GRnCapsule_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: RnCapsuleDesc_t->Capsule(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Capsule' is not possible.\n");
}
void* GRnCapsuleDesc_t::GetPtr() {
    return m_ptr;
}
std::string GRnCapsuleDesc_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GRnCapsuleDesc_t::IsValid() {
    return (m_ptr != nullptr);
}
GRnShapeDesc_t GRnCapsuleDesc_t::GetParent() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("RnCapsuleDesc_t::GetParent(ptr=%p)", m_ptr));
    GRnShapeDesc_t value(m_ptr);
    return value;
}
void GRnCapsuleDesc_t::SetParent(GRnShapeDesc_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("RnCapsuleDesc_t::SetParent(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassRnCapsuleDesc_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GRnCapsuleDesc_t>("RnCapsuleDesc_t")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Capsule", &GRnCapsuleDesc_t::GetCapsule, &GRnCapsuleDesc_t::SetCapsule)
        .addProperty("Parent", &GRnCapsuleDesc_t::GetParent, &GRnCapsuleDesc_t::SetParent)
        .addFunction("ToPtr", &GRnCapsuleDesc_t::ToPtr)
        .addFunction("IsValid", &GRnCapsuleDesc_t::IsValid)
        .endClass();
}
GCAnimGraphDebugReplay::GCAnimGraphDebugReplay(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCAnimGraphDebugReplay::GCAnimGraphDebugReplay(void *ptr) {
    m_ptr = ptr;
}
std::string GCAnimGraphDebugReplay::GetAnimGraphFileName() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CAnimGraphDebugReplay->AnimGraphFileName(ptr=%p)", m_ptr));
    return GetSchemaValue<CUtlString>(m_ptr, "CAnimGraphDebugReplay", "m_animGraphFileName").Get();
}
void GCAnimGraphDebugReplay::SetAnimGraphFileName(std::string value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CAnimGraphDebugReplay->AnimGraphFileName(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CAnimGraphDebugReplay", "m_animGraphFileName", false, CUtlString(value.c_str()));
}
int32_t GCAnimGraphDebugReplay::GetStartIndex() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CAnimGraphDebugReplay->StartIndex(ptr=%p)", m_ptr));
    return GetSchemaValue<int32_t>(m_ptr, "CAnimGraphDebugReplay", "m_startIndex");
}
void GCAnimGraphDebugReplay::SetStartIndex(int32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CAnimGraphDebugReplay->StartIndex(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CAnimGraphDebugReplay", "m_startIndex", false, value);
}
int32_t GCAnimGraphDebugReplay::GetWriteIndex() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CAnimGraphDebugReplay->WriteIndex(ptr=%p)", m_ptr));
    return GetSchemaValue<int32_t>(m_ptr, "CAnimGraphDebugReplay", "m_writeIndex");
}
void GCAnimGraphDebugReplay::SetWriteIndex(int32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CAnimGraphDebugReplay->WriteIndex(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CAnimGraphDebugReplay", "m_writeIndex", false, value);
}
int32_t GCAnimGraphDebugReplay::GetFrameCount() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CAnimGraphDebugReplay->FrameCount(ptr=%p)", m_ptr));
    return GetSchemaValue<int32_t>(m_ptr, "CAnimGraphDebugReplay", "m_frameCount");
}
void GCAnimGraphDebugReplay::SetFrameCount(int32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CAnimGraphDebugReplay->FrameCount(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CAnimGraphDebugReplay", "m_frameCount", false, value);
}
void* GCAnimGraphDebugReplay::GetPtr() {
    return m_ptr;
}
std::string GCAnimGraphDebugReplay::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCAnimGraphDebugReplay::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCAnimGraphDebugReplay(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCAnimGraphDebugReplay>("CAnimGraphDebugReplay")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("AnimGraphFileName", &GCAnimGraphDebugReplay::GetAnimGraphFileName, &GCAnimGraphDebugReplay::SetAnimGraphFileName)
        .addProperty("StartIndex", &GCAnimGraphDebugReplay::GetStartIndex, &GCAnimGraphDebugReplay::SetStartIndex)
        .addProperty("WriteIndex", &GCAnimGraphDebugReplay::GetWriteIndex, &GCAnimGraphDebugReplay::SetWriteIndex)
        .addProperty("FrameCount", &GCAnimGraphDebugReplay::GetFrameCount, &GCAnimGraphDebugReplay::SetFrameCount)
        .addFunction("ToPtr", &GCAnimGraphDebugReplay::ToPtr)
        .addFunction("IsValid", &GCAnimGraphDebugReplay::IsValid)
        .endClass();
}
GCVoiceContainerSwitch::GCVoiceContainerSwitch(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCVoiceContainerSwitch::GCVoiceContainerSwitch(void *ptr) {
    m_ptr = ptr;
}
std::vector<GCVoiceContainerBase*> GCVoiceContainerSwitch::GetSoundsToPlay() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CVoiceContainerSwitch->SoundsToPlay(ptr=%p)", m_ptr));
    CUtlVector<GCVoiceContainerBase*>* vec = GetSchemaValue<CUtlVector<GCVoiceContainerBase*>*>(m_ptr, "CVoiceContainerSwitch", "m_soundsToPlay"); std::vector<GCVoiceContainerBase*> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCVoiceContainerSwitch::SetSoundsToPlay(std::vector<GCVoiceContainerBase*> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CVoiceContainerSwitch->SoundsToPlay(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<GCVoiceContainerBase*>(m_ptr, "CVoiceContainerSwitch", "m_soundsToPlay", false, value);
}
void* GCVoiceContainerSwitch::GetPtr() {
    return m_ptr;
}
std::string GCVoiceContainerSwitch::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCVoiceContainerSwitch::IsValid() {
    return (m_ptr != nullptr);
}
GCVoiceContainerBase GCVoiceContainerSwitch::GetParent() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CVoiceContainerSwitch::GetParent(ptr=%p)", m_ptr));
    GCVoiceContainerBase value(m_ptr);
    return value;
}
void GCVoiceContainerSwitch::SetParent(GCVoiceContainerBase value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CVoiceContainerSwitch::SetParent(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCVoiceContainerSwitch(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCVoiceContainerSwitch>("CVoiceContainerSwitch")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("SoundsToPlay", &GCVoiceContainerSwitch::GetSoundsToPlay, &GCVoiceContainerSwitch::SetSoundsToPlay)
        .addProperty("Parent", &GCVoiceContainerSwitch::GetParent, &GCVoiceContainerSwitch::SetParent)
        .addFunction("ToPtr", &GCVoiceContainerSwitch::ToPtr)
        .addFunction("IsValid", &GCVoiceContainerSwitch::IsValid)
        .endClass();
}
GLookAtBone_t::GLookAtBone_t(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GLookAtBone_t::GLookAtBone_t(void *ptr) {
    m_ptr = ptr;
}
int32_t GLookAtBone_t::GetIndex() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: LookAtBone_t->Index(ptr=%p)", m_ptr));
    return GetSchemaValue<int32_t>(m_ptr, "LookAtBone_t", "m_index");
}
void GLookAtBone_t::SetIndex(int32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: LookAtBone_t->Index(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "LookAtBone_t", "m_index", true, value);
}
float GLookAtBone_t::GetWeight() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: LookAtBone_t->Weight(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "LookAtBone_t", "m_weight");
}
void GLookAtBone_t::SetWeight(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: LookAtBone_t->Weight(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "LookAtBone_t", "m_weight", true, value);
}
void* GLookAtBone_t::GetPtr() {
    return m_ptr;
}
std::string GLookAtBone_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GLookAtBone_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassLookAtBone_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GLookAtBone_t>("LookAtBone_t")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Index", &GLookAtBone_t::GetIndex, &GLookAtBone_t::SetIndex)
        .addProperty("Weight", &GLookAtBone_t::GetWeight, &GLookAtBone_t::SetWeight)
        .addFunction("ToPtr", &GLookAtBone_t::ToPtr)
        .addFunction("IsValid", &GLookAtBone_t::IsValid)
        .endClass();
}
GCNmBoneMaskValueNode::GCNmBoneMaskValueNode(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCNmBoneMaskValueNode::GCNmBoneMaskValueNode(void *ptr) {
    m_ptr = ptr;
}
void* GCNmBoneMaskValueNode::GetPtr() {
    return m_ptr;
}
std::string GCNmBoneMaskValueNode::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCNmBoneMaskValueNode::IsValid() {
    return (m_ptr != nullptr);
}
GCNmValueNode GCNmBoneMaskValueNode::GetParent() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CNmBoneMaskValueNode::GetParent(ptr=%p)", m_ptr));
    GCNmValueNode value(m_ptr);
    return value;
}
void GCNmBoneMaskValueNode::SetParent(GCNmValueNode value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CNmBoneMaskValueNode::SetParent(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCNmBoneMaskValueNode(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCNmBoneMaskValueNode>("CNmBoneMaskValueNode")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Parent", &GCNmBoneMaskValueNode::GetParent, &GCNmBoneMaskValueNode::SetParent)
        .addFunction("ToPtr", &GCNmBoneMaskValueNode::ToPtr)
        .addFunction("IsValid", &GCNmBoneMaskValueNode::IsValid)
        .endClass();
}
GCNmTransitionEvent::GCNmTransitionEvent(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCNmTransitionEvent::GCNmTransitionEvent(void *ptr) {
    m_ptr = ptr;
}
uint64_t GCNmTransitionEvent::GetRule() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CNmTransitionEvent->Rule(ptr=%p)", m_ptr));
    return GetSchemaValue<uint64_t>(m_ptr, "CNmTransitionEvent", "m_rule");
}
void GCNmTransitionEvent::SetRule(uint64_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CNmTransitionEvent->Rule(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CNmTransitionEvent", "m_rule", false, value);
}
void* GCNmTransitionEvent::GetPtr() {
    return m_ptr;
}
std::string GCNmTransitionEvent::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCNmTransitionEvent::IsValid() {
    return (m_ptr != nullptr);
}
GCNmEvent GCNmTransitionEvent::GetParent() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CNmTransitionEvent::GetParent(ptr=%p)", m_ptr));
    GCNmEvent value(m_ptr);
    return value;
}
void GCNmTransitionEvent::SetParent(GCNmEvent value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CNmTransitionEvent::SetParent(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCNmTransitionEvent(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCNmTransitionEvent>("CNmTransitionEvent")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Rule", &GCNmTransitionEvent::GetRule, &GCNmTransitionEvent::SetRule)
        .addProperty("Parent", &GCNmTransitionEvent::GetParent, &GCNmTransitionEvent::SetParent)
        .addFunction("ToPtr", &GCNmTransitionEvent::ToPtr)
        .addFunction("IsValid", &GCNmTransitionEvent::IsValid)
        .endClass();
}
GCStringAnimTag::GCStringAnimTag(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCStringAnimTag::GCStringAnimTag(void *ptr) {
    m_ptr = ptr;
}
void* GCStringAnimTag::GetPtr() {
    return m_ptr;
}
std::string GCStringAnimTag::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCStringAnimTag::IsValid() {
    return (m_ptr != nullptr);
}
GCAnimTagBase GCStringAnimTag::GetParent() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CStringAnimTag::GetParent(ptr=%p)", m_ptr));
    GCAnimTagBase value(m_ptr);
    return value;
}
void GCStringAnimTag::SetParent(GCAnimTagBase value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CStringAnimTag::SetParent(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCStringAnimTag(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCStringAnimTag>("CStringAnimTag")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Parent", &GCStringAnimTag::GetParent, &GCStringAnimTag::SetParent)
        .addFunction("ToPtr", &GCStringAnimTag::ToPtr)
        .addFunction("IsValid", &GCStringAnimTag::IsValid)
        .endClass();
}
GSkeletonAnimCapture_t__Bone_t::GSkeletonAnimCapture_t__Bone_t(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GSkeletonAnimCapture_t__Bone_t::GSkeletonAnimCapture_t__Bone_t(void *ptr) {
    m_ptr = ptr;
}
std::string GSkeletonAnimCapture_t__Bone_t::GetName() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: SkeletonAnimCapture_t__Bone_t->Name(ptr=%p)", m_ptr));
    return GetSchemaValue<CUtlString>(m_ptr, "SkeletonAnimCapture_t__Bone_t", "m_Name").Get();
}
void GSkeletonAnimCapture_t__Bone_t::SetName(std::string value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: SkeletonAnimCapture_t__Bone_t->Name(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "SkeletonAnimCapture_t__Bone_t", "m_Name", true, CUtlString(value.c_str()));
}
int32_t GSkeletonAnimCapture_t__Bone_t::GetParent() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: SkeletonAnimCapture_t__Bone_t->Parent(ptr=%p)", m_ptr));
    return GetSchemaValue<int32_t>(m_ptr, "SkeletonAnimCapture_t__Bone_t", "m_nParent");
}
void GSkeletonAnimCapture_t__Bone_t::SetParent(int32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: SkeletonAnimCapture_t__Bone_t->Parent(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "SkeletonAnimCapture_t__Bone_t", "m_nParent", true, value);
}
void* GSkeletonAnimCapture_t__Bone_t::GetPtr() {
    return m_ptr;
}
std::string GSkeletonAnimCapture_t__Bone_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GSkeletonAnimCapture_t__Bone_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassSkeletonAnimCapture_t__Bone_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GSkeletonAnimCapture_t__Bone_t>("SkeletonAnimCapture_t__Bone_t")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Name", &GSkeletonAnimCapture_t__Bone_t::GetName, &GSkeletonAnimCapture_t__Bone_t::SetName)
        .addProperty("Parent", &GSkeletonAnimCapture_t__Bone_t::GetParent, &GSkeletonAnimCapture_t__Bone_t::SetParent)
        .addFunction("ToPtr", &GSkeletonAnimCapture_t__Bone_t::ToPtr)
        .addFunction("IsValid", &GSkeletonAnimCapture_t__Bone_t::IsValid)
        .endClass();
}
GCStaticPoseCache::GCStaticPoseCache(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCStaticPoseCache::GCStaticPoseCache(void *ptr) {
    m_ptr = ptr;
}
std::vector<GCCachedPose> GCStaticPoseCache::GetPoses() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CStaticPoseCache->Poses(ptr=%p)", m_ptr));
    CUtlVector<GCCachedPose>* vec = GetSchemaValue<CUtlVector<GCCachedPose>*>(m_ptr, "CStaticPoseCache", "m_poses"); std::vector<GCCachedPose> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCStaticPoseCache::SetPoses(std::vector<GCCachedPose> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CStaticPoseCache->Poses(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<GCCachedPose>(m_ptr, "CStaticPoseCache", "m_poses", false, value);
}
int32_t GCStaticPoseCache::GetBoneCount() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CStaticPoseCache->BoneCount(ptr=%p)", m_ptr));
    return GetSchemaValue<int32_t>(m_ptr, "CStaticPoseCache", "m_nBoneCount");
}
void GCStaticPoseCache::SetBoneCount(int32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CStaticPoseCache->BoneCount(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CStaticPoseCache", "m_nBoneCount", false, value);
}
int32_t GCStaticPoseCache::GetMorphCount() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CStaticPoseCache->MorphCount(ptr=%p)", m_ptr));
    return GetSchemaValue<int32_t>(m_ptr, "CStaticPoseCache", "m_nMorphCount");
}
void GCStaticPoseCache::SetMorphCount(int32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CStaticPoseCache->MorphCount(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CStaticPoseCache", "m_nMorphCount", false, value);
}
void* GCStaticPoseCache::GetPtr() {
    return m_ptr;
}
std::string GCStaticPoseCache::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCStaticPoseCache::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCStaticPoseCache(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCStaticPoseCache>("CStaticPoseCache")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Poses", &GCStaticPoseCache::GetPoses, &GCStaticPoseCache::SetPoses)
        .addProperty("BoneCount", &GCStaticPoseCache::GetBoneCount, &GCStaticPoseCache::SetBoneCount)
        .addProperty("MorphCount", &GCStaticPoseCache::GetMorphCount, &GCStaticPoseCache::SetMorphCount)
        .addFunction("ToPtr", &GCStaticPoseCache::ToPtr)
        .addFunction("IsValid", &GCStaticPoseCache::IsValid)
        .endClass();
}
GParticlePreviewBodyGroup_t::GParticlePreviewBodyGroup_t(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GParticlePreviewBodyGroup_t::GParticlePreviewBodyGroup_t(void *ptr) {
    m_ptr = ptr;
}
std::string GParticlePreviewBodyGroup_t::GetBodyGroupName() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: ParticlePreviewBodyGroup_t->BodyGroupName(ptr=%p)", m_ptr));
    return GetSchemaValue<CUtlString>(m_ptr, "ParticlePreviewBodyGroup_t", "m_bodyGroupName").Get();
}
void GParticlePreviewBodyGroup_t::SetBodyGroupName(std::string value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: ParticlePreviewBodyGroup_t->BodyGroupName(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "ParticlePreviewBodyGroup_t", "m_bodyGroupName", true, CUtlString(value.c_str()));
}
int32_t GParticlePreviewBodyGroup_t::GetValue() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: ParticlePreviewBodyGroup_t->Value(ptr=%p)", m_ptr));
    return GetSchemaValue<int32_t>(m_ptr, "ParticlePreviewBodyGroup_t", "m_nValue");
}
void GParticlePreviewBodyGroup_t::SetValue(int32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: ParticlePreviewBodyGroup_t->Value(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "ParticlePreviewBodyGroup_t", "m_nValue", true, value);
}
void* GParticlePreviewBodyGroup_t::GetPtr() {
    return m_ptr;
}
std::string GParticlePreviewBodyGroup_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GParticlePreviewBodyGroup_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassParticlePreviewBodyGroup_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GParticlePreviewBodyGroup_t>("ParticlePreviewBodyGroup_t")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("BodyGroupName", &GParticlePreviewBodyGroup_t::GetBodyGroupName, &GParticlePreviewBodyGroup_t::SetBodyGroupName)
        .addProperty("Value", &GParticlePreviewBodyGroup_t::GetValue, &GParticlePreviewBodyGroup_t::SetValue)
        .addFunction("ToPtr", &GParticlePreviewBodyGroup_t::ToPtr)
        .addFunction("IsValid", &GParticlePreviewBodyGroup_t::IsValid)
        .endClass();
}
GFeWorldCollisionParams_t::GFeWorldCollisionParams_t(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GFeWorldCollisionParams_t::GFeWorldCollisionParams_t(void *ptr) {
    m_ptr = ptr;
}
float GFeWorldCollisionParams_t::GetWorldFriction() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FeWorldCollisionParams_t->WorldFriction(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "FeWorldCollisionParams_t", "flWorldFriction");
}
void GFeWorldCollisionParams_t::SetWorldFriction(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FeWorldCollisionParams_t->WorldFriction(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "FeWorldCollisionParams_t", "flWorldFriction", true, value);
}
float GFeWorldCollisionParams_t::GetGroundFriction() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FeWorldCollisionParams_t->GroundFriction(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "FeWorldCollisionParams_t", "flGroundFriction");
}
void GFeWorldCollisionParams_t::SetGroundFriction(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FeWorldCollisionParams_t->GroundFriction(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "FeWorldCollisionParams_t", "flGroundFriction", true, value);
}
uint16_t GFeWorldCollisionParams_t::GetListBegin() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FeWorldCollisionParams_t->ListBegin(ptr=%p)", m_ptr));
    return GetSchemaValue<uint16_t>(m_ptr, "FeWorldCollisionParams_t", "nListBegin");
}
void GFeWorldCollisionParams_t::SetListBegin(uint16_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FeWorldCollisionParams_t->ListBegin(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "FeWorldCollisionParams_t", "nListBegin", true, value);
}
uint16_t GFeWorldCollisionParams_t::GetListEnd() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FeWorldCollisionParams_t->ListEnd(ptr=%p)", m_ptr));
    return GetSchemaValue<uint16_t>(m_ptr, "FeWorldCollisionParams_t", "nListEnd");
}
void GFeWorldCollisionParams_t::SetListEnd(uint16_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FeWorldCollisionParams_t->ListEnd(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "FeWorldCollisionParams_t", "nListEnd", true, value);
}
void* GFeWorldCollisionParams_t::GetPtr() {
    return m_ptr;
}
std::string GFeWorldCollisionParams_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GFeWorldCollisionParams_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassFeWorldCollisionParams_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GFeWorldCollisionParams_t>("FeWorldCollisionParams_t")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("WorldFriction", &GFeWorldCollisionParams_t::GetWorldFriction, &GFeWorldCollisionParams_t::SetWorldFriction)
        .addProperty("GroundFriction", &GFeWorldCollisionParams_t::GetGroundFriction, &GFeWorldCollisionParams_t::SetGroundFriction)
        .addProperty("ListBegin", &GFeWorldCollisionParams_t::GetListBegin, &GFeWorldCollisionParams_t::SetListBegin)
        .addProperty("ListEnd", &GFeWorldCollisionParams_t::GetListEnd, &GFeWorldCollisionParams_t::SetListEnd)
        .addFunction("ToPtr", &GFeWorldCollisionParams_t::ToPtr)
        .addFunction("IsValid", &GFeWorldCollisionParams_t::IsValid)
        .endClass();
}
GCPlayerInputAnimMotorUpdater::GCPlayerInputAnimMotorUpdater(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCPlayerInputAnimMotorUpdater::GCPlayerInputAnimMotorUpdater(void *ptr) {
    m_ptr = ptr;
}
std::vector<float32> GCPlayerInputAnimMotorUpdater::GetSampleTimes() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CPlayerInputAnimMotorUpdater->SampleTimes(ptr=%p)", m_ptr));
    CUtlVector<float32>* vec = GetSchemaValue<CUtlVector<float32>*>(m_ptr, "CPlayerInputAnimMotorUpdater", "m_sampleTimes"); std::vector<float32> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCPlayerInputAnimMotorUpdater::SetSampleTimes(std::vector<float32> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CPlayerInputAnimMotorUpdater->SampleTimes(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<float32>(m_ptr, "CPlayerInputAnimMotorUpdater", "m_sampleTimes", false, value);
}
float GCPlayerInputAnimMotorUpdater::GetSpringConstant() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CPlayerInputAnimMotorUpdater->SpringConstant(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CPlayerInputAnimMotorUpdater", "m_flSpringConstant");
}
void GCPlayerInputAnimMotorUpdater::SetSpringConstant(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CPlayerInputAnimMotorUpdater->SpringConstant(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CPlayerInputAnimMotorUpdater", "m_flSpringConstant", false, value);
}
float GCPlayerInputAnimMotorUpdater::GetAnticipationDistance() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CPlayerInputAnimMotorUpdater->AnticipationDistance(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CPlayerInputAnimMotorUpdater", "m_flAnticipationDistance");
}
void GCPlayerInputAnimMotorUpdater::SetAnticipationDistance(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CPlayerInputAnimMotorUpdater->AnticipationDistance(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CPlayerInputAnimMotorUpdater", "m_flAnticipationDistance", false, value);
}
GCAnimParamHandle GCPlayerInputAnimMotorUpdater::GetAnticipationPosParam() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CPlayerInputAnimMotorUpdater->AnticipationPosParam(ptr=%p)", m_ptr));
    GCAnimParamHandle value(GetSchemaPtr(m_ptr, "CPlayerInputAnimMotorUpdater", "m_hAnticipationPosParam"));
    return value;
}
void GCPlayerInputAnimMotorUpdater::SetAnticipationPosParam(GCAnimParamHandle value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CPlayerInputAnimMotorUpdater->AnticipationPosParam(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'AnticipationPosParam' is not possible.\n");
}
GCAnimParamHandle GCPlayerInputAnimMotorUpdater::GetAnticipationHeadingParam() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CPlayerInputAnimMotorUpdater->AnticipationHeadingParam(ptr=%p)", m_ptr));
    GCAnimParamHandle value(GetSchemaPtr(m_ptr, "CPlayerInputAnimMotorUpdater", "m_hAnticipationHeadingParam"));
    return value;
}
void GCPlayerInputAnimMotorUpdater::SetAnticipationHeadingParam(GCAnimParamHandle value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CPlayerInputAnimMotorUpdater->AnticipationHeadingParam(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'AnticipationHeadingParam' is not possible.\n");
}
bool GCPlayerInputAnimMotorUpdater::GetUseAcceleration() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CPlayerInputAnimMotorUpdater->UseAcceleration(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "CPlayerInputAnimMotorUpdater", "m_bUseAcceleration");
}
void GCPlayerInputAnimMotorUpdater::SetUseAcceleration(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CPlayerInputAnimMotorUpdater->UseAcceleration(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CPlayerInputAnimMotorUpdater", "m_bUseAcceleration", false, value);
}
void* GCPlayerInputAnimMotorUpdater::GetPtr() {
    return m_ptr;
}
std::string GCPlayerInputAnimMotorUpdater::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCPlayerInputAnimMotorUpdater::IsValid() {
    return (m_ptr != nullptr);
}
GCAnimMotorUpdaterBase GCPlayerInputAnimMotorUpdater::GetParent() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CPlayerInputAnimMotorUpdater::GetParent(ptr=%p)", m_ptr));
    GCAnimMotorUpdaterBase value(m_ptr);
    return value;
}
void GCPlayerInputAnimMotorUpdater::SetParent(GCAnimMotorUpdaterBase value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CPlayerInputAnimMotorUpdater::SetParent(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCPlayerInputAnimMotorUpdater(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCPlayerInputAnimMotorUpdater>("CPlayerInputAnimMotorUpdater")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("SampleTimes", &GCPlayerInputAnimMotorUpdater::GetSampleTimes, &GCPlayerInputAnimMotorUpdater::SetSampleTimes)
        .addProperty("SpringConstant", &GCPlayerInputAnimMotorUpdater::GetSpringConstant, &GCPlayerInputAnimMotorUpdater::SetSpringConstant)
        .addProperty("AnticipationDistance", &GCPlayerInputAnimMotorUpdater::GetAnticipationDistance, &GCPlayerInputAnimMotorUpdater::SetAnticipationDistance)
        .addProperty("AnticipationPosParam", &GCPlayerInputAnimMotorUpdater::GetAnticipationPosParam, &GCPlayerInputAnimMotorUpdater::SetAnticipationPosParam)
        .addProperty("AnticipationHeadingParam", &GCPlayerInputAnimMotorUpdater::GetAnticipationHeadingParam, &GCPlayerInputAnimMotorUpdater::SetAnticipationHeadingParam)
        .addProperty("UseAcceleration", &GCPlayerInputAnimMotorUpdater::GetUseAcceleration, &GCPlayerInputAnimMotorUpdater::SetUseAcceleration)
        .addProperty("Parent", &GCPlayerInputAnimMotorUpdater::GetParent, &GCPlayerInputAnimMotorUpdater::SetParent)
        .addFunction("ToPtr", &GCPlayerInputAnimMotorUpdater::ToPtr)
        .addFunction("IsValid", &GCPlayerInputAnimMotorUpdater::IsValid)
        .endClass();
}
GCParticleCollectionRendererVecInput::GCParticleCollectionRendererVecInput(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCParticleCollectionRendererVecInput::GCParticleCollectionRendererVecInput(void *ptr) {
    m_ptr = ptr;
}
void* GCParticleCollectionRendererVecInput::GetPtr() {
    return m_ptr;
}
std::string GCParticleCollectionRendererVecInput::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCParticleCollectionRendererVecInput::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCParticleCollectionRendererVecInput(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCParticleCollectionRendererVecInput>("CParticleCollectionRendererVecInput")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addFunction("ToPtr", &GCParticleCollectionRendererVecInput::ToPtr)
        .addFunction("IsValid", &GCParticleCollectionRendererVecInput::IsValid)
        .endClass();
}
GFeBandBendLimit_t::GFeBandBendLimit_t(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GFeBandBendLimit_t::GFeBandBendLimit_t(void *ptr) {
    m_ptr = ptr;
}
float GFeBandBendLimit_t::GetDistMin() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FeBandBendLimit_t->DistMin(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "FeBandBendLimit_t", "flDistMin");
}
void GFeBandBendLimit_t::SetDistMin(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FeBandBendLimit_t->DistMin(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "FeBandBendLimit_t", "flDistMin", true, value);
}
float GFeBandBendLimit_t::GetDistMax() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FeBandBendLimit_t->DistMax(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "FeBandBendLimit_t", "flDistMax");
}
void GFeBandBendLimit_t::SetDistMax(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FeBandBendLimit_t->DistMax(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "FeBandBendLimit_t", "flDistMax", true, value);
}
std::vector<uint16_t> GFeBandBendLimit_t::GetNode() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FeBandBendLimit_t->Node(ptr=%p,size=6)", m_ptr));
    uint16_t* outValue = (uint16_t*)GetSchemaPtr(m_ptr, "FeBandBendLimit_t", "nNode"); std::vector<uint16_t> ret; for(int i = 0; i < 6; i++) { ret.push_back(outValue[i]); } return ret;
}
void GFeBandBendLimit_t::SetNode(std::vector<uint16_t> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FeBandBendLimit_t->Node(ptr=%p,size=6)", m_ptr));
    if(value.size() != 6) return PLUGIN_PRINT("Schema SDK", "Field 'Node' needs to have 6 values.\n");
    auto val = GetSchemaValuePtr<uint16_t>(m_ptr, "FeBandBendLimit_t", "nNode");
    for(size_t i = 0; i < value.size(); i++) val[i] = value[i];
}
void* GFeBandBendLimit_t::GetPtr() {
    return m_ptr;
}
std::string GFeBandBendLimit_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GFeBandBendLimit_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassFeBandBendLimit_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GFeBandBendLimit_t>("FeBandBendLimit_t")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("DistMin", &GFeBandBendLimit_t::GetDistMin, &GFeBandBendLimit_t::SetDistMin)
        .addProperty("DistMax", &GFeBandBendLimit_t::GetDistMax, &GFeBandBendLimit_t::SetDistMax)
        .addProperty("Node", &GFeBandBendLimit_t::GetNode, &GFeBandBendLimit_t::SetNode)
        .addFunction("ToPtr", &GFeBandBendLimit_t::ToPtr)
        .addFunction("IsValid", &GFeBandBendLimit_t::IsValid)
        .endClass();
}
GCAnimFoot::GCAnimFoot(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCAnimFoot::GCAnimFoot(void *ptr) {
    m_ptr = ptr;
}
std::string GCAnimFoot::GetName() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CAnimFoot->Name(ptr=%p)", m_ptr));
    return GetSchemaValue<CUtlString>(m_ptr, "CAnimFoot", "m_name").Get();
}
void GCAnimFoot::SetName(std::string value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CAnimFoot->Name(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CAnimFoot", "m_name", false, CUtlString(value.c_str()));
}
Vector GCAnimFoot::GetBallOffset() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CAnimFoot->BallOffset(ptr=%p)", m_ptr));
    return GetSchemaValue<Vector>(m_ptr, "CAnimFoot", "m_vBallOffset");
}
void GCAnimFoot::SetBallOffset(Vector value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CAnimFoot->BallOffset(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CAnimFoot", "m_vBallOffset", false, value);
}
Vector GCAnimFoot::GetHeelOffset() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CAnimFoot->HeelOffset(ptr=%p)", m_ptr));
    return GetSchemaValue<Vector>(m_ptr, "CAnimFoot", "m_vHeelOffset");
}
void GCAnimFoot::SetHeelOffset(Vector value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CAnimFoot->HeelOffset(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CAnimFoot", "m_vHeelOffset", false, value);
}
int32_t GCAnimFoot::GetAnkleBoneIndex() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CAnimFoot->AnkleBoneIndex(ptr=%p)", m_ptr));
    return GetSchemaValue<int32_t>(m_ptr, "CAnimFoot", "m_ankleBoneIndex");
}
void GCAnimFoot::SetAnkleBoneIndex(int32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CAnimFoot->AnkleBoneIndex(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CAnimFoot", "m_ankleBoneIndex", false, value);
}
int32_t GCAnimFoot::GetToeBoneIndex() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CAnimFoot->ToeBoneIndex(ptr=%p)", m_ptr));
    return GetSchemaValue<int32_t>(m_ptr, "CAnimFoot", "m_toeBoneIndex");
}
void GCAnimFoot::SetToeBoneIndex(int32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CAnimFoot->ToeBoneIndex(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CAnimFoot", "m_toeBoneIndex", false, value);
}
void* GCAnimFoot::GetPtr() {
    return m_ptr;
}
std::string GCAnimFoot::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCAnimFoot::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCAnimFoot(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCAnimFoot>("CAnimFoot")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Name", &GCAnimFoot::GetName, &GCAnimFoot::SetName)
        .addProperty("BallOffset", &GCAnimFoot::GetBallOffset, &GCAnimFoot::SetBallOffset)
        .addProperty("HeelOffset", &GCAnimFoot::GetHeelOffset, &GCAnimFoot::SetHeelOffset)
        .addProperty("AnkleBoneIndex", &GCAnimFoot::GetAnkleBoneIndex, &GCAnimFoot::SetAnkleBoneIndex)
        .addProperty("ToeBoneIndex", &GCAnimFoot::GetToeBoneIndex, &GCAnimFoot::SetToeBoneIndex)
        .addFunction("ToPtr", &GCAnimFoot::ToPtr)
        .addFunction("IsValid", &GCAnimFoot::IsValid)
        .endClass();
}
GEventClientAdvanceTick_t::GEventClientAdvanceTick_t(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GEventClientAdvanceTick_t::GEventClientAdvanceTick_t(void *ptr) {
    m_ptr = ptr;
}
void* GEventClientAdvanceTick_t::GetPtr() {
    return m_ptr;
}
std::string GEventClientAdvanceTick_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GEventClientAdvanceTick_t::IsValid() {
    return (m_ptr != nullptr);
}
GEventAdvanceTick_t GEventClientAdvanceTick_t::GetParent() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("EventClientAdvanceTick_t::GetParent(ptr=%p)", m_ptr));
    GEventAdvanceTick_t value(m_ptr);
    return value;
}
void GEventClientAdvanceTick_t::SetParent(GEventAdvanceTick_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("EventClientAdvanceTick_t::SetParent(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassEventClientAdvanceTick_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GEventClientAdvanceTick_t>("EventClientAdvanceTick_t")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Parent", &GEventClientAdvanceTick_t::GetParent, &GEventClientAdvanceTick_t::SetParent)
        .addFunction("ToPtr", &GEventClientAdvanceTick_t::ToPtr)
        .addFunction("IsValid", &GEventClientAdvanceTick_t::IsValid)
        .endClass();
}
GMaterialOverride_t::GMaterialOverride_t(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GMaterialOverride_t::GMaterialOverride_t(void *ptr) {
    m_ptr = ptr;
}
uint32_t GMaterialOverride_t::GetSubSceneObject() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: MaterialOverride_t->SubSceneObject(ptr=%p)", m_ptr));
    return GetSchemaValue<uint32_t>(m_ptr, "MaterialOverride_t", "m_nSubSceneObject");
}
void GMaterialOverride_t::SetSubSceneObject(uint32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: MaterialOverride_t->SubSceneObject(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "MaterialOverride_t", "m_nSubSceneObject", true, value);
}
uint32_t GMaterialOverride_t::GetDrawCallIndex() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: MaterialOverride_t->DrawCallIndex(ptr=%p)", m_ptr));
    return GetSchemaValue<uint32_t>(m_ptr, "MaterialOverride_t", "m_nDrawCallIndex");
}
void GMaterialOverride_t::SetDrawCallIndex(uint32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: MaterialOverride_t->DrawCallIndex(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "MaterialOverride_t", "m_nDrawCallIndex", true, value);
}
void* GMaterialOverride_t::GetPtr() {
    return m_ptr;
}
std::string GMaterialOverride_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GMaterialOverride_t::IsValid() {
    return (m_ptr != nullptr);
}
GBaseSceneObjectOverride_t GMaterialOverride_t::GetParent() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("MaterialOverride_t::GetParent(ptr=%p)", m_ptr));
    GBaseSceneObjectOverride_t value(m_ptr);
    return value;
}
void GMaterialOverride_t::SetParent(GBaseSceneObjectOverride_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("MaterialOverride_t::SetParent(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassMaterialOverride_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GMaterialOverride_t>("MaterialOverride_t")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("SubSceneObject", &GMaterialOverride_t::GetSubSceneObject, &GMaterialOverride_t::SetSubSceneObject)
        .addProperty("DrawCallIndex", &GMaterialOverride_t::GetDrawCallIndex, &GMaterialOverride_t::SetDrawCallIndex)
        .addProperty("Parent", &GMaterialOverride_t::GetParent, &GMaterialOverride_t::SetParent)
        .addFunction("ToPtr", &GMaterialOverride_t::ToPtr)
        .addFunction("IsValid", &GMaterialOverride_t::IsValid)
        .endClass();
}
GCAnimDemoCaptureSettings::GCAnimDemoCaptureSettings(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCAnimDemoCaptureSettings::GCAnimDemoCaptureSettings(void *ptr) {
    m_ptr = ptr;
}
Vector2D GCAnimDemoCaptureSettings::GetErrorRangeSplineRotation() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CAnimDemoCaptureSettings->ErrorRangeSplineRotation(ptr=%p)", m_ptr));
    return GetSchemaValue<Vector2D>(m_ptr, "CAnimDemoCaptureSettings", "m_vecErrorRangeSplineRotation");
}
void GCAnimDemoCaptureSettings::SetErrorRangeSplineRotation(Vector2D value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CAnimDemoCaptureSettings->ErrorRangeSplineRotation(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CAnimDemoCaptureSettings", "m_vecErrorRangeSplineRotation", false, value);
}
Vector2D GCAnimDemoCaptureSettings::GetErrorRangeSplineTranslation() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CAnimDemoCaptureSettings->ErrorRangeSplineTranslation(ptr=%p)", m_ptr));
    return GetSchemaValue<Vector2D>(m_ptr, "CAnimDemoCaptureSettings", "m_vecErrorRangeSplineTranslation");
}
void GCAnimDemoCaptureSettings::SetErrorRangeSplineTranslation(Vector2D value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CAnimDemoCaptureSettings->ErrorRangeSplineTranslation(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CAnimDemoCaptureSettings", "m_vecErrorRangeSplineTranslation", false, value);
}
Vector2D GCAnimDemoCaptureSettings::GetErrorRangeSplineScale() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CAnimDemoCaptureSettings->ErrorRangeSplineScale(ptr=%p)", m_ptr));
    return GetSchemaValue<Vector2D>(m_ptr, "CAnimDemoCaptureSettings", "m_vecErrorRangeSplineScale");
}
void GCAnimDemoCaptureSettings::SetErrorRangeSplineScale(Vector2D value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CAnimDemoCaptureSettings->ErrorRangeSplineScale(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CAnimDemoCaptureSettings", "m_vecErrorRangeSplineScale", false, value);
}
float GCAnimDemoCaptureSettings::GetIkRotation_MaxSplineError() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CAnimDemoCaptureSettings->IkRotation_MaxSplineError(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CAnimDemoCaptureSettings", "m_flIkRotation_MaxSplineError");
}
void GCAnimDemoCaptureSettings::SetIkRotation_MaxSplineError(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CAnimDemoCaptureSettings->IkRotation_MaxSplineError(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CAnimDemoCaptureSettings", "m_flIkRotation_MaxSplineError", false, value);
}
float GCAnimDemoCaptureSettings::GetIkTranslation_MaxSplineError() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CAnimDemoCaptureSettings->IkTranslation_MaxSplineError(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CAnimDemoCaptureSettings", "m_flIkTranslation_MaxSplineError");
}
void GCAnimDemoCaptureSettings::SetIkTranslation_MaxSplineError(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CAnimDemoCaptureSettings->IkTranslation_MaxSplineError(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CAnimDemoCaptureSettings", "m_flIkTranslation_MaxSplineError", false, value);
}
Vector2D GCAnimDemoCaptureSettings::GetErrorRangeQuantizationRotation() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CAnimDemoCaptureSettings->ErrorRangeQuantizationRotation(ptr=%p)", m_ptr));
    return GetSchemaValue<Vector2D>(m_ptr, "CAnimDemoCaptureSettings", "m_vecErrorRangeQuantizationRotation");
}
void GCAnimDemoCaptureSettings::SetErrorRangeQuantizationRotation(Vector2D value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CAnimDemoCaptureSettings->ErrorRangeQuantizationRotation(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CAnimDemoCaptureSettings", "m_vecErrorRangeQuantizationRotation", false, value);
}
Vector2D GCAnimDemoCaptureSettings::GetErrorRangeQuantizationTranslation() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CAnimDemoCaptureSettings->ErrorRangeQuantizationTranslation(ptr=%p)", m_ptr));
    return GetSchemaValue<Vector2D>(m_ptr, "CAnimDemoCaptureSettings", "m_vecErrorRangeQuantizationTranslation");
}
void GCAnimDemoCaptureSettings::SetErrorRangeQuantizationTranslation(Vector2D value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CAnimDemoCaptureSettings->ErrorRangeQuantizationTranslation(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CAnimDemoCaptureSettings", "m_vecErrorRangeQuantizationTranslation", false, value);
}
Vector2D GCAnimDemoCaptureSettings::GetErrorRangeQuantizationScale() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CAnimDemoCaptureSettings->ErrorRangeQuantizationScale(ptr=%p)", m_ptr));
    return GetSchemaValue<Vector2D>(m_ptr, "CAnimDemoCaptureSettings", "m_vecErrorRangeQuantizationScale");
}
void GCAnimDemoCaptureSettings::SetErrorRangeQuantizationScale(Vector2D value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CAnimDemoCaptureSettings->ErrorRangeQuantizationScale(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CAnimDemoCaptureSettings", "m_vecErrorRangeQuantizationScale", false, value);
}
float GCAnimDemoCaptureSettings::GetIkRotation_MaxQuantizationError() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CAnimDemoCaptureSettings->IkRotation_MaxQuantizationError(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CAnimDemoCaptureSettings", "m_flIkRotation_MaxQuantizationError");
}
void GCAnimDemoCaptureSettings::SetIkRotation_MaxQuantizationError(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CAnimDemoCaptureSettings->IkRotation_MaxQuantizationError(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CAnimDemoCaptureSettings", "m_flIkRotation_MaxQuantizationError", false, value);
}
float GCAnimDemoCaptureSettings::GetIkTranslation_MaxQuantizationError() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CAnimDemoCaptureSettings->IkTranslation_MaxQuantizationError(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CAnimDemoCaptureSettings", "m_flIkTranslation_MaxQuantizationError");
}
void GCAnimDemoCaptureSettings::SetIkTranslation_MaxQuantizationError(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CAnimDemoCaptureSettings->IkTranslation_MaxQuantizationError(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CAnimDemoCaptureSettings", "m_flIkTranslation_MaxQuantizationError", false, value);
}
std::string GCAnimDemoCaptureSettings::GetBaseSequence() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CAnimDemoCaptureSettings->BaseSequence(ptr=%p)", m_ptr));
    return GetSchemaValue<CUtlString>(m_ptr, "CAnimDemoCaptureSettings", "m_baseSequence").Get();
}
void GCAnimDemoCaptureSettings::SetBaseSequence(std::string value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CAnimDemoCaptureSettings->BaseSequence(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CAnimDemoCaptureSettings", "m_baseSequence", false, CUtlString(value.c_str()));
}
int32_t GCAnimDemoCaptureSettings::GetBaseSequenceFrame() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CAnimDemoCaptureSettings->BaseSequenceFrame(ptr=%p)", m_ptr));
    return GetSchemaValue<int32_t>(m_ptr, "CAnimDemoCaptureSettings", "m_nBaseSequenceFrame");
}
void GCAnimDemoCaptureSettings::SetBaseSequenceFrame(int32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CAnimDemoCaptureSettings->BaseSequenceFrame(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CAnimDemoCaptureSettings", "m_nBaseSequenceFrame", false, value);
}
uint64_t GCAnimDemoCaptureSettings::GetBoneSelectionMode() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CAnimDemoCaptureSettings->BoneSelectionMode(ptr=%p)", m_ptr));
    return GetSchemaValue<uint64_t>(m_ptr, "CAnimDemoCaptureSettings", "m_boneSelectionMode");
}
void GCAnimDemoCaptureSettings::SetBoneSelectionMode(uint64_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CAnimDemoCaptureSettings->BoneSelectionMode(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CAnimDemoCaptureSettings", "m_boneSelectionMode", false, value);
}
std::vector<GBoneDemoCaptureSettings_t> GCAnimDemoCaptureSettings::GetBones() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CAnimDemoCaptureSettings->Bones(ptr=%p)", m_ptr));
    CUtlVector<GBoneDemoCaptureSettings_t>* vec = GetSchemaValue<CUtlVector<GBoneDemoCaptureSettings_t>*>(m_ptr, "CAnimDemoCaptureSettings", "m_bones"); std::vector<GBoneDemoCaptureSettings_t> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCAnimDemoCaptureSettings::SetBones(std::vector<GBoneDemoCaptureSettings_t> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CAnimDemoCaptureSettings->Bones(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<GBoneDemoCaptureSettings_t>(m_ptr, "CAnimDemoCaptureSettings", "m_bones", false, value);
}
std::vector<GIKDemoCaptureSettings_t> GCAnimDemoCaptureSettings::GetIkChains() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CAnimDemoCaptureSettings->IkChains(ptr=%p)", m_ptr));
    CUtlVector<GIKDemoCaptureSettings_t>* vec = GetSchemaValue<CUtlVector<GIKDemoCaptureSettings_t>*>(m_ptr, "CAnimDemoCaptureSettings", "m_ikChains"); std::vector<GIKDemoCaptureSettings_t> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCAnimDemoCaptureSettings::SetIkChains(std::vector<GIKDemoCaptureSettings_t> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CAnimDemoCaptureSettings->IkChains(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<GIKDemoCaptureSettings_t>(m_ptr, "CAnimDemoCaptureSettings", "m_ikChains", false, value);
}
void* GCAnimDemoCaptureSettings::GetPtr() {
    return m_ptr;
}
std::string GCAnimDemoCaptureSettings::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCAnimDemoCaptureSettings::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCAnimDemoCaptureSettings(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCAnimDemoCaptureSettings>("CAnimDemoCaptureSettings")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("ErrorRangeSplineRotation", &GCAnimDemoCaptureSettings::GetErrorRangeSplineRotation, &GCAnimDemoCaptureSettings::SetErrorRangeSplineRotation)
        .addProperty("ErrorRangeSplineTranslation", &GCAnimDemoCaptureSettings::GetErrorRangeSplineTranslation, &GCAnimDemoCaptureSettings::SetErrorRangeSplineTranslation)
        .addProperty("ErrorRangeSplineScale", &GCAnimDemoCaptureSettings::GetErrorRangeSplineScale, &GCAnimDemoCaptureSettings::SetErrorRangeSplineScale)
        .addProperty("IkRotation_MaxSplineError", &GCAnimDemoCaptureSettings::GetIkRotation_MaxSplineError, &GCAnimDemoCaptureSettings::SetIkRotation_MaxSplineError)
        .addProperty("IkTranslation_MaxSplineError", &GCAnimDemoCaptureSettings::GetIkTranslation_MaxSplineError, &GCAnimDemoCaptureSettings::SetIkTranslation_MaxSplineError)
        .addProperty("ErrorRangeQuantizationRotation", &GCAnimDemoCaptureSettings::GetErrorRangeQuantizationRotation, &GCAnimDemoCaptureSettings::SetErrorRangeQuantizationRotation)
        .addProperty("ErrorRangeQuantizationTranslation", &GCAnimDemoCaptureSettings::GetErrorRangeQuantizationTranslation, &GCAnimDemoCaptureSettings::SetErrorRangeQuantizationTranslation)
        .addProperty("ErrorRangeQuantizationScale", &GCAnimDemoCaptureSettings::GetErrorRangeQuantizationScale, &GCAnimDemoCaptureSettings::SetErrorRangeQuantizationScale)
        .addProperty("IkRotation_MaxQuantizationError", &GCAnimDemoCaptureSettings::GetIkRotation_MaxQuantizationError, &GCAnimDemoCaptureSettings::SetIkRotation_MaxQuantizationError)
        .addProperty("IkTranslation_MaxQuantizationError", &GCAnimDemoCaptureSettings::GetIkTranslation_MaxQuantizationError, &GCAnimDemoCaptureSettings::SetIkTranslation_MaxQuantizationError)
        .addProperty("BaseSequence", &GCAnimDemoCaptureSettings::GetBaseSequence, &GCAnimDemoCaptureSettings::SetBaseSequence)
        .addProperty("BaseSequenceFrame", &GCAnimDemoCaptureSettings::GetBaseSequenceFrame, &GCAnimDemoCaptureSettings::SetBaseSequenceFrame)
        .addProperty("BoneSelectionMode", &GCAnimDemoCaptureSettings::GetBoneSelectionMode, &GCAnimDemoCaptureSettings::SetBoneSelectionMode)
        .addProperty("Bones", &GCAnimDemoCaptureSettings::GetBones, &GCAnimDemoCaptureSettings::SetBones)
        .addProperty("IkChains", &GCAnimDemoCaptureSettings::GetIkChains, &GCAnimDemoCaptureSettings::SetIkChains)
        .addFunction("ToPtr", &GCAnimDemoCaptureSettings::ToPtr)
        .addFunction("IsValid", &GCAnimDemoCaptureSettings::IsValid)
        .endClass();
}
GCNmIDEvent::GCNmIDEvent(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCNmIDEvent::GCNmIDEvent(void *ptr) {
    m_ptr = ptr;
}
void* GCNmIDEvent::GetPtr() {
    return m_ptr;
}
std::string GCNmIDEvent::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCNmIDEvent::IsValid() {
    return (m_ptr != nullptr);
}
GCNmEvent GCNmIDEvent::GetParent() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CNmIDEvent::GetParent(ptr=%p)", m_ptr));
    GCNmEvent value(m_ptr);
    return value;
}
void GCNmIDEvent::SetParent(GCNmEvent value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CNmIDEvent::SetParent(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCNmIDEvent(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCNmIDEvent>("CNmIDEvent")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Parent", &GCNmIDEvent::GetParent, &GCNmIDEvent::SetParent)
        .addFunction("ToPtr", &GCNmIDEvent::ToPtr)
        .addFunction("IsValid", &GCNmIDEvent::IsValid)
        .endClass();
}
GCPathMetricEvaluator::GCPathMetricEvaluator(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCPathMetricEvaluator::GCPathMetricEvaluator(void *ptr) {
    m_ptr = ptr;
}
std::vector<float32> GCPathMetricEvaluator::GetPathTimeSamples() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CPathMetricEvaluator->PathTimeSamples(ptr=%p)", m_ptr));
    CUtlVector<float32>* vec = GetSchemaValue<CUtlVector<float32>*>(m_ptr, "CPathMetricEvaluator", "m_pathTimeSamples"); std::vector<float32> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCPathMetricEvaluator::SetPathTimeSamples(std::vector<float32> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CPathMetricEvaluator->PathTimeSamples(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<float32>(m_ptr, "CPathMetricEvaluator", "m_pathTimeSamples", false, value);
}
float GCPathMetricEvaluator::GetDistance() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CPathMetricEvaluator->Distance(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CPathMetricEvaluator", "m_flDistance");
}
void GCPathMetricEvaluator::SetDistance(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CPathMetricEvaluator->Distance(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CPathMetricEvaluator", "m_flDistance", false, value);
}
bool GCPathMetricEvaluator::GetExtrapolateMovement() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CPathMetricEvaluator->ExtrapolateMovement(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "CPathMetricEvaluator", "m_bExtrapolateMovement");
}
void GCPathMetricEvaluator::SetExtrapolateMovement(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CPathMetricEvaluator->ExtrapolateMovement(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CPathMetricEvaluator", "m_bExtrapolateMovement", false, value);
}
float GCPathMetricEvaluator::GetMinExtrapolationSpeed() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CPathMetricEvaluator->MinExtrapolationSpeed(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CPathMetricEvaluator", "m_flMinExtrapolationSpeed");
}
void GCPathMetricEvaluator::SetMinExtrapolationSpeed(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CPathMetricEvaluator->MinExtrapolationSpeed(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CPathMetricEvaluator", "m_flMinExtrapolationSpeed", false, value);
}
void* GCPathMetricEvaluator::GetPtr() {
    return m_ptr;
}
std::string GCPathMetricEvaluator::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCPathMetricEvaluator::IsValid() {
    return (m_ptr != nullptr);
}
GCMotionMetricEvaluator GCPathMetricEvaluator::GetParent() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CPathMetricEvaluator::GetParent(ptr=%p)", m_ptr));
    GCMotionMetricEvaluator value(m_ptr);
    return value;
}
void GCPathMetricEvaluator::SetParent(GCMotionMetricEvaluator value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CPathMetricEvaluator::SetParent(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCPathMetricEvaluator(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCPathMetricEvaluator>("CPathMetricEvaluator")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("PathTimeSamples", &GCPathMetricEvaluator::GetPathTimeSamples, &GCPathMetricEvaluator::SetPathTimeSamples)
        .addProperty("Distance", &GCPathMetricEvaluator::GetDistance, &GCPathMetricEvaluator::SetDistance)
        .addProperty("ExtrapolateMovement", &GCPathMetricEvaluator::GetExtrapolateMovement, &GCPathMetricEvaluator::SetExtrapolateMovement)
        .addProperty("MinExtrapolationSpeed", &GCPathMetricEvaluator::GetMinExtrapolationSpeed, &GCPathMetricEvaluator::SetMinExtrapolationSpeed)
        .addProperty("Parent", &GCPathMetricEvaluator::GetParent, &GCPathMetricEvaluator::SetParent)
        .addFunction("ToPtr", &GCPathMetricEvaluator::ToPtr)
        .addFunction("IsValid", &GCPathMetricEvaluator::IsValid)
        .endClass();
}
GMaterialParam_t::GMaterialParam_t(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GMaterialParam_t::GMaterialParam_t(void *ptr) {
    m_ptr = ptr;
}
std::string GMaterialParam_t::GetName() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: MaterialParam_t->Name(ptr=%p)", m_ptr));
    return GetSchemaValue<CUtlString>(m_ptr, "MaterialParam_t", "m_name").Get();
}
void GMaterialParam_t::SetName(std::string value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: MaterialParam_t->Name(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "MaterialParam_t", "m_name", true, CUtlString(value.c_str()));
}
void* GMaterialParam_t::GetPtr() {
    return m_ptr;
}
std::string GMaterialParam_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GMaterialParam_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassMaterialParam_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GMaterialParam_t>("MaterialParam_t")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Name", &GMaterialParam_t::GetName, &GMaterialParam_t::SetName)
        .addFunction("ToPtr", &GMaterialParam_t::ToPtr)
        .addFunction("IsValid", &GMaterialParam_t::IsValid)
        .endClass();
}
GCSpeedScaleUpdateNode::GCSpeedScaleUpdateNode(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCSpeedScaleUpdateNode::GCSpeedScaleUpdateNode(void *ptr) {
    m_ptr = ptr;
}
GCAnimParamHandle GCSpeedScaleUpdateNode::GetParamIndex() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CSpeedScaleUpdateNode->ParamIndex(ptr=%p)", m_ptr));
    GCAnimParamHandle value(GetSchemaPtr(m_ptr, "CSpeedScaleUpdateNode", "m_paramIndex"));
    return value;
}
void GCSpeedScaleUpdateNode::SetParamIndex(GCAnimParamHandle value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CSpeedScaleUpdateNode->ParamIndex(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'ParamIndex' is not possible.\n");
}
void* GCSpeedScaleUpdateNode::GetPtr() {
    return m_ptr;
}
std::string GCSpeedScaleUpdateNode::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCSpeedScaleUpdateNode::IsValid() {
    return (m_ptr != nullptr);
}
GCUnaryUpdateNode GCSpeedScaleUpdateNode::GetParent() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CSpeedScaleUpdateNode::GetParent(ptr=%p)", m_ptr));
    GCUnaryUpdateNode value(m_ptr);
    return value;
}
void GCSpeedScaleUpdateNode::SetParent(GCUnaryUpdateNode value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CSpeedScaleUpdateNode::SetParent(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCSpeedScaleUpdateNode(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCSpeedScaleUpdateNode>("CSpeedScaleUpdateNode")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("ParamIndex", &GCSpeedScaleUpdateNode::GetParamIndex, &GCSpeedScaleUpdateNode::SetParamIndex)
        .addProperty("Parent", &GCSpeedScaleUpdateNode::GetParent, &GCSpeedScaleUpdateNode::SetParent)
        .addFunction("ToPtr", &GCSpeedScaleUpdateNode::ToPtr)
        .addFunction("IsValid", &GCSpeedScaleUpdateNode::IsValid)
        .endClass();
}
GVMixEQ8Desc_t::GVMixEQ8Desc_t(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GVMixEQ8Desc_t::GVMixEQ8Desc_t(void *ptr) {
    m_ptr = ptr;
}
std::vector<GVMixFilterDesc_t> GVMixEQ8Desc_t::GetStages() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: VMixEQ8Desc_t->Stages(ptr=%p,size=8)", m_ptr));
    GVMixFilterDesc_t* outValue = (GVMixFilterDesc_t*)GetSchemaPtr(m_ptr, "VMixEQ8Desc_t", "m_stages"); std::vector<GVMixFilterDesc_t> ret; for(int i = 0; i < 8; i++) { ret.push_back(outValue[i]); } return ret;
}
void GVMixEQ8Desc_t::SetStages(std::vector<GVMixFilterDesc_t> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: VMixEQ8Desc_t->Stages(ptr=%p,size=8)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Stages' is not possible.\n");
}
void* GVMixEQ8Desc_t::GetPtr() {
    return m_ptr;
}
std::string GVMixEQ8Desc_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GVMixEQ8Desc_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassVMixEQ8Desc_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GVMixEQ8Desc_t>("VMixEQ8Desc_t")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Stages", &GVMixEQ8Desc_t::GetStages, &GVMixEQ8Desc_t::SetStages)
        .addFunction("ToPtr", &GVMixEQ8Desc_t::ToPtr)
        .addFunction("IsValid", &GVMixEQ8Desc_t::IsValid)
        .endClass();
}
GCModelConfigElement_SetMaterialGroupOnAttachedModels::GCModelConfigElement_SetMaterialGroupOnAttachedModels(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCModelConfigElement_SetMaterialGroupOnAttachedModels::GCModelConfigElement_SetMaterialGroupOnAttachedModels(void *ptr) {
    m_ptr = ptr;
}
std::string GCModelConfigElement_SetMaterialGroupOnAttachedModels::GetMaterialGroupName() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CModelConfigElement_SetMaterialGroupOnAttachedModels->MaterialGroupName(ptr=%p)", m_ptr));
    return GetSchemaValue<CUtlString>(m_ptr, "CModelConfigElement_SetMaterialGroupOnAttachedModels", "m_MaterialGroupName").Get();
}
void GCModelConfigElement_SetMaterialGroupOnAttachedModels::SetMaterialGroupName(std::string value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CModelConfigElement_SetMaterialGroupOnAttachedModels->MaterialGroupName(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CModelConfigElement_SetMaterialGroupOnAttachedModels", "m_MaterialGroupName", false, CUtlString(value.c_str()));
}
void* GCModelConfigElement_SetMaterialGroupOnAttachedModels::GetPtr() {
    return m_ptr;
}
std::string GCModelConfigElement_SetMaterialGroupOnAttachedModels::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCModelConfigElement_SetMaterialGroupOnAttachedModels::IsValid() {
    return (m_ptr != nullptr);
}
GCModelConfigElement GCModelConfigElement_SetMaterialGroupOnAttachedModels::GetParent() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CModelConfigElement_SetMaterialGroupOnAttachedModels::GetParent(ptr=%p)", m_ptr));
    GCModelConfigElement value(m_ptr);
    return value;
}
void GCModelConfigElement_SetMaterialGroupOnAttachedModels::SetParent(GCModelConfigElement value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CModelConfigElement_SetMaterialGroupOnAttachedModels::SetParent(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCModelConfigElement_SetMaterialGroupOnAttachedModels(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCModelConfigElement_SetMaterialGroupOnAttachedModels>("CModelConfigElement_SetMaterialGroupOnAttachedModels")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("MaterialGroupName", &GCModelConfigElement_SetMaterialGroupOnAttachedModels::GetMaterialGroupName, &GCModelConfigElement_SetMaterialGroupOnAttachedModels::SetMaterialGroupName)
        .addProperty("Parent", &GCModelConfigElement_SetMaterialGroupOnAttachedModels::GetParent, &GCModelConfigElement_SetMaterialGroupOnAttachedModels::SetParent)
        .addFunction("ToPtr", &GCModelConfigElement_SetMaterialGroupOnAttachedModels::ToPtr)
        .addFunction("IsValid", &GCModelConfigElement_SetMaterialGroupOnAttachedModels::IsValid)
        .endClass();
}
GTwoBoneIKSettings_t::GTwoBoneIKSettings_t(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GTwoBoneIKSettings_t::GTwoBoneIKSettings_t(void *ptr) {
    m_ptr = ptr;
}
uint64_t GTwoBoneIKSettings_t::GetEndEffectorType() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: TwoBoneIKSettings_t->EndEffectorType(ptr=%p)", m_ptr));
    return GetSchemaValue<uint64_t>(m_ptr, "TwoBoneIKSettings_t", "m_endEffectorType");
}
void GTwoBoneIKSettings_t::SetEndEffectorType(uint64_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: TwoBoneIKSettings_t->EndEffectorType(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "TwoBoneIKSettings_t", "m_endEffectorType", true, value);
}
GCAnimAttachment GTwoBoneIKSettings_t::GetEndEffectorAttachment() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: TwoBoneIKSettings_t->EndEffectorAttachment(ptr=%p)", m_ptr));
    GCAnimAttachment value(GetSchemaPtr(m_ptr, "TwoBoneIKSettings_t", "m_endEffectorAttachment"));
    return value;
}
void GTwoBoneIKSettings_t::SetEndEffectorAttachment(GCAnimAttachment value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: TwoBoneIKSettings_t->EndEffectorAttachment(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'EndEffectorAttachment' is not possible.\n");
}
uint64_t GTwoBoneIKSettings_t::GetTargetType() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: TwoBoneIKSettings_t->TargetType(ptr=%p)", m_ptr));
    return GetSchemaValue<uint64_t>(m_ptr, "TwoBoneIKSettings_t", "m_targetType");
}
void GTwoBoneIKSettings_t::SetTargetType(uint64_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: TwoBoneIKSettings_t->TargetType(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "TwoBoneIKSettings_t", "m_targetType", true, value);
}
GCAnimAttachment GTwoBoneIKSettings_t::GetTargetAttachment() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: TwoBoneIKSettings_t->TargetAttachment(ptr=%p)", m_ptr));
    GCAnimAttachment value(GetSchemaPtr(m_ptr, "TwoBoneIKSettings_t", "m_targetAttachment"));
    return value;
}
void GTwoBoneIKSettings_t::SetTargetAttachment(GCAnimAttachment value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: TwoBoneIKSettings_t->TargetAttachment(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'TargetAttachment' is not possible.\n");
}
int32_t GTwoBoneIKSettings_t::GetTargetBoneIndex() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: TwoBoneIKSettings_t->TargetBoneIndex(ptr=%p)", m_ptr));
    return GetSchemaValue<int32_t>(m_ptr, "TwoBoneIKSettings_t", "m_targetBoneIndex");
}
void GTwoBoneIKSettings_t::SetTargetBoneIndex(int32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: TwoBoneIKSettings_t->TargetBoneIndex(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "TwoBoneIKSettings_t", "m_targetBoneIndex", true, value);
}
GCAnimParamHandle GTwoBoneIKSettings_t::GetPositionParam() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: TwoBoneIKSettings_t->PositionParam(ptr=%p)", m_ptr));
    GCAnimParamHandle value(GetSchemaPtr(m_ptr, "TwoBoneIKSettings_t", "m_hPositionParam"));
    return value;
}
void GTwoBoneIKSettings_t::SetPositionParam(GCAnimParamHandle value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: TwoBoneIKSettings_t->PositionParam(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'PositionParam' is not possible.\n");
}
GCAnimParamHandle GTwoBoneIKSettings_t::GetRotationParam() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: TwoBoneIKSettings_t->RotationParam(ptr=%p)", m_ptr));
    GCAnimParamHandle value(GetSchemaPtr(m_ptr, "TwoBoneIKSettings_t", "m_hRotationParam"));
    return value;
}
void GTwoBoneIKSettings_t::SetRotationParam(GCAnimParamHandle value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: TwoBoneIKSettings_t->RotationParam(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'RotationParam' is not possible.\n");
}
bool GTwoBoneIKSettings_t::GetAlwaysUseFallbackHinge() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: TwoBoneIKSettings_t->AlwaysUseFallbackHinge(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "TwoBoneIKSettings_t", "m_bAlwaysUseFallbackHinge");
}
void GTwoBoneIKSettings_t::SetAlwaysUseFallbackHinge(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: TwoBoneIKSettings_t->AlwaysUseFallbackHinge(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "TwoBoneIKSettings_t", "m_bAlwaysUseFallbackHinge", true, value);
}
Vector GTwoBoneIKSettings_t::GetLsFallbackHingeAxis() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: TwoBoneIKSettings_t->LsFallbackHingeAxis(ptr=%p)", m_ptr));
    return GetSchemaValue<Vector>(m_ptr, "TwoBoneIKSettings_t", "m_vLsFallbackHingeAxis");
}
void GTwoBoneIKSettings_t::SetLsFallbackHingeAxis(Vector value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: TwoBoneIKSettings_t->LsFallbackHingeAxis(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "TwoBoneIKSettings_t", "m_vLsFallbackHingeAxis", true, value);
}
int32_t GTwoBoneIKSettings_t::GetFixedBoneIndex() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: TwoBoneIKSettings_t->FixedBoneIndex(ptr=%p)", m_ptr));
    return GetSchemaValue<int32_t>(m_ptr, "TwoBoneIKSettings_t", "m_nFixedBoneIndex");
}
void GTwoBoneIKSettings_t::SetFixedBoneIndex(int32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: TwoBoneIKSettings_t->FixedBoneIndex(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "TwoBoneIKSettings_t", "m_nFixedBoneIndex", true, value);
}
int32_t GTwoBoneIKSettings_t::GetMiddleBoneIndex() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: TwoBoneIKSettings_t->MiddleBoneIndex(ptr=%p)", m_ptr));
    return GetSchemaValue<int32_t>(m_ptr, "TwoBoneIKSettings_t", "m_nMiddleBoneIndex");
}
void GTwoBoneIKSettings_t::SetMiddleBoneIndex(int32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: TwoBoneIKSettings_t->MiddleBoneIndex(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "TwoBoneIKSettings_t", "m_nMiddleBoneIndex", true, value);
}
int32_t GTwoBoneIKSettings_t::GetEndBoneIndex() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: TwoBoneIKSettings_t->EndBoneIndex(ptr=%p)", m_ptr));
    return GetSchemaValue<int32_t>(m_ptr, "TwoBoneIKSettings_t", "m_nEndBoneIndex");
}
void GTwoBoneIKSettings_t::SetEndBoneIndex(int32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: TwoBoneIKSettings_t->EndBoneIndex(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "TwoBoneIKSettings_t", "m_nEndBoneIndex", true, value);
}
bool GTwoBoneIKSettings_t::GetMatchTargetOrientation() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: TwoBoneIKSettings_t->MatchTargetOrientation(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "TwoBoneIKSettings_t", "m_bMatchTargetOrientation");
}
void GTwoBoneIKSettings_t::SetMatchTargetOrientation(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: TwoBoneIKSettings_t->MatchTargetOrientation(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "TwoBoneIKSettings_t", "m_bMatchTargetOrientation", true, value);
}
bool GTwoBoneIKSettings_t::GetConstrainTwist() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: TwoBoneIKSettings_t->ConstrainTwist(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "TwoBoneIKSettings_t", "m_bConstrainTwist");
}
void GTwoBoneIKSettings_t::SetConstrainTwist(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: TwoBoneIKSettings_t->ConstrainTwist(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "TwoBoneIKSettings_t", "m_bConstrainTwist", true, value);
}
float GTwoBoneIKSettings_t::GetMaxTwist() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: TwoBoneIKSettings_t->MaxTwist(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "TwoBoneIKSettings_t", "m_flMaxTwist");
}
void GTwoBoneIKSettings_t::SetMaxTwist(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: TwoBoneIKSettings_t->MaxTwist(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "TwoBoneIKSettings_t", "m_flMaxTwist", true, value);
}
void* GTwoBoneIKSettings_t::GetPtr() {
    return m_ptr;
}
std::string GTwoBoneIKSettings_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GTwoBoneIKSettings_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassTwoBoneIKSettings_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GTwoBoneIKSettings_t>("TwoBoneIKSettings_t")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("EndEffectorType", &GTwoBoneIKSettings_t::GetEndEffectorType, &GTwoBoneIKSettings_t::SetEndEffectorType)
        .addProperty("EndEffectorAttachment", &GTwoBoneIKSettings_t::GetEndEffectorAttachment, &GTwoBoneIKSettings_t::SetEndEffectorAttachment)
        .addProperty("TargetType", &GTwoBoneIKSettings_t::GetTargetType, &GTwoBoneIKSettings_t::SetTargetType)
        .addProperty("TargetAttachment", &GTwoBoneIKSettings_t::GetTargetAttachment, &GTwoBoneIKSettings_t::SetTargetAttachment)
        .addProperty("TargetBoneIndex", &GTwoBoneIKSettings_t::GetTargetBoneIndex, &GTwoBoneIKSettings_t::SetTargetBoneIndex)
        .addProperty("PositionParam", &GTwoBoneIKSettings_t::GetPositionParam, &GTwoBoneIKSettings_t::SetPositionParam)
        .addProperty("RotationParam", &GTwoBoneIKSettings_t::GetRotationParam, &GTwoBoneIKSettings_t::SetRotationParam)
        .addProperty("AlwaysUseFallbackHinge", &GTwoBoneIKSettings_t::GetAlwaysUseFallbackHinge, &GTwoBoneIKSettings_t::SetAlwaysUseFallbackHinge)
        .addProperty("LsFallbackHingeAxis", &GTwoBoneIKSettings_t::GetLsFallbackHingeAxis, &GTwoBoneIKSettings_t::SetLsFallbackHingeAxis)
        .addProperty("FixedBoneIndex", &GTwoBoneIKSettings_t::GetFixedBoneIndex, &GTwoBoneIKSettings_t::SetFixedBoneIndex)
        .addProperty("MiddleBoneIndex", &GTwoBoneIKSettings_t::GetMiddleBoneIndex, &GTwoBoneIKSettings_t::SetMiddleBoneIndex)
        .addProperty("EndBoneIndex", &GTwoBoneIKSettings_t::GetEndBoneIndex, &GTwoBoneIKSettings_t::SetEndBoneIndex)
        .addProperty("MatchTargetOrientation", &GTwoBoneIKSettings_t::GetMatchTargetOrientation, &GTwoBoneIKSettings_t::SetMatchTargetOrientation)
        .addProperty("ConstrainTwist", &GTwoBoneIKSettings_t::GetConstrainTwist, &GTwoBoneIKSettings_t::SetConstrainTwist)
        .addProperty("MaxTwist", &GTwoBoneIKSettings_t::GetMaxTwist, &GTwoBoneIKSettings_t::SetMaxTwist)
        .addFunction("ToPtr", &GTwoBoneIKSettings_t::ToPtr)
        .addFunction("IsValid", &GTwoBoneIKSettings_t::IsValid)
        .endClass();
}
GCompositeMaterialInputContainer_t::GCompositeMaterialInputContainer_t(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCompositeMaterialInputContainer_t::GCompositeMaterialInputContainer_t(void *ptr) {
    m_ptr = ptr;
}
bool GCompositeMaterialInputContainer_t::GetEnabled() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CompositeMaterialInputContainer_t->Enabled(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "CompositeMaterialInputContainer_t", "m_bEnabled");
}
void GCompositeMaterialInputContainer_t::SetEnabled(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CompositeMaterialInputContainer_t->Enabled(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CompositeMaterialInputContainer_t", "m_bEnabled", true, value);
}
uint64_t GCompositeMaterialInputContainer_t::GetCompositeMaterialInputContainerSourceType() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CompositeMaterialInputContainer_t->CompositeMaterialInputContainerSourceType(ptr=%p)", m_ptr));
    return GetSchemaValue<uint64_t>(m_ptr, "CompositeMaterialInputContainer_t", "m_nCompositeMaterialInputContainerSourceType");
}
void GCompositeMaterialInputContainer_t::SetCompositeMaterialInputContainerSourceType(uint64_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CompositeMaterialInputContainer_t->CompositeMaterialInputContainerSourceType(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CompositeMaterialInputContainer_t", "m_nCompositeMaterialInputContainerSourceType", true, value);
}
std::string GCompositeMaterialInputContainer_t::GetStrAttrName() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CompositeMaterialInputContainer_t->StrAttrName(ptr=%p)", m_ptr));
    return GetSchemaValue<CUtlString>(m_ptr, "CompositeMaterialInputContainer_t", "m_strAttrName").Get();
}
void GCompositeMaterialInputContainer_t::SetStrAttrName(std::string value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CompositeMaterialInputContainer_t->StrAttrName(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CompositeMaterialInputContainer_t", "m_strAttrName", true, CUtlString(value.c_str()));
}
std::string GCompositeMaterialInputContainer_t::GetStrAlias() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CompositeMaterialInputContainer_t->StrAlias(ptr=%p)", m_ptr));
    return GetSchemaValue<CUtlString>(m_ptr, "CompositeMaterialInputContainer_t", "m_strAlias").Get();
}
void GCompositeMaterialInputContainer_t::SetStrAlias(std::string value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CompositeMaterialInputContainer_t->StrAlias(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CompositeMaterialInputContainer_t", "m_strAlias", true, CUtlString(value.c_str()));
}
std::vector<GCompositeMaterialInputLooseVariable_t> GCompositeMaterialInputContainer_t::GetLooseVariables() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CompositeMaterialInputContainer_t->LooseVariables(ptr=%p)", m_ptr));
    CUtlVector<GCompositeMaterialInputLooseVariable_t>* vec = GetSchemaValue<CUtlVector<GCompositeMaterialInputLooseVariable_t>*>(m_ptr, "CompositeMaterialInputContainer_t", "m_vecLooseVariables"); std::vector<GCompositeMaterialInputLooseVariable_t> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCompositeMaterialInputContainer_t::SetLooseVariables(std::vector<GCompositeMaterialInputLooseVariable_t> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CompositeMaterialInputContainer_t->LooseVariables(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<GCompositeMaterialInputLooseVariable_t>(m_ptr, "CompositeMaterialInputContainer_t", "m_vecLooseVariables", true, value);
}
std::string GCompositeMaterialInputContainer_t::GetStrAttrNameForVar() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CompositeMaterialInputContainer_t->StrAttrNameForVar(ptr=%p)", m_ptr));
    return GetSchemaValue<CUtlString>(m_ptr, "CompositeMaterialInputContainer_t", "m_strAttrNameForVar").Get();
}
void GCompositeMaterialInputContainer_t::SetStrAttrNameForVar(std::string value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CompositeMaterialInputContainer_t->StrAttrNameForVar(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CompositeMaterialInputContainer_t", "m_strAttrNameForVar", true, CUtlString(value.c_str()));
}
bool GCompositeMaterialInputContainer_t::GetExposeExternally() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CompositeMaterialInputContainer_t->ExposeExternally(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "CompositeMaterialInputContainer_t", "m_bExposeExternally");
}
void GCompositeMaterialInputContainer_t::SetExposeExternally(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CompositeMaterialInputContainer_t->ExposeExternally(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CompositeMaterialInputContainer_t", "m_bExposeExternally", true, value);
}
void* GCompositeMaterialInputContainer_t::GetPtr() {
    return m_ptr;
}
std::string GCompositeMaterialInputContainer_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCompositeMaterialInputContainer_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCompositeMaterialInputContainer_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCompositeMaterialInputContainer_t>("CompositeMaterialInputContainer_t")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Enabled", &GCompositeMaterialInputContainer_t::GetEnabled, &GCompositeMaterialInputContainer_t::SetEnabled)
        .addProperty("CompositeMaterialInputContainerSourceType", &GCompositeMaterialInputContainer_t::GetCompositeMaterialInputContainerSourceType, &GCompositeMaterialInputContainer_t::SetCompositeMaterialInputContainerSourceType)
        .addProperty("StrAttrName", &GCompositeMaterialInputContainer_t::GetStrAttrName, &GCompositeMaterialInputContainer_t::SetStrAttrName)
        .addProperty("StrAlias", &GCompositeMaterialInputContainer_t::GetStrAlias, &GCompositeMaterialInputContainer_t::SetStrAlias)
        .addProperty("LooseVariables", &GCompositeMaterialInputContainer_t::GetLooseVariables, &GCompositeMaterialInputContainer_t::SetLooseVariables)
        .addProperty("StrAttrNameForVar", &GCompositeMaterialInputContainer_t::GetStrAttrNameForVar, &GCompositeMaterialInputContainer_t::SetStrAttrNameForVar)
        .addProperty("ExposeExternally", &GCompositeMaterialInputContainer_t::GetExposeExternally, &GCompositeMaterialInputContainer_t::SetExposeExternally)
        .addFunction("ToPtr", &GCompositeMaterialInputContainer_t::ToPtr)
        .addFunction("IsValid", &GCompositeMaterialInputContainer_t::IsValid)
        .endClass();
}
GCStateNodeStateData::GCStateNodeStateData(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCStateNodeStateData::GCStateNodeStateData(void *ptr) {
    m_ptr = ptr;
}
GCAnimUpdateNodeRef GCStateNodeStateData::GetChild() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CStateNodeStateData->Child(ptr=%p)", m_ptr));
    GCAnimUpdateNodeRef value(GetSchemaPtr(m_ptr, "CStateNodeStateData", "m_pChild"));
    return value;
}
void GCStateNodeStateData::SetChild(GCAnimUpdateNodeRef value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CStateNodeStateData->Child(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Child' is not possible.\n");
}
void* GCStateNodeStateData::GetPtr() {
    return m_ptr;
}
std::string GCStateNodeStateData::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCStateNodeStateData::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCStateNodeStateData(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCStateNodeStateData>("CStateNodeStateData")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Child", &GCStateNodeStateData::GetChild, &GCStateNodeStateData::SetChild)
        .addFunction("ToPtr", &GCStateNodeStateData::ToPtr)
        .addFunction("IsValid", &GCStateNodeStateData::IsValid)
        .endClass();
}
GFeTwistConstraint_t::GFeTwistConstraint_t(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GFeTwistConstraint_t::GFeTwistConstraint_t(void *ptr) {
    m_ptr = ptr;
}
uint16_t GFeTwistConstraint_t::GetNodeOrient() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FeTwistConstraint_t->NodeOrient(ptr=%p)", m_ptr));
    return GetSchemaValue<uint16_t>(m_ptr, "FeTwistConstraint_t", "nNodeOrient");
}
void GFeTwistConstraint_t::SetNodeOrient(uint16_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FeTwistConstraint_t->NodeOrient(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "FeTwistConstraint_t", "nNodeOrient", true, value);
}
uint16_t GFeTwistConstraint_t::GetNodeEnd() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FeTwistConstraint_t->NodeEnd(ptr=%p)", m_ptr));
    return GetSchemaValue<uint16_t>(m_ptr, "FeTwistConstraint_t", "nNodeEnd");
}
void GFeTwistConstraint_t::SetNodeEnd(uint16_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FeTwistConstraint_t->NodeEnd(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "FeTwistConstraint_t", "nNodeEnd", true, value);
}
float GFeTwistConstraint_t::GetTwistRelax() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FeTwistConstraint_t->TwistRelax(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "FeTwistConstraint_t", "flTwistRelax");
}
void GFeTwistConstraint_t::SetTwistRelax(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FeTwistConstraint_t->TwistRelax(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "FeTwistConstraint_t", "flTwistRelax", true, value);
}
float GFeTwistConstraint_t::GetSwingRelax() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FeTwistConstraint_t->SwingRelax(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "FeTwistConstraint_t", "flSwingRelax");
}
void GFeTwistConstraint_t::SetSwingRelax(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FeTwistConstraint_t->SwingRelax(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "FeTwistConstraint_t", "flSwingRelax", true, value);
}
void* GFeTwistConstraint_t::GetPtr() {
    return m_ptr;
}
std::string GFeTwistConstraint_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GFeTwistConstraint_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassFeTwistConstraint_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GFeTwistConstraint_t>("FeTwistConstraint_t")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("NodeOrient", &GFeTwistConstraint_t::GetNodeOrient, &GFeTwistConstraint_t::SetNodeOrient)
        .addProperty("NodeEnd", &GFeTwistConstraint_t::GetNodeEnd, &GFeTwistConstraint_t::SetNodeEnd)
        .addProperty("TwistRelax", &GFeTwistConstraint_t::GetTwistRelax, &GFeTwistConstraint_t::SetTwistRelax)
        .addProperty("SwingRelax", &GFeTwistConstraint_t::GetSwingRelax, &GFeTwistConstraint_t::SetSwingRelax)
        .addFunction("ToPtr", &GFeTwistConstraint_t::ToPtr)
        .addFunction("IsValid", &GFeTwistConstraint_t::IsValid)
        .endClass();
}
GFootFixedData_t::GFootFixedData_t(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GFootFixedData_t::GFootFixedData_t(void *ptr) {
    m_ptr = ptr;
}
Vector GFootFixedData_t::GetToeOffset() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FootFixedData_t->ToeOffset(ptr=%p)", m_ptr));
    return GetSchemaValue<Vector>(m_ptr, "FootFixedData_t", "m_vToeOffset");
}
void GFootFixedData_t::SetToeOffset(Vector value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FootFixedData_t->ToeOffset(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "FootFixedData_t", "m_vToeOffset", true, value);
}
Vector GFootFixedData_t::GetHeelOffset() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FootFixedData_t->HeelOffset(ptr=%p)", m_ptr));
    return GetSchemaValue<Vector>(m_ptr, "FootFixedData_t", "m_vHeelOffset");
}
void GFootFixedData_t::SetHeelOffset(Vector value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FootFixedData_t->HeelOffset(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "FootFixedData_t", "m_vHeelOffset", true, value);
}
int32_t GFootFixedData_t::GetTargetBoneIndex() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FootFixedData_t->TargetBoneIndex(ptr=%p)", m_ptr));
    return GetSchemaValue<int32_t>(m_ptr, "FootFixedData_t", "m_nTargetBoneIndex");
}
void GFootFixedData_t::SetTargetBoneIndex(int32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FootFixedData_t->TargetBoneIndex(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "FootFixedData_t", "m_nTargetBoneIndex", true, value);
}
int32_t GFootFixedData_t::GetAnkleBoneIndex() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FootFixedData_t->AnkleBoneIndex(ptr=%p)", m_ptr));
    return GetSchemaValue<int32_t>(m_ptr, "FootFixedData_t", "m_nAnkleBoneIndex");
}
void GFootFixedData_t::SetAnkleBoneIndex(int32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FootFixedData_t->AnkleBoneIndex(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "FootFixedData_t", "m_nAnkleBoneIndex", true, value);
}
int32_t GFootFixedData_t::GetIKAnchorBoneIndex() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FootFixedData_t->IKAnchorBoneIndex(ptr=%p)", m_ptr));
    return GetSchemaValue<int32_t>(m_ptr, "FootFixedData_t", "m_nIKAnchorBoneIndex");
}
void GFootFixedData_t::SetIKAnchorBoneIndex(int32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FootFixedData_t->IKAnchorBoneIndex(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "FootFixedData_t", "m_nIKAnchorBoneIndex", true, value);
}
int32_t GFootFixedData_t::GetIkChainIndex() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FootFixedData_t->IkChainIndex(ptr=%p)", m_ptr));
    return GetSchemaValue<int32_t>(m_ptr, "FootFixedData_t", "m_ikChainIndex");
}
void GFootFixedData_t::SetIkChainIndex(int32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FootFixedData_t->IkChainIndex(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "FootFixedData_t", "m_ikChainIndex", true, value);
}
float GFootFixedData_t::GetMaxIKLength() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FootFixedData_t->MaxIKLength(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "FootFixedData_t", "m_flMaxIKLength");
}
void GFootFixedData_t::SetMaxIKLength(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FootFixedData_t->MaxIKLength(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "FootFixedData_t", "m_flMaxIKLength", true, value);
}
int32_t GFootFixedData_t::GetFootIndex() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FootFixedData_t->FootIndex(ptr=%p)", m_ptr));
    return GetSchemaValue<int32_t>(m_ptr, "FootFixedData_t", "m_nFootIndex");
}
void GFootFixedData_t::SetFootIndex(int32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FootFixedData_t->FootIndex(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "FootFixedData_t", "m_nFootIndex", true, value);
}
int32_t GFootFixedData_t::GetTagIndex() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FootFixedData_t->TagIndex(ptr=%p)", m_ptr));
    return GetSchemaValue<int32_t>(m_ptr, "FootFixedData_t", "m_nTagIndex");
}
void GFootFixedData_t::SetTagIndex(int32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FootFixedData_t->TagIndex(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "FootFixedData_t", "m_nTagIndex", true, value);
}
float GFootFixedData_t::GetMaxRotationLeft() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FootFixedData_t->MaxRotationLeft(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "FootFixedData_t", "m_flMaxRotationLeft");
}
void GFootFixedData_t::SetMaxRotationLeft(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FootFixedData_t->MaxRotationLeft(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "FootFixedData_t", "m_flMaxRotationLeft", true, value);
}
float GFootFixedData_t::GetMaxRotationRight() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FootFixedData_t->MaxRotationRight(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "FootFixedData_t", "m_flMaxRotationRight");
}
void GFootFixedData_t::SetMaxRotationRight(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FootFixedData_t->MaxRotationRight(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "FootFixedData_t", "m_flMaxRotationRight", true, value);
}
void* GFootFixedData_t::GetPtr() {
    return m_ptr;
}
std::string GFootFixedData_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GFootFixedData_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassFootFixedData_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GFootFixedData_t>("FootFixedData_t")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("ToeOffset", &GFootFixedData_t::GetToeOffset, &GFootFixedData_t::SetToeOffset)
        .addProperty("HeelOffset", &GFootFixedData_t::GetHeelOffset, &GFootFixedData_t::SetHeelOffset)
        .addProperty("TargetBoneIndex", &GFootFixedData_t::GetTargetBoneIndex, &GFootFixedData_t::SetTargetBoneIndex)
        .addProperty("AnkleBoneIndex", &GFootFixedData_t::GetAnkleBoneIndex, &GFootFixedData_t::SetAnkleBoneIndex)
        .addProperty("IKAnchorBoneIndex", &GFootFixedData_t::GetIKAnchorBoneIndex, &GFootFixedData_t::SetIKAnchorBoneIndex)
        .addProperty("IkChainIndex", &GFootFixedData_t::GetIkChainIndex, &GFootFixedData_t::SetIkChainIndex)
        .addProperty("MaxIKLength", &GFootFixedData_t::GetMaxIKLength, &GFootFixedData_t::SetMaxIKLength)
        .addProperty("FootIndex", &GFootFixedData_t::GetFootIndex, &GFootFixedData_t::SetFootIndex)
        .addProperty("TagIndex", &GFootFixedData_t::GetTagIndex, &GFootFixedData_t::SetTagIndex)
        .addProperty("MaxRotationLeft", &GFootFixedData_t::GetMaxRotationLeft, &GFootFixedData_t::SetMaxRotationLeft)
        .addProperty("MaxRotationRight", &GFootFixedData_t::GetMaxRotationRight, &GFootFixedData_t::SetMaxRotationRight)
        .addFunction("ToPtr", &GFootFixedData_t::ToPtr)
        .addFunction("IsValid", &GFootFixedData_t::IsValid)
        .endClass();
}
GVMixDiffusorDesc_t::GVMixDiffusorDesc_t(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GVMixDiffusorDesc_t::GVMixDiffusorDesc_t(void *ptr) {
    m_ptr = ptr;
}
float GVMixDiffusorDesc_t::GetSize() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: VMixDiffusorDesc_t->Size(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "VMixDiffusorDesc_t", "m_flSize");
}
void GVMixDiffusorDesc_t::SetSize(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: VMixDiffusorDesc_t->Size(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "VMixDiffusorDesc_t", "m_flSize", true, value);
}
float GVMixDiffusorDesc_t::GetComplexity() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: VMixDiffusorDesc_t->Complexity(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "VMixDiffusorDesc_t", "m_flComplexity");
}
void GVMixDiffusorDesc_t::SetComplexity(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: VMixDiffusorDesc_t->Complexity(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "VMixDiffusorDesc_t", "m_flComplexity", true, value);
}
float GVMixDiffusorDesc_t::GetFeedback() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: VMixDiffusorDesc_t->Feedback(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "VMixDiffusorDesc_t", "m_flFeedback");
}
void GVMixDiffusorDesc_t::SetFeedback(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: VMixDiffusorDesc_t->Feedback(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "VMixDiffusorDesc_t", "m_flFeedback", true, value);
}
float GVMixDiffusorDesc_t::GetOutputGain() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: VMixDiffusorDesc_t->OutputGain(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "VMixDiffusorDesc_t", "m_flOutputGain");
}
void GVMixDiffusorDesc_t::SetOutputGain(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: VMixDiffusorDesc_t->OutputGain(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "VMixDiffusorDesc_t", "m_flOutputGain", true, value);
}
void* GVMixDiffusorDesc_t::GetPtr() {
    return m_ptr;
}
std::string GVMixDiffusorDesc_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GVMixDiffusorDesc_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassVMixDiffusorDesc_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GVMixDiffusorDesc_t>("VMixDiffusorDesc_t")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Size", &GVMixDiffusorDesc_t::GetSize, &GVMixDiffusorDesc_t::SetSize)
        .addProperty("Complexity", &GVMixDiffusorDesc_t::GetComplexity, &GVMixDiffusorDesc_t::SetComplexity)
        .addProperty("Feedback", &GVMixDiffusorDesc_t::GetFeedback, &GVMixDiffusorDesc_t::SetFeedback)
        .addProperty("OutputGain", &GVMixDiffusorDesc_t::GetOutputGain, &GVMixDiffusorDesc_t::SetOutputGain)
        .addFunction("ToPtr", &GVMixDiffusorDesc_t::ToPtr)
        .addFunction("IsValid", &GVMixDiffusorDesc_t::IsValid)
        .endClass();
}
GFeProxyVertexMap_t::GFeProxyVertexMap_t(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GFeProxyVertexMap_t::GFeProxyVertexMap_t(void *ptr) {
    m_ptr = ptr;
}
std::string GFeProxyVertexMap_t::GetName() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FeProxyVertexMap_t->Name(ptr=%p)", m_ptr));
    return GetSchemaValue<CUtlString>(m_ptr, "FeProxyVertexMap_t", "m_Name").Get();
}
void GFeProxyVertexMap_t::SetName(std::string value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FeProxyVertexMap_t->Name(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "FeProxyVertexMap_t", "m_Name", true, CUtlString(value.c_str()));
}
float GFeProxyVertexMap_t::GetWeight() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FeProxyVertexMap_t->Weight(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "FeProxyVertexMap_t", "m_flWeight");
}
void GFeProxyVertexMap_t::SetWeight(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FeProxyVertexMap_t->Weight(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "FeProxyVertexMap_t", "m_flWeight", true, value);
}
void* GFeProxyVertexMap_t::GetPtr() {
    return m_ptr;
}
std::string GFeProxyVertexMap_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GFeProxyVertexMap_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassFeProxyVertexMap_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GFeProxyVertexMap_t>("FeProxyVertexMap_t")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Name", &GFeProxyVertexMap_t::GetName, &GFeProxyVertexMap_t::SetName)
        .addProperty("Weight", &GFeProxyVertexMap_t::GetWeight, &GFeProxyVertexMap_t::SetWeight)
        .addFunction("ToPtr", &GFeProxyVertexMap_t::ToPtr)
        .addFunction("IsValid", &GFeProxyVertexMap_t::IsValid)
        .endClass();
}
GCDirectPlaybackUpdateNode::GCDirectPlaybackUpdateNode(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCDirectPlaybackUpdateNode::GCDirectPlaybackUpdateNode(void *ptr) {
    m_ptr = ptr;
}
bool GCDirectPlaybackUpdateNode::GetFinishEarly() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CDirectPlaybackUpdateNode->FinishEarly(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "CDirectPlaybackUpdateNode", "m_bFinishEarly");
}
void GCDirectPlaybackUpdateNode::SetFinishEarly(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CDirectPlaybackUpdateNode->FinishEarly(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CDirectPlaybackUpdateNode", "m_bFinishEarly", false, value);
}
bool GCDirectPlaybackUpdateNode::GetResetOnFinish() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CDirectPlaybackUpdateNode->ResetOnFinish(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "CDirectPlaybackUpdateNode", "m_bResetOnFinish");
}
void GCDirectPlaybackUpdateNode::SetResetOnFinish(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CDirectPlaybackUpdateNode->ResetOnFinish(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CDirectPlaybackUpdateNode", "m_bResetOnFinish", false, value);
}
std::vector<GCDirectPlaybackTagData> GCDirectPlaybackUpdateNode::GetAllTags() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CDirectPlaybackUpdateNode->AllTags(ptr=%p)", m_ptr));
    CUtlVector<GCDirectPlaybackTagData>* vec = GetSchemaValue<CUtlVector<GCDirectPlaybackTagData>*>(m_ptr, "CDirectPlaybackUpdateNode", "m_allTags"); std::vector<GCDirectPlaybackTagData> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCDirectPlaybackUpdateNode::SetAllTags(std::vector<GCDirectPlaybackTagData> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CDirectPlaybackUpdateNode->AllTags(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<GCDirectPlaybackTagData>(m_ptr, "CDirectPlaybackUpdateNode", "m_allTags", false, value);
}
void* GCDirectPlaybackUpdateNode::GetPtr() {
    return m_ptr;
}
std::string GCDirectPlaybackUpdateNode::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCDirectPlaybackUpdateNode::IsValid() {
    return (m_ptr != nullptr);
}
GCUnaryUpdateNode GCDirectPlaybackUpdateNode::GetParent() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CDirectPlaybackUpdateNode::GetParent(ptr=%p)", m_ptr));
    GCUnaryUpdateNode value(m_ptr);
    return value;
}
void GCDirectPlaybackUpdateNode::SetParent(GCUnaryUpdateNode value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CDirectPlaybackUpdateNode::SetParent(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCDirectPlaybackUpdateNode(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCDirectPlaybackUpdateNode>("CDirectPlaybackUpdateNode")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("FinishEarly", &GCDirectPlaybackUpdateNode::GetFinishEarly, &GCDirectPlaybackUpdateNode::SetFinishEarly)
        .addProperty("ResetOnFinish", &GCDirectPlaybackUpdateNode::GetResetOnFinish, &GCDirectPlaybackUpdateNode::SetResetOnFinish)
        .addProperty("AllTags", &GCDirectPlaybackUpdateNode::GetAllTags, &GCDirectPlaybackUpdateNode::SetAllTags)
        .addProperty("Parent", &GCDirectPlaybackUpdateNode::GetParent, &GCDirectPlaybackUpdateNode::SetParent)
        .addFunction("ToPtr", &GCDirectPlaybackUpdateNode::ToPtr)
        .addFunction("IsValid", &GCDirectPlaybackUpdateNode::IsValid)
        .endClass();
}
GPostProcessingLocalContrastParameters_t::GPostProcessingLocalContrastParameters_t(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GPostProcessingLocalContrastParameters_t::GPostProcessingLocalContrastParameters_t(void *ptr) {
    m_ptr = ptr;
}
float GPostProcessingLocalContrastParameters_t::GetLocalContrastStrength() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: PostProcessingLocalContrastParameters_t->LocalContrastStrength(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "PostProcessingLocalContrastParameters_t", "m_flLocalContrastStrength");
}
void GPostProcessingLocalContrastParameters_t::SetLocalContrastStrength(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: PostProcessingLocalContrastParameters_t->LocalContrastStrength(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "PostProcessingLocalContrastParameters_t", "m_flLocalContrastStrength", true, value);
}
float GPostProcessingLocalContrastParameters_t::GetLocalContrastEdgeStrength() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: PostProcessingLocalContrastParameters_t->LocalContrastEdgeStrength(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "PostProcessingLocalContrastParameters_t", "m_flLocalContrastEdgeStrength");
}
void GPostProcessingLocalContrastParameters_t::SetLocalContrastEdgeStrength(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: PostProcessingLocalContrastParameters_t->LocalContrastEdgeStrength(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "PostProcessingLocalContrastParameters_t", "m_flLocalContrastEdgeStrength", true, value);
}
float GPostProcessingLocalContrastParameters_t::GetLocalContrastVignetteStart() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: PostProcessingLocalContrastParameters_t->LocalContrastVignetteStart(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "PostProcessingLocalContrastParameters_t", "m_flLocalContrastVignetteStart");
}
void GPostProcessingLocalContrastParameters_t::SetLocalContrastVignetteStart(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: PostProcessingLocalContrastParameters_t->LocalContrastVignetteStart(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "PostProcessingLocalContrastParameters_t", "m_flLocalContrastVignetteStart", true, value);
}
float GPostProcessingLocalContrastParameters_t::GetLocalContrastVignetteEnd() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: PostProcessingLocalContrastParameters_t->LocalContrastVignetteEnd(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "PostProcessingLocalContrastParameters_t", "m_flLocalContrastVignetteEnd");
}
void GPostProcessingLocalContrastParameters_t::SetLocalContrastVignetteEnd(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: PostProcessingLocalContrastParameters_t->LocalContrastVignetteEnd(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "PostProcessingLocalContrastParameters_t", "m_flLocalContrastVignetteEnd", true, value);
}
float GPostProcessingLocalContrastParameters_t::GetLocalContrastVignetteBlur() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: PostProcessingLocalContrastParameters_t->LocalContrastVignetteBlur(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "PostProcessingLocalContrastParameters_t", "m_flLocalContrastVignetteBlur");
}
void GPostProcessingLocalContrastParameters_t::SetLocalContrastVignetteBlur(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: PostProcessingLocalContrastParameters_t->LocalContrastVignetteBlur(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "PostProcessingLocalContrastParameters_t", "m_flLocalContrastVignetteBlur", true, value);
}
void* GPostProcessingLocalContrastParameters_t::GetPtr() {
    return m_ptr;
}
std::string GPostProcessingLocalContrastParameters_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GPostProcessingLocalContrastParameters_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassPostProcessingLocalContrastParameters_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GPostProcessingLocalContrastParameters_t>("PostProcessingLocalContrastParameters_t")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("LocalContrastStrength", &GPostProcessingLocalContrastParameters_t::GetLocalContrastStrength, &GPostProcessingLocalContrastParameters_t::SetLocalContrastStrength)
        .addProperty("LocalContrastEdgeStrength", &GPostProcessingLocalContrastParameters_t::GetLocalContrastEdgeStrength, &GPostProcessingLocalContrastParameters_t::SetLocalContrastEdgeStrength)
        .addProperty("LocalContrastVignetteStart", &GPostProcessingLocalContrastParameters_t::GetLocalContrastVignetteStart, &GPostProcessingLocalContrastParameters_t::SetLocalContrastVignetteStart)
        .addProperty("LocalContrastVignetteEnd", &GPostProcessingLocalContrastParameters_t::GetLocalContrastVignetteEnd, &GPostProcessingLocalContrastParameters_t::SetLocalContrastVignetteEnd)
        .addProperty("LocalContrastVignetteBlur", &GPostProcessingLocalContrastParameters_t::GetLocalContrastVignetteBlur, &GPostProcessingLocalContrastParameters_t::SetLocalContrastVignetteBlur)
        .addFunction("ToPtr", &GPostProcessingLocalContrastParameters_t::ToPtr)
        .addFunction("IsValid", &GPostProcessingLocalContrastParameters_t::IsValid)
        .endClass();
}
GCFootLockUpdateNode::GCFootLockUpdateNode(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCFootLockUpdateNode::GCFootLockUpdateNode(void *ptr) {
    m_ptr = ptr;
}
GFootLockPoseOpFixedSettings GCFootLockUpdateNode::GetOpFixedSettings() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CFootLockUpdateNode->OpFixedSettings(ptr=%p)", m_ptr));
    GFootLockPoseOpFixedSettings value(GetSchemaPtr(m_ptr, "CFootLockUpdateNode", "m_opFixedSettings"));
    return value;
}
void GCFootLockUpdateNode::SetOpFixedSettings(GFootLockPoseOpFixedSettings value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CFootLockUpdateNode->OpFixedSettings(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'OpFixedSettings' is not possible.\n");
}
std::vector<GFootFixedSettings> GCFootLockUpdateNode::GetFootSettings() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CFootLockUpdateNode->FootSettings(ptr=%p)", m_ptr));
    CUtlVector<GFootFixedSettings>* vec = GetSchemaValue<CUtlVector<GFootFixedSettings>*>(m_ptr, "CFootLockUpdateNode", "m_footSettings"); std::vector<GFootFixedSettings> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCFootLockUpdateNode::SetFootSettings(std::vector<GFootFixedSettings> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CFootLockUpdateNode->FootSettings(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<GFootFixedSettings>(m_ptr, "CFootLockUpdateNode", "m_footSettings", false, value);
}
GCAnimInputDamping GCFootLockUpdateNode::GetHipShiftDamping() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CFootLockUpdateNode->HipShiftDamping(ptr=%p)", m_ptr));
    GCAnimInputDamping value(GetSchemaPtr(m_ptr, "CFootLockUpdateNode", "m_hipShiftDamping"));
    return value;
}
void GCFootLockUpdateNode::SetHipShiftDamping(GCAnimInputDamping value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CFootLockUpdateNode->HipShiftDamping(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'HipShiftDamping' is not possible.\n");
}
GCAnimInputDamping GCFootLockUpdateNode::GetRootHeightDamping() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CFootLockUpdateNode->RootHeightDamping(ptr=%p)", m_ptr));
    GCAnimInputDamping value(GetSchemaPtr(m_ptr, "CFootLockUpdateNode", "m_rootHeightDamping"));
    return value;
}
void GCFootLockUpdateNode::SetRootHeightDamping(GCAnimInputDamping value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CFootLockUpdateNode->RootHeightDamping(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'RootHeightDamping' is not possible.\n");
}
float GCFootLockUpdateNode::GetStrideCurveScale() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CFootLockUpdateNode->StrideCurveScale(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CFootLockUpdateNode", "m_flStrideCurveScale");
}
void GCFootLockUpdateNode::SetStrideCurveScale(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CFootLockUpdateNode->StrideCurveScale(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CFootLockUpdateNode", "m_flStrideCurveScale", false, value);
}
float GCFootLockUpdateNode::GetStrideCurveLimitScale() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CFootLockUpdateNode->StrideCurveLimitScale(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CFootLockUpdateNode", "m_flStrideCurveLimitScale");
}
void GCFootLockUpdateNode::SetStrideCurveLimitScale(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CFootLockUpdateNode->StrideCurveLimitScale(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CFootLockUpdateNode", "m_flStrideCurveLimitScale", false, value);
}
float GCFootLockUpdateNode::GetStepHeightIncreaseScale() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CFootLockUpdateNode->StepHeightIncreaseScale(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CFootLockUpdateNode", "m_flStepHeightIncreaseScale");
}
void GCFootLockUpdateNode::SetStepHeightIncreaseScale(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CFootLockUpdateNode->StepHeightIncreaseScale(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CFootLockUpdateNode", "m_flStepHeightIncreaseScale", false, value);
}
float GCFootLockUpdateNode::GetStepHeightDecreaseScale() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CFootLockUpdateNode->StepHeightDecreaseScale(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CFootLockUpdateNode", "m_flStepHeightDecreaseScale");
}
void GCFootLockUpdateNode::SetStepHeightDecreaseScale(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CFootLockUpdateNode->StepHeightDecreaseScale(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CFootLockUpdateNode", "m_flStepHeightDecreaseScale", false, value);
}
float GCFootLockUpdateNode::GetHipShiftScale() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CFootLockUpdateNode->HipShiftScale(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CFootLockUpdateNode", "m_flHipShiftScale");
}
void GCFootLockUpdateNode::SetHipShiftScale(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CFootLockUpdateNode->HipShiftScale(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CFootLockUpdateNode", "m_flHipShiftScale", false, value);
}
float GCFootLockUpdateNode::GetBlendTime() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CFootLockUpdateNode->BlendTime(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CFootLockUpdateNode", "m_flBlendTime");
}
void GCFootLockUpdateNode::SetBlendTime(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CFootLockUpdateNode->BlendTime(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CFootLockUpdateNode", "m_flBlendTime", false, value);
}
float GCFootLockUpdateNode::GetMaxRootHeightOffset() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CFootLockUpdateNode->MaxRootHeightOffset(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CFootLockUpdateNode", "m_flMaxRootHeightOffset");
}
void GCFootLockUpdateNode::SetMaxRootHeightOffset(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CFootLockUpdateNode->MaxRootHeightOffset(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CFootLockUpdateNode", "m_flMaxRootHeightOffset", false, value);
}
float GCFootLockUpdateNode::GetMinRootHeightOffset() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CFootLockUpdateNode->MinRootHeightOffset(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CFootLockUpdateNode", "m_flMinRootHeightOffset");
}
void GCFootLockUpdateNode::SetMinRootHeightOffset(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CFootLockUpdateNode->MinRootHeightOffset(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CFootLockUpdateNode", "m_flMinRootHeightOffset", false, value);
}
float GCFootLockUpdateNode::GetTiltPlanePitchSpringStrength() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CFootLockUpdateNode->TiltPlanePitchSpringStrength(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CFootLockUpdateNode", "m_flTiltPlanePitchSpringStrength");
}
void GCFootLockUpdateNode::SetTiltPlanePitchSpringStrength(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CFootLockUpdateNode->TiltPlanePitchSpringStrength(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CFootLockUpdateNode", "m_flTiltPlanePitchSpringStrength", false, value);
}
float GCFootLockUpdateNode::GetTiltPlaneRollSpringStrength() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CFootLockUpdateNode->TiltPlaneRollSpringStrength(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CFootLockUpdateNode", "m_flTiltPlaneRollSpringStrength");
}
void GCFootLockUpdateNode::SetTiltPlaneRollSpringStrength(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CFootLockUpdateNode->TiltPlaneRollSpringStrength(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CFootLockUpdateNode", "m_flTiltPlaneRollSpringStrength", false, value);
}
bool GCFootLockUpdateNode::GetApplyFootRotationLimits() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CFootLockUpdateNode->ApplyFootRotationLimits(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "CFootLockUpdateNode", "m_bApplyFootRotationLimits");
}
void GCFootLockUpdateNode::SetApplyFootRotationLimits(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CFootLockUpdateNode->ApplyFootRotationLimits(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CFootLockUpdateNode", "m_bApplyFootRotationLimits", false, value);
}
bool GCFootLockUpdateNode::GetApplyHipShift() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CFootLockUpdateNode->ApplyHipShift(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "CFootLockUpdateNode", "m_bApplyHipShift");
}
void GCFootLockUpdateNode::SetApplyHipShift(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CFootLockUpdateNode->ApplyHipShift(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CFootLockUpdateNode", "m_bApplyHipShift", false, value);
}
bool GCFootLockUpdateNode::GetModulateStepHeight() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CFootLockUpdateNode->ModulateStepHeight(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "CFootLockUpdateNode", "m_bModulateStepHeight");
}
void GCFootLockUpdateNode::SetModulateStepHeight(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CFootLockUpdateNode->ModulateStepHeight(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CFootLockUpdateNode", "m_bModulateStepHeight", false, value);
}
bool GCFootLockUpdateNode::GetResetChild() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CFootLockUpdateNode->ResetChild(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "CFootLockUpdateNode", "m_bResetChild");
}
void GCFootLockUpdateNode::SetResetChild(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CFootLockUpdateNode->ResetChild(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CFootLockUpdateNode", "m_bResetChild", false, value);
}
bool GCFootLockUpdateNode::GetEnableVerticalCurvedPaths() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CFootLockUpdateNode->EnableVerticalCurvedPaths(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "CFootLockUpdateNode", "m_bEnableVerticalCurvedPaths");
}
void GCFootLockUpdateNode::SetEnableVerticalCurvedPaths(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CFootLockUpdateNode->EnableVerticalCurvedPaths(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CFootLockUpdateNode", "m_bEnableVerticalCurvedPaths", false, value);
}
bool GCFootLockUpdateNode::GetEnableRootHeightDamping() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CFootLockUpdateNode->EnableRootHeightDamping(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "CFootLockUpdateNode", "m_bEnableRootHeightDamping");
}
void GCFootLockUpdateNode::SetEnableRootHeightDamping(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CFootLockUpdateNode->EnableRootHeightDamping(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CFootLockUpdateNode", "m_bEnableRootHeightDamping", false, value);
}
void* GCFootLockUpdateNode::GetPtr() {
    return m_ptr;
}
std::string GCFootLockUpdateNode::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCFootLockUpdateNode::IsValid() {
    return (m_ptr != nullptr);
}
GCUnaryUpdateNode GCFootLockUpdateNode::GetParent() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CFootLockUpdateNode::GetParent(ptr=%p)", m_ptr));
    GCUnaryUpdateNode value(m_ptr);
    return value;
}
void GCFootLockUpdateNode::SetParent(GCUnaryUpdateNode value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CFootLockUpdateNode::SetParent(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCFootLockUpdateNode(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCFootLockUpdateNode>("CFootLockUpdateNode")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("OpFixedSettings", &GCFootLockUpdateNode::GetOpFixedSettings, &GCFootLockUpdateNode::SetOpFixedSettings)
        .addProperty("FootSettings", &GCFootLockUpdateNode::GetFootSettings, &GCFootLockUpdateNode::SetFootSettings)
        .addProperty("HipShiftDamping", &GCFootLockUpdateNode::GetHipShiftDamping, &GCFootLockUpdateNode::SetHipShiftDamping)
        .addProperty("RootHeightDamping", &GCFootLockUpdateNode::GetRootHeightDamping, &GCFootLockUpdateNode::SetRootHeightDamping)
        .addProperty("StrideCurveScale", &GCFootLockUpdateNode::GetStrideCurveScale, &GCFootLockUpdateNode::SetStrideCurveScale)
        .addProperty("StrideCurveLimitScale", &GCFootLockUpdateNode::GetStrideCurveLimitScale, &GCFootLockUpdateNode::SetStrideCurveLimitScale)
        .addProperty("StepHeightIncreaseScale", &GCFootLockUpdateNode::GetStepHeightIncreaseScale, &GCFootLockUpdateNode::SetStepHeightIncreaseScale)
        .addProperty("StepHeightDecreaseScale", &GCFootLockUpdateNode::GetStepHeightDecreaseScale, &GCFootLockUpdateNode::SetStepHeightDecreaseScale)
        .addProperty("HipShiftScale", &GCFootLockUpdateNode::GetHipShiftScale, &GCFootLockUpdateNode::SetHipShiftScale)
        .addProperty("BlendTime", &GCFootLockUpdateNode::GetBlendTime, &GCFootLockUpdateNode::SetBlendTime)
        .addProperty("MaxRootHeightOffset", &GCFootLockUpdateNode::GetMaxRootHeightOffset, &GCFootLockUpdateNode::SetMaxRootHeightOffset)
        .addProperty("MinRootHeightOffset", &GCFootLockUpdateNode::GetMinRootHeightOffset, &GCFootLockUpdateNode::SetMinRootHeightOffset)
        .addProperty("TiltPlanePitchSpringStrength", &GCFootLockUpdateNode::GetTiltPlanePitchSpringStrength, &GCFootLockUpdateNode::SetTiltPlanePitchSpringStrength)
        .addProperty("TiltPlaneRollSpringStrength", &GCFootLockUpdateNode::GetTiltPlaneRollSpringStrength, &GCFootLockUpdateNode::SetTiltPlaneRollSpringStrength)
        .addProperty("ApplyFootRotationLimits", &GCFootLockUpdateNode::GetApplyFootRotationLimits, &GCFootLockUpdateNode::SetApplyFootRotationLimits)
        .addProperty("ApplyHipShift", &GCFootLockUpdateNode::GetApplyHipShift, &GCFootLockUpdateNode::SetApplyHipShift)
        .addProperty("ModulateStepHeight", &GCFootLockUpdateNode::GetModulateStepHeight, &GCFootLockUpdateNode::SetModulateStepHeight)
        .addProperty("ResetChild", &GCFootLockUpdateNode::GetResetChild, &GCFootLockUpdateNode::SetResetChild)
        .addProperty("EnableVerticalCurvedPaths", &GCFootLockUpdateNode::GetEnableVerticalCurvedPaths, &GCFootLockUpdateNode::SetEnableVerticalCurvedPaths)
        .addProperty("EnableRootHeightDamping", &GCFootLockUpdateNode::GetEnableRootHeightDamping, &GCFootLockUpdateNode::SetEnableRootHeightDamping)
        .addProperty("Parent", &GCFootLockUpdateNode::GetParent, &GCFootLockUpdateNode::SetParent)
        .addFunction("ToPtr", &GCFootLockUpdateNode::ToPtr)
        .addFunction("IsValid", &GCFootLockUpdateNode::IsValid)
        .endClass();
}
GCParentConstraint::GCParentConstraint(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCParentConstraint::GCParentConstraint(void *ptr) {
    m_ptr = ptr;
}
void* GCParentConstraint::GetPtr() {
    return m_ptr;
}
std::string GCParentConstraint::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCParentConstraint::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseConstraint GCParentConstraint::GetParent() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CParentConstraint::GetParent(ptr=%p)", m_ptr));
    GCBaseConstraint value(m_ptr);
    return value;
}
void GCParentConstraint::SetParent(GCBaseConstraint value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CParentConstraint::SetParent(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCParentConstraint(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCParentConstraint>("CParentConstraint")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Parent", &GCParentConstraint::GetParent, &GCParentConstraint::SetParent)
        .addFunction("ToPtr", &GCParentConstraint::ToPtr)
        .addFunction("IsValid", &GCParentConstraint::IsValid)
        .endClass();
}
GSkeletonAnimCapture_t__Frame_t::GSkeletonAnimCapture_t__Frame_t(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GSkeletonAnimCapture_t__Frame_t::GSkeletonAnimCapture_t__Frame_t(void *ptr) {
    m_ptr = ptr;
}
float GSkeletonAnimCapture_t__Frame_t::GetTime() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: SkeletonAnimCapture_t__Frame_t->Time(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "SkeletonAnimCapture_t__Frame_t", "m_flTime");
}
void GSkeletonAnimCapture_t__Frame_t::SetTime(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: SkeletonAnimCapture_t__Frame_t->Time(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "SkeletonAnimCapture_t__Frame_t", "m_flTime", true, value);
}
GSkeletonAnimCapture_t GSkeletonAnimCapture_t__Frame_t::GetStamp() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: SkeletonAnimCapture_t__Frame_t->Stamp(ptr=%p)", m_ptr));
    GSkeletonAnimCapture_t value(GetSchemaPtr(m_ptr, "SkeletonAnimCapture_t__Frame_t", "m_Stamp"));
    return value;
}
void GSkeletonAnimCapture_t__Frame_t::SetStamp(GSkeletonAnimCapture_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: SkeletonAnimCapture_t__Frame_t->Stamp(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Stamp' is not possible.\n");
}
bool GSkeletonAnimCapture_t__Frame_t::GetTeleport() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: SkeletonAnimCapture_t__Frame_t->Teleport(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "SkeletonAnimCapture_t__Frame_t", "m_bTeleport");
}
void GSkeletonAnimCapture_t__Frame_t::SetTeleport(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: SkeletonAnimCapture_t__Frame_t->Teleport(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "SkeletonAnimCapture_t__Frame_t", "m_bTeleport", true, value);
}
std::vector<Vector> GSkeletonAnimCapture_t__Frame_t::GetFeModelPos() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: SkeletonAnimCapture_t__Frame_t->FeModelPos(ptr=%p)", m_ptr));
    CUtlVector<Vector>* vec = GetSchemaValue<CUtlVector<Vector>*>(m_ptr, "SkeletonAnimCapture_t__Frame_t", "m_FeModelPos"); std::vector<Vector> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GSkeletonAnimCapture_t__Frame_t::SetFeModelPos(std::vector<Vector> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: SkeletonAnimCapture_t__Frame_t->FeModelPos(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<Vector>(m_ptr, "SkeletonAnimCapture_t__Frame_t", "m_FeModelPos", true, value);
}
std::vector<float32> GSkeletonAnimCapture_t__Frame_t::GetFlexControllerWeights() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: SkeletonAnimCapture_t__Frame_t->FlexControllerWeights(ptr=%p)", m_ptr));
    CUtlVector<float32>* vec = GetSchemaValue<CUtlVector<float32>*>(m_ptr, "SkeletonAnimCapture_t__Frame_t", "m_FlexControllerWeights"); std::vector<float32> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GSkeletonAnimCapture_t__Frame_t::SetFlexControllerWeights(std::vector<float32> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: SkeletonAnimCapture_t__Frame_t->FlexControllerWeights(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<float32>(m_ptr, "SkeletonAnimCapture_t__Frame_t", "m_FlexControllerWeights", true, value);
}
void* GSkeletonAnimCapture_t__Frame_t::GetPtr() {
    return m_ptr;
}
std::string GSkeletonAnimCapture_t__Frame_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GSkeletonAnimCapture_t__Frame_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassSkeletonAnimCapture_t__Frame_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GSkeletonAnimCapture_t__Frame_t>("SkeletonAnimCapture_t__Frame_t")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Time", &GSkeletonAnimCapture_t__Frame_t::GetTime, &GSkeletonAnimCapture_t__Frame_t::SetTime)
        .addProperty("Stamp", &GSkeletonAnimCapture_t__Frame_t::GetStamp, &GSkeletonAnimCapture_t__Frame_t::SetStamp)
        .addProperty("Teleport", &GSkeletonAnimCapture_t__Frame_t::GetTeleport, &GSkeletonAnimCapture_t__Frame_t::SetTeleport)
        .addProperty("FeModelPos", &GSkeletonAnimCapture_t__Frame_t::GetFeModelPos, &GSkeletonAnimCapture_t__Frame_t::SetFeModelPos)
        .addProperty("FlexControllerWeights", &GSkeletonAnimCapture_t__Frame_t::GetFlexControllerWeights, &GSkeletonAnimCapture_t__Frame_t::SetFlexControllerWeights)
        .addFunction("ToPtr", &GSkeletonAnimCapture_t__Frame_t::ToPtr)
        .addFunction("IsValid", &GSkeletonAnimCapture_t__Frame_t::IsValid)
        .endClass();
}
GCPathParameters::GCPathParameters(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCPathParameters::GCPathParameters(void *ptr) {
    m_ptr = ptr;
}
int32_t GCPathParameters::GetStartControlPointNumber() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CPathParameters->StartControlPointNumber(ptr=%p)", m_ptr));
    return GetSchemaValue<int32_t>(m_ptr, "CPathParameters", "m_nStartControlPointNumber");
}
void GCPathParameters::SetStartControlPointNumber(int32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CPathParameters->StartControlPointNumber(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CPathParameters", "m_nStartControlPointNumber", false, value);
}
int32_t GCPathParameters::GetEndControlPointNumber() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CPathParameters->EndControlPointNumber(ptr=%p)", m_ptr));
    return GetSchemaValue<int32_t>(m_ptr, "CPathParameters", "m_nEndControlPointNumber");
}
void GCPathParameters::SetEndControlPointNumber(int32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CPathParameters->EndControlPointNumber(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CPathParameters", "m_nEndControlPointNumber", false, value);
}
int32_t GCPathParameters::GetBulgeControl() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CPathParameters->BulgeControl(ptr=%p)", m_ptr));
    return GetSchemaValue<int32_t>(m_ptr, "CPathParameters", "m_nBulgeControl");
}
void GCPathParameters::SetBulgeControl(int32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CPathParameters->BulgeControl(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CPathParameters", "m_nBulgeControl", false, value);
}
float GCPathParameters::GetBulge() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CPathParameters->Bulge(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CPathParameters", "m_flBulge");
}
void GCPathParameters::SetBulge(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CPathParameters->Bulge(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CPathParameters", "m_flBulge", false, value);
}
float GCPathParameters::GetMidPoint() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CPathParameters->MidPoint(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CPathParameters", "m_flMidPoint");
}
void GCPathParameters::SetMidPoint(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CPathParameters->MidPoint(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CPathParameters", "m_flMidPoint", false, value);
}
Vector GCPathParameters::GetStartPointOffset() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CPathParameters->StartPointOffset(ptr=%p)", m_ptr));
    return GetSchemaValue<Vector>(m_ptr, "CPathParameters", "m_vStartPointOffset");
}
void GCPathParameters::SetStartPointOffset(Vector value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CPathParameters->StartPointOffset(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CPathParameters", "m_vStartPointOffset", false, value);
}
Vector GCPathParameters::GetMidPointOffset() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CPathParameters->MidPointOffset(ptr=%p)", m_ptr));
    return GetSchemaValue<Vector>(m_ptr, "CPathParameters", "m_vMidPointOffset");
}
void GCPathParameters::SetMidPointOffset(Vector value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CPathParameters->MidPointOffset(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CPathParameters", "m_vMidPointOffset", false, value);
}
Vector GCPathParameters::GetEndOffset() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CPathParameters->EndOffset(ptr=%p)", m_ptr));
    return GetSchemaValue<Vector>(m_ptr, "CPathParameters", "m_vEndOffset");
}
void GCPathParameters::SetEndOffset(Vector value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CPathParameters->EndOffset(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CPathParameters", "m_vEndOffset", false, value);
}
void* GCPathParameters::GetPtr() {
    return m_ptr;
}
std::string GCPathParameters::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCPathParameters::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCPathParameters(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCPathParameters>("CPathParameters")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("StartControlPointNumber", &GCPathParameters::GetStartControlPointNumber, &GCPathParameters::SetStartControlPointNumber)
        .addProperty("EndControlPointNumber", &GCPathParameters::GetEndControlPointNumber, &GCPathParameters::SetEndControlPointNumber)
        .addProperty("BulgeControl", &GCPathParameters::GetBulgeControl, &GCPathParameters::SetBulgeControl)
        .addProperty("Bulge", &GCPathParameters::GetBulge, &GCPathParameters::SetBulge)
        .addProperty("MidPoint", &GCPathParameters::GetMidPoint, &GCPathParameters::SetMidPoint)
        .addProperty("StartPointOffset", &GCPathParameters::GetStartPointOffset, &GCPathParameters::SetStartPointOffset)
        .addProperty("MidPointOffset", &GCPathParameters::GetMidPointOffset, &GCPathParameters::SetMidPointOffset)
        .addProperty("EndOffset", &GCPathParameters::GetEndOffset, &GCPathParameters::SetEndOffset)
        .addFunction("ToPtr", &GCPathParameters::ToPtr)
        .addFunction("IsValid", &GCPathParameters::IsValid)
        .endClass();
}
GCSlowDownOnSlopesUpdateNode::GCSlowDownOnSlopesUpdateNode(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCSlowDownOnSlopesUpdateNode::GCSlowDownOnSlopesUpdateNode(void *ptr) {
    m_ptr = ptr;
}
float GCSlowDownOnSlopesUpdateNode::GetSlowDownStrength() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CSlowDownOnSlopesUpdateNode->SlowDownStrength(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CSlowDownOnSlopesUpdateNode", "m_flSlowDownStrength");
}
void GCSlowDownOnSlopesUpdateNode::SetSlowDownStrength(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CSlowDownOnSlopesUpdateNode->SlowDownStrength(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CSlowDownOnSlopesUpdateNode", "m_flSlowDownStrength", false, value);
}
void* GCSlowDownOnSlopesUpdateNode::GetPtr() {
    return m_ptr;
}
std::string GCSlowDownOnSlopesUpdateNode::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCSlowDownOnSlopesUpdateNode::IsValid() {
    return (m_ptr != nullptr);
}
GCUnaryUpdateNode GCSlowDownOnSlopesUpdateNode::GetParent() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CSlowDownOnSlopesUpdateNode::GetParent(ptr=%p)", m_ptr));
    GCUnaryUpdateNode value(m_ptr);
    return value;
}
void GCSlowDownOnSlopesUpdateNode::SetParent(GCUnaryUpdateNode value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CSlowDownOnSlopesUpdateNode::SetParent(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCSlowDownOnSlopesUpdateNode(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCSlowDownOnSlopesUpdateNode>("CSlowDownOnSlopesUpdateNode")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("SlowDownStrength", &GCSlowDownOnSlopesUpdateNode::GetSlowDownStrength, &GCSlowDownOnSlopesUpdateNode::SetSlowDownStrength)
        .addProperty("Parent", &GCSlowDownOnSlopesUpdateNode::GetParent, &GCSlowDownOnSlopesUpdateNode::SetParent)
        .addFunction("ToPtr", &GCSlowDownOnSlopesUpdateNode::ToPtr)
        .addFunction("IsValid", &GCSlowDownOnSlopesUpdateNode::IsValid)
        .endClass();
}
GCAttachment::GCAttachment(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCAttachment::GCAttachment(void *ptr) {
    m_ptr = ptr;
}
std::string GCAttachment::GetName() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CAttachment->Name(ptr=%p)", m_ptr));
    return GetSchemaValue<CUtlString>(m_ptr, "CAttachment", "m_name").Get();
}
void GCAttachment::SetName(std::string value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CAttachment->Name(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CAttachment", "m_name", false, CUtlString(value.c_str()));
}
std::vector<CUtlString> GCAttachment::GetInfluenceNames() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CAttachment->InfluenceNames(ptr=%p,size=3)", m_ptr));
    CUtlString* outValue = (CUtlString*)GetSchemaPtr(m_ptr, "CAttachment", "m_influenceNames"); std::vector<CUtlString> ret; for(int i = 0; i < 3; i++) { ret.push_back(outValue[i]); } return ret;
}
void GCAttachment::SetInfluenceNames(std::vector<CUtlString> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CAttachment->InfluenceNames(ptr=%p,size=3)", m_ptr));
    if(value.size() != 3) return PLUGIN_PRINT("Schema SDK", "Field 'InfluenceNames' needs to have 3 values.\n");
    auto val = GetSchemaValuePtr<CUtlString>(m_ptr, "CAttachment", "m_influenceNames");
    for(size_t i = 0; i < value.size(); i++) val[i] = value[i];
}
std::vector<Vector> GCAttachment::GetInfluenceOffsets() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CAttachment->InfluenceOffsets(ptr=%p,size=3)", m_ptr));
    Vector* outValue = (Vector*)GetSchemaPtr(m_ptr, "CAttachment", "m_vInfluenceOffsets"); std::vector<Vector> ret; for(int i = 0; i < 3; i++) { ret.push_back(outValue[i]); } return ret;
}
void GCAttachment::SetInfluenceOffsets(std::vector<Vector> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CAttachment->InfluenceOffsets(ptr=%p,size=3)", m_ptr));
    if(value.size() != 3) return PLUGIN_PRINT("Schema SDK", "Field 'InfluenceOffsets' needs to have 3 values.\n");
    auto val = GetSchemaValuePtr<Vector>(m_ptr, "CAttachment", "m_vInfluenceOffsets");
    for(size_t i = 0; i < value.size(); i++) val[i] = value[i];
}
std::vector<float> GCAttachment::GetInfluenceWeights() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CAttachment->InfluenceWeights(ptr=%p,size=3)", m_ptr));
    float* outValue = (float*)GetSchemaPtr(m_ptr, "CAttachment", "m_influenceWeights"); std::vector<float> ret; for(int i = 0; i < 3; i++) { ret.push_back(outValue[i]); } return ret;
}
void GCAttachment::SetInfluenceWeights(std::vector<float> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CAttachment->InfluenceWeights(ptr=%p,size=3)", m_ptr));
    if(value.size() != 3) return PLUGIN_PRINT("Schema SDK", "Field 'InfluenceWeights' needs to have 3 values.\n");
    auto val = GetSchemaValuePtr<float>(m_ptr, "CAttachment", "m_influenceWeights");
    for(size_t i = 0; i < value.size(); i++) val[i] = value[i];
}
std::vector<bool> GCAttachment::GetInfluenceRootTransform() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CAttachment->InfluenceRootTransform(ptr=%p,size=3)", m_ptr));
    bool* outValue = (bool*)GetSchemaPtr(m_ptr, "CAttachment", "m_bInfluenceRootTransform"); std::vector<bool> ret; for(int i = 0; i < 3; i++) { ret.push_back(outValue[i]); } return ret;
}
void GCAttachment::SetInfluenceRootTransform(std::vector<bool> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CAttachment->InfluenceRootTransform(ptr=%p,size=3)", m_ptr));
    if(value.size() != 3) return PLUGIN_PRINT("Schema SDK", "Field 'InfluenceRootTransform' needs to have 3 values.\n");
    auto val = GetSchemaValuePtr<bool>(m_ptr, "CAttachment", "m_bInfluenceRootTransform");
    for(size_t i = 0; i < value.size(); i++) val[i] = value[i];
}
uint32_t GCAttachment::GetInfluences() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CAttachment->Influences(ptr=%p)", m_ptr));
    return GetSchemaValue<uint32_t>(m_ptr, "CAttachment", "m_nInfluences");
}
void GCAttachment::SetInfluences(uint32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CAttachment->Influences(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CAttachment", "m_nInfluences", false, value);
}
bool GCAttachment::GetIgnoreRotation() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CAttachment->IgnoreRotation(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "CAttachment", "m_bIgnoreRotation");
}
void GCAttachment::SetIgnoreRotation(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CAttachment->IgnoreRotation(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CAttachment", "m_bIgnoreRotation", false, value);
}
void* GCAttachment::GetPtr() {
    return m_ptr;
}
std::string GCAttachment::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCAttachment::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCAttachment(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCAttachment>("CAttachment")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Name", &GCAttachment::GetName, &GCAttachment::SetName)
        .addProperty("InfluenceNames", &GCAttachment::GetInfluenceNames, &GCAttachment::SetInfluenceNames)
        .addProperty("InfluenceOffsets", &GCAttachment::GetInfluenceOffsets, &GCAttachment::SetInfluenceOffsets)
        .addProperty("InfluenceWeights", &GCAttachment::GetInfluenceWeights, &GCAttachment::SetInfluenceWeights)
        .addProperty("InfluenceRootTransform", &GCAttachment::GetInfluenceRootTransform, &GCAttachment::SetInfluenceRootTransform)
        .addProperty("Influences", &GCAttachment::GetInfluences, &GCAttachment::SetInfluences)
        .addProperty("IgnoreRotation", &GCAttachment::GetIgnoreRotation, &GCAttachment::SetIgnoreRotation)
        .addFunction("ToPtr", &GCAttachment::ToPtr)
        .addFunction("IsValid", &GCAttachment::IsValid)
        .endClass();
}
GCEmptyEntityInstance::GCEmptyEntityInstance(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCEmptyEntityInstance::GCEmptyEntityInstance(void *ptr) {
    m_ptr = ptr;
}
void* GCEmptyEntityInstance::GetPtr() {
    return m_ptr;
}
std::string GCEmptyEntityInstance::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCEmptyEntityInstance::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCEmptyEntityInstance(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCEmptyEntityInstance>("CEmptyEntityInstance")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addFunction("ToPtr", &GCEmptyEntityInstance::ToPtr)
        .addFunction("IsValid", &GCEmptyEntityInstance::IsValid)
        .endClass();
}
GCCompositeMaterialEditorDoc::GCCompositeMaterialEditorDoc(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCCompositeMaterialEditorDoc::GCCompositeMaterialEditorDoc(void *ptr) {
    m_ptr = ptr;
}
int32_t GCCompositeMaterialEditorDoc::GetVersion() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CCompositeMaterialEditorDoc->Version(ptr=%p)", m_ptr));
    return GetSchemaValue<int32_t>(m_ptr, "CCompositeMaterialEditorDoc", "m_nVersion");
}
void GCCompositeMaterialEditorDoc::SetVersion(int32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CCompositeMaterialEditorDoc->Version(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CCompositeMaterialEditorDoc", "m_nVersion", false, value);
}
std::vector<GCompositeMaterialEditorPoint_t> GCCompositeMaterialEditorDoc::GetPoints() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CCompositeMaterialEditorDoc->Points(ptr=%p)", m_ptr));
    CUtlVector<GCompositeMaterialEditorPoint_t>* vec = GetSchemaValue<CUtlVector<GCompositeMaterialEditorPoint_t>*>(m_ptr, "CCompositeMaterialEditorDoc", "m_Points"); std::vector<GCompositeMaterialEditorPoint_t> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCCompositeMaterialEditorDoc::SetPoints(std::vector<GCompositeMaterialEditorPoint_t> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CCompositeMaterialEditorDoc->Points(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<GCompositeMaterialEditorPoint_t>(m_ptr, "CCompositeMaterialEditorDoc", "m_Points", false, value);
}
void* GCCompositeMaterialEditorDoc::GetPtr() {
    return m_ptr;
}
std::string GCCompositeMaterialEditorDoc::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCCompositeMaterialEditorDoc::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCCompositeMaterialEditorDoc(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCCompositeMaterialEditorDoc>("CCompositeMaterialEditorDoc")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Version", &GCCompositeMaterialEditorDoc::GetVersion, &GCCompositeMaterialEditorDoc::SetVersion)
        .addProperty("Points", &GCCompositeMaterialEditorDoc::GetPoints, &GCCompositeMaterialEditorDoc::SetPoints)
        .addFunction("ToPtr", &GCCompositeMaterialEditorDoc::ToPtr)
        .addFunction("IsValid", &GCCompositeMaterialEditorDoc::IsValid)
        .endClass();
}
GCPhysSurfacePropertiesPhysics::GCPhysSurfacePropertiesPhysics(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCPhysSurfacePropertiesPhysics::GCPhysSurfacePropertiesPhysics(void *ptr) {
    m_ptr = ptr;
}
float GCPhysSurfacePropertiesPhysics::GetFriction() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CPhysSurfacePropertiesPhysics->Friction(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CPhysSurfacePropertiesPhysics", "m_friction");
}
void GCPhysSurfacePropertiesPhysics::SetFriction(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CPhysSurfacePropertiesPhysics->Friction(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CPhysSurfacePropertiesPhysics", "m_friction", false, value);
}
float GCPhysSurfacePropertiesPhysics::GetElasticity() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CPhysSurfacePropertiesPhysics->Elasticity(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CPhysSurfacePropertiesPhysics", "m_elasticity");
}
void GCPhysSurfacePropertiesPhysics::SetElasticity(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CPhysSurfacePropertiesPhysics->Elasticity(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CPhysSurfacePropertiesPhysics", "m_elasticity", false, value);
}
float GCPhysSurfacePropertiesPhysics::GetDensity() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CPhysSurfacePropertiesPhysics->Density(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CPhysSurfacePropertiesPhysics", "m_density");
}
void GCPhysSurfacePropertiesPhysics::SetDensity(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CPhysSurfacePropertiesPhysics->Density(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CPhysSurfacePropertiesPhysics", "m_density", false, value);
}
float GCPhysSurfacePropertiesPhysics::GetThickness() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CPhysSurfacePropertiesPhysics->Thickness(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CPhysSurfacePropertiesPhysics", "m_thickness");
}
void GCPhysSurfacePropertiesPhysics::SetThickness(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CPhysSurfacePropertiesPhysics->Thickness(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CPhysSurfacePropertiesPhysics", "m_thickness", false, value);
}
float GCPhysSurfacePropertiesPhysics::GetSoftContactFrequency() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CPhysSurfacePropertiesPhysics->SoftContactFrequency(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CPhysSurfacePropertiesPhysics", "m_softContactFrequency");
}
void GCPhysSurfacePropertiesPhysics::SetSoftContactFrequency(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CPhysSurfacePropertiesPhysics->SoftContactFrequency(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CPhysSurfacePropertiesPhysics", "m_softContactFrequency", false, value);
}
float GCPhysSurfacePropertiesPhysics::GetSoftContactDampingRatio() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CPhysSurfacePropertiesPhysics->SoftContactDampingRatio(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CPhysSurfacePropertiesPhysics", "m_softContactDampingRatio");
}
void GCPhysSurfacePropertiesPhysics::SetSoftContactDampingRatio(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CPhysSurfacePropertiesPhysics->SoftContactDampingRatio(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CPhysSurfacePropertiesPhysics", "m_softContactDampingRatio", false, value);
}
float GCPhysSurfacePropertiesPhysics::GetWheelDrag() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CPhysSurfacePropertiesPhysics->WheelDrag(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CPhysSurfacePropertiesPhysics", "m_wheelDrag");
}
void GCPhysSurfacePropertiesPhysics::SetWheelDrag(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CPhysSurfacePropertiesPhysics->WheelDrag(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CPhysSurfacePropertiesPhysics", "m_wheelDrag", false, value);
}
void* GCPhysSurfacePropertiesPhysics::GetPtr() {
    return m_ptr;
}
std::string GCPhysSurfacePropertiesPhysics::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCPhysSurfacePropertiesPhysics::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCPhysSurfacePropertiesPhysics(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCPhysSurfacePropertiesPhysics>("CPhysSurfacePropertiesPhysics")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Friction", &GCPhysSurfacePropertiesPhysics::GetFriction, &GCPhysSurfacePropertiesPhysics::SetFriction)
        .addProperty("Elasticity", &GCPhysSurfacePropertiesPhysics::GetElasticity, &GCPhysSurfacePropertiesPhysics::SetElasticity)
        .addProperty("Density", &GCPhysSurfacePropertiesPhysics::GetDensity, &GCPhysSurfacePropertiesPhysics::SetDensity)
        .addProperty("Thickness", &GCPhysSurfacePropertiesPhysics::GetThickness, &GCPhysSurfacePropertiesPhysics::SetThickness)
        .addProperty("SoftContactFrequency", &GCPhysSurfacePropertiesPhysics::GetSoftContactFrequency, &GCPhysSurfacePropertiesPhysics::SetSoftContactFrequency)
        .addProperty("SoftContactDampingRatio", &GCPhysSurfacePropertiesPhysics::GetSoftContactDampingRatio, &GCPhysSurfacePropertiesPhysics::SetSoftContactDampingRatio)
        .addProperty("WheelDrag", &GCPhysSurfacePropertiesPhysics::GetWheelDrag, &GCPhysSurfacePropertiesPhysics::SetWheelDrag)
        .addFunction("ToPtr", &GCPhysSurfacePropertiesPhysics::ToPtr)
        .addFunction("IsValid", &GCPhysSurfacePropertiesPhysics::IsValid)
        .endClass();
}
GEventClientPostOutput_t::GEventClientPostOutput_t(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GEventClientPostOutput_t::GEventClientPostOutput_t(void *ptr) {
    m_ptr = ptr;
}
GEngineLoopState_t GEventClientPostOutput_t::GetLoopState() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: EventClientPostOutput_t->LoopState(ptr=%p)", m_ptr));
    GEngineLoopState_t value(GetSchemaPtr(m_ptr, "EventClientPostOutput_t", "m_LoopState"));
    return value;
}
void GEventClientPostOutput_t::SetLoopState(GEngineLoopState_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: EventClientPostOutput_t->LoopState(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'LoopState' is not possible.\n");
}
double GEventClientPostOutput_t::GetRenderTime() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: EventClientPostOutput_t->RenderTime(ptr=%p)", m_ptr));
    return GetSchemaValue<double>(m_ptr, "EventClientPostOutput_t", "m_flRenderTime");
}
void GEventClientPostOutput_t::SetRenderTime(double value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: EventClientPostOutput_t->RenderTime(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "EventClientPostOutput_t", "m_flRenderTime", true, value);
}
float GEventClientPostOutput_t::GetRenderFrameTime() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: EventClientPostOutput_t->RenderFrameTime(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "EventClientPostOutput_t", "m_flRenderFrameTime");
}
void GEventClientPostOutput_t::SetRenderFrameTime(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: EventClientPostOutput_t->RenderFrameTime(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "EventClientPostOutput_t", "m_flRenderFrameTime", true, value);
}
float GEventClientPostOutput_t::GetRenderFrameTimeUnbounded() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: EventClientPostOutput_t->RenderFrameTimeUnbounded(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "EventClientPostOutput_t", "m_flRenderFrameTimeUnbounded");
}
void GEventClientPostOutput_t::SetRenderFrameTimeUnbounded(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: EventClientPostOutput_t->RenderFrameTimeUnbounded(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "EventClientPostOutput_t", "m_flRenderFrameTimeUnbounded", true, value);
}
bool GEventClientPostOutput_t::GetRenderOnly() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: EventClientPostOutput_t->RenderOnly(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "EventClientPostOutput_t", "m_bRenderOnly");
}
void GEventClientPostOutput_t::SetRenderOnly(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: EventClientPostOutput_t->RenderOnly(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "EventClientPostOutput_t", "m_bRenderOnly", true, value);
}
void* GEventClientPostOutput_t::GetPtr() {
    return m_ptr;
}
std::string GEventClientPostOutput_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GEventClientPostOutput_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassEventClientPostOutput_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GEventClientPostOutput_t>("EventClientPostOutput_t")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("LoopState", &GEventClientPostOutput_t::GetLoopState, &GEventClientPostOutput_t::SetLoopState)
        .addProperty("RenderTime", &GEventClientPostOutput_t::GetRenderTime, &GEventClientPostOutput_t::SetRenderTime)
        .addProperty("RenderFrameTime", &GEventClientPostOutput_t::GetRenderFrameTime, &GEventClientPostOutput_t::SetRenderFrameTime)
        .addProperty("RenderFrameTimeUnbounded", &GEventClientPostOutput_t::GetRenderFrameTimeUnbounded, &GEventClientPostOutput_t::SetRenderFrameTimeUnbounded)
        .addProperty("RenderOnly", &GEventClientPostOutput_t::GetRenderOnly, &GEventClientPostOutput_t::SetRenderOnly)
        .addFunction("ToPtr", &GEventClientPostOutput_t::ToPtr)
        .addFunction("IsValid", &GEventClientPostOutput_t::IsValid)
        .endClass();
}
GFeNodeIntegrator_t::GFeNodeIntegrator_t(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GFeNodeIntegrator_t::GFeNodeIntegrator_t(void *ptr) {
    m_ptr = ptr;
}
float GFeNodeIntegrator_t::GetPointDamping() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FeNodeIntegrator_t->PointDamping(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "FeNodeIntegrator_t", "flPointDamping");
}
void GFeNodeIntegrator_t::SetPointDamping(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FeNodeIntegrator_t->PointDamping(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "FeNodeIntegrator_t", "flPointDamping", true, value);
}
float GFeNodeIntegrator_t::GetAnimationForceAttraction() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FeNodeIntegrator_t->AnimationForceAttraction(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "FeNodeIntegrator_t", "flAnimationForceAttraction");
}
void GFeNodeIntegrator_t::SetAnimationForceAttraction(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FeNodeIntegrator_t->AnimationForceAttraction(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "FeNodeIntegrator_t", "flAnimationForceAttraction", true, value);
}
float GFeNodeIntegrator_t::GetAnimationVertexAttraction() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FeNodeIntegrator_t->AnimationVertexAttraction(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "FeNodeIntegrator_t", "flAnimationVertexAttraction");
}
void GFeNodeIntegrator_t::SetAnimationVertexAttraction(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FeNodeIntegrator_t->AnimationVertexAttraction(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "FeNodeIntegrator_t", "flAnimationVertexAttraction", true, value);
}
float GFeNodeIntegrator_t::GetGravity() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FeNodeIntegrator_t->Gravity(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "FeNodeIntegrator_t", "flGravity");
}
void GFeNodeIntegrator_t::SetGravity(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FeNodeIntegrator_t->Gravity(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "FeNodeIntegrator_t", "flGravity", true, value);
}
void* GFeNodeIntegrator_t::GetPtr() {
    return m_ptr;
}
std::string GFeNodeIntegrator_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GFeNodeIntegrator_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassFeNodeIntegrator_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GFeNodeIntegrator_t>("FeNodeIntegrator_t")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("PointDamping", &GFeNodeIntegrator_t::GetPointDamping, &GFeNodeIntegrator_t::SetPointDamping)
        .addProperty("AnimationForceAttraction", &GFeNodeIntegrator_t::GetAnimationForceAttraction, &GFeNodeIntegrator_t::SetAnimationForceAttraction)
        .addProperty("AnimationVertexAttraction", &GFeNodeIntegrator_t::GetAnimationVertexAttraction, &GFeNodeIntegrator_t::SetAnimationVertexAttraction)
        .addProperty("Gravity", &GFeNodeIntegrator_t::GetGravity, &GFeNodeIntegrator_t::SetGravity)
        .addFunction("ToPtr", &GFeNodeIntegrator_t::ToPtr)
        .addFunction("IsValid", &GFeNodeIntegrator_t::IsValid)
        .endClass();
}
GRnMeshDesc_t::GRnMeshDesc_t(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GRnMeshDesc_t::GRnMeshDesc_t(void *ptr) {
    m_ptr = ptr;
}
GRnMesh_t GRnMeshDesc_t::GetMesh() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: RnMeshDesc_t->Mesh(ptr=%p)", m_ptr));
    GRnMesh_t value(GetSchemaPtr(m_ptr, "RnMeshDesc_t", "m_Mesh"));
    return value;
}
void GRnMeshDesc_t::SetMesh(GRnMesh_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: RnMeshDesc_t->Mesh(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Mesh' is not possible.\n");
}
void* GRnMeshDesc_t::GetPtr() {
    return m_ptr;
}
std::string GRnMeshDesc_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GRnMeshDesc_t::IsValid() {
    return (m_ptr != nullptr);
}
GRnShapeDesc_t GRnMeshDesc_t::GetParent() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("RnMeshDesc_t::GetParent(ptr=%p)", m_ptr));
    GRnShapeDesc_t value(m_ptr);
    return value;
}
void GRnMeshDesc_t::SetParent(GRnShapeDesc_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("RnMeshDesc_t::SetParent(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassRnMeshDesc_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GRnMeshDesc_t>("RnMeshDesc_t")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Mesh", &GRnMeshDesc_t::GetMesh, &GRnMeshDesc_t::SetMesh)
        .addProperty("Parent", &GRnMeshDesc_t::GetParent, &GRnMeshDesc_t::SetParent)
        .addFunction("ToPtr", &GRnMeshDesc_t::ToPtr)
        .addFunction("IsValid", &GRnMeshDesc_t::IsValid)
        .endClass();
}
GCAnimGraphNetworkSettings::GCAnimGraphNetworkSettings(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCAnimGraphNetworkSettings::GCAnimGraphNetworkSettings(void *ptr) {
    m_ptr = ptr;
}
bool GCAnimGraphNetworkSettings::GetNetworkingEnabled() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CAnimGraphNetworkSettings->NetworkingEnabled(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "CAnimGraphNetworkSettings", "m_bNetworkingEnabled");
}
void GCAnimGraphNetworkSettings::SetNetworkingEnabled(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CAnimGraphNetworkSettings->NetworkingEnabled(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CAnimGraphNetworkSettings", "m_bNetworkingEnabled", false, value);
}
void* GCAnimGraphNetworkSettings::GetPtr() {
    return m_ptr;
}
std::string GCAnimGraphNetworkSettings::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCAnimGraphNetworkSettings::IsValid() {
    return (m_ptr != nullptr);
}
GCAnimGraphSettingsGroup GCAnimGraphNetworkSettings::GetParent() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CAnimGraphNetworkSettings::GetParent(ptr=%p)", m_ptr));
    GCAnimGraphSettingsGroup value(m_ptr);
    return value;
}
void GCAnimGraphNetworkSettings::SetParent(GCAnimGraphSettingsGroup value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CAnimGraphNetworkSettings::SetParent(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCAnimGraphNetworkSettings(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCAnimGraphNetworkSettings>("CAnimGraphNetworkSettings")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("NetworkingEnabled", &GCAnimGraphNetworkSettings::GetNetworkingEnabled, &GCAnimGraphNetworkSettings::SetNetworkingEnabled)
        .addProperty("Parent", &GCAnimGraphNetworkSettings::GetParent, &GCAnimGraphNetworkSettings::SetParent)
        .addFunction("ToPtr", &GCAnimGraphNetworkSettings::ToPtr)
        .addFunction("IsValid", &GCAnimGraphNetworkSettings::IsValid)
        .endClass();
}
GCAimConstraint::GCAimConstraint(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCAimConstraint::GCAimConstraint(void *ptr) {
    m_ptr = ptr;
}
uint32_t GCAimConstraint::GetUpType() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CAimConstraint->UpType(ptr=%p)", m_ptr));
    return GetSchemaValue<uint32_t>(m_ptr, "CAimConstraint", "m_nUpType");
}
void GCAimConstraint::SetUpType(uint32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CAimConstraint->UpType(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CAimConstraint", "m_nUpType", false, value);
}
void* GCAimConstraint::GetPtr() {
    return m_ptr;
}
std::string GCAimConstraint::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCAimConstraint::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseConstraint GCAimConstraint::GetParent() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CAimConstraint::GetParent(ptr=%p)", m_ptr));
    GCBaseConstraint value(m_ptr);
    return value;
}
void GCAimConstraint::SetParent(GCBaseConstraint value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CAimConstraint::SetParent(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCAimConstraint(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCAimConstraint>("CAimConstraint")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("UpType", &GCAimConstraint::GetUpType, &GCAimConstraint::SetUpType)
        .addProperty("Parent", &GCAimConstraint::GetParent, &GCAimConstraint::SetParent)
        .addFunction("ToPtr", &GCAimConstraint::ToPtr)
        .addFunction("IsValid", &GCAimConstraint::IsValid)
        .endClass();
}
GCAnimActionUpdater::GCAnimActionUpdater(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCAnimActionUpdater::GCAnimActionUpdater(void *ptr) {
    m_ptr = ptr;
}
void* GCAnimActionUpdater::GetPtr() {
    return m_ptr;
}
std::string GCAnimActionUpdater::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCAnimActionUpdater::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCAnimActionUpdater(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCAnimActionUpdater>("CAnimActionUpdater")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addFunction("ToPtr", &GCAnimActionUpdater::ToPtr)
        .addFunction("IsValid", &GCAnimActionUpdater::IsValid)
        .endClass();
}
GCParticleFunctionForce::GCParticleFunctionForce(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCParticleFunctionForce::GCParticleFunctionForce(void *ptr) {
    m_ptr = ptr;
}
void* GCParticleFunctionForce::GetPtr() {
    return m_ptr;
}
std::string GCParticleFunctionForce::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCParticleFunctionForce::IsValid() {
    return (m_ptr != nullptr);
}
GCParticleFunction GCParticleFunctionForce::GetParent() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CParticleFunctionForce::GetParent(ptr=%p)", m_ptr));
    GCParticleFunction value(m_ptr);
    return value;
}
void GCParticleFunctionForce::SetParent(GCParticleFunction value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CParticleFunctionForce::SetParent(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCParticleFunctionForce(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCParticleFunctionForce>("CParticleFunctionForce")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Parent", &GCParticleFunctionForce::GetParent, &GCParticleFunctionForce::SetParent)
        .addFunction("ToPtr", &GCParticleFunctionForce::ToPtr)
        .addFunction("IsValid", &GCParticleFunctionForce::IsValid)
        .endClass();
}
GCSpinUpdateBase::GCSpinUpdateBase(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCSpinUpdateBase::GCSpinUpdateBase(void *ptr) {
    m_ptr = ptr;
}
void* GCSpinUpdateBase::GetPtr() {
    return m_ptr;
}
std::string GCSpinUpdateBase::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCSpinUpdateBase::IsValid() {
    return (m_ptr != nullptr);
}
GCParticleFunctionOperator GCSpinUpdateBase::GetParent() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CSpinUpdateBase::GetParent(ptr=%p)", m_ptr));
    GCParticleFunctionOperator value(m_ptr);
    return value;
}
void GCSpinUpdateBase::SetParent(GCParticleFunctionOperator value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CSpinUpdateBase::SetParent(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCSpinUpdateBase(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCSpinUpdateBase>("CSpinUpdateBase")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Parent", &GCSpinUpdateBase::GetParent, &GCSpinUpdateBase::SetParent)
        .addFunction("ToPtr", &GCSpinUpdateBase::ToPtr)
        .addFunction("IsValid", &GCSpinUpdateBase::IsValid)
        .endClass();
}
GControlPointReference_t::GControlPointReference_t(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GControlPointReference_t::GControlPointReference_t(void *ptr) {
    m_ptr = ptr;
}
int32_t GControlPointReference_t::GetControlPointNameString() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: ControlPointReference_t->ControlPointNameString(ptr=%p)", m_ptr));
    return GetSchemaValue<int32_t>(m_ptr, "ControlPointReference_t", "m_controlPointNameString");
}
void GControlPointReference_t::SetControlPointNameString(int32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: ControlPointReference_t->ControlPointNameString(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "ControlPointReference_t", "m_controlPointNameString", true, value);
}
Vector GControlPointReference_t::GetOffsetFromControlPoint() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: ControlPointReference_t->OffsetFromControlPoint(ptr=%p)", m_ptr));
    return GetSchemaValue<Vector>(m_ptr, "ControlPointReference_t", "m_vOffsetFromControlPoint");
}
void GControlPointReference_t::SetOffsetFromControlPoint(Vector value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: ControlPointReference_t->OffsetFromControlPoint(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "ControlPointReference_t", "m_vOffsetFromControlPoint", true, value);
}
bool GControlPointReference_t::GetOffsetInLocalSpace() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: ControlPointReference_t->OffsetInLocalSpace(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "ControlPointReference_t", "m_bOffsetInLocalSpace");
}
void GControlPointReference_t::SetOffsetInLocalSpace(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: ControlPointReference_t->OffsetInLocalSpace(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "ControlPointReference_t", "m_bOffsetInLocalSpace", true, value);
}
void* GControlPointReference_t::GetPtr() {
    return m_ptr;
}
std::string GControlPointReference_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GControlPointReference_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassControlPointReference_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GControlPointReference_t>("ControlPointReference_t")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("ControlPointNameString", &GControlPointReference_t::GetControlPointNameString, &GControlPointReference_t::SetControlPointNameString)
        .addProperty("OffsetFromControlPoint", &GControlPointReference_t::GetOffsetFromControlPoint, &GControlPointReference_t::SetOffsetFromControlPoint)
        .addProperty("OffsetInLocalSpace", &GControlPointReference_t::GetOffsetInLocalSpace, &GControlPointReference_t::SetOffsetInLocalSpace)
        .addFunction("ToPtr", &GControlPointReference_t::ToPtr)
        .addFunction("IsValid", &GControlPointReference_t::IsValid)
        .endClass();
}
GCVoiceContainerRandomSampler::GCVoiceContainerRandomSampler(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCVoiceContainerRandomSampler::GCVoiceContainerRandomSampler(void *ptr) {
    m_ptr = ptr;
}
float GCVoiceContainerRandomSampler::GetAmplitude() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CVoiceContainerRandomSampler->Amplitude(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CVoiceContainerRandomSampler", "m_flAmplitude");
}
void GCVoiceContainerRandomSampler::SetAmplitude(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CVoiceContainerRandomSampler->Amplitude(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CVoiceContainerRandomSampler", "m_flAmplitude", false, value);
}
float GCVoiceContainerRandomSampler::GetAmplitudeJitter() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CVoiceContainerRandomSampler->AmplitudeJitter(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CVoiceContainerRandomSampler", "m_flAmplitudeJitter");
}
void GCVoiceContainerRandomSampler::SetAmplitudeJitter(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CVoiceContainerRandomSampler->AmplitudeJitter(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CVoiceContainerRandomSampler", "m_flAmplitudeJitter", false, value);
}
float GCVoiceContainerRandomSampler::GetTimeJitter() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CVoiceContainerRandomSampler->TimeJitter(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CVoiceContainerRandomSampler", "m_flTimeJitter");
}
void GCVoiceContainerRandomSampler::SetTimeJitter(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CVoiceContainerRandomSampler->TimeJitter(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CVoiceContainerRandomSampler", "m_flTimeJitter", false, value);
}
float GCVoiceContainerRandomSampler::GetMaxLength() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CVoiceContainerRandomSampler->MaxLength(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CVoiceContainerRandomSampler", "m_flMaxLength");
}
void GCVoiceContainerRandomSampler::SetMaxLength(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CVoiceContainerRandomSampler->MaxLength(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CVoiceContainerRandomSampler", "m_flMaxLength", false, value);
}
int32_t GCVoiceContainerRandomSampler::GetNumDelayVariations() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CVoiceContainerRandomSampler->NumDelayVariations(ptr=%p)", m_ptr));
    return GetSchemaValue<int32_t>(m_ptr, "CVoiceContainerRandomSampler", "m_nNumDelayVariations");
}
void GCVoiceContainerRandomSampler::SetNumDelayVariations(int32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CVoiceContainerRandomSampler->NumDelayVariations(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CVoiceContainerRandomSampler", "m_nNumDelayVariations", false, value);
}
void* GCVoiceContainerRandomSampler::GetPtr() {
    return m_ptr;
}
std::string GCVoiceContainerRandomSampler::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCVoiceContainerRandomSampler::IsValid() {
    return (m_ptr != nullptr);
}
GCVoiceContainerBase GCVoiceContainerRandomSampler::GetParent() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CVoiceContainerRandomSampler::GetParent(ptr=%p)", m_ptr));
    GCVoiceContainerBase value(m_ptr);
    return value;
}
void GCVoiceContainerRandomSampler::SetParent(GCVoiceContainerBase value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CVoiceContainerRandomSampler::SetParent(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCVoiceContainerRandomSampler(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCVoiceContainerRandomSampler>("CVoiceContainerRandomSampler")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Amplitude", &GCVoiceContainerRandomSampler::GetAmplitude, &GCVoiceContainerRandomSampler::SetAmplitude)
        .addProperty("AmplitudeJitter", &GCVoiceContainerRandomSampler::GetAmplitudeJitter, &GCVoiceContainerRandomSampler::SetAmplitudeJitter)
        .addProperty("TimeJitter", &GCVoiceContainerRandomSampler::GetTimeJitter, &GCVoiceContainerRandomSampler::SetTimeJitter)
        .addProperty("MaxLength", &GCVoiceContainerRandomSampler::GetMaxLength, &GCVoiceContainerRandomSampler::SetMaxLength)
        .addProperty("NumDelayVariations", &GCVoiceContainerRandomSampler::GetNumDelayVariations, &GCVoiceContainerRandomSampler::SetNumDelayVariations)
        .addProperty("Parent", &GCVoiceContainerRandomSampler::GetParent, &GCVoiceContainerRandomSampler::SetParent)
        .addFunction("ToPtr", &GCVoiceContainerRandomSampler::ToPtr)
        .addFunction("IsValid", &GCVoiceContainerRandomSampler::IsValid)
        .endClass();
}
GFeFollowNode_t::GFeFollowNode_t(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GFeFollowNode_t::GFeFollowNode_t(void *ptr) {
    m_ptr = ptr;
}
uint16_t GFeFollowNode_t::GetParentNode() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FeFollowNode_t->ParentNode(ptr=%p)", m_ptr));
    return GetSchemaValue<uint16_t>(m_ptr, "FeFollowNode_t", "nParentNode");
}
void GFeFollowNode_t::SetParentNode(uint16_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FeFollowNode_t->ParentNode(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "FeFollowNode_t", "nParentNode", true, value);
}
uint16_t GFeFollowNode_t::GetChildNode() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FeFollowNode_t->ChildNode(ptr=%p)", m_ptr));
    return GetSchemaValue<uint16_t>(m_ptr, "FeFollowNode_t", "nChildNode");
}
void GFeFollowNode_t::SetChildNode(uint16_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FeFollowNode_t->ChildNode(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "FeFollowNode_t", "nChildNode", true, value);
}
float GFeFollowNode_t::GetWeight() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FeFollowNode_t->Weight(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "FeFollowNode_t", "flWeight");
}
void GFeFollowNode_t::SetWeight(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FeFollowNode_t->Weight(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "FeFollowNode_t", "flWeight", true, value);
}
void* GFeFollowNode_t::GetPtr() {
    return m_ptr;
}
std::string GFeFollowNode_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GFeFollowNode_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassFeFollowNode_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GFeFollowNode_t>("FeFollowNode_t")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("ParentNode", &GFeFollowNode_t::GetParentNode, &GFeFollowNode_t::SetParentNode)
        .addProperty("ChildNode", &GFeFollowNode_t::GetChildNode, &GFeFollowNode_t::SetChildNode)
        .addProperty("Weight", &GFeFollowNode_t::GetWeight, &GFeFollowNode_t::SetWeight)
        .addFunction("ToPtr", &GFeFollowNode_t::ToPtr)
        .addFunction("IsValid", &GFeFollowNode_t::IsValid)
        .endClass();
}
GCovMatrix3::GCovMatrix3(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCovMatrix3::GCovMatrix3(void *ptr) {
    m_ptr = ptr;
}
Vector GCovMatrix3::GetDiag() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CovMatrix3->Diag(ptr=%p)", m_ptr));
    return GetSchemaValue<Vector>(m_ptr, "CovMatrix3", "m_vDiag");
}
void GCovMatrix3::SetDiag(Vector value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CovMatrix3->Diag(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CovMatrix3", "m_vDiag", false, value);
}
float GCovMatrix3::GetXY() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CovMatrix3->XY(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CovMatrix3", "m_flXY");
}
void GCovMatrix3::SetXY(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CovMatrix3->XY(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CovMatrix3", "m_flXY", false, value);
}
float GCovMatrix3::GetXZ() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CovMatrix3->XZ(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CovMatrix3", "m_flXZ");
}
void GCovMatrix3::SetXZ(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CovMatrix3->XZ(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CovMatrix3", "m_flXZ", false, value);
}
float GCovMatrix3::GetYZ() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CovMatrix3->YZ(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CovMatrix3", "m_flYZ");
}
void GCovMatrix3::SetYZ(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CovMatrix3->YZ(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CovMatrix3", "m_flYZ", false, value);
}
void* GCovMatrix3::GetPtr() {
    return m_ptr;
}
std::string GCovMatrix3::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCovMatrix3::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCovMatrix3(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCovMatrix3>("CovMatrix3")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Diag", &GCovMatrix3::GetDiag, &GCovMatrix3::SetDiag)
        .addProperty("XY", &GCovMatrix3::GetXY, &GCovMatrix3::SetXY)
        .addProperty("XZ", &GCovMatrix3::GetXZ, &GCovMatrix3::SetXZ)
        .addProperty("YZ", &GCovMatrix3::GetYZ, &GCovMatrix3::SetYZ)
        .addFunction("ToPtr", &GCovMatrix3::ToPtr)
        .addFunction("IsValid", &GCovMatrix3::IsValid)
        .endClass();
}
GAnimStateID::GAnimStateID(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GAnimStateID::GAnimStateID(void *ptr) {
    m_ptr = ptr;
}
uint32_t GAnimStateID::GetId() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: AnimStateID->Id(ptr=%p)", m_ptr));
    return GetSchemaValue<uint32_t>(m_ptr, "AnimStateID", "m_id");
}
void GAnimStateID::SetId(uint32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: AnimStateID->Id(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "AnimStateID", "m_id", false, value);
}
void* GAnimStateID::GetPtr() {
    return m_ptr;
}
std::string GAnimStateID::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GAnimStateID::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassAnimStateID(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GAnimStateID>("AnimStateID")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Id", &GAnimStateID::GetId, &GAnimStateID::SetId)
        .addFunction("ToPtr", &GAnimStateID::ToPtr)
        .addFunction("IsValid", &GAnimStateID::IsValid)
        .endClass();
}
GCVoiceContainerStaticAdditiveSynth::GCVoiceContainerStaticAdditiveSynth(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCVoiceContainerStaticAdditiveSynth::GCVoiceContainerStaticAdditiveSynth(void *ptr) {
    m_ptr = ptr;
}
float GCVoiceContainerStaticAdditiveSynth::GetMinVolume() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CVoiceContainerStaticAdditiveSynth->MinVolume(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CVoiceContainerStaticAdditiveSynth", "m_flMinVolume");
}
void GCVoiceContainerStaticAdditiveSynth::SetMinVolume(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CVoiceContainerStaticAdditiveSynth->MinVolume(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CVoiceContainerStaticAdditiveSynth", "m_flMinVolume", false, value);
}
int32_t GCVoiceContainerStaticAdditiveSynth::GetInstancesAtMinVolume() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CVoiceContainerStaticAdditiveSynth->InstancesAtMinVolume(ptr=%p)", m_ptr));
    return GetSchemaValue<int32_t>(m_ptr, "CVoiceContainerStaticAdditiveSynth", "m_nInstancesAtMinVolume");
}
void GCVoiceContainerStaticAdditiveSynth::SetInstancesAtMinVolume(int32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CVoiceContainerStaticAdditiveSynth->InstancesAtMinVolume(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CVoiceContainerStaticAdditiveSynth", "m_nInstancesAtMinVolume", false, value);
}
float GCVoiceContainerStaticAdditiveSynth::GetMaxVolume() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CVoiceContainerStaticAdditiveSynth->MaxVolume(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CVoiceContainerStaticAdditiveSynth", "m_flMaxVolume");
}
void GCVoiceContainerStaticAdditiveSynth::SetMaxVolume(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CVoiceContainerStaticAdditiveSynth->MaxVolume(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CVoiceContainerStaticAdditiveSynth", "m_flMaxVolume", false, value);
}
int32_t GCVoiceContainerStaticAdditiveSynth::GetInstancesAtMaxVolume() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CVoiceContainerStaticAdditiveSynth->InstancesAtMaxVolume(ptr=%p)", m_ptr));
    return GetSchemaValue<int32_t>(m_ptr, "CVoiceContainerStaticAdditiveSynth", "m_nInstancesAtMaxVolume");
}
void GCVoiceContainerStaticAdditiveSynth::SetInstancesAtMaxVolume(int32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CVoiceContainerStaticAdditiveSynth->InstancesAtMaxVolume(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CVoiceContainerStaticAdditiveSynth", "m_nInstancesAtMaxVolume", false, value);
}
void* GCVoiceContainerStaticAdditiveSynth::GetPtr() {
    return m_ptr;
}
std::string GCVoiceContainerStaticAdditiveSynth::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCVoiceContainerStaticAdditiveSynth::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCVoiceContainerStaticAdditiveSynth(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCVoiceContainerStaticAdditiveSynth>("CVoiceContainerStaticAdditiveSynth")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("MinVolume", &GCVoiceContainerStaticAdditiveSynth::GetMinVolume, &GCVoiceContainerStaticAdditiveSynth::SetMinVolume)
        .addProperty("InstancesAtMinVolume", &GCVoiceContainerStaticAdditiveSynth::GetInstancesAtMinVolume, &GCVoiceContainerStaticAdditiveSynth::SetInstancesAtMinVolume)
        .addProperty("MaxVolume", &GCVoiceContainerStaticAdditiveSynth::GetMaxVolume, &GCVoiceContainerStaticAdditiveSynth::SetMaxVolume)
        .addProperty("InstancesAtMaxVolume", &GCVoiceContainerStaticAdditiveSynth::GetInstancesAtMaxVolume, &GCVoiceContainerStaticAdditiveSynth::SetInstancesAtMaxVolume)
        .addFunction("ToPtr", &GCVoiceContainerStaticAdditiveSynth::ToPtr)
        .addFunction("IsValid", &GCVoiceContainerStaticAdditiveSynth::IsValid)
        .endClass();
}
GRnSoftbodyCapsule_t::GRnSoftbodyCapsule_t(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GRnSoftbodyCapsule_t::GRnSoftbodyCapsule_t(void *ptr) {
    m_ptr = ptr;
}
std::vector<Vector> GRnSoftbodyCapsule_t::GetCenter() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: RnSoftbodyCapsule_t->Center(ptr=%p,size=2)", m_ptr));
    Vector* outValue = (Vector*)GetSchemaPtr(m_ptr, "RnSoftbodyCapsule_t", "m_vCenter"); std::vector<Vector> ret; for(int i = 0; i < 2; i++) { ret.push_back(outValue[i]); } return ret;
}
void GRnSoftbodyCapsule_t::SetCenter(std::vector<Vector> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: RnSoftbodyCapsule_t->Center(ptr=%p,size=2)", m_ptr));
    if(value.size() != 2) return PLUGIN_PRINT("Schema SDK", "Field 'Center' needs to have 2 values.\n");
    auto val = GetSchemaValuePtr<Vector>(m_ptr, "RnSoftbodyCapsule_t", "m_vCenter");
    for(size_t i = 0; i < value.size(); i++) val[i] = value[i];
}
float GRnSoftbodyCapsule_t::GetRadius() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: RnSoftbodyCapsule_t->Radius(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "RnSoftbodyCapsule_t", "m_flRadius");
}
void GRnSoftbodyCapsule_t::SetRadius(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: RnSoftbodyCapsule_t->Radius(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "RnSoftbodyCapsule_t", "m_flRadius", true, value);
}
std::vector<uint16_t> GRnSoftbodyCapsule_t::GetParticle() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: RnSoftbodyCapsule_t->Particle(ptr=%p,size=2)", m_ptr));
    uint16_t* outValue = (uint16_t*)GetSchemaPtr(m_ptr, "RnSoftbodyCapsule_t", "m_nParticle"); std::vector<uint16_t> ret; for(int i = 0; i < 2; i++) { ret.push_back(outValue[i]); } return ret;
}
void GRnSoftbodyCapsule_t::SetParticle(std::vector<uint16_t> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: RnSoftbodyCapsule_t->Particle(ptr=%p,size=2)", m_ptr));
    if(value.size() != 2) return PLUGIN_PRINT("Schema SDK", "Field 'Particle' needs to have 2 values.\n");
    auto val = GetSchemaValuePtr<uint16_t>(m_ptr, "RnSoftbodyCapsule_t", "m_nParticle");
    for(size_t i = 0; i < value.size(); i++) val[i] = value[i];
}
void* GRnSoftbodyCapsule_t::GetPtr() {
    return m_ptr;
}
std::string GRnSoftbodyCapsule_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GRnSoftbodyCapsule_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassRnSoftbodyCapsule_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GRnSoftbodyCapsule_t>("RnSoftbodyCapsule_t")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Center", &GRnSoftbodyCapsule_t::GetCenter, &GRnSoftbodyCapsule_t::SetCenter)
        .addProperty("Radius", &GRnSoftbodyCapsule_t::GetRadius, &GRnSoftbodyCapsule_t::SetRadius)
        .addProperty("Particle", &GRnSoftbodyCapsule_t::GetParticle, &GRnSoftbodyCapsule_t::SetParticle)
        .addFunction("ToPtr", &GRnSoftbodyCapsule_t::ToPtr)
        .addFunction("IsValid", &GRnSoftbodyCapsule_t::IsValid)
        .endClass();
}
GCModelConfigElement_RandomPick::GCModelConfigElement_RandomPick(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCModelConfigElement_RandomPick::GCModelConfigElement_RandomPick(void *ptr) {
    m_ptr = ptr;
}
std::vector<CUtlString> GCModelConfigElement_RandomPick::GetChoices() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CModelConfigElement_RandomPick->Choices(ptr=%p)", m_ptr));
    CUtlVector<CUtlString>* vec = GetSchemaValue<CUtlVector<CUtlString>*>(m_ptr, "CModelConfigElement_RandomPick", "m_Choices"); std::vector<CUtlString> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCModelConfigElement_RandomPick::SetChoices(std::vector<CUtlString> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CModelConfigElement_RandomPick->Choices(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<CUtlString>(m_ptr, "CModelConfigElement_RandomPick", "m_Choices", false, value);
}
std::vector<float32> GCModelConfigElement_RandomPick::GetChoiceWeights() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CModelConfigElement_RandomPick->ChoiceWeights(ptr=%p)", m_ptr));
    CUtlVector<float32>* vec = GetSchemaValue<CUtlVector<float32>*>(m_ptr, "CModelConfigElement_RandomPick", "m_ChoiceWeights"); std::vector<float32> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCModelConfigElement_RandomPick::SetChoiceWeights(std::vector<float32> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CModelConfigElement_RandomPick->ChoiceWeights(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<float32>(m_ptr, "CModelConfigElement_RandomPick", "m_ChoiceWeights", false, value);
}
void* GCModelConfigElement_RandomPick::GetPtr() {
    return m_ptr;
}
std::string GCModelConfigElement_RandomPick::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCModelConfigElement_RandomPick::IsValid() {
    return (m_ptr != nullptr);
}
GCModelConfigElement GCModelConfigElement_RandomPick::GetParent() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CModelConfigElement_RandomPick::GetParent(ptr=%p)", m_ptr));
    GCModelConfigElement value(m_ptr);
    return value;
}
void GCModelConfigElement_RandomPick::SetParent(GCModelConfigElement value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CModelConfigElement_RandomPick::SetParent(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCModelConfigElement_RandomPick(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCModelConfigElement_RandomPick>("CModelConfigElement_RandomPick")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Choices", &GCModelConfigElement_RandomPick::GetChoices, &GCModelConfigElement_RandomPick::SetChoices)
        .addProperty("ChoiceWeights", &GCModelConfigElement_RandomPick::GetChoiceWeights, &GCModelConfigElement_RandomPick::SetChoiceWeights)
        .addProperty("Parent", &GCModelConfigElement_RandomPick::GetParent, &GCModelConfigElement_RandomPick::SetParent)
        .addFunction("ToPtr", &GCModelConfigElement_RandomPick::ToPtr)
        .addFunction("IsValid", &GCModelConfigElement_RandomPick::IsValid)
        .endClass();
}
GNmSyncTrackTime_t::GNmSyncTrackTime_t(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GNmSyncTrackTime_t::GNmSyncTrackTime_t(void *ptr) {
    m_ptr = ptr;
}
int32_t GNmSyncTrackTime_t::GetEventIdx() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: NmSyncTrackTime_t->EventIdx(ptr=%p)", m_ptr));
    return GetSchemaValue<int32_t>(m_ptr, "NmSyncTrackTime_t", "m_nEventIdx");
}
void GNmSyncTrackTime_t::SetEventIdx(int32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: NmSyncTrackTime_t->EventIdx(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "NmSyncTrackTime_t", "m_nEventIdx", true, value);
}
GNmPercent_t GNmSyncTrackTime_t::GetPercentageThrough() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: NmSyncTrackTime_t->PercentageThrough(ptr=%p)", m_ptr));
    GNmPercent_t value(GetSchemaPtr(m_ptr, "NmSyncTrackTime_t", "m_percentageThrough"));
    return value;
}
void GNmSyncTrackTime_t::SetPercentageThrough(GNmPercent_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: NmSyncTrackTime_t->PercentageThrough(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'PercentageThrough' is not possible.\n");
}
void* GNmSyncTrackTime_t::GetPtr() {
    return m_ptr;
}
std::string GNmSyncTrackTime_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GNmSyncTrackTime_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassNmSyncTrackTime_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GNmSyncTrackTime_t>("NmSyncTrackTime_t")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("EventIdx", &GNmSyncTrackTime_t::GetEventIdx, &GNmSyncTrackTime_t::SetEventIdx)
        .addProperty("PercentageThrough", &GNmSyncTrackTime_t::GetPercentageThrough, &GNmSyncTrackTime_t::SetPercentageThrough)
        .addFunction("ToPtr", &GNmSyncTrackTime_t::ToPtr)
        .addFunction("IsValid", &GNmSyncTrackTime_t::IsValid)
        .endClass();
}
GCGeneralRandomRotation::GCGeneralRandomRotation(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCGeneralRandomRotation::GCGeneralRandomRotation(void *ptr) {
    m_ptr = ptr;
}
GParticleAttributeIndex_t GCGeneralRandomRotation::GetFieldOutput() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CGeneralRandomRotation->FieldOutput(ptr=%p)", m_ptr));
    GParticleAttributeIndex_t value(GetSchemaPtr(m_ptr, "CGeneralRandomRotation", "m_nFieldOutput"));
    return value;
}
void GCGeneralRandomRotation::SetFieldOutput(GParticleAttributeIndex_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CGeneralRandomRotation->FieldOutput(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'FieldOutput' is not possible.\n");
}
float GCGeneralRandomRotation::GetDegrees() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CGeneralRandomRotation->Degrees(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CGeneralRandomRotation", "m_flDegrees");
}
void GCGeneralRandomRotation::SetDegrees(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CGeneralRandomRotation->Degrees(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CGeneralRandomRotation", "m_flDegrees", false, value);
}
float GCGeneralRandomRotation::GetDegreesMin() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CGeneralRandomRotation->DegreesMin(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CGeneralRandomRotation", "m_flDegreesMin");
}
void GCGeneralRandomRotation::SetDegreesMin(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CGeneralRandomRotation->DegreesMin(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CGeneralRandomRotation", "m_flDegreesMin", false, value);
}
float GCGeneralRandomRotation::GetDegreesMax() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CGeneralRandomRotation->DegreesMax(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CGeneralRandomRotation", "m_flDegreesMax");
}
void GCGeneralRandomRotation::SetDegreesMax(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CGeneralRandomRotation->DegreesMax(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CGeneralRandomRotation", "m_flDegreesMax", false, value);
}
float GCGeneralRandomRotation::GetRotationRandExponent() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CGeneralRandomRotation->RotationRandExponent(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CGeneralRandomRotation", "m_flRotationRandExponent");
}
void GCGeneralRandomRotation::SetRotationRandExponent(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CGeneralRandomRotation->RotationRandExponent(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CGeneralRandomRotation", "m_flRotationRandExponent", false, value);
}
bool GCGeneralRandomRotation::GetRandomlyFlipDirection() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CGeneralRandomRotation->RandomlyFlipDirection(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "CGeneralRandomRotation", "m_bRandomlyFlipDirection");
}
void GCGeneralRandomRotation::SetRandomlyFlipDirection(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CGeneralRandomRotation->RandomlyFlipDirection(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CGeneralRandomRotation", "m_bRandomlyFlipDirection", false, value);
}
void* GCGeneralRandomRotation::GetPtr() {
    return m_ptr;
}
std::string GCGeneralRandomRotation::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCGeneralRandomRotation::IsValid() {
    return (m_ptr != nullptr);
}
GCParticleFunctionInitializer GCGeneralRandomRotation::GetParent() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CGeneralRandomRotation::GetParent(ptr=%p)", m_ptr));
    GCParticleFunctionInitializer value(m_ptr);
    return value;
}
void GCGeneralRandomRotation::SetParent(GCParticleFunctionInitializer value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CGeneralRandomRotation::SetParent(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCGeneralRandomRotation(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCGeneralRandomRotation>("CGeneralRandomRotation")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("FieldOutput", &GCGeneralRandomRotation::GetFieldOutput, &GCGeneralRandomRotation::SetFieldOutput)
        .addProperty("Degrees", &GCGeneralRandomRotation::GetDegrees, &GCGeneralRandomRotation::SetDegrees)
        .addProperty("DegreesMin", &GCGeneralRandomRotation::GetDegreesMin, &GCGeneralRandomRotation::SetDegreesMin)
        .addProperty("DegreesMax", &GCGeneralRandomRotation::GetDegreesMax, &GCGeneralRandomRotation::SetDegreesMax)
        .addProperty("RotationRandExponent", &GCGeneralRandomRotation::GetRotationRandExponent, &GCGeneralRandomRotation::SetRotationRandExponent)
        .addProperty("RandomlyFlipDirection", &GCGeneralRandomRotation::GetRandomlyFlipDirection, &GCGeneralRandomRotation::SetRandomlyFlipDirection)
        .addProperty("Parent", &GCGeneralRandomRotation::GetParent, &GCGeneralRandomRotation::SetParent)
        .addFunction("ToPtr", &GCGeneralRandomRotation::ToPtr)
        .addFunction("IsValid", &GCGeneralRandomRotation::IsValid)
        .endClass();
}
GRnPlane_t::GRnPlane_t(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GRnPlane_t::GRnPlane_t(void *ptr) {
    m_ptr = ptr;
}
Vector GRnPlane_t::GetNormal() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: RnPlane_t->Normal(ptr=%p)", m_ptr));
    return GetSchemaValue<Vector>(m_ptr, "RnPlane_t", "m_vNormal");
}
void GRnPlane_t::SetNormal(Vector value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: RnPlane_t->Normal(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "RnPlane_t", "m_vNormal", true, value);
}
float GRnPlane_t::GetOffset() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: RnPlane_t->Offset(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "RnPlane_t", "m_flOffset");
}
void GRnPlane_t::SetOffset(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: RnPlane_t->Offset(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "RnPlane_t", "m_flOffset", true, value);
}
void* GRnPlane_t::GetPtr() {
    return m_ptr;
}
std::string GRnPlane_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GRnPlane_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassRnPlane_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GRnPlane_t>("RnPlane_t")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Normal", &GRnPlane_t::GetNormal, &GRnPlane_t::SetNormal)
        .addProperty("Offset", &GRnPlane_t::GetOffset, &GRnPlane_t::SetOffset)
        .addFunction("ToPtr", &GRnPlane_t::ToPtr)
        .addFunction("IsValid", &GRnPlane_t::IsValid)
        .endClass();
}
GFeNodeWindBase_t::GFeNodeWindBase_t(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GFeNodeWindBase_t::GFeNodeWindBase_t(void *ptr) {
    m_ptr = ptr;
}
uint16_t GFeNodeWindBase_t::GetNodeX0() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FeNodeWindBase_t->NodeX0(ptr=%p)", m_ptr));
    return GetSchemaValue<uint16_t>(m_ptr, "FeNodeWindBase_t", "nNodeX0");
}
void GFeNodeWindBase_t::SetNodeX0(uint16_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FeNodeWindBase_t->NodeX0(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "FeNodeWindBase_t", "nNodeX0", true, value);
}
uint16_t GFeNodeWindBase_t::GetNodeX1() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FeNodeWindBase_t->NodeX1(ptr=%p)", m_ptr));
    return GetSchemaValue<uint16_t>(m_ptr, "FeNodeWindBase_t", "nNodeX1");
}
void GFeNodeWindBase_t::SetNodeX1(uint16_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FeNodeWindBase_t->NodeX1(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "FeNodeWindBase_t", "nNodeX1", true, value);
}
uint16_t GFeNodeWindBase_t::GetNodeY0() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FeNodeWindBase_t->NodeY0(ptr=%p)", m_ptr));
    return GetSchemaValue<uint16_t>(m_ptr, "FeNodeWindBase_t", "nNodeY0");
}
void GFeNodeWindBase_t::SetNodeY0(uint16_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FeNodeWindBase_t->NodeY0(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "FeNodeWindBase_t", "nNodeY0", true, value);
}
uint16_t GFeNodeWindBase_t::GetNodeY1() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FeNodeWindBase_t->NodeY1(ptr=%p)", m_ptr));
    return GetSchemaValue<uint16_t>(m_ptr, "FeNodeWindBase_t", "nNodeY1");
}
void GFeNodeWindBase_t::SetNodeY1(uint16_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FeNodeWindBase_t->NodeY1(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "FeNodeWindBase_t", "nNodeY1", true, value);
}
void* GFeNodeWindBase_t::GetPtr() {
    return m_ptr;
}
std::string GFeNodeWindBase_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GFeNodeWindBase_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassFeNodeWindBase_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GFeNodeWindBase_t>("FeNodeWindBase_t")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("NodeX0", &GFeNodeWindBase_t::GetNodeX0, &GFeNodeWindBase_t::SetNodeX0)
        .addProperty("NodeX1", &GFeNodeWindBase_t::GetNodeX1, &GFeNodeWindBase_t::SetNodeX1)
        .addProperty("NodeY0", &GFeNodeWindBase_t::GetNodeY0, &GFeNodeWindBase_t::SetNodeY0)
        .addProperty("NodeY1", &GFeNodeWindBase_t::GetNodeY1, &GFeNodeWindBase_t::SetNodeY1)
        .addFunction("ToPtr", &GFeNodeWindBase_t::ToPtr)
        .addFunction("IsValid", &GFeNodeWindBase_t::IsValid)
        .endClass();
}
GCQuaternionAnimParameter::GCQuaternionAnimParameter(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCQuaternionAnimParameter::GCQuaternionAnimParameter(void *ptr) {
    m_ptr = ptr;
}
bool GCQuaternionAnimParameter::GetInterpolate() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CQuaternionAnimParameter->Interpolate(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "CQuaternionAnimParameter", "m_bInterpolate");
}
void GCQuaternionAnimParameter::SetInterpolate(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CQuaternionAnimParameter->Interpolate(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CQuaternionAnimParameter", "m_bInterpolate", false, value);
}
void* GCQuaternionAnimParameter::GetPtr() {
    return m_ptr;
}
std::string GCQuaternionAnimParameter::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCQuaternionAnimParameter::IsValid() {
    return (m_ptr != nullptr);
}
GCConcreteAnimParameter GCQuaternionAnimParameter::GetParent() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CQuaternionAnimParameter::GetParent(ptr=%p)", m_ptr));
    GCConcreteAnimParameter value(m_ptr);
    return value;
}
void GCQuaternionAnimParameter::SetParent(GCConcreteAnimParameter value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CQuaternionAnimParameter::SetParent(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCQuaternionAnimParameter(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCQuaternionAnimParameter>("CQuaternionAnimParameter")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Interpolate", &GCQuaternionAnimParameter::GetInterpolate, &GCQuaternionAnimParameter::SetInterpolate)
        .addProperty("Parent", &GCQuaternionAnimParameter::GetParent, &GCQuaternionAnimParameter::SetParent)
        .addFunction("ToPtr", &GCQuaternionAnimParameter::ToPtr)
        .addFunction("IsValid", &GCQuaternionAnimParameter::IsValid)
        .endClass();
}
GSkeletonAnimCapture_t__Camera_t::GSkeletonAnimCapture_t__Camera_t(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GSkeletonAnimCapture_t__Camera_t::GSkeletonAnimCapture_t__Camera_t(void *ptr) {
    m_ptr = ptr;
}
float GSkeletonAnimCapture_t__Camera_t::GetTime() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: SkeletonAnimCapture_t__Camera_t->Time(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "SkeletonAnimCapture_t__Camera_t", "m_flTime");
}
void GSkeletonAnimCapture_t__Camera_t::SetTime(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: SkeletonAnimCapture_t__Camera_t->Time(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "SkeletonAnimCapture_t__Camera_t", "m_flTime", true, value);
}
void* GSkeletonAnimCapture_t__Camera_t::GetPtr() {
    return m_ptr;
}
std::string GSkeletonAnimCapture_t__Camera_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GSkeletonAnimCapture_t__Camera_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassSkeletonAnimCapture_t__Camera_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GSkeletonAnimCapture_t__Camera_t>("SkeletonAnimCapture_t__Camera_t")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Time", &GSkeletonAnimCapture_t__Camera_t::GetTime, &GSkeletonAnimCapture_t__Camera_t::SetTime)
        .addFunction("ToPtr", &GSkeletonAnimCapture_t__Camera_t::ToPtr)
        .addFunction("IsValid", &GSkeletonAnimCapture_t__Camera_t::IsValid)
        .endClass();
}
GCAnimEncodeDifference::GCAnimEncodeDifference(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCAnimEncodeDifference::GCAnimEncodeDifference(void *ptr) {
    m_ptr = ptr;
}
std::vector<GCAnimBoneDifference> GCAnimEncodeDifference::GetBoneArray() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CAnimEncodeDifference->BoneArray(ptr=%p)", m_ptr));
    CUtlVector<GCAnimBoneDifference>* vec = GetSchemaValue<CUtlVector<GCAnimBoneDifference>*>(m_ptr, "CAnimEncodeDifference", "m_boneArray"); std::vector<GCAnimBoneDifference> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCAnimEncodeDifference::SetBoneArray(std::vector<GCAnimBoneDifference> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CAnimEncodeDifference->BoneArray(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<GCAnimBoneDifference>(m_ptr, "CAnimEncodeDifference", "m_boneArray", false, value);
}
std::vector<GCAnimMorphDifference> GCAnimEncodeDifference::GetMorphArray() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CAnimEncodeDifference->MorphArray(ptr=%p)", m_ptr));
    CUtlVector<GCAnimMorphDifference>* vec = GetSchemaValue<CUtlVector<GCAnimMorphDifference>*>(m_ptr, "CAnimEncodeDifference", "m_morphArray"); std::vector<GCAnimMorphDifference> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCAnimEncodeDifference::SetMorphArray(std::vector<GCAnimMorphDifference> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CAnimEncodeDifference->MorphArray(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<GCAnimMorphDifference>(m_ptr, "CAnimEncodeDifference", "m_morphArray", false, value);
}
std::vector<GCAnimUserDifference> GCAnimEncodeDifference::GetUserArray() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CAnimEncodeDifference->UserArray(ptr=%p)", m_ptr));
    CUtlVector<GCAnimUserDifference>* vec = GetSchemaValue<CUtlVector<GCAnimUserDifference>*>(m_ptr, "CAnimEncodeDifference", "m_userArray"); std::vector<GCAnimUserDifference> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCAnimEncodeDifference::SetUserArray(std::vector<GCAnimUserDifference> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CAnimEncodeDifference->UserArray(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<GCAnimUserDifference>(m_ptr, "CAnimEncodeDifference", "m_userArray", false, value);
}
std::vector<uint8> GCAnimEncodeDifference::GetHasRotationBitArray() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CAnimEncodeDifference->HasRotationBitArray(ptr=%p)", m_ptr));
    CUtlVector<uint8>* vec = GetSchemaValue<CUtlVector<uint8>*>(m_ptr, "CAnimEncodeDifference", "m_bHasRotationBitArray"); std::vector<uint8> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCAnimEncodeDifference::SetHasRotationBitArray(std::vector<uint8> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CAnimEncodeDifference->HasRotationBitArray(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<uint8>(m_ptr, "CAnimEncodeDifference", "m_bHasRotationBitArray", false, value);
}
std::vector<uint8> GCAnimEncodeDifference::GetHasMovementBitArray() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CAnimEncodeDifference->HasMovementBitArray(ptr=%p)", m_ptr));
    CUtlVector<uint8>* vec = GetSchemaValue<CUtlVector<uint8>*>(m_ptr, "CAnimEncodeDifference", "m_bHasMovementBitArray"); std::vector<uint8> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCAnimEncodeDifference::SetHasMovementBitArray(std::vector<uint8> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CAnimEncodeDifference->HasMovementBitArray(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<uint8>(m_ptr, "CAnimEncodeDifference", "m_bHasMovementBitArray", false, value);
}
std::vector<uint8> GCAnimEncodeDifference::GetHasMorphBitArray() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CAnimEncodeDifference->HasMorphBitArray(ptr=%p)", m_ptr));
    CUtlVector<uint8>* vec = GetSchemaValue<CUtlVector<uint8>*>(m_ptr, "CAnimEncodeDifference", "m_bHasMorphBitArray"); std::vector<uint8> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCAnimEncodeDifference::SetHasMorphBitArray(std::vector<uint8> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CAnimEncodeDifference->HasMorphBitArray(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<uint8>(m_ptr, "CAnimEncodeDifference", "m_bHasMorphBitArray", false, value);
}
std::vector<uint8> GCAnimEncodeDifference::GetHasUserBitArray() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CAnimEncodeDifference->HasUserBitArray(ptr=%p)", m_ptr));
    CUtlVector<uint8>* vec = GetSchemaValue<CUtlVector<uint8>*>(m_ptr, "CAnimEncodeDifference", "m_bHasUserBitArray"); std::vector<uint8> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCAnimEncodeDifference::SetHasUserBitArray(std::vector<uint8> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CAnimEncodeDifference->HasUserBitArray(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<uint8>(m_ptr, "CAnimEncodeDifference", "m_bHasUserBitArray", false, value);
}
void* GCAnimEncodeDifference::GetPtr() {
    return m_ptr;
}
std::string GCAnimEncodeDifference::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCAnimEncodeDifference::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCAnimEncodeDifference(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCAnimEncodeDifference>("CAnimEncodeDifference")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("BoneArray", &GCAnimEncodeDifference::GetBoneArray, &GCAnimEncodeDifference::SetBoneArray)
        .addProperty("MorphArray", &GCAnimEncodeDifference::GetMorphArray, &GCAnimEncodeDifference::SetMorphArray)
        .addProperty("UserArray", &GCAnimEncodeDifference::GetUserArray, &GCAnimEncodeDifference::SetUserArray)
        .addProperty("HasRotationBitArray", &GCAnimEncodeDifference::GetHasRotationBitArray, &GCAnimEncodeDifference::SetHasRotationBitArray)
        .addProperty("HasMovementBitArray", &GCAnimEncodeDifference::GetHasMovementBitArray, &GCAnimEncodeDifference::SetHasMovementBitArray)
        .addProperty("HasMorphBitArray", &GCAnimEncodeDifference::GetHasMorphBitArray, &GCAnimEncodeDifference::SetHasMorphBitArray)
        .addProperty("HasUserBitArray", &GCAnimEncodeDifference::GetHasUserBitArray, &GCAnimEncodeDifference::SetHasUserBitArray)
        .addFunction("ToPtr", &GCAnimEncodeDifference::ToPtr)
        .addFunction("IsValid", &GCAnimEncodeDifference::IsValid)
        .endClass();
}
GAggregateSceneObject_t::GAggregateSceneObject_t(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GAggregateSceneObject_t::GAggregateSceneObject_t(void *ptr) {
    m_ptr = ptr;
}
uint64_t GAggregateSceneObject_t::GetAllFlags() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: AggregateSceneObject_t->AllFlags(ptr=%p)", m_ptr));
    return GetSchemaValue<uint64_t>(m_ptr, "AggregateSceneObject_t", "m_allFlags");
}
void GAggregateSceneObject_t::SetAllFlags(uint64_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: AggregateSceneObject_t->AllFlags(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "AggregateSceneObject_t", "m_allFlags", true, value);
}
uint64_t GAggregateSceneObject_t::GetAnyFlags() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: AggregateSceneObject_t->AnyFlags(ptr=%p)", m_ptr));
    return GetSchemaValue<uint64_t>(m_ptr, "AggregateSceneObject_t", "m_anyFlags");
}
void GAggregateSceneObject_t::SetAnyFlags(uint64_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: AggregateSceneObject_t->AnyFlags(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "AggregateSceneObject_t", "m_anyFlags", true, value);
}
int16_t GAggregateSceneObject_t::GetLayer() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: AggregateSceneObject_t->Layer(ptr=%p)", m_ptr));
    return GetSchemaValue<int16_t>(m_ptr, "AggregateSceneObject_t", "m_nLayer");
}
void GAggregateSceneObject_t::SetLayer(int16_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: AggregateSceneObject_t->Layer(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "AggregateSceneObject_t", "m_nLayer", true, value);
}
std::vector<GAggregateMeshInfo_t> GAggregateSceneObject_t::GetAggregateMeshes() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: AggregateSceneObject_t->AggregateMeshes(ptr=%p)", m_ptr));
    CUtlVector<GAggregateMeshInfo_t>* vec = GetSchemaValue<CUtlVector<GAggregateMeshInfo_t>*>(m_ptr, "AggregateSceneObject_t", "m_aggregateMeshes"); std::vector<GAggregateMeshInfo_t> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GAggregateSceneObject_t::SetAggregateMeshes(std::vector<GAggregateMeshInfo_t> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: AggregateSceneObject_t->AggregateMeshes(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<GAggregateMeshInfo_t>(m_ptr, "AggregateSceneObject_t", "m_aggregateMeshes", true, value);
}
std::vector<GAggregateLODSetup_t> GAggregateSceneObject_t::GetLodSetups() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: AggregateSceneObject_t->LodSetups(ptr=%p)", m_ptr));
    CUtlVector<GAggregateLODSetup_t>* vec = GetSchemaValue<CUtlVector<GAggregateLODSetup_t>*>(m_ptr, "AggregateSceneObject_t", "m_lodSetups"); std::vector<GAggregateLODSetup_t> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GAggregateSceneObject_t::SetLodSetups(std::vector<GAggregateLODSetup_t> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: AggregateSceneObject_t->LodSetups(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<GAggregateLODSetup_t>(m_ptr, "AggregateSceneObject_t", "m_lodSetups", true, value);
}
std::vector<uint16> GAggregateSceneObject_t::GetVisClusterMembership() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: AggregateSceneObject_t->VisClusterMembership(ptr=%p)", m_ptr));
    CUtlVector<uint16>* vec = GetSchemaValue<CUtlVector<uint16>*>(m_ptr, "AggregateSceneObject_t", "m_visClusterMembership"); std::vector<uint16> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GAggregateSceneObject_t::SetVisClusterMembership(std::vector<uint16> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: AggregateSceneObject_t->VisClusterMembership(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<uint16>(m_ptr, "AggregateSceneObject_t", "m_visClusterMembership", true, value);
}
void* GAggregateSceneObject_t::GetPtr() {
    return m_ptr;
}
std::string GAggregateSceneObject_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GAggregateSceneObject_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassAggregateSceneObject_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GAggregateSceneObject_t>("AggregateSceneObject_t")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("AllFlags", &GAggregateSceneObject_t::GetAllFlags, &GAggregateSceneObject_t::SetAllFlags)
        .addProperty("AnyFlags", &GAggregateSceneObject_t::GetAnyFlags, &GAggregateSceneObject_t::SetAnyFlags)
        .addProperty("Layer", &GAggregateSceneObject_t::GetLayer, &GAggregateSceneObject_t::SetLayer)
        .addProperty("AggregateMeshes", &GAggregateSceneObject_t::GetAggregateMeshes, &GAggregateSceneObject_t::SetAggregateMeshes)
        .addProperty("LodSetups", &GAggregateSceneObject_t::GetLodSetups, &GAggregateSceneObject_t::SetLodSetups)
        .addProperty("VisClusterMembership", &GAggregateSceneObject_t::GetVisClusterMembership, &GAggregateSceneObject_t::SetVisClusterMembership)
        .addFunction("ToPtr", &GAggregateSceneObject_t::ToPtr)
        .addFunction("IsValid", &GAggregateSceneObject_t::IsValid)
        .endClass();
}
GIKDemoCaptureSettings_t::GIKDemoCaptureSettings_t(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GIKDemoCaptureSettings_t::GIKDemoCaptureSettings_t(void *ptr) {
    m_ptr = ptr;
}
std::string GIKDemoCaptureSettings_t::GetParentBoneName() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: IKDemoCaptureSettings_t->ParentBoneName(ptr=%p)", m_ptr));
    return GetSchemaValue<CUtlString>(m_ptr, "IKDemoCaptureSettings_t", "m_parentBoneName").Get();
}
void GIKDemoCaptureSettings_t::SetParentBoneName(std::string value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: IKDemoCaptureSettings_t->ParentBoneName(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "IKDemoCaptureSettings_t", "m_parentBoneName", true, CUtlString(value.c_str()));
}
uint64_t GIKDemoCaptureSettings_t::GetMode() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: IKDemoCaptureSettings_t->Mode(ptr=%p)", m_ptr));
    return GetSchemaValue<uint64_t>(m_ptr, "IKDemoCaptureSettings_t", "m_eMode");
}
void GIKDemoCaptureSettings_t::SetMode(uint64_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: IKDemoCaptureSettings_t->Mode(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "IKDemoCaptureSettings_t", "m_eMode", true, value);
}
std::string GIKDemoCaptureSettings_t::GetIkChainName() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: IKDemoCaptureSettings_t->IkChainName(ptr=%p)", m_ptr));
    return GetSchemaValue<CUtlString>(m_ptr, "IKDemoCaptureSettings_t", "m_ikChainName").Get();
}
void GIKDemoCaptureSettings_t::SetIkChainName(std::string value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: IKDemoCaptureSettings_t->IkChainName(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "IKDemoCaptureSettings_t", "m_ikChainName", true, CUtlString(value.c_str()));
}
std::string GIKDemoCaptureSettings_t::GetOneBoneStart() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: IKDemoCaptureSettings_t->OneBoneStart(ptr=%p)", m_ptr));
    return GetSchemaValue<CUtlString>(m_ptr, "IKDemoCaptureSettings_t", "m_oneBoneStart").Get();
}
void GIKDemoCaptureSettings_t::SetOneBoneStart(std::string value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: IKDemoCaptureSettings_t->OneBoneStart(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "IKDemoCaptureSettings_t", "m_oneBoneStart", true, CUtlString(value.c_str()));
}
std::string GIKDemoCaptureSettings_t::GetOneBoneEnd() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: IKDemoCaptureSettings_t->OneBoneEnd(ptr=%p)", m_ptr));
    return GetSchemaValue<CUtlString>(m_ptr, "IKDemoCaptureSettings_t", "m_oneBoneEnd").Get();
}
void GIKDemoCaptureSettings_t::SetOneBoneEnd(std::string value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: IKDemoCaptureSettings_t->OneBoneEnd(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "IKDemoCaptureSettings_t", "m_oneBoneEnd", true, CUtlString(value.c_str()));
}
void* GIKDemoCaptureSettings_t::GetPtr() {
    return m_ptr;
}
std::string GIKDemoCaptureSettings_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GIKDemoCaptureSettings_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassIKDemoCaptureSettings_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GIKDemoCaptureSettings_t>("IKDemoCaptureSettings_t")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("ParentBoneName", &GIKDemoCaptureSettings_t::GetParentBoneName, &GIKDemoCaptureSettings_t::SetParentBoneName)
        .addProperty("Mode", &GIKDemoCaptureSettings_t::GetMode, &GIKDemoCaptureSettings_t::SetMode)
        .addProperty("IkChainName", &GIKDemoCaptureSettings_t::GetIkChainName, &GIKDemoCaptureSettings_t::SetIkChainName)
        .addProperty("OneBoneStart", &GIKDemoCaptureSettings_t::GetOneBoneStart, &GIKDemoCaptureSettings_t::SetOneBoneStart)
        .addProperty("OneBoneEnd", &GIKDemoCaptureSettings_t::GetOneBoneEnd, &GIKDemoCaptureSettings_t::SetOneBoneEnd)
        .addFunction("ToPtr", &GIKDemoCaptureSettings_t::ToPtr)
        .addFunction("IsValid", &GIKDemoCaptureSettings_t::IsValid)
        .endClass();
}
GCParticleCollectionBindingInstance::GCParticleCollectionBindingInstance(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCParticleCollectionBindingInstance::GCParticleCollectionBindingInstance(void *ptr) {
    m_ptr = ptr;
}
void* GCParticleCollectionBindingInstance::GetPtr() {
    return m_ptr;
}
std::string GCParticleCollectionBindingInstance::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCParticleCollectionBindingInstance::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCParticleCollectionBindingInstance(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCParticleCollectionBindingInstance>("CParticleCollectionBindingInstance")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addFunction("ToPtr", &GCParticleCollectionBindingInstance::ToPtr)
        .addFunction("IsValid", &GCParticleCollectionBindingInstance::IsValid)
        .endClass();
}
GCVoiceContainerDefault::GCVoiceContainerDefault(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCVoiceContainerDefault::GCVoiceContainerDefault(void *ptr) {
    m_ptr = ptr;
}
void* GCVoiceContainerDefault::GetPtr() {
    return m_ptr;
}
std::string GCVoiceContainerDefault::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCVoiceContainerDefault::IsValid() {
    return (m_ptr != nullptr);
}
GCVoiceContainerBase GCVoiceContainerDefault::GetParent() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CVoiceContainerDefault::GetParent(ptr=%p)", m_ptr));
    GCVoiceContainerBase value(m_ptr);
    return value;
}
void GCVoiceContainerDefault::SetParent(GCVoiceContainerBase value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CVoiceContainerDefault::SetParent(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCVoiceContainerDefault(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCVoiceContainerDefault>("CVoiceContainerDefault")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Parent", &GCVoiceContainerDefault::GetParent, &GCVoiceContainerDefault::SetParent)
        .addFunction("ToPtr", &GCVoiceContainerDefault::ToPtr)
        .addFunction("IsValid", &GCVoiceContainerDefault::IsValid)
        .endClass();
}
GCSoundEventMetaData::GCSoundEventMetaData(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCSoundEventMetaData::GCSoundEventMetaData(void *ptr) {
    m_ptr = ptr;
}
void* GCSoundEventMetaData::GetPtr() {
    return m_ptr;
}
std::string GCSoundEventMetaData::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCSoundEventMetaData::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCSoundEventMetaData(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCSoundEventMetaData>("CSoundEventMetaData")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addFunction("ToPtr", &GCSoundEventMetaData::ToPtr)
        .addFunction("IsValid", &GCSoundEventMetaData::IsValid)
        .endClass();
}
GCMorphConstraint::GCMorphConstraint(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCMorphConstraint::GCMorphConstraint(void *ptr) {
    m_ptr = ptr;
}
std::string GCMorphConstraint::GetTargetMorph() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CMorphConstraint->TargetMorph(ptr=%p)", m_ptr));
    return GetSchemaValue<CUtlString>(m_ptr, "CMorphConstraint", "m_sTargetMorph").Get();
}
void GCMorphConstraint::SetTargetMorph(std::string value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CMorphConstraint->TargetMorph(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CMorphConstraint", "m_sTargetMorph", false, CUtlString(value.c_str()));
}
int32_t GCMorphConstraint::GetSlaveChannel() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CMorphConstraint->SlaveChannel(ptr=%p)", m_ptr));
    return GetSchemaValue<int32_t>(m_ptr, "CMorphConstraint", "m_nSlaveChannel");
}
void GCMorphConstraint::SetSlaveChannel(int32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CMorphConstraint->SlaveChannel(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CMorphConstraint", "m_nSlaveChannel", false, value);
}
float GCMorphConstraint::GetMin() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CMorphConstraint->Min(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CMorphConstraint", "m_flMin");
}
void GCMorphConstraint::SetMin(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CMorphConstraint->Min(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CMorphConstraint", "m_flMin", false, value);
}
float GCMorphConstraint::GetMax() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CMorphConstraint->Max(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CMorphConstraint", "m_flMax");
}
void GCMorphConstraint::SetMax(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CMorphConstraint->Max(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CMorphConstraint", "m_flMax", false, value);
}
void* GCMorphConstraint::GetPtr() {
    return m_ptr;
}
std::string GCMorphConstraint::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCMorphConstraint::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseConstraint GCMorphConstraint::GetParent() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CMorphConstraint::GetParent(ptr=%p)", m_ptr));
    GCBaseConstraint value(m_ptr);
    return value;
}
void GCMorphConstraint::SetParent(GCBaseConstraint value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CMorphConstraint::SetParent(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCMorphConstraint(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCMorphConstraint>("CMorphConstraint")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("TargetMorph", &GCMorphConstraint::GetTargetMorph, &GCMorphConstraint::SetTargetMorph)
        .addProperty("SlaveChannel", &GCMorphConstraint::GetSlaveChannel, &GCMorphConstraint::SetSlaveChannel)
        .addProperty("Min", &GCMorphConstraint::GetMin, &GCMorphConstraint::SetMin)
        .addProperty("Max", &GCMorphConstraint::GetMax, &GCMorphConstraint::SetMax)
        .addProperty("Parent", &GCMorphConstraint::GetParent, &GCMorphConstraint::SetParent)
        .addFunction("ToPtr", &GCMorphConstraint::ToPtr)
        .addFunction("IsValid", &GCMorphConstraint::IsValid)
        .endClass();
}
GDop26_t::GDop26_t(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GDop26_t::GDop26_t(void *ptr) {
    m_ptr = ptr;
}
std::vector<float> GDop26_t::GetSupport() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: Dop26_t->Support(ptr=%p,size=26)", m_ptr));
    float* outValue = (float*)GetSchemaPtr(m_ptr, "Dop26_t", "m_flSupport"); std::vector<float> ret; for(int i = 0; i < 26; i++) { ret.push_back(outValue[i]); } return ret;
}
void GDop26_t::SetSupport(std::vector<float> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: Dop26_t->Support(ptr=%p,size=26)", m_ptr));
    if(value.size() != 26) return PLUGIN_PRINT("Schema SDK", "Field 'Support' needs to have 26 values.\n");
    auto val = GetSchemaValuePtr<float>(m_ptr, "Dop26_t", "m_flSupport");
    for(size_t i = 0; i < value.size(); i++) val[i] = value[i];
}
void* GDop26_t::GetPtr() {
    return m_ptr;
}
std::string GDop26_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GDop26_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassDop26_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GDop26_t>("Dop26_t")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Support", &GDop26_t::GetSupport, &GDop26_t::SetSupport)
        .addFunction("ToPtr", &GDop26_t::ToPtr)
        .addFunction("IsValid", &GDop26_t::IsValid)
        .endClass();
}
GCAnimGraphModelBinding::GCAnimGraphModelBinding(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCAnimGraphModelBinding::GCAnimGraphModelBinding(void *ptr) {
    m_ptr = ptr;
}
std::string GCAnimGraphModelBinding::GetModelName() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CAnimGraphModelBinding->ModelName(ptr=%p)", m_ptr));
    return GetSchemaValue<CUtlString>(m_ptr, "CAnimGraphModelBinding", "m_modelName").Get();
}
void GCAnimGraphModelBinding::SetModelName(std::string value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CAnimGraphModelBinding->ModelName(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CAnimGraphModelBinding", "m_modelName", false, CUtlString(value.c_str()));
}
void* GCAnimGraphModelBinding::GetPtr() {
    return m_ptr;
}
std::string GCAnimGraphModelBinding::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCAnimGraphModelBinding::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCAnimGraphModelBinding(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCAnimGraphModelBinding>("CAnimGraphModelBinding")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("ModelName", &GCAnimGraphModelBinding::GetModelName, &GCAnimGraphModelBinding::SetModelName)
        .addFunction("ToPtr", &GCAnimGraphModelBinding::ToPtr)
        .addFunction("IsValid", &GCAnimGraphModelBinding::IsValid)
        .endClass();
}
GFakeEntityDerivedA_tAPI::GFakeEntityDerivedA_tAPI(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GFakeEntityDerivedA_tAPI::GFakeEntityDerivedA_tAPI(void *ptr) {
    m_ptr = ptr;
}
void* GFakeEntityDerivedA_tAPI::GetPtr() {
    return m_ptr;
}
std::string GFakeEntityDerivedA_tAPI::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GFakeEntityDerivedA_tAPI::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassFakeEntityDerivedA_tAPI(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GFakeEntityDerivedA_tAPI>("FakeEntityDerivedA_tAPI")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addFunction("ToPtr", &GFakeEntityDerivedA_tAPI::ToPtr)
        .addFunction("IsValid", &GFakeEntityDerivedA_tAPI::IsValid)
        .endClass();
}
GCAnimParamHandleMap::GCAnimParamHandleMap(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCAnimParamHandleMap::GCAnimParamHandleMap(void *ptr) {
    m_ptr = ptr;
}
void* GCAnimParamHandleMap::GetPtr() {
    return m_ptr;
}
std::string GCAnimParamHandleMap::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCAnimParamHandleMap::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCAnimParamHandleMap(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCAnimParamHandleMap>("CAnimParamHandleMap")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addFunction("ToPtr", &GCAnimParamHandleMap::ToPtr)
        .addFunction("IsValid", &GCAnimParamHandleMap::IsValid)
        .endClass();
}
GFeMorphLayerDepr_t::GFeMorphLayerDepr_t(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GFeMorphLayerDepr_t::GFeMorphLayerDepr_t(void *ptr) {
    m_ptr = ptr;
}
std::string GFeMorphLayerDepr_t::GetName() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FeMorphLayerDepr_t->Name(ptr=%p)", m_ptr));
    return GetSchemaValue<CUtlString>(m_ptr, "FeMorphLayerDepr_t", "m_Name").Get();
}
void GFeMorphLayerDepr_t::SetName(std::string value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FeMorphLayerDepr_t->Name(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "FeMorphLayerDepr_t", "m_Name", true, CUtlString(value.c_str()));
}
uint32_t GFeMorphLayerDepr_t::GetNameHash() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FeMorphLayerDepr_t->NameHash(ptr=%p)", m_ptr));
    return GetSchemaValue<uint32_t>(m_ptr, "FeMorphLayerDepr_t", "m_nNameHash");
}
void GFeMorphLayerDepr_t::SetNameHash(uint32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FeMorphLayerDepr_t->NameHash(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "FeMorphLayerDepr_t", "m_nNameHash", true, value);
}
std::vector<uint16> GFeMorphLayerDepr_t::GetNodes() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FeMorphLayerDepr_t->Nodes(ptr=%p)", m_ptr));
    CUtlVector<uint16>* vec = GetSchemaValue<CUtlVector<uint16>*>(m_ptr, "FeMorphLayerDepr_t", "m_Nodes"); std::vector<uint16> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GFeMorphLayerDepr_t::SetNodes(std::vector<uint16> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FeMorphLayerDepr_t->Nodes(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<uint16>(m_ptr, "FeMorphLayerDepr_t", "m_Nodes", true, value);
}
std::vector<Vector> GFeMorphLayerDepr_t::GetInitPos() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FeMorphLayerDepr_t->InitPos(ptr=%p)", m_ptr));
    CUtlVector<Vector>* vec = GetSchemaValue<CUtlVector<Vector>*>(m_ptr, "FeMorphLayerDepr_t", "m_InitPos"); std::vector<Vector> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GFeMorphLayerDepr_t::SetInitPos(std::vector<Vector> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FeMorphLayerDepr_t->InitPos(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<Vector>(m_ptr, "FeMorphLayerDepr_t", "m_InitPos", true, value);
}
std::vector<float32> GFeMorphLayerDepr_t::GetGravity() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FeMorphLayerDepr_t->Gravity(ptr=%p)", m_ptr));
    CUtlVector<float32>* vec = GetSchemaValue<CUtlVector<float32>*>(m_ptr, "FeMorphLayerDepr_t", "m_Gravity"); std::vector<float32> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GFeMorphLayerDepr_t::SetGravity(std::vector<float32> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FeMorphLayerDepr_t->Gravity(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<float32>(m_ptr, "FeMorphLayerDepr_t", "m_Gravity", true, value);
}
std::vector<float32> GFeMorphLayerDepr_t::GetGoalStrength() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FeMorphLayerDepr_t->GoalStrength(ptr=%p)", m_ptr));
    CUtlVector<float32>* vec = GetSchemaValue<CUtlVector<float32>*>(m_ptr, "FeMorphLayerDepr_t", "m_GoalStrength"); std::vector<float32> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GFeMorphLayerDepr_t::SetGoalStrength(std::vector<float32> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FeMorphLayerDepr_t->GoalStrength(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<float32>(m_ptr, "FeMorphLayerDepr_t", "m_GoalStrength", true, value);
}
std::vector<float32> GFeMorphLayerDepr_t::GetGoalDamping() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FeMorphLayerDepr_t->GoalDamping(ptr=%p)", m_ptr));
    CUtlVector<float32>* vec = GetSchemaValue<CUtlVector<float32>*>(m_ptr, "FeMorphLayerDepr_t", "m_GoalDamping"); std::vector<float32> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GFeMorphLayerDepr_t::SetGoalDamping(std::vector<float32> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FeMorphLayerDepr_t->GoalDamping(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<float32>(m_ptr, "FeMorphLayerDepr_t", "m_GoalDamping", true, value);
}
uint32_t GFeMorphLayerDepr_t::GetFlags() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FeMorphLayerDepr_t->Flags(ptr=%p)", m_ptr));
    return GetSchemaValue<uint32_t>(m_ptr, "FeMorphLayerDepr_t", "m_nFlags");
}
void GFeMorphLayerDepr_t::SetFlags(uint32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FeMorphLayerDepr_t->Flags(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "FeMorphLayerDepr_t", "m_nFlags", true, value);
}
void* GFeMorphLayerDepr_t::GetPtr() {
    return m_ptr;
}
std::string GFeMorphLayerDepr_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GFeMorphLayerDepr_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassFeMorphLayerDepr_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GFeMorphLayerDepr_t>("FeMorphLayerDepr_t")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Name", &GFeMorphLayerDepr_t::GetName, &GFeMorphLayerDepr_t::SetName)
        .addProperty("NameHash", &GFeMorphLayerDepr_t::GetNameHash, &GFeMorphLayerDepr_t::SetNameHash)
        .addProperty("Nodes", &GFeMorphLayerDepr_t::GetNodes, &GFeMorphLayerDepr_t::SetNodes)
        .addProperty("InitPos", &GFeMorphLayerDepr_t::GetInitPos, &GFeMorphLayerDepr_t::SetInitPos)
        .addProperty("Gravity", &GFeMorphLayerDepr_t::GetGravity, &GFeMorphLayerDepr_t::SetGravity)
        .addProperty("GoalStrength", &GFeMorphLayerDepr_t::GetGoalStrength, &GFeMorphLayerDepr_t::SetGoalStrength)
        .addProperty("GoalDamping", &GFeMorphLayerDepr_t::GetGoalDamping, &GFeMorphLayerDepr_t::SetGoalDamping)
        .addProperty("Flags", &GFeMorphLayerDepr_t::GetFlags, &GFeMorphLayerDepr_t::SetFlags)
        .addFunction("ToPtr", &GFeMorphLayerDepr_t::ToPtr)
        .addFunction("IsValid", &GFeMorphLayerDepr_t::IsValid)
        .endClass();
}
GFourCovMatrices3::GFourCovMatrices3(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GFourCovMatrices3::GFourCovMatrices3(void *ptr) {
    m_ptr = ptr;
}
float GFourCovMatrices3::GetXY() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FourCovMatrices3->XY(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "FourCovMatrices3", "m_flXY");
}
void GFourCovMatrices3::SetXY(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FourCovMatrices3->XY(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "FourCovMatrices3", "m_flXY", false, value);
}
float GFourCovMatrices3::GetXZ() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FourCovMatrices3->XZ(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "FourCovMatrices3", "m_flXZ");
}
void GFourCovMatrices3::SetXZ(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FourCovMatrices3->XZ(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "FourCovMatrices3", "m_flXZ", false, value);
}
float GFourCovMatrices3::GetYZ() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FourCovMatrices3->YZ(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "FourCovMatrices3", "m_flYZ");
}
void GFourCovMatrices3::SetYZ(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FourCovMatrices3->YZ(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "FourCovMatrices3", "m_flYZ", false, value);
}
void* GFourCovMatrices3::GetPtr() {
    return m_ptr;
}
std::string GFourCovMatrices3::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GFourCovMatrices3::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassFourCovMatrices3(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GFourCovMatrices3>("FourCovMatrices3")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("XY", &GFourCovMatrices3::GetXY, &GFourCovMatrices3::SetXY)
        .addProperty("XZ", &GFourCovMatrices3::GetXZ, &GFourCovMatrices3::SetXZ)
        .addProperty("YZ", &GFourCovMatrices3::GetYZ, &GFourCovMatrices3::SetYZ)
        .addFunction("ToPtr", &GFourCovMatrices3::ToPtr)
        .addFunction("IsValid", &GFourCovMatrices3::IsValid)
        .endClass();
}
GFeFitMatrix_t::GFeFitMatrix_t(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GFeFitMatrix_t::GFeFitMatrix_t(void *ptr) {
    m_ptr = ptr;
}
Vector GFeFitMatrix_t::GetCenter() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FeFitMatrix_t->Center(ptr=%p)", m_ptr));
    return GetSchemaValue<Vector>(m_ptr, "FeFitMatrix_t", "vCenter");
}
void GFeFitMatrix_t::SetCenter(Vector value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FeFitMatrix_t->Center(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "FeFitMatrix_t", "vCenter", true, value);
}
uint16_t GFeFitMatrix_t::GetEnd() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FeFitMatrix_t->End(ptr=%p)", m_ptr));
    return GetSchemaValue<uint16_t>(m_ptr, "FeFitMatrix_t", "nEnd");
}
void GFeFitMatrix_t::SetEnd(uint16_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FeFitMatrix_t->End(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "FeFitMatrix_t", "nEnd", true, value);
}
uint16_t GFeFitMatrix_t::GetNode() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FeFitMatrix_t->Node(ptr=%p)", m_ptr));
    return GetSchemaValue<uint16_t>(m_ptr, "FeFitMatrix_t", "nNode");
}
void GFeFitMatrix_t::SetNode(uint16_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FeFitMatrix_t->Node(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "FeFitMatrix_t", "nNode", true, value);
}
uint16_t GFeFitMatrix_t::GetBeginDynamic() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FeFitMatrix_t->BeginDynamic(ptr=%p)", m_ptr));
    return GetSchemaValue<uint16_t>(m_ptr, "FeFitMatrix_t", "nBeginDynamic");
}
void GFeFitMatrix_t::SetBeginDynamic(uint16_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FeFitMatrix_t->BeginDynamic(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "FeFitMatrix_t", "nBeginDynamic", true, value);
}
void* GFeFitMatrix_t::GetPtr() {
    return m_ptr;
}
std::string GFeFitMatrix_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GFeFitMatrix_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassFeFitMatrix_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GFeFitMatrix_t>("FeFitMatrix_t")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Center", &GFeFitMatrix_t::GetCenter, &GFeFitMatrix_t::SetCenter)
        .addProperty("End", &GFeFitMatrix_t::GetEnd, &GFeFitMatrix_t::SetEnd)
        .addProperty("Node", &GFeFitMatrix_t::GetNode, &GFeFitMatrix_t::SetNode)
        .addProperty("BeginDynamic", &GFeFitMatrix_t::GetBeginDynamic, &GFeFitMatrix_t::SetBeginDynamic)
        .addFunction("ToPtr", &GFeFitMatrix_t::ToPtr)
        .addFunction("IsValid", &GFeFitMatrix_t::IsValid)
        .endClass();
}
GRnVertex_t::GRnVertex_t(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GRnVertex_t::GRnVertex_t(void *ptr) {
    m_ptr = ptr;
}
uint32_t GRnVertex_t::GetEdge() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: RnVertex_t->Edge(ptr=%p)", m_ptr));
    return GetSchemaValue<uint32_t>(m_ptr, "RnVertex_t", "m_nEdge");
}
void GRnVertex_t::SetEdge(uint32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: RnVertex_t->Edge(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "RnVertex_t", "m_nEdge", true, value);
}
void* GRnVertex_t::GetPtr() {
    return m_ptr;
}
std::string GRnVertex_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GRnVertex_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassRnVertex_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GRnVertex_t>("RnVertex_t")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Edge", &GRnVertex_t::GetEdge, &GRnVertex_t::SetEdge)
        .addFunction("ToPtr", &GRnVertex_t::ToPtr)
        .addFunction("IsValid", &GRnVertex_t::IsValid)
        .endClass();
}
GTraceSettings_t::GTraceSettings_t(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GTraceSettings_t::GTraceSettings_t(void *ptr) {
    m_ptr = ptr;
}
float GTraceSettings_t::GetTraceHeight() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: TraceSettings_t->TraceHeight(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "TraceSettings_t", "m_flTraceHeight");
}
void GTraceSettings_t::SetTraceHeight(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: TraceSettings_t->TraceHeight(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "TraceSettings_t", "m_flTraceHeight", true, value);
}
float GTraceSettings_t::GetTraceRadius() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: TraceSettings_t->TraceRadius(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "TraceSettings_t", "m_flTraceRadius");
}
void GTraceSettings_t::SetTraceRadius(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: TraceSettings_t->TraceRadius(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "TraceSettings_t", "m_flTraceRadius", true, value);
}
void* GTraceSettings_t::GetPtr() {
    return m_ptr;
}
std::string GTraceSettings_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GTraceSettings_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassTraceSettings_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GTraceSettings_t>("TraceSettings_t")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("TraceHeight", &GTraceSettings_t::GetTraceHeight, &GTraceSettings_t::SetTraceHeight)
        .addProperty("TraceRadius", &GTraceSettings_t::GetTraceRadius, &GTraceSettings_t::SetTraceRadius)
        .addFunction("ToPtr", &GTraceSettings_t::ToPtr)
        .addFunction("IsValid", &GTraceSettings_t::IsValid)
        .endClass();
}
GCConstraintTarget::GCConstraintTarget(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCConstraintTarget::GCConstraintTarget(void *ptr) {
    m_ptr = ptr;
}
Vector GCConstraintTarget::GetOffset() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CConstraintTarget->Offset(ptr=%p)", m_ptr));
    return GetSchemaValue<Vector>(m_ptr, "CConstraintTarget", "m_vOffset");
}
void GCConstraintTarget::SetOffset(Vector value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CConstraintTarget->Offset(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CConstraintTarget", "m_vOffset", false, value);
}
uint32_t GCConstraintTarget::GetBoneHash() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CConstraintTarget->BoneHash(ptr=%p)", m_ptr));
    return GetSchemaValue<uint32_t>(m_ptr, "CConstraintTarget", "m_nBoneHash");
}
void GCConstraintTarget::SetBoneHash(uint32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CConstraintTarget->BoneHash(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CConstraintTarget", "m_nBoneHash", false, value);
}
std::string GCConstraintTarget::GetName() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CConstraintTarget->Name(ptr=%p)", m_ptr));
    return GetSchemaValue<CUtlString>(m_ptr, "CConstraintTarget", "m_sName").Get();
}
void GCConstraintTarget::SetName(std::string value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CConstraintTarget->Name(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CConstraintTarget", "m_sName", false, CUtlString(value.c_str()));
}
float GCConstraintTarget::GetWeight() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CConstraintTarget->Weight(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CConstraintTarget", "m_flWeight");
}
void GCConstraintTarget::SetWeight(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CConstraintTarget->Weight(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CConstraintTarget", "m_flWeight", false, value);
}
bool GCConstraintTarget::GetIsAttachment() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CConstraintTarget->IsAttachment(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "CConstraintTarget", "m_bIsAttachment");
}
void GCConstraintTarget::SetIsAttachment(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CConstraintTarget->IsAttachment(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CConstraintTarget", "m_bIsAttachment", false, value);
}
void* GCConstraintTarget::GetPtr() {
    return m_ptr;
}
std::string GCConstraintTarget::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCConstraintTarget::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCConstraintTarget(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCConstraintTarget>("CConstraintTarget")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Offset", &GCConstraintTarget::GetOffset, &GCConstraintTarget::SetOffset)
        .addProperty("BoneHash", &GCConstraintTarget::GetBoneHash, &GCConstraintTarget::SetBoneHash)
        .addProperty("Name", &GCConstraintTarget::GetName, &GCConstraintTarget::SetName)
        .addProperty("Weight", &GCConstraintTarget::GetWeight, &GCConstraintTarget::SetWeight)
        .addProperty("IsAttachment", &GCConstraintTarget::GetIsAttachment, &GCConstraintTarget::SetIsAttachment)
        .addFunction("ToPtr", &GCConstraintTarget::ToPtr)
        .addFunction("IsValid", &GCConstraintTarget::IsValid)
        .endClass();
}
GCompMatPropertyMutator_t::GCompMatPropertyMutator_t(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCompMatPropertyMutator_t::GCompMatPropertyMutator_t(void *ptr) {
    m_ptr = ptr;
}
bool GCompMatPropertyMutator_t::GetEnabled() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CompMatPropertyMutator_t->Enabled(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "CompMatPropertyMutator_t", "m_bEnabled");
}
void GCompMatPropertyMutator_t::SetEnabled(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CompMatPropertyMutator_t->Enabled(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CompMatPropertyMutator_t", "m_bEnabled", true, value);
}
uint64_t GCompMatPropertyMutator_t::GetMutatorCommandType() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CompMatPropertyMutator_t->MutatorCommandType(ptr=%p)", m_ptr));
    return GetSchemaValue<uint64_t>(m_ptr, "CompMatPropertyMutator_t", "m_nMutatorCommandType");
}
void GCompMatPropertyMutator_t::SetMutatorCommandType(uint64_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CompMatPropertyMutator_t->MutatorCommandType(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CompMatPropertyMutator_t", "m_nMutatorCommandType", true, value);
}
std::string GCompMatPropertyMutator_t::GetStrInitWith_Container() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CompMatPropertyMutator_t->StrInitWith_Container(ptr=%p)", m_ptr));
    return GetSchemaValue<CUtlString>(m_ptr, "CompMatPropertyMutator_t", "m_strInitWith_Container").Get();
}
void GCompMatPropertyMutator_t::SetStrInitWith_Container(std::string value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CompMatPropertyMutator_t->StrInitWith_Container(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CompMatPropertyMutator_t", "m_strInitWith_Container", true, CUtlString(value.c_str()));
}
std::string GCompMatPropertyMutator_t::GetStrCopyProperty_InputContainerSrc() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CompMatPropertyMutator_t->StrCopyProperty_InputContainerSrc(ptr=%p)", m_ptr));
    return GetSchemaValue<CUtlString>(m_ptr, "CompMatPropertyMutator_t", "m_strCopyProperty_InputContainerSrc").Get();
}
void GCompMatPropertyMutator_t::SetStrCopyProperty_InputContainerSrc(std::string value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CompMatPropertyMutator_t->StrCopyProperty_InputContainerSrc(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CompMatPropertyMutator_t", "m_strCopyProperty_InputContainerSrc", true, CUtlString(value.c_str()));
}
std::string GCompMatPropertyMutator_t::GetStrCopyProperty_InputContainerProperty() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CompMatPropertyMutator_t->StrCopyProperty_InputContainerProperty(ptr=%p)", m_ptr));
    return GetSchemaValue<CUtlString>(m_ptr, "CompMatPropertyMutator_t", "m_strCopyProperty_InputContainerProperty").Get();
}
void GCompMatPropertyMutator_t::SetStrCopyProperty_InputContainerProperty(std::string value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CompMatPropertyMutator_t->StrCopyProperty_InputContainerProperty(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CompMatPropertyMutator_t", "m_strCopyProperty_InputContainerProperty", true, CUtlString(value.c_str()));
}
std::string GCompMatPropertyMutator_t::GetStrCopyProperty_TargetProperty() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CompMatPropertyMutator_t->StrCopyProperty_TargetProperty(ptr=%p)", m_ptr));
    return GetSchemaValue<CUtlString>(m_ptr, "CompMatPropertyMutator_t", "m_strCopyProperty_TargetProperty").Get();
}
void GCompMatPropertyMutator_t::SetStrCopyProperty_TargetProperty(std::string value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CompMatPropertyMutator_t->StrCopyProperty_TargetProperty(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CompMatPropertyMutator_t", "m_strCopyProperty_TargetProperty", true, CUtlString(value.c_str()));
}
std::string GCompMatPropertyMutator_t::GetStrRandomRollInputVars_SeedInputVar() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CompMatPropertyMutator_t->StrRandomRollInputVars_SeedInputVar(ptr=%p)", m_ptr));
    return GetSchemaValue<CUtlString>(m_ptr, "CompMatPropertyMutator_t", "m_strRandomRollInputVars_SeedInputVar").Get();
}
void GCompMatPropertyMutator_t::SetStrRandomRollInputVars_SeedInputVar(std::string value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CompMatPropertyMutator_t->StrRandomRollInputVars_SeedInputVar(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CompMatPropertyMutator_t", "m_strRandomRollInputVars_SeedInputVar", true, CUtlString(value.c_str()));
}
std::vector<CUtlString> GCompMatPropertyMutator_t::GetRandomRollInputVars_InputVarsToRoll() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CompMatPropertyMutator_t->RandomRollInputVars_InputVarsToRoll(ptr=%p)", m_ptr));
    CUtlVector<CUtlString>* vec = GetSchemaValue<CUtlVector<CUtlString>*>(m_ptr, "CompMatPropertyMutator_t", "m_vecRandomRollInputVars_InputVarsToRoll"); std::vector<CUtlString> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCompMatPropertyMutator_t::SetRandomRollInputVars_InputVarsToRoll(std::vector<CUtlString> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CompMatPropertyMutator_t->RandomRollInputVars_InputVarsToRoll(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<CUtlString>(m_ptr, "CompMatPropertyMutator_t", "m_vecRandomRollInputVars_InputVarsToRoll", true, value);
}
std::string GCompMatPropertyMutator_t::GetStrCopyMatchingKeys_InputContainerSrc() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CompMatPropertyMutator_t->StrCopyMatchingKeys_InputContainerSrc(ptr=%p)", m_ptr));
    return GetSchemaValue<CUtlString>(m_ptr, "CompMatPropertyMutator_t", "m_strCopyMatchingKeys_InputContainerSrc").Get();
}
void GCompMatPropertyMutator_t::SetStrCopyMatchingKeys_InputContainerSrc(std::string value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CompMatPropertyMutator_t->StrCopyMatchingKeys_InputContainerSrc(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CompMatPropertyMutator_t", "m_strCopyMatchingKeys_InputContainerSrc", true, CUtlString(value.c_str()));
}
std::string GCompMatPropertyMutator_t::GetStrCopyKeysWithSuffix_InputContainerSrc() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CompMatPropertyMutator_t->StrCopyKeysWithSuffix_InputContainerSrc(ptr=%p)", m_ptr));
    return GetSchemaValue<CUtlString>(m_ptr, "CompMatPropertyMutator_t", "m_strCopyKeysWithSuffix_InputContainerSrc").Get();
}
void GCompMatPropertyMutator_t::SetStrCopyKeysWithSuffix_InputContainerSrc(std::string value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CompMatPropertyMutator_t->StrCopyKeysWithSuffix_InputContainerSrc(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CompMatPropertyMutator_t", "m_strCopyKeysWithSuffix_InputContainerSrc", true, CUtlString(value.c_str()));
}
std::string GCompMatPropertyMutator_t::GetStrCopyKeysWithSuffix_FindSuffix() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CompMatPropertyMutator_t->StrCopyKeysWithSuffix_FindSuffix(ptr=%p)", m_ptr));
    return GetSchemaValue<CUtlString>(m_ptr, "CompMatPropertyMutator_t", "m_strCopyKeysWithSuffix_FindSuffix").Get();
}
void GCompMatPropertyMutator_t::SetStrCopyKeysWithSuffix_FindSuffix(std::string value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CompMatPropertyMutator_t->StrCopyKeysWithSuffix_FindSuffix(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CompMatPropertyMutator_t", "m_strCopyKeysWithSuffix_FindSuffix", true, CUtlString(value.c_str()));
}
std::string GCompMatPropertyMutator_t::GetStrCopyKeysWithSuffix_ReplaceSuffix() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CompMatPropertyMutator_t->StrCopyKeysWithSuffix_ReplaceSuffix(ptr=%p)", m_ptr));
    return GetSchemaValue<CUtlString>(m_ptr, "CompMatPropertyMutator_t", "m_strCopyKeysWithSuffix_ReplaceSuffix").Get();
}
void GCompMatPropertyMutator_t::SetStrCopyKeysWithSuffix_ReplaceSuffix(std::string value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CompMatPropertyMutator_t->StrCopyKeysWithSuffix_ReplaceSuffix(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CompMatPropertyMutator_t", "m_strCopyKeysWithSuffix_ReplaceSuffix", true, CUtlString(value.c_str()));
}
GCompositeMaterialInputLooseVariable_t GCompMatPropertyMutator_t::GetSetValue_Value() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CompMatPropertyMutator_t->SetValue_Value(ptr=%p)", m_ptr));
    GCompositeMaterialInputLooseVariable_t value(GetSchemaPtr(m_ptr, "CompMatPropertyMutator_t", "m_nSetValue_Value"));
    return value;
}
void GCompMatPropertyMutator_t::SetSetValue_Value(GCompositeMaterialInputLooseVariable_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CompMatPropertyMutator_t->SetValue_Value(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'SetValue_Value' is not possible.\n");
}
std::string GCompMatPropertyMutator_t::GetStrGenerateTexture_TargetParam() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CompMatPropertyMutator_t->StrGenerateTexture_TargetParam(ptr=%p)", m_ptr));
    return GetSchemaValue<CUtlString>(m_ptr, "CompMatPropertyMutator_t", "m_strGenerateTexture_TargetParam").Get();
}
void GCompMatPropertyMutator_t::SetStrGenerateTexture_TargetParam(std::string value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CompMatPropertyMutator_t->StrGenerateTexture_TargetParam(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CompMatPropertyMutator_t", "m_strGenerateTexture_TargetParam", true, CUtlString(value.c_str()));
}
std::string GCompMatPropertyMutator_t::GetStrGenerateTexture_InitialContainer() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CompMatPropertyMutator_t->StrGenerateTexture_InitialContainer(ptr=%p)", m_ptr));
    return GetSchemaValue<CUtlString>(m_ptr, "CompMatPropertyMutator_t", "m_strGenerateTexture_InitialContainer").Get();
}
void GCompMatPropertyMutator_t::SetStrGenerateTexture_InitialContainer(std::string value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CompMatPropertyMutator_t->StrGenerateTexture_InitialContainer(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CompMatPropertyMutator_t", "m_strGenerateTexture_InitialContainer", true, CUtlString(value.c_str()));
}
int32_t GCompMatPropertyMutator_t::GetResolution() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CompMatPropertyMutator_t->Resolution(ptr=%p)", m_ptr));
    return GetSchemaValue<int32_t>(m_ptr, "CompMatPropertyMutator_t", "m_nResolution");
}
void GCompMatPropertyMutator_t::SetResolution(int32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CompMatPropertyMutator_t->Resolution(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CompMatPropertyMutator_t", "m_nResolution", true, value);
}
bool GCompMatPropertyMutator_t::GetIsScratchTarget() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CompMatPropertyMutator_t->IsScratchTarget(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "CompMatPropertyMutator_t", "m_bIsScratchTarget");
}
void GCompMatPropertyMutator_t::SetIsScratchTarget(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CompMatPropertyMutator_t->IsScratchTarget(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CompMatPropertyMutator_t", "m_bIsScratchTarget", true, value);
}
bool GCompMatPropertyMutator_t::GetSplatDebugInfo() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CompMatPropertyMutator_t->SplatDebugInfo(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "CompMatPropertyMutator_t", "m_bSplatDebugInfo");
}
void GCompMatPropertyMutator_t::SetSplatDebugInfo(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CompMatPropertyMutator_t->SplatDebugInfo(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CompMatPropertyMutator_t", "m_bSplatDebugInfo", true, value);
}
bool GCompMatPropertyMutator_t::GetCaptureInRenderDoc() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CompMatPropertyMutator_t->CaptureInRenderDoc(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "CompMatPropertyMutator_t", "m_bCaptureInRenderDoc");
}
void GCompMatPropertyMutator_t::SetCaptureInRenderDoc(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CompMatPropertyMutator_t->CaptureInRenderDoc(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CompMatPropertyMutator_t", "m_bCaptureInRenderDoc", true, value);
}
std::vector<GCompMatPropertyMutator_t> GCompMatPropertyMutator_t::GetTexGenInstructions() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CompMatPropertyMutator_t->TexGenInstructions(ptr=%p)", m_ptr));
    CUtlVector<GCompMatPropertyMutator_t>* vec = GetSchemaValue<CUtlVector<GCompMatPropertyMutator_t>*>(m_ptr, "CompMatPropertyMutator_t", "m_vecTexGenInstructions"); std::vector<GCompMatPropertyMutator_t> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCompMatPropertyMutator_t::SetTexGenInstructions(std::vector<GCompMatPropertyMutator_t> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CompMatPropertyMutator_t->TexGenInstructions(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<GCompMatPropertyMutator_t>(m_ptr, "CompMatPropertyMutator_t", "m_vecTexGenInstructions", true, value);
}
std::vector<GCompMatPropertyMutator_t> GCompMatPropertyMutator_t::GetConditionalMutators() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CompMatPropertyMutator_t->ConditionalMutators(ptr=%p)", m_ptr));
    CUtlVector<GCompMatPropertyMutator_t>* vec = GetSchemaValue<CUtlVector<GCompMatPropertyMutator_t>*>(m_ptr, "CompMatPropertyMutator_t", "m_vecConditionalMutators"); std::vector<GCompMatPropertyMutator_t> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCompMatPropertyMutator_t::SetConditionalMutators(std::vector<GCompMatPropertyMutator_t> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CompMatPropertyMutator_t->ConditionalMutators(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<GCompMatPropertyMutator_t>(m_ptr, "CompMatPropertyMutator_t", "m_vecConditionalMutators", true, value);
}
std::string GCompMatPropertyMutator_t::GetStrPopInputQueue_Container() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CompMatPropertyMutator_t->StrPopInputQueue_Container(ptr=%p)", m_ptr));
    return GetSchemaValue<CUtlString>(m_ptr, "CompMatPropertyMutator_t", "m_strPopInputQueue_Container").Get();
}
void GCompMatPropertyMutator_t::SetStrPopInputQueue_Container(std::string value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CompMatPropertyMutator_t->StrPopInputQueue_Container(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CompMatPropertyMutator_t", "m_strPopInputQueue_Container", true, CUtlString(value.c_str()));
}
std::string GCompMatPropertyMutator_t::GetStrDrawText_InputContainerSrc() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CompMatPropertyMutator_t->StrDrawText_InputContainerSrc(ptr=%p)", m_ptr));
    return GetSchemaValue<CUtlString>(m_ptr, "CompMatPropertyMutator_t", "m_strDrawText_InputContainerSrc").Get();
}
void GCompMatPropertyMutator_t::SetStrDrawText_InputContainerSrc(std::string value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CompMatPropertyMutator_t->StrDrawText_InputContainerSrc(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CompMatPropertyMutator_t", "m_strDrawText_InputContainerSrc", true, CUtlString(value.c_str()));
}
std::string GCompMatPropertyMutator_t::GetStrDrawText_InputContainerProperty() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CompMatPropertyMutator_t->StrDrawText_InputContainerProperty(ptr=%p)", m_ptr));
    return GetSchemaValue<CUtlString>(m_ptr, "CompMatPropertyMutator_t", "m_strDrawText_InputContainerProperty").Get();
}
void GCompMatPropertyMutator_t::SetStrDrawText_InputContainerProperty(std::string value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CompMatPropertyMutator_t->StrDrawText_InputContainerProperty(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CompMatPropertyMutator_t", "m_strDrawText_InputContainerProperty", true, CUtlString(value.c_str()));
}
Vector2D GCompMatPropertyMutator_t::GetDrawText_Position() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CompMatPropertyMutator_t->DrawText_Position(ptr=%p)", m_ptr));
    return GetSchemaValue<Vector2D>(m_ptr, "CompMatPropertyMutator_t", "m_vecDrawText_Position");
}
void GCompMatPropertyMutator_t::SetDrawText_Position(Vector2D value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CompMatPropertyMutator_t->DrawText_Position(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CompMatPropertyMutator_t", "m_vecDrawText_Position", true, value);
}
Color GCompMatPropertyMutator_t::GetColDrawText_Color() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CompMatPropertyMutator_t->ColDrawText_Color(ptr=%p)", m_ptr));
    return GetSchemaValue<Color>(m_ptr, "CompMatPropertyMutator_t", "m_colDrawText_Color");
}
void GCompMatPropertyMutator_t::SetColDrawText_Color(Color value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CompMatPropertyMutator_t->ColDrawText_Color(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CompMatPropertyMutator_t", "m_colDrawText_Color", true, value);
}
std::string GCompMatPropertyMutator_t::GetStrDrawText_Font() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CompMatPropertyMutator_t->StrDrawText_Font(ptr=%p)", m_ptr));
    return GetSchemaValue<CUtlString>(m_ptr, "CompMatPropertyMutator_t", "m_strDrawText_Font").Get();
}
void GCompMatPropertyMutator_t::SetStrDrawText_Font(std::string value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CompMatPropertyMutator_t->StrDrawText_Font(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CompMatPropertyMutator_t", "m_strDrawText_Font", true, CUtlString(value.c_str()));
}
std::vector<GCompMatMutatorCondition_t> GCompMatPropertyMutator_t::GetConditions() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CompMatPropertyMutator_t->Conditions(ptr=%p)", m_ptr));
    CUtlVector<GCompMatMutatorCondition_t>* vec = GetSchemaValue<CUtlVector<GCompMatMutatorCondition_t>*>(m_ptr, "CompMatPropertyMutator_t", "m_vecConditions"); std::vector<GCompMatMutatorCondition_t> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCompMatPropertyMutator_t::SetConditions(std::vector<GCompMatMutatorCondition_t> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CompMatPropertyMutator_t->Conditions(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<GCompMatMutatorCondition_t>(m_ptr, "CompMatPropertyMutator_t", "m_vecConditions", true, value);
}
void* GCompMatPropertyMutator_t::GetPtr() {
    return m_ptr;
}
std::string GCompMatPropertyMutator_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCompMatPropertyMutator_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCompMatPropertyMutator_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCompMatPropertyMutator_t>("CompMatPropertyMutator_t")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Enabled", &GCompMatPropertyMutator_t::GetEnabled, &GCompMatPropertyMutator_t::SetEnabled)
        .addProperty("MutatorCommandType", &GCompMatPropertyMutator_t::GetMutatorCommandType, &GCompMatPropertyMutator_t::SetMutatorCommandType)
        .addProperty("StrInitWith_Container", &GCompMatPropertyMutator_t::GetStrInitWith_Container, &GCompMatPropertyMutator_t::SetStrInitWith_Container)
        .addProperty("StrCopyProperty_InputContainerSrc", &GCompMatPropertyMutator_t::GetStrCopyProperty_InputContainerSrc, &GCompMatPropertyMutator_t::SetStrCopyProperty_InputContainerSrc)
        .addProperty("StrCopyProperty_InputContainerProperty", &GCompMatPropertyMutator_t::GetStrCopyProperty_InputContainerProperty, &GCompMatPropertyMutator_t::SetStrCopyProperty_InputContainerProperty)
        .addProperty("StrCopyProperty_TargetProperty", &GCompMatPropertyMutator_t::GetStrCopyProperty_TargetProperty, &GCompMatPropertyMutator_t::SetStrCopyProperty_TargetProperty)
        .addProperty("StrRandomRollInputVars_SeedInputVar", &GCompMatPropertyMutator_t::GetStrRandomRollInputVars_SeedInputVar, &GCompMatPropertyMutator_t::SetStrRandomRollInputVars_SeedInputVar)
        .addProperty("RandomRollInputVars_InputVarsToRoll", &GCompMatPropertyMutator_t::GetRandomRollInputVars_InputVarsToRoll, &GCompMatPropertyMutator_t::SetRandomRollInputVars_InputVarsToRoll)
        .addProperty("StrCopyMatchingKeys_InputContainerSrc", &GCompMatPropertyMutator_t::GetStrCopyMatchingKeys_InputContainerSrc, &GCompMatPropertyMutator_t::SetStrCopyMatchingKeys_InputContainerSrc)
        .addProperty("StrCopyKeysWithSuffix_InputContainerSrc", &GCompMatPropertyMutator_t::GetStrCopyKeysWithSuffix_InputContainerSrc, &GCompMatPropertyMutator_t::SetStrCopyKeysWithSuffix_InputContainerSrc)
        .addProperty("StrCopyKeysWithSuffix_FindSuffix", &GCompMatPropertyMutator_t::GetStrCopyKeysWithSuffix_FindSuffix, &GCompMatPropertyMutator_t::SetStrCopyKeysWithSuffix_FindSuffix)
        .addProperty("StrCopyKeysWithSuffix_ReplaceSuffix", &GCompMatPropertyMutator_t::GetStrCopyKeysWithSuffix_ReplaceSuffix, &GCompMatPropertyMutator_t::SetStrCopyKeysWithSuffix_ReplaceSuffix)
        .addProperty("SetValue_Value", &GCompMatPropertyMutator_t::GetSetValue_Value, &GCompMatPropertyMutator_t::SetSetValue_Value)
        .addProperty("StrGenerateTexture_TargetParam", &GCompMatPropertyMutator_t::GetStrGenerateTexture_TargetParam, &GCompMatPropertyMutator_t::SetStrGenerateTexture_TargetParam)
        .addProperty("StrGenerateTexture_InitialContainer", &GCompMatPropertyMutator_t::GetStrGenerateTexture_InitialContainer, &GCompMatPropertyMutator_t::SetStrGenerateTexture_InitialContainer)
        .addProperty("Resolution", &GCompMatPropertyMutator_t::GetResolution, &GCompMatPropertyMutator_t::SetResolution)
        .addProperty("IsScratchTarget", &GCompMatPropertyMutator_t::GetIsScratchTarget, &GCompMatPropertyMutator_t::SetIsScratchTarget)
        .addProperty("SplatDebugInfo", &GCompMatPropertyMutator_t::GetSplatDebugInfo, &GCompMatPropertyMutator_t::SetSplatDebugInfo)
        .addProperty("CaptureInRenderDoc", &GCompMatPropertyMutator_t::GetCaptureInRenderDoc, &GCompMatPropertyMutator_t::SetCaptureInRenderDoc)
        .addProperty("TexGenInstructions", &GCompMatPropertyMutator_t::GetTexGenInstructions, &GCompMatPropertyMutator_t::SetTexGenInstructions)
        .addProperty("ConditionalMutators", &GCompMatPropertyMutator_t::GetConditionalMutators, &GCompMatPropertyMutator_t::SetConditionalMutators)
        .addProperty("StrPopInputQueue_Container", &GCompMatPropertyMutator_t::GetStrPopInputQueue_Container, &GCompMatPropertyMutator_t::SetStrPopInputQueue_Container)
        .addProperty("StrDrawText_InputContainerSrc", &GCompMatPropertyMutator_t::GetStrDrawText_InputContainerSrc, &GCompMatPropertyMutator_t::SetStrDrawText_InputContainerSrc)
        .addProperty("StrDrawText_InputContainerProperty", &GCompMatPropertyMutator_t::GetStrDrawText_InputContainerProperty, &GCompMatPropertyMutator_t::SetStrDrawText_InputContainerProperty)
        .addProperty("DrawText_Position", &GCompMatPropertyMutator_t::GetDrawText_Position, &GCompMatPropertyMutator_t::SetDrawText_Position)
        .addProperty("ColDrawText_Color", &GCompMatPropertyMutator_t::GetColDrawText_Color, &GCompMatPropertyMutator_t::SetColDrawText_Color)
        .addProperty("StrDrawText_Font", &GCompMatPropertyMutator_t::GetStrDrawText_Font, &GCompMatPropertyMutator_t::SetStrDrawText_Font)
        .addProperty("Conditions", &GCompMatPropertyMutator_t::GetConditions, &GCompMatPropertyMutator_t::SetConditions)
        .addFunction("ToPtr", &GCompMatPropertyMutator_t::ToPtr)
        .addFunction("IsValid", &GCompMatPropertyMutator_t::IsValid)
        .endClass();
}
GIKBoneNameAndIndex_t::GIKBoneNameAndIndex_t(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GIKBoneNameAndIndex_t::GIKBoneNameAndIndex_t(void *ptr) {
    m_ptr = ptr;
}
std::string GIKBoneNameAndIndex_t::GetName() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: IKBoneNameAndIndex_t->Name(ptr=%p)", m_ptr));
    return GetSchemaValue<CUtlString>(m_ptr, "IKBoneNameAndIndex_t", "m_Name").Get();
}
void GIKBoneNameAndIndex_t::SetName(std::string value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: IKBoneNameAndIndex_t->Name(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "IKBoneNameAndIndex_t", "m_Name", true, CUtlString(value.c_str()));
}
void* GIKBoneNameAndIndex_t::GetPtr() {
    return m_ptr;
}
std::string GIKBoneNameAndIndex_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GIKBoneNameAndIndex_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassIKBoneNameAndIndex_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GIKBoneNameAndIndex_t>("IKBoneNameAndIndex_t")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Name", &GIKBoneNameAndIndex_t::GetName, &GIKBoneNameAndIndex_t::SetName)
        .addFunction("ToPtr", &GIKBoneNameAndIndex_t::ToPtr)
        .addFunction("IsValid", &GIKBoneNameAndIndex_t::IsValid)
        .endClass();
}
GPermEntityLumpData_t::GPermEntityLumpData_t(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GPermEntityLumpData_t::GPermEntityLumpData_t(void *ptr) {
    m_ptr = ptr;
}
std::string GPermEntityLumpData_t::GetName() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: PermEntityLumpData_t->Name(ptr=%p)", m_ptr));
    return GetSchemaValue<CUtlString>(m_ptr, "PermEntityLumpData_t", "m_name").Get();
}
void GPermEntityLumpData_t::SetName(std::string value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: PermEntityLumpData_t->Name(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "PermEntityLumpData_t", "m_name", true, CUtlString(value.c_str()));
}
void* GPermEntityLumpData_t::GetPtr() {
    return m_ptr;
}
std::string GPermEntityLumpData_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GPermEntityLumpData_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassPermEntityLumpData_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GPermEntityLumpData_t>("PermEntityLumpData_t")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Name", &GPermEntityLumpData_t::GetName, &GPermEntityLumpData_t::SetName)
        .addFunction("ToPtr", &GPermEntityLumpData_t::ToPtr)
        .addFunction("IsValid", &GPermEntityLumpData_t::IsValid)
        .endClass();
}
GVMixDelayDesc_t::GVMixDelayDesc_t(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GVMixDelayDesc_t::GVMixDelayDesc_t(void *ptr) {
    m_ptr = ptr;
}
GVMixFilterDesc_t GVMixDelayDesc_t::GetFeedbackFilter() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: VMixDelayDesc_t->FeedbackFilter(ptr=%p)", m_ptr));
    GVMixFilterDesc_t value(GetSchemaPtr(m_ptr, "VMixDelayDesc_t", "m_feedbackFilter"));
    return value;
}
void GVMixDelayDesc_t::SetFeedbackFilter(GVMixFilterDesc_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: VMixDelayDesc_t->FeedbackFilter(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'FeedbackFilter' is not possible.\n");
}
bool GVMixDelayDesc_t::GetEnableFilter() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: VMixDelayDesc_t->EnableFilter(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "VMixDelayDesc_t", "m_bEnableFilter");
}
void GVMixDelayDesc_t::SetEnableFilter(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: VMixDelayDesc_t->EnableFilter(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "VMixDelayDesc_t", "m_bEnableFilter", true, value);
}
float GVMixDelayDesc_t::GetDelay() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: VMixDelayDesc_t->Delay(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "VMixDelayDesc_t", "m_flDelay");
}
void GVMixDelayDesc_t::SetDelay(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: VMixDelayDesc_t->Delay(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "VMixDelayDesc_t", "m_flDelay", true, value);
}
float GVMixDelayDesc_t::GetDirectGain() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: VMixDelayDesc_t->DirectGain(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "VMixDelayDesc_t", "m_flDirectGain");
}
void GVMixDelayDesc_t::SetDirectGain(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: VMixDelayDesc_t->DirectGain(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "VMixDelayDesc_t", "m_flDirectGain", true, value);
}
float GVMixDelayDesc_t::GetDelayGain() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: VMixDelayDesc_t->DelayGain(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "VMixDelayDesc_t", "m_flDelayGain");
}
void GVMixDelayDesc_t::SetDelayGain(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: VMixDelayDesc_t->DelayGain(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "VMixDelayDesc_t", "m_flDelayGain", true, value);
}
float GVMixDelayDesc_t::GetFeedbackGain() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: VMixDelayDesc_t->FeedbackGain(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "VMixDelayDesc_t", "m_flFeedbackGain");
}
void GVMixDelayDesc_t::SetFeedbackGain(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: VMixDelayDesc_t->FeedbackGain(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "VMixDelayDesc_t", "m_flFeedbackGain", true, value);
}
float GVMixDelayDesc_t::GetWidth() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: VMixDelayDesc_t->Width(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "VMixDelayDesc_t", "m_flWidth");
}
void GVMixDelayDesc_t::SetWidth(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: VMixDelayDesc_t->Width(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "VMixDelayDesc_t", "m_flWidth", true, value);
}
void* GVMixDelayDesc_t::GetPtr() {
    return m_ptr;
}
std::string GVMixDelayDesc_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GVMixDelayDesc_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassVMixDelayDesc_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GVMixDelayDesc_t>("VMixDelayDesc_t")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("FeedbackFilter", &GVMixDelayDesc_t::GetFeedbackFilter, &GVMixDelayDesc_t::SetFeedbackFilter)
        .addProperty("EnableFilter", &GVMixDelayDesc_t::GetEnableFilter, &GVMixDelayDesc_t::SetEnableFilter)
        .addProperty("Delay", &GVMixDelayDesc_t::GetDelay, &GVMixDelayDesc_t::SetDelay)
        .addProperty("DirectGain", &GVMixDelayDesc_t::GetDirectGain, &GVMixDelayDesc_t::SetDirectGain)
        .addProperty("DelayGain", &GVMixDelayDesc_t::GetDelayGain, &GVMixDelayDesc_t::SetDelayGain)
        .addProperty("FeedbackGain", &GVMixDelayDesc_t::GetFeedbackGain, &GVMixDelayDesc_t::SetFeedbackGain)
        .addProperty("Width", &GVMixDelayDesc_t::GetWidth, &GVMixDelayDesc_t::SetWidth)
        .addFunction("ToPtr", &GVMixDelayDesc_t::ToPtr)
        .addFunction("IsValid", &GVMixDelayDesc_t::IsValid)
        .endClass();
}
GCBoneConstraintDotToMorph::GCBoneConstraintDotToMorph(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCBoneConstraintDotToMorph::GCBoneConstraintDotToMorph(void *ptr) {
    m_ptr = ptr;
}
std::string GCBoneConstraintDotToMorph::GetBoneName() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CBoneConstraintDotToMorph->BoneName(ptr=%p)", m_ptr));
    return GetSchemaValue<CUtlString>(m_ptr, "CBoneConstraintDotToMorph", "m_sBoneName").Get();
}
void GCBoneConstraintDotToMorph::SetBoneName(std::string value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CBoneConstraintDotToMorph->BoneName(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CBoneConstraintDotToMorph", "m_sBoneName", false, CUtlString(value.c_str()));
}
std::string GCBoneConstraintDotToMorph::GetTargetBoneName() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CBoneConstraintDotToMorph->TargetBoneName(ptr=%p)", m_ptr));
    return GetSchemaValue<CUtlString>(m_ptr, "CBoneConstraintDotToMorph", "m_sTargetBoneName").Get();
}
void GCBoneConstraintDotToMorph::SetTargetBoneName(std::string value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CBoneConstraintDotToMorph->TargetBoneName(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CBoneConstraintDotToMorph", "m_sTargetBoneName", false, CUtlString(value.c_str()));
}
std::string GCBoneConstraintDotToMorph::GetMorphChannelName() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CBoneConstraintDotToMorph->MorphChannelName(ptr=%p)", m_ptr));
    return GetSchemaValue<CUtlString>(m_ptr, "CBoneConstraintDotToMorph", "m_sMorphChannelName").Get();
}
void GCBoneConstraintDotToMorph::SetMorphChannelName(std::string value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CBoneConstraintDotToMorph->MorphChannelName(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CBoneConstraintDotToMorph", "m_sMorphChannelName", false, CUtlString(value.c_str()));
}
std::vector<float> GCBoneConstraintDotToMorph::GetRemap() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CBoneConstraintDotToMorph->Remap(ptr=%p,size=4)", m_ptr));
    float* outValue = (float*)GetSchemaPtr(m_ptr, "CBoneConstraintDotToMorph", "m_flRemap"); std::vector<float> ret; for(int i = 0; i < 4; i++) { ret.push_back(outValue[i]); } return ret;
}
void GCBoneConstraintDotToMorph::SetRemap(std::vector<float> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CBoneConstraintDotToMorph->Remap(ptr=%p,size=4)", m_ptr));
    if(value.size() != 4) return PLUGIN_PRINT("Schema SDK", "Field 'Remap' needs to have 4 values.\n");
    auto val = GetSchemaValuePtr<float>(m_ptr, "CBoneConstraintDotToMorph", "m_flRemap");
    for(size_t i = 0; i < value.size(); i++) val[i] = value[i];
}
void* GCBoneConstraintDotToMorph::GetPtr() {
    return m_ptr;
}
std::string GCBoneConstraintDotToMorph::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCBoneConstraintDotToMorph::IsValid() {
    return (m_ptr != nullptr);
}
GCBoneConstraintBase GCBoneConstraintDotToMorph::GetParent() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CBoneConstraintDotToMorph::GetParent(ptr=%p)", m_ptr));
    GCBoneConstraintBase value(m_ptr);
    return value;
}
void GCBoneConstraintDotToMorph::SetParent(GCBoneConstraintBase value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CBoneConstraintDotToMorph::SetParent(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCBoneConstraintDotToMorph(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCBoneConstraintDotToMorph>("CBoneConstraintDotToMorph")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("BoneName", &GCBoneConstraintDotToMorph::GetBoneName, &GCBoneConstraintDotToMorph::SetBoneName)
        .addProperty("TargetBoneName", &GCBoneConstraintDotToMorph::GetTargetBoneName, &GCBoneConstraintDotToMorph::SetTargetBoneName)
        .addProperty("MorphChannelName", &GCBoneConstraintDotToMorph::GetMorphChannelName, &GCBoneConstraintDotToMorph::SetMorphChannelName)
        .addProperty("Remap", &GCBoneConstraintDotToMorph::GetRemap, &GCBoneConstraintDotToMorph::SetRemap)
        .addProperty("Parent", &GCBoneConstraintDotToMorph::GetParent, &GCBoneConstraintDotToMorph::SetParent)
        .addFunction("ToPtr", &GCBoneConstraintDotToMorph::ToPtr)
        .addFunction("IsValid", &GCBoneConstraintDotToMorph::IsValid)
        .endClass();
}
GPostProcessingBloomParameters_t::GPostProcessingBloomParameters_t(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GPostProcessingBloomParameters_t::GPostProcessingBloomParameters_t(void *ptr) {
    m_ptr = ptr;
}
uint64_t GPostProcessingBloomParameters_t::GetBlendMode() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: PostProcessingBloomParameters_t->BlendMode(ptr=%p)", m_ptr));
    return GetSchemaValue<uint64_t>(m_ptr, "PostProcessingBloomParameters_t", "m_blendMode");
}
void GPostProcessingBloomParameters_t::SetBlendMode(uint64_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: PostProcessingBloomParameters_t->BlendMode(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "PostProcessingBloomParameters_t", "m_blendMode", true, value);
}
float GPostProcessingBloomParameters_t::GetBloomStrength() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: PostProcessingBloomParameters_t->BloomStrength(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "PostProcessingBloomParameters_t", "m_flBloomStrength");
}
void GPostProcessingBloomParameters_t::SetBloomStrength(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: PostProcessingBloomParameters_t->BloomStrength(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "PostProcessingBloomParameters_t", "m_flBloomStrength", true, value);
}
float GPostProcessingBloomParameters_t::GetScreenBloomStrength() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: PostProcessingBloomParameters_t->ScreenBloomStrength(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "PostProcessingBloomParameters_t", "m_flScreenBloomStrength");
}
void GPostProcessingBloomParameters_t::SetScreenBloomStrength(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: PostProcessingBloomParameters_t->ScreenBloomStrength(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "PostProcessingBloomParameters_t", "m_flScreenBloomStrength", true, value);
}
float GPostProcessingBloomParameters_t::GetBlurBloomStrength() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: PostProcessingBloomParameters_t->BlurBloomStrength(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "PostProcessingBloomParameters_t", "m_flBlurBloomStrength");
}
void GPostProcessingBloomParameters_t::SetBlurBloomStrength(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: PostProcessingBloomParameters_t->BlurBloomStrength(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "PostProcessingBloomParameters_t", "m_flBlurBloomStrength", true, value);
}
float GPostProcessingBloomParameters_t::GetBloomThreshold() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: PostProcessingBloomParameters_t->BloomThreshold(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "PostProcessingBloomParameters_t", "m_flBloomThreshold");
}
void GPostProcessingBloomParameters_t::SetBloomThreshold(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: PostProcessingBloomParameters_t->BloomThreshold(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "PostProcessingBloomParameters_t", "m_flBloomThreshold", true, value);
}
float GPostProcessingBloomParameters_t::GetBloomThresholdWidth() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: PostProcessingBloomParameters_t->BloomThresholdWidth(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "PostProcessingBloomParameters_t", "m_flBloomThresholdWidth");
}
void GPostProcessingBloomParameters_t::SetBloomThresholdWidth(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: PostProcessingBloomParameters_t->BloomThresholdWidth(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "PostProcessingBloomParameters_t", "m_flBloomThresholdWidth", true, value);
}
float GPostProcessingBloomParameters_t::GetSkyboxBloomStrength() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: PostProcessingBloomParameters_t->SkyboxBloomStrength(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "PostProcessingBloomParameters_t", "m_flSkyboxBloomStrength");
}
void GPostProcessingBloomParameters_t::SetSkyboxBloomStrength(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: PostProcessingBloomParameters_t->SkyboxBloomStrength(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "PostProcessingBloomParameters_t", "m_flSkyboxBloomStrength", true, value);
}
float GPostProcessingBloomParameters_t::GetBloomStartValue() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: PostProcessingBloomParameters_t->BloomStartValue(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "PostProcessingBloomParameters_t", "m_flBloomStartValue");
}
void GPostProcessingBloomParameters_t::SetBloomStartValue(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: PostProcessingBloomParameters_t->BloomStartValue(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "PostProcessingBloomParameters_t", "m_flBloomStartValue", true, value);
}
std::vector<float> GPostProcessingBloomParameters_t::GetBlurWeight() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: PostProcessingBloomParameters_t->BlurWeight(ptr=%p,size=5)", m_ptr));
    float* outValue = (float*)GetSchemaPtr(m_ptr, "PostProcessingBloomParameters_t", "m_flBlurWeight"); std::vector<float> ret; for(int i = 0; i < 5; i++) { ret.push_back(outValue[i]); } return ret;
}
void GPostProcessingBloomParameters_t::SetBlurWeight(std::vector<float> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: PostProcessingBloomParameters_t->BlurWeight(ptr=%p,size=5)", m_ptr));
    if(value.size() != 5) return PLUGIN_PRINT("Schema SDK", "Field 'BlurWeight' needs to have 5 values.\n");
    auto val = GetSchemaValuePtr<float>(m_ptr, "PostProcessingBloomParameters_t", "m_flBlurWeight");
    for(size_t i = 0; i < value.size(); i++) val[i] = value[i];
}
std::vector<Vector> GPostProcessingBloomParameters_t::GetBlurTint() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: PostProcessingBloomParameters_t->BlurTint(ptr=%p,size=5)", m_ptr));
    Vector* outValue = (Vector*)GetSchemaPtr(m_ptr, "PostProcessingBloomParameters_t", "m_vBlurTint"); std::vector<Vector> ret; for(int i = 0; i < 5; i++) { ret.push_back(outValue[i]); } return ret;
}
void GPostProcessingBloomParameters_t::SetBlurTint(std::vector<Vector> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: PostProcessingBloomParameters_t->BlurTint(ptr=%p,size=5)", m_ptr));
    if(value.size() != 5) return PLUGIN_PRINT("Schema SDK", "Field 'BlurTint' needs to have 5 values.\n");
    auto val = GetSchemaValuePtr<Vector>(m_ptr, "PostProcessingBloomParameters_t", "m_vBlurTint");
    for(size_t i = 0; i < value.size(); i++) val[i] = value[i];
}
void* GPostProcessingBloomParameters_t::GetPtr() {
    return m_ptr;
}
std::string GPostProcessingBloomParameters_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GPostProcessingBloomParameters_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassPostProcessingBloomParameters_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GPostProcessingBloomParameters_t>("PostProcessingBloomParameters_t")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("BlendMode", &GPostProcessingBloomParameters_t::GetBlendMode, &GPostProcessingBloomParameters_t::SetBlendMode)
        .addProperty("BloomStrength", &GPostProcessingBloomParameters_t::GetBloomStrength, &GPostProcessingBloomParameters_t::SetBloomStrength)
        .addProperty("ScreenBloomStrength", &GPostProcessingBloomParameters_t::GetScreenBloomStrength, &GPostProcessingBloomParameters_t::SetScreenBloomStrength)
        .addProperty("BlurBloomStrength", &GPostProcessingBloomParameters_t::GetBlurBloomStrength, &GPostProcessingBloomParameters_t::SetBlurBloomStrength)
        .addProperty("BloomThreshold", &GPostProcessingBloomParameters_t::GetBloomThreshold, &GPostProcessingBloomParameters_t::SetBloomThreshold)
        .addProperty("BloomThresholdWidth", &GPostProcessingBloomParameters_t::GetBloomThresholdWidth, &GPostProcessingBloomParameters_t::SetBloomThresholdWidth)
        .addProperty("SkyboxBloomStrength", &GPostProcessingBloomParameters_t::GetSkyboxBloomStrength, &GPostProcessingBloomParameters_t::SetSkyboxBloomStrength)
        .addProperty("BloomStartValue", &GPostProcessingBloomParameters_t::GetBloomStartValue, &GPostProcessingBloomParameters_t::SetBloomStartValue)
        .addProperty("BlurWeight", &GPostProcessingBloomParameters_t::GetBlurWeight, &GPostProcessingBloomParameters_t::SetBlurWeight)
        .addProperty("BlurTint", &GPostProcessingBloomParameters_t::GetBlurTint, &GPostProcessingBloomParameters_t::SetBlurTint)
        .addFunction("ToPtr", &GPostProcessingBloomParameters_t::ToPtr)
        .addFunction("IsValid", &GPostProcessingBloomParameters_t::IsValid)
        .endClass();
}
GEntOutput_t::GEntOutput_t(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GEntOutput_t::GEntOutput_t(void *ptr) {
    m_ptr = ptr;
}
void* GEntOutput_t::GetPtr() {
    return m_ptr;
}
std::string GEntOutput_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GEntOutput_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassEntOutput_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GEntOutput_t>("EntOutput_t")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addFunction("ToPtr", &GEntOutput_t::ToPtr)
        .addFunction("IsValid", &GEntOutput_t::IsValid)
        .endClass();
}
GFakeEntityDerivedB_tAPI::GFakeEntityDerivedB_tAPI(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GFakeEntityDerivedB_tAPI::GFakeEntityDerivedB_tAPI(void *ptr) {
    m_ptr = ptr;
}
void* GFakeEntityDerivedB_tAPI::GetPtr() {
    return m_ptr;
}
std::string GFakeEntityDerivedB_tAPI::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GFakeEntityDerivedB_tAPI::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassFakeEntityDerivedB_tAPI(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GFakeEntityDerivedB_tAPI>("FakeEntityDerivedB_tAPI")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addFunction("ToPtr", &GFakeEntityDerivedB_tAPI::ToPtr)
        .addFunction("IsValid", &GFakeEntityDerivedB_tAPI::IsValid)
        .endClass();
}
GCSlopeComponentUpdater::GCSlopeComponentUpdater(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCSlopeComponentUpdater::GCSlopeComponentUpdater(void *ptr) {
    m_ptr = ptr;
}
float GCSlopeComponentUpdater::GetTraceDistance() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CSlopeComponentUpdater->TraceDistance(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CSlopeComponentUpdater", "m_flTraceDistance");
}
void GCSlopeComponentUpdater::SetTraceDistance(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CSlopeComponentUpdater->TraceDistance(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CSlopeComponentUpdater", "m_flTraceDistance", false, value);
}
GCAnimParamHandle GCSlopeComponentUpdater::GetSlopeAngle() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CSlopeComponentUpdater->SlopeAngle(ptr=%p)", m_ptr));
    GCAnimParamHandle value(GetSchemaPtr(m_ptr, "CSlopeComponentUpdater", "m_hSlopeAngle"));
    return value;
}
void GCSlopeComponentUpdater::SetSlopeAngle(GCAnimParamHandle value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CSlopeComponentUpdater->SlopeAngle(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'SlopeAngle' is not possible.\n");
}
GCAnimParamHandle GCSlopeComponentUpdater::GetSlopeAngleFront() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CSlopeComponentUpdater->SlopeAngleFront(ptr=%p)", m_ptr));
    GCAnimParamHandle value(GetSchemaPtr(m_ptr, "CSlopeComponentUpdater", "m_hSlopeAngleFront"));
    return value;
}
void GCSlopeComponentUpdater::SetSlopeAngleFront(GCAnimParamHandle value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CSlopeComponentUpdater->SlopeAngleFront(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'SlopeAngleFront' is not possible.\n");
}
GCAnimParamHandle GCSlopeComponentUpdater::GetSlopeAngleSide() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CSlopeComponentUpdater->SlopeAngleSide(ptr=%p)", m_ptr));
    GCAnimParamHandle value(GetSchemaPtr(m_ptr, "CSlopeComponentUpdater", "m_hSlopeAngleSide"));
    return value;
}
void GCSlopeComponentUpdater::SetSlopeAngleSide(GCAnimParamHandle value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CSlopeComponentUpdater->SlopeAngleSide(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'SlopeAngleSide' is not possible.\n");
}
GCAnimParamHandle GCSlopeComponentUpdater::GetSlopeHeading() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CSlopeComponentUpdater->SlopeHeading(ptr=%p)", m_ptr));
    GCAnimParamHandle value(GetSchemaPtr(m_ptr, "CSlopeComponentUpdater", "m_hSlopeHeading"));
    return value;
}
void GCSlopeComponentUpdater::SetSlopeHeading(GCAnimParamHandle value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CSlopeComponentUpdater->SlopeHeading(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'SlopeHeading' is not possible.\n");
}
GCAnimParamHandle GCSlopeComponentUpdater::GetSlopeNormal() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CSlopeComponentUpdater->SlopeNormal(ptr=%p)", m_ptr));
    GCAnimParamHandle value(GetSchemaPtr(m_ptr, "CSlopeComponentUpdater", "m_hSlopeNormal"));
    return value;
}
void GCSlopeComponentUpdater::SetSlopeNormal(GCAnimParamHandle value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CSlopeComponentUpdater->SlopeNormal(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'SlopeNormal' is not possible.\n");
}
GCAnimParamHandle GCSlopeComponentUpdater::GetSlopeNormal_WorldSpace() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CSlopeComponentUpdater->SlopeNormal_WorldSpace(ptr=%p)", m_ptr));
    GCAnimParamHandle value(GetSchemaPtr(m_ptr, "CSlopeComponentUpdater", "m_hSlopeNormal_WorldSpace"));
    return value;
}
void GCSlopeComponentUpdater::SetSlopeNormal_WorldSpace(GCAnimParamHandle value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CSlopeComponentUpdater->SlopeNormal_WorldSpace(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'SlopeNormal_WorldSpace' is not possible.\n");
}
void* GCSlopeComponentUpdater::GetPtr() {
    return m_ptr;
}
std::string GCSlopeComponentUpdater::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCSlopeComponentUpdater::IsValid() {
    return (m_ptr != nullptr);
}
GCAnimComponentUpdater GCSlopeComponentUpdater::GetParent() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CSlopeComponentUpdater::GetParent(ptr=%p)", m_ptr));
    GCAnimComponentUpdater value(m_ptr);
    return value;
}
void GCSlopeComponentUpdater::SetParent(GCAnimComponentUpdater value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CSlopeComponentUpdater::SetParent(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCSlopeComponentUpdater(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCSlopeComponentUpdater>("CSlopeComponentUpdater")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("TraceDistance", &GCSlopeComponentUpdater::GetTraceDistance, &GCSlopeComponentUpdater::SetTraceDistance)
        .addProperty("SlopeAngle", &GCSlopeComponentUpdater::GetSlopeAngle, &GCSlopeComponentUpdater::SetSlopeAngle)
        .addProperty("SlopeAngleFront", &GCSlopeComponentUpdater::GetSlopeAngleFront, &GCSlopeComponentUpdater::SetSlopeAngleFront)
        .addProperty("SlopeAngleSide", &GCSlopeComponentUpdater::GetSlopeAngleSide, &GCSlopeComponentUpdater::SetSlopeAngleSide)
        .addProperty("SlopeHeading", &GCSlopeComponentUpdater::GetSlopeHeading, &GCSlopeComponentUpdater::SetSlopeHeading)
        .addProperty("SlopeNormal", &GCSlopeComponentUpdater::GetSlopeNormal, &GCSlopeComponentUpdater::SetSlopeNormal)
        .addProperty("SlopeNormal_WorldSpace", &GCSlopeComponentUpdater::GetSlopeNormal_WorldSpace, &GCSlopeComponentUpdater::SetSlopeNormal_WorldSpace)
        .addProperty("Parent", &GCSlopeComponentUpdater::GetParent, &GCSlopeComponentUpdater::SetParent)
        .addFunction("ToPtr", &GCSlopeComponentUpdater::ToPtr)
        .addFunction("IsValid", &GCSlopeComponentUpdater::IsValid)
        .endClass();
}
GRnNode_t::GRnNode_t(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GRnNode_t::GRnNode_t(void *ptr) {
    m_ptr = ptr;
}
Vector GRnNode_t::GetMin() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: RnNode_t->Min(ptr=%p)", m_ptr));
    return GetSchemaValue<Vector>(m_ptr, "RnNode_t", "m_vMin");
}
void GRnNode_t::SetMin(Vector value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: RnNode_t->Min(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "RnNode_t", "m_vMin", true, value);
}
uint32_t GRnNode_t::GetChildren() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: RnNode_t->Children(ptr=%p)", m_ptr));
    return GetSchemaValue<uint32_t>(m_ptr, "RnNode_t", "m_nChildren");
}
void GRnNode_t::SetChildren(uint32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: RnNode_t->Children(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "RnNode_t", "m_nChildren", true, value);
}
Vector GRnNode_t::GetMax() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: RnNode_t->Max(ptr=%p)", m_ptr));
    return GetSchemaValue<Vector>(m_ptr, "RnNode_t", "m_vMax");
}
void GRnNode_t::SetMax(Vector value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: RnNode_t->Max(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "RnNode_t", "m_vMax", true, value);
}
uint32_t GRnNode_t::GetTriangleOffset() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: RnNode_t->TriangleOffset(ptr=%p)", m_ptr));
    return GetSchemaValue<uint32_t>(m_ptr, "RnNode_t", "m_nTriangleOffset");
}
void GRnNode_t::SetTriangleOffset(uint32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: RnNode_t->TriangleOffset(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "RnNode_t", "m_nTriangleOffset", true, value);
}
void* GRnNode_t::GetPtr() {
    return m_ptr;
}
std::string GRnNode_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GRnNode_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassRnNode_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GRnNode_t>("RnNode_t")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Min", &GRnNode_t::GetMin, &GRnNode_t::SetMin)
        .addProperty("Children", &GRnNode_t::GetChildren, &GRnNode_t::SetChildren)
        .addProperty("Max", &GRnNode_t::GetMax, &GRnNode_t::SetMax)
        .addProperty("TriangleOffset", &GRnNode_t::GetTriangleOffset, &GRnNode_t::SetTriangleOffset)
        .addFunction("ToPtr", &GRnNode_t::ToPtr)
        .addFunction("IsValid", &GRnNode_t::IsValid)
        .endClass();
}
GCSeqCmdSeqDesc::GCSeqCmdSeqDesc(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCSeqCmdSeqDesc::GCSeqCmdSeqDesc(void *ptr) {
    m_ptr = ptr;
}
GCSeqSeqDescFlag GCSeqCmdSeqDesc::GetFlags() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CSeqCmdSeqDesc->Flags(ptr=%p)", m_ptr));
    GCSeqSeqDescFlag value(GetSchemaPtr(m_ptr, "CSeqCmdSeqDesc", "m_flags"));
    return value;
}
void GCSeqCmdSeqDesc::SetFlags(GCSeqSeqDescFlag value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CSeqCmdSeqDesc->Flags(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Flags' is not possible.\n");
}
GCSeqTransition GCSeqCmdSeqDesc::GetTransition() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CSeqCmdSeqDesc->Transition(ptr=%p)", m_ptr));
    GCSeqTransition value(GetSchemaPtr(m_ptr, "CSeqCmdSeqDesc", "m_transition"));
    return value;
}
void GCSeqCmdSeqDesc::SetTransition(GCSeqTransition value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CSeqCmdSeqDesc->Transition(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Transition' is not possible.\n");
}
int16_t GCSeqCmdSeqDesc::GetFrameRangeSequence() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CSeqCmdSeqDesc->FrameRangeSequence(ptr=%p)", m_ptr));
    return GetSchemaValue<int16_t>(m_ptr, "CSeqCmdSeqDesc", "m_nFrameRangeSequence");
}
void GCSeqCmdSeqDesc::SetFrameRangeSequence(int16_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CSeqCmdSeqDesc->FrameRangeSequence(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CSeqCmdSeqDesc", "m_nFrameRangeSequence", false, value);
}
int16_t GCSeqCmdSeqDesc::GetFrameCount() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CSeqCmdSeqDesc->FrameCount(ptr=%p)", m_ptr));
    return GetSchemaValue<int16_t>(m_ptr, "CSeqCmdSeqDesc", "m_nFrameCount");
}
void GCSeqCmdSeqDesc::SetFrameCount(int16_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CSeqCmdSeqDesc->FrameCount(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CSeqCmdSeqDesc", "m_nFrameCount", false, value);
}
float GCSeqCmdSeqDesc::GetFPS() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CSeqCmdSeqDesc->FPS(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CSeqCmdSeqDesc", "m_flFPS");
}
void GCSeqCmdSeqDesc::SetFPS(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CSeqCmdSeqDesc->FPS(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CSeqCmdSeqDesc", "m_flFPS", false, value);
}
int16_t GCSeqCmdSeqDesc::GetSubCycles() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CSeqCmdSeqDesc->SubCycles(ptr=%p)", m_ptr));
    return GetSchemaValue<int16_t>(m_ptr, "CSeqCmdSeqDesc", "m_nSubCycles");
}
void GCSeqCmdSeqDesc::SetSubCycles(int16_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CSeqCmdSeqDesc->SubCycles(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CSeqCmdSeqDesc", "m_nSubCycles", false, value);
}
int16_t GCSeqCmdSeqDesc::GetNumLocalResults() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CSeqCmdSeqDesc->NumLocalResults(ptr=%p)", m_ptr));
    return GetSchemaValue<int16_t>(m_ptr, "CSeqCmdSeqDesc", "m_numLocalResults");
}
void GCSeqCmdSeqDesc::SetNumLocalResults(int16_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CSeqCmdSeqDesc->NumLocalResults(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CSeqCmdSeqDesc", "m_numLocalResults", false, value);
}
std::vector<GCSeqCmdLayer> GCSeqCmdSeqDesc::GetCmdLayerArray() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CSeqCmdSeqDesc->CmdLayerArray(ptr=%p)", m_ptr));
    CUtlVector<GCSeqCmdLayer>* vec = GetSchemaValue<CUtlVector<GCSeqCmdLayer>*>(m_ptr, "CSeqCmdSeqDesc", "m_cmdLayerArray"); std::vector<GCSeqCmdLayer> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCSeqCmdSeqDesc::SetCmdLayerArray(std::vector<GCSeqCmdLayer> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CSeqCmdSeqDesc->CmdLayerArray(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<GCSeqCmdLayer>(m_ptr, "CSeqCmdSeqDesc", "m_cmdLayerArray", false, value);
}
std::vector<GCAnimEventDefinition> GCSeqCmdSeqDesc::GetEventArray() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CSeqCmdSeqDesc->EventArray(ptr=%p)", m_ptr));
    CUtlVector<GCAnimEventDefinition>* vec = GetSchemaValue<CUtlVector<GCAnimEventDefinition>*>(m_ptr, "CSeqCmdSeqDesc", "m_eventArray"); std::vector<GCAnimEventDefinition> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCSeqCmdSeqDesc::SetEventArray(std::vector<GCAnimEventDefinition> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CSeqCmdSeqDesc->EventArray(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<GCAnimEventDefinition>(m_ptr, "CSeqCmdSeqDesc", "m_eventArray", false, value);
}
std::vector<GCAnimActivity> GCSeqCmdSeqDesc::GetActivityArray() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CSeqCmdSeqDesc->ActivityArray(ptr=%p)", m_ptr));
    CUtlVector<GCAnimActivity>* vec = GetSchemaValue<CUtlVector<GCAnimActivity>*>(m_ptr, "CSeqCmdSeqDesc", "m_activityArray"); std::vector<GCAnimActivity> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCSeqCmdSeqDesc::SetActivityArray(std::vector<GCAnimActivity> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CSeqCmdSeqDesc->ActivityArray(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<GCAnimActivity>(m_ptr, "CSeqCmdSeqDesc", "m_activityArray", false, value);
}
std::vector<GCSeqPoseSetting> GCSeqCmdSeqDesc::GetPoseSettingArray() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CSeqCmdSeqDesc->PoseSettingArray(ptr=%p)", m_ptr));
    CUtlVector<GCSeqPoseSetting>* vec = GetSchemaValue<CUtlVector<GCSeqPoseSetting>*>(m_ptr, "CSeqCmdSeqDesc", "m_poseSettingArray"); std::vector<GCSeqPoseSetting> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCSeqCmdSeqDesc::SetPoseSettingArray(std::vector<GCSeqPoseSetting> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CSeqCmdSeqDesc->PoseSettingArray(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<GCSeqPoseSetting>(m_ptr, "CSeqCmdSeqDesc", "m_poseSettingArray", false, value);
}
void* GCSeqCmdSeqDesc::GetPtr() {
    return m_ptr;
}
std::string GCSeqCmdSeqDesc::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCSeqCmdSeqDesc::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCSeqCmdSeqDesc(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCSeqCmdSeqDesc>("CSeqCmdSeqDesc")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Flags", &GCSeqCmdSeqDesc::GetFlags, &GCSeqCmdSeqDesc::SetFlags)
        .addProperty("Transition", &GCSeqCmdSeqDesc::GetTransition, &GCSeqCmdSeqDesc::SetTransition)
        .addProperty("FrameRangeSequence", &GCSeqCmdSeqDesc::GetFrameRangeSequence, &GCSeqCmdSeqDesc::SetFrameRangeSequence)
        .addProperty("FrameCount", &GCSeqCmdSeqDesc::GetFrameCount, &GCSeqCmdSeqDesc::SetFrameCount)
        .addProperty("FPS", &GCSeqCmdSeqDesc::GetFPS, &GCSeqCmdSeqDesc::SetFPS)
        .addProperty("SubCycles", &GCSeqCmdSeqDesc::GetSubCycles, &GCSeqCmdSeqDesc::SetSubCycles)
        .addProperty("NumLocalResults", &GCSeqCmdSeqDesc::GetNumLocalResults, &GCSeqCmdSeqDesc::SetNumLocalResults)
        .addProperty("CmdLayerArray", &GCSeqCmdSeqDesc::GetCmdLayerArray, &GCSeqCmdSeqDesc::SetCmdLayerArray)
        .addProperty("EventArray", &GCSeqCmdSeqDesc::GetEventArray, &GCSeqCmdSeqDesc::SetEventArray)
        .addProperty("ActivityArray", &GCSeqCmdSeqDesc::GetActivityArray, &GCSeqCmdSeqDesc::SetActivityArray)
        .addProperty("PoseSettingArray", &GCSeqCmdSeqDesc::GetPoseSettingArray, &GCSeqCmdSeqDesc::SetPoseSettingArray)
        .addFunction("ToPtr", &GCSeqCmdSeqDesc::ToPtr)
        .addFunction("IsValid", &GCSeqCmdSeqDesc::IsValid)
        .endClass();
}
GCPathAnimMotorUpdaterBase::GCPathAnimMotorUpdaterBase(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCPathAnimMotorUpdaterBase::GCPathAnimMotorUpdaterBase(void *ptr) {
    m_ptr = ptr;
}
bool GCPathAnimMotorUpdaterBase::GetLockToPath() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CPathAnimMotorUpdaterBase->LockToPath(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "CPathAnimMotorUpdaterBase", "m_bLockToPath");
}
void GCPathAnimMotorUpdaterBase::SetLockToPath(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CPathAnimMotorUpdaterBase->LockToPath(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CPathAnimMotorUpdaterBase", "m_bLockToPath", false, value);
}
void* GCPathAnimMotorUpdaterBase::GetPtr() {
    return m_ptr;
}
std::string GCPathAnimMotorUpdaterBase::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCPathAnimMotorUpdaterBase::IsValid() {
    return (m_ptr != nullptr);
}
GCAnimMotorUpdaterBase GCPathAnimMotorUpdaterBase::GetParent() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CPathAnimMotorUpdaterBase::GetParent(ptr=%p)", m_ptr));
    GCAnimMotorUpdaterBase value(m_ptr);
    return value;
}
void GCPathAnimMotorUpdaterBase::SetParent(GCAnimMotorUpdaterBase value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CPathAnimMotorUpdaterBase::SetParent(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCPathAnimMotorUpdaterBase(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCPathAnimMotorUpdaterBase>("CPathAnimMotorUpdaterBase")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("LockToPath", &GCPathAnimMotorUpdaterBase::GetLockToPath, &GCPathAnimMotorUpdaterBase::SetLockToPath)
        .addProperty("Parent", &GCPathAnimMotorUpdaterBase::GetParent, &GCPathAnimMotorUpdaterBase::SetParent)
        .addFunction("ToPtr", &GCPathAnimMotorUpdaterBase::ToPtr)
        .addFunction("IsValid", &GCPathAnimMotorUpdaterBase::IsValid)
        .endClass();
}
GCVariantDefaultAllocator::GCVariantDefaultAllocator(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCVariantDefaultAllocator::GCVariantDefaultAllocator(void *ptr) {
    m_ptr = ptr;
}
void* GCVariantDefaultAllocator::GetPtr() {
    return m_ptr;
}
std::string GCVariantDefaultAllocator::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCVariantDefaultAllocator::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCVariantDefaultAllocator(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCVariantDefaultAllocator>("CVariantDefaultAllocator")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addFunction("ToPtr", &GCVariantDefaultAllocator::ToPtr)
        .addFunction("IsValid", &GCVariantDefaultAllocator::IsValid)
        .endClass();
}
GVMixOscDesc_t::GVMixOscDesc_t(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GVMixOscDesc_t::GVMixOscDesc_t(void *ptr) {
    m_ptr = ptr;
}
uint64_t GVMixOscDesc_t::GetOscType() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: VMixOscDesc_t->OscType(ptr=%p)", m_ptr));
    return GetSchemaValue<uint64_t>(m_ptr, "VMixOscDesc_t", "oscType");
}
void GVMixOscDesc_t::SetOscType(uint64_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: VMixOscDesc_t->OscType(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "VMixOscDesc_t", "oscType", true, value);
}
float GVMixOscDesc_t::GetFreq() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: VMixOscDesc_t->Freq(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "VMixOscDesc_t", "m_freq");
}
void GVMixOscDesc_t::SetFreq(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: VMixOscDesc_t->Freq(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "VMixOscDesc_t", "m_freq", true, value);
}
float GVMixOscDesc_t::GetPhase() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: VMixOscDesc_t->Phase(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "VMixOscDesc_t", "m_flPhase");
}
void GVMixOscDesc_t::SetPhase(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: VMixOscDesc_t->Phase(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "VMixOscDesc_t", "m_flPhase", true, value);
}
void* GVMixOscDesc_t::GetPtr() {
    return m_ptr;
}
std::string GVMixOscDesc_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GVMixOscDesc_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassVMixOscDesc_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GVMixOscDesc_t>("VMixOscDesc_t")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("OscType", &GVMixOscDesc_t::GetOscType, &GVMixOscDesc_t::SetOscType)
        .addProperty("Freq", &GVMixOscDesc_t::GetFreq, &GVMixOscDesc_t::SetFreq)
        .addProperty("Phase", &GVMixOscDesc_t::GetPhase, &GVMixOscDesc_t::SetPhase)
        .addFunction("ToPtr", &GVMixOscDesc_t::ToPtr)
        .addFunction("IsValid", &GVMixOscDesc_t::IsValid)
        .endClass();
}
GFeEdgeDesc_t::GFeEdgeDesc_t(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GFeEdgeDesc_t::GFeEdgeDesc_t(void *ptr) {
    m_ptr = ptr;
}
std::vector<uint16_t> GFeEdgeDesc_t::GetEdge() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FeEdgeDesc_t->Edge(ptr=%p,size=2)", m_ptr));
    uint16_t* outValue = (uint16_t*)GetSchemaPtr(m_ptr, "FeEdgeDesc_t", "nEdge"); std::vector<uint16_t> ret; for(int i = 0; i < 2; i++) { ret.push_back(outValue[i]); } return ret;
}
void GFeEdgeDesc_t::SetEdge(std::vector<uint16_t> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FeEdgeDesc_t->Edge(ptr=%p,size=2)", m_ptr));
    if(value.size() != 2) return PLUGIN_PRINT("Schema SDK", "Field 'Edge' needs to have 2 values.\n");
    auto val = GetSchemaValuePtr<uint16_t>(m_ptr, "FeEdgeDesc_t", "nEdge");
    for(size_t i = 0; i < value.size(); i++) val[i] = value[i];
}
std::vector<uint16_t> GFeEdgeDesc_t::GetVirtElem() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FeEdgeDesc_t->VirtElem(ptr=%p,size=2)", m_ptr));
    uint16_t* outValue = (uint16_t*)GetSchemaPtr(m_ptr, "FeEdgeDesc_t", "nVirtElem"); std::vector<uint16_t> ret; for(int i = 0; i < 2; i++) { ret.push_back(outValue[i]); } return ret;
}
void GFeEdgeDesc_t::SetVirtElem(std::vector<uint16_t> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FeEdgeDesc_t->VirtElem(ptr=%p,size=2)", m_ptr));
    if(value.size() != 2) return PLUGIN_PRINT("Schema SDK", "Field 'VirtElem' needs to have 2 values.\n");
    auto val = GetSchemaValuePtr<uint16_t>(m_ptr, "FeEdgeDesc_t", "nVirtElem");
    for(size_t i = 0; i < value.size(); i++) val[i] = value[i];
}
void* GFeEdgeDesc_t::GetPtr() {
    return m_ptr;
}
std::string GFeEdgeDesc_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GFeEdgeDesc_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassFeEdgeDesc_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GFeEdgeDesc_t>("FeEdgeDesc_t")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Edge", &GFeEdgeDesc_t::GetEdge, &GFeEdgeDesc_t::SetEdge)
        .addProperty("VirtElem", &GFeEdgeDesc_t::GetVirtElem, &GFeEdgeDesc_t::SetVirtElem)
        .addFunction("ToPtr", &GFeEdgeDesc_t::ToPtr)
        .addFunction("IsValid", &GFeEdgeDesc_t::IsValid)
        .endClass();
}
GCPathAnimMotorUpdater::GCPathAnimMotorUpdater(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCPathAnimMotorUpdater::GCPathAnimMotorUpdater(void *ptr) {
    m_ptr = ptr;
}
void* GCPathAnimMotorUpdater::GetPtr() {
    return m_ptr;
}
std::string GCPathAnimMotorUpdater::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCPathAnimMotorUpdater::IsValid() {
    return (m_ptr != nullptr);
}
GCPathAnimMotorUpdaterBase GCPathAnimMotorUpdater::GetParent() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CPathAnimMotorUpdater::GetParent(ptr=%p)", m_ptr));
    GCPathAnimMotorUpdaterBase value(m_ptr);
    return value;
}
void GCPathAnimMotorUpdater::SetParent(GCPathAnimMotorUpdaterBase value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CPathAnimMotorUpdater::SetParent(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCPathAnimMotorUpdater(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCPathAnimMotorUpdater>("CPathAnimMotorUpdater")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Parent", &GCPathAnimMotorUpdater::GetParent, &GCPathAnimMotorUpdater::SetParent)
        .addFunction("ToPtr", &GCPathAnimMotorUpdater::ToPtr)
        .addFunction("IsValid", &GCPathAnimMotorUpdater::IsValid)
        .endClass();
}
GCWayPointHelperUpdateNode::GCWayPointHelperUpdateNode(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCWayPointHelperUpdateNode::GCWayPointHelperUpdateNode(void *ptr) {
    m_ptr = ptr;
}
float GCWayPointHelperUpdateNode::GetStartCycle() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CWayPointHelperUpdateNode->StartCycle(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CWayPointHelperUpdateNode", "m_flStartCycle");
}
void GCWayPointHelperUpdateNode::SetStartCycle(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CWayPointHelperUpdateNode->StartCycle(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CWayPointHelperUpdateNode", "m_flStartCycle", false, value);
}
float GCWayPointHelperUpdateNode::GetEndCycle() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CWayPointHelperUpdateNode->EndCycle(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CWayPointHelperUpdateNode", "m_flEndCycle");
}
void GCWayPointHelperUpdateNode::SetEndCycle(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CWayPointHelperUpdateNode->EndCycle(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CWayPointHelperUpdateNode", "m_flEndCycle", false, value);
}
bool GCWayPointHelperUpdateNode::GetOnlyGoals() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CWayPointHelperUpdateNode->OnlyGoals(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "CWayPointHelperUpdateNode", "m_bOnlyGoals");
}
void GCWayPointHelperUpdateNode::SetOnlyGoals(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CWayPointHelperUpdateNode->OnlyGoals(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CWayPointHelperUpdateNode", "m_bOnlyGoals", false, value);
}
bool GCWayPointHelperUpdateNode::GetPreventOvershoot() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CWayPointHelperUpdateNode->PreventOvershoot(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "CWayPointHelperUpdateNode", "m_bPreventOvershoot");
}
void GCWayPointHelperUpdateNode::SetPreventOvershoot(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CWayPointHelperUpdateNode->PreventOvershoot(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CWayPointHelperUpdateNode", "m_bPreventOvershoot", false, value);
}
bool GCWayPointHelperUpdateNode::GetPreventUndershoot() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CWayPointHelperUpdateNode->PreventUndershoot(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "CWayPointHelperUpdateNode", "m_bPreventUndershoot");
}
void GCWayPointHelperUpdateNode::SetPreventUndershoot(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CWayPointHelperUpdateNode->PreventUndershoot(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CWayPointHelperUpdateNode", "m_bPreventUndershoot", false, value);
}
void* GCWayPointHelperUpdateNode::GetPtr() {
    return m_ptr;
}
std::string GCWayPointHelperUpdateNode::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCWayPointHelperUpdateNode::IsValid() {
    return (m_ptr != nullptr);
}
GCUnaryUpdateNode GCWayPointHelperUpdateNode::GetParent() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CWayPointHelperUpdateNode::GetParent(ptr=%p)", m_ptr));
    GCUnaryUpdateNode value(m_ptr);
    return value;
}
void GCWayPointHelperUpdateNode::SetParent(GCUnaryUpdateNode value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CWayPointHelperUpdateNode::SetParent(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCWayPointHelperUpdateNode(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCWayPointHelperUpdateNode>("CWayPointHelperUpdateNode")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("StartCycle", &GCWayPointHelperUpdateNode::GetStartCycle, &GCWayPointHelperUpdateNode::SetStartCycle)
        .addProperty("EndCycle", &GCWayPointHelperUpdateNode::GetEndCycle, &GCWayPointHelperUpdateNode::SetEndCycle)
        .addProperty("OnlyGoals", &GCWayPointHelperUpdateNode::GetOnlyGoals, &GCWayPointHelperUpdateNode::SetOnlyGoals)
        .addProperty("PreventOvershoot", &GCWayPointHelperUpdateNode::GetPreventOvershoot, &GCWayPointHelperUpdateNode::SetPreventOvershoot)
        .addProperty("PreventUndershoot", &GCWayPointHelperUpdateNode::GetPreventUndershoot, &GCWayPointHelperUpdateNode::SetPreventUndershoot)
        .addProperty("Parent", &GCWayPointHelperUpdateNode::GetParent, &GCWayPointHelperUpdateNode::SetParent)
        .addFunction("ToPtr", &GCWayPointHelperUpdateNode::ToPtr)
        .addFunction("IsValid", &GCWayPointHelperUpdateNode::IsValid)
        .endClass();
}
GMaterialParamInt_t::GMaterialParamInt_t(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GMaterialParamInt_t::GMaterialParamInt_t(void *ptr) {
    m_ptr = ptr;
}
int32_t GMaterialParamInt_t::GetValue() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: MaterialParamInt_t->Value(ptr=%p)", m_ptr));
    return GetSchemaValue<int32_t>(m_ptr, "MaterialParamInt_t", "m_nValue");
}
void GMaterialParamInt_t::SetValue(int32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: MaterialParamInt_t->Value(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "MaterialParamInt_t", "m_nValue", true, value);
}
void* GMaterialParamInt_t::GetPtr() {
    return m_ptr;
}
std::string GMaterialParamInt_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GMaterialParamInt_t::IsValid() {
    return (m_ptr != nullptr);
}
GMaterialParam_t GMaterialParamInt_t::GetParent() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("MaterialParamInt_t::GetParent(ptr=%p)", m_ptr));
    GMaterialParam_t value(m_ptr);
    return value;
}
void GMaterialParamInt_t::SetParent(GMaterialParam_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("MaterialParamInt_t::SetParent(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassMaterialParamInt_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GMaterialParamInt_t>("MaterialParamInt_t")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Value", &GMaterialParamInt_t::GetValue, &GMaterialParamInt_t::SetValue)
        .addProperty("Parent", &GMaterialParamInt_t::GetParent, &GMaterialParamInt_t::SetParent)
        .addFunction("ToPtr", &GMaterialParamInt_t::ToPtr)
        .addFunction("IsValid", &GMaterialParamInt_t::IsValid)
        .endClass();
}
GPermModelInfo_t::GPermModelInfo_t(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GPermModelInfo_t::GPermModelInfo_t(void *ptr) {
    m_ptr = ptr;
}
uint32_t GPermModelInfo_t::GetFlags() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: PermModelInfo_t->Flags(ptr=%p)", m_ptr));
    return GetSchemaValue<uint32_t>(m_ptr, "PermModelInfo_t", "m_nFlags");
}
void GPermModelInfo_t::SetFlags(uint32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: PermModelInfo_t->Flags(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "PermModelInfo_t", "m_nFlags", true, value);
}
Vector GPermModelInfo_t::GetHullMin() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: PermModelInfo_t->HullMin(ptr=%p)", m_ptr));
    return GetSchemaValue<Vector>(m_ptr, "PermModelInfo_t", "m_vHullMin");
}
void GPermModelInfo_t::SetHullMin(Vector value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: PermModelInfo_t->HullMin(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "PermModelInfo_t", "m_vHullMin", true, value);
}
Vector GPermModelInfo_t::GetHullMax() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: PermModelInfo_t->HullMax(ptr=%p)", m_ptr));
    return GetSchemaValue<Vector>(m_ptr, "PermModelInfo_t", "m_vHullMax");
}
void GPermModelInfo_t::SetHullMax(Vector value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: PermModelInfo_t->HullMax(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "PermModelInfo_t", "m_vHullMax", true, value);
}
Vector GPermModelInfo_t::GetViewMin() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: PermModelInfo_t->ViewMin(ptr=%p)", m_ptr));
    return GetSchemaValue<Vector>(m_ptr, "PermModelInfo_t", "m_vViewMin");
}
void GPermModelInfo_t::SetViewMin(Vector value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: PermModelInfo_t->ViewMin(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "PermModelInfo_t", "m_vViewMin", true, value);
}
Vector GPermModelInfo_t::GetViewMax() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: PermModelInfo_t->ViewMax(ptr=%p)", m_ptr));
    return GetSchemaValue<Vector>(m_ptr, "PermModelInfo_t", "m_vViewMax");
}
void GPermModelInfo_t::SetViewMax(Vector value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: PermModelInfo_t->ViewMax(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "PermModelInfo_t", "m_vViewMax", true, value);
}
float GPermModelInfo_t::GetMass() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: PermModelInfo_t->Mass(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "PermModelInfo_t", "m_flMass");
}
void GPermModelInfo_t::SetMass(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: PermModelInfo_t->Mass(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "PermModelInfo_t", "m_flMass", true, value);
}
Vector GPermModelInfo_t::GetEyePosition() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: PermModelInfo_t->EyePosition(ptr=%p)", m_ptr));
    return GetSchemaValue<Vector>(m_ptr, "PermModelInfo_t", "m_vEyePosition");
}
void GPermModelInfo_t::SetEyePosition(Vector value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: PermModelInfo_t->EyePosition(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "PermModelInfo_t", "m_vEyePosition", true, value);
}
float GPermModelInfo_t::GetMaxEyeDeflection() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: PermModelInfo_t->MaxEyeDeflection(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "PermModelInfo_t", "m_flMaxEyeDeflection");
}
void GPermModelInfo_t::SetMaxEyeDeflection(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: PermModelInfo_t->MaxEyeDeflection(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "PermModelInfo_t", "m_flMaxEyeDeflection", true, value);
}
std::string GPermModelInfo_t::GetSurfaceProperty() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: PermModelInfo_t->SurfaceProperty(ptr=%p)", m_ptr));
    return GetSchemaValue<CUtlString>(m_ptr, "PermModelInfo_t", "m_sSurfaceProperty").Get();
}
void GPermModelInfo_t::SetSurfaceProperty(std::string value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: PermModelInfo_t->SurfaceProperty(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "PermModelInfo_t", "m_sSurfaceProperty", true, CUtlString(value.c_str()));
}
std::string GPermModelInfo_t::GetKeyValueText() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: PermModelInfo_t->KeyValueText(ptr=%p)", m_ptr));
    return GetSchemaValue<CUtlString>(m_ptr, "PermModelInfo_t", "m_keyValueText").Get();
}
void GPermModelInfo_t::SetKeyValueText(std::string value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: PermModelInfo_t->KeyValueText(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "PermModelInfo_t", "m_keyValueText", true, CUtlString(value.c_str()));
}
void* GPermModelInfo_t::GetPtr() {
    return m_ptr;
}
std::string GPermModelInfo_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GPermModelInfo_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassPermModelInfo_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GPermModelInfo_t>("PermModelInfo_t")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Flags", &GPermModelInfo_t::GetFlags, &GPermModelInfo_t::SetFlags)
        .addProperty("HullMin", &GPermModelInfo_t::GetHullMin, &GPermModelInfo_t::SetHullMin)
        .addProperty("HullMax", &GPermModelInfo_t::GetHullMax, &GPermModelInfo_t::SetHullMax)
        .addProperty("ViewMin", &GPermModelInfo_t::GetViewMin, &GPermModelInfo_t::SetViewMin)
        .addProperty("ViewMax", &GPermModelInfo_t::GetViewMax, &GPermModelInfo_t::SetViewMax)
        .addProperty("Mass", &GPermModelInfo_t::GetMass, &GPermModelInfo_t::SetMass)
        .addProperty("EyePosition", &GPermModelInfo_t::GetEyePosition, &GPermModelInfo_t::SetEyePosition)
        .addProperty("MaxEyeDeflection", &GPermModelInfo_t::GetMaxEyeDeflection, &GPermModelInfo_t::SetMaxEyeDeflection)
        .addProperty("SurfaceProperty", &GPermModelInfo_t::GetSurfaceProperty, &GPermModelInfo_t::SetSurfaceProperty)
        .addProperty("KeyValueText", &GPermModelInfo_t::GetKeyValueText, &GPermModelInfo_t::SetKeyValueText)
        .addFunction("ToPtr", &GPermModelInfo_t::ToPtr)
        .addFunction("IsValid", &GPermModelInfo_t::IsValid)
        .endClass();
}
GAnimScriptHandle::GAnimScriptHandle(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GAnimScriptHandle::GAnimScriptHandle(void *ptr) {
    m_ptr = ptr;
}
uint32_t GAnimScriptHandle::GetId() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: AnimScriptHandle->Id(ptr=%p)", m_ptr));
    return GetSchemaValue<uint32_t>(m_ptr, "AnimScriptHandle", "m_id");
}
void GAnimScriptHandle::SetId(uint32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: AnimScriptHandle->Id(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "AnimScriptHandle", "m_id", false, value);
}
void* GAnimScriptHandle::GetPtr() {
    return m_ptr;
}
std::string GAnimScriptHandle::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GAnimScriptHandle::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassAnimScriptHandle(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GAnimScriptHandle>("AnimScriptHandle")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Id", &GAnimScriptHandle::GetId, &GAnimScriptHandle::SetId)
        .addFunction("ToPtr", &GAnimScriptHandle::ToPtr)
        .addFunction("IsValid", &GAnimScriptHandle::IsValid)
        .endClass();
}
GFeCtrlOffset_t::GFeCtrlOffset_t(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GFeCtrlOffset_t::GFeCtrlOffset_t(void *ptr) {
    m_ptr = ptr;
}
Vector GFeCtrlOffset_t::GetOffset() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FeCtrlOffset_t->Offset(ptr=%p)", m_ptr));
    return GetSchemaValue<Vector>(m_ptr, "FeCtrlOffset_t", "vOffset");
}
void GFeCtrlOffset_t::SetOffset(Vector value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FeCtrlOffset_t->Offset(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "FeCtrlOffset_t", "vOffset", true, value);
}
uint16_t GFeCtrlOffset_t::GetCtrlParent() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FeCtrlOffset_t->CtrlParent(ptr=%p)", m_ptr));
    return GetSchemaValue<uint16_t>(m_ptr, "FeCtrlOffset_t", "nCtrlParent");
}
void GFeCtrlOffset_t::SetCtrlParent(uint16_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FeCtrlOffset_t->CtrlParent(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "FeCtrlOffset_t", "nCtrlParent", true, value);
}
uint16_t GFeCtrlOffset_t::GetCtrlChild() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FeCtrlOffset_t->CtrlChild(ptr=%p)", m_ptr));
    return GetSchemaValue<uint16_t>(m_ptr, "FeCtrlOffset_t", "nCtrlChild");
}
void GFeCtrlOffset_t::SetCtrlChild(uint16_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FeCtrlOffset_t->CtrlChild(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "FeCtrlOffset_t", "nCtrlChild", true, value);
}
void* GFeCtrlOffset_t::GetPtr() {
    return m_ptr;
}
std::string GFeCtrlOffset_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GFeCtrlOffset_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassFeCtrlOffset_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GFeCtrlOffset_t>("FeCtrlOffset_t")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Offset", &GFeCtrlOffset_t::GetOffset, &GFeCtrlOffset_t::SetOffset)
        .addProperty("CtrlParent", &GFeCtrlOffset_t::GetCtrlParent, &GFeCtrlOffset_t::SetCtrlParent)
        .addProperty("CtrlChild", &GFeCtrlOffset_t::GetCtrlChild, &GFeCtrlOffset_t::SetCtrlChild)
        .addFunction("ToPtr", &GFeCtrlOffset_t::ToPtr)
        .addFunction("IsValid", &GFeCtrlOffset_t::IsValid)
        .endClass();
}
GFeTri_t::GFeTri_t(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GFeTri_t::GFeTri_t(void *ptr) {
    m_ptr = ptr;
}
std::vector<uint16_t> GFeTri_t::GetNode() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FeTri_t->Node(ptr=%p,size=3)", m_ptr));
    uint16_t* outValue = (uint16_t*)GetSchemaPtr(m_ptr, "FeTri_t", "nNode"); std::vector<uint16_t> ret; for(int i = 0; i < 3; i++) { ret.push_back(outValue[i]); } return ret;
}
void GFeTri_t::SetNode(std::vector<uint16_t> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FeTri_t->Node(ptr=%p,size=3)", m_ptr));
    if(value.size() != 3) return PLUGIN_PRINT("Schema SDK", "Field 'Node' needs to have 3 values.\n");
    auto val = GetSchemaValuePtr<uint16_t>(m_ptr, "FeTri_t", "nNode");
    for(size_t i = 0; i < value.size(); i++) val[i] = value[i];
}
float GFeTri_t::GetW1() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FeTri_t->W1(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "FeTri_t", "w1");
}
void GFeTri_t::SetW1(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FeTri_t->W1(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "FeTri_t", "w1", true, value);
}
float GFeTri_t::GetW2() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FeTri_t->W2(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "FeTri_t", "w2");
}
void GFeTri_t::SetW2(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FeTri_t->W2(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "FeTri_t", "w2", true, value);
}
float GFeTri_t::Get1x() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FeTri_t->1x(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "FeTri_t", "v1x");
}
void GFeTri_t::Set1x(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FeTri_t->1x(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "FeTri_t", "v1x", true, value);
}
Vector2D GFeTri_t::Get2() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FeTri_t->2(ptr=%p)", m_ptr));
    return GetSchemaValue<Vector2D>(m_ptr, "FeTri_t", "v2");
}
void GFeTri_t::Set2(Vector2D value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FeTri_t->2(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "FeTri_t", "v2", true, value);
}
void* GFeTri_t::GetPtr() {
    return m_ptr;
}
std::string GFeTri_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GFeTri_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassFeTri_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GFeTri_t>("FeTri_t")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Node", &GFeTri_t::GetNode, &GFeTri_t::SetNode)
        .addProperty("W1", &GFeTri_t::GetW1, &GFeTri_t::SetW1)
        .addProperty("W2", &GFeTri_t::GetW2, &GFeTri_t::SetW2)
        .addProperty("1x", &GFeTri_t::Get1x, &GFeTri_t::Set1x)
        .addProperty("2", &GFeTri_t::Get2, &GFeTri_t::Set2)
        .addFunction("ToPtr", &GFeTri_t::ToPtr)
        .addFunction("IsValid", &GFeTri_t::IsValid)
        .endClass();
}
GCLeanMatrixUpdateNode::GCLeanMatrixUpdateNode(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCLeanMatrixUpdateNode::GCLeanMatrixUpdateNode(void *ptr) {
    m_ptr = ptr;
}
std::vector<GCPoseHandle> GCLeanMatrixUpdateNode::GetPoses() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CLeanMatrixUpdateNode->Poses(ptr=%p,size=9)", m_ptr));
    GCPoseHandle* outValue = (GCPoseHandle*)GetSchemaPtr(m_ptr, "CLeanMatrixUpdateNode", "m_poses"); std::vector<GCPoseHandle> ret; for(int i = 0; i < 9; i++) { ret.push_back(outValue[i]); } return ret;
}
void GCLeanMatrixUpdateNode::SetPoses(std::vector<GCPoseHandle> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CLeanMatrixUpdateNode->Poses(ptr=%p,size=9)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Poses' is not possible.\n");
}
GCAnimInputDamping GCLeanMatrixUpdateNode::GetDamping() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CLeanMatrixUpdateNode->Damping(ptr=%p)", m_ptr));
    GCAnimInputDamping value(GetSchemaPtr(m_ptr, "CLeanMatrixUpdateNode", "m_damping"));
    return value;
}
void GCLeanMatrixUpdateNode::SetDamping(GCAnimInputDamping value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CLeanMatrixUpdateNode->Damping(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Damping' is not possible.\n");
}
uint64_t GCLeanMatrixUpdateNode::GetBlendSource() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CLeanMatrixUpdateNode->BlendSource(ptr=%p)", m_ptr));
    return GetSchemaValue<uint64_t>(m_ptr, "CLeanMatrixUpdateNode", "m_blendSource");
}
void GCLeanMatrixUpdateNode::SetBlendSource(uint64_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CLeanMatrixUpdateNode->BlendSource(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CLeanMatrixUpdateNode", "m_blendSource", false, value);
}
GCAnimParamHandle GCLeanMatrixUpdateNode::GetParamIndex() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CLeanMatrixUpdateNode->ParamIndex(ptr=%p)", m_ptr));
    GCAnimParamHandle value(GetSchemaPtr(m_ptr, "CLeanMatrixUpdateNode", "m_paramIndex"));
    return value;
}
void GCLeanMatrixUpdateNode::SetParamIndex(GCAnimParamHandle value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CLeanMatrixUpdateNode->ParamIndex(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'ParamIndex' is not possible.\n");
}
Vector GCLeanMatrixUpdateNode::GetVerticalAxis() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CLeanMatrixUpdateNode->VerticalAxis(ptr=%p)", m_ptr));
    return GetSchemaValue<Vector>(m_ptr, "CLeanMatrixUpdateNode", "m_verticalAxis");
}
void GCLeanMatrixUpdateNode::SetVerticalAxis(Vector value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CLeanMatrixUpdateNode->VerticalAxis(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CLeanMatrixUpdateNode", "m_verticalAxis", false, value);
}
Vector GCLeanMatrixUpdateNode::GetHorizontalAxis() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CLeanMatrixUpdateNode->HorizontalAxis(ptr=%p)", m_ptr));
    return GetSchemaValue<Vector>(m_ptr, "CLeanMatrixUpdateNode", "m_horizontalAxis");
}
void GCLeanMatrixUpdateNode::SetHorizontalAxis(Vector value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CLeanMatrixUpdateNode->HorizontalAxis(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CLeanMatrixUpdateNode", "m_horizontalAxis", false, value);
}
float GCLeanMatrixUpdateNode::GetMaxValue() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CLeanMatrixUpdateNode->MaxValue(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CLeanMatrixUpdateNode", "m_flMaxValue");
}
void GCLeanMatrixUpdateNode::SetMaxValue(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CLeanMatrixUpdateNode->MaxValue(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CLeanMatrixUpdateNode", "m_flMaxValue", false, value);
}
int32_t GCLeanMatrixUpdateNode::GetSequenceMaxFrame() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CLeanMatrixUpdateNode->SequenceMaxFrame(ptr=%p)", m_ptr));
    return GetSchemaValue<int32_t>(m_ptr, "CLeanMatrixUpdateNode", "m_nSequenceMaxFrame");
}
void GCLeanMatrixUpdateNode::SetSequenceMaxFrame(int32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CLeanMatrixUpdateNode->SequenceMaxFrame(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CLeanMatrixUpdateNode", "m_nSequenceMaxFrame", false, value);
}
void* GCLeanMatrixUpdateNode::GetPtr() {
    return m_ptr;
}
std::string GCLeanMatrixUpdateNode::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCLeanMatrixUpdateNode::IsValid() {
    return (m_ptr != nullptr);
}
GCLeafUpdateNode GCLeanMatrixUpdateNode::GetParent() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CLeanMatrixUpdateNode::GetParent(ptr=%p)", m_ptr));
    GCLeafUpdateNode value(m_ptr);
    return value;
}
void GCLeanMatrixUpdateNode::SetParent(GCLeafUpdateNode value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CLeanMatrixUpdateNode::SetParent(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCLeanMatrixUpdateNode(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCLeanMatrixUpdateNode>("CLeanMatrixUpdateNode")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Poses", &GCLeanMatrixUpdateNode::GetPoses, &GCLeanMatrixUpdateNode::SetPoses)
        .addProperty("Damping", &GCLeanMatrixUpdateNode::GetDamping, &GCLeanMatrixUpdateNode::SetDamping)
        .addProperty("BlendSource", &GCLeanMatrixUpdateNode::GetBlendSource, &GCLeanMatrixUpdateNode::SetBlendSource)
        .addProperty("ParamIndex", &GCLeanMatrixUpdateNode::GetParamIndex, &GCLeanMatrixUpdateNode::SetParamIndex)
        .addProperty("VerticalAxis", &GCLeanMatrixUpdateNode::GetVerticalAxis, &GCLeanMatrixUpdateNode::SetVerticalAxis)
        .addProperty("HorizontalAxis", &GCLeanMatrixUpdateNode::GetHorizontalAxis, &GCLeanMatrixUpdateNode::SetHorizontalAxis)
        .addProperty("MaxValue", &GCLeanMatrixUpdateNode::GetMaxValue, &GCLeanMatrixUpdateNode::SetMaxValue)
        .addProperty("SequenceMaxFrame", &GCLeanMatrixUpdateNode::GetSequenceMaxFrame, &GCLeanMatrixUpdateNode::SetSequenceMaxFrame)
        .addProperty("Parent", &GCLeanMatrixUpdateNode::GetParent, &GCLeanMatrixUpdateNode::SetParent)
        .addFunction("ToPtr", &GCLeanMatrixUpdateNode::ToPtr)
        .addFunction("IsValid", &GCLeanMatrixUpdateNode::IsValid)
        .endClass();
}
GCStanceScaleUpdateNode::GCStanceScaleUpdateNode(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCStanceScaleUpdateNode::GCStanceScaleUpdateNode(void *ptr) {
    m_ptr = ptr;
}
GCAnimParamHandle GCStanceScaleUpdateNode::GetParam() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CStanceScaleUpdateNode->Param(ptr=%p)", m_ptr));
    GCAnimParamHandle value(GetSchemaPtr(m_ptr, "CStanceScaleUpdateNode", "m_hParam"));
    return value;
}
void GCStanceScaleUpdateNode::SetParam(GCAnimParamHandle value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CStanceScaleUpdateNode->Param(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Param' is not possible.\n");
}
void* GCStanceScaleUpdateNode::GetPtr() {
    return m_ptr;
}
std::string GCStanceScaleUpdateNode::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCStanceScaleUpdateNode::IsValid() {
    return (m_ptr != nullptr);
}
GCUnaryUpdateNode GCStanceScaleUpdateNode::GetParent() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CStanceScaleUpdateNode::GetParent(ptr=%p)", m_ptr));
    GCUnaryUpdateNode value(m_ptr);
    return value;
}
void GCStanceScaleUpdateNode::SetParent(GCUnaryUpdateNode value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CStanceScaleUpdateNode::SetParent(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCStanceScaleUpdateNode(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCStanceScaleUpdateNode>("CStanceScaleUpdateNode")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Param", &GCStanceScaleUpdateNode::GetParam, &GCStanceScaleUpdateNode::SetParam)
        .addProperty("Parent", &GCStanceScaleUpdateNode::GetParent, &GCStanceScaleUpdateNode::SetParent)
        .addFunction("ToPtr", &GCStanceScaleUpdateNode::ToPtr)
        .addFunction("IsValid", &GCStanceScaleUpdateNode::IsValid)
        .endClass();
}
GIKTargetSettings_t::GIKTargetSettings_t(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GIKTargetSettings_t::GIKTargetSettings_t(void *ptr) {
    m_ptr = ptr;
}
uint64_t GIKTargetSettings_t::GetTargetSource() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: IKTargetSettings_t->TargetSource(ptr=%p)", m_ptr));
    return GetSchemaValue<uint64_t>(m_ptr, "IKTargetSettings_t", "m_TargetSource");
}
void GIKTargetSettings_t::SetTargetSource(uint64_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: IKTargetSettings_t->TargetSource(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "IKTargetSettings_t", "m_TargetSource", true, value);
}
GIKBoneNameAndIndex_t GIKTargetSettings_t::GetBone() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: IKTargetSettings_t->Bone(ptr=%p)", m_ptr));
    GIKBoneNameAndIndex_t value(GetSchemaPtr(m_ptr, "IKTargetSettings_t", "m_Bone"));
    return value;
}
void GIKTargetSettings_t::SetBone(GIKBoneNameAndIndex_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: IKTargetSettings_t->Bone(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Bone' is not possible.\n");
}
GAnimParamID GIKTargetSettings_t::GetAnimgraphParameterNamePosition() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: IKTargetSettings_t->AnimgraphParameterNamePosition(ptr=%p)", m_ptr));
    GAnimParamID value(GetSchemaPtr(m_ptr, "IKTargetSettings_t", "m_AnimgraphParameterNamePosition"));
    return value;
}
void GIKTargetSettings_t::SetAnimgraphParameterNamePosition(GAnimParamID value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: IKTargetSettings_t->AnimgraphParameterNamePosition(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'AnimgraphParameterNamePosition' is not possible.\n");
}
GAnimParamID GIKTargetSettings_t::GetAnimgraphParameterNameOrientation() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: IKTargetSettings_t->AnimgraphParameterNameOrientation(ptr=%p)", m_ptr));
    GAnimParamID value(GetSchemaPtr(m_ptr, "IKTargetSettings_t", "m_AnimgraphParameterNameOrientation"));
    return value;
}
void GIKTargetSettings_t::SetAnimgraphParameterNameOrientation(GAnimParamID value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: IKTargetSettings_t->AnimgraphParameterNameOrientation(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'AnimgraphParameterNameOrientation' is not possible.\n");
}
uint64_t GIKTargetSettings_t::GetTargetCoordSystem() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: IKTargetSettings_t->TargetCoordSystem(ptr=%p)", m_ptr));
    return GetSchemaValue<uint64_t>(m_ptr, "IKTargetSettings_t", "m_TargetCoordSystem");
}
void GIKTargetSettings_t::SetTargetCoordSystem(uint64_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: IKTargetSettings_t->TargetCoordSystem(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "IKTargetSettings_t", "m_TargetCoordSystem", true, value);
}
void* GIKTargetSettings_t::GetPtr() {
    return m_ptr;
}
std::string GIKTargetSettings_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GIKTargetSettings_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassIKTargetSettings_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GIKTargetSettings_t>("IKTargetSettings_t")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("TargetSource", &GIKTargetSettings_t::GetTargetSource, &GIKTargetSettings_t::SetTargetSource)
        .addProperty("Bone", &GIKTargetSettings_t::GetBone, &GIKTargetSettings_t::SetBone)
        .addProperty("AnimgraphParameterNamePosition", &GIKTargetSettings_t::GetAnimgraphParameterNamePosition, &GIKTargetSettings_t::SetAnimgraphParameterNamePosition)
        .addProperty("AnimgraphParameterNameOrientation", &GIKTargetSettings_t::GetAnimgraphParameterNameOrientation, &GIKTargetSettings_t::SetAnimgraphParameterNameOrientation)
        .addProperty("TargetCoordSystem", &GIKTargetSettings_t::GetTargetCoordSystem, &GIKTargetSettings_t::SetTargetCoordSystem)
        .addFunction("ToPtr", &GIKTargetSettings_t::ToPtr)
        .addFunction("IsValid", &GIKTargetSettings_t::IsValid)
        .endClass();
}
GTestResource_t::GTestResource_t(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GTestResource_t::GTestResource_t(void *ptr) {
    m_ptr = ptr;
}
std::string GTestResource_t::GetName() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: TestResource_t->Name(ptr=%p)", m_ptr));
    return GetSchemaValue<CUtlString>(m_ptr, "TestResource_t", "m_name").Get();
}
void GTestResource_t::SetName(std::string value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: TestResource_t->Name(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "TestResource_t", "m_name", true, CUtlString(value.c_str()));
}
void* GTestResource_t::GetPtr() {
    return m_ptr;
}
std::string GTestResource_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GTestResource_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassTestResource_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GTestResource_t>("TestResource_t")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Name", &GTestResource_t::GetName, &GTestResource_t::SetName)
        .addFunction("ToPtr", &GTestResource_t::ToPtr)
        .addFunction("IsValid", &GTestResource_t::IsValid)
        .endClass();
}
GCBaseRendererSource2::GCBaseRendererSource2(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCBaseRendererSource2::GCBaseRendererSource2(void *ptr) {
    m_ptr = ptr;
}
GCParticleCollectionRendererFloatInput GCBaseRendererSource2::GetRadiusScale() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CBaseRendererSource2->RadiusScale(ptr=%p)", m_ptr));
    GCParticleCollectionRendererFloatInput value(GetSchemaPtr(m_ptr, "CBaseRendererSource2", "m_flRadiusScale"));
    return value;
}
void GCBaseRendererSource2::SetRadiusScale(GCParticleCollectionRendererFloatInput value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CBaseRendererSource2->RadiusScale(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'RadiusScale' is not possible.\n");
}
GCParticleCollectionRendererFloatInput GCBaseRendererSource2::GetAlphaScale() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CBaseRendererSource2->AlphaScale(ptr=%p)", m_ptr));
    GCParticleCollectionRendererFloatInput value(GetSchemaPtr(m_ptr, "CBaseRendererSource2", "m_flAlphaScale"));
    return value;
}
void GCBaseRendererSource2::SetAlphaScale(GCParticleCollectionRendererFloatInput value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CBaseRendererSource2->AlphaScale(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'AlphaScale' is not possible.\n");
}
GCParticleCollectionRendererFloatInput GCBaseRendererSource2::GetRollScale() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CBaseRendererSource2->RollScale(ptr=%p)", m_ptr));
    GCParticleCollectionRendererFloatInput value(GetSchemaPtr(m_ptr, "CBaseRendererSource2", "m_flRollScale"));
    return value;
}
void GCBaseRendererSource2::SetRollScale(GCParticleCollectionRendererFloatInput value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CBaseRendererSource2->RollScale(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'RollScale' is not possible.\n");
}
GParticleAttributeIndex_t GCBaseRendererSource2::GetAlpha2Field() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CBaseRendererSource2->Alpha2Field(ptr=%p)", m_ptr));
    GParticleAttributeIndex_t value(GetSchemaPtr(m_ptr, "CBaseRendererSource2", "m_nAlpha2Field"));
    return value;
}
void GCBaseRendererSource2::SetAlpha2Field(GParticleAttributeIndex_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CBaseRendererSource2->Alpha2Field(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Alpha2Field' is not possible.\n");
}
GCParticleCollectionRendererVecInput GCBaseRendererSource2::GetColorScale() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CBaseRendererSource2->ColorScale(ptr=%p)", m_ptr));
    GCParticleCollectionRendererVecInput value(GetSchemaPtr(m_ptr, "CBaseRendererSource2", "m_vecColorScale"));
    return value;
}
void GCBaseRendererSource2::SetColorScale(GCParticleCollectionRendererVecInput value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CBaseRendererSource2->ColorScale(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'ColorScale' is not possible.\n");
}
uint64_t GCBaseRendererSource2::GetColorBlendType() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CBaseRendererSource2->ColorBlendType(ptr=%p)", m_ptr));
    return GetSchemaValue<uint64_t>(m_ptr, "CBaseRendererSource2", "m_nColorBlendType");
}
void GCBaseRendererSource2::SetColorBlendType(uint64_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CBaseRendererSource2->ColorBlendType(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CBaseRendererSource2", "m_nColorBlendType", false, value);
}
uint64_t GCBaseRendererSource2::GetShaderType() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CBaseRendererSource2->ShaderType(ptr=%p)", m_ptr));
    return GetSchemaValue<uint64_t>(m_ptr, "CBaseRendererSource2", "m_nShaderType");
}
void GCBaseRendererSource2::SetShaderType(uint64_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CBaseRendererSource2->ShaderType(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CBaseRendererSource2", "m_nShaderType", false, value);
}
std::string GCBaseRendererSource2::GetStrShaderOverride() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CBaseRendererSource2->StrShaderOverride(ptr=%p)", m_ptr));
    return GetSchemaValue<CUtlString>(m_ptr, "CBaseRendererSource2", "m_strShaderOverride").Get();
}
void GCBaseRendererSource2::SetStrShaderOverride(std::string value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CBaseRendererSource2->StrShaderOverride(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CBaseRendererSource2", "m_strShaderOverride", false, CUtlString(value.c_str()));
}
GCParticleCollectionRendererFloatInput GCBaseRendererSource2::GetCenterXOffset() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CBaseRendererSource2->CenterXOffset(ptr=%p)", m_ptr));
    GCParticleCollectionRendererFloatInput value(GetSchemaPtr(m_ptr, "CBaseRendererSource2", "m_flCenterXOffset"));
    return value;
}
void GCBaseRendererSource2::SetCenterXOffset(GCParticleCollectionRendererFloatInput value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CBaseRendererSource2->CenterXOffset(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'CenterXOffset' is not possible.\n");
}
GCParticleCollectionRendererFloatInput GCBaseRendererSource2::GetCenterYOffset() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CBaseRendererSource2->CenterYOffset(ptr=%p)", m_ptr));
    GCParticleCollectionRendererFloatInput value(GetSchemaPtr(m_ptr, "CBaseRendererSource2", "m_flCenterYOffset"));
    return value;
}
void GCBaseRendererSource2::SetCenterYOffset(GCParticleCollectionRendererFloatInput value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CBaseRendererSource2->CenterYOffset(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'CenterYOffset' is not possible.\n");
}
float GCBaseRendererSource2::GetBumpStrength() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CBaseRendererSource2->BumpStrength(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CBaseRendererSource2", "m_flBumpStrength");
}
void GCBaseRendererSource2::SetBumpStrength(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CBaseRendererSource2->BumpStrength(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CBaseRendererSource2", "m_flBumpStrength", false, value);
}
uint64_t GCBaseRendererSource2::GetCropTextureOverride() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CBaseRendererSource2->CropTextureOverride(ptr=%p)", m_ptr));
    return GetSchemaValue<uint64_t>(m_ptr, "CBaseRendererSource2", "m_nCropTextureOverride");
}
void GCBaseRendererSource2::SetCropTextureOverride(uint64_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CBaseRendererSource2->CropTextureOverride(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CBaseRendererSource2", "m_nCropTextureOverride", false, value);
}
std::vector<GTextureGroup_t> GCBaseRendererSource2::GetTexturesInput() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CBaseRendererSource2->TexturesInput(ptr=%p)", m_ptr));
    CUtlVector<GTextureGroup_t>* vec = GetSchemaValue<CUtlVector<GTextureGroup_t>*>(m_ptr, "CBaseRendererSource2", "m_vecTexturesInput"); std::vector<GTextureGroup_t> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCBaseRendererSource2::SetTexturesInput(std::vector<GTextureGroup_t> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CBaseRendererSource2->TexturesInput(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<GTextureGroup_t>(m_ptr, "CBaseRendererSource2", "m_vecTexturesInput", false, value);
}
float GCBaseRendererSource2::GetAnimationRate() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CBaseRendererSource2->AnimationRate(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CBaseRendererSource2", "m_flAnimationRate");
}
void GCBaseRendererSource2::SetAnimationRate(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CBaseRendererSource2->AnimationRate(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CBaseRendererSource2", "m_flAnimationRate", false, value);
}
uint64_t GCBaseRendererSource2::GetAnimationType() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CBaseRendererSource2->AnimationType(ptr=%p)", m_ptr));
    return GetSchemaValue<uint64_t>(m_ptr, "CBaseRendererSource2", "m_nAnimationType");
}
void GCBaseRendererSource2::SetAnimationType(uint64_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CBaseRendererSource2->AnimationType(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CBaseRendererSource2", "m_nAnimationType", false, value);
}
bool GCBaseRendererSource2::GetAnimateInFPS() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CBaseRendererSource2->AnimateInFPS(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "CBaseRendererSource2", "m_bAnimateInFPS");
}
void GCBaseRendererSource2::SetAnimateInFPS(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CBaseRendererSource2->AnimateInFPS(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CBaseRendererSource2", "m_bAnimateInFPS", false, value);
}
GCParticleCollectionRendererFloatInput GCBaseRendererSource2::GetSelfIllumAmount() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CBaseRendererSource2->SelfIllumAmount(ptr=%p)", m_ptr));
    GCParticleCollectionRendererFloatInput value(GetSchemaPtr(m_ptr, "CBaseRendererSource2", "m_flSelfIllumAmount"));
    return value;
}
void GCBaseRendererSource2::SetSelfIllumAmount(GCParticleCollectionRendererFloatInput value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CBaseRendererSource2->SelfIllumAmount(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'SelfIllumAmount' is not possible.\n");
}
GCParticleCollectionRendererFloatInput GCBaseRendererSource2::GetDiffuseAmount() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CBaseRendererSource2->DiffuseAmount(ptr=%p)", m_ptr));
    GCParticleCollectionRendererFloatInput value(GetSchemaPtr(m_ptr, "CBaseRendererSource2", "m_flDiffuseAmount"));
    return value;
}
void GCBaseRendererSource2::SetDiffuseAmount(GCParticleCollectionRendererFloatInput value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CBaseRendererSource2->DiffuseAmount(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'DiffuseAmount' is not possible.\n");
}
GCParticleCollectionRendererFloatInput GCBaseRendererSource2::GetDiffuseClamp() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CBaseRendererSource2->DiffuseClamp(ptr=%p)", m_ptr));
    GCParticleCollectionRendererFloatInput value(GetSchemaPtr(m_ptr, "CBaseRendererSource2", "m_flDiffuseClamp"));
    return value;
}
void GCBaseRendererSource2::SetDiffuseClamp(GCParticleCollectionRendererFloatInput value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CBaseRendererSource2->DiffuseClamp(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'DiffuseClamp' is not possible.\n");
}
int32_t GCBaseRendererSource2::GetLightingControlPoint() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CBaseRendererSource2->LightingControlPoint(ptr=%p)", m_ptr));
    return GetSchemaValue<int32_t>(m_ptr, "CBaseRendererSource2", "m_nLightingControlPoint");
}
void GCBaseRendererSource2::SetLightingControlPoint(int32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CBaseRendererSource2->LightingControlPoint(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CBaseRendererSource2", "m_nLightingControlPoint", false, value);
}
GParticleAttributeIndex_t GCBaseRendererSource2::GetSelfIllumPerParticle() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CBaseRendererSource2->SelfIllumPerParticle(ptr=%p)", m_ptr));
    GParticleAttributeIndex_t value(GetSchemaPtr(m_ptr, "CBaseRendererSource2", "m_nSelfIllumPerParticle"));
    return value;
}
void GCBaseRendererSource2::SetSelfIllumPerParticle(GParticleAttributeIndex_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CBaseRendererSource2->SelfIllumPerParticle(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'SelfIllumPerParticle' is not possible.\n");
}
uint64_t GCBaseRendererSource2::GetOutputBlendMode() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CBaseRendererSource2->OutputBlendMode(ptr=%p)", m_ptr));
    return GetSchemaValue<uint64_t>(m_ptr, "CBaseRendererSource2", "m_nOutputBlendMode");
}
void GCBaseRendererSource2::SetOutputBlendMode(uint64_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CBaseRendererSource2->OutputBlendMode(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CBaseRendererSource2", "m_nOutputBlendMode", false, value);
}
bool GCBaseRendererSource2::GetGammaCorrectVertexColors() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CBaseRendererSource2->GammaCorrectVertexColors(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "CBaseRendererSource2", "m_bGammaCorrectVertexColors");
}
void GCBaseRendererSource2::SetGammaCorrectVertexColors(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CBaseRendererSource2->GammaCorrectVertexColors(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CBaseRendererSource2", "m_bGammaCorrectVertexColors", false, value);
}
bool GCBaseRendererSource2::GetSaturateColorPreAlphaBlend() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CBaseRendererSource2->SaturateColorPreAlphaBlend(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "CBaseRendererSource2", "m_bSaturateColorPreAlphaBlend");
}
void GCBaseRendererSource2::SetSaturateColorPreAlphaBlend(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CBaseRendererSource2->SaturateColorPreAlphaBlend(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CBaseRendererSource2", "m_bSaturateColorPreAlphaBlend", false, value);
}
GCParticleCollectionRendererFloatInput GCBaseRendererSource2::GetAddSelfAmount() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CBaseRendererSource2->AddSelfAmount(ptr=%p)", m_ptr));
    GCParticleCollectionRendererFloatInput value(GetSchemaPtr(m_ptr, "CBaseRendererSource2", "m_flAddSelfAmount"));
    return value;
}
void GCBaseRendererSource2::SetAddSelfAmount(GCParticleCollectionRendererFloatInput value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CBaseRendererSource2->AddSelfAmount(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'AddSelfAmount' is not possible.\n");
}
GCParticleCollectionRendererFloatInput GCBaseRendererSource2::GetDesaturation() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CBaseRendererSource2->Desaturation(ptr=%p)", m_ptr));
    GCParticleCollectionRendererFloatInput value(GetSchemaPtr(m_ptr, "CBaseRendererSource2", "m_flDesaturation"));
    return value;
}
void GCBaseRendererSource2::SetDesaturation(GCParticleCollectionRendererFloatInput value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CBaseRendererSource2->Desaturation(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Desaturation' is not possible.\n");
}
GCParticleCollectionRendererFloatInput GCBaseRendererSource2::GetOverbrightFactor() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CBaseRendererSource2->OverbrightFactor(ptr=%p)", m_ptr));
    GCParticleCollectionRendererFloatInput value(GetSchemaPtr(m_ptr, "CBaseRendererSource2", "m_flOverbrightFactor"));
    return value;
}
void GCBaseRendererSource2::SetOverbrightFactor(GCParticleCollectionRendererFloatInput value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CBaseRendererSource2->OverbrightFactor(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'OverbrightFactor' is not possible.\n");
}
int32_t GCBaseRendererSource2::GetHSVShiftControlPoint() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CBaseRendererSource2->HSVShiftControlPoint(ptr=%p)", m_ptr));
    return GetSchemaValue<int32_t>(m_ptr, "CBaseRendererSource2", "m_nHSVShiftControlPoint");
}
void GCBaseRendererSource2::SetHSVShiftControlPoint(int32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CBaseRendererSource2->HSVShiftControlPoint(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CBaseRendererSource2", "m_nHSVShiftControlPoint", false, value);
}
uint64_t GCBaseRendererSource2::GetFogType() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CBaseRendererSource2->FogType(ptr=%p)", m_ptr));
    return GetSchemaValue<uint64_t>(m_ptr, "CBaseRendererSource2", "m_nFogType");
}
void GCBaseRendererSource2::SetFogType(uint64_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CBaseRendererSource2->FogType(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CBaseRendererSource2", "m_nFogType", false, value);
}
GCParticleCollectionRendererFloatInput GCBaseRendererSource2::GetFogAmount() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CBaseRendererSource2->FogAmount(ptr=%p)", m_ptr));
    GCParticleCollectionRendererFloatInput value(GetSchemaPtr(m_ptr, "CBaseRendererSource2", "m_flFogAmount"));
    return value;
}
void GCBaseRendererSource2::SetFogAmount(GCParticleCollectionRendererFloatInput value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CBaseRendererSource2->FogAmount(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'FogAmount' is not possible.\n");
}
bool GCBaseRendererSource2::GetTintByFOW() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CBaseRendererSource2->TintByFOW(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "CBaseRendererSource2", "m_bTintByFOW");
}
void GCBaseRendererSource2::SetTintByFOW(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CBaseRendererSource2->TintByFOW(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CBaseRendererSource2", "m_bTintByFOW", false, value);
}
bool GCBaseRendererSource2::GetTintByGlobalLight() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CBaseRendererSource2->TintByGlobalLight(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "CBaseRendererSource2", "m_bTintByGlobalLight");
}
void GCBaseRendererSource2::SetTintByGlobalLight(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CBaseRendererSource2->TintByGlobalLight(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CBaseRendererSource2", "m_bTintByGlobalLight", false, value);
}
uint64_t GCBaseRendererSource2::GetPerParticleAlphaReference() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CBaseRendererSource2->PerParticleAlphaReference(ptr=%p)", m_ptr));
    return GetSchemaValue<uint64_t>(m_ptr, "CBaseRendererSource2", "m_nPerParticleAlphaReference");
}
void GCBaseRendererSource2::SetPerParticleAlphaReference(uint64_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CBaseRendererSource2->PerParticleAlphaReference(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CBaseRendererSource2", "m_nPerParticleAlphaReference", false, value);
}
uint64_t GCBaseRendererSource2::GetPerParticleAlphaRefWindow() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CBaseRendererSource2->PerParticleAlphaRefWindow(ptr=%p)", m_ptr));
    return GetSchemaValue<uint64_t>(m_ptr, "CBaseRendererSource2", "m_nPerParticleAlphaRefWindow");
}
void GCBaseRendererSource2::SetPerParticleAlphaRefWindow(uint64_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CBaseRendererSource2->PerParticleAlphaRefWindow(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CBaseRendererSource2", "m_nPerParticleAlphaRefWindow", false, value);
}
uint64_t GCBaseRendererSource2::GetAlphaReferenceType() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CBaseRendererSource2->AlphaReferenceType(ptr=%p)", m_ptr));
    return GetSchemaValue<uint64_t>(m_ptr, "CBaseRendererSource2", "m_nAlphaReferenceType");
}
void GCBaseRendererSource2::SetAlphaReferenceType(uint64_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CBaseRendererSource2->AlphaReferenceType(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CBaseRendererSource2", "m_nAlphaReferenceType", false, value);
}
GCParticleCollectionRendererFloatInput GCBaseRendererSource2::GetAlphaReferenceSoftness() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CBaseRendererSource2->AlphaReferenceSoftness(ptr=%p)", m_ptr));
    GCParticleCollectionRendererFloatInput value(GetSchemaPtr(m_ptr, "CBaseRendererSource2", "m_flAlphaReferenceSoftness"));
    return value;
}
void GCBaseRendererSource2::SetAlphaReferenceSoftness(GCParticleCollectionRendererFloatInput value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CBaseRendererSource2->AlphaReferenceSoftness(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'AlphaReferenceSoftness' is not possible.\n");
}
GCParticleCollectionRendererFloatInput GCBaseRendererSource2::GetSourceAlphaValueToMapToZero() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CBaseRendererSource2->SourceAlphaValueToMapToZero(ptr=%p)", m_ptr));
    GCParticleCollectionRendererFloatInput value(GetSchemaPtr(m_ptr, "CBaseRendererSource2", "m_flSourceAlphaValueToMapToZero"));
    return value;
}
void GCBaseRendererSource2::SetSourceAlphaValueToMapToZero(GCParticleCollectionRendererFloatInput value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CBaseRendererSource2->SourceAlphaValueToMapToZero(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'SourceAlphaValueToMapToZero' is not possible.\n");
}
GCParticleCollectionRendererFloatInput GCBaseRendererSource2::GetSourceAlphaValueToMapToOne() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CBaseRendererSource2->SourceAlphaValueToMapToOne(ptr=%p)", m_ptr));
    GCParticleCollectionRendererFloatInput value(GetSchemaPtr(m_ptr, "CBaseRendererSource2", "m_flSourceAlphaValueToMapToOne"));
    return value;
}
void GCBaseRendererSource2::SetSourceAlphaValueToMapToOne(GCParticleCollectionRendererFloatInput value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CBaseRendererSource2->SourceAlphaValueToMapToOne(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'SourceAlphaValueToMapToOne' is not possible.\n");
}
bool GCBaseRendererSource2::GetRefract() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CBaseRendererSource2->Refract(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "CBaseRendererSource2", "m_bRefract");
}
void GCBaseRendererSource2::SetRefract(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CBaseRendererSource2->Refract(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CBaseRendererSource2", "m_bRefract", false, value);
}
bool GCBaseRendererSource2::GetRefractSolid() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CBaseRendererSource2->RefractSolid(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "CBaseRendererSource2", "m_bRefractSolid");
}
void GCBaseRendererSource2::SetRefractSolid(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CBaseRendererSource2->RefractSolid(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CBaseRendererSource2", "m_bRefractSolid", false, value);
}
GCParticleCollectionRendererFloatInput GCBaseRendererSource2::GetRefractAmount() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CBaseRendererSource2->RefractAmount(ptr=%p)", m_ptr));
    GCParticleCollectionRendererFloatInput value(GetSchemaPtr(m_ptr, "CBaseRendererSource2", "m_flRefractAmount"));
    return value;
}
void GCBaseRendererSource2::SetRefractAmount(GCParticleCollectionRendererFloatInput value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CBaseRendererSource2->RefractAmount(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'RefractAmount' is not possible.\n");
}
int32_t GCBaseRendererSource2::GetRefractBlurRadius() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CBaseRendererSource2->RefractBlurRadius(ptr=%p)", m_ptr));
    return GetSchemaValue<int32_t>(m_ptr, "CBaseRendererSource2", "m_nRefractBlurRadius");
}
void GCBaseRendererSource2::SetRefractBlurRadius(int32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CBaseRendererSource2->RefractBlurRadius(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CBaseRendererSource2", "m_nRefractBlurRadius", false, value);
}
uint64_t GCBaseRendererSource2::GetRefractBlurType() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CBaseRendererSource2->RefractBlurType(ptr=%p)", m_ptr));
    return GetSchemaValue<uint64_t>(m_ptr, "CBaseRendererSource2", "m_nRefractBlurType");
}
void GCBaseRendererSource2::SetRefractBlurType(uint64_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CBaseRendererSource2->RefractBlurType(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CBaseRendererSource2", "m_nRefractBlurType", false, value);
}
bool GCBaseRendererSource2::GetOnlyRenderInEffectsBloomPass() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CBaseRendererSource2->OnlyRenderInEffectsBloomPass(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "CBaseRendererSource2", "m_bOnlyRenderInEffectsBloomPass");
}
void GCBaseRendererSource2::SetOnlyRenderInEffectsBloomPass(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CBaseRendererSource2->OnlyRenderInEffectsBloomPass(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CBaseRendererSource2", "m_bOnlyRenderInEffectsBloomPass", false, value);
}
bool GCBaseRendererSource2::GetOnlyRenderInEffectsWaterPass() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CBaseRendererSource2->OnlyRenderInEffectsWaterPass(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "CBaseRendererSource2", "m_bOnlyRenderInEffectsWaterPass");
}
void GCBaseRendererSource2::SetOnlyRenderInEffectsWaterPass(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CBaseRendererSource2->OnlyRenderInEffectsWaterPass(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CBaseRendererSource2", "m_bOnlyRenderInEffectsWaterPass", false, value);
}
bool GCBaseRendererSource2::GetUseMixedResolutionRendering() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CBaseRendererSource2->UseMixedResolutionRendering(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "CBaseRendererSource2", "m_bUseMixedResolutionRendering");
}
void GCBaseRendererSource2::SetUseMixedResolutionRendering(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CBaseRendererSource2->UseMixedResolutionRendering(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CBaseRendererSource2", "m_bUseMixedResolutionRendering", false, value);
}
bool GCBaseRendererSource2::GetOnlyRenderInEffecsGameOverlay() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CBaseRendererSource2->OnlyRenderInEffecsGameOverlay(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "CBaseRendererSource2", "m_bOnlyRenderInEffecsGameOverlay");
}
void GCBaseRendererSource2::SetOnlyRenderInEffecsGameOverlay(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CBaseRendererSource2->OnlyRenderInEffecsGameOverlay(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CBaseRendererSource2", "m_bOnlyRenderInEffecsGameOverlay", false, value);
}
std::string GCBaseRendererSource2::GetStencilTestID() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CBaseRendererSource2->StencilTestID(ptr=%p)", m_ptr));
    return GetSchemaValuePtr<char>(m_ptr, "CBaseRendererSource2", "m_stencilTestID");
}
void GCBaseRendererSource2::SetStencilTestID(std::string value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CBaseRendererSource2->StencilTestID(ptr=%p)", m_ptr));
    WriteSchemaPtrValue(m_ptr, "CBaseRendererSource2", "m_stencilTestID", false, reinterpret_cast<byte*>(const_cast<char*>(value.c_str())), 128);
}
bool GCBaseRendererSource2::GetStencilTestExclude() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CBaseRendererSource2->StencilTestExclude(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "CBaseRendererSource2", "m_bStencilTestExclude");
}
void GCBaseRendererSource2::SetStencilTestExclude(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CBaseRendererSource2->StencilTestExclude(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CBaseRendererSource2", "m_bStencilTestExclude", false, value);
}
std::string GCBaseRendererSource2::GetStencilWriteID() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CBaseRendererSource2->StencilWriteID(ptr=%p)", m_ptr));
    return GetSchemaValuePtr<char>(m_ptr, "CBaseRendererSource2", "m_stencilWriteID");
}
void GCBaseRendererSource2::SetStencilWriteID(std::string value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CBaseRendererSource2->StencilWriteID(ptr=%p)", m_ptr));
    WriteSchemaPtrValue(m_ptr, "CBaseRendererSource2", "m_stencilWriteID", false, reinterpret_cast<byte*>(const_cast<char*>(value.c_str())), 128);
}
bool GCBaseRendererSource2::GetWriteStencilOnDepthPass() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CBaseRendererSource2->WriteStencilOnDepthPass(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "CBaseRendererSource2", "m_bWriteStencilOnDepthPass");
}
void GCBaseRendererSource2::SetWriteStencilOnDepthPass(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CBaseRendererSource2->WriteStencilOnDepthPass(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CBaseRendererSource2", "m_bWriteStencilOnDepthPass", false, value);
}
bool GCBaseRendererSource2::GetWriteStencilOnDepthFail() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CBaseRendererSource2->WriteStencilOnDepthFail(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "CBaseRendererSource2", "m_bWriteStencilOnDepthFail");
}
void GCBaseRendererSource2::SetWriteStencilOnDepthFail(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CBaseRendererSource2->WriteStencilOnDepthFail(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CBaseRendererSource2", "m_bWriteStencilOnDepthFail", false, value);
}
bool GCBaseRendererSource2::GetReverseZBuffering() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CBaseRendererSource2->ReverseZBuffering(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "CBaseRendererSource2", "m_bReverseZBuffering");
}
void GCBaseRendererSource2::SetReverseZBuffering(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CBaseRendererSource2->ReverseZBuffering(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CBaseRendererSource2", "m_bReverseZBuffering", false, value);
}
bool GCBaseRendererSource2::GetDisableZBuffering() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CBaseRendererSource2->DisableZBuffering(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "CBaseRendererSource2", "m_bDisableZBuffering");
}
void GCBaseRendererSource2::SetDisableZBuffering(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CBaseRendererSource2->DisableZBuffering(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CBaseRendererSource2", "m_bDisableZBuffering", false, value);
}
uint64_t GCBaseRendererSource2::GetFeatheringMode() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CBaseRendererSource2->FeatheringMode(ptr=%p)", m_ptr));
    return GetSchemaValue<uint64_t>(m_ptr, "CBaseRendererSource2", "m_nFeatheringMode");
}
void GCBaseRendererSource2::SetFeatheringMode(uint64_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CBaseRendererSource2->FeatheringMode(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CBaseRendererSource2", "m_nFeatheringMode", false, value);
}
GCParticleCollectionRendererFloatInput GCBaseRendererSource2::GetFeatheringMinDist() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CBaseRendererSource2->FeatheringMinDist(ptr=%p)", m_ptr));
    GCParticleCollectionRendererFloatInput value(GetSchemaPtr(m_ptr, "CBaseRendererSource2", "m_flFeatheringMinDist"));
    return value;
}
void GCBaseRendererSource2::SetFeatheringMinDist(GCParticleCollectionRendererFloatInput value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CBaseRendererSource2->FeatheringMinDist(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'FeatheringMinDist' is not possible.\n");
}
GCParticleCollectionRendererFloatInput GCBaseRendererSource2::GetFeatheringMaxDist() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CBaseRendererSource2->FeatheringMaxDist(ptr=%p)", m_ptr));
    GCParticleCollectionRendererFloatInput value(GetSchemaPtr(m_ptr, "CBaseRendererSource2", "m_flFeatheringMaxDist"));
    return value;
}
void GCBaseRendererSource2::SetFeatheringMaxDist(GCParticleCollectionRendererFloatInput value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CBaseRendererSource2->FeatheringMaxDist(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'FeatheringMaxDist' is not possible.\n");
}
GCParticleCollectionRendererFloatInput GCBaseRendererSource2::GetFeatheringFilter() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CBaseRendererSource2->FeatheringFilter(ptr=%p)", m_ptr));
    GCParticleCollectionRendererFloatInput value(GetSchemaPtr(m_ptr, "CBaseRendererSource2", "m_flFeatheringFilter"));
    return value;
}
void GCBaseRendererSource2::SetFeatheringFilter(GCParticleCollectionRendererFloatInput value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CBaseRendererSource2->FeatheringFilter(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'FeatheringFilter' is not possible.\n");
}
GCParticleCollectionRendererFloatInput GCBaseRendererSource2::GetDepthBias() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CBaseRendererSource2->DepthBias(ptr=%p)", m_ptr));
    GCParticleCollectionRendererFloatInput value(GetSchemaPtr(m_ptr, "CBaseRendererSource2", "m_flDepthBias"));
    return value;
}
void GCBaseRendererSource2::SetDepthBias(GCParticleCollectionRendererFloatInput value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CBaseRendererSource2->DepthBias(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'DepthBias' is not possible.\n");
}
uint64_t GCBaseRendererSource2::GetSortMethod() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CBaseRendererSource2->SortMethod(ptr=%p)", m_ptr));
    return GetSchemaValue<uint64_t>(m_ptr, "CBaseRendererSource2", "m_nSortMethod");
}
void GCBaseRendererSource2::SetSortMethod(uint64_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CBaseRendererSource2->SortMethod(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CBaseRendererSource2", "m_nSortMethod", false, value);
}
bool GCBaseRendererSource2::GetBlendFramesSeq0() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CBaseRendererSource2->BlendFramesSeq0(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "CBaseRendererSource2", "m_bBlendFramesSeq0");
}
void GCBaseRendererSource2::SetBlendFramesSeq0(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CBaseRendererSource2->BlendFramesSeq0(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CBaseRendererSource2", "m_bBlendFramesSeq0", false, value);
}
bool GCBaseRendererSource2::GetMaxLuminanceBlendingSequence0() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CBaseRendererSource2->MaxLuminanceBlendingSequence0(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "CBaseRendererSource2", "m_bMaxLuminanceBlendingSequence0");
}
void GCBaseRendererSource2::SetMaxLuminanceBlendingSequence0(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CBaseRendererSource2->MaxLuminanceBlendingSequence0(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CBaseRendererSource2", "m_bMaxLuminanceBlendingSequence0", false, value);
}
void* GCBaseRendererSource2::GetPtr() {
    return m_ptr;
}
std::string GCBaseRendererSource2::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCBaseRendererSource2::IsValid() {
    return (m_ptr != nullptr);
}
GCParticleFunctionRenderer GCBaseRendererSource2::GetParent() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CBaseRendererSource2::GetParent(ptr=%p)", m_ptr));
    GCParticleFunctionRenderer value(m_ptr);
    return value;
}
void GCBaseRendererSource2::SetParent(GCParticleFunctionRenderer value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CBaseRendererSource2::SetParent(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCBaseRendererSource2(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCBaseRendererSource2>("CBaseRendererSource2")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("RadiusScale", &GCBaseRendererSource2::GetRadiusScale, &GCBaseRendererSource2::SetRadiusScale)
        .addProperty("AlphaScale", &GCBaseRendererSource2::GetAlphaScale, &GCBaseRendererSource2::SetAlphaScale)
        .addProperty("RollScale", &GCBaseRendererSource2::GetRollScale, &GCBaseRendererSource2::SetRollScale)
        .addProperty("Alpha2Field", &GCBaseRendererSource2::GetAlpha2Field, &GCBaseRendererSource2::SetAlpha2Field)
        .addProperty("ColorScale", &GCBaseRendererSource2::GetColorScale, &GCBaseRendererSource2::SetColorScale)
        .addProperty("ColorBlendType", &GCBaseRendererSource2::GetColorBlendType, &GCBaseRendererSource2::SetColorBlendType)
        .addProperty("ShaderType", &GCBaseRendererSource2::GetShaderType, &GCBaseRendererSource2::SetShaderType)
        .addProperty("StrShaderOverride", &GCBaseRendererSource2::GetStrShaderOverride, &GCBaseRendererSource2::SetStrShaderOverride)
        .addProperty("CenterXOffset", &GCBaseRendererSource2::GetCenterXOffset, &GCBaseRendererSource2::SetCenterXOffset)
        .addProperty("CenterYOffset", &GCBaseRendererSource2::GetCenterYOffset, &GCBaseRendererSource2::SetCenterYOffset)
        .addProperty("BumpStrength", &GCBaseRendererSource2::GetBumpStrength, &GCBaseRendererSource2::SetBumpStrength)
        .addProperty("CropTextureOverride", &GCBaseRendererSource2::GetCropTextureOverride, &GCBaseRendererSource2::SetCropTextureOverride)
        .addProperty("TexturesInput", &GCBaseRendererSource2::GetTexturesInput, &GCBaseRendererSource2::SetTexturesInput)
        .addProperty("AnimationRate", &GCBaseRendererSource2::GetAnimationRate, &GCBaseRendererSource2::SetAnimationRate)
        .addProperty("AnimationType", &GCBaseRendererSource2::GetAnimationType, &GCBaseRendererSource2::SetAnimationType)
        .addProperty("AnimateInFPS", &GCBaseRendererSource2::GetAnimateInFPS, &GCBaseRendererSource2::SetAnimateInFPS)
        .addProperty("SelfIllumAmount", &GCBaseRendererSource2::GetSelfIllumAmount, &GCBaseRendererSource2::SetSelfIllumAmount)
        .addProperty("DiffuseAmount", &GCBaseRendererSource2::GetDiffuseAmount, &GCBaseRendererSource2::SetDiffuseAmount)
        .addProperty("DiffuseClamp", &GCBaseRendererSource2::GetDiffuseClamp, &GCBaseRendererSource2::SetDiffuseClamp)
        .addProperty("LightingControlPoint", &GCBaseRendererSource2::GetLightingControlPoint, &GCBaseRendererSource2::SetLightingControlPoint)
        .addProperty("SelfIllumPerParticle", &GCBaseRendererSource2::GetSelfIllumPerParticle, &GCBaseRendererSource2::SetSelfIllumPerParticle)
        .addProperty("OutputBlendMode", &GCBaseRendererSource2::GetOutputBlendMode, &GCBaseRendererSource2::SetOutputBlendMode)
        .addProperty("GammaCorrectVertexColors", &GCBaseRendererSource2::GetGammaCorrectVertexColors, &GCBaseRendererSource2::SetGammaCorrectVertexColors)
        .addProperty("SaturateColorPreAlphaBlend", &GCBaseRendererSource2::GetSaturateColorPreAlphaBlend, &GCBaseRendererSource2::SetSaturateColorPreAlphaBlend)
        .addProperty("AddSelfAmount", &GCBaseRendererSource2::GetAddSelfAmount, &GCBaseRendererSource2::SetAddSelfAmount)
        .addProperty("Desaturation", &GCBaseRendererSource2::GetDesaturation, &GCBaseRendererSource2::SetDesaturation)
        .addProperty("OverbrightFactor", &GCBaseRendererSource2::GetOverbrightFactor, &GCBaseRendererSource2::SetOverbrightFactor)
        .addProperty("HSVShiftControlPoint", &GCBaseRendererSource2::GetHSVShiftControlPoint, &GCBaseRendererSource2::SetHSVShiftControlPoint)
        .addProperty("FogType", &GCBaseRendererSource2::GetFogType, &GCBaseRendererSource2::SetFogType)
        .addProperty("FogAmount", &GCBaseRendererSource2::GetFogAmount, &GCBaseRendererSource2::SetFogAmount)
        .addProperty("TintByFOW", &GCBaseRendererSource2::GetTintByFOW, &GCBaseRendererSource2::SetTintByFOW)
        .addProperty("TintByGlobalLight", &GCBaseRendererSource2::GetTintByGlobalLight, &GCBaseRendererSource2::SetTintByGlobalLight)
        .addProperty("PerParticleAlphaReference", &GCBaseRendererSource2::GetPerParticleAlphaReference, &GCBaseRendererSource2::SetPerParticleAlphaReference)
        .addProperty("PerParticleAlphaRefWindow", &GCBaseRendererSource2::GetPerParticleAlphaRefWindow, &GCBaseRendererSource2::SetPerParticleAlphaRefWindow)
        .addProperty("AlphaReferenceType", &GCBaseRendererSource2::GetAlphaReferenceType, &GCBaseRendererSource2::SetAlphaReferenceType)
        .addProperty("AlphaReferenceSoftness", &GCBaseRendererSource2::GetAlphaReferenceSoftness, &GCBaseRendererSource2::SetAlphaReferenceSoftness)
        .addProperty("SourceAlphaValueToMapToZero", &GCBaseRendererSource2::GetSourceAlphaValueToMapToZero, &GCBaseRendererSource2::SetSourceAlphaValueToMapToZero)
        .addProperty("SourceAlphaValueToMapToOne", &GCBaseRendererSource2::GetSourceAlphaValueToMapToOne, &GCBaseRendererSource2::SetSourceAlphaValueToMapToOne)
        .addProperty("Refract", &GCBaseRendererSource2::GetRefract, &GCBaseRendererSource2::SetRefract)
        .addProperty("RefractSolid", &GCBaseRendererSource2::GetRefractSolid, &GCBaseRendererSource2::SetRefractSolid)
        .addProperty("RefractAmount", &GCBaseRendererSource2::GetRefractAmount, &GCBaseRendererSource2::SetRefractAmount)
        .addProperty("RefractBlurRadius", &GCBaseRendererSource2::GetRefractBlurRadius, &GCBaseRendererSource2::SetRefractBlurRadius)
        .addProperty("RefractBlurType", &GCBaseRendererSource2::GetRefractBlurType, &GCBaseRendererSource2::SetRefractBlurType)
        .addProperty("OnlyRenderInEffectsBloomPass", &GCBaseRendererSource2::GetOnlyRenderInEffectsBloomPass, &GCBaseRendererSource2::SetOnlyRenderInEffectsBloomPass)
        .addProperty("OnlyRenderInEffectsWaterPass", &GCBaseRendererSource2::GetOnlyRenderInEffectsWaterPass, &GCBaseRendererSource2::SetOnlyRenderInEffectsWaterPass)
        .addProperty("UseMixedResolutionRendering", &GCBaseRendererSource2::GetUseMixedResolutionRendering, &GCBaseRendererSource2::SetUseMixedResolutionRendering)
        .addProperty("OnlyRenderInEffecsGameOverlay", &GCBaseRendererSource2::GetOnlyRenderInEffecsGameOverlay, &GCBaseRendererSource2::SetOnlyRenderInEffecsGameOverlay)
        .addProperty("StencilTestID", &GCBaseRendererSource2::GetStencilTestID, &GCBaseRendererSource2::SetStencilTestID)
        .addProperty("StencilTestExclude", &GCBaseRendererSource2::GetStencilTestExclude, &GCBaseRendererSource2::SetStencilTestExclude)
        .addProperty("StencilWriteID", &GCBaseRendererSource2::GetStencilWriteID, &GCBaseRendererSource2::SetStencilWriteID)
        .addProperty("WriteStencilOnDepthPass", &GCBaseRendererSource2::GetWriteStencilOnDepthPass, &GCBaseRendererSource2::SetWriteStencilOnDepthPass)
        .addProperty("WriteStencilOnDepthFail", &GCBaseRendererSource2::GetWriteStencilOnDepthFail, &GCBaseRendererSource2::SetWriteStencilOnDepthFail)
        .addProperty("ReverseZBuffering", &GCBaseRendererSource2::GetReverseZBuffering, &GCBaseRendererSource2::SetReverseZBuffering)
        .addProperty("DisableZBuffering", &GCBaseRendererSource2::GetDisableZBuffering, &GCBaseRendererSource2::SetDisableZBuffering)
        .addProperty("FeatheringMode", &GCBaseRendererSource2::GetFeatheringMode, &GCBaseRendererSource2::SetFeatheringMode)
        .addProperty("FeatheringMinDist", &GCBaseRendererSource2::GetFeatheringMinDist, &GCBaseRendererSource2::SetFeatheringMinDist)
        .addProperty("FeatheringMaxDist", &GCBaseRendererSource2::GetFeatheringMaxDist, &GCBaseRendererSource2::SetFeatheringMaxDist)
        .addProperty("FeatheringFilter", &GCBaseRendererSource2::GetFeatheringFilter, &GCBaseRendererSource2::SetFeatheringFilter)
        .addProperty("DepthBias", &GCBaseRendererSource2::GetDepthBias, &GCBaseRendererSource2::SetDepthBias)
        .addProperty("SortMethod", &GCBaseRendererSource2::GetSortMethod, &GCBaseRendererSource2::SetSortMethod)
        .addProperty("BlendFramesSeq0", &GCBaseRendererSource2::GetBlendFramesSeq0, &GCBaseRendererSource2::SetBlendFramesSeq0)
        .addProperty("MaxLuminanceBlendingSequence0", &GCBaseRendererSource2::GetMaxLuminanceBlendingSequence0, &GCBaseRendererSource2::SetMaxLuminanceBlendingSequence0)
        .addProperty("Parent", &GCBaseRendererSource2::GetParent, &GCBaseRendererSource2::SetParent)
        .addFunction("ToPtr", &GCBaseRendererSource2::ToPtr)
        .addFunction("IsValid", &GCBaseRendererSource2::IsValid)
        .endClass();
}
GCSSDSMsg_ViewRender::GCSSDSMsg_ViewRender(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCSSDSMsg_ViewRender::GCSSDSMsg_ViewRender(void *ptr) {
    m_ptr = ptr;
}
GSceneViewId_t GCSSDSMsg_ViewRender::GetViewId() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CSSDSMsg_ViewRender->ViewId(ptr=%p)", m_ptr));
    GSceneViewId_t value(GetSchemaPtr(m_ptr, "CSSDSMsg_ViewRender", "m_viewId"));
    return value;
}
void GCSSDSMsg_ViewRender::SetViewId(GSceneViewId_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CSSDSMsg_ViewRender->ViewId(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'ViewId' is not possible.\n");
}
std::string GCSSDSMsg_ViewRender::GetViewName() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CSSDSMsg_ViewRender->ViewName(ptr=%p)", m_ptr));
    return GetSchemaValue<CUtlString>(m_ptr, "CSSDSMsg_ViewRender", "m_ViewName").Get();
}
void GCSSDSMsg_ViewRender::SetViewName(std::string value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CSSDSMsg_ViewRender->ViewName(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CSSDSMsg_ViewRender", "m_ViewName", false, CUtlString(value.c_str()));
}
void* GCSSDSMsg_ViewRender::GetPtr() {
    return m_ptr;
}
std::string GCSSDSMsg_ViewRender::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCSSDSMsg_ViewRender::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCSSDSMsg_ViewRender(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCSSDSMsg_ViewRender>("CSSDSMsg_ViewRender")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("ViewId", &GCSSDSMsg_ViewRender::GetViewId, &GCSSDSMsg_ViewRender::SetViewId)
        .addProperty("ViewName", &GCSSDSMsg_ViewRender::GetViewName, &GCSSDSMsg_ViewRender::SetViewName)
        .addFunction("ToPtr", &GCSSDSMsg_ViewRender::ToPtr)
        .addFunction("IsValid", &GCSSDSMsg_ViewRender::IsValid)
        .endClass();
}
GCZeroPoseUpdateNode::GCZeroPoseUpdateNode(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCZeroPoseUpdateNode::GCZeroPoseUpdateNode(void *ptr) {
    m_ptr = ptr;
}
void* GCZeroPoseUpdateNode::GetPtr() {
    return m_ptr;
}
std::string GCZeroPoseUpdateNode::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCZeroPoseUpdateNode::IsValid() {
    return (m_ptr != nullptr);
}
GCLeafUpdateNode GCZeroPoseUpdateNode::GetParent() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CZeroPoseUpdateNode::GetParent(ptr=%p)", m_ptr));
    GCLeafUpdateNode value(m_ptr);
    return value;
}
void GCZeroPoseUpdateNode::SetParent(GCLeafUpdateNode value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CZeroPoseUpdateNode::SetParent(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCZeroPoseUpdateNode(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCZeroPoseUpdateNode>("CZeroPoseUpdateNode")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Parent", &GCZeroPoseUpdateNode::GetParent, &GCZeroPoseUpdateNode::SetParent)
        .addFunction("ToPtr", &GCZeroPoseUpdateNode::ToPtr)
        .addFunction("IsValid", &GCZeroPoseUpdateNode::IsValid)
        .endClass();
}
GFeFitWeight_t::GFeFitWeight_t(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GFeFitWeight_t::GFeFitWeight_t(void *ptr) {
    m_ptr = ptr;
}
float GFeFitWeight_t::GetWeight() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FeFitWeight_t->Weight(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "FeFitWeight_t", "flWeight");
}
void GFeFitWeight_t::SetWeight(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FeFitWeight_t->Weight(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "FeFitWeight_t", "flWeight", true, value);
}
uint16_t GFeFitWeight_t::GetNode() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FeFitWeight_t->Node(ptr=%p)", m_ptr));
    return GetSchemaValue<uint16_t>(m_ptr, "FeFitWeight_t", "nNode");
}
void GFeFitWeight_t::SetNode(uint16_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FeFitWeight_t->Node(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "FeFitWeight_t", "nNode", true, value);
}
uint16_t GFeFitWeight_t::GetDummy() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FeFitWeight_t->Dummy(ptr=%p)", m_ptr));
    return GetSchemaValue<uint16_t>(m_ptr, "FeFitWeight_t", "nDummy");
}
void GFeFitWeight_t::SetDummy(uint16_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FeFitWeight_t->Dummy(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "FeFitWeight_t", "nDummy", true, value);
}
void* GFeFitWeight_t::GetPtr() {
    return m_ptr;
}
std::string GFeFitWeight_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GFeFitWeight_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassFeFitWeight_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GFeFitWeight_t>("FeFitWeight_t")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Weight", &GFeFitWeight_t::GetWeight, &GFeFitWeight_t::SetWeight)
        .addProperty("Node", &GFeFitWeight_t::GetNode, &GFeFitWeight_t::SetNode)
        .addProperty("Dummy", &GFeFitWeight_t::GetDummy, &GFeFitWeight_t::SetDummy)
        .addFunction("ToPtr", &GFeFitWeight_t::ToPtr)
        .addFunction("IsValid", &GFeFitWeight_t::IsValid)
        .endClass();
}
GCFootCycleMetricEvaluator::GCFootCycleMetricEvaluator(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCFootCycleMetricEvaluator::GCFootCycleMetricEvaluator(void *ptr) {
    m_ptr = ptr;
}
std::vector<int32> GCFootCycleMetricEvaluator::GetFootIndices() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CFootCycleMetricEvaluator->FootIndices(ptr=%p)", m_ptr));
    CUtlVector<int32>* vec = GetSchemaValue<CUtlVector<int32>*>(m_ptr, "CFootCycleMetricEvaluator", "m_footIndices"); std::vector<int32> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCFootCycleMetricEvaluator::SetFootIndices(std::vector<int32> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CFootCycleMetricEvaluator->FootIndices(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<int32>(m_ptr, "CFootCycleMetricEvaluator", "m_footIndices", false, value);
}
void* GCFootCycleMetricEvaluator::GetPtr() {
    return m_ptr;
}
std::string GCFootCycleMetricEvaluator::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCFootCycleMetricEvaluator::IsValid() {
    return (m_ptr != nullptr);
}
GCMotionMetricEvaluator GCFootCycleMetricEvaluator::GetParent() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CFootCycleMetricEvaluator::GetParent(ptr=%p)", m_ptr));
    GCMotionMetricEvaluator value(m_ptr);
    return value;
}
void GCFootCycleMetricEvaluator::SetParent(GCMotionMetricEvaluator value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CFootCycleMetricEvaluator::SetParent(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCFootCycleMetricEvaluator(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCFootCycleMetricEvaluator>("CFootCycleMetricEvaluator")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("FootIndices", &GCFootCycleMetricEvaluator::GetFootIndices, &GCFootCycleMetricEvaluator::SetFootIndices)
        .addProperty("Parent", &GCFootCycleMetricEvaluator::GetParent, &GCFootCycleMetricEvaluator::SetParent)
        .addFunction("ToPtr", &GCFootCycleMetricEvaluator::ToPtr)
        .addFunction("IsValid", &GCFootCycleMetricEvaluator::IsValid)
        .endClass();
}
GCFootPositionMetricEvaluator::GCFootPositionMetricEvaluator(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCFootPositionMetricEvaluator::GCFootPositionMetricEvaluator(void *ptr) {
    m_ptr = ptr;
}
std::vector<int32> GCFootPositionMetricEvaluator::GetFootIndices() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CFootPositionMetricEvaluator->FootIndices(ptr=%p)", m_ptr));
    CUtlVector<int32>* vec = GetSchemaValue<CUtlVector<int32>*>(m_ptr, "CFootPositionMetricEvaluator", "m_footIndices"); std::vector<int32> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCFootPositionMetricEvaluator::SetFootIndices(std::vector<int32> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CFootPositionMetricEvaluator->FootIndices(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<int32>(m_ptr, "CFootPositionMetricEvaluator", "m_footIndices", false, value);
}
bool GCFootPositionMetricEvaluator::GetIgnoreSlope() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CFootPositionMetricEvaluator->IgnoreSlope(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "CFootPositionMetricEvaluator", "m_bIgnoreSlope");
}
void GCFootPositionMetricEvaluator::SetIgnoreSlope(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CFootPositionMetricEvaluator->IgnoreSlope(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CFootPositionMetricEvaluator", "m_bIgnoreSlope", false, value);
}
void* GCFootPositionMetricEvaluator::GetPtr() {
    return m_ptr;
}
std::string GCFootPositionMetricEvaluator::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCFootPositionMetricEvaluator::IsValid() {
    return (m_ptr != nullptr);
}
GCMotionMetricEvaluator GCFootPositionMetricEvaluator::GetParent() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CFootPositionMetricEvaluator::GetParent(ptr=%p)", m_ptr));
    GCMotionMetricEvaluator value(m_ptr);
    return value;
}
void GCFootPositionMetricEvaluator::SetParent(GCMotionMetricEvaluator value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CFootPositionMetricEvaluator::SetParent(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCFootPositionMetricEvaluator(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCFootPositionMetricEvaluator>("CFootPositionMetricEvaluator")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("FootIndices", &GCFootPositionMetricEvaluator::GetFootIndices, &GCFootPositionMetricEvaluator::SetFootIndices)
        .addProperty("IgnoreSlope", &GCFootPositionMetricEvaluator::GetIgnoreSlope, &GCFootPositionMetricEvaluator::SetIgnoreSlope)
        .addProperty("Parent", &GCFootPositionMetricEvaluator::GetParent, &GCFootPositionMetricEvaluator::SetParent)
        .addFunction("ToPtr", &GCFootPositionMetricEvaluator::ToPtr)
        .addFunction("IsValid", &GCFootPositionMetricEvaluator::IsValid)
        .endClass();
}
GCFlexOp::GCFlexOp(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCFlexOp::GCFlexOp(void *ptr) {
    m_ptr = ptr;
}
uint64_t GCFlexOp::GetOpCode() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CFlexOp->OpCode(ptr=%p)", m_ptr));
    return GetSchemaValue<uint64_t>(m_ptr, "CFlexOp", "m_OpCode");
}
void GCFlexOp::SetOpCode(uint64_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CFlexOp->OpCode(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CFlexOp", "m_OpCode", false, value);
}
int32_t GCFlexOp::GetData() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CFlexOp->Data(ptr=%p)", m_ptr));
    return GetSchemaValue<int32_t>(m_ptr, "CFlexOp", "m_Data");
}
void GCFlexOp::SetData(int32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CFlexOp->Data(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CFlexOp", "m_Data", false, value);
}
void* GCFlexOp::GetPtr() {
    return m_ptr;
}
std::string GCFlexOp::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCFlexOp::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCFlexOp(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCFlexOp>("CFlexOp")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("OpCode", &GCFlexOp::GetOpCode, &GCFlexOp::SetOpCode)
        .addProperty("Data", &GCFlexOp::GetData, &GCFlexOp::SetData)
        .addFunction("ToPtr", &GCFlexOp::ToPtr)
        .addFunction("IsValid", &GCFlexOp::IsValid)
        .endClass();
}
GCPointConstraint::GCPointConstraint(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCPointConstraint::GCPointConstraint(void *ptr) {
    m_ptr = ptr;
}
void* GCPointConstraint::GetPtr() {
    return m_ptr;
}
std::string GCPointConstraint::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCPointConstraint::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseConstraint GCPointConstraint::GetParent() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CPointConstraint::GetParent(ptr=%p)", m_ptr));
    GCBaseConstraint value(m_ptr);
    return value;
}
void GCPointConstraint::SetParent(GCBaseConstraint value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CPointConstraint::SetParent(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCPointConstraint(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCPointConstraint>("CPointConstraint")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Parent", &GCPointConstraint::GetParent, &GCPointConstraint::SetParent)
        .addFunction("ToPtr", &GCPointConstraint::ToPtr)
        .addFunction("IsValid", &GCPointConstraint::IsValid)
        .endClass();
}
GMotionBlendItem::GMotionBlendItem(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GMotionBlendItem::GMotionBlendItem(void *ptr) {
    m_ptr = ptr;
}
float GMotionBlendItem::GetKeyValue() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: MotionBlendItem->KeyValue(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "MotionBlendItem", "m_flKeyValue");
}
void GMotionBlendItem::SetKeyValue(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: MotionBlendItem->KeyValue(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "MotionBlendItem", "m_flKeyValue", false, value);
}
void* GMotionBlendItem::GetPtr() {
    return m_ptr;
}
std::string GMotionBlendItem::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GMotionBlendItem::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassMotionBlendItem(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GMotionBlendItem>("MotionBlendItem")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("KeyValue", &GMotionBlendItem::GetKeyValue, &GMotionBlendItem::SetKeyValue)
        .addFunction("ToPtr", &GMotionBlendItem::ToPtr)
        .addFunction("IsValid", &GMotionBlendItem::IsValid)
        .endClass();
}
GCVectorQuantizer::GCVectorQuantizer(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCVectorQuantizer::GCVectorQuantizer(void *ptr) {
    m_ptr = ptr;
}
std::vector<float32> GCVectorQuantizer::GetCentroidVectors() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CVectorQuantizer->CentroidVectors(ptr=%p)", m_ptr));
    CUtlVector<float32>* vec = GetSchemaValue<CUtlVector<float32>*>(m_ptr, "CVectorQuantizer", "m_centroidVectors"); std::vector<float32> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCVectorQuantizer::SetCentroidVectors(std::vector<float32> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CVectorQuantizer->CentroidVectors(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<float32>(m_ptr, "CVectorQuantizer", "m_centroidVectors", false, value);
}
int32_t GCVectorQuantizer::GetCentroids() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CVectorQuantizer->Centroids(ptr=%p)", m_ptr));
    return GetSchemaValue<int32_t>(m_ptr, "CVectorQuantizer", "m_nCentroids");
}
void GCVectorQuantizer::SetCentroids(int32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CVectorQuantizer->Centroids(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CVectorQuantizer", "m_nCentroids", false, value);
}
int32_t GCVectorQuantizer::GetDimensions() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CVectorQuantizer->Dimensions(ptr=%p)", m_ptr));
    return GetSchemaValue<int32_t>(m_ptr, "CVectorQuantizer", "m_nDimensions");
}
void GCVectorQuantizer::SetDimensions(int32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CVectorQuantizer->Dimensions(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CVectorQuantizer", "m_nDimensions", false, value);
}
void* GCVectorQuantizer::GetPtr() {
    return m_ptr;
}
std::string GCVectorQuantizer::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCVectorQuantizer::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCVectorQuantizer(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCVectorQuantizer>("CVectorQuantizer")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("CentroidVectors", &GCVectorQuantizer::GetCentroidVectors, &GCVectorQuantizer::SetCentroidVectors)
        .addProperty("Centroids", &GCVectorQuantizer::GetCentroids, &GCVectorQuantizer::SetCentroids)
        .addProperty("Dimensions", &GCVectorQuantizer::GetDimensions, &GCVectorQuantizer::SetDimensions)
        .addFunction("ToPtr", &GCVectorQuantizer::ToPtr)
        .addFunction("IsValid", &GCVectorQuantizer::IsValid)
        .endClass();
}
GSignatureOutflow_Resume::GSignatureOutflow_Resume(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GSignatureOutflow_Resume::GSignatureOutflow_Resume(void *ptr) {
    m_ptr = ptr;
}
void* GSignatureOutflow_Resume::GetPtr() {
    return m_ptr;
}
std::string GSignatureOutflow_Resume::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GSignatureOutflow_Resume::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassSignatureOutflow_Resume(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GSignatureOutflow_Resume>("SignatureOutflow_Resume")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addFunction("ToPtr", &GSignatureOutflow_Resume::ToPtr)
        .addFunction("IsValid", &GSignatureOutflow_Resume::IsValid)
        .endClass();
}
GFeBoxRigid_t::GFeBoxRigid_t(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GFeBoxRigid_t::GFeBoxRigid_t(void *ptr) {
    m_ptr = ptr;
}
uint16_t GFeBoxRigid_t::GetNode() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FeBoxRigid_t->Node(ptr=%p)", m_ptr));
    return GetSchemaValue<uint16_t>(m_ptr, "FeBoxRigid_t", "nNode");
}
void GFeBoxRigid_t::SetNode(uint16_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FeBoxRigid_t->Node(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "FeBoxRigid_t", "nNode", true, value);
}
uint16_t GFeBoxRigid_t::GetCollisionMask() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FeBoxRigid_t->CollisionMask(ptr=%p)", m_ptr));
    return GetSchemaValue<uint16_t>(m_ptr, "FeBoxRigid_t", "nCollisionMask");
}
void GFeBoxRigid_t::SetCollisionMask(uint16_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FeBoxRigid_t->CollisionMask(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "FeBoxRigid_t", "nCollisionMask", true, value);
}
Vector GFeBoxRigid_t::GetSize() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FeBoxRigid_t->Size(ptr=%p)", m_ptr));
    return GetSchemaValue<Vector>(m_ptr, "FeBoxRigid_t", "vSize");
}
void GFeBoxRigid_t::SetSize(Vector value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FeBoxRigid_t->Size(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "FeBoxRigid_t", "vSize", true, value);
}
uint16_t GFeBoxRigid_t::GetVertexMapIndex() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FeBoxRigid_t->VertexMapIndex(ptr=%p)", m_ptr));
    return GetSchemaValue<uint16_t>(m_ptr, "FeBoxRigid_t", "nVertexMapIndex");
}
void GFeBoxRigid_t::SetVertexMapIndex(uint16_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FeBoxRigid_t->VertexMapIndex(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "FeBoxRigid_t", "nVertexMapIndex", true, value);
}
uint16_t GFeBoxRigid_t::GetFlags() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FeBoxRigid_t->Flags(ptr=%p)", m_ptr));
    return GetSchemaValue<uint16_t>(m_ptr, "FeBoxRigid_t", "nFlags");
}
void GFeBoxRigid_t::SetFlags(uint16_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FeBoxRigid_t->Flags(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "FeBoxRigid_t", "nFlags", true, value);
}
void* GFeBoxRigid_t::GetPtr() {
    return m_ptr;
}
std::string GFeBoxRigid_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GFeBoxRigid_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassFeBoxRigid_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GFeBoxRigid_t>("FeBoxRigid_t")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Node", &GFeBoxRigid_t::GetNode, &GFeBoxRigid_t::SetNode)
        .addProperty("CollisionMask", &GFeBoxRigid_t::GetCollisionMask, &GFeBoxRigid_t::SetCollisionMask)
        .addProperty("Size", &GFeBoxRigid_t::GetSize, &GFeBoxRigid_t::SetSize)
        .addProperty("VertexMapIndex", &GFeBoxRigid_t::GetVertexMapIndex, &GFeBoxRigid_t::SetVertexMapIndex)
        .addProperty("Flags", &GFeBoxRigid_t::GetFlags, &GFeBoxRigid_t::SetFlags)
        .addFunction("ToPtr", &GFeBoxRigid_t::ToPtr)
        .addFunction("IsValid", &GFeBoxRigid_t::IsValid)
        .endClass();
}
GCIntAnimParameter::GCIntAnimParameter(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCIntAnimParameter::GCIntAnimParameter(void *ptr) {
    m_ptr = ptr;
}
int32_t GCIntAnimParameter::GetDefaultValue() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CIntAnimParameter->DefaultValue(ptr=%p)", m_ptr));
    return GetSchemaValue<int32_t>(m_ptr, "CIntAnimParameter", "m_defaultValue");
}
void GCIntAnimParameter::SetDefaultValue(int32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CIntAnimParameter->DefaultValue(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CIntAnimParameter", "m_defaultValue", false, value);
}
int32_t GCIntAnimParameter::GetMinValue() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CIntAnimParameter->MinValue(ptr=%p)", m_ptr));
    return GetSchemaValue<int32_t>(m_ptr, "CIntAnimParameter", "m_minValue");
}
void GCIntAnimParameter::SetMinValue(int32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CIntAnimParameter->MinValue(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CIntAnimParameter", "m_minValue", false, value);
}
int32_t GCIntAnimParameter::GetMaxValue() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CIntAnimParameter->MaxValue(ptr=%p)", m_ptr));
    return GetSchemaValue<int32_t>(m_ptr, "CIntAnimParameter", "m_maxValue");
}
void GCIntAnimParameter::SetMaxValue(int32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CIntAnimParameter->MaxValue(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CIntAnimParameter", "m_maxValue", false, value);
}
void* GCIntAnimParameter::GetPtr() {
    return m_ptr;
}
std::string GCIntAnimParameter::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCIntAnimParameter::IsValid() {
    return (m_ptr != nullptr);
}
GCConcreteAnimParameter GCIntAnimParameter::GetParent() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CIntAnimParameter::GetParent(ptr=%p)", m_ptr));
    GCConcreteAnimParameter value(m_ptr);
    return value;
}
void GCIntAnimParameter::SetParent(GCConcreteAnimParameter value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CIntAnimParameter::SetParent(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCIntAnimParameter(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCIntAnimParameter>("CIntAnimParameter")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("DefaultValue", &GCIntAnimParameter::GetDefaultValue, &GCIntAnimParameter::SetDefaultValue)
        .addProperty("MinValue", &GCIntAnimParameter::GetMinValue, &GCIntAnimParameter::SetMinValue)
        .addProperty("MaxValue", &GCIntAnimParameter::GetMaxValue, &GCIntAnimParameter::SetMaxValue)
        .addProperty("Parent", &GCIntAnimParameter::GetParent, &GCIntAnimParameter::SetParent)
        .addFunction("ToPtr", &GCIntAnimParameter::ToPtr)
        .addFunction("IsValid", &GCIntAnimParameter::IsValid)
        .endClass();
}
GCNmTargetValueNode::GCNmTargetValueNode(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCNmTargetValueNode::GCNmTargetValueNode(void *ptr) {
    m_ptr = ptr;
}
void* GCNmTargetValueNode::GetPtr() {
    return m_ptr;
}
std::string GCNmTargetValueNode::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCNmTargetValueNode::IsValid() {
    return (m_ptr != nullptr);
}
GCNmValueNode GCNmTargetValueNode::GetParent() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CNmTargetValueNode::GetParent(ptr=%p)", m_ptr));
    GCNmValueNode value(m_ptr);
    return value;
}
void GCNmTargetValueNode::SetParent(GCNmValueNode value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CNmTargetValueNode::SetParent(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCNmTargetValueNode(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCNmTargetValueNode>("CNmTargetValueNode")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Parent", &GCNmTargetValueNode::GetParent, &GCNmTargetValueNode::SetParent)
        .addFunction("ToPtr", &GCNmTargetValueNode::ToPtr)
        .addFunction("IsValid", &GCNmTargetValueNode::IsValid)
        .endClass();
}
GEventSimpleLoopFrameUpdate_t::GEventSimpleLoopFrameUpdate_t(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GEventSimpleLoopFrameUpdate_t::GEventSimpleLoopFrameUpdate_t(void *ptr) {
    m_ptr = ptr;
}
GEngineLoopState_t GEventSimpleLoopFrameUpdate_t::GetLoopState() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: EventSimpleLoopFrameUpdate_t->LoopState(ptr=%p)", m_ptr));
    GEngineLoopState_t value(GetSchemaPtr(m_ptr, "EventSimpleLoopFrameUpdate_t", "m_LoopState"));
    return value;
}
void GEventSimpleLoopFrameUpdate_t::SetLoopState(GEngineLoopState_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: EventSimpleLoopFrameUpdate_t->LoopState(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'LoopState' is not possible.\n");
}
float GEventSimpleLoopFrameUpdate_t::GetRealTime() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: EventSimpleLoopFrameUpdate_t->RealTime(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "EventSimpleLoopFrameUpdate_t", "m_flRealTime");
}
void GEventSimpleLoopFrameUpdate_t::SetRealTime(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: EventSimpleLoopFrameUpdate_t->RealTime(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "EventSimpleLoopFrameUpdate_t", "m_flRealTime", true, value);
}
float GEventSimpleLoopFrameUpdate_t::GetFrameTime() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: EventSimpleLoopFrameUpdate_t->FrameTime(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "EventSimpleLoopFrameUpdate_t", "m_flFrameTime");
}
void GEventSimpleLoopFrameUpdate_t::SetFrameTime(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: EventSimpleLoopFrameUpdate_t->FrameTime(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "EventSimpleLoopFrameUpdate_t", "m_flFrameTime", true, value);
}
void* GEventSimpleLoopFrameUpdate_t::GetPtr() {
    return m_ptr;
}
std::string GEventSimpleLoopFrameUpdate_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GEventSimpleLoopFrameUpdate_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassEventSimpleLoopFrameUpdate_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GEventSimpleLoopFrameUpdate_t>("EventSimpleLoopFrameUpdate_t")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("LoopState", &GEventSimpleLoopFrameUpdate_t::GetLoopState, &GEventSimpleLoopFrameUpdate_t::SetLoopState)
        .addProperty("RealTime", &GEventSimpleLoopFrameUpdate_t::GetRealTime, &GEventSimpleLoopFrameUpdate_t::SetRealTime)
        .addProperty("FrameTime", &GEventSimpleLoopFrameUpdate_t::GetFrameTime, &GEventSimpleLoopFrameUpdate_t::SetFrameTime)
        .addFunction("ToPtr", &GEventSimpleLoopFrameUpdate_t::ToPtr)
        .addFunction("IsValid", &GEventSimpleLoopFrameUpdate_t::IsValid)
        .endClass();
}
GEventServerAdvanceTick_t::GEventServerAdvanceTick_t(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GEventServerAdvanceTick_t::GEventServerAdvanceTick_t(void *ptr) {
    m_ptr = ptr;
}
void* GEventServerAdvanceTick_t::GetPtr() {
    return m_ptr;
}
std::string GEventServerAdvanceTick_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GEventServerAdvanceTick_t::IsValid() {
    return (m_ptr != nullptr);
}
GEventAdvanceTick_t GEventServerAdvanceTick_t::GetParent() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("EventServerAdvanceTick_t::GetParent(ptr=%p)", m_ptr));
    GEventAdvanceTick_t value(m_ptr);
    return value;
}
void GEventServerAdvanceTick_t::SetParent(GEventAdvanceTick_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("EventServerAdvanceTick_t::SetParent(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassEventServerAdvanceTick_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GEventServerAdvanceTick_t>("EventServerAdvanceTick_t")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Parent", &GEventServerAdvanceTick_t::GetParent, &GEventServerAdvanceTick_t::SetParent)
        .addFunction("ToPtr", &GEventServerAdvanceTick_t::ToPtr)
        .addFunction("IsValid", &GEventServerAdvanceTick_t::IsValid)
        .endClass();
}
GTimedEvent::GTimedEvent(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GTimedEvent::GTimedEvent(void *ptr) {
    m_ptr = ptr;
}
float GTimedEvent::GetTimeBetweenEvents() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: TimedEvent->TimeBetweenEvents(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "TimedEvent", "m_TimeBetweenEvents");
}
void GTimedEvent::SetTimeBetweenEvents(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: TimedEvent->TimeBetweenEvents(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "TimedEvent", "m_TimeBetweenEvents", false, value);
}
float GTimedEvent::GetNextEvent() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: TimedEvent->NextEvent(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "TimedEvent", "m_fNextEvent");
}
void GTimedEvent::SetNextEvent(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: TimedEvent->NextEvent(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "TimedEvent", "m_fNextEvent", false, value);
}
void* GTimedEvent::GetPtr() {
    return m_ptr;
}
std::string GTimedEvent::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GTimedEvent::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassTimedEvent(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GTimedEvent>("TimedEvent")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("TimeBetweenEvents", &GTimedEvent::GetTimeBetweenEvents, &GTimedEvent::SetTimeBetweenEvents)
        .addProperty("NextEvent", &GTimedEvent::GetNextEvent, &GTimedEvent::SetNextEvent)
        .addFunction("ToPtr", &GTimedEvent::ToPtr)
        .addFunction("IsValid", &GTimedEvent::IsValid)
        .endClass();
}
GTextureGroup_t::GTextureGroup_t(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GTextureGroup_t::GTextureGroup_t(void *ptr) {
    m_ptr = ptr;
}
bool GTextureGroup_t::GetEnabled() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: TextureGroup_t->Enabled(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "TextureGroup_t", "m_bEnabled");
}
void GTextureGroup_t::SetEnabled(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: TextureGroup_t->Enabled(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "TextureGroup_t", "m_bEnabled", true, value);
}
bool GTextureGroup_t::GetReplaceTextureWithGradient() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: TextureGroup_t->ReplaceTextureWithGradient(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "TextureGroup_t", "m_bReplaceTextureWithGradient");
}
void GTextureGroup_t::SetReplaceTextureWithGradient(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: TextureGroup_t->ReplaceTextureWithGradient(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "TextureGroup_t", "m_bReplaceTextureWithGradient", true, value);
}
uint64_t GTextureGroup_t::GetTextureType() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: TextureGroup_t->TextureType(ptr=%p)", m_ptr));
    return GetSchemaValue<uint64_t>(m_ptr, "TextureGroup_t", "m_nTextureType");
}
void GTextureGroup_t::SetTextureType(uint64_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: TextureGroup_t->TextureType(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "TextureGroup_t", "m_nTextureType", true, value);
}
uint64_t GTextureGroup_t::GetTextureChannels() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: TextureGroup_t->TextureChannels(ptr=%p)", m_ptr));
    return GetSchemaValue<uint64_t>(m_ptr, "TextureGroup_t", "m_nTextureChannels");
}
void GTextureGroup_t::SetTextureChannels(uint64_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: TextureGroup_t->TextureChannels(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "TextureGroup_t", "m_nTextureChannels", true, value);
}
uint64_t GTextureGroup_t::GetTextureBlendMode() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: TextureGroup_t->TextureBlendMode(ptr=%p)", m_ptr));
    return GetSchemaValue<uint64_t>(m_ptr, "TextureGroup_t", "m_nTextureBlendMode");
}
void GTextureGroup_t::SetTextureBlendMode(uint64_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: TextureGroup_t->TextureBlendMode(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "TextureGroup_t", "m_nTextureBlendMode", true, value);
}
GCParticleCollectionRendererFloatInput GTextureGroup_t::GetTextureBlend() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: TextureGroup_t->TextureBlend(ptr=%p)", m_ptr));
    GCParticleCollectionRendererFloatInput value(GetSchemaPtr(m_ptr, "TextureGroup_t", "m_flTextureBlend"));
    return value;
}
void GTextureGroup_t::SetTextureBlend(GCParticleCollectionRendererFloatInput value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: TextureGroup_t->TextureBlend(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'TextureBlend' is not possible.\n");
}
GTextureControls_t GTextureGroup_t::GetTextureControls() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: TextureGroup_t->TextureControls(ptr=%p)", m_ptr));
    GTextureControls_t value(GetSchemaPtr(m_ptr, "TextureGroup_t", "m_TextureControls"));
    return value;
}
void GTextureGroup_t::SetTextureControls(GTextureControls_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: TextureGroup_t->TextureControls(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'TextureControls' is not possible.\n");
}
void* GTextureGroup_t::GetPtr() {
    return m_ptr;
}
std::string GTextureGroup_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GTextureGroup_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassTextureGroup_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GTextureGroup_t>("TextureGroup_t")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Enabled", &GTextureGroup_t::GetEnabled, &GTextureGroup_t::SetEnabled)
        .addProperty("ReplaceTextureWithGradient", &GTextureGroup_t::GetReplaceTextureWithGradient, &GTextureGroup_t::SetReplaceTextureWithGradient)
        .addProperty("TextureType", &GTextureGroup_t::GetTextureType, &GTextureGroup_t::SetTextureType)
        .addProperty("TextureChannels", &GTextureGroup_t::GetTextureChannels, &GTextureGroup_t::SetTextureChannels)
        .addProperty("TextureBlendMode", &GTextureGroup_t::GetTextureBlendMode, &GTextureGroup_t::SetTextureBlendMode)
        .addProperty("TextureBlend", &GTextureGroup_t::GetTextureBlend, &GTextureGroup_t::SetTextureBlend)
        .addProperty("TextureControls", &GTextureGroup_t::GetTextureControls, &GTextureGroup_t::SetTextureControls)
        .addFunction("ToPtr", &GTextureGroup_t::ToPtr)
        .addFunction("IsValid", &GTextureGroup_t::IsValid)
        .endClass();
}
GCSosGroupActionSoundeventPrioritySchema::GCSosGroupActionSoundeventPrioritySchema(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCSosGroupActionSoundeventPrioritySchema::GCSosGroupActionSoundeventPrioritySchema(void *ptr) {
    m_ptr = ptr;
}
std::string GCSosGroupActionSoundeventPrioritySchema::GetPriorityValue() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CSosGroupActionSoundeventPrioritySchema->PriorityValue(ptr=%p)", m_ptr));
    return GetSchemaValue<CUtlString>(m_ptr, "CSosGroupActionSoundeventPrioritySchema", "m_priorityValue").Get();
}
void GCSosGroupActionSoundeventPrioritySchema::SetPriorityValue(std::string value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CSosGroupActionSoundeventPrioritySchema->PriorityValue(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CSosGroupActionSoundeventPrioritySchema", "m_priorityValue", false, CUtlString(value.c_str()));
}
std::string GCSosGroupActionSoundeventPrioritySchema::GetPriorityVolumeScalar() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CSosGroupActionSoundeventPrioritySchema->PriorityVolumeScalar(ptr=%p)", m_ptr));
    return GetSchemaValue<CUtlString>(m_ptr, "CSosGroupActionSoundeventPrioritySchema", "m_priorityVolumeScalar").Get();
}
void GCSosGroupActionSoundeventPrioritySchema::SetPriorityVolumeScalar(std::string value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CSosGroupActionSoundeventPrioritySchema->PriorityVolumeScalar(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CSosGroupActionSoundeventPrioritySchema", "m_priorityVolumeScalar", false, CUtlString(value.c_str()));
}
std::string GCSosGroupActionSoundeventPrioritySchema::GetPriorityContributeButDontRead() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CSosGroupActionSoundeventPrioritySchema->PriorityContributeButDontRead(ptr=%p)", m_ptr));
    return GetSchemaValue<CUtlString>(m_ptr, "CSosGroupActionSoundeventPrioritySchema", "m_priorityContributeButDontRead").Get();
}
void GCSosGroupActionSoundeventPrioritySchema::SetPriorityContributeButDontRead(std::string value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CSosGroupActionSoundeventPrioritySchema->PriorityContributeButDontRead(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CSosGroupActionSoundeventPrioritySchema", "m_priorityContributeButDontRead", false, CUtlString(value.c_str()));
}
std::string GCSosGroupActionSoundeventPrioritySchema::GetPriorityReadButDontContribute() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CSosGroupActionSoundeventPrioritySchema->PriorityReadButDontContribute(ptr=%p)", m_ptr));
    return GetSchemaValue<CUtlString>(m_ptr, "CSosGroupActionSoundeventPrioritySchema", "m_bPriorityReadButDontContribute").Get();
}
void GCSosGroupActionSoundeventPrioritySchema::SetPriorityReadButDontContribute(std::string value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CSosGroupActionSoundeventPrioritySchema->PriorityReadButDontContribute(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CSosGroupActionSoundeventPrioritySchema", "m_bPriorityReadButDontContribute", false, CUtlString(value.c_str()));
}
void* GCSosGroupActionSoundeventPrioritySchema::GetPtr() {
    return m_ptr;
}
std::string GCSosGroupActionSoundeventPrioritySchema::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCSosGroupActionSoundeventPrioritySchema::IsValid() {
    return (m_ptr != nullptr);
}
GCSosGroupActionSchema GCSosGroupActionSoundeventPrioritySchema::GetParent() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CSosGroupActionSoundeventPrioritySchema::GetParent(ptr=%p)", m_ptr));
    GCSosGroupActionSchema value(m_ptr);
    return value;
}
void GCSosGroupActionSoundeventPrioritySchema::SetParent(GCSosGroupActionSchema value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CSosGroupActionSoundeventPrioritySchema::SetParent(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCSosGroupActionSoundeventPrioritySchema(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCSosGroupActionSoundeventPrioritySchema>("CSosGroupActionSoundeventPrioritySchema")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("PriorityValue", &GCSosGroupActionSoundeventPrioritySchema::GetPriorityValue, &GCSosGroupActionSoundeventPrioritySchema::SetPriorityValue)
        .addProperty("PriorityVolumeScalar", &GCSosGroupActionSoundeventPrioritySchema::GetPriorityVolumeScalar, &GCSosGroupActionSoundeventPrioritySchema::SetPriorityVolumeScalar)
        .addProperty("PriorityContributeButDontRead", &GCSosGroupActionSoundeventPrioritySchema::GetPriorityContributeButDontRead, &GCSosGroupActionSoundeventPrioritySchema::SetPriorityContributeButDontRead)
        .addProperty("PriorityReadButDontContribute", &GCSosGroupActionSoundeventPrioritySchema::GetPriorityReadButDontContribute, &GCSosGroupActionSoundeventPrioritySchema::SetPriorityReadButDontContribute)
        .addProperty("Parent", &GCSosGroupActionSoundeventPrioritySchema::GetParent, &GCSosGroupActionSoundeventPrioritySchema::SetParent)
        .addFunction("ToPtr", &GCSosGroupActionSoundeventPrioritySchema::ToPtr)
        .addFunction("IsValid", &GCSosGroupActionSoundeventPrioritySchema::IsValid)
        .endClass();
}
GCBonePositionMetricEvaluator::GCBonePositionMetricEvaluator(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCBonePositionMetricEvaluator::GCBonePositionMetricEvaluator(void *ptr) {
    m_ptr = ptr;
}
int32_t GCBonePositionMetricEvaluator::GetBoneIndex() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CBonePositionMetricEvaluator->BoneIndex(ptr=%p)", m_ptr));
    return GetSchemaValue<int32_t>(m_ptr, "CBonePositionMetricEvaluator", "m_nBoneIndex");
}
void GCBonePositionMetricEvaluator::SetBoneIndex(int32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CBonePositionMetricEvaluator->BoneIndex(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CBonePositionMetricEvaluator", "m_nBoneIndex", false, value);
}
void* GCBonePositionMetricEvaluator::GetPtr() {
    return m_ptr;
}
std::string GCBonePositionMetricEvaluator::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCBonePositionMetricEvaluator::IsValid() {
    return (m_ptr != nullptr);
}
GCMotionMetricEvaluator GCBonePositionMetricEvaluator::GetParent() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CBonePositionMetricEvaluator::GetParent(ptr=%p)", m_ptr));
    GCMotionMetricEvaluator value(m_ptr);
    return value;
}
void GCBonePositionMetricEvaluator::SetParent(GCMotionMetricEvaluator value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CBonePositionMetricEvaluator::SetParent(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCBonePositionMetricEvaluator(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCBonePositionMetricEvaluator>("CBonePositionMetricEvaluator")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("BoneIndex", &GCBonePositionMetricEvaluator::GetBoneIndex, &GCBonePositionMetricEvaluator::SetBoneIndex)
        .addProperty("Parent", &GCBonePositionMetricEvaluator::GetParent, &GCBonePositionMetricEvaluator::SetParent)
        .addFunction("ToPtr", &GCBonePositionMetricEvaluator::ToPtr)
        .addFunction("IsValid", &GCBonePositionMetricEvaluator::IsValid)
        .endClass();
}
GCPhysSurfacePropertiesAudio::GCPhysSurfacePropertiesAudio(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCPhysSurfacePropertiesAudio::GCPhysSurfacePropertiesAudio(void *ptr) {
    m_ptr = ptr;
}
float GCPhysSurfacePropertiesAudio::GetReflectivity() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CPhysSurfacePropertiesAudio->Reflectivity(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CPhysSurfacePropertiesAudio", "m_reflectivity");
}
void GCPhysSurfacePropertiesAudio::SetReflectivity(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CPhysSurfacePropertiesAudio->Reflectivity(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CPhysSurfacePropertiesAudio", "m_reflectivity", false, value);
}
float GCPhysSurfacePropertiesAudio::GetHardnessFactor() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CPhysSurfacePropertiesAudio->HardnessFactor(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CPhysSurfacePropertiesAudio", "m_hardnessFactor");
}
void GCPhysSurfacePropertiesAudio::SetHardnessFactor(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CPhysSurfacePropertiesAudio->HardnessFactor(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CPhysSurfacePropertiesAudio", "m_hardnessFactor", false, value);
}
float GCPhysSurfacePropertiesAudio::GetRoughnessFactor() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CPhysSurfacePropertiesAudio->RoughnessFactor(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CPhysSurfacePropertiesAudio", "m_roughnessFactor");
}
void GCPhysSurfacePropertiesAudio::SetRoughnessFactor(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CPhysSurfacePropertiesAudio->RoughnessFactor(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CPhysSurfacePropertiesAudio", "m_roughnessFactor", false, value);
}
float GCPhysSurfacePropertiesAudio::GetRoughThreshold() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CPhysSurfacePropertiesAudio->RoughThreshold(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CPhysSurfacePropertiesAudio", "m_roughThreshold");
}
void GCPhysSurfacePropertiesAudio::SetRoughThreshold(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CPhysSurfacePropertiesAudio->RoughThreshold(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CPhysSurfacePropertiesAudio", "m_roughThreshold", false, value);
}
float GCPhysSurfacePropertiesAudio::GetHardThreshold() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CPhysSurfacePropertiesAudio->HardThreshold(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CPhysSurfacePropertiesAudio", "m_hardThreshold");
}
void GCPhysSurfacePropertiesAudio::SetHardThreshold(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CPhysSurfacePropertiesAudio->HardThreshold(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CPhysSurfacePropertiesAudio", "m_hardThreshold", false, value);
}
float GCPhysSurfacePropertiesAudio::GetHardVelocityThreshold() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CPhysSurfacePropertiesAudio->HardVelocityThreshold(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CPhysSurfacePropertiesAudio", "m_hardVelocityThreshold");
}
void GCPhysSurfacePropertiesAudio::SetHardVelocityThreshold(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CPhysSurfacePropertiesAudio->HardVelocityThreshold(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CPhysSurfacePropertiesAudio", "m_hardVelocityThreshold", false, value);
}
float GCPhysSurfacePropertiesAudio::GetStaticImpactVolume() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CPhysSurfacePropertiesAudio->StaticImpactVolume(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CPhysSurfacePropertiesAudio", "m_flStaticImpactVolume");
}
void GCPhysSurfacePropertiesAudio::SetStaticImpactVolume(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CPhysSurfacePropertiesAudio->StaticImpactVolume(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CPhysSurfacePropertiesAudio", "m_flStaticImpactVolume", false, value);
}
float GCPhysSurfacePropertiesAudio::GetOcclusionFactor() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CPhysSurfacePropertiesAudio->OcclusionFactor(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CPhysSurfacePropertiesAudio", "m_flOcclusionFactor");
}
void GCPhysSurfacePropertiesAudio::SetOcclusionFactor(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CPhysSurfacePropertiesAudio->OcclusionFactor(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CPhysSurfacePropertiesAudio", "m_flOcclusionFactor", false, value);
}
void* GCPhysSurfacePropertiesAudio::GetPtr() {
    return m_ptr;
}
std::string GCPhysSurfacePropertiesAudio::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCPhysSurfacePropertiesAudio::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCPhysSurfacePropertiesAudio(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCPhysSurfacePropertiesAudio>("CPhysSurfacePropertiesAudio")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Reflectivity", &GCPhysSurfacePropertiesAudio::GetReflectivity, &GCPhysSurfacePropertiesAudio::SetReflectivity)
        .addProperty("HardnessFactor", &GCPhysSurfacePropertiesAudio::GetHardnessFactor, &GCPhysSurfacePropertiesAudio::SetHardnessFactor)
        .addProperty("RoughnessFactor", &GCPhysSurfacePropertiesAudio::GetRoughnessFactor, &GCPhysSurfacePropertiesAudio::SetRoughnessFactor)
        .addProperty("RoughThreshold", &GCPhysSurfacePropertiesAudio::GetRoughThreshold, &GCPhysSurfacePropertiesAudio::SetRoughThreshold)
        .addProperty("HardThreshold", &GCPhysSurfacePropertiesAudio::GetHardThreshold, &GCPhysSurfacePropertiesAudio::SetHardThreshold)
        .addProperty("HardVelocityThreshold", &GCPhysSurfacePropertiesAudio::GetHardVelocityThreshold, &GCPhysSurfacePropertiesAudio::SetHardVelocityThreshold)
        .addProperty("StaticImpactVolume", &GCPhysSurfacePropertiesAudio::GetStaticImpactVolume, &GCPhysSurfacePropertiesAudio::SetStaticImpactVolume)
        .addProperty("OcclusionFactor", &GCPhysSurfacePropertiesAudio::GetOcclusionFactor, &GCPhysSurfacePropertiesAudio::SetOcclusionFactor)
        .addFunction("ToPtr", &GCPhysSurfacePropertiesAudio::ToPtr)
        .addFunction("IsValid", &GCPhysSurfacePropertiesAudio::IsValid)
        .endClass();
}
GCNmIDValueNode::GCNmIDValueNode(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCNmIDValueNode::GCNmIDValueNode(void *ptr) {
    m_ptr = ptr;
}
void* GCNmIDValueNode::GetPtr() {
    return m_ptr;
}
std::string GCNmIDValueNode::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCNmIDValueNode::IsValid() {
    return (m_ptr != nullptr);
}
GCNmValueNode GCNmIDValueNode::GetParent() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CNmIDValueNode::GetParent(ptr=%p)", m_ptr));
    GCNmValueNode value(m_ptr);
    return value;
}
void GCNmIDValueNode::SetParent(GCNmValueNode value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CNmIDValueNode::SetParent(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCNmIDValueNode(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCNmIDValueNode>("CNmIDValueNode")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Parent", &GCNmIDValueNode::GetParent, &GCNmIDValueNode::SetParent)
        .addFunction("ToPtr", &GCNmIDValueNode::ToPtr)
        .addFunction("IsValid", &GCNmIDValueNode::IsValid)
        .endClass();
}
GFeSimdNodeBase_t::GFeSimdNodeBase_t(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GFeSimdNodeBase_t::GFeSimdNodeBase_t(void *ptr) {
    m_ptr = ptr;
}
std::vector<uint16_t> GFeSimdNodeBase_t::GetNode() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FeSimdNodeBase_t->Node(ptr=%p,size=4)", m_ptr));
    uint16_t* outValue = (uint16_t*)GetSchemaPtr(m_ptr, "FeSimdNodeBase_t", "nNode"); std::vector<uint16_t> ret; for(int i = 0; i < 4; i++) { ret.push_back(outValue[i]); } return ret;
}
void GFeSimdNodeBase_t::SetNode(std::vector<uint16_t> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FeSimdNodeBase_t->Node(ptr=%p,size=4)", m_ptr));
    if(value.size() != 4) return PLUGIN_PRINT("Schema SDK", "Field 'Node' needs to have 4 values.\n");
    auto val = GetSchemaValuePtr<uint16_t>(m_ptr, "FeSimdNodeBase_t", "nNode");
    for(size_t i = 0; i < value.size(); i++) val[i] = value[i];
}
std::vector<uint16_t> GFeSimdNodeBase_t::GetNodeX0() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FeSimdNodeBase_t->NodeX0(ptr=%p,size=4)", m_ptr));
    uint16_t* outValue = (uint16_t*)GetSchemaPtr(m_ptr, "FeSimdNodeBase_t", "nNodeX0"); std::vector<uint16_t> ret; for(int i = 0; i < 4; i++) { ret.push_back(outValue[i]); } return ret;
}
void GFeSimdNodeBase_t::SetNodeX0(std::vector<uint16_t> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FeSimdNodeBase_t->NodeX0(ptr=%p,size=4)", m_ptr));
    if(value.size() != 4) return PLUGIN_PRINT("Schema SDK", "Field 'NodeX0' needs to have 4 values.\n");
    auto val = GetSchemaValuePtr<uint16_t>(m_ptr, "FeSimdNodeBase_t", "nNodeX0");
    for(size_t i = 0; i < value.size(); i++) val[i] = value[i];
}
std::vector<uint16_t> GFeSimdNodeBase_t::GetNodeX1() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FeSimdNodeBase_t->NodeX1(ptr=%p,size=4)", m_ptr));
    uint16_t* outValue = (uint16_t*)GetSchemaPtr(m_ptr, "FeSimdNodeBase_t", "nNodeX1"); std::vector<uint16_t> ret; for(int i = 0; i < 4; i++) { ret.push_back(outValue[i]); } return ret;
}
void GFeSimdNodeBase_t::SetNodeX1(std::vector<uint16_t> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FeSimdNodeBase_t->NodeX1(ptr=%p,size=4)", m_ptr));
    if(value.size() != 4) return PLUGIN_PRINT("Schema SDK", "Field 'NodeX1' needs to have 4 values.\n");
    auto val = GetSchemaValuePtr<uint16_t>(m_ptr, "FeSimdNodeBase_t", "nNodeX1");
    for(size_t i = 0; i < value.size(); i++) val[i] = value[i];
}
std::vector<uint16_t> GFeSimdNodeBase_t::GetNodeY0() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FeSimdNodeBase_t->NodeY0(ptr=%p,size=4)", m_ptr));
    uint16_t* outValue = (uint16_t*)GetSchemaPtr(m_ptr, "FeSimdNodeBase_t", "nNodeY0"); std::vector<uint16_t> ret; for(int i = 0; i < 4; i++) { ret.push_back(outValue[i]); } return ret;
}
void GFeSimdNodeBase_t::SetNodeY0(std::vector<uint16_t> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FeSimdNodeBase_t->NodeY0(ptr=%p,size=4)", m_ptr));
    if(value.size() != 4) return PLUGIN_PRINT("Schema SDK", "Field 'NodeY0' needs to have 4 values.\n");
    auto val = GetSchemaValuePtr<uint16_t>(m_ptr, "FeSimdNodeBase_t", "nNodeY0");
    for(size_t i = 0; i < value.size(); i++) val[i] = value[i];
}
std::vector<uint16_t> GFeSimdNodeBase_t::GetNodeY1() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FeSimdNodeBase_t->NodeY1(ptr=%p,size=4)", m_ptr));
    uint16_t* outValue = (uint16_t*)GetSchemaPtr(m_ptr, "FeSimdNodeBase_t", "nNodeY1"); std::vector<uint16_t> ret; for(int i = 0; i < 4; i++) { ret.push_back(outValue[i]); } return ret;
}
void GFeSimdNodeBase_t::SetNodeY1(std::vector<uint16_t> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FeSimdNodeBase_t->NodeY1(ptr=%p,size=4)", m_ptr));
    if(value.size() != 4) return PLUGIN_PRINT("Schema SDK", "Field 'NodeY1' needs to have 4 values.\n");
    auto val = GetSchemaValuePtr<uint16_t>(m_ptr, "FeSimdNodeBase_t", "nNodeY1");
    for(size_t i = 0; i < value.size(); i++) val[i] = value[i];
}
std::vector<uint16_t> GFeSimdNodeBase_t::GetDummy() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FeSimdNodeBase_t->Dummy(ptr=%p,size=4)", m_ptr));
    uint16_t* outValue = (uint16_t*)GetSchemaPtr(m_ptr, "FeSimdNodeBase_t", "nDummy"); std::vector<uint16_t> ret; for(int i = 0; i < 4; i++) { ret.push_back(outValue[i]); } return ret;
}
void GFeSimdNodeBase_t::SetDummy(std::vector<uint16_t> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FeSimdNodeBase_t->Dummy(ptr=%p,size=4)", m_ptr));
    if(value.size() != 4) return PLUGIN_PRINT("Schema SDK", "Field 'Dummy' needs to have 4 values.\n");
    auto val = GetSchemaValuePtr<uint16_t>(m_ptr, "FeSimdNodeBase_t", "nDummy");
    for(size_t i = 0; i < value.size(); i++) val[i] = value[i];
}
void* GFeSimdNodeBase_t::GetPtr() {
    return m_ptr;
}
std::string GFeSimdNodeBase_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GFeSimdNodeBase_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassFeSimdNodeBase_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GFeSimdNodeBase_t>("FeSimdNodeBase_t")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Node", &GFeSimdNodeBase_t::GetNode, &GFeSimdNodeBase_t::SetNode)
        .addProperty("NodeX0", &GFeSimdNodeBase_t::GetNodeX0, &GFeSimdNodeBase_t::SetNodeX0)
        .addProperty("NodeX1", &GFeSimdNodeBase_t::GetNodeX1, &GFeSimdNodeBase_t::SetNodeX1)
        .addProperty("NodeY0", &GFeSimdNodeBase_t::GetNodeY0, &GFeSimdNodeBase_t::SetNodeY0)
        .addProperty("NodeY1", &GFeSimdNodeBase_t::GetNodeY1, &GFeSimdNodeBase_t::SetNodeY1)
        .addProperty("Dummy", &GFeSimdNodeBase_t::GetDummy, &GFeSimdNodeBase_t::SetDummy)
        .addFunction("ToPtr", &GFeSimdNodeBase_t::ToPtr)
        .addFunction("IsValid", &GFeSimdNodeBase_t::IsValid)
        .endClass();
}
GPermModelExtPart_t::GPermModelExtPart_t(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GPermModelExtPart_t::GPermModelExtPart_t(void *ptr) {
    m_ptr = ptr;
}
std::string GPermModelExtPart_t::GetName() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: PermModelExtPart_t->Name(ptr=%p)", m_ptr));
    return GetSchemaValue<CUtlString>(m_ptr, "PermModelExtPart_t", "m_Name").Get();
}
void GPermModelExtPart_t::SetName(std::string value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: PermModelExtPart_t->Name(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "PermModelExtPart_t", "m_Name", true, CUtlString(value.c_str()));
}
int32_t GPermModelExtPart_t::GetParent() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: PermModelExtPart_t->Parent(ptr=%p)", m_ptr));
    return GetSchemaValue<int32_t>(m_ptr, "PermModelExtPart_t", "m_nParent");
}
void GPermModelExtPart_t::SetParent(int32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: PermModelExtPart_t->Parent(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "PermModelExtPart_t", "m_nParent", true, value);
}
void* GPermModelExtPart_t::GetPtr() {
    return m_ptr;
}
std::string GPermModelExtPart_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GPermModelExtPart_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassPermModelExtPart_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GPermModelExtPart_t>("PermModelExtPart_t")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Name", &GPermModelExtPart_t::GetName, &GPermModelExtPart_t::SetName)
        .addProperty("Parent", &GPermModelExtPart_t::GetParent, &GPermModelExtPart_t::SetParent)
        .addFunction("ToPtr", &GPermModelExtPart_t::ToPtr)
        .addFunction("IsValid", &GPermModelExtPart_t::IsValid)
        .endClass();
}
GCCurrentRotationVelocityMetricEvaluator::GCCurrentRotationVelocityMetricEvaluator(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCCurrentRotationVelocityMetricEvaluator::GCCurrentRotationVelocityMetricEvaluator(void *ptr) {
    m_ptr = ptr;
}
void* GCCurrentRotationVelocityMetricEvaluator::GetPtr() {
    return m_ptr;
}
std::string GCCurrentRotationVelocityMetricEvaluator::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCCurrentRotationVelocityMetricEvaluator::IsValid() {
    return (m_ptr != nullptr);
}
GCMotionMetricEvaluator GCCurrentRotationVelocityMetricEvaluator::GetParent() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CCurrentRotationVelocityMetricEvaluator::GetParent(ptr=%p)", m_ptr));
    GCMotionMetricEvaluator value(m_ptr);
    return value;
}
void GCCurrentRotationVelocityMetricEvaluator::SetParent(GCMotionMetricEvaluator value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CCurrentRotationVelocityMetricEvaluator::SetParent(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCCurrentRotationVelocityMetricEvaluator(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCCurrentRotationVelocityMetricEvaluator>("CCurrentRotationVelocityMetricEvaluator")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Parent", &GCCurrentRotationVelocityMetricEvaluator::GetParent, &GCCurrentRotationVelocityMetricEvaluator::SetParent)
        .addFunction("ToPtr", &GCCurrentRotationVelocityMetricEvaluator::ToPtr)
        .addFunction("IsValid", &GCCurrentRotationVelocityMetricEvaluator::IsValid)
        .endClass();
}
GCAnimEventDefinition::GCAnimEventDefinition(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCAnimEventDefinition::GCAnimEventDefinition(void *ptr) {
    m_ptr = ptr;
}
int32_t GCAnimEventDefinition::GetFrame() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CAnimEventDefinition->Frame(ptr=%p)", m_ptr));
    return GetSchemaValue<int32_t>(m_ptr, "CAnimEventDefinition", "m_nFrame");
}
void GCAnimEventDefinition::SetFrame(int32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CAnimEventDefinition->Frame(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CAnimEventDefinition", "m_nFrame", false, value);
}
int32_t GCAnimEventDefinition::GetEndFrame() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CAnimEventDefinition->EndFrame(ptr=%p)", m_ptr));
    return GetSchemaValue<int32_t>(m_ptr, "CAnimEventDefinition", "m_nEndFrame");
}
void GCAnimEventDefinition::SetEndFrame(int32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CAnimEventDefinition->EndFrame(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CAnimEventDefinition", "m_nEndFrame", false, value);
}
float GCAnimEventDefinition::GetCycle() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CAnimEventDefinition->Cycle(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CAnimEventDefinition", "m_flCycle");
}
void GCAnimEventDefinition::SetCycle(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CAnimEventDefinition->Cycle(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CAnimEventDefinition", "m_flCycle", false, value);
}
float GCAnimEventDefinition::GetDuration() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CAnimEventDefinition->Duration(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CAnimEventDefinition", "m_flDuration");
}
void GCAnimEventDefinition::SetDuration(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CAnimEventDefinition->Duration(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CAnimEventDefinition", "m_flDuration", false, value);
}
void* GCAnimEventDefinition::GetPtr() {
    return m_ptr;
}
std::string GCAnimEventDefinition::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCAnimEventDefinition::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCAnimEventDefinition(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCAnimEventDefinition>("CAnimEventDefinition")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Frame", &GCAnimEventDefinition::GetFrame, &GCAnimEventDefinition::SetFrame)
        .addProperty("EndFrame", &GCAnimEventDefinition::GetEndFrame, &GCAnimEventDefinition::SetEndFrame)
        .addProperty("Cycle", &GCAnimEventDefinition::GetCycle, &GCAnimEventDefinition::SetCycle)
        .addProperty("Duration", &GCAnimEventDefinition::GetDuration, &GCAnimEventDefinition::SetDuration)
        .addFunction("ToPtr", &GCAnimEventDefinition::ToPtr)
        .addFunction("IsValid", &GCAnimEventDefinition::IsValid)
        .endClass();
}
GCAnimEnum::GCAnimEnum(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCAnimEnum::GCAnimEnum(void *ptr) {
    m_ptr = ptr;
}
uint32_t GCAnimEnum::GetValue() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CAnimEnum->Value(ptr=%p)", m_ptr));
    return GetSchemaValue<uint32_t>(m_ptr, "CAnimEnum", "m_value");
}
void GCAnimEnum::SetValue(uint32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CAnimEnum->Value(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CAnimEnum", "m_value", false, value);
}
void* GCAnimEnum::GetPtr() {
    return m_ptr;
}
std::string GCAnimEnum::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCAnimEnum::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCAnimEnum(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCAnimEnum>("CAnimEnum")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Value", &GCAnimEnum::GetValue, &GCAnimEnum::SetValue)
        .addFunction("ToPtr", &GCAnimEnum::ToPtr)
        .addFunction("IsValid", &GCAnimEnum::IsValid)
        .endClass();
}
GCAnimFrameBlockAnim::GCAnimFrameBlockAnim(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCAnimFrameBlockAnim::GCAnimFrameBlockAnim(void *ptr) {
    m_ptr = ptr;
}
int32_t GCAnimFrameBlockAnim::GetStartFrame() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CAnimFrameBlockAnim->StartFrame(ptr=%p)", m_ptr));
    return GetSchemaValue<int32_t>(m_ptr, "CAnimFrameBlockAnim", "m_nStartFrame");
}
void GCAnimFrameBlockAnim::SetStartFrame(int32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CAnimFrameBlockAnim->StartFrame(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CAnimFrameBlockAnim", "m_nStartFrame", false, value);
}
int32_t GCAnimFrameBlockAnim::GetEndFrame() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CAnimFrameBlockAnim->EndFrame(ptr=%p)", m_ptr));
    return GetSchemaValue<int32_t>(m_ptr, "CAnimFrameBlockAnim", "m_nEndFrame");
}
void GCAnimFrameBlockAnim::SetEndFrame(int32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CAnimFrameBlockAnim->EndFrame(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CAnimFrameBlockAnim", "m_nEndFrame", false, value);
}
std::vector<int32> GCAnimFrameBlockAnim::GetSegmentIndexArray() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CAnimFrameBlockAnim->SegmentIndexArray(ptr=%p)", m_ptr));
    CUtlVector<int32>* vec = GetSchemaValue<CUtlVector<int32>*>(m_ptr, "CAnimFrameBlockAnim", "m_segmentIndexArray"); std::vector<int32> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCAnimFrameBlockAnim::SetSegmentIndexArray(std::vector<int32> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CAnimFrameBlockAnim->SegmentIndexArray(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<int32>(m_ptr, "CAnimFrameBlockAnim", "m_segmentIndexArray", false, value);
}
void* GCAnimFrameBlockAnim::GetPtr() {
    return m_ptr;
}
std::string GCAnimFrameBlockAnim::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCAnimFrameBlockAnim::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCAnimFrameBlockAnim(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCAnimFrameBlockAnim>("CAnimFrameBlockAnim")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("StartFrame", &GCAnimFrameBlockAnim::GetStartFrame, &GCAnimFrameBlockAnim::SetStartFrame)
        .addProperty("EndFrame", &GCAnimFrameBlockAnim::GetEndFrame, &GCAnimFrameBlockAnim::SetEndFrame)
        .addProperty("SegmentIndexArray", &GCAnimFrameBlockAnim::GetSegmentIndexArray, &GCAnimFrameBlockAnim::SetSegmentIndexArray)
        .addFunction("ToPtr", &GCAnimFrameBlockAnim::ToPtr)
        .addFunction("IsValid", &GCAnimFrameBlockAnim::IsValid)
        .endClass();
}
GCNmVirtualParameterIDNode::GCNmVirtualParameterIDNode(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCNmVirtualParameterIDNode::GCNmVirtualParameterIDNode(void *ptr) {
    m_ptr = ptr;
}
int16_t GCNmVirtualParameterIDNode::GetChildNodeIdx() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CNmVirtualParameterIDNode->ChildNodeIdx(ptr=%p)", m_ptr));
    return GetSchemaValue<int16_t>(m_ptr, "CNmVirtualParameterIDNode", "m_nChildNodeIdx");
}
void GCNmVirtualParameterIDNode::SetChildNodeIdx(int16_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CNmVirtualParameterIDNode->ChildNodeIdx(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CNmVirtualParameterIDNode", "m_nChildNodeIdx", false, value);
}
void* GCNmVirtualParameterIDNode::GetPtr() {
    return m_ptr;
}
std::string GCNmVirtualParameterIDNode::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCNmVirtualParameterIDNode::IsValid() {
    return (m_ptr != nullptr);
}
GCNmIDValueNode GCNmVirtualParameterIDNode::GetParent() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CNmVirtualParameterIDNode::GetParent(ptr=%p)", m_ptr));
    GCNmIDValueNode value(m_ptr);
    return value;
}
void GCNmVirtualParameterIDNode::SetParent(GCNmIDValueNode value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CNmVirtualParameterIDNode::SetParent(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCNmVirtualParameterIDNode(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCNmVirtualParameterIDNode>("CNmVirtualParameterIDNode")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("ChildNodeIdx", &GCNmVirtualParameterIDNode::GetChildNodeIdx, &GCNmVirtualParameterIDNode::SetChildNodeIdx)
        .addProperty("Parent", &GCNmVirtualParameterIDNode::GetParent, &GCNmVirtualParameterIDNode::SetParent)
        .addFunction("ToPtr", &GCNmVirtualParameterIDNode::ToPtr)
        .addFunction("IsValid", &GCNmVirtualParameterIDNode::IsValid)
        .endClass();
}
GCFlashlightEffect::GCFlashlightEffect(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCFlashlightEffect::GCFlashlightEffect(void *ptr) {
    m_ptr = ptr;
}
bool GCFlashlightEffect::GetIsOn() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CFlashlightEffect->IsOn(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "CFlashlightEffect", "m_bIsOn");
}
void GCFlashlightEffect::SetIsOn(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CFlashlightEffect->IsOn(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CFlashlightEffect", "m_bIsOn", false, value);
}
bool GCFlashlightEffect::GetMuzzleFlashEnabled() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CFlashlightEffect->MuzzleFlashEnabled(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "CFlashlightEffect", "m_bMuzzleFlashEnabled");
}
void GCFlashlightEffect::SetMuzzleFlashEnabled(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CFlashlightEffect->MuzzleFlashEnabled(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CFlashlightEffect", "m_bMuzzleFlashEnabled", false, value);
}
float GCFlashlightEffect::GetMuzzleFlashBrightness() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CFlashlightEffect->MuzzleFlashBrightness(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CFlashlightEffect", "m_flMuzzleFlashBrightness");
}
void GCFlashlightEffect::SetMuzzleFlashBrightness(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CFlashlightEffect->MuzzleFlashBrightness(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CFlashlightEffect", "m_flMuzzleFlashBrightness", false, value);
}
Vector GCFlashlightEffect::GetMuzzleFlashOrigin() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CFlashlightEffect->MuzzleFlashOrigin(ptr=%p)", m_ptr));
    return GetSchemaValue<Vector>(m_ptr, "CFlashlightEffect", "m_vecMuzzleFlashOrigin");
}
void GCFlashlightEffect::SetMuzzleFlashOrigin(Vector value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CFlashlightEffect->MuzzleFlashOrigin(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CFlashlightEffect", "m_vecMuzzleFlashOrigin", false, value);
}
float GCFlashlightEffect::GetFov() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CFlashlightEffect->Fov(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CFlashlightEffect", "m_flFov");
}
void GCFlashlightEffect::SetFov(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CFlashlightEffect->Fov(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CFlashlightEffect", "m_flFov", false, value);
}
float GCFlashlightEffect::GetFarZ() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CFlashlightEffect->FarZ(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CFlashlightEffect", "m_flFarZ");
}
void GCFlashlightEffect::SetFarZ(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CFlashlightEffect->FarZ(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CFlashlightEffect", "m_flFarZ", false, value);
}
float GCFlashlightEffect::GetLinearAtten() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CFlashlightEffect->LinearAtten(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CFlashlightEffect", "m_flLinearAtten");
}
void GCFlashlightEffect::SetLinearAtten(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CFlashlightEffect->LinearAtten(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CFlashlightEffect", "m_flLinearAtten", false, value);
}
bool GCFlashlightEffect::GetCastsShadows() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CFlashlightEffect->CastsShadows(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "CFlashlightEffect", "m_bCastsShadows");
}
void GCFlashlightEffect::SetCastsShadows(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CFlashlightEffect->CastsShadows(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CFlashlightEffect", "m_bCastsShadows", false, value);
}
float GCFlashlightEffect::GetCurrentPullBackDist() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CFlashlightEffect->CurrentPullBackDist(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CFlashlightEffect", "m_flCurrentPullBackDist");
}
void GCFlashlightEffect::SetCurrentPullBackDist(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CFlashlightEffect->CurrentPullBackDist(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CFlashlightEffect", "m_flCurrentPullBackDist", false, value);
}
std::string GCFlashlightEffect::GetTextureName() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CFlashlightEffect->TextureName(ptr=%p)", m_ptr));
    return GetSchemaValuePtr<char>(m_ptr, "CFlashlightEffect", "m_textureName");
}
void GCFlashlightEffect::SetTextureName(std::string value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CFlashlightEffect->TextureName(ptr=%p)", m_ptr));
    WriteSchemaPtrValue(m_ptr, "CFlashlightEffect", "m_textureName", false, reinterpret_cast<byte*>(const_cast<char*>(value.c_str())), 64);
}
void* GCFlashlightEffect::GetPtr() {
    return m_ptr;
}
std::string GCFlashlightEffect::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCFlashlightEffect::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCFlashlightEffect(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCFlashlightEffect>("CFlashlightEffect")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("IsOn", &GCFlashlightEffect::GetIsOn, &GCFlashlightEffect::SetIsOn)
        .addProperty("MuzzleFlashEnabled", &GCFlashlightEffect::GetMuzzleFlashEnabled, &GCFlashlightEffect::SetMuzzleFlashEnabled)
        .addProperty("MuzzleFlashBrightness", &GCFlashlightEffect::GetMuzzleFlashBrightness, &GCFlashlightEffect::SetMuzzleFlashBrightness)
        .addProperty("MuzzleFlashOrigin", &GCFlashlightEffect::GetMuzzleFlashOrigin, &GCFlashlightEffect::SetMuzzleFlashOrigin)
        .addProperty("Fov", &GCFlashlightEffect::GetFov, &GCFlashlightEffect::SetFov)
        .addProperty("FarZ", &GCFlashlightEffect::GetFarZ, &GCFlashlightEffect::SetFarZ)
        .addProperty("LinearAtten", &GCFlashlightEffect::GetLinearAtten, &GCFlashlightEffect::SetLinearAtten)
        .addProperty("CastsShadows", &GCFlashlightEffect::GetCastsShadows, &GCFlashlightEffect::SetCastsShadows)
        .addProperty("CurrentPullBackDist", &GCFlashlightEffect::GetCurrentPullBackDist, &GCFlashlightEffect::SetCurrentPullBackDist)
        .addProperty("TextureName", &GCFlashlightEffect::GetTextureName, &GCFlashlightEffect::SetTextureName)
        .addFunction("ToPtr", &GCFlashlightEffect::ToPtr)
        .addFunction("IsValid", &GCFlashlightEffect::IsValid)
        .endClass();
}
GFeBuildSphereRigid_t::GFeBuildSphereRigid_t(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GFeBuildSphereRigid_t::GFeBuildSphereRigid_t(void *ptr) {
    m_ptr = ptr;
}
int32_t GFeBuildSphereRigid_t::GetPriority() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FeBuildSphereRigid_t->Priority(ptr=%p)", m_ptr));
    return GetSchemaValue<int32_t>(m_ptr, "FeBuildSphereRigid_t", "m_nPriority");
}
void GFeBuildSphereRigid_t::SetPriority(int32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FeBuildSphereRigid_t->Priority(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "FeBuildSphereRigid_t", "m_nPriority", true, value);
}
uint32_t GFeBuildSphereRigid_t::GetVertexMapHash() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FeBuildSphereRigid_t->VertexMapHash(ptr=%p)", m_ptr));
    return GetSchemaValue<uint32_t>(m_ptr, "FeBuildSphereRigid_t", "m_nVertexMapHash");
}
void GFeBuildSphereRigid_t::SetVertexMapHash(uint32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FeBuildSphereRigid_t->VertexMapHash(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "FeBuildSphereRigid_t", "m_nVertexMapHash", true, value);
}
void* GFeBuildSphereRigid_t::GetPtr() {
    return m_ptr;
}
std::string GFeBuildSphereRigid_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GFeBuildSphereRigid_t::IsValid() {
    return (m_ptr != nullptr);
}
GFeSphereRigid_t GFeBuildSphereRigid_t::GetParent() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("FeBuildSphereRigid_t::GetParent(ptr=%p)", m_ptr));
    GFeSphereRigid_t value(m_ptr);
    return value;
}
void GFeBuildSphereRigid_t::SetParent(GFeSphereRigid_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("FeBuildSphereRigid_t::SetParent(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassFeBuildSphereRigid_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GFeBuildSphereRigid_t>("FeBuildSphereRigid_t")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Priority", &GFeBuildSphereRigid_t::GetPriority, &GFeBuildSphereRigid_t::SetPriority)
        .addProperty("VertexMapHash", &GFeBuildSphereRigid_t::GetVertexMapHash, &GFeBuildSphereRigid_t::SetVertexMapHash)
        .addProperty("Parent", &GFeBuildSphereRigid_t::GetParent, &GFeBuildSphereRigid_t::SetParent)
        .addFunction("ToPtr", &GFeBuildSphereRigid_t::ToPtr)
        .addFunction("IsValid", &GFeBuildSphereRigid_t::IsValid)
        .endClass();
}
GCAnimEncodedFrames::GCAnimEncodedFrames(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCAnimEncodedFrames::GCAnimEncodedFrames(void *ptr) {
    m_ptr = ptr;
}
int32_t GCAnimEncodedFrames::GetFrames() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CAnimEncodedFrames->Frames(ptr=%p)", m_ptr));
    return GetSchemaValue<int32_t>(m_ptr, "CAnimEncodedFrames", "m_nFrames");
}
void GCAnimEncodedFrames::SetFrames(int32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CAnimEncodedFrames->Frames(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CAnimEncodedFrames", "m_nFrames", false, value);
}
int32_t GCAnimEncodedFrames::GetFramesPerBlock() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CAnimEncodedFrames->FramesPerBlock(ptr=%p)", m_ptr));
    return GetSchemaValue<int32_t>(m_ptr, "CAnimEncodedFrames", "m_nFramesPerBlock");
}
void GCAnimEncodedFrames::SetFramesPerBlock(int32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CAnimEncodedFrames->FramesPerBlock(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CAnimEncodedFrames", "m_nFramesPerBlock", false, value);
}
std::vector<GCAnimFrameBlockAnim> GCAnimEncodedFrames::GetFrameblockArray() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CAnimEncodedFrames->FrameblockArray(ptr=%p)", m_ptr));
    CUtlVector<GCAnimFrameBlockAnim>* vec = GetSchemaValue<CUtlVector<GCAnimFrameBlockAnim>*>(m_ptr, "CAnimEncodedFrames", "m_frameblockArray"); std::vector<GCAnimFrameBlockAnim> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCAnimEncodedFrames::SetFrameblockArray(std::vector<GCAnimFrameBlockAnim> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CAnimEncodedFrames->FrameblockArray(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<GCAnimFrameBlockAnim>(m_ptr, "CAnimEncodedFrames", "m_frameblockArray", false, value);
}
GCAnimEncodeDifference GCAnimEncodedFrames::GetUsageDifferences() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CAnimEncodedFrames->UsageDifferences(ptr=%p)", m_ptr));
    GCAnimEncodeDifference value(GetSchemaPtr(m_ptr, "CAnimEncodedFrames", "m_usageDifferences"));
    return value;
}
void GCAnimEncodedFrames::SetUsageDifferences(GCAnimEncodeDifference value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CAnimEncodedFrames->UsageDifferences(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'UsageDifferences' is not possible.\n");
}
void* GCAnimEncodedFrames::GetPtr() {
    return m_ptr;
}
std::string GCAnimEncodedFrames::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCAnimEncodedFrames::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCAnimEncodedFrames(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCAnimEncodedFrames>("CAnimEncodedFrames")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Frames", &GCAnimEncodedFrames::GetFrames, &GCAnimEncodedFrames::SetFrames)
        .addProperty("FramesPerBlock", &GCAnimEncodedFrames::GetFramesPerBlock, &GCAnimEncodedFrames::SetFramesPerBlock)
        .addProperty("FrameblockArray", &GCAnimEncodedFrames::GetFrameblockArray, &GCAnimEncodedFrames::SetFrameblockArray)
        .addProperty("UsageDifferences", &GCAnimEncodedFrames::GetUsageDifferences, &GCAnimEncodedFrames::SetUsageDifferences)
        .addFunction("ToPtr", &GCAnimEncodedFrames::ToPtr)
        .addFunction("IsValid", &GCAnimEncodedFrames::IsValid)
        .endClass();
}
GEventSetTime_t::GEventSetTime_t(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GEventSetTime_t::GEventSetTime_t(void *ptr) {
    m_ptr = ptr;
}
GEngineLoopState_t GEventSetTime_t::GetLoopState() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: EventSetTime_t->LoopState(ptr=%p)", m_ptr));
    GEngineLoopState_t value(GetSchemaPtr(m_ptr, "EventSetTime_t", "m_LoopState"));
    return value;
}
void GEventSetTime_t::SetLoopState(GEngineLoopState_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: EventSetTime_t->LoopState(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'LoopState' is not possible.\n");
}
int32_t GEventSetTime_t::GetClientOutputFrames() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: EventSetTime_t->ClientOutputFrames(ptr=%p)", m_ptr));
    return GetSchemaValue<int32_t>(m_ptr, "EventSetTime_t", "m_nClientOutputFrames");
}
void GEventSetTime_t::SetClientOutputFrames(int32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: EventSetTime_t->ClientOutputFrames(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "EventSetTime_t", "m_nClientOutputFrames", true, value);
}
double GEventSetTime_t::GetRealTime() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: EventSetTime_t->RealTime(ptr=%p)", m_ptr));
    return GetSchemaValue<double>(m_ptr, "EventSetTime_t", "m_flRealTime");
}
void GEventSetTime_t::SetRealTime(double value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: EventSetTime_t->RealTime(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "EventSetTime_t", "m_flRealTime", true, value);
}
double GEventSetTime_t::GetRenderTime() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: EventSetTime_t->RenderTime(ptr=%p)", m_ptr));
    return GetSchemaValue<double>(m_ptr, "EventSetTime_t", "m_flRenderTime");
}
void GEventSetTime_t::SetRenderTime(double value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: EventSetTime_t->RenderTime(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "EventSetTime_t", "m_flRenderTime", true, value);
}
double GEventSetTime_t::GetRenderFrameTime() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: EventSetTime_t->RenderFrameTime(ptr=%p)", m_ptr));
    return GetSchemaValue<double>(m_ptr, "EventSetTime_t", "m_flRenderFrameTime");
}
void GEventSetTime_t::SetRenderFrameTime(double value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: EventSetTime_t->RenderFrameTime(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "EventSetTime_t", "m_flRenderFrameTime", true, value);
}
double GEventSetTime_t::GetRenderFrameTimeUnbounded() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: EventSetTime_t->RenderFrameTimeUnbounded(ptr=%p)", m_ptr));
    return GetSchemaValue<double>(m_ptr, "EventSetTime_t", "m_flRenderFrameTimeUnbounded");
}
void GEventSetTime_t::SetRenderFrameTimeUnbounded(double value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: EventSetTime_t->RenderFrameTimeUnbounded(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "EventSetTime_t", "m_flRenderFrameTimeUnbounded", true, value);
}
double GEventSetTime_t::GetRenderFrameTimeUnscaled() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: EventSetTime_t->RenderFrameTimeUnscaled(ptr=%p)", m_ptr));
    return GetSchemaValue<double>(m_ptr, "EventSetTime_t", "m_flRenderFrameTimeUnscaled");
}
void GEventSetTime_t::SetRenderFrameTimeUnscaled(double value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: EventSetTime_t->RenderFrameTimeUnscaled(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "EventSetTime_t", "m_flRenderFrameTimeUnscaled", true, value);
}
double GEventSetTime_t::GetTickRemainder() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: EventSetTime_t->TickRemainder(ptr=%p)", m_ptr));
    return GetSchemaValue<double>(m_ptr, "EventSetTime_t", "m_flTickRemainder");
}
void GEventSetTime_t::SetTickRemainder(double value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: EventSetTime_t->TickRemainder(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "EventSetTime_t", "m_flTickRemainder", true, value);
}
void* GEventSetTime_t::GetPtr() {
    return m_ptr;
}
std::string GEventSetTime_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GEventSetTime_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassEventSetTime_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GEventSetTime_t>("EventSetTime_t")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("LoopState", &GEventSetTime_t::GetLoopState, &GEventSetTime_t::SetLoopState)
        .addProperty("ClientOutputFrames", &GEventSetTime_t::GetClientOutputFrames, &GEventSetTime_t::SetClientOutputFrames)
        .addProperty("RealTime", &GEventSetTime_t::GetRealTime, &GEventSetTime_t::SetRealTime)
        .addProperty("RenderTime", &GEventSetTime_t::GetRenderTime, &GEventSetTime_t::SetRenderTime)
        .addProperty("RenderFrameTime", &GEventSetTime_t::GetRenderFrameTime, &GEventSetTime_t::SetRenderFrameTime)
        .addProperty("RenderFrameTimeUnbounded", &GEventSetTime_t::GetRenderFrameTimeUnbounded, &GEventSetTime_t::SetRenderFrameTimeUnbounded)
        .addProperty("RenderFrameTimeUnscaled", &GEventSetTime_t::GetRenderFrameTimeUnscaled, &GEventSetTime_t::SetRenderFrameTimeUnscaled)
        .addProperty("TickRemainder", &GEventSetTime_t::GetTickRemainder, &GEventSetTime_t::SetTickRemainder)
        .addFunction("ToPtr", &GEventSetTime_t::ToPtr)
        .addFunction("IsValid", &GEventSetTime_t::IsValid)
        .endClass();
}
GOldFeEdge_t::GOldFeEdge_t(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GOldFeEdge_t::GOldFeEdge_t(void *ptr) {
    m_ptr = ptr;
}
std::vector<float> GOldFeEdge_t::GetK() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: OldFeEdge_t->K(ptr=%p,size=3)", m_ptr));
    float* outValue = (float*)GetSchemaPtr(m_ptr, "OldFeEdge_t", "m_flK"); std::vector<float> ret; for(int i = 0; i < 3; i++) { ret.push_back(outValue[i]); } return ret;
}
void GOldFeEdge_t::SetK(std::vector<float> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: OldFeEdge_t->K(ptr=%p,size=3)", m_ptr));
    if(value.size() != 3) return PLUGIN_PRINT("Schema SDK", "Field 'K' needs to have 3 values.\n");
    auto val = GetSchemaValuePtr<float>(m_ptr, "OldFeEdge_t", "m_flK");
    for(size_t i = 0; i < value.size(); i++) val[i] = value[i];
}
float GOldFeEdge_t::GetInvA() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: OldFeEdge_t->InvA(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "OldFeEdge_t", "invA");
}
void GOldFeEdge_t::SetInvA(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: OldFeEdge_t->InvA(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "OldFeEdge_t", "invA", true, value);
}
float GOldFeEdge_t::GetT() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: OldFeEdge_t->T(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "OldFeEdge_t", "t");
}
void GOldFeEdge_t::SetT(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: OldFeEdge_t->T(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "OldFeEdge_t", "t", true, value);
}
float GOldFeEdge_t::GetThetaRelaxed() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: OldFeEdge_t->ThetaRelaxed(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "OldFeEdge_t", "flThetaRelaxed");
}
void GOldFeEdge_t::SetThetaRelaxed(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: OldFeEdge_t->ThetaRelaxed(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "OldFeEdge_t", "flThetaRelaxed", true, value);
}
float GOldFeEdge_t::GetThetaFactor() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: OldFeEdge_t->ThetaFactor(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "OldFeEdge_t", "flThetaFactor");
}
void GOldFeEdge_t::SetThetaFactor(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: OldFeEdge_t->ThetaFactor(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "OldFeEdge_t", "flThetaFactor", true, value);
}
float GOldFeEdge_t::GetC01() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: OldFeEdge_t->C01(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "OldFeEdge_t", "c01");
}
void GOldFeEdge_t::SetC01(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: OldFeEdge_t->C01(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "OldFeEdge_t", "c01", true, value);
}
float GOldFeEdge_t::GetC02() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: OldFeEdge_t->C02(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "OldFeEdge_t", "c02");
}
void GOldFeEdge_t::SetC02(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: OldFeEdge_t->C02(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "OldFeEdge_t", "c02", true, value);
}
float GOldFeEdge_t::GetC03() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: OldFeEdge_t->C03(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "OldFeEdge_t", "c03");
}
void GOldFeEdge_t::SetC03(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: OldFeEdge_t->C03(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "OldFeEdge_t", "c03", true, value);
}
float GOldFeEdge_t::GetC04() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: OldFeEdge_t->C04(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "OldFeEdge_t", "c04");
}
void GOldFeEdge_t::SetC04(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: OldFeEdge_t->C04(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "OldFeEdge_t", "c04", true, value);
}
float GOldFeEdge_t::GetAxialModelDist() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: OldFeEdge_t->AxialModelDist(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "OldFeEdge_t", "flAxialModelDist");
}
void GOldFeEdge_t::SetAxialModelDist(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: OldFeEdge_t->AxialModelDist(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "OldFeEdge_t", "flAxialModelDist", true, value);
}
std::vector<float> GOldFeEdge_t::GetAxialModelWeights() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: OldFeEdge_t->AxialModelWeights(ptr=%p,size=4)", m_ptr));
    float* outValue = (float*)GetSchemaPtr(m_ptr, "OldFeEdge_t", "flAxialModelWeights"); std::vector<float> ret; for(int i = 0; i < 4; i++) { ret.push_back(outValue[i]); } return ret;
}
void GOldFeEdge_t::SetAxialModelWeights(std::vector<float> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: OldFeEdge_t->AxialModelWeights(ptr=%p,size=4)", m_ptr));
    if(value.size() != 4) return PLUGIN_PRINT("Schema SDK", "Field 'AxialModelWeights' needs to have 4 values.\n");
    auto val = GetSchemaValuePtr<float>(m_ptr, "OldFeEdge_t", "flAxialModelWeights");
    for(size_t i = 0; i < value.size(); i++) val[i] = value[i];
}
std::vector<uint16_t> GOldFeEdge_t::GetNode() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: OldFeEdge_t->Node(ptr=%p,size=4)", m_ptr));
    uint16_t* outValue = (uint16_t*)GetSchemaPtr(m_ptr, "OldFeEdge_t", "m_nNode"); std::vector<uint16_t> ret; for(int i = 0; i < 4; i++) { ret.push_back(outValue[i]); } return ret;
}
void GOldFeEdge_t::SetNode(std::vector<uint16_t> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: OldFeEdge_t->Node(ptr=%p,size=4)", m_ptr));
    if(value.size() != 4) return PLUGIN_PRINT("Schema SDK", "Field 'Node' needs to have 4 values.\n");
    auto val = GetSchemaValuePtr<uint16_t>(m_ptr, "OldFeEdge_t", "m_nNode");
    for(size_t i = 0; i < value.size(); i++) val[i] = value[i];
}
void* GOldFeEdge_t::GetPtr() {
    return m_ptr;
}
std::string GOldFeEdge_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GOldFeEdge_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassOldFeEdge_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GOldFeEdge_t>("OldFeEdge_t")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("K", &GOldFeEdge_t::GetK, &GOldFeEdge_t::SetK)
        .addProperty("InvA", &GOldFeEdge_t::GetInvA, &GOldFeEdge_t::SetInvA)
        .addProperty("T", &GOldFeEdge_t::GetT, &GOldFeEdge_t::SetT)
        .addProperty("ThetaRelaxed", &GOldFeEdge_t::GetThetaRelaxed, &GOldFeEdge_t::SetThetaRelaxed)
        .addProperty("ThetaFactor", &GOldFeEdge_t::GetThetaFactor, &GOldFeEdge_t::SetThetaFactor)
        .addProperty("C01", &GOldFeEdge_t::GetC01, &GOldFeEdge_t::SetC01)
        .addProperty("C02", &GOldFeEdge_t::GetC02, &GOldFeEdge_t::SetC02)
        .addProperty("C03", &GOldFeEdge_t::GetC03, &GOldFeEdge_t::SetC03)
        .addProperty("C04", &GOldFeEdge_t::GetC04, &GOldFeEdge_t::SetC04)
        .addProperty("AxialModelDist", &GOldFeEdge_t::GetAxialModelDist, &GOldFeEdge_t::SetAxialModelDist)
        .addProperty("AxialModelWeights", &GOldFeEdge_t::GetAxialModelWeights, &GOldFeEdge_t::SetAxialModelWeights)
        .addProperty("Node", &GOldFeEdge_t::GetNode, &GOldFeEdge_t::SetNode)
        .addFunction("ToPtr", &GOldFeEdge_t::ToPtr)
        .addFunction("IsValid", &GOldFeEdge_t::IsValid)
        .endClass();
}
GCStanceOverrideUpdateNode::GCStanceOverrideUpdateNode(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCStanceOverrideUpdateNode::GCStanceOverrideUpdateNode(void *ptr) {
    m_ptr = ptr;
}
std::vector<GStanceInfo_t> GCStanceOverrideUpdateNode::GetFootStanceInfo() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CStanceOverrideUpdateNode->FootStanceInfo(ptr=%p)", m_ptr));
    CUtlVector<GStanceInfo_t>* vec = GetSchemaValue<CUtlVector<GStanceInfo_t>*>(m_ptr, "CStanceOverrideUpdateNode", "m_footStanceInfo"); std::vector<GStanceInfo_t> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCStanceOverrideUpdateNode::SetFootStanceInfo(std::vector<GStanceInfo_t> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CStanceOverrideUpdateNode->FootStanceInfo(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<GStanceInfo_t>(m_ptr, "CStanceOverrideUpdateNode", "m_footStanceInfo", false, value);
}
GCAnimUpdateNodeRef GCStanceOverrideUpdateNode::GetStanceSourceNode() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CStanceOverrideUpdateNode->StanceSourceNode(ptr=%p)", m_ptr));
    GCAnimUpdateNodeRef value(GetSchemaPtr(m_ptr, "CStanceOverrideUpdateNode", "m_pStanceSourceNode"));
    return value;
}
void GCStanceOverrideUpdateNode::SetStanceSourceNode(GCAnimUpdateNodeRef value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CStanceOverrideUpdateNode->StanceSourceNode(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'StanceSourceNode' is not possible.\n");
}
GCAnimParamHandle GCStanceOverrideUpdateNode::GetParameter() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CStanceOverrideUpdateNode->Parameter(ptr=%p)", m_ptr));
    GCAnimParamHandle value(GetSchemaPtr(m_ptr, "CStanceOverrideUpdateNode", "m_hParameter"));
    return value;
}
void GCStanceOverrideUpdateNode::SetParameter(GCAnimParamHandle value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CStanceOverrideUpdateNode->Parameter(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parameter' is not possible.\n");
}
uint64_t GCStanceOverrideUpdateNode::GetMode() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CStanceOverrideUpdateNode->Mode(ptr=%p)", m_ptr));
    return GetSchemaValue<uint64_t>(m_ptr, "CStanceOverrideUpdateNode", "m_eMode");
}
void GCStanceOverrideUpdateNode::SetMode(uint64_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CStanceOverrideUpdateNode->Mode(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CStanceOverrideUpdateNode", "m_eMode", false, value);
}
void* GCStanceOverrideUpdateNode::GetPtr() {
    return m_ptr;
}
std::string GCStanceOverrideUpdateNode::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCStanceOverrideUpdateNode::IsValid() {
    return (m_ptr != nullptr);
}
GCUnaryUpdateNode GCStanceOverrideUpdateNode::GetParent() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CStanceOverrideUpdateNode::GetParent(ptr=%p)", m_ptr));
    GCUnaryUpdateNode value(m_ptr);
    return value;
}
void GCStanceOverrideUpdateNode::SetParent(GCUnaryUpdateNode value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CStanceOverrideUpdateNode::SetParent(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCStanceOverrideUpdateNode(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCStanceOverrideUpdateNode>("CStanceOverrideUpdateNode")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("FootStanceInfo", &GCStanceOverrideUpdateNode::GetFootStanceInfo, &GCStanceOverrideUpdateNode::SetFootStanceInfo)
        .addProperty("StanceSourceNode", &GCStanceOverrideUpdateNode::GetStanceSourceNode, &GCStanceOverrideUpdateNode::SetStanceSourceNode)
        .addProperty("Parameter", &GCStanceOverrideUpdateNode::GetParameter, &GCStanceOverrideUpdateNode::SetParameter)
        .addProperty("Mode", &GCStanceOverrideUpdateNode::GetMode, &GCStanceOverrideUpdateNode::SetMode)
        .addProperty("Parent", &GCStanceOverrideUpdateNode::GetParent, &GCStanceOverrideUpdateNode::SetParent)
        .addFunction("ToPtr", &GCStanceOverrideUpdateNode::ToPtr)
        .addFunction("IsValid", &GCStanceOverrideUpdateNode::IsValid)
        .endClass();
}
Gconstraint_breakableparams_t::Gconstraint_breakableparams_t(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
Gconstraint_breakableparams_t::Gconstraint_breakableparams_t(void *ptr) {
    m_ptr = ptr;
}
float Gconstraint_breakableparams_t::GetStrength() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: constraint_breakableparams_t->Strength(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "constraint_breakableparams_t", "strength");
}
void Gconstraint_breakableparams_t::SetStrength(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: constraint_breakableparams_t->Strength(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "constraint_breakableparams_t", "strength", true, value);
}
float Gconstraint_breakableparams_t::GetForceLimit() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: constraint_breakableparams_t->ForceLimit(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "constraint_breakableparams_t", "forceLimit");
}
void Gconstraint_breakableparams_t::SetForceLimit(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: constraint_breakableparams_t->ForceLimit(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "constraint_breakableparams_t", "forceLimit", true, value);
}
float Gconstraint_breakableparams_t::GetTorqueLimit() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: constraint_breakableparams_t->TorqueLimit(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "constraint_breakableparams_t", "torqueLimit");
}
void Gconstraint_breakableparams_t::SetTorqueLimit(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: constraint_breakableparams_t->TorqueLimit(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "constraint_breakableparams_t", "torqueLimit", true, value);
}
std::vector<float> Gconstraint_breakableparams_t::GetBodyMassScale() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: constraint_breakableparams_t->BodyMassScale(ptr=%p,size=2)", m_ptr));
    float* outValue = (float*)GetSchemaPtr(m_ptr, "constraint_breakableparams_t", "bodyMassScale"); std::vector<float> ret; for(int i = 0; i < 2; i++) { ret.push_back(outValue[i]); } return ret;
}
void Gconstraint_breakableparams_t::SetBodyMassScale(std::vector<float> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: constraint_breakableparams_t->BodyMassScale(ptr=%p,size=2)", m_ptr));
    if(value.size() != 2) return PLUGIN_PRINT("Schema SDK", "Field 'BodyMassScale' needs to have 2 values.\n");
    auto val = GetSchemaValuePtr<float>(m_ptr, "constraint_breakableparams_t", "bodyMassScale");
    for(size_t i = 0; i < value.size(); i++) val[i] = value[i];
}
bool Gconstraint_breakableparams_t::GetIsActive() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: constraint_breakableparams_t->IsActive(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "constraint_breakableparams_t", "isActive");
}
void Gconstraint_breakableparams_t::SetIsActive(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: constraint_breakableparams_t->IsActive(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "constraint_breakableparams_t", "isActive", true, value);
}
void* Gconstraint_breakableparams_t::GetPtr() {
    return m_ptr;
}
std::string Gconstraint_breakableparams_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool Gconstraint_breakableparams_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassconstraint_breakableparams_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<Gconstraint_breakableparams_t>("constraint_breakableparams_t")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Strength", &Gconstraint_breakableparams_t::GetStrength, &Gconstraint_breakableparams_t::SetStrength)
        .addProperty("ForceLimit", &Gconstraint_breakableparams_t::GetForceLimit, &Gconstraint_breakableparams_t::SetForceLimit)
        .addProperty("TorqueLimit", &Gconstraint_breakableparams_t::GetTorqueLimit, &Gconstraint_breakableparams_t::SetTorqueLimit)
        .addProperty("BodyMassScale", &Gconstraint_breakableparams_t::GetBodyMassScale, &Gconstraint_breakableparams_t::SetBodyMassScale)
        .addProperty("IsActive", &Gconstraint_breakableparams_t::GetIsActive, &Gconstraint_breakableparams_t::SetIsActive)
        .addFunction("ToPtr", &Gconstraint_breakableparams_t::ToPtr)
        .addFunction("IsValid", &Gconstraint_breakableparams_t::IsValid)
        .endClass();
}
GCStateNodeTransitionData::GCStateNodeTransitionData(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCStateNodeTransitionData::GCStateNodeTransitionData(void *ptr) {
    m_ptr = ptr;
}
GCBlendCurve GCStateNodeTransitionData::GetCurve() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CStateNodeTransitionData->Curve(ptr=%p)", m_ptr));
    GCBlendCurve value(GetSchemaPtr(m_ptr, "CStateNodeTransitionData", "m_curve"));
    return value;
}
void GCStateNodeTransitionData::SetCurve(GCBlendCurve value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CStateNodeTransitionData->Curve(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Curve' is not possible.\n");
}
void* GCStateNodeTransitionData::GetPtr() {
    return m_ptr;
}
std::string GCStateNodeTransitionData::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCStateNodeTransitionData::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCStateNodeTransitionData(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCStateNodeTransitionData>("CStateNodeTransitionData")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Curve", &GCStateNodeTransitionData::GetCurve, &GCStateNodeTransitionData::SetCurve)
        .addFunction("ToPtr", &GCStateNodeTransitionData::ToPtr)
        .addFunction("IsValid", &GCStateNodeTransitionData::IsValid)
        .endClass();
}
GCMotionMatchingUpdateNode::GCMotionMatchingUpdateNode(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCMotionMatchingUpdateNode::GCMotionMatchingUpdateNode(void *ptr) {
    m_ptr = ptr;
}
GCMotionDataSet GCMotionMatchingUpdateNode::GetDataSet() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CMotionMatchingUpdateNode->DataSet(ptr=%p)", m_ptr));
    GCMotionDataSet value(GetSchemaPtr(m_ptr, "CMotionMatchingUpdateNode", "m_dataSet"));
    return value;
}
void GCMotionMatchingUpdateNode::SetDataSet(GCMotionDataSet value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CMotionMatchingUpdateNode->DataSet(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'DataSet' is not possible.\n");
}
std::vector<float32> GCMotionMatchingUpdateNode::GetWeights() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CMotionMatchingUpdateNode->Weights(ptr=%p)", m_ptr));
    CUtlVector<float32>* vec = GetSchemaValue<CUtlVector<float32>*>(m_ptr, "CMotionMatchingUpdateNode", "m_weights"); std::vector<float32> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCMotionMatchingUpdateNode::SetWeights(std::vector<float32> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CMotionMatchingUpdateNode->Weights(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<float32>(m_ptr, "CMotionMatchingUpdateNode", "m_weights", false, value);
}
bool GCMotionMatchingUpdateNode::GetSearchEveryTick() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CMotionMatchingUpdateNode->SearchEveryTick(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "CMotionMatchingUpdateNode", "m_bSearchEveryTick");
}
void GCMotionMatchingUpdateNode::SetSearchEveryTick(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CMotionMatchingUpdateNode->SearchEveryTick(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CMotionMatchingUpdateNode", "m_bSearchEveryTick", false, value);
}
float GCMotionMatchingUpdateNode::GetSearchInterval() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CMotionMatchingUpdateNode->SearchInterval(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CMotionMatchingUpdateNode", "m_flSearchInterval");
}
void GCMotionMatchingUpdateNode::SetSearchInterval(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CMotionMatchingUpdateNode->SearchInterval(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CMotionMatchingUpdateNode", "m_flSearchInterval", false, value);
}
bool GCMotionMatchingUpdateNode::GetSearchWhenClipEnds() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CMotionMatchingUpdateNode->SearchWhenClipEnds(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "CMotionMatchingUpdateNode", "m_bSearchWhenClipEnds");
}
void GCMotionMatchingUpdateNode::SetSearchWhenClipEnds(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CMotionMatchingUpdateNode->SearchWhenClipEnds(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CMotionMatchingUpdateNode", "m_bSearchWhenClipEnds", false, value);
}
bool GCMotionMatchingUpdateNode::GetSearchWhenGoalChanges() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CMotionMatchingUpdateNode->SearchWhenGoalChanges(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "CMotionMatchingUpdateNode", "m_bSearchWhenGoalChanges");
}
void GCMotionMatchingUpdateNode::SetSearchWhenGoalChanges(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CMotionMatchingUpdateNode->SearchWhenGoalChanges(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CMotionMatchingUpdateNode", "m_bSearchWhenGoalChanges", false, value);
}
GCBlendCurve GCMotionMatchingUpdateNode::GetBlendCurve() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CMotionMatchingUpdateNode->BlendCurve(ptr=%p)", m_ptr));
    GCBlendCurve value(GetSchemaPtr(m_ptr, "CMotionMatchingUpdateNode", "m_blendCurve"));
    return value;
}
void GCMotionMatchingUpdateNode::SetBlendCurve(GCBlendCurve value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CMotionMatchingUpdateNode->BlendCurve(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'BlendCurve' is not possible.\n");
}
float GCMotionMatchingUpdateNode::GetSampleRate() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CMotionMatchingUpdateNode->SampleRate(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CMotionMatchingUpdateNode", "m_flSampleRate");
}
void GCMotionMatchingUpdateNode::SetSampleRate(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CMotionMatchingUpdateNode->SampleRate(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CMotionMatchingUpdateNode", "m_flSampleRate", false, value);
}
float GCMotionMatchingUpdateNode::GetBlendTime() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CMotionMatchingUpdateNode->BlendTime(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CMotionMatchingUpdateNode", "m_flBlendTime");
}
void GCMotionMatchingUpdateNode::SetBlendTime(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CMotionMatchingUpdateNode->BlendTime(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CMotionMatchingUpdateNode", "m_flBlendTime", false, value);
}
bool GCMotionMatchingUpdateNode::GetLockClipWhenWaning() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CMotionMatchingUpdateNode->LockClipWhenWaning(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "CMotionMatchingUpdateNode", "m_bLockClipWhenWaning");
}
void GCMotionMatchingUpdateNode::SetLockClipWhenWaning(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CMotionMatchingUpdateNode->LockClipWhenWaning(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CMotionMatchingUpdateNode", "m_bLockClipWhenWaning", false, value);
}
float GCMotionMatchingUpdateNode::GetSelectionThreshold() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CMotionMatchingUpdateNode->SelectionThreshold(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CMotionMatchingUpdateNode", "m_flSelectionThreshold");
}
void GCMotionMatchingUpdateNode::SetSelectionThreshold(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CMotionMatchingUpdateNode->SelectionThreshold(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CMotionMatchingUpdateNode", "m_flSelectionThreshold", false, value);
}
float GCMotionMatchingUpdateNode::GetReselectionTimeWindow() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CMotionMatchingUpdateNode->ReselectionTimeWindow(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CMotionMatchingUpdateNode", "m_flReselectionTimeWindow");
}
void GCMotionMatchingUpdateNode::SetReselectionTimeWindow(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CMotionMatchingUpdateNode->ReselectionTimeWindow(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CMotionMatchingUpdateNode", "m_flReselectionTimeWindow", false, value);
}
bool GCMotionMatchingUpdateNode::GetEnableRotationCorrection() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CMotionMatchingUpdateNode->EnableRotationCorrection(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "CMotionMatchingUpdateNode", "m_bEnableRotationCorrection");
}
void GCMotionMatchingUpdateNode::SetEnableRotationCorrection(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CMotionMatchingUpdateNode->EnableRotationCorrection(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CMotionMatchingUpdateNode", "m_bEnableRotationCorrection", false, value);
}
bool GCMotionMatchingUpdateNode::GetGoalAssist() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CMotionMatchingUpdateNode->GoalAssist(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "CMotionMatchingUpdateNode", "m_bGoalAssist");
}
void GCMotionMatchingUpdateNode::SetGoalAssist(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CMotionMatchingUpdateNode->GoalAssist(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CMotionMatchingUpdateNode", "m_bGoalAssist", false, value);
}
float GCMotionMatchingUpdateNode::GetGoalAssistDistance() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CMotionMatchingUpdateNode->GoalAssistDistance(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CMotionMatchingUpdateNode", "m_flGoalAssistDistance");
}
void GCMotionMatchingUpdateNode::SetGoalAssistDistance(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CMotionMatchingUpdateNode->GoalAssistDistance(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CMotionMatchingUpdateNode", "m_flGoalAssistDistance", false, value);
}
float GCMotionMatchingUpdateNode::GetGoalAssistTolerance() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CMotionMatchingUpdateNode->GoalAssistTolerance(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CMotionMatchingUpdateNode", "m_flGoalAssistTolerance");
}
void GCMotionMatchingUpdateNode::SetGoalAssistTolerance(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CMotionMatchingUpdateNode->GoalAssistTolerance(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CMotionMatchingUpdateNode", "m_flGoalAssistTolerance", false, value);
}
GCAnimInputDamping GCMotionMatchingUpdateNode::GetDistanceScale_Damping() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CMotionMatchingUpdateNode->DistanceScale_Damping(ptr=%p)", m_ptr));
    GCAnimInputDamping value(GetSchemaPtr(m_ptr, "CMotionMatchingUpdateNode", "m_distanceScale_Damping"));
    return value;
}
void GCMotionMatchingUpdateNode::SetDistanceScale_Damping(GCAnimInputDamping value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CMotionMatchingUpdateNode->DistanceScale_Damping(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'DistanceScale_Damping' is not possible.\n");
}
float GCMotionMatchingUpdateNode::GetDistanceScale_OuterRadius() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CMotionMatchingUpdateNode->DistanceScale_OuterRadius(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CMotionMatchingUpdateNode", "m_flDistanceScale_OuterRadius");
}
void GCMotionMatchingUpdateNode::SetDistanceScale_OuterRadius(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CMotionMatchingUpdateNode->DistanceScale_OuterRadius(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CMotionMatchingUpdateNode", "m_flDistanceScale_OuterRadius", false, value);
}
float GCMotionMatchingUpdateNode::GetDistanceScale_InnerRadius() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CMotionMatchingUpdateNode->DistanceScale_InnerRadius(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CMotionMatchingUpdateNode", "m_flDistanceScale_InnerRadius");
}
void GCMotionMatchingUpdateNode::SetDistanceScale_InnerRadius(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CMotionMatchingUpdateNode->DistanceScale_InnerRadius(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CMotionMatchingUpdateNode", "m_flDistanceScale_InnerRadius", false, value);
}
float GCMotionMatchingUpdateNode::GetDistanceScale_MaxScale() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CMotionMatchingUpdateNode->DistanceScale_MaxScale(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CMotionMatchingUpdateNode", "m_flDistanceScale_MaxScale");
}
void GCMotionMatchingUpdateNode::SetDistanceScale_MaxScale(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CMotionMatchingUpdateNode->DistanceScale_MaxScale(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CMotionMatchingUpdateNode", "m_flDistanceScale_MaxScale", false, value);
}
float GCMotionMatchingUpdateNode::GetDistanceScale_MinScale() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CMotionMatchingUpdateNode->DistanceScale_MinScale(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CMotionMatchingUpdateNode", "m_flDistanceScale_MinScale");
}
void GCMotionMatchingUpdateNode::SetDistanceScale_MinScale(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CMotionMatchingUpdateNode->DistanceScale_MinScale(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CMotionMatchingUpdateNode", "m_flDistanceScale_MinScale", false, value);
}
bool GCMotionMatchingUpdateNode::GetEnableDistanceScaling() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CMotionMatchingUpdateNode->EnableDistanceScaling(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "CMotionMatchingUpdateNode", "m_bEnableDistanceScaling");
}
void GCMotionMatchingUpdateNode::SetEnableDistanceScaling(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CMotionMatchingUpdateNode->EnableDistanceScaling(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CMotionMatchingUpdateNode", "m_bEnableDistanceScaling", false, value);
}
void* GCMotionMatchingUpdateNode::GetPtr() {
    return m_ptr;
}
std::string GCMotionMatchingUpdateNode::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCMotionMatchingUpdateNode::IsValid() {
    return (m_ptr != nullptr);
}
GCLeafUpdateNode GCMotionMatchingUpdateNode::GetParent() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CMotionMatchingUpdateNode::GetParent(ptr=%p)", m_ptr));
    GCLeafUpdateNode value(m_ptr);
    return value;
}
void GCMotionMatchingUpdateNode::SetParent(GCLeafUpdateNode value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CMotionMatchingUpdateNode::SetParent(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCMotionMatchingUpdateNode(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCMotionMatchingUpdateNode>("CMotionMatchingUpdateNode")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("DataSet", &GCMotionMatchingUpdateNode::GetDataSet, &GCMotionMatchingUpdateNode::SetDataSet)
        .addProperty("Weights", &GCMotionMatchingUpdateNode::GetWeights, &GCMotionMatchingUpdateNode::SetWeights)
        .addProperty("SearchEveryTick", &GCMotionMatchingUpdateNode::GetSearchEveryTick, &GCMotionMatchingUpdateNode::SetSearchEveryTick)
        .addProperty("SearchInterval", &GCMotionMatchingUpdateNode::GetSearchInterval, &GCMotionMatchingUpdateNode::SetSearchInterval)
        .addProperty("SearchWhenClipEnds", &GCMotionMatchingUpdateNode::GetSearchWhenClipEnds, &GCMotionMatchingUpdateNode::SetSearchWhenClipEnds)
        .addProperty("SearchWhenGoalChanges", &GCMotionMatchingUpdateNode::GetSearchWhenGoalChanges, &GCMotionMatchingUpdateNode::SetSearchWhenGoalChanges)
        .addProperty("BlendCurve", &GCMotionMatchingUpdateNode::GetBlendCurve, &GCMotionMatchingUpdateNode::SetBlendCurve)
        .addProperty("SampleRate", &GCMotionMatchingUpdateNode::GetSampleRate, &GCMotionMatchingUpdateNode::SetSampleRate)
        .addProperty("BlendTime", &GCMotionMatchingUpdateNode::GetBlendTime, &GCMotionMatchingUpdateNode::SetBlendTime)
        .addProperty("LockClipWhenWaning", &GCMotionMatchingUpdateNode::GetLockClipWhenWaning, &GCMotionMatchingUpdateNode::SetLockClipWhenWaning)
        .addProperty("SelectionThreshold", &GCMotionMatchingUpdateNode::GetSelectionThreshold, &GCMotionMatchingUpdateNode::SetSelectionThreshold)
        .addProperty("ReselectionTimeWindow", &GCMotionMatchingUpdateNode::GetReselectionTimeWindow, &GCMotionMatchingUpdateNode::SetReselectionTimeWindow)
        .addProperty("EnableRotationCorrection", &GCMotionMatchingUpdateNode::GetEnableRotationCorrection, &GCMotionMatchingUpdateNode::SetEnableRotationCorrection)
        .addProperty("GoalAssist", &GCMotionMatchingUpdateNode::GetGoalAssist, &GCMotionMatchingUpdateNode::SetGoalAssist)
        .addProperty("GoalAssistDistance", &GCMotionMatchingUpdateNode::GetGoalAssistDistance, &GCMotionMatchingUpdateNode::SetGoalAssistDistance)
        .addProperty("GoalAssistTolerance", &GCMotionMatchingUpdateNode::GetGoalAssistTolerance, &GCMotionMatchingUpdateNode::SetGoalAssistTolerance)
        .addProperty("DistanceScale_Damping", &GCMotionMatchingUpdateNode::GetDistanceScale_Damping, &GCMotionMatchingUpdateNode::SetDistanceScale_Damping)
        .addProperty("DistanceScale_OuterRadius", &GCMotionMatchingUpdateNode::GetDistanceScale_OuterRadius, &GCMotionMatchingUpdateNode::SetDistanceScale_OuterRadius)
        .addProperty("DistanceScale_InnerRadius", &GCMotionMatchingUpdateNode::GetDistanceScale_InnerRadius, &GCMotionMatchingUpdateNode::SetDistanceScale_InnerRadius)
        .addProperty("DistanceScale_MaxScale", &GCMotionMatchingUpdateNode::GetDistanceScale_MaxScale, &GCMotionMatchingUpdateNode::SetDistanceScale_MaxScale)
        .addProperty("DistanceScale_MinScale", &GCMotionMatchingUpdateNode::GetDistanceScale_MinScale, &GCMotionMatchingUpdateNode::SetDistanceScale_MinScale)
        .addProperty("EnableDistanceScaling", &GCMotionMatchingUpdateNode::GetEnableDistanceScaling, &GCMotionMatchingUpdateNode::SetEnableDistanceScaling)
        .addProperty("Parent", &GCMotionMatchingUpdateNode::GetParent, &GCMotionMatchingUpdateNode::SetParent)
        .addFunction("ToPtr", &GCMotionMatchingUpdateNode::ToPtr)
        .addFunction("IsValid", &GCMotionMatchingUpdateNode::IsValid)
        .endClass();
}
GCNmSyncTrack__Event_t::GCNmSyncTrack__Event_t(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCNmSyncTrack__Event_t::GCNmSyncTrack__Event_t(void *ptr) {
    m_ptr = ptr;
}
GNmPercent_t GCNmSyncTrack__Event_t::GetStartTime() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CNmSyncTrack__Event_t->StartTime(ptr=%p)", m_ptr));
    GNmPercent_t value(GetSchemaPtr(m_ptr, "CNmSyncTrack__Event_t", "m_startTime"));
    return value;
}
void GCNmSyncTrack__Event_t::SetStartTime(GNmPercent_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CNmSyncTrack__Event_t->StartTime(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'StartTime' is not possible.\n");
}
GNmPercent_t GCNmSyncTrack__Event_t::GetDuration() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CNmSyncTrack__Event_t->Duration(ptr=%p)", m_ptr));
    GNmPercent_t value(GetSchemaPtr(m_ptr, "CNmSyncTrack__Event_t", "m_duration"));
    return value;
}
void GCNmSyncTrack__Event_t::SetDuration(GNmPercent_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CNmSyncTrack__Event_t->Duration(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Duration' is not possible.\n");
}
void* GCNmSyncTrack__Event_t::GetPtr() {
    return m_ptr;
}
std::string GCNmSyncTrack__Event_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCNmSyncTrack__Event_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCNmSyncTrack__Event_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCNmSyncTrack__Event_t>("CNmSyncTrack__Event_t")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("StartTime", &GCNmSyncTrack__Event_t::GetStartTime, &GCNmSyncTrack__Event_t::SetStartTime)
        .addProperty("Duration", &GCNmSyncTrack__Event_t::GetDuration, &GCNmSyncTrack__Event_t::SetDuration)
        .addFunction("ToPtr", &GCNmSyncTrack__Event_t::ToPtr)
        .addFunction("IsValid", &GCNmSyncTrack__Event_t::IsValid)
        .endClass();
}
GEventSplitScreenStateChanged_t::GEventSplitScreenStateChanged_t(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GEventSplitScreenStateChanged_t::GEventSplitScreenStateChanged_t(void *ptr) {
    m_ptr = ptr;
}
void* GEventSplitScreenStateChanged_t::GetPtr() {
    return m_ptr;
}
std::string GEventSplitScreenStateChanged_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GEventSplitScreenStateChanged_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassEventSplitScreenStateChanged_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GEventSplitScreenStateChanged_t>("EventSplitScreenStateChanged_t")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addFunction("ToPtr", &GEventSplitScreenStateChanged_t::ToPtr)
        .addFunction("IsValid", &GEventSplitScreenStateChanged_t::IsValid)
        .endClass();
}
GParticleNamedValueSource_t::GParticleNamedValueSource_t(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GParticleNamedValueSource_t::GParticleNamedValueSource_t(void *ptr) {
    m_ptr = ptr;
}
std::string GParticleNamedValueSource_t::GetName() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: ParticleNamedValueSource_t->Name(ptr=%p)", m_ptr));
    return GetSchemaValue<CUtlString>(m_ptr, "ParticleNamedValueSource_t", "m_Name").Get();
}
void GParticleNamedValueSource_t::SetName(std::string value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: ParticleNamedValueSource_t->Name(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "ParticleNamedValueSource_t", "m_Name", true, CUtlString(value.c_str()));
}
bool GParticleNamedValueSource_t::GetIsPublic() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: ParticleNamedValueSource_t->IsPublic(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "ParticleNamedValueSource_t", "m_IsPublic");
}
void GParticleNamedValueSource_t::SetIsPublic(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: ParticleNamedValueSource_t->IsPublic(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "ParticleNamedValueSource_t", "m_IsPublic", true, value);
}
uint64_t GParticleNamedValueSource_t::GetValueType() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: ParticleNamedValueSource_t->ValueType(ptr=%p)", m_ptr));
    return GetSchemaValue<uint64_t>(m_ptr, "ParticleNamedValueSource_t", "m_ValueType");
}
void GParticleNamedValueSource_t::SetValueType(uint64_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: ParticleNamedValueSource_t->ValueType(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "ParticleNamedValueSource_t", "m_ValueType", true, value);
}
GParticleNamedValueConfiguration_t GParticleNamedValueSource_t::GetDefaultConfig() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: ParticleNamedValueSource_t->DefaultConfig(ptr=%p)", m_ptr));
    GParticleNamedValueConfiguration_t value(GetSchemaPtr(m_ptr, "ParticleNamedValueSource_t", "m_DefaultConfig"));
    return value;
}
void GParticleNamedValueSource_t::SetDefaultConfig(GParticleNamedValueConfiguration_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: ParticleNamedValueSource_t->DefaultConfig(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'DefaultConfig' is not possible.\n");
}
std::vector<GParticleNamedValueConfiguration_t> GParticleNamedValueSource_t::GetNamedConfigs() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: ParticleNamedValueSource_t->NamedConfigs(ptr=%p)", m_ptr));
    CUtlVector<GParticleNamedValueConfiguration_t>* vec = GetSchemaValue<CUtlVector<GParticleNamedValueConfiguration_t>*>(m_ptr, "ParticleNamedValueSource_t", "m_NamedConfigs"); std::vector<GParticleNamedValueConfiguration_t> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GParticleNamedValueSource_t::SetNamedConfigs(std::vector<GParticleNamedValueConfiguration_t> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: ParticleNamedValueSource_t->NamedConfigs(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<GParticleNamedValueConfiguration_t>(m_ptr, "ParticleNamedValueSource_t", "m_NamedConfigs", true, value);
}
void* GParticleNamedValueSource_t::GetPtr() {
    return m_ptr;
}
std::string GParticleNamedValueSource_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GParticleNamedValueSource_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassParticleNamedValueSource_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GParticleNamedValueSource_t>("ParticleNamedValueSource_t")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Name", &GParticleNamedValueSource_t::GetName, &GParticleNamedValueSource_t::SetName)
        .addProperty("IsPublic", &GParticleNamedValueSource_t::GetIsPublic, &GParticleNamedValueSource_t::SetIsPublic)
        .addProperty("ValueType", &GParticleNamedValueSource_t::GetValueType, &GParticleNamedValueSource_t::SetValueType)
        .addProperty("DefaultConfig", &GParticleNamedValueSource_t::GetDefaultConfig, &GParticleNamedValueSource_t::SetDefaultConfig)
        .addProperty("NamedConfigs", &GParticleNamedValueSource_t::GetNamedConfigs, &GParticleNamedValueSource_t::SetNamedConfigs)
        .addFunction("ToPtr", &GParticleNamedValueSource_t::ToPtr)
        .addFunction("IsValid", &GParticleNamedValueSource_t::IsValid)
        .endClass();
}
GMaterialParamBuffer_t::GMaterialParamBuffer_t(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GMaterialParamBuffer_t::GMaterialParamBuffer_t(void *ptr) {
    m_ptr = ptr;
}
void* GMaterialParamBuffer_t::GetPtr() {
    return m_ptr;
}
std::string GMaterialParamBuffer_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GMaterialParamBuffer_t::IsValid() {
    return (m_ptr != nullptr);
}
GMaterialParam_t GMaterialParamBuffer_t::GetParent() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("MaterialParamBuffer_t::GetParent(ptr=%p)", m_ptr));
    GMaterialParam_t value(m_ptr);
    return value;
}
void GMaterialParamBuffer_t::SetParent(GMaterialParam_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("MaterialParamBuffer_t::SetParent(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassMaterialParamBuffer_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GMaterialParamBuffer_t>("MaterialParamBuffer_t")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Parent", &GMaterialParamBuffer_t::GetParent, &GMaterialParamBuffer_t::SetParent)
        .addFunction("ToPtr", &GMaterialParamBuffer_t::ToPtr)
        .addFunction("IsValid", &GMaterialParamBuffer_t::IsValid)
        .endClass();
}
GEventPostDataUpdate_t::GEventPostDataUpdate_t(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GEventPostDataUpdate_t::GEventPostDataUpdate_t(void *ptr) {
    m_ptr = ptr;
}
int32_t GEventPostDataUpdate_t::GetCount() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: EventPostDataUpdate_t->Count(ptr=%p)", m_ptr));
    return GetSchemaValue<int32_t>(m_ptr, "EventPostDataUpdate_t", "m_nCount");
}
void GEventPostDataUpdate_t::SetCount(int32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: EventPostDataUpdate_t->Count(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "EventPostDataUpdate_t", "m_nCount", true, value);
}
void* GEventPostDataUpdate_t::GetPtr() {
    return m_ptr;
}
std::string GEventPostDataUpdate_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GEventPostDataUpdate_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassEventPostDataUpdate_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GEventPostDataUpdate_t>("EventPostDataUpdate_t")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Count", &GEventPostDataUpdate_t::GetCount, &GEventPostDataUpdate_t::SetCount)
        .addFunction("ToPtr", &GEventPostDataUpdate_t::ToPtr)
        .addFunction("IsValid", &GEventPostDataUpdate_t::IsValid)
        .endClass();
}
GRenderProjectedMaterial_t::GRenderProjectedMaterial_t(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GRenderProjectedMaterial_t::GRenderProjectedMaterial_t(void *ptr) {
    m_ptr = ptr;
}
void* GRenderProjectedMaterial_t::GetPtr() {
    return m_ptr;
}
std::string GRenderProjectedMaterial_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GRenderProjectedMaterial_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassRenderProjectedMaterial_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GRenderProjectedMaterial_t>("RenderProjectedMaterial_t")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addFunction("ToPtr", &GRenderProjectedMaterial_t::ToPtr)
        .addFunction("IsValid", &GRenderProjectedMaterial_t::IsValid)
        .endClass();
}
GCSSDSMsg_ViewTargetList::GCSSDSMsg_ViewTargetList(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCSSDSMsg_ViewTargetList::GCSSDSMsg_ViewTargetList(void *ptr) {
    m_ptr = ptr;
}
GSceneViewId_t GCSSDSMsg_ViewTargetList::GetViewId() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CSSDSMsg_ViewTargetList->ViewId(ptr=%p)", m_ptr));
    GSceneViewId_t value(GetSchemaPtr(m_ptr, "CSSDSMsg_ViewTargetList", "m_viewId"));
    return value;
}
void GCSSDSMsg_ViewTargetList::SetViewId(GSceneViewId_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CSSDSMsg_ViewTargetList->ViewId(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'ViewId' is not possible.\n");
}
std::string GCSSDSMsg_ViewTargetList::GetViewName() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CSSDSMsg_ViewTargetList->ViewName(ptr=%p)", m_ptr));
    return GetSchemaValue<CUtlString>(m_ptr, "CSSDSMsg_ViewTargetList", "m_ViewName").Get();
}
void GCSSDSMsg_ViewTargetList::SetViewName(std::string value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CSSDSMsg_ViewTargetList->ViewName(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CSSDSMsg_ViewTargetList", "m_ViewName", false, CUtlString(value.c_str()));
}
std::vector<GCSSDSMsg_ViewTarget> GCSSDSMsg_ViewTargetList::GetTargets() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CSSDSMsg_ViewTargetList->Targets(ptr=%p)", m_ptr));
    CUtlVector<GCSSDSMsg_ViewTarget>* vec = GetSchemaValue<CUtlVector<GCSSDSMsg_ViewTarget>*>(m_ptr, "CSSDSMsg_ViewTargetList", "m_Targets"); std::vector<GCSSDSMsg_ViewTarget> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCSSDSMsg_ViewTargetList::SetTargets(std::vector<GCSSDSMsg_ViewTarget> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CSSDSMsg_ViewTargetList->Targets(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<GCSSDSMsg_ViewTarget>(m_ptr, "CSSDSMsg_ViewTargetList", "m_Targets", false, value);
}
void* GCSSDSMsg_ViewTargetList::GetPtr() {
    return m_ptr;
}
std::string GCSSDSMsg_ViewTargetList::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCSSDSMsg_ViewTargetList::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCSSDSMsg_ViewTargetList(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCSSDSMsg_ViewTargetList>("CSSDSMsg_ViewTargetList")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("ViewId", &GCSSDSMsg_ViewTargetList::GetViewId, &GCSSDSMsg_ViewTargetList::SetViewId)
        .addProperty("ViewName", &GCSSDSMsg_ViewTargetList::GetViewName, &GCSSDSMsg_ViewTargetList::SetViewName)
        .addProperty("Targets", &GCSSDSMsg_ViewTargetList::GetTargets, &GCSSDSMsg_ViewTargetList::SetTargets)
        .addFunction("ToPtr", &GCSSDSMsg_ViewTargetList::ToPtr)
        .addFunction("IsValid", &GCSSDSMsg_ViewTargetList::IsValid)
        .endClass();
}
GFeSimdAnimStrayRadius_t::GFeSimdAnimStrayRadius_t(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GFeSimdAnimStrayRadius_t::GFeSimdAnimStrayRadius_t(void *ptr) {
    m_ptr = ptr;
}
float GFeSimdAnimStrayRadius_t::GetMaxDist() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FeSimdAnimStrayRadius_t->MaxDist(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "FeSimdAnimStrayRadius_t", "flMaxDist");
}
void GFeSimdAnimStrayRadius_t::SetMaxDist(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FeSimdAnimStrayRadius_t->MaxDist(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "FeSimdAnimStrayRadius_t", "flMaxDist", true, value);
}
float GFeSimdAnimStrayRadius_t::GetRelaxationFactor() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FeSimdAnimStrayRadius_t->RelaxationFactor(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "FeSimdAnimStrayRadius_t", "flRelaxationFactor");
}
void GFeSimdAnimStrayRadius_t::SetRelaxationFactor(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FeSimdAnimStrayRadius_t->RelaxationFactor(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "FeSimdAnimStrayRadius_t", "flRelaxationFactor", true, value);
}
void* GFeSimdAnimStrayRadius_t::GetPtr() {
    return m_ptr;
}
std::string GFeSimdAnimStrayRadius_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GFeSimdAnimStrayRadius_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassFeSimdAnimStrayRadius_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GFeSimdAnimStrayRadius_t>("FeSimdAnimStrayRadius_t")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("MaxDist", &GFeSimdAnimStrayRadius_t::GetMaxDist, &GFeSimdAnimStrayRadius_t::SetMaxDist)
        .addProperty("RelaxationFactor", &GFeSimdAnimStrayRadius_t::GetRelaxationFactor, &GFeSimdAnimStrayRadius_t::SetRelaxationFactor)
        .addFunction("ToPtr", &GFeSimdAnimStrayRadius_t::ToPtr)
        .addFunction("IsValid", &GFeSimdAnimStrayRadius_t::IsValid)
        .endClass();
}
GCAnimUser::GCAnimUser(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCAnimUser::GCAnimUser(void *ptr) {
    m_ptr = ptr;
}
int32_t GCAnimUser::GetType() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CAnimUser->Type(ptr=%p)", m_ptr));
    return GetSchemaValue<int32_t>(m_ptr, "CAnimUser", "m_nType");
}
void GCAnimUser::SetType(int32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CAnimUser->Type(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CAnimUser", "m_nType", false, value);
}
void* GCAnimUser::GetPtr() {
    return m_ptr;
}
std::string GCAnimUser::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCAnimUser::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCAnimUser(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCAnimUser>("CAnimUser")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Type", &GCAnimUser::GetType, &GCAnimUser::SetType)
        .addFunction("ToPtr", &GCAnimUser::ToPtr)
        .addFunction("IsValid", &GCAnimUser::IsValid)
        .endClass();
}
GFeSpringIntegrator_t::GFeSpringIntegrator_t(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GFeSpringIntegrator_t::GFeSpringIntegrator_t(void *ptr) {
    m_ptr = ptr;
}
std::vector<uint16_t> GFeSpringIntegrator_t::GetNode() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FeSpringIntegrator_t->Node(ptr=%p,size=2)", m_ptr));
    uint16_t* outValue = (uint16_t*)GetSchemaPtr(m_ptr, "FeSpringIntegrator_t", "nNode"); std::vector<uint16_t> ret; for(int i = 0; i < 2; i++) { ret.push_back(outValue[i]); } return ret;
}
void GFeSpringIntegrator_t::SetNode(std::vector<uint16_t> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FeSpringIntegrator_t->Node(ptr=%p,size=2)", m_ptr));
    if(value.size() != 2) return PLUGIN_PRINT("Schema SDK", "Field 'Node' needs to have 2 values.\n");
    auto val = GetSchemaValuePtr<uint16_t>(m_ptr, "FeSpringIntegrator_t", "nNode");
    for(size_t i = 0; i < value.size(); i++) val[i] = value[i];
}
float GFeSpringIntegrator_t::GetSpringRestLength() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FeSpringIntegrator_t->SpringRestLength(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "FeSpringIntegrator_t", "flSpringRestLength");
}
void GFeSpringIntegrator_t::SetSpringRestLength(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FeSpringIntegrator_t->SpringRestLength(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "FeSpringIntegrator_t", "flSpringRestLength", true, value);
}
float GFeSpringIntegrator_t::GetSpringConstant() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FeSpringIntegrator_t->SpringConstant(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "FeSpringIntegrator_t", "flSpringConstant");
}
void GFeSpringIntegrator_t::SetSpringConstant(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FeSpringIntegrator_t->SpringConstant(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "FeSpringIntegrator_t", "flSpringConstant", true, value);
}
float GFeSpringIntegrator_t::GetSpringDamping() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FeSpringIntegrator_t->SpringDamping(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "FeSpringIntegrator_t", "flSpringDamping");
}
void GFeSpringIntegrator_t::SetSpringDamping(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FeSpringIntegrator_t->SpringDamping(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "FeSpringIntegrator_t", "flSpringDamping", true, value);
}
float GFeSpringIntegrator_t::GetNodeWeight0() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FeSpringIntegrator_t->NodeWeight0(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "FeSpringIntegrator_t", "flNodeWeight0");
}
void GFeSpringIntegrator_t::SetNodeWeight0(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FeSpringIntegrator_t->NodeWeight0(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "FeSpringIntegrator_t", "flNodeWeight0", true, value);
}
void* GFeSpringIntegrator_t::GetPtr() {
    return m_ptr;
}
std::string GFeSpringIntegrator_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GFeSpringIntegrator_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassFeSpringIntegrator_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GFeSpringIntegrator_t>("FeSpringIntegrator_t")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Node", &GFeSpringIntegrator_t::GetNode, &GFeSpringIntegrator_t::SetNode)
        .addProperty("SpringRestLength", &GFeSpringIntegrator_t::GetSpringRestLength, &GFeSpringIntegrator_t::SetSpringRestLength)
        .addProperty("SpringConstant", &GFeSpringIntegrator_t::GetSpringConstant, &GFeSpringIntegrator_t::SetSpringConstant)
        .addProperty("SpringDamping", &GFeSpringIntegrator_t::GetSpringDamping, &GFeSpringIntegrator_t::SetSpringDamping)
        .addProperty("NodeWeight0", &GFeSpringIntegrator_t::GetNodeWeight0, &GFeSpringIntegrator_t::SetNodeWeight0)
        .addFunction("ToPtr", &GFeSpringIntegrator_t::ToPtr)
        .addFunction("IsValid", &GFeSpringIntegrator_t::IsValid)
        .endClass();
}
GCModelConfigElement_UserPick::GCModelConfigElement_UserPick(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCModelConfigElement_UserPick::GCModelConfigElement_UserPick(void *ptr) {
    m_ptr = ptr;
}
std::vector<CUtlString> GCModelConfigElement_UserPick::GetChoices() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CModelConfigElement_UserPick->Choices(ptr=%p)", m_ptr));
    CUtlVector<CUtlString>* vec = GetSchemaValue<CUtlVector<CUtlString>*>(m_ptr, "CModelConfigElement_UserPick", "m_Choices"); std::vector<CUtlString> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCModelConfigElement_UserPick::SetChoices(std::vector<CUtlString> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CModelConfigElement_UserPick->Choices(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<CUtlString>(m_ptr, "CModelConfigElement_UserPick", "m_Choices", false, value);
}
void* GCModelConfigElement_UserPick::GetPtr() {
    return m_ptr;
}
std::string GCModelConfigElement_UserPick::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCModelConfigElement_UserPick::IsValid() {
    return (m_ptr != nullptr);
}
GCModelConfigElement GCModelConfigElement_UserPick::GetParent() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CModelConfigElement_UserPick::GetParent(ptr=%p)", m_ptr));
    GCModelConfigElement value(m_ptr);
    return value;
}
void GCModelConfigElement_UserPick::SetParent(GCModelConfigElement value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CModelConfigElement_UserPick::SetParent(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCModelConfigElement_UserPick(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCModelConfigElement_UserPick>("CModelConfigElement_UserPick")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Choices", &GCModelConfigElement_UserPick::GetChoices, &GCModelConfigElement_UserPick::SetChoices)
        .addProperty("Parent", &GCModelConfigElement_UserPick::GetParent, &GCModelConfigElement_UserPick::SetParent)
        .addFunction("ToPtr", &GCModelConfigElement_UserPick::ToPtr)
        .addFunction("IsValid", &GCModelConfigElement_UserPick::IsValid)
        .endClass();
}
GRenderSkeletonBone_t::GRenderSkeletonBone_t(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GRenderSkeletonBone_t::GRenderSkeletonBone_t(void *ptr) {
    m_ptr = ptr;
}
std::string GRenderSkeletonBone_t::GetBoneName() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: RenderSkeletonBone_t->BoneName(ptr=%p)", m_ptr));
    return GetSchemaValue<CUtlString>(m_ptr, "RenderSkeletonBone_t", "m_boneName").Get();
}
void GRenderSkeletonBone_t::SetBoneName(std::string value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: RenderSkeletonBone_t->BoneName(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "RenderSkeletonBone_t", "m_boneName", true, CUtlString(value.c_str()));
}
std::string GRenderSkeletonBone_t::GetParentName() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: RenderSkeletonBone_t->ParentName(ptr=%p)", m_ptr));
    return GetSchemaValue<CUtlString>(m_ptr, "RenderSkeletonBone_t", "m_parentName").Get();
}
void GRenderSkeletonBone_t::SetParentName(std::string value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: RenderSkeletonBone_t->ParentName(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "RenderSkeletonBone_t", "m_parentName", true, CUtlString(value.c_str()));
}
GSkeletonBoneBounds_t GRenderSkeletonBone_t::GetBbox() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: RenderSkeletonBone_t->Bbox(ptr=%p)", m_ptr));
    GSkeletonBoneBounds_t value(GetSchemaPtr(m_ptr, "RenderSkeletonBone_t", "m_bbox"));
    return value;
}
void GRenderSkeletonBone_t::SetBbox(GSkeletonBoneBounds_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: RenderSkeletonBone_t->Bbox(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Bbox' is not possible.\n");
}
float GRenderSkeletonBone_t::GetSphereRadius() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: RenderSkeletonBone_t->SphereRadius(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "RenderSkeletonBone_t", "m_flSphereRadius");
}
void GRenderSkeletonBone_t::SetSphereRadius(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: RenderSkeletonBone_t->SphereRadius(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "RenderSkeletonBone_t", "m_flSphereRadius", true, value);
}
void* GRenderSkeletonBone_t::GetPtr() {
    return m_ptr;
}
std::string GRenderSkeletonBone_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GRenderSkeletonBone_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassRenderSkeletonBone_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GRenderSkeletonBone_t>("RenderSkeletonBone_t")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("BoneName", &GRenderSkeletonBone_t::GetBoneName, &GRenderSkeletonBone_t::SetBoneName)
        .addProperty("ParentName", &GRenderSkeletonBone_t::GetParentName, &GRenderSkeletonBone_t::SetParentName)
        .addProperty("Bbox", &GRenderSkeletonBone_t::GetBbox, &GRenderSkeletonBone_t::SetBbox)
        .addProperty("SphereRadius", &GRenderSkeletonBone_t::GetSphereRadius, &GRenderSkeletonBone_t::SetSphereRadius)
        .addFunction("ToPtr", &GRenderSkeletonBone_t::ToPtr)
        .addFunction("IsValid", &GRenderSkeletonBone_t::IsValid)
        .endClass();
}
GAnimationDecodeDebugDump_t::GAnimationDecodeDebugDump_t(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GAnimationDecodeDebugDump_t::GAnimationDecodeDebugDump_t(void *ptr) {
    m_ptr = ptr;
}
uint64_t GAnimationDecodeDebugDump_t::GetProcessingType() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: AnimationDecodeDebugDump_t->ProcessingType(ptr=%p)", m_ptr));
    return GetSchemaValue<uint64_t>(m_ptr, "AnimationDecodeDebugDump_t", "m_processingType");
}
void GAnimationDecodeDebugDump_t::SetProcessingType(uint64_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: AnimationDecodeDebugDump_t->ProcessingType(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "AnimationDecodeDebugDump_t", "m_processingType", true, value);
}
std::vector<GAnimationDecodeDebugDumpElement_t> GAnimationDecodeDebugDump_t::GetElems() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: AnimationDecodeDebugDump_t->Elems(ptr=%p)", m_ptr));
    CUtlVector<GAnimationDecodeDebugDumpElement_t>* vec = GetSchemaValue<CUtlVector<GAnimationDecodeDebugDumpElement_t>*>(m_ptr, "AnimationDecodeDebugDump_t", "m_elems"); std::vector<GAnimationDecodeDebugDumpElement_t> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GAnimationDecodeDebugDump_t::SetElems(std::vector<GAnimationDecodeDebugDumpElement_t> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: AnimationDecodeDebugDump_t->Elems(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<GAnimationDecodeDebugDumpElement_t>(m_ptr, "AnimationDecodeDebugDump_t", "m_elems", true, value);
}
void* GAnimationDecodeDebugDump_t::GetPtr() {
    return m_ptr;
}
std::string GAnimationDecodeDebugDump_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GAnimationDecodeDebugDump_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassAnimationDecodeDebugDump_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GAnimationDecodeDebugDump_t>("AnimationDecodeDebugDump_t")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("ProcessingType", &GAnimationDecodeDebugDump_t::GetProcessingType, &GAnimationDecodeDebugDump_t::SetProcessingType)
        .addProperty("Elems", &GAnimationDecodeDebugDump_t::GetElems, &GAnimationDecodeDebugDump_t::SetElems)
        .addFunction("ToPtr", &GAnimationDecodeDebugDump_t::ToPtr)
        .addFunction("IsValid", &GAnimationDecodeDebugDump_t::IsValid)
        .endClass();
}
GPARTICLE_EHANDLE__::GPARTICLE_EHANDLE__(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GPARTICLE_EHANDLE__::GPARTICLE_EHANDLE__(void *ptr) {
    m_ptr = ptr;
}
int32_t GPARTICLE_EHANDLE__::GetUnused() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: PARTICLE_EHANDLE__->Unused(ptr=%p)", m_ptr));
    return GetSchemaValue<int32_t>(m_ptr, "PARTICLE_EHANDLE__", "unused");
}
void GPARTICLE_EHANDLE__::SetUnused(int32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: PARTICLE_EHANDLE__->Unused(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "PARTICLE_EHANDLE__", "unused", false, value);
}
void* GPARTICLE_EHANDLE__::GetPtr() {
    return m_ptr;
}
std::string GPARTICLE_EHANDLE__::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GPARTICLE_EHANDLE__::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassPARTICLE_EHANDLE__(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GPARTICLE_EHANDLE__>("PARTICLE_EHANDLE__")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Unused", &GPARTICLE_EHANDLE__::GetUnused, &GPARTICLE_EHANDLE__::SetUnused)
        .addFunction("ToPtr", &GPARTICLE_EHANDLE__::ToPtr)
        .addFunction("IsValid", &GPARTICLE_EHANDLE__::IsValid)
        .endClass();
}
GFeCollisionPlane_t::GFeCollisionPlane_t(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GFeCollisionPlane_t::GFeCollisionPlane_t(void *ptr) {
    m_ptr = ptr;
}
uint16_t GFeCollisionPlane_t::GetCtrlParent() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FeCollisionPlane_t->CtrlParent(ptr=%p)", m_ptr));
    return GetSchemaValue<uint16_t>(m_ptr, "FeCollisionPlane_t", "nCtrlParent");
}
void GFeCollisionPlane_t::SetCtrlParent(uint16_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FeCollisionPlane_t->CtrlParent(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "FeCollisionPlane_t", "nCtrlParent", true, value);
}
uint16_t GFeCollisionPlane_t::GetChildNode() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FeCollisionPlane_t->ChildNode(ptr=%p)", m_ptr));
    return GetSchemaValue<uint16_t>(m_ptr, "FeCollisionPlane_t", "nChildNode");
}
void GFeCollisionPlane_t::SetChildNode(uint16_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FeCollisionPlane_t->ChildNode(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "FeCollisionPlane_t", "nChildNode", true, value);
}
GRnPlane_t GFeCollisionPlane_t::GetPlane() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FeCollisionPlane_t->Plane(ptr=%p)", m_ptr));
    GRnPlane_t value(GetSchemaPtr(m_ptr, "FeCollisionPlane_t", "m_Plane"));
    return value;
}
void GFeCollisionPlane_t::SetPlane(GRnPlane_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FeCollisionPlane_t->Plane(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Plane' is not possible.\n");
}
float GFeCollisionPlane_t::GetStrength() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FeCollisionPlane_t->Strength(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "FeCollisionPlane_t", "flStrength");
}
void GFeCollisionPlane_t::SetStrength(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FeCollisionPlane_t->Strength(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "FeCollisionPlane_t", "flStrength", true, value);
}
void* GFeCollisionPlane_t::GetPtr() {
    return m_ptr;
}
std::string GFeCollisionPlane_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GFeCollisionPlane_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassFeCollisionPlane_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GFeCollisionPlane_t>("FeCollisionPlane_t")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("CtrlParent", &GFeCollisionPlane_t::GetCtrlParent, &GFeCollisionPlane_t::SetCtrlParent)
        .addProperty("ChildNode", &GFeCollisionPlane_t::GetChildNode, &GFeCollisionPlane_t::SetChildNode)
        .addProperty("Plane", &GFeCollisionPlane_t::GetPlane, &GFeCollisionPlane_t::SetPlane)
        .addProperty("Strength", &GFeCollisionPlane_t::GetStrength, &GFeCollisionPlane_t::SetStrength)
        .addFunction("ToPtr", &GFeCollisionPlane_t::ToPtr)
        .addFunction("IsValid", &GFeCollisionPlane_t::IsValid)
        .endClass();
}
GCAnimCycle::GCAnimCycle(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCAnimCycle::GCAnimCycle(void *ptr) {
    m_ptr = ptr;
}
void* GCAnimCycle::GetPtr() {
    return m_ptr;
}
std::string GCAnimCycle::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCAnimCycle::IsValid() {
    return (m_ptr != nullptr);
}
GCCycleBase GCAnimCycle::GetParent() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CAnimCycle::GetParent(ptr=%p)", m_ptr));
    GCCycleBase value(m_ptr);
    return value;
}
void GCAnimCycle::SetParent(GCCycleBase value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CAnimCycle::SetParent(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCAnimCycle(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCAnimCycle>("CAnimCycle")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Parent", &GCAnimCycle::GetParent, &GCAnimCycle::SetParent)
        .addFunction("ToPtr", &GCAnimCycle::ToPtr)
        .addFunction("IsValid", &GCAnimCycle::IsValid)
        .endClass();
}
GCNmSyncTrack__EventMarker_t::GCNmSyncTrack__EventMarker_t(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCNmSyncTrack__EventMarker_t::GCNmSyncTrack__EventMarker_t(void *ptr) {
    m_ptr = ptr;
}
GNmPercent_t GCNmSyncTrack__EventMarker_t::GetStartTime() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CNmSyncTrack__EventMarker_t->StartTime(ptr=%p)", m_ptr));
    GNmPercent_t value(GetSchemaPtr(m_ptr, "CNmSyncTrack__EventMarker_t", "m_startTime"));
    return value;
}
void GCNmSyncTrack__EventMarker_t::SetStartTime(GNmPercent_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CNmSyncTrack__EventMarker_t->StartTime(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'StartTime' is not possible.\n");
}
void* GCNmSyncTrack__EventMarker_t::GetPtr() {
    return m_ptr;
}
std::string GCNmSyncTrack__EventMarker_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCNmSyncTrack__EventMarker_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCNmSyncTrack__EventMarker_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCNmSyncTrack__EventMarker_t>("CNmSyncTrack__EventMarker_t")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("StartTime", &GCNmSyncTrack__EventMarker_t::GetStartTime, &GCNmSyncTrack__EventMarker_t::SetStartTime)
        .addFunction("ToPtr", &GCNmSyncTrack__EventMarker_t::ToPtr)
        .addFunction("IsValid", &GCNmSyncTrack__EventMarker_t::IsValid)
        .endClass();
}
GCAnimGraphSettingsManager::GCAnimGraphSettingsManager(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCAnimGraphSettingsManager::GCAnimGraphSettingsManager(void *ptr) {
    m_ptr = ptr;
}
void* GCAnimGraphSettingsManager::GetPtr() {
    return m_ptr;
}
std::string GCAnimGraphSettingsManager::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCAnimGraphSettingsManager::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCAnimGraphSettingsManager(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCAnimGraphSettingsManager>("CAnimGraphSettingsManager")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addFunction("ToPtr", &GCAnimGraphSettingsManager::ToPtr)
        .addFunction("IsValid", &GCAnimGraphSettingsManager::IsValid)
        .endClass();
}
GCRagdollUpdateNode::GCRagdollUpdateNode(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCRagdollUpdateNode::GCRagdollUpdateNode(void *ptr) {
    m_ptr = ptr;
}
int32_t GCRagdollUpdateNode::GetWeightListIndex() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CRagdollUpdateNode->WeightListIndex(ptr=%p)", m_ptr));
    return GetSchemaValue<int32_t>(m_ptr, "CRagdollUpdateNode", "m_nWeightListIndex");
}
void GCRagdollUpdateNode::SetWeightListIndex(int32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CRagdollUpdateNode->WeightListIndex(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CRagdollUpdateNode", "m_nWeightListIndex", false, value);
}
uint64_t GCRagdollUpdateNode::GetPoseControlMethod() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CRagdollUpdateNode->PoseControlMethod(ptr=%p)", m_ptr));
    return GetSchemaValue<uint64_t>(m_ptr, "CRagdollUpdateNode", "m_poseControlMethod");
}
void GCRagdollUpdateNode::SetPoseControlMethod(uint64_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CRagdollUpdateNode->PoseControlMethod(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CRagdollUpdateNode", "m_poseControlMethod", false, value);
}
void* GCRagdollUpdateNode::GetPtr() {
    return m_ptr;
}
std::string GCRagdollUpdateNode::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCRagdollUpdateNode::IsValid() {
    return (m_ptr != nullptr);
}
GCUnaryUpdateNode GCRagdollUpdateNode::GetParent() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CRagdollUpdateNode::GetParent(ptr=%p)", m_ptr));
    GCUnaryUpdateNode value(m_ptr);
    return value;
}
void GCRagdollUpdateNode::SetParent(GCUnaryUpdateNode value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CRagdollUpdateNode::SetParent(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCRagdollUpdateNode(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCRagdollUpdateNode>("CRagdollUpdateNode")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("WeightListIndex", &GCRagdollUpdateNode::GetWeightListIndex, &GCRagdollUpdateNode::SetWeightListIndex)
        .addProperty("PoseControlMethod", &GCRagdollUpdateNode::GetPoseControlMethod, &GCRagdollUpdateNode::SetPoseControlMethod)
        .addProperty("Parent", &GCRagdollUpdateNode::GetParent, &GCRagdollUpdateNode::SetParent)
        .addFunction("ToPtr", &GCRagdollUpdateNode::ToPtr)
        .addFunction("IsValid", &GCRagdollUpdateNode::IsValid)
        .endClass();
}
GCEntityComponentHelper::GCEntityComponentHelper(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCEntityComponentHelper::GCEntityComponentHelper(void *ptr) {
    m_ptr = ptr;
}
uint32_t GCEntityComponentHelper::GetFlags() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CEntityComponentHelper->Flags(ptr=%p)", m_ptr));
    return GetSchemaValue<uint32_t>(m_ptr, "CEntityComponentHelper", "m_flags");
}
void GCEntityComponentHelper::SetFlags(uint32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CEntityComponentHelper->Flags(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CEntityComponentHelper", "m_flags", false, value);
}
GEntComponentInfo_t GCEntityComponentHelper::GetInfo() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CEntityComponentHelper->Info(ptr=%p)", m_ptr));
    GEntComponentInfo_t value(*(void**)GetSchemaPtr(m_ptr, "CEntityComponentHelper", "m_pInfo"));
    return value;
}
void GCEntityComponentHelper::SetInfo(GEntComponentInfo_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CEntityComponentHelper->Info(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CEntityComponentHelper","m_pInfo", false, (char*)value.GetPtr());
}
int32_t GCEntityComponentHelper::GetPriority() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CEntityComponentHelper->Priority(ptr=%p)", m_ptr));
    return GetSchemaValue<int32_t>(m_ptr, "CEntityComponentHelper", "m_nPriority");
}
void GCEntityComponentHelper::SetPriority(int32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CEntityComponentHelper->Priority(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CEntityComponentHelper", "m_nPriority", false, value);
}
GCEntityComponentHelper GCEntityComponentHelper::GetNext() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CEntityComponentHelper->Next(ptr=%p)", m_ptr));
    GCEntityComponentHelper value(*(void**)GetSchemaPtr(m_ptr, "CEntityComponentHelper", "m_pNext"));
    return value;
}
void GCEntityComponentHelper::SetNext(GCEntityComponentHelper value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CEntityComponentHelper->Next(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CEntityComponentHelper","m_pNext", false, (char*)value.GetPtr());
}
void* GCEntityComponentHelper::GetPtr() {
    return m_ptr;
}
std::string GCEntityComponentHelper::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCEntityComponentHelper::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCEntityComponentHelper(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCEntityComponentHelper>("CEntityComponentHelper")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Flags", &GCEntityComponentHelper::GetFlags, &GCEntityComponentHelper::SetFlags)
        .addProperty("Info", &GCEntityComponentHelper::GetInfo, &GCEntityComponentHelper::SetInfo)
        .addProperty("Priority", &GCEntityComponentHelper::GetPriority, &GCEntityComponentHelper::SetPriority)
        .addProperty("Next", &GCEntityComponentHelper::GetNext, &GCEntityComponentHelper::SetNext)
        .addFunction("ToPtr", &GCEntityComponentHelper::ToPtr)
        .addFunction("IsValid", &GCEntityComponentHelper::IsValid)
        .endClass();
}
GCompositeMaterial_t::GCompositeMaterial_t(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCompositeMaterial_t::GCompositeMaterial_t(void *ptr) {
    m_ptr = ptr;
}
std::vector<GGeneratedTextureHandle_t> GCompositeMaterial_t::GetGeneratedTextures() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CompositeMaterial_t->GeneratedTextures(ptr=%p)", m_ptr));
    CUtlVector<GGeneratedTextureHandle_t>* vec = GetSchemaValue<CUtlVector<GGeneratedTextureHandle_t>*>(m_ptr, "CompositeMaterial_t", "m_vecGeneratedTextures"); std::vector<GGeneratedTextureHandle_t> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCompositeMaterial_t::SetGeneratedTextures(std::vector<GGeneratedTextureHandle_t> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CompositeMaterial_t->GeneratedTextures(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<GGeneratedTextureHandle_t>(m_ptr, "CompositeMaterial_t", "m_vecGeneratedTextures", true, value);
}
void* GCompositeMaterial_t::GetPtr() {
    return m_ptr;
}
std::string GCompositeMaterial_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCompositeMaterial_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCompositeMaterial_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCompositeMaterial_t>("CompositeMaterial_t")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("GeneratedTextures", &GCompositeMaterial_t::GetGeneratedTextures, &GCompositeMaterial_t::SetGeneratedTextures)
        .addFunction("ToPtr", &GCompositeMaterial_t::ToPtr)
        .addFunction("IsValid", &GCompositeMaterial_t::IsValid)
        .endClass();
}
GSignatureOutflow_Continue::GSignatureOutflow_Continue(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GSignatureOutflow_Continue::GSignatureOutflow_Continue(void *ptr) {
    m_ptr = ptr;
}
void* GSignatureOutflow_Continue::GetPtr() {
    return m_ptr;
}
std::string GSignatureOutflow_Continue::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GSignatureOutflow_Continue::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassSignatureOutflow_Continue(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GSignatureOutflow_Continue>("SignatureOutflow_Continue")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addFunction("ToPtr", &GSignatureOutflow_Continue::ToPtr)
        .addFunction("IsValid", &GSignatureOutflow_Continue::IsValid)
        .endClass();
}
GWeightList::GWeightList(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GWeightList::GWeightList(void *ptr) {
    m_ptr = ptr;
}
std::string GWeightList::GetName() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: WeightList->Name(ptr=%p)", m_ptr));
    return GetSchemaValue<CUtlString>(m_ptr, "WeightList", "m_name").Get();
}
void GWeightList::SetName(std::string value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: WeightList->Name(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "WeightList", "m_name", false, CUtlString(value.c_str()));
}
std::vector<float32> GWeightList::GetWeights() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: WeightList->Weights(ptr=%p)", m_ptr));
    CUtlVector<float32>* vec = GetSchemaValue<CUtlVector<float32>*>(m_ptr, "WeightList", "m_weights"); std::vector<float32> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GWeightList::SetWeights(std::vector<float32> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: WeightList->Weights(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<float32>(m_ptr, "WeightList", "m_weights", false, value);
}
void* GWeightList::GetPtr() {
    return m_ptr;
}
std::string GWeightList::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GWeightList::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassWeightList(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GWeightList>("WeightList")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Name", &GWeightList::GetName, &GWeightList::SetName)
        .addProperty("Weights", &GWeightList::GetWeights, &GWeightList::SetWeights)
        .addFunction("ToPtr", &GWeightList::ToPtr)
        .addFunction("IsValid", &GWeightList::IsValid)
        .endClass();
}
GRnBodyDesc_t::GRnBodyDesc_t(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GRnBodyDesc_t::GRnBodyDesc_t(void *ptr) {
    m_ptr = ptr;
}
std::string GRnBodyDesc_t::GetDebugName() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: RnBodyDesc_t->DebugName(ptr=%p)", m_ptr));
    return GetSchemaValue<CUtlString>(m_ptr, "RnBodyDesc_t", "m_sDebugName").Get();
}
void GRnBodyDesc_t::SetDebugName(std::string value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: RnBodyDesc_t->DebugName(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "RnBodyDesc_t", "m_sDebugName", true, CUtlString(value.c_str()));
}
Vector GRnBodyDesc_t::GetPosition() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: RnBodyDesc_t->Position(ptr=%p)", m_ptr));
    return GetSchemaValue<Vector>(m_ptr, "RnBodyDesc_t", "m_vPosition");
}
void GRnBodyDesc_t::SetPosition(Vector value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: RnBodyDesc_t->Position(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "RnBodyDesc_t", "m_vPosition", true, value);
}
Vector GRnBodyDesc_t::GetLinearVelocity() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: RnBodyDesc_t->LinearVelocity(ptr=%p)", m_ptr));
    return GetSchemaValue<Vector>(m_ptr, "RnBodyDesc_t", "m_vLinearVelocity");
}
void GRnBodyDesc_t::SetLinearVelocity(Vector value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: RnBodyDesc_t->LinearVelocity(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "RnBodyDesc_t", "m_vLinearVelocity", true, value);
}
Vector GRnBodyDesc_t::GetAngularVelocity() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: RnBodyDesc_t->AngularVelocity(ptr=%p)", m_ptr));
    return GetSchemaValue<Vector>(m_ptr, "RnBodyDesc_t", "m_vAngularVelocity");
}
void GRnBodyDesc_t::SetAngularVelocity(Vector value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: RnBodyDesc_t->AngularVelocity(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "RnBodyDesc_t", "m_vAngularVelocity", true, value);
}
Vector GRnBodyDesc_t::GetLocalMassCenter() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: RnBodyDesc_t->LocalMassCenter(ptr=%p)", m_ptr));
    return GetSchemaValue<Vector>(m_ptr, "RnBodyDesc_t", "m_vLocalMassCenter");
}
void GRnBodyDesc_t::SetLocalMassCenter(Vector value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: RnBodyDesc_t->LocalMassCenter(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "RnBodyDesc_t", "m_vLocalMassCenter", true, value);
}
std::vector<Vector> GRnBodyDesc_t::GetLocalInertiaInv() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: RnBodyDesc_t->LocalInertiaInv(ptr=%p,size=3)", m_ptr));
    Vector* outValue = (Vector*)GetSchemaPtr(m_ptr, "RnBodyDesc_t", "m_LocalInertiaInv"); std::vector<Vector> ret; for(int i = 0; i < 3; i++) { ret.push_back(outValue[i]); } return ret;
}
void GRnBodyDesc_t::SetLocalInertiaInv(std::vector<Vector> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: RnBodyDesc_t->LocalInertiaInv(ptr=%p,size=3)", m_ptr));
    if(value.size() != 3) return PLUGIN_PRINT("Schema SDK", "Field 'LocalInertiaInv' needs to have 3 values.\n");
    auto val = GetSchemaValuePtr<Vector>(m_ptr, "RnBodyDesc_t", "m_LocalInertiaInv");
    for(size_t i = 0; i < value.size(); i++) val[i] = value[i];
}
float GRnBodyDesc_t::GetMassInv() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: RnBodyDesc_t->MassInv(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "RnBodyDesc_t", "m_flMassInv");
}
void GRnBodyDesc_t::SetMassInv(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: RnBodyDesc_t->MassInv(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "RnBodyDesc_t", "m_flMassInv", true, value);
}
float GRnBodyDesc_t::GetGameMass() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: RnBodyDesc_t->GameMass(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "RnBodyDesc_t", "m_flGameMass");
}
void GRnBodyDesc_t::SetGameMass(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: RnBodyDesc_t->GameMass(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "RnBodyDesc_t", "m_flGameMass", true, value);
}
float GRnBodyDesc_t::GetInertiaScaleInv() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: RnBodyDesc_t->InertiaScaleInv(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "RnBodyDesc_t", "m_flInertiaScaleInv");
}
void GRnBodyDesc_t::SetInertiaScaleInv(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: RnBodyDesc_t->InertiaScaleInv(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "RnBodyDesc_t", "m_flInertiaScaleInv", true, value);
}
float GRnBodyDesc_t::GetLinearDamping() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: RnBodyDesc_t->LinearDamping(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "RnBodyDesc_t", "m_flLinearDamping");
}
void GRnBodyDesc_t::SetLinearDamping(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: RnBodyDesc_t->LinearDamping(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "RnBodyDesc_t", "m_flLinearDamping", true, value);
}
float GRnBodyDesc_t::GetAngularDamping() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: RnBodyDesc_t->AngularDamping(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "RnBodyDesc_t", "m_flAngularDamping");
}
void GRnBodyDesc_t::SetAngularDamping(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: RnBodyDesc_t->AngularDamping(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "RnBodyDesc_t", "m_flAngularDamping", true, value);
}
float GRnBodyDesc_t::GetLinearDrag() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: RnBodyDesc_t->LinearDrag(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "RnBodyDesc_t", "m_flLinearDrag");
}
void GRnBodyDesc_t::SetLinearDrag(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: RnBodyDesc_t->LinearDrag(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "RnBodyDesc_t", "m_flLinearDrag", true, value);
}
float GRnBodyDesc_t::GetAngularDrag() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: RnBodyDesc_t->AngularDrag(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "RnBodyDesc_t", "m_flAngularDrag");
}
void GRnBodyDesc_t::SetAngularDrag(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: RnBodyDesc_t->AngularDrag(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "RnBodyDesc_t", "m_flAngularDrag", true, value);
}
float GRnBodyDesc_t::GetLinearBuoyancyDrag() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: RnBodyDesc_t->LinearBuoyancyDrag(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "RnBodyDesc_t", "m_flLinearBuoyancyDrag");
}
void GRnBodyDesc_t::SetLinearBuoyancyDrag(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: RnBodyDesc_t->LinearBuoyancyDrag(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "RnBodyDesc_t", "m_flLinearBuoyancyDrag", true, value);
}
float GRnBodyDesc_t::GetAngularBuoyancyDrag() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: RnBodyDesc_t->AngularBuoyancyDrag(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "RnBodyDesc_t", "m_flAngularBuoyancyDrag");
}
void GRnBodyDesc_t::SetAngularBuoyancyDrag(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: RnBodyDesc_t->AngularBuoyancyDrag(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "RnBodyDesc_t", "m_flAngularBuoyancyDrag", true, value);
}
Vector GRnBodyDesc_t::GetLastAwakeForceAccum() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: RnBodyDesc_t->LastAwakeForceAccum(ptr=%p)", m_ptr));
    return GetSchemaValue<Vector>(m_ptr, "RnBodyDesc_t", "m_vLastAwakeForceAccum");
}
void GRnBodyDesc_t::SetLastAwakeForceAccum(Vector value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: RnBodyDesc_t->LastAwakeForceAccum(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "RnBodyDesc_t", "m_vLastAwakeForceAccum", true, value);
}
Vector GRnBodyDesc_t::GetLastAwakeTorqueAccum() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: RnBodyDesc_t->LastAwakeTorqueAccum(ptr=%p)", m_ptr));
    return GetSchemaValue<Vector>(m_ptr, "RnBodyDesc_t", "m_vLastAwakeTorqueAccum");
}
void GRnBodyDesc_t::SetLastAwakeTorqueAccum(Vector value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: RnBodyDesc_t->LastAwakeTorqueAccum(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "RnBodyDesc_t", "m_vLastAwakeTorqueAccum", true, value);
}
float GRnBodyDesc_t::GetBuoyancyFactor() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: RnBodyDesc_t->BuoyancyFactor(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "RnBodyDesc_t", "m_flBuoyancyFactor");
}
void GRnBodyDesc_t::SetBuoyancyFactor(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: RnBodyDesc_t->BuoyancyFactor(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "RnBodyDesc_t", "m_flBuoyancyFactor", true, value);
}
float GRnBodyDesc_t::GetGravityScale() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: RnBodyDesc_t->GravityScale(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "RnBodyDesc_t", "m_flGravityScale");
}
void GRnBodyDesc_t::SetGravityScale(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: RnBodyDesc_t->GravityScale(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "RnBodyDesc_t", "m_flGravityScale", true, value);
}
float GRnBodyDesc_t::GetTimeScale() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: RnBodyDesc_t->TimeScale(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "RnBodyDesc_t", "m_flTimeScale");
}
void GRnBodyDesc_t::SetTimeScale(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: RnBodyDesc_t->TimeScale(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "RnBodyDesc_t", "m_flTimeScale", true, value);
}
int32_t GRnBodyDesc_t::GetBodyType() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: RnBodyDesc_t->BodyType(ptr=%p)", m_ptr));
    return GetSchemaValue<int32_t>(m_ptr, "RnBodyDesc_t", "m_nBodyType");
}
void GRnBodyDesc_t::SetBodyType(int32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: RnBodyDesc_t->BodyType(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "RnBodyDesc_t", "m_nBodyType", true, value);
}
uint32_t GRnBodyDesc_t::GetGameIndex() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: RnBodyDesc_t->GameIndex(ptr=%p)", m_ptr));
    return GetSchemaValue<uint32_t>(m_ptr, "RnBodyDesc_t", "m_nGameIndex");
}
void GRnBodyDesc_t::SetGameIndex(uint32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: RnBodyDesc_t->GameIndex(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "RnBodyDesc_t", "m_nGameIndex", true, value);
}
uint32_t GRnBodyDesc_t::GetGameFlags() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: RnBodyDesc_t->GameFlags(ptr=%p)", m_ptr));
    return GetSchemaValue<uint32_t>(m_ptr, "RnBodyDesc_t", "m_nGameFlags");
}
void GRnBodyDesc_t::SetGameFlags(uint32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: RnBodyDesc_t->GameFlags(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "RnBodyDesc_t", "m_nGameFlags", true, value);
}
int32_t GRnBodyDesc_t::GetMinVelocityIterations() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: RnBodyDesc_t->MinVelocityIterations(ptr=%p)", m_ptr));
    return GetSchemaValue<int32_t>(m_ptr, "RnBodyDesc_t", "m_nMinVelocityIterations");
}
void GRnBodyDesc_t::SetMinVelocityIterations(int32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: RnBodyDesc_t->MinVelocityIterations(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "RnBodyDesc_t", "m_nMinVelocityIterations", true, value);
}
int32_t GRnBodyDesc_t::GetMinPositionIterations() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: RnBodyDesc_t->MinPositionIterations(ptr=%p)", m_ptr));
    return GetSchemaValue<int32_t>(m_ptr, "RnBodyDesc_t", "m_nMinPositionIterations");
}
void GRnBodyDesc_t::SetMinPositionIterations(int32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: RnBodyDesc_t->MinPositionIterations(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "RnBodyDesc_t", "m_nMinPositionIterations", true, value);
}
int32_t GRnBodyDesc_t::GetMassPriority() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: RnBodyDesc_t->MassPriority(ptr=%p)", m_ptr));
    return GetSchemaValue<int32_t>(m_ptr, "RnBodyDesc_t", "m_nMassPriority");
}
void GRnBodyDesc_t::SetMassPriority(int32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: RnBodyDesc_t->MassPriority(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "RnBodyDesc_t", "m_nMassPriority", true, value);
}
bool GRnBodyDesc_t::GetEnabled() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: RnBodyDesc_t->Enabled(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "RnBodyDesc_t", "m_bEnabled");
}
void GRnBodyDesc_t::SetEnabled(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: RnBodyDesc_t->Enabled(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "RnBodyDesc_t", "m_bEnabled", true, value);
}
bool GRnBodyDesc_t::GetSleeping() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: RnBodyDesc_t->Sleeping(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "RnBodyDesc_t", "m_bSleeping");
}
void GRnBodyDesc_t::SetSleeping(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: RnBodyDesc_t->Sleeping(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "RnBodyDesc_t", "m_bSleeping", true, value);
}
bool GRnBodyDesc_t::GetIsContinuousEnabled() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: RnBodyDesc_t->IsContinuousEnabled(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "RnBodyDesc_t", "m_bIsContinuousEnabled");
}
void GRnBodyDesc_t::SetIsContinuousEnabled(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: RnBodyDesc_t->IsContinuousEnabled(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "RnBodyDesc_t", "m_bIsContinuousEnabled", true, value);
}
bool GRnBodyDesc_t::GetDragEnabled() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: RnBodyDesc_t->DragEnabled(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "RnBodyDesc_t", "m_bDragEnabled");
}
void GRnBodyDesc_t::SetDragEnabled(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: RnBodyDesc_t->DragEnabled(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "RnBodyDesc_t", "m_bDragEnabled", true, value);
}
bool GRnBodyDesc_t::GetBuoyancyDragEnabled() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: RnBodyDesc_t->BuoyancyDragEnabled(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "RnBodyDesc_t", "m_bBuoyancyDragEnabled");
}
void GRnBodyDesc_t::SetBuoyancyDragEnabled(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: RnBodyDesc_t->BuoyancyDragEnabled(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "RnBodyDesc_t", "m_bBuoyancyDragEnabled", true, value);
}
bool GRnBodyDesc_t::GetGravityDisabled() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: RnBodyDesc_t->GravityDisabled(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "RnBodyDesc_t", "m_bGravityDisabled");
}
void GRnBodyDesc_t::SetGravityDisabled(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: RnBodyDesc_t->GravityDisabled(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "RnBodyDesc_t", "m_bGravityDisabled", true, value);
}
bool GRnBodyDesc_t::GetSpeculativeEnabled() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: RnBodyDesc_t->SpeculativeEnabled(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "RnBodyDesc_t", "m_bSpeculativeEnabled");
}
void GRnBodyDesc_t::SetSpeculativeEnabled(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: RnBodyDesc_t->SpeculativeEnabled(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "RnBodyDesc_t", "m_bSpeculativeEnabled", true, value);
}
bool GRnBodyDesc_t::GetHasShadowController() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: RnBodyDesc_t->HasShadowController(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "RnBodyDesc_t", "m_bHasShadowController");
}
void GRnBodyDesc_t::SetHasShadowController(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: RnBodyDesc_t->HasShadowController(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "RnBodyDesc_t", "m_bHasShadowController", true, value);
}
void* GRnBodyDesc_t::GetPtr() {
    return m_ptr;
}
std::string GRnBodyDesc_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GRnBodyDesc_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassRnBodyDesc_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GRnBodyDesc_t>("RnBodyDesc_t")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("DebugName", &GRnBodyDesc_t::GetDebugName, &GRnBodyDesc_t::SetDebugName)
        .addProperty("Position", &GRnBodyDesc_t::GetPosition, &GRnBodyDesc_t::SetPosition)
        .addProperty("LinearVelocity", &GRnBodyDesc_t::GetLinearVelocity, &GRnBodyDesc_t::SetLinearVelocity)
        .addProperty("AngularVelocity", &GRnBodyDesc_t::GetAngularVelocity, &GRnBodyDesc_t::SetAngularVelocity)
        .addProperty("LocalMassCenter", &GRnBodyDesc_t::GetLocalMassCenter, &GRnBodyDesc_t::SetLocalMassCenter)
        .addProperty("LocalInertiaInv", &GRnBodyDesc_t::GetLocalInertiaInv, &GRnBodyDesc_t::SetLocalInertiaInv)
        .addProperty("MassInv", &GRnBodyDesc_t::GetMassInv, &GRnBodyDesc_t::SetMassInv)
        .addProperty("GameMass", &GRnBodyDesc_t::GetGameMass, &GRnBodyDesc_t::SetGameMass)
        .addProperty("InertiaScaleInv", &GRnBodyDesc_t::GetInertiaScaleInv, &GRnBodyDesc_t::SetInertiaScaleInv)
        .addProperty("LinearDamping", &GRnBodyDesc_t::GetLinearDamping, &GRnBodyDesc_t::SetLinearDamping)
        .addProperty("AngularDamping", &GRnBodyDesc_t::GetAngularDamping, &GRnBodyDesc_t::SetAngularDamping)
        .addProperty("LinearDrag", &GRnBodyDesc_t::GetLinearDrag, &GRnBodyDesc_t::SetLinearDrag)
        .addProperty("AngularDrag", &GRnBodyDesc_t::GetAngularDrag, &GRnBodyDesc_t::SetAngularDrag)
        .addProperty("LinearBuoyancyDrag", &GRnBodyDesc_t::GetLinearBuoyancyDrag, &GRnBodyDesc_t::SetLinearBuoyancyDrag)
        .addProperty("AngularBuoyancyDrag", &GRnBodyDesc_t::GetAngularBuoyancyDrag, &GRnBodyDesc_t::SetAngularBuoyancyDrag)
        .addProperty("LastAwakeForceAccum", &GRnBodyDesc_t::GetLastAwakeForceAccum, &GRnBodyDesc_t::SetLastAwakeForceAccum)
        .addProperty("LastAwakeTorqueAccum", &GRnBodyDesc_t::GetLastAwakeTorqueAccum, &GRnBodyDesc_t::SetLastAwakeTorqueAccum)
        .addProperty("BuoyancyFactor", &GRnBodyDesc_t::GetBuoyancyFactor, &GRnBodyDesc_t::SetBuoyancyFactor)
        .addProperty("GravityScale", &GRnBodyDesc_t::GetGravityScale, &GRnBodyDesc_t::SetGravityScale)
        .addProperty("TimeScale", &GRnBodyDesc_t::GetTimeScale, &GRnBodyDesc_t::SetTimeScale)
        .addProperty("BodyType", &GRnBodyDesc_t::GetBodyType, &GRnBodyDesc_t::SetBodyType)
        .addProperty("GameIndex", &GRnBodyDesc_t::GetGameIndex, &GRnBodyDesc_t::SetGameIndex)
        .addProperty("GameFlags", &GRnBodyDesc_t::GetGameFlags, &GRnBodyDesc_t::SetGameFlags)
        .addProperty("MinVelocityIterations", &GRnBodyDesc_t::GetMinVelocityIterations, &GRnBodyDesc_t::SetMinVelocityIterations)
        .addProperty("MinPositionIterations", &GRnBodyDesc_t::GetMinPositionIterations, &GRnBodyDesc_t::SetMinPositionIterations)
        .addProperty("MassPriority", &GRnBodyDesc_t::GetMassPriority, &GRnBodyDesc_t::SetMassPriority)
        .addProperty("Enabled", &GRnBodyDesc_t::GetEnabled, &GRnBodyDesc_t::SetEnabled)
        .addProperty("Sleeping", &GRnBodyDesc_t::GetSleeping, &GRnBodyDesc_t::SetSleeping)
        .addProperty("IsContinuousEnabled", &GRnBodyDesc_t::GetIsContinuousEnabled, &GRnBodyDesc_t::SetIsContinuousEnabled)
        .addProperty("DragEnabled", &GRnBodyDesc_t::GetDragEnabled, &GRnBodyDesc_t::SetDragEnabled)
        .addProperty("BuoyancyDragEnabled", &GRnBodyDesc_t::GetBuoyancyDragEnabled, &GRnBodyDesc_t::SetBuoyancyDragEnabled)
        .addProperty("GravityDisabled", &GRnBodyDesc_t::GetGravityDisabled, &GRnBodyDesc_t::SetGravityDisabled)
        .addProperty("SpeculativeEnabled", &GRnBodyDesc_t::GetSpeculativeEnabled, &GRnBodyDesc_t::SetSpeculativeEnabled)
        .addProperty("HasShadowController", &GRnBodyDesc_t::GetHasShadowController, &GRnBodyDesc_t::SetHasShadowController)
        .addFunction("ToPtr", &GRnBodyDesc_t::ToPtr)
        .addFunction("IsValid", &GRnBodyDesc_t::IsValid)
        .endClass();
}
GCFeMorphLayer::GCFeMorphLayer(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCFeMorphLayer::GCFeMorphLayer(void *ptr) {
    m_ptr = ptr;
}
std::string GCFeMorphLayer::GetName() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CFeMorphLayer->Name(ptr=%p)", m_ptr));
    return GetSchemaValue<CUtlString>(m_ptr, "CFeMorphLayer", "m_Name").Get();
}
void GCFeMorphLayer::SetName(std::string value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CFeMorphLayer->Name(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CFeMorphLayer", "m_Name", false, CUtlString(value.c_str()));
}
uint32_t GCFeMorphLayer::GetNameHash() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CFeMorphLayer->NameHash(ptr=%p)", m_ptr));
    return GetSchemaValue<uint32_t>(m_ptr, "CFeMorphLayer", "m_nNameHash");
}
void GCFeMorphLayer::SetNameHash(uint32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CFeMorphLayer->NameHash(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CFeMorphLayer", "m_nNameHash", false, value);
}
std::vector<uint16> GCFeMorphLayer::GetNodes() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CFeMorphLayer->Nodes(ptr=%p)", m_ptr));
    CUtlVector<uint16>* vec = GetSchemaValue<CUtlVector<uint16>*>(m_ptr, "CFeMorphLayer", "m_Nodes"); std::vector<uint16> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCFeMorphLayer::SetNodes(std::vector<uint16> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CFeMorphLayer->Nodes(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<uint16>(m_ptr, "CFeMorphLayer", "m_Nodes", false, value);
}
std::vector<Vector> GCFeMorphLayer::GetInitPos() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CFeMorphLayer->InitPos(ptr=%p)", m_ptr));
    CUtlVector<Vector>* vec = GetSchemaValue<CUtlVector<Vector>*>(m_ptr, "CFeMorphLayer", "m_InitPos"); std::vector<Vector> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCFeMorphLayer::SetInitPos(std::vector<Vector> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CFeMorphLayer->InitPos(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<Vector>(m_ptr, "CFeMorphLayer", "m_InitPos", false, value);
}
std::vector<float32> GCFeMorphLayer::GetGravity() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CFeMorphLayer->Gravity(ptr=%p)", m_ptr));
    CUtlVector<float32>* vec = GetSchemaValue<CUtlVector<float32>*>(m_ptr, "CFeMorphLayer", "m_Gravity"); std::vector<float32> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCFeMorphLayer::SetGravity(std::vector<float32> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CFeMorphLayer->Gravity(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<float32>(m_ptr, "CFeMorphLayer", "m_Gravity", false, value);
}
std::vector<float32> GCFeMorphLayer::GetGoalStrength() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CFeMorphLayer->GoalStrength(ptr=%p)", m_ptr));
    CUtlVector<float32>* vec = GetSchemaValue<CUtlVector<float32>*>(m_ptr, "CFeMorphLayer", "m_GoalStrength"); std::vector<float32> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCFeMorphLayer::SetGoalStrength(std::vector<float32> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CFeMorphLayer->GoalStrength(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<float32>(m_ptr, "CFeMorphLayer", "m_GoalStrength", false, value);
}
std::vector<float32> GCFeMorphLayer::GetGoalDamping() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CFeMorphLayer->GoalDamping(ptr=%p)", m_ptr));
    CUtlVector<float32>* vec = GetSchemaValue<CUtlVector<float32>*>(m_ptr, "CFeMorphLayer", "m_GoalDamping"); std::vector<float32> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCFeMorphLayer::SetGoalDamping(std::vector<float32> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CFeMorphLayer->GoalDamping(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<float32>(m_ptr, "CFeMorphLayer", "m_GoalDamping", false, value);
}
void* GCFeMorphLayer::GetPtr() {
    return m_ptr;
}
std::string GCFeMorphLayer::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCFeMorphLayer::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCFeMorphLayer(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCFeMorphLayer>("CFeMorphLayer")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Name", &GCFeMorphLayer::GetName, &GCFeMorphLayer::SetName)
        .addProperty("NameHash", &GCFeMorphLayer::GetNameHash, &GCFeMorphLayer::SetNameHash)
        .addProperty("Nodes", &GCFeMorphLayer::GetNodes, &GCFeMorphLayer::SetNodes)
        .addProperty("InitPos", &GCFeMorphLayer::GetInitPos, &GCFeMorphLayer::SetInitPos)
        .addProperty("Gravity", &GCFeMorphLayer::GetGravity, &GCFeMorphLayer::SetGravity)
        .addProperty("GoalStrength", &GCFeMorphLayer::GetGoalStrength, &GCFeMorphLayer::SetGoalStrength)
        .addProperty("GoalDamping", &GCFeMorphLayer::GetGoalDamping, &GCFeMorphLayer::SetGoalDamping)
        .addFunction("ToPtr", &GCFeMorphLayer::ToPtr)
        .addFunction("IsValid", &GCFeMorphLayer::IsValid)
        .endClass();
}
GAnimNodeOutputID::GAnimNodeOutputID(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GAnimNodeOutputID::GAnimNodeOutputID(void *ptr) {
    m_ptr = ptr;
}
uint32_t GAnimNodeOutputID::GetId() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: AnimNodeOutputID->Id(ptr=%p)", m_ptr));
    return GetSchemaValue<uint32_t>(m_ptr, "AnimNodeOutputID", "m_id");
}
void GAnimNodeOutputID::SetId(uint32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: AnimNodeOutputID->Id(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "AnimNodeOutputID", "m_id", false, value);
}
void* GAnimNodeOutputID::GetPtr() {
    return m_ptr;
}
std::string GAnimNodeOutputID::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GAnimNodeOutputID::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassAnimNodeOutputID(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GAnimNodeOutputID>("AnimNodeOutputID")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Id", &GAnimNodeOutputID::GetId, &GAnimNodeOutputID::SetId)
        .addFunction("ToPtr", &GAnimNodeOutputID::ToPtr)
        .addFunction("IsValid", &GAnimNodeOutputID::IsValid)
        .endClass();
}
GEventClientSceneSystemThreadStateChange_t::GEventClientSceneSystemThreadStateChange_t(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GEventClientSceneSystemThreadStateChange_t::GEventClientSceneSystemThreadStateChange_t(void *ptr) {
    m_ptr = ptr;
}
bool GEventClientSceneSystemThreadStateChange_t::GetThreadsActive() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: EventClientSceneSystemThreadStateChange_t->ThreadsActive(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "EventClientSceneSystemThreadStateChange_t", "m_bThreadsActive");
}
void GEventClientSceneSystemThreadStateChange_t::SetThreadsActive(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: EventClientSceneSystemThreadStateChange_t->ThreadsActive(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "EventClientSceneSystemThreadStateChange_t", "m_bThreadsActive", true, value);
}
void* GEventClientSceneSystemThreadStateChange_t::GetPtr() {
    return m_ptr;
}
std::string GEventClientSceneSystemThreadStateChange_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GEventClientSceneSystemThreadStateChange_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassEventClientSceneSystemThreadStateChange_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GEventClientSceneSystemThreadStateChange_t>("EventClientSceneSystemThreadStateChange_t")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("ThreadsActive", &GEventClientSceneSystemThreadStateChange_t::GetThreadsActive, &GEventClientSceneSystemThreadStateChange_t::SetThreadsActive)
        .addFunction("ToPtr", &GEventClientSceneSystemThreadStateChange_t::ToPtr)
        .addFunction("IsValid", &GEventClientSceneSystemThreadStateChange_t::IsValid)
        .endClass();
}
GEventClientPreSimulate_t::GEventClientPreSimulate_t(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GEventClientPreSimulate_t::GEventClientPreSimulate_t(void *ptr) {
    m_ptr = ptr;
}
void* GEventClientPreSimulate_t::GetPtr() {
    return m_ptr;
}
std::string GEventClientPreSimulate_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GEventClientPreSimulate_t::IsValid() {
    return (m_ptr != nullptr);
}
GEventSimulate_t GEventClientPreSimulate_t::GetParent() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("EventClientPreSimulate_t::GetParent(ptr=%p)", m_ptr));
    GEventSimulate_t value(m_ptr);
    return value;
}
void GEventClientPreSimulate_t::SetParent(GEventSimulate_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("EventClientPreSimulate_t::SetParent(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassEventClientPreSimulate_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GEventClientPreSimulate_t>("EventClientPreSimulate_t")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Parent", &GEventClientPreSimulate_t::GetParent, &GEventClientPreSimulate_t::SetParent)
        .addFunction("ToPtr", &GEventClientPreSimulate_t::ToPtr)
        .addFunction("IsValid", &GEventClientPreSimulate_t::IsValid)
        .endClass();
}
GClutterSceneObject_t::GClutterSceneObject_t(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GClutterSceneObject_t::GClutterSceneObject_t(void *ptr) {
    m_ptr = ptr;
}
GAABB_t GClutterSceneObject_t::GetBounds() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: ClutterSceneObject_t->Bounds(ptr=%p)", m_ptr));
    GAABB_t value(GetSchemaPtr(m_ptr, "ClutterSceneObject_t", "m_Bounds"));
    return value;
}
void GClutterSceneObject_t::SetBounds(GAABB_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: ClutterSceneObject_t->Bounds(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Bounds' is not possible.\n");
}
uint64_t GClutterSceneObject_t::GetFlags() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: ClutterSceneObject_t->Flags(ptr=%p)", m_ptr));
    return GetSchemaValue<uint64_t>(m_ptr, "ClutterSceneObject_t", "m_flags");
}
void GClutterSceneObject_t::SetFlags(uint64_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: ClutterSceneObject_t->Flags(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "ClutterSceneObject_t", "m_flags", true, value);
}
int16_t GClutterSceneObject_t::GetLayer() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: ClutterSceneObject_t->Layer(ptr=%p)", m_ptr));
    return GetSchemaValue<int16_t>(m_ptr, "ClutterSceneObject_t", "m_nLayer");
}
void GClutterSceneObject_t::SetLayer(int16_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: ClutterSceneObject_t->Layer(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "ClutterSceneObject_t", "m_nLayer", true, value);
}
std::vector<Vector> GClutterSceneObject_t::GetInstancePositions() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: ClutterSceneObject_t->InstancePositions(ptr=%p)", m_ptr));
    CUtlVector<Vector>* vec = GetSchemaValue<CUtlVector<Vector>*>(m_ptr, "ClutterSceneObject_t", "m_instancePositions"); std::vector<Vector> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GClutterSceneObject_t::SetInstancePositions(std::vector<Vector> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: ClutterSceneObject_t->InstancePositions(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<Vector>(m_ptr, "ClutterSceneObject_t", "m_instancePositions", true, value);
}
std::vector<float32> GClutterSceneObject_t::GetInstanceScales() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: ClutterSceneObject_t->InstanceScales(ptr=%p)", m_ptr));
    CUtlVector<float32>* vec = GetSchemaValue<CUtlVector<float32>*>(m_ptr, "ClutterSceneObject_t", "m_instanceScales"); std::vector<float32> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GClutterSceneObject_t::SetInstanceScales(std::vector<float32> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: ClutterSceneObject_t->InstanceScales(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<float32>(m_ptr, "ClutterSceneObject_t", "m_instanceScales", true, value);
}
std::vector<Color> GClutterSceneObject_t::GetInstanceTintSrgb() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: ClutterSceneObject_t->InstanceTintSrgb(ptr=%p)", m_ptr));
    CUtlVector<Color>* vec = GetSchemaValue<CUtlVector<Color>*>(m_ptr, "ClutterSceneObject_t", "m_instanceTintSrgb"); std::vector<Color> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GClutterSceneObject_t::SetInstanceTintSrgb(std::vector<Color> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: ClutterSceneObject_t->InstanceTintSrgb(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<Color>(m_ptr, "ClutterSceneObject_t", "m_instanceTintSrgb", true, value);
}
std::vector<GClutterTile_t> GClutterSceneObject_t::GetTiles() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: ClutterSceneObject_t->Tiles(ptr=%p)", m_ptr));
    CUtlVector<GClutterTile_t>* vec = GetSchemaValue<CUtlVector<GClutterTile_t>*>(m_ptr, "ClutterSceneObject_t", "m_tiles"); std::vector<GClutterTile_t> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GClutterSceneObject_t::SetTiles(std::vector<GClutterTile_t> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: ClutterSceneObject_t->Tiles(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<GClutterTile_t>(m_ptr, "ClutterSceneObject_t", "m_tiles", true, value);
}
void* GClutterSceneObject_t::GetPtr() {
    return m_ptr;
}
std::string GClutterSceneObject_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GClutterSceneObject_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassClutterSceneObject_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GClutterSceneObject_t>("ClutterSceneObject_t")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Bounds", &GClutterSceneObject_t::GetBounds, &GClutterSceneObject_t::SetBounds)
        .addProperty("Flags", &GClutterSceneObject_t::GetFlags, &GClutterSceneObject_t::SetFlags)
        .addProperty("Layer", &GClutterSceneObject_t::GetLayer, &GClutterSceneObject_t::SetLayer)
        .addProperty("InstancePositions", &GClutterSceneObject_t::GetInstancePositions, &GClutterSceneObject_t::SetInstancePositions)
        .addProperty("InstanceScales", &GClutterSceneObject_t::GetInstanceScales, &GClutterSceneObject_t::SetInstanceScales)
        .addProperty("InstanceTintSrgb", &GClutterSceneObject_t::GetInstanceTintSrgb, &GClutterSceneObject_t::SetInstanceTintSrgb)
        .addProperty("Tiles", &GClutterSceneObject_t::GetTiles, &GClutterSceneObject_t::SetTiles)
        .addFunction("ToPtr", &GClutterSceneObject_t::ToPtr)
        .addFunction("IsValid", &GClutterSceneObject_t::IsValid)
        .endClass();
}
GCPoseHandle::GCPoseHandle(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCPoseHandle::GCPoseHandle(void *ptr) {
    m_ptr = ptr;
}
uint16_t GCPoseHandle::GetIndex() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CPoseHandle->Index(ptr=%p)", m_ptr));
    return GetSchemaValue<uint16_t>(m_ptr, "CPoseHandle", "m_nIndex");
}
void GCPoseHandle::SetIndex(uint16_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CPoseHandle->Index(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CPoseHandle", "m_nIndex", false, value);
}
uint64_t GCPoseHandle::GetType() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CPoseHandle->Type(ptr=%p)", m_ptr));
    return GetSchemaValue<uint64_t>(m_ptr, "CPoseHandle", "m_eType");
}
void GCPoseHandle::SetType(uint64_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CPoseHandle->Type(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CPoseHandle", "m_eType", false, value);
}
void* GCPoseHandle::GetPtr() {
    return m_ptr;
}
std::string GCPoseHandle::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCPoseHandle::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCPoseHandle(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCPoseHandle>("CPoseHandle")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Index", &GCPoseHandle::GetIndex, &GCPoseHandle::SetIndex)
        .addProperty("Type", &GCPoseHandle::GetType, &GCPoseHandle::SetType)
        .addFunction("ToPtr", &GCPoseHandle::ToPtr)
        .addFunction("IsValid", &GCPoseHandle::IsValid)
        .endClass();
}
GCAnimScriptBase::GCAnimScriptBase(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCAnimScriptBase::GCAnimScriptBase(void *ptr) {
    m_ptr = ptr;
}
bool GCAnimScriptBase::GetIsValid() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CAnimScriptBase->IsValid(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "CAnimScriptBase", "m_bIsValid");
}
void GCAnimScriptBase::SetIsValid(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CAnimScriptBase->IsValid(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CAnimScriptBase", "m_bIsValid", false, value);
}
void* GCAnimScriptBase::GetPtr() {
    return m_ptr;
}
std::string GCAnimScriptBase::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCAnimScriptBase::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCAnimScriptBase(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCAnimScriptBase>("CAnimScriptBase")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("IsValid", &GCAnimScriptBase::GetIsValid, &GCAnimScriptBase::SetIsValid)
        .addFunction("ToPtr", &GCAnimScriptBase::ToPtr)
        .addFunction("IsValid", &GCAnimScriptBase::IsValid)
        .endClass();
}
GCVoiceContainerBlender::GCVoiceContainerBlender(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCVoiceContainerBlender::GCVoiceContainerBlender(void *ptr) {
    m_ptr = ptr;
}
float GCVoiceContainerBlender::GetBlendFactor() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CVoiceContainerBlender->BlendFactor(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CVoiceContainerBlender", "m_flBlendFactor");
}
void GCVoiceContainerBlender::SetBlendFactor(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CVoiceContainerBlender->BlendFactor(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CVoiceContainerBlender", "m_flBlendFactor", false, value);
}
void* GCVoiceContainerBlender::GetPtr() {
    return m_ptr;
}
std::string GCVoiceContainerBlender::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCVoiceContainerBlender::IsValid() {
    return (m_ptr != nullptr);
}
GCVoiceContainerBase GCVoiceContainerBlender::GetParent() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CVoiceContainerBlender::GetParent(ptr=%p)", m_ptr));
    GCVoiceContainerBase value(m_ptr);
    return value;
}
void GCVoiceContainerBlender::SetParent(GCVoiceContainerBase value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CVoiceContainerBlender::SetParent(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCVoiceContainerBlender(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCVoiceContainerBlender>("CVoiceContainerBlender")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("BlendFactor", &GCVoiceContainerBlender::GetBlendFactor, &GCVoiceContainerBlender::SetBlendFactor)
        .addProperty("Parent", &GCVoiceContainerBlender::GetParent, &GCVoiceContainerBlender::SetParent)
        .addFunction("ToPtr", &GCVoiceContainerBlender::ToPtr)
        .addFunction("IsValid", &GCVoiceContainerBlender::IsValid)
        .endClass();
}
Gvphysics_save_cphysicsbody_t::Gvphysics_save_cphysicsbody_t(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
Gvphysics_save_cphysicsbody_t::Gvphysics_save_cphysicsbody_t(void *ptr) {
    m_ptr = ptr;
}
uint64_t Gvphysics_save_cphysicsbody_t::GetOldPointer() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: vphysics_save_cphysicsbody_t->OldPointer(ptr=%p)", m_ptr));
    return GetSchemaValue<uint64_t>(m_ptr, "vphysics_save_cphysicsbody_t", "m_nOldPointer");
}
void Gvphysics_save_cphysicsbody_t::SetOldPointer(uint64_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: vphysics_save_cphysicsbody_t->OldPointer(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "vphysics_save_cphysicsbody_t", "m_nOldPointer", true, value);
}
void* Gvphysics_save_cphysicsbody_t::GetPtr() {
    return m_ptr;
}
std::string Gvphysics_save_cphysicsbody_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool Gvphysics_save_cphysicsbody_t::IsValid() {
    return (m_ptr != nullptr);
}
GRnBodyDesc_t Gvphysics_save_cphysicsbody_t::GetParent() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("vphysics_save_cphysicsbody_t::GetParent(ptr=%p)", m_ptr));
    GRnBodyDesc_t value(m_ptr);
    return value;
}
void Gvphysics_save_cphysicsbody_t::SetParent(GRnBodyDesc_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("vphysics_save_cphysicsbody_t::SetParent(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassvphysics_save_cphysicsbody_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<Gvphysics_save_cphysicsbody_t>("vphysics_save_cphysicsbody_t")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("OldPointer", &Gvphysics_save_cphysicsbody_t::GetOldPointer, &Gvphysics_save_cphysicsbody_t::SetOldPointer)
        .addProperty("Parent", &Gvphysics_save_cphysicsbody_t::GetParent, &Gvphysics_save_cphysicsbody_t::SetParent)
        .addFunction("ToPtr", &Gvphysics_save_cphysicsbody_t::ToPtr)
        .addFunction("IsValid", &Gvphysics_save_cphysicsbody_t::IsValid)
        .endClass();
}
GCRagdollAnimTag::GCRagdollAnimTag(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCRagdollAnimTag::GCRagdollAnimTag(void *ptr) {
    m_ptr = ptr;
}
uint64_t GCRagdollAnimTag::GetPoseControl() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CRagdollAnimTag->PoseControl(ptr=%p)", m_ptr));
    return GetSchemaValue<uint64_t>(m_ptr, "CRagdollAnimTag", "m_nPoseControl");
}
void GCRagdollAnimTag::SetPoseControl(uint64_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CRagdollAnimTag->PoseControl(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CRagdollAnimTag", "m_nPoseControl", false, value);
}
float GCRagdollAnimTag::GetFrequency() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CRagdollAnimTag->Frequency(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CRagdollAnimTag", "m_flFrequency");
}
void GCRagdollAnimTag::SetFrequency(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CRagdollAnimTag->Frequency(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CRagdollAnimTag", "m_flFrequency", false, value);
}
float GCRagdollAnimTag::GetDampingRatio() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CRagdollAnimTag->DampingRatio(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CRagdollAnimTag", "m_flDampingRatio");
}
void GCRagdollAnimTag::SetDampingRatio(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CRagdollAnimTag->DampingRatio(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CRagdollAnimTag", "m_flDampingRatio", false, value);
}
float GCRagdollAnimTag::GetDecayDuration() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CRagdollAnimTag->DecayDuration(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CRagdollAnimTag", "m_flDecayDuration");
}
void GCRagdollAnimTag::SetDecayDuration(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CRagdollAnimTag->DecayDuration(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CRagdollAnimTag", "m_flDecayDuration", false, value);
}
float GCRagdollAnimTag::GetDecayBias() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CRagdollAnimTag->DecayBias(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CRagdollAnimTag", "m_flDecayBias");
}
void GCRagdollAnimTag::SetDecayBias(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CRagdollAnimTag->DecayBias(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CRagdollAnimTag", "m_flDecayBias", false, value);
}
bool GCRagdollAnimTag::GetDestroy() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CRagdollAnimTag->Destroy(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "CRagdollAnimTag", "m_bDestroy");
}
void GCRagdollAnimTag::SetDestroy(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CRagdollAnimTag->Destroy(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CRagdollAnimTag", "m_bDestroy", false, value);
}
void* GCRagdollAnimTag::GetPtr() {
    return m_ptr;
}
std::string GCRagdollAnimTag::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCRagdollAnimTag::IsValid() {
    return (m_ptr != nullptr);
}
GCAnimTagBase GCRagdollAnimTag::GetParent() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CRagdollAnimTag::GetParent(ptr=%p)", m_ptr));
    GCAnimTagBase value(m_ptr);
    return value;
}
void GCRagdollAnimTag::SetParent(GCAnimTagBase value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CRagdollAnimTag::SetParent(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCRagdollAnimTag(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCRagdollAnimTag>("CRagdollAnimTag")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("PoseControl", &GCRagdollAnimTag::GetPoseControl, &GCRagdollAnimTag::SetPoseControl)
        .addProperty("Frequency", &GCRagdollAnimTag::GetFrequency, &GCRagdollAnimTag::SetFrequency)
        .addProperty("DampingRatio", &GCRagdollAnimTag::GetDampingRatio, &GCRagdollAnimTag::SetDampingRatio)
        .addProperty("DecayDuration", &GCRagdollAnimTag::GetDecayDuration, &GCRagdollAnimTag::SetDecayDuration)
        .addProperty("DecayBias", &GCRagdollAnimTag::GetDecayBias, &GCRagdollAnimTag::SetDecayBias)
        .addProperty("Destroy", &GCRagdollAnimTag::GetDestroy, &GCRagdollAnimTag::SetDestroy)
        .addProperty("Parent", &GCRagdollAnimTag::GetParent, &GCRagdollAnimTag::SetParent)
        .addFunction("ToPtr", &GCRagdollAnimTag::ToPtr)
        .addFunction("IsValid", &GCRagdollAnimTag::IsValid)
        .endClass();
}
GIClientAlphaProperty::GIClientAlphaProperty(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GIClientAlphaProperty::GIClientAlphaProperty(void *ptr) {
    m_ptr = ptr;
}
void* GIClientAlphaProperty::GetPtr() {
    return m_ptr;
}
std::string GIClientAlphaProperty::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GIClientAlphaProperty::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassIClientAlphaProperty(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GIClientAlphaProperty>("IClientAlphaProperty")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addFunction("ToPtr", &GIClientAlphaProperty::ToPtr)
        .addFunction("IsValid", &GIClientAlphaProperty::IsValid)
        .endClass();
}
GPermModelData_t::GPermModelData_t(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GPermModelData_t::GPermModelData_t(void *ptr) {
    m_ptr = ptr;
}
std::string GPermModelData_t::GetName() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: PermModelData_t->Name(ptr=%p)", m_ptr));
    return GetSchemaValue<CUtlString>(m_ptr, "PermModelData_t", "m_name").Get();
}
void GPermModelData_t::SetName(std::string value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: PermModelData_t->Name(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "PermModelData_t", "m_name", true, CUtlString(value.c_str()));
}
GPermModelInfo_t GPermModelData_t::GetModelInfo() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: PermModelData_t->ModelInfo(ptr=%p)", m_ptr));
    GPermModelInfo_t value(GetSchemaPtr(m_ptr, "PermModelData_t", "m_modelInfo"));
    return value;
}
void GPermModelData_t::SetModelInfo(GPermModelInfo_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: PermModelData_t->ModelInfo(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'ModelInfo' is not possible.\n");
}
std::vector<GPermModelExtPart_t> GPermModelData_t::GetExtParts() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: PermModelData_t->ExtParts(ptr=%p)", m_ptr));
    CUtlVector<GPermModelExtPart_t>* vec = GetSchemaValue<CUtlVector<GPermModelExtPart_t>*>(m_ptr, "PermModelData_t", "m_ExtParts"); std::vector<GPermModelExtPart_t> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GPermModelData_t::SetExtParts(std::vector<GPermModelExtPart_t> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: PermModelData_t->ExtParts(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<GPermModelExtPart_t>(m_ptr, "PermModelData_t", "m_ExtParts", true, value);
}
std::vector<uint64> GPermModelData_t::GetRefMeshGroupMasks() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: PermModelData_t->RefMeshGroupMasks(ptr=%p)", m_ptr));
    CUtlVector<uint64>* vec = GetSchemaValue<CUtlVector<uint64>*>(m_ptr, "PermModelData_t", "m_refMeshGroupMasks"); std::vector<uint64> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GPermModelData_t::SetRefMeshGroupMasks(std::vector<uint64> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: PermModelData_t->RefMeshGroupMasks(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<uint64>(m_ptr, "PermModelData_t", "m_refMeshGroupMasks", true, value);
}
std::vector<uint64> GPermModelData_t::GetRefPhysGroupMasks() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: PermModelData_t->RefPhysGroupMasks(ptr=%p)", m_ptr));
    CUtlVector<uint64>* vec = GetSchemaValue<CUtlVector<uint64>*>(m_ptr, "PermModelData_t", "m_refPhysGroupMasks"); std::vector<uint64> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GPermModelData_t::SetRefPhysGroupMasks(std::vector<uint64> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: PermModelData_t->RefPhysGroupMasks(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<uint64>(m_ptr, "PermModelData_t", "m_refPhysGroupMasks", true, value);
}
std::vector<uint8> GPermModelData_t::GetRefLODGroupMasks() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: PermModelData_t->RefLODGroupMasks(ptr=%p)", m_ptr));
    CUtlVector<uint8>* vec = GetSchemaValue<CUtlVector<uint8>*>(m_ptr, "PermModelData_t", "m_refLODGroupMasks"); std::vector<uint8> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GPermModelData_t::SetRefLODGroupMasks(std::vector<uint8> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: PermModelData_t->RefLODGroupMasks(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<uint8>(m_ptr, "PermModelData_t", "m_refLODGroupMasks", true, value);
}
std::vector<float32> GPermModelData_t::GetLodGroupSwitchDistances() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: PermModelData_t->LodGroupSwitchDistances(ptr=%p)", m_ptr));
    CUtlVector<float32>* vec = GetSchemaValue<CUtlVector<float32>*>(m_ptr, "PermModelData_t", "m_lodGroupSwitchDistances"); std::vector<float32> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GPermModelData_t::SetLodGroupSwitchDistances(std::vector<float32> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: PermModelData_t->LodGroupSwitchDistances(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<float32>(m_ptr, "PermModelData_t", "m_lodGroupSwitchDistances", true, value);
}
std::vector<CUtlString> GPermModelData_t::GetMeshGroups() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: PermModelData_t->MeshGroups(ptr=%p)", m_ptr));
    CUtlVector<CUtlString>* vec = GetSchemaValue<CUtlVector<CUtlString>*>(m_ptr, "PermModelData_t", "m_meshGroups"); std::vector<CUtlString> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GPermModelData_t::SetMeshGroups(std::vector<CUtlString> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: PermModelData_t->MeshGroups(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<CUtlString>(m_ptr, "PermModelData_t", "m_meshGroups", true, value);
}
std::vector<GMaterialGroup_t> GPermModelData_t::GetMaterialGroups() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: PermModelData_t->MaterialGroups(ptr=%p)", m_ptr));
    CUtlVector<GMaterialGroup_t>* vec = GetSchemaValue<CUtlVector<GMaterialGroup_t>*>(m_ptr, "PermModelData_t", "m_materialGroups"); std::vector<GMaterialGroup_t> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GPermModelData_t::SetMaterialGroups(std::vector<GMaterialGroup_t> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: PermModelData_t->MaterialGroups(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<GMaterialGroup_t>(m_ptr, "PermModelData_t", "m_materialGroups", true, value);
}
uint64_t GPermModelData_t::GetDefaultMeshGroupMask() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: PermModelData_t->DefaultMeshGroupMask(ptr=%p)", m_ptr));
    return GetSchemaValue<uint64_t>(m_ptr, "PermModelData_t", "m_nDefaultMeshGroupMask");
}
void GPermModelData_t::SetDefaultMeshGroupMask(uint64_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: PermModelData_t->DefaultMeshGroupMask(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "PermModelData_t", "m_nDefaultMeshGroupMask", true, value);
}
GModelSkeletonData_t GPermModelData_t::GetModelSkeleton() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: PermModelData_t->ModelSkeleton(ptr=%p)", m_ptr));
    GModelSkeletonData_t value(GetSchemaPtr(m_ptr, "PermModelData_t", "m_modelSkeleton"));
    return value;
}
void GPermModelData_t::SetModelSkeleton(GModelSkeletonData_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: PermModelData_t->ModelSkeleton(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'ModelSkeleton' is not possible.\n");
}
std::vector<int16> GPermModelData_t::GetRemappingTable() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: PermModelData_t->RemappingTable(ptr=%p)", m_ptr));
    CUtlVector<int16>* vec = GetSchemaValue<CUtlVector<int16>*>(m_ptr, "PermModelData_t", "m_remappingTable"); std::vector<int16> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GPermModelData_t::SetRemappingTable(std::vector<int16> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: PermModelData_t->RemappingTable(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<int16>(m_ptr, "PermModelData_t", "m_remappingTable", true, value);
}
std::vector<uint16> GPermModelData_t::GetRemappingTableStarts() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: PermModelData_t->RemappingTableStarts(ptr=%p)", m_ptr));
    CUtlVector<uint16>* vec = GetSchemaValue<CUtlVector<uint16>*>(m_ptr, "PermModelData_t", "m_remappingTableStarts"); std::vector<uint16> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GPermModelData_t::SetRemappingTableStarts(std::vector<uint16> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: PermModelData_t->RemappingTableStarts(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<uint16>(m_ptr, "PermModelData_t", "m_remappingTableStarts", true, value);
}
std::vector<GModelBoneFlexDriver_t> GPermModelData_t::GetBoneFlexDrivers() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: PermModelData_t->BoneFlexDrivers(ptr=%p)", m_ptr));
    CUtlVector<GModelBoneFlexDriver_t>* vec = GetSchemaValue<CUtlVector<GModelBoneFlexDriver_t>*>(m_ptr, "PermModelData_t", "m_boneFlexDrivers"); std::vector<GModelBoneFlexDriver_t> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GPermModelData_t::SetBoneFlexDrivers(std::vector<GModelBoneFlexDriver_t> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: PermModelData_t->BoneFlexDrivers(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<GModelBoneFlexDriver_t>(m_ptr, "PermModelData_t", "m_boneFlexDrivers", true, value);
}
GCModelConfigList GPermModelData_t::GetModelConfigList() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: PermModelData_t->ModelConfigList(ptr=%p)", m_ptr));
    GCModelConfigList value(*(void**)GetSchemaPtr(m_ptr, "PermModelData_t", "m_pModelConfigList"));
    return value;
}
void GPermModelData_t::SetModelConfigList(GCModelConfigList value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: PermModelData_t->ModelConfigList(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "PermModelData_t","m_pModelConfigList", true, (char*)value.GetPtr());
}
std::vector<CUtlString> GPermModelData_t::GetBodyGroupsHiddenInTools() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: PermModelData_t->BodyGroupsHiddenInTools(ptr=%p)", m_ptr));
    CUtlVector<CUtlString>* vec = GetSchemaValue<CUtlVector<CUtlString>*>(m_ptr, "PermModelData_t", "m_BodyGroupsHiddenInTools"); std::vector<CUtlString> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GPermModelData_t::SetBodyGroupsHiddenInTools(std::vector<CUtlString> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: PermModelData_t->BodyGroupsHiddenInTools(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<CUtlString>(m_ptr, "PermModelData_t", "m_BodyGroupsHiddenInTools", true, value);
}
std::vector<GPermModelDataAnimatedMaterialAttribute_t> GPermModelData_t::GetAnimatedMaterialAttributes() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: PermModelData_t->AnimatedMaterialAttributes(ptr=%p)", m_ptr));
    CUtlVector<GPermModelDataAnimatedMaterialAttribute_t>* vec = GetSchemaValue<CUtlVector<GPermModelDataAnimatedMaterialAttribute_t>*>(m_ptr, "PermModelData_t", "m_AnimatedMaterialAttributes"); std::vector<GPermModelDataAnimatedMaterialAttribute_t> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GPermModelData_t::SetAnimatedMaterialAttributes(std::vector<GPermModelDataAnimatedMaterialAttribute_t> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: PermModelData_t->AnimatedMaterialAttributes(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<GPermModelDataAnimatedMaterialAttribute_t>(m_ptr, "PermModelData_t", "m_AnimatedMaterialAttributes", true, value);
}
void* GPermModelData_t::GetPtr() {
    return m_ptr;
}
std::string GPermModelData_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GPermModelData_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassPermModelData_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GPermModelData_t>("PermModelData_t")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Name", &GPermModelData_t::GetName, &GPermModelData_t::SetName)
        .addProperty("ModelInfo", &GPermModelData_t::GetModelInfo, &GPermModelData_t::SetModelInfo)
        .addProperty("ExtParts", &GPermModelData_t::GetExtParts, &GPermModelData_t::SetExtParts)
        .addProperty("RefMeshGroupMasks", &GPermModelData_t::GetRefMeshGroupMasks, &GPermModelData_t::SetRefMeshGroupMasks)
        .addProperty("RefPhysGroupMasks", &GPermModelData_t::GetRefPhysGroupMasks, &GPermModelData_t::SetRefPhysGroupMasks)
        .addProperty("RefLODGroupMasks", &GPermModelData_t::GetRefLODGroupMasks, &GPermModelData_t::SetRefLODGroupMasks)
        .addProperty("LodGroupSwitchDistances", &GPermModelData_t::GetLodGroupSwitchDistances, &GPermModelData_t::SetLodGroupSwitchDistances)
        .addProperty("MeshGroups", &GPermModelData_t::GetMeshGroups, &GPermModelData_t::SetMeshGroups)
        .addProperty("MaterialGroups", &GPermModelData_t::GetMaterialGroups, &GPermModelData_t::SetMaterialGroups)
        .addProperty("DefaultMeshGroupMask", &GPermModelData_t::GetDefaultMeshGroupMask, &GPermModelData_t::SetDefaultMeshGroupMask)
        .addProperty("ModelSkeleton", &GPermModelData_t::GetModelSkeleton, &GPermModelData_t::SetModelSkeleton)
        .addProperty("RemappingTable", &GPermModelData_t::GetRemappingTable, &GPermModelData_t::SetRemappingTable)
        .addProperty("RemappingTableStarts", &GPermModelData_t::GetRemappingTableStarts, &GPermModelData_t::SetRemappingTableStarts)
        .addProperty("BoneFlexDrivers", &GPermModelData_t::GetBoneFlexDrivers, &GPermModelData_t::SetBoneFlexDrivers)
        .addProperty("ModelConfigList", &GPermModelData_t::GetModelConfigList, &GPermModelData_t::SetModelConfigList)
        .addProperty("BodyGroupsHiddenInTools", &GPermModelData_t::GetBodyGroupsHiddenInTools, &GPermModelData_t::SetBodyGroupsHiddenInTools)
        .addProperty("AnimatedMaterialAttributes", &GPermModelData_t::GetAnimatedMaterialAttributes, &GPermModelData_t::SetAnimatedMaterialAttributes)
        .addFunction("ToPtr", &GPermModelData_t::ToPtr)
        .addFunction("IsValid", &GPermModelData_t::IsValid)
        .endClass();
}
GFootFixedSettings::GFootFixedSettings(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GFootFixedSettings::GFootFixedSettings(void *ptr) {
    m_ptr = ptr;
}
GTraceSettings_t GFootFixedSettings::GetTraceSettings() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FootFixedSettings->TraceSettings(ptr=%p)", m_ptr));
    GTraceSettings_t value(GetSchemaPtr(m_ptr, "FootFixedSettings", "m_traceSettings"));
    return value;
}
void GFootFixedSettings::SetTraceSettings(GTraceSettings_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FootFixedSettings->TraceSettings(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'TraceSettings' is not possible.\n");
}
Vector GFootFixedSettings::GetFootBaseBindPosePositionMS() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FootFixedSettings->FootBaseBindPosePositionMS(ptr=%p)", m_ptr));
    return GetSchemaValue<Vector>(m_ptr, "FootFixedSettings", "m_vFootBaseBindPosePositionMS");
}
void GFootFixedSettings::SetFootBaseBindPosePositionMS(Vector value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FootFixedSettings->FootBaseBindPosePositionMS(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "FootFixedSettings", "m_vFootBaseBindPosePositionMS", false, value);
}
float GFootFixedSettings::GetFootBaseLength() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FootFixedSettings->FootBaseLength(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "FootFixedSettings", "m_flFootBaseLength");
}
void GFootFixedSettings::SetFootBaseLength(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FootFixedSettings->FootBaseLength(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "FootFixedSettings", "m_flFootBaseLength", false, value);
}
float GFootFixedSettings::GetMaxRotationLeft() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FootFixedSettings->MaxRotationLeft(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "FootFixedSettings", "m_flMaxRotationLeft");
}
void GFootFixedSettings::SetMaxRotationLeft(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FootFixedSettings->MaxRotationLeft(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "FootFixedSettings", "m_flMaxRotationLeft", false, value);
}
float GFootFixedSettings::GetMaxRotationRight() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FootFixedSettings->MaxRotationRight(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "FootFixedSettings", "m_flMaxRotationRight");
}
void GFootFixedSettings::SetMaxRotationRight(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FootFixedSettings->MaxRotationRight(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "FootFixedSettings", "m_flMaxRotationRight", false, value);
}
int32_t GFootFixedSettings::GetFootstepLandedTagIndex() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FootFixedSettings->FootstepLandedTagIndex(ptr=%p)", m_ptr));
    return GetSchemaValue<int32_t>(m_ptr, "FootFixedSettings", "m_footstepLandedTagIndex");
}
void GFootFixedSettings::SetFootstepLandedTagIndex(int32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FootFixedSettings->FootstepLandedTagIndex(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "FootFixedSettings", "m_footstepLandedTagIndex", false, value);
}
bool GFootFixedSettings::GetEnableTracing() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FootFixedSettings->EnableTracing(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "FootFixedSettings", "m_bEnableTracing");
}
void GFootFixedSettings::SetEnableTracing(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FootFixedSettings->EnableTracing(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "FootFixedSettings", "m_bEnableTracing", false, value);
}
float GFootFixedSettings::GetTraceAngleBlend() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FootFixedSettings->TraceAngleBlend(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "FootFixedSettings", "m_flTraceAngleBlend");
}
void GFootFixedSettings::SetTraceAngleBlend(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FootFixedSettings->TraceAngleBlend(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "FootFixedSettings", "m_flTraceAngleBlend", false, value);
}
int32_t GFootFixedSettings::GetDisableTagIndex() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FootFixedSettings->DisableTagIndex(ptr=%p)", m_ptr));
    return GetSchemaValue<int32_t>(m_ptr, "FootFixedSettings", "m_nDisableTagIndex");
}
void GFootFixedSettings::SetDisableTagIndex(int32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FootFixedSettings->DisableTagIndex(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "FootFixedSettings", "m_nDisableTagIndex", false, value);
}
int32_t GFootFixedSettings::GetFootIndex() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FootFixedSettings->FootIndex(ptr=%p)", m_ptr));
    return GetSchemaValue<int32_t>(m_ptr, "FootFixedSettings", "m_nFootIndex");
}
void GFootFixedSettings::SetFootIndex(int32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FootFixedSettings->FootIndex(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "FootFixedSettings", "m_nFootIndex", false, value);
}
void* GFootFixedSettings::GetPtr() {
    return m_ptr;
}
std::string GFootFixedSettings::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GFootFixedSettings::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassFootFixedSettings(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GFootFixedSettings>("FootFixedSettings")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("TraceSettings", &GFootFixedSettings::GetTraceSettings, &GFootFixedSettings::SetTraceSettings)
        .addProperty("FootBaseBindPosePositionMS", &GFootFixedSettings::GetFootBaseBindPosePositionMS, &GFootFixedSettings::SetFootBaseBindPosePositionMS)
        .addProperty("FootBaseLength", &GFootFixedSettings::GetFootBaseLength, &GFootFixedSettings::SetFootBaseLength)
        .addProperty("MaxRotationLeft", &GFootFixedSettings::GetMaxRotationLeft, &GFootFixedSettings::SetMaxRotationLeft)
        .addProperty("MaxRotationRight", &GFootFixedSettings::GetMaxRotationRight, &GFootFixedSettings::SetMaxRotationRight)
        .addProperty("FootstepLandedTagIndex", &GFootFixedSettings::GetFootstepLandedTagIndex, &GFootFixedSettings::SetFootstepLandedTagIndex)
        .addProperty("EnableTracing", &GFootFixedSettings::GetEnableTracing, &GFootFixedSettings::SetEnableTracing)
        .addProperty("TraceAngleBlend", &GFootFixedSettings::GetTraceAngleBlend, &GFootFixedSettings::SetTraceAngleBlend)
        .addProperty("DisableTagIndex", &GFootFixedSettings::GetDisableTagIndex, &GFootFixedSettings::SetDisableTagIndex)
        .addProperty("FootIndex", &GFootFixedSettings::GetFootIndex, &GFootFixedSettings::SetFootIndex)
        .addFunction("ToPtr", &GFootFixedSettings::ToPtr)
        .addFunction("IsValid", &GFootFixedSettings::IsValid)
        .endClass();
}
GCSolveIKTargetHandle_t::GCSolveIKTargetHandle_t(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCSolveIKTargetHandle_t::GCSolveIKTargetHandle_t(void *ptr) {
    m_ptr = ptr;
}
GCAnimParamHandle GCSolveIKTargetHandle_t::GetPositionHandle() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CSolveIKTargetHandle_t->PositionHandle(ptr=%p)", m_ptr));
    GCAnimParamHandle value(GetSchemaPtr(m_ptr, "CSolveIKTargetHandle_t", "m_positionHandle"));
    return value;
}
void GCSolveIKTargetHandle_t::SetPositionHandle(GCAnimParamHandle value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CSolveIKTargetHandle_t->PositionHandle(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'PositionHandle' is not possible.\n");
}
GCAnimParamHandle GCSolveIKTargetHandle_t::GetOrientationHandle() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CSolveIKTargetHandle_t->OrientationHandle(ptr=%p)", m_ptr));
    GCAnimParamHandle value(GetSchemaPtr(m_ptr, "CSolveIKTargetHandle_t", "m_orientationHandle"));
    return value;
}
void GCSolveIKTargetHandle_t::SetOrientationHandle(GCAnimParamHandle value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CSolveIKTargetHandle_t->OrientationHandle(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'OrientationHandle' is not possible.\n");
}
void* GCSolveIKTargetHandle_t::GetPtr() {
    return m_ptr;
}
std::string GCSolveIKTargetHandle_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCSolveIKTargetHandle_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCSolveIKTargetHandle_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCSolveIKTargetHandle_t>("CSolveIKTargetHandle_t")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("PositionHandle", &GCSolveIKTargetHandle_t::GetPositionHandle, &GCSolveIKTargetHandle_t::SetPositionHandle)
        .addProperty("OrientationHandle", &GCSolveIKTargetHandle_t::GetOrientationHandle, &GCSolveIKTargetHandle_t::SetOrientationHandle)
        .addFunction("ToPtr", &GCSolveIKTargetHandle_t::ToPtr)
        .addFunction("IsValid", &GCSolveIKTargetHandle_t::IsValid)
        .endClass();
}
GCBlendUpdateNode::GCBlendUpdateNode(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCBlendUpdateNode::GCBlendUpdateNode(void *ptr) {
    m_ptr = ptr;
}
std::vector<GCAnimUpdateNodeRef> GCBlendUpdateNode::GetChildren() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CBlendUpdateNode->Children(ptr=%p)", m_ptr));
    CUtlVector<GCAnimUpdateNodeRef>* vec = GetSchemaValue<CUtlVector<GCAnimUpdateNodeRef>*>(m_ptr, "CBlendUpdateNode", "m_children"); std::vector<GCAnimUpdateNodeRef> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCBlendUpdateNode::SetChildren(std::vector<GCAnimUpdateNodeRef> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CBlendUpdateNode->Children(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<GCAnimUpdateNodeRef>(m_ptr, "CBlendUpdateNode", "m_children", false, value);
}
std::vector<uint8> GCBlendUpdateNode::GetSortedOrder() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CBlendUpdateNode->SortedOrder(ptr=%p)", m_ptr));
    CUtlVector<uint8>* vec = GetSchemaValue<CUtlVector<uint8>*>(m_ptr, "CBlendUpdateNode", "m_sortedOrder"); std::vector<uint8> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCBlendUpdateNode::SetSortedOrder(std::vector<uint8> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CBlendUpdateNode->SortedOrder(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<uint8>(m_ptr, "CBlendUpdateNode", "m_sortedOrder", false, value);
}
std::vector<float32> GCBlendUpdateNode::GetTargetValues() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CBlendUpdateNode->TargetValues(ptr=%p)", m_ptr));
    CUtlVector<float32>* vec = GetSchemaValue<CUtlVector<float32>*>(m_ptr, "CBlendUpdateNode", "m_targetValues"); std::vector<float32> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCBlendUpdateNode::SetTargetValues(std::vector<float32> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CBlendUpdateNode->TargetValues(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<float32>(m_ptr, "CBlendUpdateNode", "m_targetValues", false, value);
}
uint64_t GCBlendUpdateNode::GetBlendValueSource() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CBlendUpdateNode->BlendValueSource(ptr=%p)", m_ptr));
    return GetSchemaValue<uint64_t>(m_ptr, "CBlendUpdateNode", "m_blendValueSource");
}
void GCBlendUpdateNode::SetBlendValueSource(uint64_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CBlendUpdateNode->BlendValueSource(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CBlendUpdateNode", "m_blendValueSource", false, value);
}
GCAnimParamHandle GCBlendUpdateNode::GetParamIndex() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CBlendUpdateNode->ParamIndex(ptr=%p)", m_ptr));
    GCAnimParamHandle value(GetSchemaPtr(m_ptr, "CBlendUpdateNode", "m_paramIndex"));
    return value;
}
void GCBlendUpdateNode::SetParamIndex(GCAnimParamHandle value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CBlendUpdateNode->ParamIndex(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'ParamIndex' is not possible.\n");
}
GCAnimInputDamping GCBlendUpdateNode::GetDamping() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CBlendUpdateNode->Damping(ptr=%p)", m_ptr));
    GCAnimInputDamping value(GetSchemaPtr(m_ptr, "CBlendUpdateNode", "m_damping"));
    return value;
}
void GCBlendUpdateNode::SetDamping(GCAnimInputDamping value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CBlendUpdateNode->Damping(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Damping' is not possible.\n");
}
uint64_t GCBlendUpdateNode::GetBlendKeyType() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CBlendUpdateNode->BlendKeyType(ptr=%p)", m_ptr));
    return GetSchemaValue<uint64_t>(m_ptr, "CBlendUpdateNode", "m_blendKeyType");
}
void GCBlendUpdateNode::SetBlendKeyType(uint64_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CBlendUpdateNode->BlendKeyType(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CBlendUpdateNode", "m_blendKeyType", false, value);
}
bool GCBlendUpdateNode::GetLockBlendOnReset() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CBlendUpdateNode->LockBlendOnReset(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "CBlendUpdateNode", "m_bLockBlendOnReset");
}
void GCBlendUpdateNode::SetLockBlendOnReset(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CBlendUpdateNode->LockBlendOnReset(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CBlendUpdateNode", "m_bLockBlendOnReset", false, value);
}
bool GCBlendUpdateNode::GetSyncCycles() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CBlendUpdateNode->SyncCycles(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "CBlendUpdateNode", "m_bSyncCycles");
}
void GCBlendUpdateNode::SetSyncCycles(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CBlendUpdateNode->SyncCycles(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CBlendUpdateNode", "m_bSyncCycles", false, value);
}
bool GCBlendUpdateNode::GetLoop() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CBlendUpdateNode->Loop(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "CBlendUpdateNode", "m_bLoop");
}
void GCBlendUpdateNode::SetLoop(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CBlendUpdateNode->Loop(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CBlendUpdateNode", "m_bLoop", false, value);
}
bool GCBlendUpdateNode::GetLockWhenWaning() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CBlendUpdateNode->LockWhenWaning(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "CBlendUpdateNode", "m_bLockWhenWaning");
}
void GCBlendUpdateNode::SetLockWhenWaning(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CBlendUpdateNode->LockWhenWaning(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CBlendUpdateNode", "m_bLockWhenWaning", false, value);
}
void* GCBlendUpdateNode::GetPtr() {
    return m_ptr;
}
std::string GCBlendUpdateNode::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCBlendUpdateNode::IsValid() {
    return (m_ptr != nullptr);
}
GCAnimUpdateNodeBase GCBlendUpdateNode::GetParent() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CBlendUpdateNode::GetParent(ptr=%p)", m_ptr));
    GCAnimUpdateNodeBase value(m_ptr);
    return value;
}
void GCBlendUpdateNode::SetParent(GCAnimUpdateNodeBase value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CBlendUpdateNode::SetParent(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCBlendUpdateNode(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCBlendUpdateNode>("CBlendUpdateNode")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Children", &GCBlendUpdateNode::GetChildren, &GCBlendUpdateNode::SetChildren)
        .addProperty("SortedOrder", &GCBlendUpdateNode::GetSortedOrder, &GCBlendUpdateNode::SetSortedOrder)
        .addProperty("TargetValues", &GCBlendUpdateNode::GetTargetValues, &GCBlendUpdateNode::SetTargetValues)
        .addProperty("BlendValueSource", &GCBlendUpdateNode::GetBlendValueSource, &GCBlendUpdateNode::SetBlendValueSource)
        .addProperty("ParamIndex", &GCBlendUpdateNode::GetParamIndex, &GCBlendUpdateNode::SetParamIndex)
        .addProperty("Damping", &GCBlendUpdateNode::GetDamping, &GCBlendUpdateNode::SetDamping)
        .addProperty("BlendKeyType", &GCBlendUpdateNode::GetBlendKeyType, &GCBlendUpdateNode::SetBlendKeyType)
        .addProperty("LockBlendOnReset", &GCBlendUpdateNode::GetLockBlendOnReset, &GCBlendUpdateNode::SetLockBlendOnReset)
        .addProperty("SyncCycles", &GCBlendUpdateNode::GetSyncCycles, &GCBlendUpdateNode::SetSyncCycles)
        .addProperty("Loop", &GCBlendUpdateNode::GetLoop, &GCBlendUpdateNode::SetLoop)
        .addProperty("LockWhenWaning", &GCBlendUpdateNode::GetLockWhenWaning, &GCBlendUpdateNode::SetLockWhenWaning)
        .addProperty("Parent", &GCBlendUpdateNode::GetParent, &GCBlendUpdateNode::SetParent)
        .addFunction("ToPtr", &GCBlendUpdateNode::ToPtr)
        .addFunction("IsValid", &GCBlendUpdateNode::IsValid)
        .endClass();
}
GCAnimationGraphVisualizerSphere::GCAnimationGraphVisualizerSphere(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCAnimationGraphVisualizerSphere::GCAnimationGraphVisualizerSphere(void *ptr) {
    m_ptr = ptr;
}
Vector GCAnimationGraphVisualizerSphere::GetWsPosition() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CAnimationGraphVisualizerSphere->WsPosition(ptr=%p)", m_ptr));
    return GetSchemaValue<Vector>(m_ptr, "CAnimationGraphVisualizerSphere", "m_vWsPosition");
}
void GCAnimationGraphVisualizerSphere::SetWsPosition(Vector value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CAnimationGraphVisualizerSphere->WsPosition(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CAnimationGraphVisualizerSphere", "m_vWsPosition", false, value);
}
float GCAnimationGraphVisualizerSphere::GetRadius() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CAnimationGraphVisualizerSphere->Radius(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CAnimationGraphVisualizerSphere", "m_flRadius");
}
void GCAnimationGraphVisualizerSphere::SetRadius(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CAnimationGraphVisualizerSphere->Radius(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CAnimationGraphVisualizerSphere", "m_flRadius", false, value);
}
Color GCAnimationGraphVisualizerSphere::GetColor() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CAnimationGraphVisualizerSphere->Color(ptr=%p)", m_ptr));
    return GetSchemaValue<Color>(m_ptr, "CAnimationGraphVisualizerSphere", "m_Color");
}
void GCAnimationGraphVisualizerSphere::SetColor(Color value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CAnimationGraphVisualizerSphere->Color(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CAnimationGraphVisualizerSphere", "m_Color", false, value);
}
void* GCAnimationGraphVisualizerSphere::GetPtr() {
    return m_ptr;
}
std::string GCAnimationGraphVisualizerSphere::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCAnimationGraphVisualizerSphere::IsValid() {
    return (m_ptr != nullptr);
}
GCAnimationGraphVisualizerPrimitiveBase GCAnimationGraphVisualizerSphere::GetParent() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CAnimationGraphVisualizerSphere::GetParent(ptr=%p)", m_ptr));
    GCAnimationGraphVisualizerPrimitiveBase value(m_ptr);
    return value;
}
void GCAnimationGraphVisualizerSphere::SetParent(GCAnimationGraphVisualizerPrimitiveBase value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CAnimationGraphVisualizerSphere::SetParent(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCAnimationGraphVisualizerSphere(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCAnimationGraphVisualizerSphere>("CAnimationGraphVisualizerSphere")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("WsPosition", &GCAnimationGraphVisualizerSphere::GetWsPosition, &GCAnimationGraphVisualizerSphere::SetWsPosition)
        .addProperty("Radius", &GCAnimationGraphVisualizerSphere::GetRadius, &GCAnimationGraphVisualizerSphere::SetRadius)
        .addProperty("Color", &GCAnimationGraphVisualizerSphere::GetColor, &GCAnimationGraphVisualizerSphere::SetColor)
        .addProperty("Parent", &GCAnimationGraphVisualizerSphere::GetParent, &GCAnimationGraphVisualizerSphere::SetParent)
        .addFunction("ToPtr", &GCAnimationGraphVisualizerSphere::ToPtr)
        .addFunction("IsValid", &GCAnimationGraphVisualizerSphere::IsValid)
        .endClass();
}
GMaterialParamFloat_t::GMaterialParamFloat_t(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GMaterialParamFloat_t::GMaterialParamFloat_t(void *ptr) {
    m_ptr = ptr;
}
float GMaterialParamFloat_t::GetValue() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: MaterialParamFloat_t->Value(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "MaterialParamFloat_t", "m_flValue");
}
void GMaterialParamFloat_t::SetValue(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: MaterialParamFloat_t->Value(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "MaterialParamFloat_t", "m_flValue", true, value);
}
void* GMaterialParamFloat_t::GetPtr() {
    return m_ptr;
}
std::string GMaterialParamFloat_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GMaterialParamFloat_t::IsValid() {
    return (m_ptr != nullptr);
}
GMaterialParam_t GMaterialParamFloat_t::GetParent() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("MaterialParamFloat_t::GetParent(ptr=%p)", m_ptr));
    GMaterialParam_t value(m_ptr);
    return value;
}
void GMaterialParamFloat_t::SetParent(GMaterialParam_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("MaterialParamFloat_t::SetParent(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassMaterialParamFloat_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GMaterialParamFloat_t>("MaterialParamFloat_t")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Value", &GMaterialParamFloat_t::GetValue, &GMaterialParamFloat_t::SetValue)
        .addProperty("Parent", &GMaterialParamFloat_t::GetParent, &GMaterialParamFloat_t::SetParent)
        .addFunction("ToPtr", &GMaterialParamFloat_t::ToPtr)
        .addFunction("IsValid", &GMaterialParamFloat_t::IsValid)
        .endClass();
}
GEventServerSimulate_t::GEventServerSimulate_t(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GEventServerSimulate_t::GEventServerSimulate_t(void *ptr) {
    m_ptr = ptr;
}
void* GEventServerSimulate_t::GetPtr() {
    return m_ptr;
}
std::string GEventServerSimulate_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GEventServerSimulate_t::IsValid() {
    return (m_ptr != nullptr);
}
GEventSimulate_t GEventServerSimulate_t::GetParent() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("EventServerSimulate_t::GetParent(ptr=%p)", m_ptr));
    GEventSimulate_t value(m_ptr);
    return value;
}
void GEventServerSimulate_t::SetParent(GEventSimulate_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("EventServerSimulate_t::SetParent(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassEventServerSimulate_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GEventServerSimulate_t>("EventServerSimulate_t")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Parent", &GEventServerSimulate_t::GetParent, &GEventServerSimulate_t::SetParent)
        .addFunction("ToPtr", &GEventServerSimulate_t::ToPtr)
        .addFunction("IsValid", &GEventServerSimulate_t::IsValid)
        .endClass();
}
GCVoiceContainerEnvelopeAnalyzer::GCVoiceContainerEnvelopeAnalyzer(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCVoiceContainerEnvelopeAnalyzer::GCVoiceContainerEnvelopeAnalyzer(void *ptr) {
    m_ptr = ptr;
}
uint64_t GCVoiceContainerEnvelopeAnalyzer::GetMode() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CVoiceContainerEnvelopeAnalyzer->Mode(ptr=%p)", m_ptr));
    return GetSchemaValue<uint64_t>(m_ptr, "CVoiceContainerEnvelopeAnalyzer", "m_mode");
}
void GCVoiceContainerEnvelopeAnalyzer::SetMode(uint64_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CVoiceContainerEnvelopeAnalyzer->Mode(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CVoiceContainerEnvelopeAnalyzer", "m_mode", false, value);
}
int32_t GCVoiceContainerEnvelopeAnalyzer::GetSamples() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CVoiceContainerEnvelopeAnalyzer->Samples(ptr=%p)", m_ptr));
    return GetSchemaValue<int32_t>(m_ptr, "CVoiceContainerEnvelopeAnalyzer", "m_nSamples");
}
void GCVoiceContainerEnvelopeAnalyzer::SetSamples(int32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CVoiceContainerEnvelopeAnalyzer->Samples(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CVoiceContainerEnvelopeAnalyzer", "m_nSamples", false, value);
}
float GCVoiceContainerEnvelopeAnalyzer::GetThreshold() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CVoiceContainerEnvelopeAnalyzer->Threshold(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CVoiceContainerEnvelopeAnalyzer", "m_flThreshold");
}
void GCVoiceContainerEnvelopeAnalyzer::SetThreshold(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CVoiceContainerEnvelopeAnalyzer->Threshold(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CVoiceContainerEnvelopeAnalyzer", "m_flThreshold", false, value);
}
void* GCVoiceContainerEnvelopeAnalyzer::GetPtr() {
    return m_ptr;
}
std::string GCVoiceContainerEnvelopeAnalyzer::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCVoiceContainerEnvelopeAnalyzer::IsValid() {
    return (m_ptr != nullptr);
}
GCVoiceContainerAnalysisBase GCVoiceContainerEnvelopeAnalyzer::GetParent() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CVoiceContainerEnvelopeAnalyzer::GetParent(ptr=%p)", m_ptr));
    GCVoiceContainerAnalysisBase value(m_ptr);
    return value;
}
void GCVoiceContainerEnvelopeAnalyzer::SetParent(GCVoiceContainerAnalysisBase value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CVoiceContainerEnvelopeAnalyzer::SetParent(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCVoiceContainerEnvelopeAnalyzer(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCVoiceContainerEnvelopeAnalyzer>("CVoiceContainerEnvelopeAnalyzer")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Mode", &GCVoiceContainerEnvelopeAnalyzer::GetMode, &GCVoiceContainerEnvelopeAnalyzer::SetMode)
        .addProperty("Samples", &GCVoiceContainerEnvelopeAnalyzer::GetSamples, &GCVoiceContainerEnvelopeAnalyzer::SetSamples)
        .addProperty("Threshold", &GCVoiceContainerEnvelopeAnalyzer::GetThreshold, &GCVoiceContainerEnvelopeAnalyzer::SetThreshold)
        .addProperty("Parent", &GCVoiceContainerEnvelopeAnalyzer::GetParent, &GCVoiceContainerEnvelopeAnalyzer::SetParent)
        .addFunction("ToPtr", &GCVoiceContainerEnvelopeAnalyzer::ToPtr)
        .addFunction("IsValid", &GCVoiceContainerEnvelopeAnalyzer::IsValid)
        .endClass();
}
GFollowAttachmentSettings_t::GFollowAttachmentSettings_t(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GFollowAttachmentSettings_t::GFollowAttachmentSettings_t(void *ptr) {
    m_ptr = ptr;
}
GCAnimAttachment GFollowAttachmentSettings_t::GetAttachment() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FollowAttachmentSettings_t->Attachment(ptr=%p)", m_ptr));
    GCAnimAttachment value(GetSchemaPtr(m_ptr, "FollowAttachmentSettings_t", "m_attachment"));
    return value;
}
void GFollowAttachmentSettings_t::SetAttachment(GCAnimAttachment value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FollowAttachmentSettings_t->Attachment(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Attachment' is not possible.\n");
}
int32_t GFollowAttachmentSettings_t::GetBoneIndex() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FollowAttachmentSettings_t->BoneIndex(ptr=%p)", m_ptr));
    return GetSchemaValue<int32_t>(m_ptr, "FollowAttachmentSettings_t", "m_boneIndex");
}
void GFollowAttachmentSettings_t::SetBoneIndex(int32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FollowAttachmentSettings_t->BoneIndex(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "FollowAttachmentSettings_t", "m_boneIndex", true, value);
}
bool GFollowAttachmentSettings_t::GetMatchTranslation() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FollowAttachmentSettings_t->MatchTranslation(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "FollowAttachmentSettings_t", "m_bMatchTranslation");
}
void GFollowAttachmentSettings_t::SetMatchTranslation(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FollowAttachmentSettings_t->MatchTranslation(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "FollowAttachmentSettings_t", "m_bMatchTranslation", true, value);
}
bool GFollowAttachmentSettings_t::GetMatchRotation() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FollowAttachmentSettings_t->MatchRotation(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "FollowAttachmentSettings_t", "m_bMatchRotation");
}
void GFollowAttachmentSettings_t::SetMatchRotation(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FollowAttachmentSettings_t->MatchRotation(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "FollowAttachmentSettings_t", "m_bMatchRotation", true, value);
}
void* GFollowAttachmentSettings_t::GetPtr() {
    return m_ptr;
}
std::string GFollowAttachmentSettings_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GFollowAttachmentSettings_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassFollowAttachmentSettings_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GFollowAttachmentSettings_t>("FollowAttachmentSettings_t")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Attachment", &GFollowAttachmentSettings_t::GetAttachment, &GFollowAttachmentSettings_t::SetAttachment)
        .addProperty("BoneIndex", &GFollowAttachmentSettings_t::GetBoneIndex, &GFollowAttachmentSettings_t::SetBoneIndex)
        .addProperty("MatchTranslation", &GFollowAttachmentSettings_t::GetMatchTranslation, &GFollowAttachmentSettings_t::SetMatchTranslation)
        .addProperty("MatchRotation", &GFollowAttachmentSettings_t::GetMatchRotation, &GFollowAttachmentSettings_t::SetMatchRotation)
        .addFunction("ToPtr", &GFollowAttachmentSettings_t::ToPtr)
        .addFunction("IsValid", &GFollowAttachmentSettings_t::IsValid)
        .endClass();
}
GJiggleBoneSettings_t::GJiggleBoneSettings_t(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GJiggleBoneSettings_t::GJiggleBoneSettings_t(void *ptr) {
    m_ptr = ptr;
}
int32_t GJiggleBoneSettings_t::GetBoneIndex() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: JiggleBoneSettings_t->BoneIndex(ptr=%p)", m_ptr));
    return GetSchemaValue<int32_t>(m_ptr, "JiggleBoneSettings_t", "m_nBoneIndex");
}
void GJiggleBoneSettings_t::SetBoneIndex(int32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: JiggleBoneSettings_t->BoneIndex(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "JiggleBoneSettings_t", "m_nBoneIndex", true, value);
}
float GJiggleBoneSettings_t::GetSpringStrength() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: JiggleBoneSettings_t->SpringStrength(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "JiggleBoneSettings_t", "m_flSpringStrength");
}
void GJiggleBoneSettings_t::SetSpringStrength(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: JiggleBoneSettings_t->SpringStrength(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "JiggleBoneSettings_t", "m_flSpringStrength", true, value);
}
float GJiggleBoneSettings_t::GetMaxTimeStep() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: JiggleBoneSettings_t->MaxTimeStep(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "JiggleBoneSettings_t", "m_flMaxTimeStep");
}
void GJiggleBoneSettings_t::SetMaxTimeStep(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: JiggleBoneSettings_t->MaxTimeStep(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "JiggleBoneSettings_t", "m_flMaxTimeStep", true, value);
}
float GJiggleBoneSettings_t::GetDamping() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: JiggleBoneSettings_t->Damping(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "JiggleBoneSettings_t", "m_flDamping");
}
void GJiggleBoneSettings_t::SetDamping(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: JiggleBoneSettings_t->Damping(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "JiggleBoneSettings_t", "m_flDamping", true, value);
}
Vector GJiggleBoneSettings_t::GetBoundsMaxLS() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: JiggleBoneSettings_t->BoundsMaxLS(ptr=%p)", m_ptr));
    return GetSchemaValue<Vector>(m_ptr, "JiggleBoneSettings_t", "m_vBoundsMaxLS");
}
void GJiggleBoneSettings_t::SetBoundsMaxLS(Vector value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: JiggleBoneSettings_t->BoundsMaxLS(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "JiggleBoneSettings_t", "m_vBoundsMaxLS", true, value);
}
Vector GJiggleBoneSettings_t::GetBoundsMinLS() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: JiggleBoneSettings_t->BoundsMinLS(ptr=%p)", m_ptr));
    return GetSchemaValue<Vector>(m_ptr, "JiggleBoneSettings_t", "m_vBoundsMinLS");
}
void GJiggleBoneSettings_t::SetBoundsMinLS(Vector value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: JiggleBoneSettings_t->BoundsMinLS(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "JiggleBoneSettings_t", "m_vBoundsMinLS", true, value);
}
uint64_t GJiggleBoneSettings_t::GetSimSpace() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: JiggleBoneSettings_t->SimSpace(ptr=%p)", m_ptr));
    return GetSchemaValue<uint64_t>(m_ptr, "JiggleBoneSettings_t", "m_eSimSpace");
}
void GJiggleBoneSettings_t::SetSimSpace(uint64_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: JiggleBoneSettings_t->SimSpace(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "JiggleBoneSettings_t", "m_eSimSpace", true, value);
}
void* GJiggleBoneSettings_t::GetPtr() {
    return m_ptr;
}
std::string GJiggleBoneSettings_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GJiggleBoneSettings_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassJiggleBoneSettings_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GJiggleBoneSettings_t>("JiggleBoneSettings_t")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("BoneIndex", &GJiggleBoneSettings_t::GetBoneIndex, &GJiggleBoneSettings_t::SetBoneIndex)
        .addProperty("SpringStrength", &GJiggleBoneSettings_t::GetSpringStrength, &GJiggleBoneSettings_t::SetSpringStrength)
        .addProperty("MaxTimeStep", &GJiggleBoneSettings_t::GetMaxTimeStep, &GJiggleBoneSettings_t::SetMaxTimeStep)
        .addProperty("Damping", &GJiggleBoneSettings_t::GetDamping, &GJiggleBoneSettings_t::SetDamping)
        .addProperty("BoundsMaxLS", &GJiggleBoneSettings_t::GetBoundsMaxLS, &GJiggleBoneSettings_t::SetBoundsMaxLS)
        .addProperty("BoundsMinLS", &GJiggleBoneSettings_t::GetBoundsMinLS, &GJiggleBoneSettings_t::SetBoundsMinLS)
        .addProperty("SimSpace", &GJiggleBoneSettings_t::GetSimSpace, &GJiggleBoneSettings_t::SetSimSpace)
        .addFunction("ToPtr", &GJiggleBoneSettings_t::ToPtr)
        .addFunction("IsValid", &GJiggleBoneSettings_t::IsValid)
        .endClass();
}
GCAnimStateMachineUpdater::GCAnimStateMachineUpdater(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCAnimStateMachineUpdater::GCAnimStateMachineUpdater(void *ptr) {
    m_ptr = ptr;
}
std::vector<GCStateUpdateData> GCAnimStateMachineUpdater::GetStates() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CAnimStateMachineUpdater->States(ptr=%p)", m_ptr));
    CUtlVector<GCStateUpdateData>* vec = GetSchemaValue<CUtlVector<GCStateUpdateData>*>(m_ptr, "CAnimStateMachineUpdater", "m_states"); std::vector<GCStateUpdateData> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCAnimStateMachineUpdater::SetStates(std::vector<GCStateUpdateData> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CAnimStateMachineUpdater->States(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<GCStateUpdateData>(m_ptr, "CAnimStateMachineUpdater", "m_states", false, value);
}
std::vector<GCTransitionUpdateData> GCAnimStateMachineUpdater::GetTransitions() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CAnimStateMachineUpdater->Transitions(ptr=%p)", m_ptr));
    CUtlVector<GCTransitionUpdateData>* vec = GetSchemaValue<CUtlVector<GCTransitionUpdateData>*>(m_ptr, "CAnimStateMachineUpdater", "m_transitions"); std::vector<GCTransitionUpdateData> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCAnimStateMachineUpdater::SetTransitions(std::vector<GCTransitionUpdateData> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CAnimStateMachineUpdater->Transitions(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<GCTransitionUpdateData>(m_ptr, "CAnimStateMachineUpdater", "m_transitions", false, value);
}
int32_t GCAnimStateMachineUpdater::GetStartStateIndex() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CAnimStateMachineUpdater->StartStateIndex(ptr=%p)", m_ptr));
    return GetSchemaValue<int32_t>(m_ptr, "CAnimStateMachineUpdater", "m_startStateIndex");
}
void GCAnimStateMachineUpdater::SetStartStateIndex(int32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CAnimStateMachineUpdater->StartStateIndex(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CAnimStateMachineUpdater", "m_startStateIndex", false, value);
}
void* GCAnimStateMachineUpdater::GetPtr() {
    return m_ptr;
}
std::string GCAnimStateMachineUpdater::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCAnimStateMachineUpdater::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCAnimStateMachineUpdater(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCAnimStateMachineUpdater>("CAnimStateMachineUpdater")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("States", &GCAnimStateMachineUpdater::GetStates, &GCAnimStateMachineUpdater::SetStates)
        .addProperty("Transitions", &GCAnimStateMachineUpdater::GetTransitions, &GCAnimStateMachineUpdater::SetTransitions)
        .addProperty("StartStateIndex", &GCAnimStateMachineUpdater::GetStartStateIndex, &GCAnimStateMachineUpdater::SetStartStateIndex)
        .addFunction("ToPtr", &GCAnimStateMachineUpdater::ToPtr)
        .addFunction("IsValid", &GCAnimStateMachineUpdater::IsValid)
        .endClass();
}
GCNmControlParameterFloatNode::GCNmControlParameterFloatNode(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCNmControlParameterFloatNode::GCNmControlParameterFloatNode(void *ptr) {
    m_ptr = ptr;
}
void* GCNmControlParameterFloatNode::GetPtr() {
    return m_ptr;
}
std::string GCNmControlParameterFloatNode::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCNmControlParameterFloatNode::IsValid() {
    return (m_ptr != nullptr);
}
GCNmFloatValueNode GCNmControlParameterFloatNode::GetParent() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CNmControlParameterFloatNode::GetParent(ptr=%p)", m_ptr));
    GCNmFloatValueNode value(m_ptr);
    return value;
}
void GCNmControlParameterFloatNode::SetParent(GCNmFloatValueNode value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CNmControlParameterFloatNode::SetParent(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCNmControlParameterFloatNode(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCNmControlParameterFloatNode>("CNmControlParameterFloatNode")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Parent", &GCNmControlParameterFloatNode::GetParent, &GCNmControlParameterFloatNode::SetParent)
        .addFunction("ToPtr", &GCNmControlParameterFloatNode::ToPtr)
        .addFunction("IsValid", &GCNmControlParameterFloatNode::IsValid)
        .endClass();
}
GCSeqCmdLayer::GCSeqCmdLayer(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCSeqCmdLayer::GCSeqCmdLayer(void *ptr) {
    m_ptr = ptr;
}
int16_t GCSeqCmdLayer::GetCmd() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CSeqCmdLayer->Cmd(ptr=%p)", m_ptr));
    return GetSchemaValue<int16_t>(m_ptr, "CSeqCmdLayer", "m_cmd");
}
void GCSeqCmdLayer::SetCmd(int16_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CSeqCmdLayer->Cmd(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CSeqCmdLayer", "m_cmd", false, value);
}
int16_t GCSeqCmdLayer::GetLocalReference() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CSeqCmdLayer->LocalReference(ptr=%p)", m_ptr));
    return GetSchemaValue<int16_t>(m_ptr, "CSeqCmdLayer", "m_nLocalReference");
}
void GCSeqCmdLayer::SetLocalReference(int16_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CSeqCmdLayer->LocalReference(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CSeqCmdLayer", "m_nLocalReference", false, value);
}
int16_t GCSeqCmdLayer::GetLocalBonemask() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CSeqCmdLayer->LocalBonemask(ptr=%p)", m_ptr));
    return GetSchemaValue<int16_t>(m_ptr, "CSeqCmdLayer", "m_nLocalBonemask");
}
void GCSeqCmdLayer::SetLocalBonemask(int16_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CSeqCmdLayer->LocalBonemask(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CSeqCmdLayer", "m_nLocalBonemask", false, value);
}
int16_t GCSeqCmdLayer::GetDstResult() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CSeqCmdLayer->DstResult(ptr=%p)", m_ptr));
    return GetSchemaValue<int16_t>(m_ptr, "CSeqCmdLayer", "m_nDstResult");
}
void GCSeqCmdLayer::SetDstResult(int16_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CSeqCmdLayer->DstResult(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CSeqCmdLayer", "m_nDstResult", false, value);
}
int16_t GCSeqCmdLayer::GetSrcResult() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CSeqCmdLayer->SrcResult(ptr=%p)", m_ptr));
    return GetSchemaValue<int16_t>(m_ptr, "CSeqCmdLayer", "m_nSrcResult");
}
void GCSeqCmdLayer::SetSrcResult(int16_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CSeqCmdLayer->SrcResult(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CSeqCmdLayer", "m_nSrcResult", false, value);
}
bool GCSeqCmdLayer::GetSpline() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CSeqCmdLayer->Spline(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "CSeqCmdLayer", "m_bSpline");
}
void GCSeqCmdLayer::SetSpline(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CSeqCmdLayer->Spline(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CSeqCmdLayer", "m_bSpline", false, value);
}
float GCSeqCmdLayer::GetVar1() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CSeqCmdLayer->Var1(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CSeqCmdLayer", "m_flVar1");
}
void GCSeqCmdLayer::SetVar1(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CSeqCmdLayer->Var1(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CSeqCmdLayer", "m_flVar1", false, value);
}
float GCSeqCmdLayer::GetVar2() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CSeqCmdLayer->Var2(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CSeqCmdLayer", "m_flVar2");
}
void GCSeqCmdLayer::SetVar2(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CSeqCmdLayer->Var2(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CSeqCmdLayer", "m_flVar2", false, value);
}
int16_t GCSeqCmdLayer::GetLineNumber() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CSeqCmdLayer->LineNumber(ptr=%p)", m_ptr));
    return GetSchemaValue<int16_t>(m_ptr, "CSeqCmdLayer", "m_nLineNumber");
}
void GCSeqCmdLayer::SetLineNumber(int16_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CSeqCmdLayer->LineNumber(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CSeqCmdLayer", "m_nLineNumber", false, value);
}
void* GCSeqCmdLayer::GetPtr() {
    return m_ptr;
}
std::string GCSeqCmdLayer::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCSeqCmdLayer::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCSeqCmdLayer(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCSeqCmdLayer>("CSeqCmdLayer")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Cmd", &GCSeqCmdLayer::GetCmd, &GCSeqCmdLayer::SetCmd)
        .addProperty("LocalReference", &GCSeqCmdLayer::GetLocalReference, &GCSeqCmdLayer::SetLocalReference)
        .addProperty("LocalBonemask", &GCSeqCmdLayer::GetLocalBonemask, &GCSeqCmdLayer::SetLocalBonemask)
        .addProperty("DstResult", &GCSeqCmdLayer::GetDstResult, &GCSeqCmdLayer::SetDstResult)
        .addProperty("SrcResult", &GCSeqCmdLayer::GetSrcResult, &GCSeqCmdLayer::SetSrcResult)
        .addProperty("Spline", &GCSeqCmdLayer::GetSpline, &GCSeqCmdLayer::SetSpline)
        .addProperty("Var1", &GCSeqCmdLayer::GetVar1, &GCSeqCmdLayer::SetVar1)
        .addProperty("Var2", &GCSeqCmdLayer::GetVar2, &GCSeqCmdLayer::SetVar2)
        .addProperty("LineNumber", &GCSeqCmdLayer::GetLineNumber, &GCSeqCmdLayer::SetLineNumber)
        .addFunction("ToPtr", &GCSeqCmdLayer::ToPtr)
        .addFunction("IsValid", &GCSeqCmdLayer::IsValid)
        .endClass();
}
GCAnimScriptComponentUpdater::GCAnimScriptComponentUpdater(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCAnimScriptComponentUpdater::GCAnimScriptComponentUpdater(void *ptr) {
    m_ptr = ptr;
}
GAnimScriptHandle GCAnimScriptComponentUpdater::GetScript() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CAnimScriptComponentUpdater->Script(ptr=%p)", m_ptr));
    GAnimScriptHandle value(GetSchemaPtr(m_ptr, "CAnimScriptComponentUpdater", "m_hScript"));
    return value;
}
void GCAnimScriptComponentUpdater::SetScript(GAnimScriptHandle value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CAnimScriptComponentUpdater->Script(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Script' is not possible.\n");
}
void* GCAnimScriptComponentUpdater::GetPtr() {
    return m_ptr;
}
std::string GCAnimScriptComponentUpdater::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCAnimScriptComponentUpdater::IsValid() {
    return (m_ptr != nullptr);
}
GCAnimComponentUpdater GCAnimScriptComponentUpdater::GetParent() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CAnimScriptComponentUpdater::GetParent(ptr=%p)", m_ptr));
    GCAnimComponentUpdater value(m_ptr);
    return value;
}
void GCAnimScriptComponentUpdater::SetParent(GCAnimComponentUpdater value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CAnimScriptComponentUpdater::SetParent(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCAnimScriptComponentUpdater(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCAnimScriptComponentUpdater>("CAnimScriptComponentUpdater")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Script", &GCAnimScriptComponentUpdater::GetScript, &GCAnimScriptComponentUpdater::SetScript)
        .addProperty("Parent", &GCAnimScriptComponentUpdater::GetParent, &GCAnimScriptComponentUpdater::SetParent)
        .addFunction("ToPtr", &GCAnimScriptComponentUpdater::ToPtr)
        .addFunction("IsValid", &GCAnimScriptComponentUpdater::IsValid)
        .endClass();
}
GFeRigidColliderIndices_t::GFeRigidColliderIndices_t(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GFeRigidColliderIndices_t::GFeRigidColliderIndices_t(void *ptr) {
    m_ptr = ptr;
}
uint16_t GFeRigidColliderIndices_t::GetTaperedCapsuleRigidIndex() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FeRigidColliderIndices_t->TaperedCapsuleRigidIndex(ptr=%p)", m_ptr));
    return GetSchemaValue<uint16_t>(m_ptr, "FeRigidColliderIndices_t", "m_nTaperedCapsuleRigidIndex");
}
void GFeRigidColliderIndices_t::SetTaperedCapsuleRigidIndex(uint16_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FeRigidColliderIndices_t->TaperedCapsuleRigidIndex(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "FeRigidColliderIndices_t", "m_nTaperedCapsuleRigidIndex", true, value);
}
uint16_t GFeRigidColliderIndices_t::GetSphereRigidIndex() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FeRigidColliderIndices_t->SphereRigidIndex(ptr=%p)", m_ptr));
    return GetSchemaValue<uint16_t>(m_ptr, "FeRigidColliderIndices_t", "m_nSphereRigidIndex");
}
void GFeRigidColliderIndices_t::SetSphereRigidIndex(uint16_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FeRigidColliderIndices_t->SphereRigidIndex(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "FeRigidColliderIndices_t", "m_nSphereRigidIndex", true, value);
}
uint16_t GFeRigidColliderIndices_t::GetBoxRigidIndex() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FeRigidColliderIndices_t->BoxRigidIndex(ptr=%p)", m_ptr));
    return GetSchemaValue<uint16_t>(m_ptr, "FeRigidColliderIndices_t", "m_nBoxRigidIndex");
}
void GFeRigidColliderIndices_t::SetBoxRigidIndex(uint16_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FeRigidColliderIndices_t->BoxRigidIndex(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "FeRigidColliderIndices_t", "m_nBoxRigidIndex", true, value);
}
uint16_t GFeRigidColliderIndices_t::GetCollisionPlaneIndex() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FeRigidColliderIndices_t->CollisionPlaneIndex(ptr=%p)", m_ptr));
    return GetSchemaValue<uint16_t>(m_ptr, "FeRigidColliderIndices_t", "m_nCollisionPlaneIndex");
}
void GFeRigidColliderIndices_t::SetCollisionPlaneIndex(uint16_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FeRigidColliderIndices_t->CollisionPlaneIndex(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "FeRigidColliderIndices_t", "m_nCollisionPlaneIndex", true, value);
}
void* GFeRigidColliderIndices_t::GetPtr() {
    return m_ptr;
}
std::string GFeRigidColliderIndices_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GFeRigidColliderIndices_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassFeRigidColliderIndices_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GFeRigidColliderIndices_t>("FeRigidColliderIndices_t")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("TaperedCapsuleRigidIndex", &GFeRigidColliderIndices_t::GetTaperedCapsuleRigidIndex, &GFeRigidColliderIndices_t::SetTaperedCapsuleRigidIndex)
        .addProperty("SphereRigidIndex", &GFeRigidColliderIndices_t::GetSphereRigidIndex, &GFeRigidColliderIndices_t::SetSphereRigidIndex)
        .addProperty("BoxRigidIndex", &GFeRigidColliderIndices_t::GetBoxRigidIndex, &GFeRigidColliderIndices_t::SetBoxRigidIndex)
        .addProperty("CollisionPlaneIndex", &GFeRigidColliderIndices_t::GetCollisionPlaneIndex, &GFeRigidColliderIndices_t::SetCollisionPlaneIndex)
        .addFunction("ToPtr", &GFeRigidColliderIndices_t::ToPtr)
        .addFunction("IsValid", &GFeRigidColliderIndices_t::IsValid)
        .endClass();
}
GCSeqAutoLayer::GCSeqAutoLayer(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCSeqAutoLayer::GCSeqAutoLayer(void *ptr) {
    m_ptr = ptr;
}
int16_t GCSeqAutoLayer::GetLocalReference() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CSeqAutoLayer->LocalReference(ptr=%p)", m_ptr));
    return GetSchemaValue<int16_t>(m_ptr, "CSeqAutoLayer", "m_nLocalReference");
}
void GCSeqAutoLayer::SetLocalReference(int16_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CSeqAutoLayer->LocalReference(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CSeqAutoLayer", "m_nLocalReference", false, value);
}
int16_t GCSeqAutoLayer::GetLocalPose() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CSeqAutoLayer->LocalPose(ptr=%p)", m_ptr));
    return GetSchemaValue<int16_t>(m_ptr, "CSeqAutoLayer", "m_nLocalPose");
}
void GCSeqAutoLayer::SetLocalPose(int16_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CSeqAutoLayer->LocalPose(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CSeqAutoLayer", "m_nLocalPose", false, value);
}
GCSeqAutoLayerFlag GCSeqAutoLayer::GetFlags() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CSeqAutoLayer->Flags(ptr=%p)", m_ptr));
    GCSeqAutoLayerFlag value(GetSchemaPtr(m_ptr, "CSeqAutoLayer", "m_flags"));
    return value;
}
void GCSeqAutoLayer::SetFlags(GCSeqAutoLayerFlag value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CSeqAutoLayer->Flags(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Flags' is not possible.\n");
}
float GCSeqAutoLayer::GetStart() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CSeqAutoLayer->Start(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CSeqAutoLayer", "m_start");
}
void GCSeqAutoLayer::SetStart(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CSeqAutoLayer->Start(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CSeqAutoLayer", "m_start", false, value);
}
float GCSeqAutoLayer::GetPeak() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CSeqAutoLayer->Peak(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CSeqAutoLayer", "m_peak");
}
void GCSeqAutoLayer::SetPeak(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CSeqAutoLayer->Peak(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CSeqAutoLayer", "m_peak", false, value);
}
float GCSeqAutoLayer::GetTail() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CSeqAutoLayer->Tail(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CSeqAutoLayer", "m_tail");
}
void GCSeqAutoLayer::SetTail(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CSeqAutoLayer->Tail(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CSeqAutoLayer", "m_tail", false, value);
}
float GCSeqAutoLayer::GetEnd() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CSeqAutoLayer->End(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CSeqAutoLayer", "m_end");
}
void GCSeqAutoLayer::SetEnd(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CSeqAutoLayer->End(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CSeqAutoLayer", "m_end", false, value);
}
void* GCSeqAutoLayer::GetPtr() {
    return m_ptr;
}
std::string GCSeqAutoLayer::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCSeqAutoLayer::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCSeqAutoLayer(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCSeqAutoLayer>("CSeqAutoLayer")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("LocalReference", &GCSeqAutoLayer::GetLocalReference, &GCSeqAutoLayer::SetLocalReference)
        .addProperty("LocalPose", &GCSeqAutoLayer::GetLocalPose, &GCSeqAutoLayer::SetLocalPose)
        .addProperty("Flags", &GCSeqAutoLayer::GetFlags, &GCSeqAutoLayer::SetFlags)
        .addProperty("Start", &GCSeqAutoLayer::GetStart, &GCSeqAutoLayer::SetStart)
        .addProperty("Peak", &GCSeqAutoLayer::GetPeak, &GCSeqAutoLayer::SetPeak)
        .addProperty("Tail", &GCSeqAutoLayer::GetTail, &GCSeqAutoLayer::SetTail)
        .addProperty("End", &GCSeqAutoLayer::GetEnd, &GCSeqAutoLayer::SetEnd)
        .addFunction("ToPtr", &GCSeqAutoLayer::ToPtr)
        .addFunction("IsValid", &GCSeqAutoLayer::IsValid)
        .endClass();
}
GBakedLightingInfo_t::GBakedLightingInfo_t(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GBakedLightingInfo_t::GBakedLightingInfo_t(void *ptr) {
    m_ptr = ptr;
}
uint32_t GBakedLightingInfo_t::GetLightmapVersionNumber() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: BakedLightingInfo_t->LightmapVersionNumber(ptr=%p)", m_ptr));
    return GetSchemaValue<uint32_t>(m_ptr, "BakedLightingInfo_t", "m_nLightmapVersionNumber");
}
void GBakedLightingInfo_t::SetLightmapVersionNumber(uint32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: BakedLightingInfo_t->LightmapVersionNumber(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "BakedLightingInfo_t", "m_nLightmapVersionNumber", true, value);
}
uint32_t GBakedLightingInfo_t::GetLightmapGameVersionNumber() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: BakedLightingInfo_t->LightmapGameVersionNumber(ptr=%p)", m_ptr));
    return GetSchemaValue<uint32_t>(m_ptr, "BakedLightingInfo_t", "m_nLightmapGameVersionNumber");
}
void GBakedLightingInfo_t::SetLightmapGameVersionNumber(uint32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: BakedLightingInfo_t->LightmapGameVersionNumber(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "BakedLightingInfo_t", "m_nLightmapGameVersionNumber", true, value);
}
Vector2D GBakedLightingInfo_t::GetLightmapUvScale() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: BakedLightingInfo_t->LightmapUvScale(ptr=%p)", m_ptr));
    return GetSchemaValue<Vector2D>(m_ptr, "BakedLightingInfo_t", "m_vLightmapUvScale");
}
void GBakedLightingInfo_t::SetLightmapUvScale(Vector2D value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: BakedLightingInfo_t->LightmapUvScale(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "BakedLightingInfo_t", "m_vLightmapUvScale", true, value);
}
bool GBakedLightingInfo_t::GetHasLightmaps() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: BakedLightingInfo_t->HasLightmaps(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "BakedLightingInfo_t", "m_bHasLightmaps");
}
void GBakedLightingInfo_t::SetHasLightmaps(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: BakedLightingInfo_t->HasLightmaps(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "BakedLightingInfo_t", "m_bHasLightmaps", true, value);
}
bool GBakedLightingInfo_t::GetBakedShadowsGamma20() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: BakedLightingInfo_t->BakedShadowsGamma20(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "BakedLightingInfo_t", "m_bBakedShadowsGamma20");
}
void GBakedLightingInfo_t::SetBakedShadowsGamma20(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: BakedLightingInfo_t->BakedShadowsGamma20(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "BakedLightingInfo_t", "m_bBakedShadowsGamma20", true, value);
}
bool GBakedLightingInfo_t::GetCompressionEnabled() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: BakedLightingInfo_t->CompressionEnabled(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "BakedLightingInfo_t", "m_bCompressionEnabled");
}
void GBakedLightingInfo_t::SetCompressionEnabled(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: BakedLightingInfo_t->CompressionEnabled(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "BakedLightingInfo_t", "m_bCompressionEnabled", true, value);
}
uint32_t GBakedLightingInfo_t::GetChartPackIterations() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: BakedLightingInfo_t->ChartPackIterations(ptr=%p)", m_ptr));
    return GetSchemaValue<uint32_t>(m_ptr, "BakedLightingInfo_t", "m_nChartPackIterations");
}
void GBakedLightingInfo_t::SetChartPackIterations(uint32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: BakedLightingInfo_t->ChartPackIterations(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "BakedLightingInfo_t", "m_nChartPackIterations", true, value);
}
uint32_t GBakedLightingInfo_t::GetVradQuality() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: BakedLightingInfo_t->VradQuality(ptr=%p)", m_ptr));
    return GetSchemaValue<uint32_t>(m_ptr, "BakedLightingInfo_t", "m_nVradQuality");
}
void GBakedLightingInfo_t::SetVradQuality(uint32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: BakedLightingInfo_t->VradQuality(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "BakedLightingInfo_t", "m_nVradQuality", true, value);
}
void* GBakedLightingInfo_t::GetPtr() {
    return m_ptr;
}
std::string GBakedLightingInfo_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GBakedLightingInfo_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassBakedLightingInfo_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GBakedLightingInfo_t>("BakedLightingInfo_t")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("LightmapVersionNumber", &GBakedLightingInfo_t::GetLightmapVersionNumber, &GBakedLightingInfo_t::SetLightmapVersionNumber)
        .addProperty("LightmapGameVersionNumber", &GBakedLightingInfo_t::GetLightmapGameVersionNumber, &GBakedLightingInfo_t::SetLightmapGameVersionNumber)
        .addProperty("LightmapUvScale", &GBakedLightingInfo_t::GetLightmapUvScale, &GBakedLightingInfo_t::SetLightmapUvScale)
        .addProperty("HasLightmaps", &GBakedLightingInfo_t::GetHasLightmaps, &GBakedLightingInfo_t::SetHasLightmaps)
        .addProperty("BakedShadowsGamma20", &GBakedLightingInfo_t::GetBakedShadowsGamma20, &GBakedLightingInfo_t::SetBakedShadowsGamma20)
        .addProperty("CompressionEnabled", &GBakedLightingInfo_t::GetCompressionEnabled, &GBakedLightingInfo_t::SetCompressionEnabled)
        .addProperty("ChartPackIterations", &GBakedLightingInfo_t::GetChartPackIterations, &GBakedLightingInfo_t::SetChartPackIterations)
        .addProperty("VradQuality", &GBakedLightingInfo_t::GetVradQuality, &GBakedLightingInfo_t::SetVradQuality)
        .addFunction("ToPtr", &GBakedLightingInfo_t::ToPtr)
        .addFunction("IsValid", &GBakedLightingInfo_t::IsValid)
        .endClass();
}
GCExampleSchemaVData_PolymorphicBase::GCExampleSchemaVData_PolymorphicBase(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCExampleSchemaVData_PolymorphicBase::GCExampleSchemaVData_PolymorphicBase(void *ptr) {
    m_ptr = ptr;
}
int32_t GCExampleSchemaVData_PolymorphicBase::GetBase() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CExampleSchemaVData_PolymorphicBase->Base(ptr=%p)", m_ptr));
    return GetSchemaValue<int32_t>(m_ptr, "CExampleSchemaVData_PolymorphicBase", "m_nBase");
}
void GCExampleSchemaVData_PolymorphicBase::SetBase(int32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CExampleSchemaVData_PolymorphicBase->Base(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CExampleSchemaVData_PolymorphicBase", "m_nBase", false, value);
}
void* GCExampleSchemaVData_PolymorphicBase::GetPtr() {
    return m_ptr;
}
std::string GCExampleSchemaVData_PolymorphicBase::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCExampleSchemaVData_PolymorphicBase::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCExampleSchemaVData_PolymorphicBase(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCExampleSchemaVData_PolymorphicBase>("CExampleSchemaVData_PolymorphicBase")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Base", &GCExampleSchemaVData_PolymorphicBase::GetBase, &GCExampleSchemaVData_PolymorphicBase::SetBase)
        .addFunction("ToPtr", &GCExampleSchemaVData_PolymorphicBase::ToPtr)
        .addFunction("IsValid", &GCExampleSchemaVData_PolymorphicBase::IsValid)
        .endClass();
}
GFourVectors2D::GFourVectors2D(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GFourVectors2D::GFourVectors2D(void *ptr) {
    m_ptr = ptr;
}
float GFourVectors2D::GetX() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FourVectors2D->X(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "FourVectors2D", "x");
}
void GFourVectors2D::SetX(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FourVectors2D->X(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "FourVectors2D", "x", false, value);
}
float GFourVectors2D::GetY() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FourVectors2D->Y(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "FourVectors2D", "y");
}
void GFourVectors2D::SetY(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FourVectors2D->Y(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "FourVectors2D", "y", false, value);
}
void* GFourVectors2D::GetPtr() {
    return m_ptr;
}
std::string GFourVectors2D::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GFourVectors2D::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassFourVectors2D(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GFourVectors2D>("FourVectors2D")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("X", &GFourVectors2D::GetX, &GFourVectors2D::SetX)
        .addProperty("Y", &GFourVectors2D::GetY, &GFourVectors2D::SetY)
        .addFunction("ToPtr", &GFourVectors2D::ToPtr)
        .addFunction("IsValid", &GFourVectors2D::IsValid)
        .endClass();
}
GCOrientConstraint::GCOrientConstraint(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCOrientConstraint::GCOrientConstraint(void *ptr) {
    m_ptr = ptr;
}
void* GCOrientConstraint::GetPtr() {
    return m_ptr;
}
std::string GCOrientConstraint::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCOrientConstraint::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseConstraint GCOrientConstraint::GetParent() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("COrientConstraint::GetParent(ptr=%p)", m_ptr));
    GCBaseConstraint value(m_ptr);
    return value;
}
void GCOrientConstraint::SetParent(GCBaseConstraint value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("COrientConstraint::SetParent(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCOrientConstraint(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCOrientConstraint>("COrientConstraint")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Parent", &GCOrientConstraint::GetParent, &GCOrientConstraint::SetParent)
        .addFunction("ToPtr", &GCOrientConstraint::ToPtr)
        .addFunction("IsValid", &GCOrientConstraint::IsValid)
        .endClass();
}
GSequenceWeightedList_t::GSequenceWeightedList_t(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GSequenceWeightedList_t::GSequenceWeightedList_t(void *ptr) {
    m_ptr = ptr;
}
int32_t GSequenceWeightedList_t::GetSequence() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: SequenceWeightedList_t->Sequence(ptr=%p)", m_ptr));
    return GetSchemaValue<int32_t>(m_ptr, "SequenceWeightedList_t", "m_nSequence");
}
void GSequenceWeightedList_t::SetSequence(int32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: SequenceWeightedList_t->Sequence(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "SequenceWeightedList_t", "m_nSequence", true, value);
}
float GSequenceWeightedList_t::GetRelativeWeight() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: SequenceWeightedList_t->RelativeWeight(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "SequenceWeightedList_t", "m_flRelativeWeight");
}
void GSequenceWeightedList_t::SetRelativeWeight(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: SequenceWeightedList_t->RelativeWeight(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "SequenceWeightedList_t", "m_flRelativeWeight", true, value);
}
void* GSequenceWeightedList_t::GetPtr() {
    return m_ptr;
}
std::string GSequenceWeightedList_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GSequenceWeightedList_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassSequenceWeightedList_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GSequenceWeightedList_t>("SequenceWeightedList_t")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Sequence", &GSequenceWeightedList_t::GetSequence, &GSequenceWeightedList_t::SetSequence)
        .addProperty("RelativeWeight", &GSequenceWeightedList_t::GetRelativeWeight, &GSequenceWeightedList_t::SetRelativeWeight)
        .addFunction("ToPtr", &GSequenceWeightedList_t::ToPtr)
        .addFunction("IsValid", &GSequenceWeightedList_t::IsValid)
        .endClass();
}
GCSosGroupActionMemberCountEnvelopeSchema::GCSosGroupActionMemberCountEnvelopeSchema(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCSosGroupActionMemberCountEnvelopeSchema::GCSosGroupActionMemberCountEnvelopeSchema(void *ptr) {
    m_ptr = ptr;
}
int32_t GCSosGroupActionMemberCountEnvelopeSchema::GetBaseCount() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CSosGroupActionMemberCountEnvelopeSchema->BaseCount(ptr=%p)", m_ptr));
    return GetSchemaValue<int32_t>(m_ptr, "CSosGroupActionMemberCountEnvelopeSchema", "m_nBaseCount");
}
void GCSosGroupActionMemberCountEnvelopeSchema::SetBaseCount(int32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CSosGroupActionMemberCountEnvelopeSchema->BaseCount(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CSosGroupActionMemberCountEnvelopeSchema", "m_nBaseCount", false, value);
}
int32_t GCSosGroupActionMemberCountEnvelopeSchema::GetTargetCount() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CSosGroupActionMemberCountEnvelopeSchema->TargetCount(ptr=%p)", m_ptr));
    return GetSchemaValue<int32_t>(m_ptr, "CSosGroupActionMemberCountEnvelopeSchema", "m_nTargetCount");
}
void GCSosGroupActionMemberCountEnvelopeSchema::SetTargetCount(int32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CSosGroupActionMemberCountEnvelopeSchema->TargetCount(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CSosGroupActionMemberCountEnvelopeSchema", "m_nTargetCount", false, value);
}
float GCSosGroupActionMemberCountEnvelopeSchema::GetBaseValue() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CSosGroupActionMemberCountEnvelopeSchema->BaseValue(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CSosGroupActionMemberCountEnvelopeSchema", "m_flBaseValue");
}
void GCSosGroupActionMemberCountEnvelopeSchema::SetBaseValue(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CSosGroupActionMemberCountEnvelopeSchema->BaseValue(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CSosGroupActionMemberCountEnvelopeSchema", "m_flBaseValue", false, value);
}
float GCSosGroupActionMemberCountEnvelopeSchema::GetTargetValue() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CSosGroupActionMemberCountEnvelopeSchema->TargetValue(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CSosGroupActionMemberCountEnvelopeSchema", "m_flTargetValue");
}
void GCSosGroupActionMemberCountEnvelopeSchema::SetTargetValue(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CSosGroupActionMemberCountEnvelopeSchema->TargetValue(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CSosGroupActionMemberCountEnvelopeSchema", "m_flTargetValue", false, value);
}
float GCSosGroupActionMemberCountEnvelopeSchema::GetAttack() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CSosGroupActionMemberCountEnvelopeSchema->Attack(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CSosGroupActionMemberCountEnvelopeSchema", "m_flAttack");
}
void GCSosGroupActionMemberCountEnvelopeSchema::SetAttack(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CSosGroupActionMemberCountEnvelopeSchema->Attack(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CSosGroupActionMemberCountEnvelopeSchema", "m_flAttack", false, value);
}
float GCSosGroupActionMemberCountEnvelopeSchema::GetDecay() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CSosGroupActionMemberCountEnvelopeSchema->Decay(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CSosGroupActionMemberCountEnvelopeSchema", "m_flDecay");
}
void GCSosGroupActionMemberCountEnvelopeSchema::SetDecay(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CSosGroupActionMemberCountEnvelopeSchema->Decay(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CSosGroupActionMemberCountEnvelopeSchema", "m_flDecay", false, value);
}
std::string GCSosGroupActionMemberCountEnvelopeSchema::GetResultVarName() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CSosGroupActionMemberCountEnvelopeSchema->ResultVarName(ptr=%p)", m_ptr));
    return GetSchemaValue<CUtlString>(m_ptr, "CSosGroupActionMemberCountEnvelopeSchema", "m_resultVarName").Get();
}
void GCSosGroupActionMemberCountEnvelopeSchema::SetResultVarName(std::string value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CSosGroupActionMemberCountEnvelopeSchema->ResultVarName(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CSosGroupActionMemberCountEnvelopeSchema", "m_resultVarName", false, CUtlString(value.c_str()));
}
bool GCSosGroupActionMemberCountEnvelopeSchema::GetSaveToGroup() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CSosGroupActionMemberCountEnvelopeSchema->SaveToGroup(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "CSosGroupActionMemberCountEnvelopeSchema", "m_bSaveToGroup");
}
void GCSosGroupActionMemberCountEnvelopeSchema::SetSaveToGroup(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CSosGroupActionMemberCountEnvelopeSchema->SaveToGroup(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CSosGroupActionMemberCountEnvelopeSchema", "m_bSaveToGroup", false, value);
}
void* GCSosGroupActionMemberCountEnvelopeSchema::GetPtr() {
    return m_ptr;
}
std::string GCSosGroupActionMemberCountEnvelopeSchema::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCSosGroupActionMemberCountEnvelopeSchema::IsValid() {
    return (m_ptr != nullptr);
}
GCSosGroupActionSchema GCSosGroupActionMemberCountEnvelopeSchema::GetParent() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CSosGroupActionMemberCountEnvelopeSchema::GetParent(ptr=%p)", m_ptr));
    GCSosGroupActionSchema value(m_ptr);
    return value;
}
void GCSosGroupActionMemberCountEnvelopeSchema::SetParent(GCSosGroupActionSchema value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CSosGroupActionMemberCountEnvelopeSchema::SetParent(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCSosGroupActionMemberCountEnvelopeSchema(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCSosGroupActionMemberCountEnvelopeSchema>("CSosGroupActionMemberCountEnvelopeSchema")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("BaseCount", &GCSosGroupActionMemberCountEnvelopeSchema::GetBaseCount, &GCSosGroupActionMemberCountEnvelopeSchema::SetBaseCount)
        .addProperty("TargetCount", &GCSosGroupActionMemberCountEnvelopeSchema::GetTargetCount, &GCSosGroupActionMemberCountEnvelopeSchema::SetTargetCount)
        .addProperty("BaseValue", &GCSosGroupActionMemberCountEnvelopeSchema::GetBaseValue, &GCSosGroupActionMemberCountEnvelopeSchema::SetBaseValue)
        .addProperty("TargetValue", &GCSosGroupActionMemberCountEnvelopeSchema::GetTargetValue, &GCSosGroupActionMemberCountEnvelopeSchema::SetTargetValue)
        .addProperty("Attack", &GCSosGroupActionMemberCountEnvelopeSchema::GetAttack, &GCSosGroupActionMemberCountEnvelopeSchema::SetAttack)
        .addProperty("Decay", &GCSosGroupActionMemberCountEnvelopeSchema::GetDecay, &GCSosGroupActionMemberCountEnvelopeSchema::SetDecay)
        .addProperty("ResultVarName", &GCSosGroupActionMemberCountEnvelopeSchema::GetResultVarName, &GCSosGroupActionMemberCountEnvelopeSchema::SetResultVarName)
        .addProperty("SaveToGroup", &GCSosGroupActionMemberCountEnvelopeSchema::GetSaveToGroup, &GCSosGroupActionMemberCountEnvelopeSchema::SetSaveToGroup)
        .addProperty("Parent", &GCSosGroupActionMemberCountEnvelopeSchema::GetParent, &GCSosGroupActionMemberCountEnvelopeSchema::SetParent)
        .addFunction("ToPtr", &GCSosGroupActionMemberCountEnvelopeSchema::ToPtr)
        .addFunction("IsValid", &GCSosGroupActionMemberCountEnvelopeSchema::IsValid)
        .endClass();
}
GFeRodConstraint_t::GFeRodConstraint_t(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GFeRodConstraint_t::GFeRodConstraint_t(void *ptr) {
    m_ptr = ptr;
}
std::vector<uint16_t> GFeRodConstraint_t::GetNode() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FeRodConstraint_t->Node(ptr=%p,size=2)", m_ptr));
    uint16_t* outValue = (uint16_t*)GetSchemaPtr(m_ptr, "FeRodConstraint_t", "nNode"); std::vector<uint16_t> ret; for(int i = 0; i < 2; i++) { ret.push_back(outValue[i]); } return ret;
}
void GFeRodConstraint_t::SetNode(std::vector<uint16_t> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FeRodConstraint_t->Node(ptr=%p,size=2)", m_ptr));
    if(value.size() != 2) return PLUGIN_PRINT("Schema SDK", "Field 'Node' needs to have 2 values.\n");
    auto val = GetSchemaValuePtr<uint16_t>(m_ptr, "FeRodConstraint_t", "nNode");
    for(size_t i = 0; i < value.size(); i++) val[i] = value[i];
}
float GFeRodConstraint_t::GetMaxDist() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FeRodConstraint_t->MaxDist(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "FeRodConstraint_t", "flMaxDist");
}
void GFeRodConstraint_t::SetMaxDist(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FeRodConstraint_t->MaxDist(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "FeRodConstraint_t", "flMaxDist", true, value);
}
float GFeRodConstraint_t::GetMinDist() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FeRodConstraint_t->MinDist(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "FeRodConstraint_t", "flMinDist");
}
void GFeRodConstraint_t::SetMinDist(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FeRodConstraint_t->MinDist(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "FeRodConstraint_t", "flMinDist", true, value);
}
float GFeRodConstraint_t::GetWeight0() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FeRodConstraint_t->Weight0(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "FeRodConstraint_t", "flWeight0");
}
void GFeRodConstraint_t::SetWeight0(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FeRodConstraint_t->Weight0(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "FeRodConstraint_t", "flWeight0", true, value);
}
float GFeRodConstraint_t::GetRelaxationFactor() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FeRodConstraint_t->RelaxationFactor(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "FeRodConstraint_t", "flRelaxationFactor");
}
void GFeRodConstraint_t::SetRelaxationFactor(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FeRodConstraint_t->RelaxationFactor(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "FeRodConstraint_t", "flRelaxationFactor", true, value);
}
void* GFeRodConstraint_t::GetPtr() {
    return m_ptr;
}
std::string GFeRodConstraint_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GFeRodConstraint_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassFeRodConstraint_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GFeRodConstraint_t>("FeRodConstraint_t")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Node", &GFeRodConstraint_t::GetNode, &GFeRodConstraint_t::SetNode)
        .addProperty("MaxDist", &GFeRodConstraint_t::GetMaxDist, &GFeRodConstraint_t::SetMaxDist)
        .addProperty("MinDist", &GFeRodConstraint_t::GetMinDist, &GFeRodConstraint_t::SetMinDist)
        .addProperty("Weight0", &GFeRodConstraint_t::GetWeight0, &GFeRodConstraint_t::SetWeight0)
        .addProperty("RelaxationFactor", &GFeRodConstraint_t::GetRelaxationFactor, &GFeRodConstraint_t::SetRelaxationFactor)
        .addFunction("ToPtr", &GFeRodConstraint_t::ToPtr)
        .addFunction("IsValid", &GFeRodConstraint_t::IsValid)
        .endClass();
}
GFollowTargetOpFixedSettings_t::GFollowTargetOpFixedSettings_t(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GFollowTargetOpFixedSettings_t::GFollowTargetOpFixedSettings_t(void *ptr) {
    m_ptr = ptr;
}
int32_t GFollowTargetOpFixedSettings_t::GetBoneIndex() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FollowTargetOpFixedSettings_t->BoneIndex(ptr=%p)", m_ptr));
    return GetSchemaValue<int32_t>(m_ptr, "FollowTargetOpFixedSettings_t", "m_boneIndex");
}
void GFollowTargetOpFixedSettings_t::SetBoneIndex(int32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FollowTargetOpFixedSettings_t->BoneIndex(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "FollowTargetOpFixedSettings_t", "m_boneIndex", true, value);
}
bool GFollowTargetOpFixedSettings_t::GetBoneTarget() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FollowTargetOpFixedSettings_t->BoneTarget(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "FollowTargetOpFixedSettings_t", "m_bBoneTarget");
}
void GFollowTargetOpFixedSettings_t::SetBoneTarget(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FollowTargetOpFixedSettings_t->BoneTarget(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "FollowTargetOpFixedSettings_t", "m_bBoneTarget", true, value);
}
int32_t GFollowTargetOpFixedSettings_t::GetBoneTargetIndex() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FollowTargetOpFixedSettings_t->BoneTargetIndex(ptr=%p)", m_ptr));
    return GetSchemaValue<int32_t>(m_ptr, "FollowTargetOpFixedSettings_t", "m_boneTargetIndex");
}
void GFollowTargetOpFixedSettings_t::SetBoneTargetIndex(int32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FollowTargetOpFixedSettings_t->BoneTargetIndex(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "FollowTargetOpFixedSettings_t", "m_boneTargetIndex", true, value);
}
bool GFollowTargetOpFixedSettings_t::GetWorldCoodinateTarget() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FollowTargetOpFixedSettings_t->WorldCoodinateTarget(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "FollowTargetOpFixedSettings_t", "m_bWorldCoodinateTarget");
}
void GFollowTargetOpFixedSettings_t::SetWorldCoodinateTarget(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FollowTargetOpFixedSettings_t->WorldCoodinateTarget(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "FollowTargetOpFixedSettings_t", "m_bWorldCoodinateTarget", true, value);
}
bool GFollowTargetOpFixedSettings_t::GetMatchTargetOrientation() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: FollowTargetOpFixedSettings_t->MatchTargetOrientation(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "FollowTargetOpFixedSettings_t", "m_bMatchTargetOrientation");
}
void GFollowTargetOpFixedSettings_t::SetMatchTargetOrientation(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: FollowTargetOpFixedSettings_t->MatchTargetOrientation(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "FollowTargetOpFixedSettings_t", "m_bMatchTargetOrientation", true, value);
}
void* GFollowTargetOpFixedSettings_t::GetPtr() {
    return m_ptr;
}
std::string GFollowTargetOpFixedSettings_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GFollowTargetOpFixedSettings_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassFollowTargetOpFixedSettings_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GFollowTargetOpFixedSettings_t>("FollowTargetOpFixedSettings_t")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("BoneIndex", &GFollowTargetOpFixedSettings_t::GetBoneIndex, &GFollowTargetOpFixedSettings_t::SetBoneIndex)
        .addProperty("BoneTarget", &GFollowTargetOpFixedSettings_t::GetBoneTarget, &GFollowTargetOpFixedSettings_t::SetBoneTarget)
        .addProperty("BoneTargetIndex", &GFollowTargetOpFixedSettings_t::GetBoneTargetIndex, &GFollowTargetOpFixedSettings_t::SetBoneTargetIndex)
        .addProperty("WorldCoodinateTarget", &GFollowTargetOpFixedSettings_t::GetWorldCoodinateTarget, &GFollowTargetOpFixedSettings_t::SetWorldCoodinateTarget)
        .addProperty("MatchTargetOrientation", &GFollowTargetOpFixedSettings_t::GetMatchTargetOrientation, &GFollowTargetOpFixedSettings_t::SetMatchTargetOrientation)
        .addFunction("ToPtr", &GFollowTargetOpFixedSettings_t::ToPtr)
        .addFunction("IsValid", &GFollowTargetOpFixedSettings_t::IsValid)
        .endClass();
}
GCRenderSkeleton::GCRenderSkeleton(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCRenderSkeleton::GCRenderSkeleton(void *ptr) {
    m_ptr = ptr;
}
std::vector<GRenderSkeletonBone_t> GCRenderSkeleton::GetBones() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CRenderSkeleton->Bones(ptr=%p)", m_ptr));
    CUtlVector<GRenderSkeletonBone_t>* vec = GetSchemaValue<CUtlVector<GRenderSkeletonBone_t>*>(m_ptr, "CRenderSkeleton", "m_bones"); std::vector<GRenderSkeletonBone_t> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCRenderSkeleton::SetBones(std::vector<GRenderSkeletonBone_t> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CRenderSkeleton->Bones(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<GRenderSkeletonBone_t>(m_ptr, "CRenderSkeleton", "m_bones", false, value);
}
std::vector<int32> GCRenderSkeleton::GetBoneParents() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CRenderSkeleton->BoneParents(ptr=%p)", m_ptr));
    CUtlVector<int32>* vec = GetSchemaValue<CUtlVector<int32>*>(m_ptr, "CRenderSkeleton", "m_boneParents"); std::vector<int32> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCRenderSkeleton::SetBoneParents(std::vector<int32> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CRenderSkeleton->BoneParents(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<int32>(m_ptr, "CRenderSkeleton", "m_boneParents", false, value);
}
int32_t GCRenderSkeleton::GetBoneWeightCount() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CRenderSkeleton->BoneWeightCount(ptr=%p)", m_ptr));
    return GetSchemaValue<int32_t>(m_ptr, "CRenderSkeleton", "m_nBoneWeightCount");
}
void GCRenderSkeleton::SetBoneWeightCount(int32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CRenderSkeleton->BoneWeightCount(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CRenderSkeleton", "m_nBoneWeightCount", false, value);
}
void* GCRenderSkeleton::GetPtr() {
    return m_ptr;
}
std::string GCRenderSkeleton::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCRenderSkeleton::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCRenderSkeleton(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCRenderSkeleton>("CRenderSkeleton")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Bones", &GCRenderSkeleton::GetBones, &GCRenderSkeleton::SetBones)
        .addProperty("BoneParents", &GCRenderSkeleton::GetBoneParents, &GCRenderSkeleton::SetBoneParents)
        .addProperty("BoneWeightCount", &GCRenderSkeleton::GetBoneWeightCount, &GCRenderSkeleton::SetBoneWeightCount)
        .addFunction("ToPtr", &GCRenderSkeleton::ToPtr)
        .addFunction("IsValid", &GCRenderSkeleton::IsValid)
        .endClass();
}
GVMixConvolutionDesc_t::GVMixConvolutionDesc_t(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GVMixConvolutionDesc_t::GVMixConvolutionDesc_t(void *ptr) {
    m_ptr = ptr;
}
float GVMixConvolutionDesc_t::GetFldbGain() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: VMixConvolutionDesc_t->FldbGain(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "VMixConvolutionDesc_t", "m_fldbGain");
}
void GVMixConvolutionDesc_t::SetFldbGain(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: VMixConvolutionDesc_t->FldbGain(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "VMixConvolutionDesc_t", "m_fldbGain", true, value);
}
float GVMixConvolutionDesc_t::GetPreDelayMS() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: VMixConvolutionDesc_t->PreDelayMS(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "VMixConvolutionDesc_t", "m_flPreDelayMS");
}
void GVMixConvolutionDesc_t::SetPreDelayMS(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: VMixConvolutionDesc_t->PreDelayMS(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "VMixConvolutionDesc_t", "m_flPreDelayMS", true, value);
}
float GVMixConvolutionDesc_t::GetWetMix() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: VMixConvolutionDesc_t->WetMix(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "VMixConvolutionDesc_t", "m_flWetMix");
}
void GVMixConvolutionDesc_t::SetWetMix(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: VMixConvolutionDesc_t->WetMix(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "VMixConvolutionDesc_t", "m_flWetMix", true, value);
}
float GVMixConvolutionDesc_t::GetFldbLow() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: VMixConvolutionDesc_t->FldbLow(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "VMixConvolutionDesc_t", "m_fldbLow");
}
void GVMixConvolutionDesc_t::SetFldbLow(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: VMixConvolutionDesc_t->FldbLow(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "VMixConvolutionDesc_t", "m_fldbLow", true, value);
}
float GVMixConvolutionDesc_t::GetFldbMid() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: VMixConvolutionDesc_t->FldbMid(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "VMixConvolutionDesc_t", "m_fldbMid");
}
void GVMixConvolutionDesc_t::SetFldbMid(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: VMixConvolutionDesc_t->FldbMid(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "VMixConvolutionDesc_t", "m_fldbMid", true, value);
}
float GVMixConvolutionDesc_t::GetFldbHigh() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: VMixConvolutionDesc_t->FldbHigh(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "VMixConvolutionDesc_t", "m_fldbHigh");
}
void GVMixConvolutionDesc_t::SetFldbHigh(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: VMixConvolutionDesc_t->FldbHigh(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "VMixConvolutionDesc_t", "m_fldbHigh", true, value);
}
float GVMixConvolutionDesc_t::GetLowCutoffFreq() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: VMixConvolutionDesc_t->LowCutoffFreq(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "VMixConvolutionDesc_t", "m_flLowCutoffFreq");
}
void GVMixConvolutionDesc_t::SetLowCutoffFreq(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: VMixConvolutionDesc_t->LowCutoffFreq(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "VMixConvolutionDesc_t", "m_flLowCutoffFreq", true, value);
}
float GVMixConvolutionDesc_t::GetHighCutoffFreq() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: VMixConvolutionDesc_t->HighCutoffFreq(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "VMixConvolutionDesc_t", "m_flHighCutoffFreq");
}
void GVMixConvolutionDesc_t::SetHighCutoffFreq(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: VMixConvolutionDesc_t->HighCutoffFreq(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "VMixConvolutionDesc_t", "m_flHighCutoffFreq", true, value);
}
void* GVMixConvolutionDesc_t::GetPtr() {
    return m_ptr;
}
std::string GVMixConvolutionDesc_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GVMixConvolutionDesc_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassVMixConvolutionDesc_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GVMixConvolutionDesc_t>("VMixConvolutionDesc_t")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("FldbGain", &GVMixConvolutionDesc_t::GetFldbGain, &GVMixConvolutionDesc_t::SetFldbGain)
        .addProperty("PreDelayMS", &GVMixConvolutionDesc_t::GetPreDelayMS, &GVMixConvolutionDesc_t::SetPreDelayMS)
        .addProperty("WetMix", &GVMixConvolutionDesc_t::GetWetMix, &GVMixConvolutionDesc_t::SetWetMix)
        .addProperty("FldbLow", &GVMixConvolutionDesc_t::GetFldbLow, &GVMixConvolutionDesc_t::SetFldbLow)
        .addProperty("FldbMid", &GVMixConvolutionDesc_t::GetFldbMid, &GVMixConvolutionDesc_t::SetFldbMid)
        .addProperty("FldbHigh", &GVMixConvolutionDesc_t::GetFldbHigh, &GVMixConvolutionDesc_t::SetFldbHigh)
        .addProperty("LowCutoffFreq", &GVMixConvolutionDesc_t::GetLowCutoffFreq, &GVMixConvolutionDesc_t::SetLowCutoffFreq)
        .addProperty("HighCutoffFreq", &GVMixConvolutionDesc_t::GetHighCutoffFreq, &GVMixConvolutionDesc_t::SetHighCutoffFreq)
        .addFunction("ToPtr", &GVMixConvolutionDesc_t::ToPtr)
        .addFunction("IsValid", &GVMixConvolutionDesc_t::IsValid)
        .endClass();
}
GCSosGroupBranchPattern::GCSosGroupBranchPattern(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCSosGroupBranchPattern::GCSosGroupBranchPattern(void *ptr) {
    m_ptr = ptr;
}
bool GCSosGroupBranchPattern::GetMatchEventName() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CSosGroupBranchPattern->MatchEventName(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "CSosGroupBranchPattern", "m_bMatchEventName");
}
void GCSosGroupBranchPattern::SetMatchEventName(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CSosGroupBranchPattern->MatchEventName(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CSosGroupBranchPattern", "m_bMatchEventName", false, value);
}
bool GCSosGroupBranchPattern::GetMatchEventSubString() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CSosGroupBranchPattern->MatchEventSubString(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "CSosGroupBranchPattern", "m_bMatchEventSubString");
}
void GCSosGroupBranchPattern::SetMatchEventSubString(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CSosGroupBranchPattern->MatchEventSubString(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CSosGroupBranchPattern", "m_bMatchEventSubString", false, value);
}
bool GCSosGroupBranchPattern::GetMatchEntIndex() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CSosGroupBranchPattern->MatchEntIndex(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "CSosGroupBranchPattern", "m_bMatchEntIndex");
}
void GCSosGroupBranchPattern::SetMatchEntIndex(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CSosGroupBranchPattern->MatchEntIndex(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CSosGroupBranchPattern", "m_bMatchEntIndex", false, value);
}
bool GCSosGroupBranchPattern::GetMatchOpvar() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CSosGroupBranchPattern->MatchOpvar(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "CSosGroupBranchPattern", "m_bMatchOpvar");
}
void GCSosGroupBranchPattern::SetMatchOpvar(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CSosGroupBranchPattern->MatchOpvar(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CSosGroupBranchPattern", "m_bMatchOpvar", false, value);
}
bool GCSosGroupBranchPattern::GetMatchString() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CSosGroupBranchPattern->MatchString(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "CSosGroupBranchPattern", "m_bMatchString");
}
void GCSosGroupBranchPattern::SetMatchString(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CSosGroupBranchPattern->MatchString(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CSosGroupBranchPattern", "m_bMatchString", false, value);
}
void* GCSosGroupBranchPattern::GetPtr() {
    return m_ptr;
}
std::string GCSosGroupBranchPattern::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCSosGroupBranchPattern::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCSosGroupBranchPattern(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCSosGroupBranchPattern>("CSosGroupBranchPattern")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("MatchEventName", &GCSosGroupBranchPattern::GetMatchEventName, &GCSosGroupBranchPattern::SetMatchEventName)
        .addProperty("MatchEventSubString", &GCSosGroupBranchPattern::GetMatchEventSubString, &GCSosGroupBranchPattern::SetMatchEventSubString)
        .addProperty("MatchEntIndex", &GCSosGroupBranchPattern::GetMatchEntIndex, &GCSosGroupBranchPattern::SetMatchEntIndex)
        .addProperty("MatchOpvar", &GCSosGroupBranchPattern::GetMatchOpvar, &GCSosGroupBranchPattern::SetMatchOpvar)
        .addProperty("MatchString", &GCSosGroupBranchPattern::GetMatchString, &GCSosGroupBranchPattern::SetMatchString)
        .addFunction("ToPtr", &GCSosGroupBranchPattern::ToPtr)
        .addFunction("IsValid", &GCSosGroupBranchPattern::IsValid)
        .endClass();
}
GCNmGraphDefinition__ExternalGraphSlot_t::GCNmGraphDefinition__ExternalGraphSlot_t(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCNmGraphDefinition__ExternalGraphSlot_t::GCNmGraphDefinition__ExternalGraphSlot_t(void *ptr) {
    m_ptr = ptr;
}
int16_t GCNmGraphDefinition__ExternalGraphSlot_t::GetNodeIdx() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CNmGraphDefinition__ExternalGraphSlot_t->NodeIdx(ptr=%p)", m_ptr));
    return GetSchemaValue<int16_t>(m_ptr, "CNmGraphDefinition__ExternalGraphSlot_t", "m_nNodeIdx");
}
void GCNmGraphDefinition__ExternalGraphSlot_t::SetNodeIdx(int16_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CNmGraphDefinition__ExternalGraphSlot_t->NodeIdx(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CNmGraphDefinition__ExternalGraphSlot_t", "m_nNodeIdx", true, value);
}
void* GCNmGraphDefinition__ExternalGraphSlot_t::GetPtr() {
    return m_ptr;
}
std::string GCNmGraphDefinition__ExternalGraphSlot_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCNmGraphDefinition__ExternalGraphSlot_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCNmGraphDefinition__ExternalGraphSlot_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCNmGraphDefinition__ExternalGraphSlot_t>("CNmGraphDefinition__ExternalGraphSlot_t")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("NodeIdx", &GCNmGraphDefinition__ExternalGraphSlot_t::GetNodeIdx, &GCNmGraphDefinition__ExternalGraphSlot_t::SetNodeIdx)
        .addFunction("ToPtr", &GCNmGraphDefinition__ExternalGraphSlot_t::ToPtr)
        .addFunction("IsValid", &GCNmGraphDefinition__ExternalGraphSlot_t::IsValid)
        .endClass();
}
GCNmStateMachineNode__StateDefinition_t::GCNmStateMachineNode__StateDefinition_t(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCNmStateMachineNode__StateDefinition_t::GCNmStateMachineNode__StateDefinition_t(void *ptr) {
    m_ptr = ptr;
}
int16_t GCNmStateMachineNode__StateDefinition_t::GetStateNodeIdx() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CNmStateMachineNode__StateDefinition_t->StateNodeIdx(ptr=%p)", m_ptr));
    return GetSchemaValue<int16_t>(m_ptr, "CNmStateMachineNode__StateDefinition_t", "m_nStateNodeIdx");
}
void GCNmStateMachineNode__StateDefinition_t::SetStateNodeIdx(int16_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CNmStateMachineNode__StateDefinition_t->StateNodeIdx(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CNmStateMachineNode__StateDefinition_t", "m_nStateNodeIdx", true, value);
}
int16_t GCNmStateMachineNode__StateDefinition_t::GetEntryConditionNodeIdx() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CNmStateMachineNode__StateDefinition_t->EntryConditionNodeIdx(ptr=%p)", m_ptr));
    return GetSchemaValue<int16_t>(m_ptr, "CNmStateMachineNode__StateDefinition_t", "m_entryConditionNodeIdx");
}
void GCNmStateMachineNode__StateDefinition_t::SetEntryConditionNodeIdx(int16_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CNmStateMachineNode__StateDefinition_t->EntryConditionNodeIdx(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CNmStateMachineNode__StateDefinition_t", "m_entryConditionNodeIdx", true, value);
}
void* GCNmStateMachineNode__StateDefinition_t::GetPtr() {
    return m_ptr;
}
std::string GCNmStateMachineNode__StateDefinition_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCNmStateMachineNode__StateDefinition_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCNmStateMachineNode__StateDefinition_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCNmStateMachineNode__StateDefinition_t>("CNmStateMachineNode__StateDefinition_t")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("StateNodeIdx", &GCNmStateMachineNode__StateDefinition_t::GetStateNodeIdx, &GCNmStateMachineNode__StateDefinition_t::SetStateNodeIdx)
        .addProperty("EntryConditionNodeIdx", &GCNmStateMachineNode__StateDefinition_t::GetEntryConditionNodeIdx, &GCNmStateMachineNode__StateDefinition_t::SetEntryConditionNodeIdx)
        .addFunction("ToPtr", &GCNmStateMachineNode__StateDefinition_t::ToPtr)
        .addFunction("IsValid", &GCNmStateMachineNode__StateDefinition_t::IsValid)
        .endClass();
}
GCModelConfigElement_SetBodygroupOnAttachedModels::GCModelConfigElement_SetBodygroupOnAttachedModels(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCModelConfigElement_SetBodygroupOnAttachedModels::GCModelConfigElement_SetBodygroupOnAttachedModels(void *ptr) {
    m_ptr = ptr;
}
std::string GCModelConfigElement_SetBodygroupOnAttachedModels::GetGroupName() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CModelConfigElement_SetBodygroupOnAttachedModels->GroupName(ptr=%p)", m_ptr));
    return GetSchemaValue<CUtlString>(m_ptr, "CModelConfigElement_SetBodygroupOnAttachedModels", "m_GroupName").Get();
}
void GCModelConfigElement_SetBodygroupOnAttachedModels::SetGroupName(std::string value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CModelConfigElement_SetBodygroupOnAttachedModels->GroupName(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CModelConfigElement_SetBodygroupOnAttachedModels", "m_GroupName", false, CUtlString(value.c_str()));
}
int32_t GCModelConfigElement_SetBodygroupOnAttachedModels::GetChoice() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CModelConfigElement_SetBodygroupOnAttachedModels->Choice(ptr=%p)", m_ptr));
    return GetSchemaValue<int32_t>(m_ptr, "CModelConfigElement_SetBodygroupOnAttachedModels", "m_nChoice");
}
void GCModelConfigElement_SetBodygroupOnAttachedModels::SetChoice(int32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CModelConfigElement_SetBodygroupOnAttachedModels->Choice(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CModelConfigElement_SetBodygroupOnAttachedModels", "m_nChoice", false, value);
}
void* GCModelConfigElement_SetBodygroupOnAttachedModels::GetPtr() {
    return m_ptr;
}
std::string GCModelConfigElement_SetBodygroupOnAttachedModels::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCModelConfigElement_SetBodygroupOnAttachedModels::IsValid() {
    return (m_ptr != nullptr);
}
GCModelConfigElement GCModelConfigElement_SetBodygroupOnAttachedModels::GetParent() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CModelConfigElement_SetBodygroupOnAttachedModels::GetParent(ptr=%p)", m_ptr));
    GCModelConfigElement value(m_ptr);
    return value;
}
void GCModelConfigElement_SetBodygroupOnAttachedModels::SetParent(GCModelConfigElement value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CModelConfigElement_SetBodygroupOnAttachedModels::SetParent(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCModelConfigElement_SetBodygroupOnAttachedModels(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCModelConfigElement_SetBodygroupOnAttachedModels>("CModelConfigElement_SetBodygroupOnAttachedModels")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("GroupName", &GCModelConfigElement_SetBodygroupOnAttachedModels::GetGroupName, &GCModelConfigElement_SetBodygroupOnAttachedModels::SetGroupName)
        .addProperty("Choice", &GCModelConfigElement_SetBodygroupOnAttachedModels::GetChoice, &GCModelConfigElement_SetBodygroupOnAttachedModels::SetChoice)
        .addProperty("Parent", &GCModelConfigElement_SetBodygroupOnAttachedModels::GetParent, &GCModelConfigElement_SetBodygroupOnAttachedModels::SetParent)
        .addFunction("ToPtr", &GCModelConfigElement_SetBodygroupOnAttachedModels::ToPtr)
        .addFunction("IsValid", &GCModelConfigElement_SetBodygroupOnAttachedModels::IsValid)
        .endClass();
}
GCNmFootEvent::GCNmFootEvent(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCNmFootEvent::GCNmFootEvent(void *ptr) {
    m_ptr = ptr;
}
uint64_t GCNmFootEvent::GetPhase() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CNmFootEvent->Phase(ptr=%p)", m_ptr));
    return GetSchemaValue<uint64_t>(m_ptr, "CNmFootEvent", "m_phase");
}
void GCNmFootEvent::SetPhase(uint64_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CNmFootEvent->Phase(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CNmFootEvent", "m_phase", false, value);
}
void* GCNmFootEvent::GetPtr() {
    return m_ptr;
}
std::string GCNmFootEvent::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCNmFootEvent::IsValid() {
    return (m_ptr != nullptr);
}
GCNmEvent GCNmFootEvent::GetParent() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CNmFootEvent::GetParent(ptr=%p)", m_ptr));
    GCNmEvent value(m_ptr);
    return value;
}
void GCNmFootEvent::SetParent(GCNmEvent value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CNmFootEvent::SetParent(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCNmFootEvent(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCNmFootEvent>("CNmFootEvent")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Phase", &GCNmFootEvent::GetPhase, &GCNmFootEvent::SetPhase)
        .addProperty("Parent", &GCNmFootEvent::GetParent, &GCNmFootEvent::SetParent)
        .addFunction("ToPtr", &GCNmFootEvent::ToPtr)
        .addFunction("IsValid", &GCNmFootEvent::IsValid)
        .endClass();
}
GCHandshakeAnimTagBase::GCHandshakeAnimTagBase(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCHandshakeAnimTagBase::GCHandshakeAnimTagBase(void *ptr) {
    m_ptr = ptr;
}
bool GCHandshakeAnimTagBase::GetIsDisableTag() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CHandshakeAnimTagBase->IsDisableTag(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "CHandshakeAnimTagBase", "m_bIsDisableTag");
}
void GCHandshakeAnimTagBase::SetIsDisableTag(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CHandshakeAnimTagBase->IsDisableTag(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CHandshakeAnimTagBase", "m_bIsDisableTag", false, value);
}
void* GCHandshakeAnimTagBase::GetPtr() {
    return m_ptr;
}
std::string GCHandshakeAnimTagBase::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCHandshakeAnimTagBase::IsValid() {
    return (m_ptr != nullptr);
}
GCAnimTagBase GCHandshakeAnimTagBase::GetParent() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CHandshakeAnimTagBase::GetParent(ptr=%p)", m_ptr));
    GCAnimTagBase value(m_ptr);
    return value;
}
void GCHandshakeAnimTagBase::SetParent(GCAnimTagBase value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CHandshakeAnimTagBase::SetParent(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCHandshakeAnimTagBase(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCHandshakeAnimTagBase>("CHandshakeAnimTagBase")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("IsDisableTag", &GCHandshakeAnimTagBase::GetIsDisableTag, &GCHandshakeAnimTagBase::SetIsDisableTag)
        .addProperty("Parent", &GCHandshakeAnimTagBase::GetParent, &GCHandshakeAnimTagBase::SetParent)
        .addFunction("ToPtr", &GCHandshakeAnimTagBase::ToPtr)
        .addFunction("IsValid", &GCHandshakeAnimTagBase::IsValid)
        .endClass();
}
GCBlend2DUpdateNode::GCBlend2DUpdateNode(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCBlend2DUpdateNode::GCBlend2DUpdateNode(void *ptr) {
    m_ptr = ptr;
}
std::vector<GBlendItem_t> GCBlend2DUpdateNode::GetItems() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CBlend2DUpdateNode->Items(ptr=%p)", m_ptr));
    CUtlVector<GBlendItem_t>* vec = GetSchemaValue<CUtlVector<GBlendItem_t>*>(m_ptr, "CBlend2DUpdateNode", "m_items"); std::vector<GBlendItem_t> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCBlend2DUpdateNode::SetItems(std::vector<GBlendItem_t> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CBlend2DUpdateNode->Items(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<GBlendItem_t>(m_ptr, "CBlend2DUpdateNode", "m_items", false, value);
}
std::vector<GTagSpan_t> GCBlend2DUpdateNode::GetTags() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CBlend2DUpdateNode->Tags(ptr=%p)", m_ptr));
    CUtlVector<GTagSpan_t>* vec = GetSchemaValue<CUtlVector<GTagSpan_t>*>(m_ptr, "CBlend2DUpdateNode", "m_tags"); std::vector<GTagSpan_t> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCBlend2DUpdateNode::SetTags(std::vector<GTagSpan_t> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CBlend2DUpdateNode->Tags(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<GTagSpan_t>(m_ptr, "CBlend2DUpdateNode", "m_tags", false, value);
}
GCParamSpanUpdater GCBlend2DUpdateNode::GetParamSpans() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CBlend2DUpdateNode->ParamSpans(ptr=%p)", m_ptr));
    GCParamSpanUpdater value(GetSchemaPtr(m_ptr, "CBlend2DUpdateNode", "m_paramSpans"));
    return value;
}
void GCBlend2DUpdateNode::SetParamSpans(GCParamSpanUpdater value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CBlend2DUpdateNode->ParamSpans(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'ParamSpans' is not possible.\n");
}
std::vector<int32> GCBlend2DUpdateNode::GetNodeItemIndices() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CBlend2DUpdateNode->NodeItemIndices(ptr=%p)", m_ptr));
    CUtlVector<int32>* vec = GetSchemaValue<CUtlVector<int32>*>(m_ptr, "CBlend2DUpdateNode", "m_nodeItemIndices"); std::vector<int32> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCBlend2DUpdateNode::SetNodeItemIndices(std::vector<int32> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CBlend2DUpdateNode->NodeItemIndices(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<int32>(m_ptr, "CBlend2DUpdateNode", "m_nodeItemIndices", false, value);
}
GCAnimInputDamping GCBlend2DUpdateNode::GetDamping() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CBlend2DUpdateNode->Damping(ptr=%p)", m_ptr));
    GCAnimInputDamping value(GetSchemaPtr(m_ptr, "CBlend2DUpdateNode", "m_damping"));
    return value;
}
void GCBlend2DUpdateNode::SetDamping(GCAnimInputDamping value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CBlend2DUpdateNode->Damping(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Damping' is not possible.\n");
}
uint64_t GCBlend2DUpdateNode::GetBlendSourceX() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CBlend2DUpdateNode->BlendSourceX(ptr=%p)", m_ptr));
    return GetSchemaValue<uint64_t>(m_ptr, "CBlend2DUpdateNode", "m_blendSourceX");
}
void GCBlend2DUpdateNode::SetBlendSourceX(uint64_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CBlend2DUpdateNode->BlendSourceX(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CBlend2DUpdateNode", "m_blendSourceX", false, value);
}
GCAnimParamHandle GCBlend2DUpdateNode::GetParamX() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CBlend2DUpdateNode->ParamX(ptr=%p)", m_ptr));
    GCAnimParamHandle value(GetSchemaPtr(m_ptr, "CBlend2DUpdateNode", "m_paramX"));
    return value;
}
void GCBlend2DUpdateNode::SetParamX(GCAnimParamHandle value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CBlend2DUpdateNode->ParamX(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'ParamX' is not possible.\n");
}
uint64_t GCBlend2DUpdateNode::GetBlendSourceY() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CBlend2DUpdateNode->BlendSourceY(ptr=%p)", m_ptr));
    return GetSchemaValue<uint64_t>(m_ptr, "CBlend2DUpdateNode", "m_blendSourceY");
}
void GCBlend2DUpdateNode::SetBlendSourceY(uint64_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CBlend2DUpdateNode->BlendSourceY(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CBlend2DUpdateNode", "m_blendSourceY", false, value);
}
GCAnimParamHandle GCBlend2DUpdateNode::GetParamY() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CBlend2DUpdateNode->ParamY(ptr=%p)", m_ptr));
    GCAnimParamHandle value(GetSchemaPtr(m_ptr, "CBlend2DUpdateNode", "m_paramY"));
    return value;
}
void GCBlend2DUpdateNode::SetParamY(GCAnimParamHandle value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CBlend2DUpdateNode->ParamY(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'ParamY' is not possible.\n");
}
uint64_t GCBlend2DUpdateNode::GetBlendMode() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CBlend2DUpdateNode->BlendMode(ptr=%p)", m_ptr));
    return GetSchemaValue<uint64_t>(m_ptr, "CBlend2DUpdateNode", "m_eBlendMode");
}
void GCBlend2DUpdateNode::SetBlendMode(uint64_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CBlend2DUpdateNode->BlendMode(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CBlend2DUpdateNode", "m_eBlendMode", false, value);
}
float GCBlend2DUpdateNode::GetPlaybackSpeed() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CBlend2DUpdateNode->PlaybackSpeed(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CBlend2DUpdateNode", "m_playbackSpeed");
}
void GCBlend2DUpdateNode::SetPlaybackSpeed(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CBlend2DUpdateNode->PlaybackSpeed(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CBlend2DUpdateNode", "m_playbackSpeed", false, value);
}
bool GCBlend2DUpdateNode::GetLoop() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CBlend2DUpdateNode->Loop(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "CBlend2DUpdateNode", "m_bLoop");
}
void GCBlend2DUpdateNode::SetLoop(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CBlend2DUpdateNode->Loop(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CBlend2DUpdateNode", "m_bLoop", false, value);
}
bool GCBlend2DUpdateNode::GetLockBlendOnReset() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CBlend2DUpdateNode->LockBlendOnReset(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "CBlend2DUpdateNode", "m_bLockBlendOnReset");
}
void GCBlend2DUpdateNode::SetLockBlendOnReset(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CBlend2DUpdateNode->LockBlendOnReset(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CBlend2DUpdateNode", "m_bLockBlendOnReset", false, value);
}
bool GCBlend2DUpdateNode::GetLockWhenWaning() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CBlend2DUpdateNode->LockWhenWaning(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "CBlend2DUpdateNode", "m_bLockWhenWaning");
}
void GCBlend2DUpdateNode::SetLockWhenWaning(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CBlend2DUpdateNode->LockWhenWaning(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CBlend2DUpdateNode", "m_bLockWhenWaning", false, value);
}
bool GCBlend2DUpdateNode::GetAnimEventsAndTagsOnMostWeightedOnly() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CBlend2DUpdateNode->AnimEventsAndTagsOnMostWeightedOnly(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "CBlend2DUpdateNode", "m_bAnimEventsAndTagsOnMostWeightedOnly");
}
void GCBlend2DUpdateNode::SetAnimEventsAndTagsOnMostWeightedOnly(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CBlend2DUpdateNode->AnimEventsAndTagsOnMostWeightedOnly(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CBlend2DUpdateNode", "m_bAnimEventsAndTagsOnMostWeightedOnly", false, value);
}
void* GCBlend2DUpdateNode::GetPtr() {
    return m_ptr;
}
std::string GCBlend2DUpdateNode::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCBlend2DUpdateNode::IsValid() {
    return (m_ptr != nullptr);
}
GCAnimUpdateNodeBase GCBlend2DUpdateNode::GetParent() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CBlend2DUpdateNode::GetParent(ptr=%p)", m_ptr));
    GCAnimUpdateNodeBase value(m_ptr);
    return value;
}
void GCBlend2DUpdateNode::SetParent(GCAnimUpdateNodeBase value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CBlend2DUpdateNode::SetParent(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCBlend2DUpdateNode(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCBlend2DUpdateNode>("CBlend2DUpdateNode")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Items", &GCBlend2DUpdateNode::GetItems, &GCBlend2DUpdateNode::SetItems)
        .addProperty("Tags", &GCBlend2DUpdateNode::GetTags, &GCBlend2DUpdateNode::SetTags)
        .addProperty("ParamSpans", &GCBlend2DUpdateNode::GetParamSpans, &GCBlend2DUpdateNode::SetParamSpans)
        .addProperty("NodeItemIndices", &GCBlend2DUpdateNode::GetNodeItemIndices, &GCBlend2DUpdateNode::SetNodeItemIndices)
        .addProperty("Damping", &GCBlend2DUpdateNode::GetDamping, &GCBlend2DUpdateNode::SetDamping)
        .addProperty("BlendSourceX", &GCBlend2DUpdateNode::GetBlendSourceX, &GCBlend2DUpdateNode::SetBlendSourceX)
        .addProperty("ParamX", &GCBlend2DUpdateNode::GetParamX, &GCBlend2DUpdateNode::SetParamX)
        .addProperty("BlendSourceY", &GCBlend2DUpdateNode::GetBlendSourceY, &GCBlend2DUpdateNode::SetBlendSourceY)
        .addProperty("ParamY", &GCBlend2DUpdateNode::GetParamY, &GCBlend2DUpdateNode::SetParamY)
        .addProperty("BlendMode", &GCBlend2DUpdateNode::GetBlendMode, &GCBlend2DUpdateNode::SetBlendMode)
        .addProperty("PlaybackSpeed", &GCBlend2DUpdateNode::GetPlaybackSpeed, &GCBlend2DUpdateNode::SetPlaybackSpeed)
        .addProperty("Loop", &GCBlend2DUpdateNode::GetLoop, &GCBlend2DUpdateNode::SetLoop)
        .addProperty("LockBlendOnReset", &GCBlend2DUpdateNode::GetLockBlendOnReset, &GCBlend2DUpdateNode::SetLockBlendOnReset)
        .addProperty("LockWhenWaning", &GCBlend2DUpdateNode::GetLockWhenWaning, &GCBlend2DUpdateNode::SetLockWhenWaning)
        .addProperty("AnimEventsAndTagsOnMostWeightedOnly", &GCBlend2DUpdateNode::GetAnimEventsAndTagsOnMostWeightedOnly, &GCBlend2DUpdateNode::SetAnimEventsAndTagsOnMostWeightedOnly)
        .addProperty("Parent", &GCBlend2DUpdateNode::GetParent, &GCBlend2DUpdateNode::SetParent)
        .addFunction("ToPtr", &GCBlend2DUpdateNode::ToPtr)
        .addFunction("IsValid", &GCBlend2DUpdateNode::IsValid)
        .endClass();
}
GAnimationSnapshotBase_t::GAnimationSnapshotBase_t(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GAnimationSnapshotBase_t::GAnimationSnapshotBase_t(void *ptr) {
    m_ptr = ptr;
}
float GAnimationSnapshotBase_t::GetRealTime() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: AnimationSnapshotBase_t->RealTime(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "AnimationSnapshotBase_t", "m_flRealTime");
}
void GAnimationSnapshotBase_t::SetRealTime(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: AnimationSnapshotBase_t->RealTime(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "AnimationSnapshotBase_t", "m_flRealTime", true, value);
}
bool GAnimationSnapshotBase_t::GetBonesInWorldSpace() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: AnimationSnapshotBase_t->BonesInWorldSpace(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "AnimationSnapshotBase_t", "m_bBonesInWorldSpace");
}
void GAnimationSnapshotBase_t::SetBonesInWorldSpace(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: AnimationSnapshotBase_t->BonesInWorldSpace(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "AnimationSnapshotBase_t", "m_bBonesInWorldSpace", true, value);
}
std::vector<uint32> GAnimationSnapshotBase_t::GetBoneSetupMask() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: AnimationSnapshotBase_t->BoneSetupMask(ptr=%p)", m_ptr));
    CUtlVector<uint32>* vec = GetSchemaValue<CUtlVector<uint32>*>(m_ptr, "AnimationSnapshotBase_t", "m_boneSetupMask"); std::vector<uint32> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GAnimationSnapshotBase_t::SetBoneSetupMask(std::vector<uint32> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: AnimationSnapshotBase_t->BoneSetupMask(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<uint32>(m_ptr, "AnimationSnapshotBase_t", "m_boneSetupMask", true, value);
}
std::vector<float32> GAnimationSnapshotBase_t::GetFlexControllers() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: AnimationSnapshotBase_t->FlexControllers(ptr=%p)", m_ptr));
    CUtlVector<float32>* vec = GetSchemaValue<CUtlVector<float32>*>(m_ptr, "AnimationSnapshotBase_t", "m_flexControllers"); std::vector<float32> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GAnimationSnapshotBase_t::SetFlexControllers(std::vector<float32> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: AnimationSnapshotBase_t->FlexControllers(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<float32>(m_ptr, "AnimationSnapshotBase_t", "m_flexControllers", true, value);
}
uint64_t GAnimationSnapshotBase_t::GetSnapshotType() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: AnimationSnapshotBase_t->SnapshotType(ptr=%p)", m_ptr));
    return GetSchemaValue<uint64_t>(m_ptr, "AnimationSnapshotBase_t", "m_SnapshotType");
}
void GAnimationSnapshotBase_t::SetSnapshotType(uint64_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: AnimationSnapshotBase_t->SnapshotType(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "AnimationSnapshotBase_t", "m_SnapshotType", true, value);
}
bool GAnimationSnapshotBase_t::GetHasDecodeDump() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: AnimationSnapshotBase_t->HasDecodeDump(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "AnimationSnapshotBase_t", "m_bHasDecodeDump");
}
void GAnimationSnapshotBase_t::SetHasDecodeDump(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: AnimationSnapshotBase_t->HasDecodeDump(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "AnimationSnapshotBase_t", "m_bHasDecodeDump", true, value);
}
GAnimationDecodeDebugDumpElement_t GAnimationSnapshotBase_t::GetDecodeDump() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: AnimationSnapshotBase_t->DecodeDump(ptr=%p)", m_ptr));
    GAnimationDecodeDebugDumpElement_t value(GetSchemaPtr(m_ptr, "AnimationSnapshotBase_t", "m_DecodeDump"));
    return value;
}
void GAnimationSnapshotBase_t::SetDecodeDump(GAnimationDecodeDebugDumpElement_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: AnimationSnapshotBase_t->DecodeDump(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'DecodeDump' is not possible.\n");
}
void* GAnimationSnapshotBase_t::GetPtr() {
    return m_ptr;
}
std::string GAnimationSnapshotBase_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GAnimationSnapshotBase_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassAnimationSnapshotBase_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GAnimationSnapshotBase_t>("AnimationSnapshotBase_t")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("RealTime", &GAnimationSnapshotBase_t::GetRealTime, &GAnimationSnapshotBase_t::SetRealTime)
        .addProperty("BonesInWorldSpace", &GAnimationSnapshotBase_t::GetBonesInWorldSpace, &GAnimationSnapshotBase_t::SetBonesInWorldSpace)
        .addProperty("BoneSetupMask", &GAnimationSnapshotBase_t::GetBoneSetupMask, &GAnimationSnapshotBase_t::SetBoneSetupMask)
        .addProperty("FlexControllers", &GAnimationSnapshotBase_t::GetFlexControllers, &GAnimationSnapshotBase_t::SetFlexControllers)
        .addProperty("SnapshotType", &GAnimationSnapshotBase_t::GetSnapshotType, &GAnimationSnapshotBase_t::SetSnapshotType)
        .addProperty("HasDecodeDump", &GAnimationSnapshotBase_t::GetHasDecodeDump, &GAnimationSnapshotBase_t::SetHasDecodeDump)
        .addProperty("DecodeDump", &GAnimationSnapshotBase_t::GetDecodeDump, &GAnimationSnapshotBase_t::SetDecodeDump)
        .addFunction("ToPtr", &GAnimationSnapshotBase_t::ToPtr)
        .addFunction("IsValid", &GAnimationSnapshotBase_t::IsValid)
        .endClass();
}
GCTiltTwistConstraint::GCTiltTwistConstraint(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCTiltTwistConstraint::GCTiltTwistConstraint(void *ptr) {
    m_ptr = ptr;
}
int32_t GCTiltTwistConstraint::GetTargetAxis() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CTiltTwistConstraint->TargetAxis(ptr=%p)", m_ptr));
    return GetSchemaValue<int32_t>(m_ptr, "CTiltTwistConstraint", "m_nTargetAxis");
}
void GCTiltTwistConstraint::SetTargetAxis(int32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CTiltTwistConstraint->TargetAxis(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CTiltTwistConstraint", "m_nTargetAxis", false, value);
}
int32_t GCTiltTwistConstraint::GetSlaveAxis() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CTiltTwistConstraint->SlaveAxis(ptr=%p)", m_ptr));
    return GetSchemaValue<int32_t>(m_ptr, "CTiltTwistConstraint", "m_nSlaveAxis");
}
void GCTiltTwistConstraint::SetSlaveAxis(int32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CTiltTwistConstraint->SlaveAxis(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CTiltTwistConstraint", "m_nSlaveAxis", false, value);
}
void* GCTiltTwistConstraint::GetPtr() {
    return m_ptr;
}
std::string GCTiltTwistConstraint::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCTiltTwistConstraint::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseConstraint GCTiltTwistConstraint::GetParent() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CTiltTwistConstraint::GetParent(ptr=%p)", m_ptr));
    GCBaseConstraint value(m_ptr);
    return value;
}
void GCTiltTwistConstraint::SetParent(GCBaseConstraint value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CTiltTwistConstraint::SetParent(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCTiltTwistConstraint(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCTiltTwistConstraint>("CTiltTwistConstraint")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("TargetAxis", &GCTiltTwistConstraint::GetTargetAxis, &GCTiltTwistConstraint::SetTargetAxis)
        .addProperty("SlaveAxis", &GCTiltTwistConstraint::GetSlaveAxis, &GCTiltTwistConstraint::SetSlaveAxis)
        .addProperty("Parent", &GCTiltTwistConstraint::GetParent, &GCTiltTwistConstraint::SetParent)
        .addFunction("ToPtr", &GCTiltTwistConstraint::ToPtr)
        .addFunction("IsValid", &GCTiltTwistConstraint::IsValid)
        .endClass();
}
GMaterialParamTexture_t::GMaterialParamTexture_t(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GMaterialParamTexture_t::GMaterialParamTexture_t(void *ptr) {
    m_ptr = ptr;
}
void* GMaterialParamTexture_t::GetPtr() {
    return m_ptr;
}
std::string GMaterialParamTexture_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GMaterialParamTexture_t::IsValid() {
    return (m_ptr != nullptr);
}
GMaterialParam_t GMaterialParamTexture_t::GetParent() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("MaterialParamTexture_t::GetParent(ptr=%p)", m_ptr));
    GMaterialParam_t value(m_ptr);
    return value;
}
void GMaterialParamTexture_t::SetParent(GMaterialParam_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("MaterialParamTexture_t::SetParent(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassMaterialParamTexture_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GMaterialParamTexture_t>("MaterialParamTexture_t")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Parent", &GMaterialParamTexture_t::GetParent, &GMaterialParamTexture_t::SetParent)
        .addFunction("ToPtr", &GMaterialParamTexture_t::ToPtr)
        .addFunction("IsValid", &GMaterialParamTexture_t::IsValid)
        .endClass();
}
GCGlobalLightBase::GCGlobalLightBase(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCGlobalLightBase::GCGlobalLightBase(void *ptr) {
    m_ptr = ptr;
}
bool GCGlobalLightBase::GetSpotLight() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CGlobalLightBase->SpotLight(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "CGlobalLightBase", "m_bSpotLight");
}
void GCGlobalLightBase::SetSpotLight(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CGlobalLightBase->SpotLight(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CGlobalLightBase", "m_bSpotLight", false, value);
}
Vector GCGlobalLightBase::GetSpotLightOrigin() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CGlobalLightBase->SpotLightOrigin(ptr=%p)", m_ptr));
    return GetSchemaValue<Vector>(m_ptr, "CGlobalLightBase", "m_SpotLightOrigin");
}
void GCGlobalLightBase::SetSpotLightOrigin(Vector value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CGlobalLightBase->SpotLightOrigin(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CGlobalLightBase", "m_SpotLightOrigin", false, value);
}
QAngle GCGlobalLightBase::GetSpotLightAngles() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CGlobalLightBase->SpotLightAngles(ptr=%p)", m_ptr));
    return GetSchemaValue<QAngle>(m_ptr, "CGlobalLightBase", "m_SpotLightAngles");
}
void GCGlobalLightBase::SetSpotLightAngles(QAngle value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CGlobalLightBase->SpotLightAngles(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CGlobalLightBase", "m_SpotLightAngles", false, value);
}
Vector GCGlobalLightBase::GetShadowDirection() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CGlobalLightBase->ShadowDirection(ptr=%p)", m_ptr));
    return GetSchemaValue<Vector>(m_ptr, "CGlobalLightBase", "m_ShadowDirection");
}
void GCGlobalLightBase::SetShadowDirection(Vector value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CGlobalLightBase->ShadowDirection(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CGlobalLightBase", "m_ShadowDirection", false, value);
}
Vector GCGlobalLightBase::GetAmbientDirection() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CGlobalLightBase->AmbientDirection(ptr=%p)", m_ptr));
    return GetSchemaValue<Vector>(m_ptr, "CGlobalLightBase", "m_AmbientDirection");
}
void GCGlobalLightBase::SetAmbientDirection(Vector value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CGlobalLightBase->AmbientDirection(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CGlobalLightBase", "m_AmbientDirection", false, value);
}
Vector GCGlobalLightBase::GetSpecularDirection() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CGlobalLightBase->SpecularDirection(ptr=%p)", m_ptr));
    return GetSchemaValue<Vector>(m_ptr, "CGlobalLightBase", "m_SpecularDirection");
}
void GCGlobalLightBase::SetSpecularDirection(Vector value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CGlobalLightBase->SpecularDirection(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CGlobalLightBase", "m_SpecularDirection", false, value);
}
Vector GCGlobalLightBase::GetInspectorSpecularDirection() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CGlobalLightBase->InspectorSpecularDirection(ptr=%p)", m_ptr));
    return GetSchemaValue<Vector>(m_ptr, "CGlobalLightBase", "m_InspectorSpecularDirection");
}
void GCGlobalLightBase::SetInspectorSpecularDirection(Vector value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CGlobalLightBase->InspectorSpecularDirection(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CGlobalLightBase", "m_InspectorSpecularDirection", false, value);
}
float GCGlobalLightBase::GetSpecularPower() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CGlobalLightBase->SpecularPower(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CGlobalLightBase", "m_flSpecularPower");
}
void GCGlobalLightBase::SetSpecularPower(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CGlobalLightBase->SpecularPower(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CGlobalLightBase", "m_flSpecularPower", false, value);
}
float GCGlobalLightBase::GetSpecularIndependence() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CGlobalLightBase->SpecularIndependence(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CGlobalLightBase", "m_flSpecularIndependence");
}
void GCGlobalLightBase::SetSpecularIndependence(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CGlobalLightBase->SpecularIndependence(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CGlobalLightBase", "m_flSpecularIndependence", false, value);
}
Color GCGlobalLightBase::GetSpecularColor() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CGlobalLightBase->SpecularColor(ptr=%p)", m_ptr));
    return GetSchemaValue<Color>(m_ptr, "CGlobalLightBase", "m_SpecularColor");
}
void GCGlobalLightBase::SetSpecularColor(Color value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CGlobalLightBase->SpecularColor(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CGlobalLightBase", "m_SpecularColor", false, value);
}
bool GCGlobalLightBase::GetStartDisabled() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CGlobalLightBase->StartDisabled(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "CGlobalLightBase", "m_bStartDisabled");
}
void GCGlobalLightBase::SetStartDisabled(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CGlobalLightBase->StartDisabled(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CGlobalLightBase", "m_bStartDisabled", false, value);
}
bool GCGlobalLightBase::GetEnabled() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CGlobalLightBase->Enabled(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "CGlobalLightBase", "m_bEnabled");
}
void GCGlobalLightBase::SetEnabled(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CGlobalLightBase->Enabled(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CGlobalLightBase", "m_bEnabled", false, value);
}
Color GCGlobalLightBase::GetLightColor() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CGlobalLightBase->LightColor(ptr=%p)", m_ptr));
    return GetSchemaValue<Color>(m_ptr, "CGlobalLightBase", "m_LightColor");
}
void GCGlobalLightBase::SetLightColor(Color value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CGlobalLightBase->LightColor(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CGlobalLightBase", "m_LightColor", false, value);
}
Color GCGlobalLightBase::GetAmbientColor1() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CGlobalLightBase->AmbientColor1(ptr=%p)", m_ptr));
    return GetSchemaValue<Color>(m_ptr, "CGlobalLightBase", "m_AmbientColor1");
}
void GCGlobalLightBase::SetAmbientColor1(Color value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CGlobalLightBase->AmbientColor1(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CGlobalLightBase", "m_AmbientColor1", false, value);
}
Color GCGlobalLightBase::GetAmbientColor2() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CGlobalLightBase->AmbientColor2(ptr=%p)", m_ptr));
    return GetSchemaValue<Color>(m_ptr, "CGlobalLightBase", "m_AmbientColor2");
}
void GCGlobalLightBase::SetAmbientColor2(Color value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CGlobalLightBase->AmbientColor2(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CGlobalLightBase", "m_AmbientColor2", false, value);
}
Color GCGlobalLightBase::GetAmbientColor3() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CGlobalLightBase->AmbientColor3(ptr=%p)", m_ptr));
    return GetSchemaValue<Color>(m_ptr, "CGlobalLightBase", "m_AmbientColor3");
}
void GCGlobalLightBase::SetAmbientColor3(Color value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CGlobalLightBase->AmbientColor3(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CGlobalLightBase", "m_AmbientColor3", false, value);
}
float GCGlobalLightBase::GetSunDistance() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CGlobalLightBase->SunDistance(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CGlobalLightBase", "m_flSunDistance");
}
void GCGlobalLightBase::SetSunDistance(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CGlobalLightBase->SunDistance(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CGlobalLightBase", "m_flSunDistance", false, value);
}
float GCGlobalLightBase::GetFOV() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CGlobalLightBase->FOV(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CGlobalLightBase", "m_flFOV");
}
void GCGlobalLightBase::SetFOV(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CGlobalLightBase->FOV(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CGlobalLightBase", "m_flFOV", false, value);
}
float GCGlobalLightBase::GetNearZ() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CGlobalLightBase->NearZ(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CGlobalLightBase", "m_flNearZ");
}
void GCGlobalLightBase::SetNearZ(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CGlobalLightBase->NearZ(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CGlobalLightBase", "m_flNearZ", false, value);
}
float GCGlobalLightBase::GetFarZ() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CGlobalLightBase->FarZ(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CGlobalLightBase", "m_flFarZ");
}
void GCGlobalLightBase::SetFarZ(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CGlobalLightBase->FarZ(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CGlobalLightBase", "m_flFarZ", false, value);
}
bool GCGlobalLightBase::GetEnableShadows() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CGlobalLightBase->EnableShadows(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "CGlobalLightBase", "m_bEnableShadows");
}
void GCGlobalLightBase::SetEnableShadows(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CGlobalLightBase->EnableShadows(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CGlobalLightBase", "m_bEnableShadows", false, value);
}
bool GCGlobalLightBase::GetOldEnableShadows() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CGlobalLightBase->OldEnableShadows(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "CGlobalLightBase", "m_bOldEnableShadows");
}
void GCGlobalLightBase::SetOldEnableShadows(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CGlobalLightBase->OldEnableShadows(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CGlobalLightBase", "m_bOldEnableShadows", false, value);
}
bool GCGlobalLightBase::GetBackgroundClearNotRequired() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CGlobalLightBase->BackgroundClearNotRequired(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "CGlobalLightBase", "m_bBackgroundClearNotRequired");
}
void GCGlobalLightBase::SetBackgroundClearNotRequired(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CGlobalLightBase->BackgroundClearNotRequired(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CGlobalLightBase", "m_bBackgroundClearNotRequired", false, value);
}
float GCGlobalLightBase::GetCloudScale() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CGlobalLightBase->CloudScale(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CGlobalLightBase", "m_flCloudScale");
}
void GCGlobalLightBase::SetCloudScale(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CGlobalLightBase->CloudScale(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CGlobalLightBase", "m_flCloudScale", false, value);
}
float GCGlobalLightBase::GetCloud1Speed() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CGlobalLightBase->Cloud1Speed(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CGlobalLightBase", "m_flCloud1Speed");
}
void GCGlobalLightBase::SetCloud1Speed(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CGlobalLightBase->Cloud1Speed(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CGlobalLightBase", "m_flCloud1Speed", false, value);
}
float GCGlobalLightBase::GetCloud1Direction() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CGlobalLightBase->Cloud1Direction(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CGlobalLightBase", "m_flCloud1Direction");
}
void GCGlobalLightBase::SetCloud1Direction(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CGlobalLightBase->Cloud1Direction(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CGlobalLightBase", "m_flCloud1Direction", false, value);
}
float GCGlobalLightBase::GetCloud2Speed() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CGlobalLightBase->Cloud2Speed(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CGlobalLightBase", "m_flCloud2Speed");
}
void GCGlobalLightBase::SetCloud2Speed(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CGlobalLightBase->Cloud2Speed(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CGlobalLightBase", "m_flCloud2Speed", false, value);
}
float GCGlobalLightBase::GetCloud2Direction() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CGlobalLightBase->Cloud2Direction(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CGlobalLightBase", "m_flCloud2Direction");
}
void GCGlobalLightBase::SetCloud2Direction(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CGlobalLightBase->Cloud2Direction(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CGlobalLightBase", "m_flCloud2Direction", false, value);
}
float GCGlobalLightBase::GetAmbientScale1() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CGlobalLightBase->AmbientScale1(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CGlobalLightBase", "m_flAmbientScale1");
}
void GCGlobalLightBase::SetAmbientScale1(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CGlobalLightBase->AmbientScale1(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CGlobalLightBase", "m_flAmbientScale1", false, value);
}
float GCGlobalLightBase::GetAmbientScale2() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CGlobalLightBase->AmbientScale2(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CGlobalLightBase", "m_flAmbientScale2");
}
void GCGlobalLightBase::SetAmbientScale2(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CGlobalLightBase->AmbientScale2(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CGlobalLightBase", "m_flAmbientScale2", false, value);
}
float GCGlobalLightBase::GetGroundScale() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CGlobalLightBase->GroundScale(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CGlobalLightBase", "m_flGroundScale");
}
void GCGlobalLightBase::SetGroundScale(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CGlobalLightBase->GroundScale(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CGlobalLightBase", "m_flGroundScale", false, value);
}
float GCGlobalLightBase::GetLightScale() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CGlobalLightBase->LightScale(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CGlobalLightBase", "m_flLightScale");
}
void GCGlobalLightBase::SetLightScale(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CGlobalLightBase->LightScale(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CGlobalLightBase", "m_flLightScale", false, value);
}
float GCGlobalLightBase::GetFoWDarkness() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CGlobalLightBase->FoWDarkness(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CGlobalLightBase", "m_flFoWDarkness");
}
void GCGlobalLightBase::SetFoWDarkness(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CGlobalLightBase->FoWDarkness(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CGlobalLightBase", "m_flFoWDarkness", false, value);
}
bool GCGlobalLightBase::GetEnableSeparateSkyboxFog() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CGlobalLightBase->EnableSeparateSkyboxFog(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "CGlobalLightBase", "m_bEnableSeparateSkyboxFog");
}
void GCGlobalLightBase::SetEnableSeparateSkyboxFog(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CGlobalLightBase->EnableSeparateSkyboxFog(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CGlobalLightBase", "m_bEnableSeparateSkyboxFog", false, value);
}
Vector GCGlobalLightBase::GetFowColor() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CGlobalLightBase->FowColor(ptr=%p)", m_ptr));
    return GetSchemaValue<Vector>(m_ptr, "CGlobalLightBase", "m_vFowColor");
}
void GCGlobalLightBase::SetFowColor(Vector value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CGlobalLightBase->FowColor(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CGlobalLightBase", "m_vFowColor", false, value);
}
Vector GCGlobalLightBase::GetViewOrigin() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CGlobalLightBase->ViewOrigin(ptr=%p)", m_ptr));
    return GetSchemaValue<Vector>(m_ptr, "CGlobalLightBase", "m_ViewOrigin");
}
void GCGlobalLightBase::SetViewOrigin(Vector value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CGlobalLightBase->ViewOrigin(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CGlobalLightBase", "m_ViewOrigin", false, value);
}
QAngle GCGlobalLightBase::GetViewAngles() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CGlobalLightBase->ViewAngles(ptr=%p)", m_ptr));
    return GetSchemaValue<QAngle>(m_ptr, "CGlobalLightBase", "m_ViewAngles");
}
void GCGlobalLightBase::SetViewAngles(QAngle value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CGlobalLightBase->ViewAngles(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CGlobalLightBase", "m_ViewAngles", false, value);
}
float GCGlobalLightBase::GetViewFoV() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CGlobalLightBase->ViewFoV(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CGlobalLightBase", "m_flViewFoV");
}
void GCGlobalLightBase::SetViewFoV(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CGlobalLightBase->ViewFoV(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CGlobalLightBase", "m_flViewFoV", false, value);
}
std::vector<Vector> GCGlobalLightBase::GetWorldPoints() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CGlobalLightBase->WorldPoints(ptr=%p,size=8)", m_ptr));
    Vector* outValue = (Vector*)GetSchemaPtr(m_ptr, "CGlobalLightBase", "m_WorldPoints"); std::vector<Vector> ret; for(int i = 0; i < 8; i++) { ret.push_back(outValue[i]); } return ret;
}
void GCGlobalLightBase::SetWorldPoints(std::vector<Vector> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CGlobalLightBase->WorldPoints(ptr=%p,size=8)", m_ptr));
    if(value.size() != 8) return PLUGIN_PRINT("Schema SDK", "Field 'WorldPoints' needs to have 8 values.\n");
    auto val = GetSchemaValuePtr<Vector>(m_ptr, "CGlobalLightBase", "m_WorldPoints");
    for(size_t i = 0; i < value.size(); i++) val[i] = value[i];
}
Vector2D GCGlobalLightBase::GetFogOffsetLayer0() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CGlobalLightBase->FogOffsetLayer0(ptr=%p)", m_ptr));
    return GetSchemaValue<Vector2D>(m_ptr, "CGlobalLightBase", "m_vFogOffsetLayer0");
}
void GCGlobalLightBase::SetFogOffsetLayer0(Vector2D value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CGlobalLightBase->FogOffsetLayer0(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CGlobalLightBase", "m_vFogOffsetLayer0", false, value);
}
Vector2D GCGlobalLightBase::GetFogOffsetLayer1() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CGlobalLightBase->FogOffsetLayer1(ptr=%p)", m_ptr));
    return GetSchemaValue<Vector2D>(m_ptr, "CGlobalLightBase", "m_vFogOffsetLayer1");
}
void GCGlobalLightBase::SetFogOffsetLayer1(Vector2D value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CGlobalLightBase->FogOffsetLayer1(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CGlobalLightBase", "m_vFogOffsetLayer1", false, value);
}
void* GCGlobalLightBase::GetPtr() {
    return m_ptr;
}
std::string GCGlobalLightBase::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCGlobalLightBase::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCGlobalLightBase(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCGlobalLightBase>("CGlobalLightBase")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("SpotLight", &GCGlobalLightBase::GetSpotLight, &GCGlobalLightBase::SetSpotLight)
        .addProperty("SpotLightOrigin", &GCGlobalLightBase::GetSpotLightOrigin, &GCGlobalLightBase::SetSpotLightOrigin)
        .addProperty("SpotLightAngles", &GCGlobalLightBase::GetSpotLightAngles, &GCGlobalLightBase::SetSpotLightAngles)
        .addProperty("ShadowDirection", &GCGlobalLightBase::GetShadowDirection, &GCGlobalLightBase::SetShadowDirection)
        .addProperty("AmbientDirection", &GCGlobalLightBase::GetAmbientDirection, &GCGlobalLightBase::SetAmbientDirection)
        .addProperty("SpecularDirection", &GCGlobalLightBase::GetSpecularDirection, &GCGlobalLightBase::SetSpecularDirection)
        .addProperty("InspectorSpecularDirection", &GCGlobalLightBase::GetInspectorSpecularDirection, &GCGlobalLightBase::SetInspectorSpecularDirection)
        .addProperty("SpecularPower", &GCGlobalLightBase::GetSpecularPower, &GCGlobalLightBase::SetSpecularPower)
        .addProperty("SpecularIndependence", &GCGlobalLightBase::GetSpecularIndependence, &GCGlobalLightBase::SetSpecularIndependence)
        .addProperty("SpecularColor", &GCGlobalLightBase::GetSpecularColor, &GCGlobalLightBase::SetSpecularColor)
        .addProperty("StartDisabled", &GCGlobalLightBase::GetStartDisabled, &GCGlobalLightBase::SetStartDisabled)
        .addProperty("Enabled", &GCGlobalLightBase::GetEnabled, &GCGlobalLightBase::SetEnabled)
        .addProperty("LightColor", &GCGlobalLightBase::GetLightColor, &GCGlobalLightBase::SetLightColor)
        .addProperty("AmbientColor1", &GCGlobalLightBase::GetAmbientColor1, &GCGlobalLightBase::SetAmbientColor1)
        .addProperty("AmbientColor2", &GCGlobalLightBase::GetAmbientColor2, &GCGlobalLightBase::SetAmbientColor2)
        .addProperty("AmbientColor3", &GCGlobalLightBase::GetAmbientColor3, &GCGlobalLightBase::SetAmbientColor3)
        .addProperty("SunDistance", &GCGlobalLightBase::GetSunDistance, &GCGlobalLightBase::SetSunDistance)
        .addProperty("FOV", &GCGlobalLightBase::GetFOV, &GCGlobalLightBase::SetFOV)
        .addProperty("NearZ", &GCGlobalLightBase::GetNearZ, &GCGlobalLightBase::SetNearZ)
        .addProperty("FarZ", &GCGlobalLightBase::GetFarZ, &GCGlobalLightBase::SetFarZ)
        .addProperty("EnableShadows", &GCGlobalLightBase::GetEnableShadows, &GCGlobalLightBase::SetEnableShadows)
        .addProperty("OldEnableShadows", &GCGlobalLightBase::GetOldEnableShadows, &GCGlobalLightBase::SetOldEnableShadows)
        .addProperty("BackgroundClearNotRequired", &GCGlobalLightBase::GetBackgroundClearNotRequired, &GCGlobalLightBase::SetBackgroundClearNotRequired)
        .addProperty("CloudScale", &GCGlobalLightBase::GetCloudScale, &GCGlobalLightBase::SetCloudScale)
        .addProperty("Cloud1Speed", &GCGlobalLightBase::GetCloud1Speed, &GCGlobalLightBase::SetCloud1Speed)
        .addProperty("Cloud1Direction", &GCGlobalLightBase::GetCloud1Direction, &GCGlobalLightBase::SetCloud1Direction)
        .addProperty("Cloud2Speed", &GCGlobalLightBase::GetCloud2Speed, &GCGlobalLightBase::SetCloud2Speed)
        .addProperty("Cloud2Direction", &GCGlobalLightBase::GetCloud2Direction, &GCGlobalLightBase::SetCloud2Direction)
        .addProperty("AmbientScale1", &GCGlobalLightBase::GetAmbientScale1, &GCGlobalLightBase::SetAmbientScale1)
        .addProperty("AmbientScale2", &GCGlobalLightBase::GetAmbientScale2, &GCGlobalLightBase::SetAmbientScale2)
        .addProperty("GroundScale", &GCGlobalLightBase::GetGroundScale, &GCGlobalLightBase::SetGroundScale)
        .addProperty("LightScale", &GCGlobalLightBase::GetLightScale, &GCGlobalLightBase::SetLightScale)
        .addProperty("FoWDarkness", &GCGlobalLightBase::GetFoWDarkness, &GCGlobalLightBase::SetFoWDarkness)
        .addProperty("EnableSeparateSkyboxFog", &GCGlobalLightBase::GetEnableSeparateSkyboxFog, &GCGlobalLightBase::SetEnableSeparateSkyboxFog)
        .addProperty("FowColor", &GCGlobalLightBase::GetFowColor, &GCGlobalLightBase::SetFowColor)
        .addProperty("ViewOrigin", &GCGlobalLightBase::GetViewOrigin, &GCGlobalLightBase::SetViewOrigin)
        .addProperty("ViewAngles", &GCGlobalLightBase::GetViewAngles, &GCGlobalLightBase::SetViewAngles)
        .addProperty("ViewFoV", &GCGlobalLightBase::GetViewFoV, &GCGlobalLightBase::SetViewFoV)
        .addProperty("WorldPoints", &GCGlobalLightBase::GetWorldPoints, &GCGlobalLightBase::SetWorldPoints)
        .addProperty("FogOffsetLayer0", &GCGlobalLightBase::GetFogOffsetLayer0, &GCGlobalLightBase::SetFogOffsetLayer0)
        .addProperty("FogOffsetLayer1", &GCGlobalLightBase::GetFogOffsetLayer1, &GCGlobalLightBase::SetFogOffsetLayer1)
        .addFunction("ToPtr", &GCGlobalLightBase::ToPtr)
        .addFunction("IsValid", &GCGlobalLightBase::IsValid)
        .endClass();
}
GCModelConfigElement_SetBodygroup::GCModelConfigElement_SetBodygroup(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCModelConfigElement_SetBodygroup::GCModelConfigElement_SetBodygroup(void *ptr) {
    m_ptr = ptr;
}
std::string GCModelConfigElement_SetBodygroup::GetGroupName() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CModelConfigElement_SetBodygroup->GroupName(ptr=%p)", m_ptr));
    return GetSchemaValue<CUtlString>(m_ptr, "CModelConfigElement_SetBodygroup", "m_GroupName").Get();
}
void GCModelConfigElement_SetBodygroup::SetGroupName(std::string value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CModelConfigElement_SetBodygroup->GroupName(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CModelConfigElement_SetBodygroup", "m_GroupName", false, CUtlString(value.c_str()));
}
int32_t GCModelConfigElement_SetBodygroup::GetChoice() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CModelConfigElement_SetBodygroup->Choice(ptr=%p)", m_ptr));
    return GetSchemaValue<int32_t>(m_ptr, "CModelConfigElement_SetBodygroup", "m_nChoice");
}
void GCModelConfigElement_SetBodygroup::SetChoice(int32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CModelConfigElement_SetBodygroup->Choice(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CModelConfigElement_SetBodygroup", "m_nChoice", false, value);
}
void* GCModelConfigElement_SetBodygroup::GetPtr() {
    return m_ptr;
}
std::string GCModelConfigElement_SetBodygroup::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCModelConfigElement_SetBodygroup::IsValid() {
    return (m_ptr != nullptr);
}
GCModelConfigElement GCModelConfigElement_SetBodygroup::GetParent() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CModelConfigElement_SetBodygroup::GetParent(ptr=%p)", m_ptr));
    GCModelConfigElement value(m_ptr);
    return value;
}
void GCModelConfigElement_SetBodygroup::SetParent(GCModelConfigElement value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CModelConfigElement_SetBodygroup::SetParent(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCModelConfigElement_SetBodygroup(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCModelConfigElement_SetBodygroup>("CModelConfigElement_SetBodygroup")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("GroupName", &GCModelConfigElement_SetBodygroup::GetGroupName, &GCModelConfigElement_SetBodygroup::SetGroupName)
        .addProperty("Choice", &GCModelConfigElement_SetBodygroup::GetChoice, &GCModelConfigElement_SetBodygroup::SetChoice)
        .addProperty("Parent", &GCModelConfigElement_SetBodygroup::GetParent, &GCModelConfigElement_SetBodygroup::SetParent)
        .addFunction("ToPtr", &GCModelConfigElement_SetBodygroup::ToPtr)
        .addFunction("IsValid", &GCModelConfigElement_SetBodygroup::IsValid)
        .endClass();
}
GCModelConfigElement_AttachedModel::GCModelConfigElement_AttachedModel(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCModelConfigElement_AttachedModel::GCModelConfigElement_AttachedModel(void *ptr) {
    m_ptr = ptr;
}
std::string GCModelConfigElement_AttachedModel::GetInstanceName() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CModelConfigElement_AttachedModel->InstanceName(ptr=%p)", m_ptr));
    return GetSchemaValue<CUtlString>(m_ptr, "CModelConfigElement_AttachedModel", "m_InstanceName").Get();
}
void GCModelConfigElement_AttachedModel::SetInstanceName(std::string value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CModelConfigElement_AttachedModel->InstanceName(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CModelConfigElement_AttachedModel", "m_InstanceName", false, CUtlString(value.c_str()));
}
std::string GCModelConfigElement_AttachedModel::GetEntityClass() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CModelConfigElement_AttachedModel->EntityClass(ptr=%p)", m_ptr));
    return GetSchemaValue<CUtlString>(m_ptr, "CModelConfigElement_AttachedModel", "m_EntityClass").Get();
}
void GCModelConfigElement_AttachedModel::SetEntityClass(std::string value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CModelConfigElement_AttachedModel->EntityClass(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CModelConfigElement_AttachedModel", "m_EntityClass", false, CUtlString(value.c_str()));
}
Vector GCModelConfigElement_AttachedModel::GetOffset() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CModelConfigElement_AttachedModel->Offset(ptr=%p)", m_ptr));
    return GetSchemaValue<Vector>(m_ptr, "CModelConfigElement_AttachedModel", "m_vOffset");
}
void GCModelConfigElement_AttachedModel::SetOffset(Vector value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CModelConfigElement_AttachedModel->Offset(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CModelConfigElement_AttachedModel", "m_vOffset", false, value);
}
QAngle GCModelConfigElement_AttachedModel::GetAngOffset() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CModelConfigElement_AttachedModel->AngOffset(ptr=%p)", m_ptr));
    return GetSchemaValue<QAngle>(m_ptr, "CModelConfigElement_AttachedModel", "m_aAngOffset");
}
void GCModelConfigElement_AttachedModel::SetAngOffset(QAngle value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CModelConfigElement_AttachedModel->AngOffset(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CModelConfigElement_AttachedModel", "m_aAngOffset", false, value);
}
std::string GCModelConfigElement_AttachedModel::GetAttachmentName() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CModelConfigElement_AttachedModel->AttachmentName(ptr=%p)", m_ptr));
    return GetSchemaValue<CUtlString>(m_ptr, "CModelConfigElement_AttachedModel", "m_AttachmentName").Get();
}
void GCModelConfigElement_AttachedModel::SetAttachmentName(std::string value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CModelConfigElement_AttachedModel->AttachmentName(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CModelConfigElement_AttachedModel", "m_AttachmentName", false, CUtlString(value.c_str()));
}
std::string GCModelConfigElement_AttachedModel::GetLocalAttachmentOffsetName() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CModelConfigElement_AttachedModel->LocalAttachmentOffsetName(ptr=%p)", m_ptr));
    return GetSchemaValue<CUtlString>(m_ptr, "CModelConfigElement_AttachedModel", "m_LocalAttachmentOffsetName").Get();
}
void GCModelConfigElement_AttachedModel::SetLocalAttachmentOffsetName(std::string value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CModelConfigElement_AttachedModel->LocalAttachmentOffsetName(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CModelConfigElement_AttachedModel", "m_LocalAttachmentOffsetName", false, CUtlString(value.c_str()));
}
uint64_t GCModelConfigElement_AttachedModel::GetAttachmentType() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CModelConfigElement_AttachedModel->AttachmentType(ptr=%p)", m_ptr));
    return GetSchemaValue<uint64_t>(m_ptr, "CModelConfigElement_AttachedModel", "m_AttachmentType");
}
void GCModelConfigElement_AttachedModel::SetAttachmentType(uint64_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CModelConfigElement_AttachedModel->AttachmentType(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CModelConfigElement_AttachedModel", "m_AttachmentType", false, value);
}
bool GCModelConfigElement_AttachedModel::GetBoneMergeFlex() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CModelConfigElement_AttachedModel->BoneMergeFlex(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "CModelConfigElement_AttachedModel", "m_bBoneMergeFlex");
}
void GCModelConfigElement_AttachedModel::SetBoneMergeFlex(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CModelConfigElement_AttachedModel->BoneMergeFlex(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CModelConfigElement_AttachedModel", "m_bBoneMergeFlex", false, value);
}
bool GCModelConfigElement_AttachedModel::GetUserSpecifiedColor() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CModelConfigElement_AttachedModel->UserSpecifiedColor(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "CModelConfigElement_AttachedModel", "m_bUserSpecifiedColor");
}
void GCModelConfigElement_AttachedModel::SetUserSpecifiedColor(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CModelConfigElement_AttachedModel->UserSpecifiedColor(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CModelConfigElement_AttachedModel", "m_bUserSpecifiedColor", false, value);
}
bool GCModelConfigElement_AttachedModel::GetUserSpecifiedMaterialGroup() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CModelConfigElement_AttachedModel->UserSpecifiedMaterialGroup(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "CModelConfigElement_AttachedModel", "m_bUserSpecifiedMaterialGroup");
}
void GCModelConfigElement_AttachedModel::SetUserSpecifiedMaterialGroup(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CModelConfigElement_AttachedModel->UserSpecifiedMaterialGroup(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CModelConfigElement_AttachedModel", "m_bUserSpecifiedMaterialGroup", false, value);
}
bool GCModelConfigElement_AttachedModel::GetAcceptParentMaterialDrivenDecals() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CModelConfigElement_AttachedModel->AcceptParentMaterialDrivenDecals(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "CModelConfigElement_AttachedModel", "m_bAcceptParentMaterialDrivenDecals");
}
void GCModelConfigElement_AttachedModel::SetAcceptParentMaterialDrivenDecals(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CModelConfigElement_AttachedModel->AcceptParentMaterialDrivenDecals(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CModelConfigElement_AttachedModel", "m_bAcceptParentMaterialDrivenDecals", false, value);
}
std::string GCModelConfigElement_AttachedModel::GetBodygroupOnOtherModels() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CModelConfigElement_AttachedModel->BodygroupOnOtherModels(ptr=%p)", m_ptr));
    return GetSchemaValue<CUtlString>(m_ptr, "CModelConfigElement_AttachedModel", "m_BodygroupOnOtherModels").Get();
}
void GCModelConfigElement_AttachedModel::SetBodygroupOnOtherModels(std::string value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CModelConfigElement_AttachedModel->BodygroupOnOtherModels(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CModelConfigElement_AttachedModel", "m_BodygroupOnOtherModels", false, CUtlString(value.c_str()));
}
std::string GCModelConfigElement_AttachedModel::GetMaterialGroupOnOtherModels() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CModelConfigElement_AttachedModel->MaterialGroupOnOtherModels(ptr=%p)", m_ptr));
    return GetSchemaValue<CUtlString>(m_ptr, "CModelConfigElement_AttachedModel", "m_MaterialGroupOnOtherModels").Get();
}
void GCModelConfigElement_AttachedModel::SetMaterialGroupOnOtherModels(std::string value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CModelConfigElement_AttachedModel->MaterialGroupOnOtherModels(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CModelConfigElement_AttachedModel", "m_MaterialGroupOnOtherModels", false, CUtlString(value.c_str()));
}
void* GCModelConfigElement_AttachedModel::GetPtr() {
    return m_ptr;
}
std::string GCModelConfigElement_AttachedModel::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCModelConfigElement_AttachedModel::IsValid() {
    return (m_ptr != nullptr);
}
GCModelConfigElement GCModelConfigElement_AttachedModel::GetParent() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CModelConfigElement_AttachedModel::GetParent(ptr=%p)", m_ptr));
    GCModelConfigElement value(m_ptr);
    return value;
}
void GCModelConfigElement_AttachedModel::SetParent(GCModelConfigElement value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CModelConfigElement_AttachedModel::SetParent(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCModelConfigElement_AttachedModel(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCModelConfigElement_AttachedModel>("CModelConfigElement_AttachedModel")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("InstanceName", &GCModelConfigElement_AttachedModel::GetInstanceName, &GCModelConfigElement_AttachedModel::SetInstanceName)
        .addProperty("EntityClass", &GCModelConfigElement_AttachedModel::GetEntityClass, &GCModelConfigElement_AttachedModel::SetEntityClass)
        .addProperty("Offset", &GCModelConfigElement_AttachedModel::GetOffset, &GCModelConfigElement_AttachedModel::SetOffset)
        .addProperty("AngOffset", &GCModelConfigElement_AttachedModel::GetAngOffset, &GCModelConfigElement_AttachedModel::SetAngOffset)
        .addProperty("AttachmentName", &GCModelConfigElement_AttachedModel::GetAttachmentName, &GCModelConfigElement_AttachedModel::SetAttachmentName)
        .addProperty("LocalAttachmentOffsetName", &GCModelConfigElement_AttachedModel::GetLocalAttachmentOffsetName, &GCModelConfigElement_AttachedModel::SetLocalAttachmentOffsetName)
        .addProperty("AttachmentType", &GCModelConfigElement_AttachedModel::GetAttachmentType, &GCModelConfigElement_AttachedModel::SetAttachmentType)
        .addProperty("BoneMergeFlex", &GCModelConfigElement_AttachedModel::GetBoneMergeFlex, &GCModelConfigElement_AttachedModel::SetBoneMergeFlex)
        .addProperty("UserSpecifiedColor", &GCModelConfigElement_AttachedModel::GetUserSpecifiedColor, &GCModelConfigElement_AttachedModel::SetUserSpecifiedColor)
        .addProperty("UserSpecifiedMaterialGroup", &GCModelConfigElement_AttachedModel::GetUserSpecifiedMaterialGroup, &GCModelConfigElement_AttachedModel::SetUserSpecifiedMaterialGroup)
        .addProperty("AcceptParentMaterialDrivenDecals", &GCModelConfigElement_AttachedModel::GetAcceptParentMaterialDrivenDecals, &GCModelConfigElement_AttachedModel::SetAcceptParentMaterialDrivenDecals)
        .addProperty("BodygroupOnOtherModels", &GCModelConfigElement_AttachedModel::GetBodygroupOnOtherModels, &GCModelConfigElement_AttachedModel::SetBodygroupOnOtherModels)
        .addProperty("MaterialGroupOnOtherModels", &GCModelConfigElement_AttachedModel::GetMaterialGroupOnOtherModels, &GCModelConfigElement_AttachedModel::SetMaterialGroupOnOtherModels)
        .addProperty("Parent", &GCModelConfigElement_AttachedModel::GetParent, &GCModelConfigElement_AttachedModel::SetParent)
        .addFunction("ToPtr", &GCModelConfigElement_AttachedModel::ToPtr)
        .addFunction("IsValid", &GCModelConfigElement_AttachedModel::IsValid)
        .endClass();
}
GCFollowAttachmentUpdateNode::GCFollowAttachmentUpdateNode(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCFollowAttachmentUpdateNode::GCFollowAttachmentUpdateNode(void *ptr) {
    m_ptr = ptr;
}
GFollowAttachmentSettings_t GCFollowAttachmentUpdateNode::GetOpFixedData() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CFollowAttachmentUpdateNode->OpFixedData(ptr=%p)", m_ptr));
    GFollowAttachmentSettings_t value(GetSchemaPtr(m_ptr, "CFollowAttachmentUpdateNode", "m_opFixedData"));
    return value;
}
void GCFollowAttachmentUpdateNode::SetOpFixedData(GFollowAttachmentSettings_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CFollowAttachmentUpdateNode->OpFixedData(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'OpFixedData' is not possible.\n");
}
void* GCFollowAttachmentUpdateNode::GetPtr() {
    return m_ptr;
}
std::string GCFollowAttachmentUpdateNode::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCFollowAttachmentUpdateNode::IsValid() {
    return (m_ptr != nullptr);
}
GCUnaryUpdateNode GCFollowAttachmentUpdateNode::GetParent() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CFollowAttachmentUpdateNode::GetParent(ptr=%p)", m_ptr));
    GCUnaryUpdateNode value(m_ptr);
    return value;
}
void GCFollowAttachmentUpdateNode::SetParent(GCUnaryUpdateNode value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CFollowAttachmentUpdateNode::SetParent(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCFollowAttachmentUpdateNode(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCFollowAttachmentUpdateNode>("CFollowAttachmentUpdateNode")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("OpFixedData", &GCFollowAttachmentUpdateNode::GetOpFixedData, &GCFollowAttachmentUpdateNode::SetOpFixedData)
        .addProperty("Parent", &GCFollowAttachmentUpdateNode::GetParent, &GCFollowAttachmentUpdateNode::SetParent)
        .addFunction("ToPtr", &GCFollowAttachmentUpdateNode::ToPtr)
        .addFunction("IsValid", &GCFollowAttachmentUpdateNode::IsValid)
        .endClass();
}
GParticleChildrenInfo_t::GParticleChildrenInfo_t(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GParticleChildrenInfo_t::GParticleChildrenInfo_t(void *ptr) {
    m_ptr = ptr;
}
float GParticleChildrenInfo_t::GetDelay() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: ParticleChildrenInfo_t->Delay(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "ParticleChildrenInfo_t", "m_flDelay");
}
void GParticleChildrenInfo_t::SetDelay(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: ParticleChildrenInfo_t->Delay(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "ParticleChildrenInfo_t", "m_flDelay", true, value);
}
bool GParticleChildrenInfo_t::GetEndCap() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: ParticleChildrenInfo_t->EndCap(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "ParticleChildrenInfo_t", "m_bEndCap");
}
void GParticleChildrenInfo_t::SetEndCap(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: ParticleChildrenInfo_t->EndCap(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "ParticleChildrenInfo_t", "m_bEndCap", true, value);
}
bool GParticleChildrenInfo_t::GetDisableChild() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: ParticleChildrenInfo_t->DisableChild(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "ParticleChildrenInfo_t", "m_bDisableChild");
}
void GParticleChildrenInfo_t::SetDisableChild(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: ParticleChildrenInfo_t->DisableChild(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "ParticleChildrenInfo_t", "m_bDisableChild", true, value);
}
uint64_t GParticleChildrenInfo_t::GetDetailLevel() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: ParticleChildrenInfo_t->DetailLevel(ptr=%p)", m_ptr));
    return GetSchemaValue<uint64_t>(m_ptr, "ParticleChildrenInfo_t", "m_nDetailLevel");
}
void GParticleChildrenInfo_t::SetDetailLevel(uint64_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: ParticleChildrenInfo_t->DetailLevel(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "ParticleChildrenInfo_t", "m_nDetailLevel", true, value);
}
void* GParticleChildrenInfo_t::GetPtr() {
    return m_ptr;
}
std::string GParticleChildrenInfo_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GParticleChildrenInfo_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassParticleChildrenInfo_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GParticleChildrenInfo_t>("ParticleChildrenInfo_t")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Delay", &GParticleChildrenInfo_t::GetDelay, &GParticleChildrenInfo_t::SetDelay)
        .addProperty("EndCap", &GParticleChildrenInfo_t::GetEndCap, &GParticleChildrenInfo_t::SetEndCap)
        .addProperty("DisableChild", &GParticleChildrenInfo_t::GetDisableChild, &GParticleChildrenInfo_t::SetDisableChild)
        .addProperty("DetailLevel", &GParticleChildrenInfo_t::GetDetailLevel, &GParticleChildrenInfo_t::SetDetailLevel)
        .addFunction("ToPtr", &GParticleChildrenInfo_t::ToPtr)
        .addFunction("IsValid", &GParticleChildrenInfo_t::IsValid)
        .endClass();
}
GCVoiceContainerNull::GCVoiceContainerNull(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCVoiceContainerNull::GCVoiceContainerNull(void *ptr) {
    m_ptr = ptr;
}
void* GCVoiceContainerNull::GetPtr() {
    return m_ptr;
}
std::string GCVoiceContainerNull::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCVoiceContainerNull::IsValid() {
    return (m_ptr != nullptr);
}
GCVoiceContainerBase GCVoiceContainerNull::GetParent() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CVoiceContainerNull::GetParent(ptr=%p)", m_ptr));
    GCVoiceContainerBase value(m_ptr);
    return value;
}
void GCVoiceContainerNull::SetParent(GCVoiceContainerBase value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CVoiceContainerNull::SetParent(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCVoiceContainerNull(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCVoiceContainerNull>("CVoiceContainerNull")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Parent", &GCVoiceContainerNull::GetParent, &GCVoiceContainerNull::SetParent)
        .addFunction("ToPtr", &GCVoiceContainerNull::ToPtr)
        .addFunction("IsValid", &GCVoiceContainerNull::IsValid)
        .endClass();
}
GMoodAnimation_t::GMoodAnimation_t(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GMoodAnimation_t::GMoodAnimation_t(void *ptr) {
    m_ptr = ptr;
}
std::string GMoodAnimation_t::GetName() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: MoodAnimation_t->Name(ptr=%p)", m_ptr));
    return GetSchemaValue<CUtlString>(m_ptr, "MoodAnimation_t", "m_sName").Get();
}
void GMoodAnimation_t::SetName(std::string value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: MoodAnimation_t->Name(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "MoodAnimation_t", "m_sName", true, CUtlString(value.c_str()));
}
float GMoodAnimation_t::GetWeight() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: MoodAnimation_t->Weight(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "MoodAnimation_t", "m_flWeight");
}
void GMoodAnimation_t::SetWeight(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: MoodAnimation_t->Weight(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "MoodAnimation_t", "m_flWeight", true, value);
}
void* GMoodAnimation_t::GetPtr() {
    return m_ptr;
}
std::string GMoodAnimation_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GMoodAnimation_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassMoodAnimation_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GMoodAnimation_t>("MoodAnimation_t")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Name", &GMoodAnimation_t::GetName, &GMoodAnimation_t::SetName)
        .addProperty("Weight", &GMoodAnimation_t::GetWeight, &GMoodAnimation_t::SetWeight)
        .addFunction("ToPtr", &GMoodAnimation_t::ToPtr)
        .addFunction("IsValid", &GMoodAnimation_t::IsValid)
        .endClass();
}
GCClientAlphaProperty::GCClientAlphaProperty(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCClientAlphaProperty::GCClientAlphaProperty(void *ptr) {
    m_ptr = ptr;
}
uint32_t GCClientAlphaProperty::GetRenderFX() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CClientAlphaProperty->RenderFX(ptr=%p)", m_ptr));
    return GetSchemaValue<uint32_t>(m_ptr, "CClientAlphaProperty", "m_nRenderFX");
}
void GCClientAlphaProperty::SetRenderFX(uint32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CClientAlphaProperty->RenderFX(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CClientAlphaProperty", "m_nRenderFX", false, value);
}
uint32_t GCClientAlphaProperty::GetRenderMode() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CClientAlphaProperty->RenderMode(ptr=%p)", m_ptr));
    return GetSchemaValue<uint32_t>(m_ptr, "CClientAlphaProperty", "m_nRenderMode");
}
void GCClientAlphaProperty::SetRenderMode(uint32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CClientAlphaProperty->RenderMode(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CClientAlphaProperty", "m_nRenderMode", false, value);
}
uint32_t GCClientAlphaProperty::GetAlpha() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CClientAlphaProperty->Alpha(ptr=%p)", m_ptr));
    return GetSchemaValue<uint32_t>(m_ptr, "CClientAlphaProperty", "m_nAlpha");
}
void GCClientAlphaProperty::SetAlpha(uint32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CClientAlphaProperty->Alpha(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CClientAlphaProperty", "m_nAlpha", false, value);
}
uint16_t GCClientAlphaProperty::GetDesyncOffset() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CClientAlphaProperty->DesyncOffset(ptr=%p)", m_ptr));
    return GetSchemaValue<uint16_t>(m_ptr, "CClientAlphaProperty", "m_nDesyncOffset");
}
void GCClientAlphaProperty::SetDesyncOffset(uint16_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CClientAlphaProperty->DesyncOffset(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CClientAlphaProperty", "m_nDesyncOffset", false, value);
}
uint16_t GCClientAlphaProperty::GetReserved2() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CClientAlphaProperty->Reserved2(ptr=%p)", m_ptr));
    return GetSchemaValue<uint16_t>(m_ptr, "CClientAlphaProperty", "m_nReserved2");
}
void GCClientAlphaProperty::SetReserved2(uint16_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CClientAlphaProperty->Reserved2(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CClientAlphaProperty", "m_nReserved2", false, value);
}
uint16_t GCClientAlphaProperty::GetDistFadeStart() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CClientAlphaProperty->DistFadeStart(ptr=%p)", m_ptr));
    return GetSchemaValue<uint16_t>(m_ptr, "CClientAlphaProperty", "m_nDistFadeStart");
}
void GCClientAlphaProperty::SetDistFadeStart(uint16_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CClientAlphaProperty->DistFadeStart(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CClientAlphaProperty", "m_nDistFadeStart", false, value);
}
uint16_t GCClientAlphaProperty::GetDistFadeEnd() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CClientAlphaProperty->DistFadeEnd(ptr=%p)", m_ptr));
    return GetSchemaValue<uint16_t>(m_ptr, "CClientAlphaProperty", "m_nDistFadeEnd");
}
void GCClientAlphaProperty::SetDistFadeEnd(uint16_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CClientAlphaProperty->DistFadeEnd(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CClientAlphaProperty", "m_nDistFadeEnd", false, value);
}
float GCClientAlphaProperty::GetFadeScale() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CClientAlphaProperty->FadeScale(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CClientAlphaProperty", "m_flFadeScale");
}
void GCClientAlphaProperty::SetFadeScale(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CClientAlphaProperty->FadeScale(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CClientAlphaProperty", "m_flFadeScale", false, value);
}
float GCClientAlphaProperty::GetRenderFxStartTime() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CClientAlphaProperty->RenderFxStartTime(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CClientAlphaProperty", "m_flRenderFxStartTime");
}
void GCClientAlphaProperty::SetRenderFxStartTime(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CClientAlphaProperty->RenderFxStartTime(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CClientAlphaProperty", "m_flRenderFxStartTime", false, value);
}
float GCClientAlphaProperty::GetRenderFxDuration() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CClientAlphaProperty->RenderFxDuration(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CClientAlphaProperty", "m_flRenderFxDuration");
}
void GCClientAlphaProperty::SetRenderFxDuration(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CClientAlphaProperty->RenderFxDuration(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CClientAlphaProperty", "m_flRenderFxDuration", false, value);
}
void* GCClientAlphaProperty::GetPtr() {
    return m_ptr;
}
std::string GCClientAlphaProperty::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCClientAlphaProperty::IsValid() {
    return (m_ptr != nullptr);
}
GIClientAlphaProperty GCClientAlphaProperty::GetParent() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CClientAlphaProperty::GetParent(ptr=%p)", m_ptr));
    GIClientAlphaProperty value(m_ptr);
    return value;
}
void GCClientAlphaProperty::SetParent(GIClientAlphaProperty value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CClientAlphaProperty::SetParent(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCClientAlphaProperty(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCClientAlphaProperty>("CClientAlphaProperty")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("RenderFX", &GCClientAlphaProperty::GetRenderFX, &GCClientAlphaProperty::SetRenderFX)
        .addProperty("RenderMode", &GCClientAlphaProperty::GetRenderMode, &GCClientAlphaProperty::SetRenderMode)
        .addProperty("Alpha", &GCClientAlphaProperty::GetAlpha, &GCClientAlphaProperty::SetAlpha)
        .addProperty("DesyncOffset", &GCClientAlphaProperty::GetDesyncOffset, &GCClientAlphaProperty::SetDesyncOffset)
        .addProperty("Reserved2", &GCClientAlphaProperty::GetReserved2, &GCClientAlphaProperty::SetReserved2)
        .addProperty("DistFadeStart", &GCClientAlphaProperty::GetDistFadeStart, &GCClientAlphaProperty::SetDistFadeStart)
        .addProperty("DistFadeEnd", &GCClientAlphaProperty::GetDistFadeEnd, &GCClientAlphaProperty::SetDistFadeEnd)
        .addProperty("FadeScale", &GCClientAlphaProperty::GetFadeScale, &GCClientAlphaProperty::SetFadeScale)
        .addProperty("RenderFxStartTime", &GCClientAlphaProperty::GetRenderFxStartTime, &GCClientAlphaProperty::SetRenderFxStartTime)
        .addProperty("RenderFxDuration", &GCClientAlphaProperty::GetRenderFxDuration, &GCClientAlphaProperty::SetRenderFxDuration)
        .addProperty("Parent", &GCClientAlphaProperty::GetParent, &GCClientAlphaProperty::SetParent)
        .addFunction("ToPtr", &GCClientAlphaProperty::ToPtr)
        .addFunction("IsValid", &GCClientAlphaProperty::IsValid)
        .endClass();
}
GCTimeRemainingMetricEvaluator::GCTimeRemainingMetricEvaluator(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCTimeRemainingMetricEvaluator::GCTimeRemainingMetricEvaluator(void *ptr) {
    m_ptr = ptr;
}
bool GCTimeRemainingMetricEvaluator::GetMatchByTimeRemaining() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CTimeRemainingMetricEvaluator->MatchByTimeRemaining(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "CTimeRemainingMetricEvaluator", "m_bMatchByTimeRemaining");
}
void GCTimeRemainingMetricEvaluator::SetMatchByTimeRemaining(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CTimeRemainingMetricEvaluator->MatchByTimeRemaining(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CTimeRemainingMetricEvaluator", "m_bMatchByTimeRemaining", false, value);
}
float GCTimeRemainingMetricEvaluator::GetMaxTimeRemaining() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CTimeRemainingMetricEvaluator->MaxTimeRemaining(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CTimeRemainingMetricEvaluator", "m_flMaxTimeRemaining");
}
void GCTimeRemainingMetricEvaluator::SetMaxTimeRemaining(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CTimeRemainingMetricEvaluator->MaxTimeRemaining(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CTimeRemainingMetricEvaluator", "m_flMaxTimeRemaining", false, value);
}
bool GCTimeRemainingMetricEvaluator::GetFilterByTimeRemaining() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CTimeRemainingMetricEvaluator->FilterByTimeRemaining(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "CTimeRemainingMetricEvaluator", "m_bFilterByTimeRemaining");
}
void GCTimeRemainingMetricEvaluator::SetFilterByTimeRemaining(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CTimeRemainingMetricEvaluator->FilterByTimeRemaining(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CTimeRemainingMetricEvaluator", "m_bFilterByTimeRemaining", false, value);
}
float GCTimeRemainingMetricEvaluator::GetMinTimeRemaining() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CTimeRemainingMetricEvaluator->MinTimeRemaining(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CTimeRemainingMetricEvaluator", "m_flMinTimeRemaining");
}
void GCTimeRemainingMetricEvaluator::SetMinTimeRemaining(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CTimeRemainingMetricEvaluator->MinTimeRemaining(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CTimeRemainingMetricEvaluator", "m_flMinTimeRemaining", false, value);
}
void* GCTimeRemainingMetricEvaluator::GetPtr() {
    return m_ptr;
}
std::string GCTimeRemainingMetricEvaluator::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCTimeRemainingMetricEvaluator::IsValid() {
    return (m_ptr != nullptr);
}
GCMotionMetricEvaluator GCTimeRemainingMetricEvaluator::GetParent() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CTimeRemainingMetricEvaluator::GetParent(ptr=%p)", m_ptr));
    GCMotionMetricEvaluator value(m_ptr);
    return value;
}
void GCTimeRemainingMetricEvaluator::SetParent(GCMotionMetricEvaluator value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CTimeRemainingMetricEvaluator::SetParent(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCTimeRemainingMetricEvaluator(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCTimeRemainingMetricEvaluator>("CTimeRemainingMetricEvaluator")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("MatchByTimeRemaining", &GCTimeRemainingMetricEvaluator::GetMatchByTimeRemaining, &GCTimeRemainingMetricEvaluator::SetMatchByTimeRemaining)
        .addProperty("MaxTimeRemaining", &GCTimeRemainingMetricEvaluator::GetMaxTimeRemaining, &GCTimeRemainingMetricEvaluator::SetMaxTimeRemaining)
        .addProperty("FilterByTimeRemaining", &GCTimeRemainingMetricEvaluator::GetFilterByTimeRemaining, &GCTimeRemainingMetricEvaluator::SetFilterByTimeRemaining)
        .addProperty("MinTimeRemaining", &GCTimeRemainingMetricEvaluator::GetMinTimeRemaining, &GCTimeRemainingMetricEvaluator::SetMinTimeRemaining)
        .addProperty("Parent", &GCTimeRemainingMetricEvaluator::GetParent, &GCTimeRemainingMetricEvaluator::SetParent)
        .addFunction("ToPtr", &GCTimeRemainingMetricEvaluator::ToPtr)
        .addFunction("IsValid", &GCTimeRemainingMetricEvaluator::IsValid)
        .endClass();
}
GNmSyncTrackTimeRange_t::GNmSyncTrackTimeRange_t(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GNmSyncTrackTimeRange_t::GNmSyncTrackTimeRange_t(void *ptr) {
    m_ptr = ptr;
}
GNmSyncTrackTime_t GNmSyncTrackTimeRange_t::GetStartTime() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: NmSyncTrackTimeRange_t->StartTime(ptr=%p)", m_ptr));
    GNmSyncTrackTime_t value(GetSchemaPtr(m_ptr, "NmSyncTrackTimeRange_t", "m_startTime"));
    return value;
}
void GNmSyncTrackTimeRange_t::SetStartTime(GNmSyncTrackTime_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: NmSyncTrackTimeRange_t->StartTime(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'StartTime' is not possible.\n");
}
GNmSyncTrackTime_t GNmSyncTrackTimeRange_t::GetEndTime() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: NmSyncTrackTimeRange_t->EndTime(ptr=%p)", m_ptr));
    GNmSyncTrackTime_t value(GetSchemaPtr(m_ptr, "NmSyncTrackTimeRange_t", "m_endTime"));
    return value;
}
void GNmSyncTrackTimeRange_t::SetEndTime(GNmSyncTrackTime_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: NmSyncTrackTimeRange_t->EndTime(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'EndTime' is not possible.\n");
}
void* GNmSyncTrackTimeRange_t::GetPtr() {
    return m_ptr;
}
std::string GNmSyncTrackTimeRange_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GNmSyncTrackTimeRange_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassNmSyncTrackTimeRange_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GNmSyncTrackTimeRange_t>("NmSyncTrackTimeRange_t")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("StartTime", &GNmSyncTrackTimeRange_t::GetStartTime, &GNmSyncTrackTimeRange_t::SetStartTime)
        .addProperty("EndTime", &GNmSyncTrackTimeRange_t::GetEndTime, &GNmSyncTrackTimeRange_t::SetEndTime)
        .addFunction("ToPtr", &GNmSyncTrackTimeRange_t::ToPtr)
        .addFunction("IsValid", &GNmSyncTrackTimeRange_t::IsValid)
        .endClass();
}
GCAnimActivity::GCAnimActivity(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCAnimActivity::GCAnimActivity(void *ptr) {
    m_ptr = ptr;
}
int32_t GCAnimActivity::GetActivity() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CAnimActivity->Activity(ptr=%p)", m_ptr));
    return GetSchemaValue<int32_t>(m_ptr, "CAnimActivity", "m_nActivity");
}
void GCAnimActivity::SetActivity(int32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CAnimActivity->Activity(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CAnimActivity", "m_nActivity", false, value);
}
int32_t GCAnimActivity::GetFlags() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CAnimActivity->Flags(ptr=%p)", m_ptr));
    return GetSchemaValue<int32_t>(m_ptr, "CAnimActivity", "m_nFlags");
}
void GCAnimActivity::SetFlags(int32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CAnimActivity->Flags(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CAnimActivity", "m_nFlags", false, value);
}
int32_t GCAnimActivity::GetWeight() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CAnimActivity->Weight(ptr=%p)", m_ptr));
    return GetSchemaValue<int32_t>(m_ptr, "CAnimActivity", "m_nWeight");
}
void GCAnimActivity::SetWeight(int32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CAnimActivity->Weight(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CAnimActivity", "m_nWeight", false, value);
}
void* GCAnimActivity::GetPtr() {
    return m_ptr;
}
std::string GCAnimActivity::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCAnimActivity::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCAnimActivity(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCAnimActivity>("CAnimActivity")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Activity", &GCAnimActivity::GetActivity, &GCAnimActivity::SetActivity)
        .addProperty("Flags", &GCAnimActivity::GetFlags, &GCAnimActivity::SetFlags)
        .addProperty("Weight", &GCAnimActivity::GetWeight, &GCAnimActivity::SetWeight)
        .addFunction("ToPtr", &GCAnimActivity::ToPtr)
        .addFunction("IsValid", &GCAnimActivity::IsValid)
        .endClass();
}
GCNmGraphDefinition::GCNmGraphDefinition(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCNmGraphDefinition::GCNmGraphDefinition(void *ptr) {
    m_ptr = ptr;
}
std::vector<int16> GCNmGraphDefinition::GetPersistentNodeIndices() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CNmGraphDefinition->PersistentNodeIndices(ptr=%p)", m_ptr));
    CUtlVector<int16>* vec = GetSchemaValue<CUtlVector<int16>*>(m_ptr, "CNmGraphDefinition", "m_persistentNodeIndices"); std::vector<int16> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCNmGraphDefinition::SetPersistentNodeIndices(std::vector<int16> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CNmGraphDefinition->PersistentNodeIndices(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<int16>(m_ptr, "CNmGraphDefinition", "m_persistentNodeIndices", false, value);
}
int16_t GCNmGraphDefinition::GetRootNodeIdx() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CNmGraphDefinition->RootNodeIdx(ptr=%p)", m_ptr));
    return GetSchemaValue<int16_t>(m_ptr, "CNmGraphDefinition", "m_nRootNodeIdx");
}
void GCNmGraphDefinition::SetRootNodeIdx(int16_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CNmGraphDefinition->RootNodeIdx(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CNmGraphDefinition", "m_nRootNodeIdx", false, value);
}
std::vector<int16> GCNmGraphDefinition::GetVirtualParameterNodeIndices() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CNmGraphDefinition->VirtualParameterNodeIndices(ptr=%p)", m_ptr));
    CUtlVector<int16>* vec = GetSchemaValue<CUtlVector<int16>*>(m_ptr, "CNmGraphDefinition", "m_virtualParameterNodeIndices"); std::vector<int16> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCNmGraphDefinition::SetVirtualParameterNodeIndices(std::vector<int16> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CNmGraphDefinition->VirtualParameterNodeIndices(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<int16>(m_ptr, "CNmGraphDefinition", "m_virtualParameterNodeIndices", false, value);
}
std::vector<GCNmGraphDefinition> GCNmGraphDefinition::GetChildGraphSlots() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CNmGraphDefinition->ChildGraphSlots(ptr=%p)", m_ptr));
    CUtlVector<GCNmGraphDefinition>* vec = GetSchemaValue<CUtlVector<GCNmGraphDefinition>*>(m_ptr, "CNmGraphDefinition", "m_childGraphSlots"); std::vector<GCNmGraphDefinition> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCNmGraphDefinition::SetChildGraphSlots(std::vector<GCNmGraphDefinition> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CNmGraphDefinition->ChildGraphSlots(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<GCNmGraphDefinition>(m_ptr, "CNmGraphDefinition", "m_childGraphSlots", false, value);
}
std::vector<GCNmGraphDefinition> GCNmGraphDefinition::GetExternalGraphSlots() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CNmGraphDefinition->ExternalGraphSlots(ptr=%p)", m_ptr));
    CUtlVector<GCNmGraphDefinition>* vec = GetSchemaValue<CUtlVector<GCNmGraphDefinition>*>(m_ptr, "CNmGraphDefinition", "m_externalGraphSlots"); std::vector<GCNmGraphDefinition> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCNmGraphDefinition::SetExternalGraphSlots(std::vector<GCNmGraphDefinition> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CNmGraphDefinition->ExternalGraphSlots(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<GCNmGraphDefinition>(m_ptr, "CNmGraphDefinition", "m_externalGraphSlots", false, value);
}
void* GCNmGraphDefinition::GetPtr() {
    return m_ptr;
}
std::string GCNmGraphDefinition::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCNmGraphDefinition::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCNmGraphDefinition(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCNmGraphDefinition>("CNmGraphDefinition")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("PersistentNodeIndices", &GCNmGraphDefinition::GetPersistentNodeIndices, &GCNmGraphDefinition::SetPersistentNodeIndices)
        .addProperty("RootNodeIdx", &GCNmGraphDefinition::GetRootNodeIdx, &GCNmGraphDefinition::SetRootNodeIdx)
        .addProperty("VirtualParameterNodeIndices", &GCNmGraphDefinition::GetVirtualParameterNodeIndices, &GCNmGraphDefinition::SetVirtualParameterNodeIndices)
        .addProperty("ChildGraphSlots", &GCNmGraphDefinition::GetChildGraphSlots, &GCNmGraphDefinition::SetChildGraphSlots)
        .addProperty("ExternalGraphSlots", &GCNmGraphDefinition::GetExternalGraphSlots, &GCNmGraphDefinition::SetExternalGraphSlots)
        .addFunction("ToPtr", &GCNmGraphDefinition::ToPtr)
        .addFunction("IsValid", &GCNmGraphDefinition::IsValid)
        .endClass();
}
GCSolveIKChainUpdateNode::GCSolveIKChainUpdateNode(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCSolveIKChainUpdateNode::GCSolveIKChainUpdateNode(void *ptr) {
    m_ptr = ptr;
}
std::vector<GCSolveIKTargetHandle_t> GCSolveIKChainUpdateNode::GetTargetHandles() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CSolveIKChainUpdateNode->TargetHandles(ptr=%p)", m_ptr));
    CUtlVector<GCSolveIKTargetHandle_t>* vec = GetSchemaValue<CUtlVector<GCSolveIKTargetHandle_t>*>(m_ptr, "CSolveIKChainUpdateNode", "m_targetHandles"); std::vector<GCSolveIKTargetHandle_t> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCSolveIKChainUpdateNode::SetTargetHandles(std::vector<GCSolveIKTargetHandle_t> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CSolveIKChainUpdateNode->TargetHandles(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<GCSolveIKTargetHandle_t>(m_ptr, "CSolveIKChainUpdateNode", "m_targetHandles", false, value);
}
GSolveIKChainPoseOpFixedSettings_t GCSolveIKChainUpdateNode::GetOpFixedData() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CSolveIKChainUpdateNode->OpFixedData(ptr=%p)", m_ptr));
    GSolveIKChainPoseOpFixedSettings_t value(GetSchemaPtr(m_ptr, "CSolveIKChainUpdateNode", "m_opFixedData"));
    return value;
}
void GCSolveIKChainUpdateNode::SetOpFixedData(GSolveIKChainPoseOpFixedSettings_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CSolveIKChainUpdateNode->OpFixedData(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'OpFixedData' is not possible.\n");
}
void* GCSolveIKChainUpdateNode::GetPtr() {
    return m_ptr;
}
std::string GCSolveIKChainUpdateNode::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCSolveIKChainUpdateNode::IsValid() {
    return (m_ptr != nullptr);
}
GCUnaryUpdateNode GCSolveIKChainUpdateNode::GetParent() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CSolveIKChainUpdateNode::GetParent(ptr=%p)", m_ptr));
    GCUnaryUpdateNode value(m_ptr);
    return value;
}
void GCSolveIKChainUpdateNode::SetParent(GCUnaryUpdateNode value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CSolveIKChainUpdateNode::SetParent(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCSolveIKChainUpdateNode(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCSolveIKChainUpdateNode>("CSolveIKChainUpdateNode")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("TargetHandles", &GCSolveIKChainUpdateNode::GetTargetHandles, &GCSolveIKChainUpdateNode::SetTargetHandles)
        .addProperty("OpFixedData", &GCSolveIKChainUpdateNode::GetOpFixedData, &GCSolveIKChainUpdateNode::SetOpFixedData)
        .addProperty("Parent", &GCSolveIKChainUpdateNode::GetParent, &GCSolveIKChainUpdateNode::SetParent)
        .addFunction("ToPtr", &GCSolveIKChainUpdateNode::ToPtr)
        .addFunction("IsValid", &GCSolveIKChainUpdateNode::IsValid)
        .endClass();
}
GEventClientPollNetworking_t::GEventClientPollNetworking_t(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GEventClientPollNetworking_t::GEventClientPollNetworking_t(void *ptr) {
    m_ptr = ptr;
}
int32_t GEventClientPollNetworking_t::GetTickCount() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: EventClientPollNetworking_t->TickCount(ptr=%p)", m_ptr));
    return GetSchemaValue<int32_t>(m_ptr, "EventClientPollNetworking_t", "m_nTickCount");
}
void GEventClientPollNetworking_t::SetTickCount(int32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: EventClientPollNetworking_t->TickCount(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "EventClientPollNetworking_t", "m_nTickCount", true, value);
}
void* GEventClientPollNetworking_t::GetPtr() {
    return m_ptr;
}
std::string GEventClientPollNetworking_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GEventClientPollNetworking_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassEventClientPollNetworking_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GEventClientPollNetworking_t>("EventClientPollNetworking_t")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("TickCount", &GEventClientPollNetworking_t::GetTickCount, &GEventClientPollNetworking_t::SetTickCount)
        .addFunction("ToPtr", &GEventClientPollNetworking_t::ToPtr)
        .addFunction("IsValid", &GEventClientPollNetworking_t::IsValid)
        .endClass();
}
GCMeshletDescriptor::GCMeshletDescriptor(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCMeshletDescriptor::GCMeshletDescriptor(void *ptr) {
    m_ptr = ptr;
}
GCDrawCullingData GCMeshletDescriptor::GetCullingData() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CMeshletDescriptor->CullingData(ptr=%p)", m_ptr));
    GCDrawCullingData value(GetSchemaPtr(m_ptr, "CMeshletDescriptor", "m_CullingData"));
    return value;
}
void GCMeshletDescriptor::SetCullingData(GCDrawCullingData value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CMeshletDescriptor->CullingData(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'CullingData' is not possible.\n");
}
void* GCMeshletDescriptor::GetPtr() {
    return m_ptr;
}
std::string GCMeshletDescriptor::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCMeshletDescriptor::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCMeshletDescriptor(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCMeshletDescriptor>("CMeshletDescriptor")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("CullingData", &GCMeshletDescriptor::GetCullingData, &GCMeshletDescriptor::SetCullingData)
        .addFunction("ToPtr", &GCMeshletDescriptor::ToPtr)
        .addFunction("IsValid", &GCMeshletDescriptor::IsValid)
        .endClass();
}
GCNmLayerBlendNode__LayerDefinition_t::GCNmLayerBlendNode__LayerDefinition_t(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCNmLayerBlendNode__LayerDefinition_t::GCNmLayerBlendNode__LayerDefinition_t(void *ptr) {
    m_ptr = ptr;
}
int16_t GCNmLayerBlendNode__LayerDefinition_t::GetInputNodeIdx() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CNmLayerBlendNode__LayerDefinition_t->InputNodeIdx(ptr=%p)", m_ptr));
    return GetSchemaValue<int16_t>(m_ptr, "CNmLayerBlendNode__LayerDefinition_t", "m_nInputNodeIdx");
}
void GCNmLayerBlendNode__LayerDefinition_t::SetInputNodeIdx(int16_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CNmLayerBlendNode__LayerDefinition_t->InputNodeIdx(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CNmLayerBlendNode__LayerDefinition_t", "m_nInputNodeIdx", true, value);
}
int16_t GCNmLayerBlendNode__LayerDefinition_t::GetWeightValueNodeIdx() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CNmLayerBlendNode__LayerDefinition_t->WeightValueNodeIdx(ptr=%p)", m_ptr));
    return GetSchemaValue<int16_t>(m_ptr, "CNmLayerBlendNode__LayerDefinition_t", "m_nWeightValueNodeIdx");
}
void GCNmLayerBlendNode__LayerDefinition_t::SetWeightValueNodeIdx(int16_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CNmLayerBlendNode__LayerDefinition_t->WeightValueNodeIdx(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CNmLayerBlendNode__LayerDefinition_t", "m_nWeightValueNodeIdx", true, value);
}
int16_t GCNmLayerBlendNode__LayerDefinition_t::GetBoneMaskValueNodeIdx() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CNmLayerBlendNode__LayerDefinition_t->BoneMaskValueNodeIdx(ptr=%p)", m_ptr));
    return GetSchemaValue<int16_t>(m_ptr, "CNmLayerBlendNode__LayerDefinition_t", "m_nBoneMaskValueNodeIdx");
}
void GCNmLayerBlendNode__LayerDefinition_t::SetBoneMaskValueNodeIdx(int16_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CNmLayerBlendNode__LayerDefinition_t->BoneMaskValueNodeIdx(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CNmLayerBlendNode__LayerDefinition_t", "m_nBoneMaskValueNodeIdx", true, value);
}
int16_t GCNmLayerBlendNode__LayerDefinition_t::GetRootMotionWeightValueNodeIdx() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CNmLayerBlendNode__LayerDefinition_t->RootMotionWeightValueNodeIdx(ptr=%p)", m_ptr));
    return GetSchemaValue<int16_t>(m_ptr, "CNmLayerBlendNode__LayerDefinition_t", "m_nRootMotionWeightValueNodeIdx");
}
void GCNmLayerBlendNode__LayerDefinition_t::SetRootMotionWeightValueNodeIdx(int16_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CNmLayerBlendNode__LayerDefinition_t->RootMotionWeightValueNodeIdx(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CNmLayerBlendNode__LayerDefinition_t", "m_nRootMotionWeightValueNodeIdx", true, value);
}
bool GCNmLayerBlendNode__LayerDefinition_t::GetIsSynchronized() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CNmLayerBlendNode__LayerDefinition_t->IsSynchronized(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "CNmLayerBlendNode__LayerDefinition_t", "m_bIsSynchronized");
}
void GCNmLayerBlendNode__LayerDefinition_t::SetIsSynchronized(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CNmLayerBlendNode__LayerDefinition_t->IsSynchronized(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CNmLayerBlendNode__LayerDefinition_t", "m_bIsSynchronized", true, value);
}
bool GCNmLayerBlendNode__LayerDefinition_t::GetIgnoreEvents() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CNmLayerBlendNode__LayerDefinition_t->IgnoreEvents(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "CNmLayerBlendNode__LayerDefinition_t", "m_bIgnoreEvents");
}
void GCNmLayerBlendNode__LayerDefinition_t::SetIgnoreEvents(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CNmLayerBlendNode__LayerDefinition_t->IgnoreEvents(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CNmLayerBlendNode__LayerDefinition_t", "m_bIgnoreEvents", true, value);
}
bool GCNmLayerBlendNode__LayerDefinition_t::GetIsStateMachineLayer() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CNmLayerBlendNode__LayerDefinition_t->IsStateMachineLayer(ptr=%p)", m_ptr));
    return GetSchemaValue<bool>(m_ptr, "CNmLayerBlendNode__LayerDefinition_t", "m_bIsStateMachineLayer");
}
void GCNmLayerBlendNode__LayerDefinition_t::SetIsStateMachineLayer(bool value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CNmLayerBlendNode__LayerDefinition_t->IsStateMachineLayer(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CNmLayerBlendNode__LayerDefinition_t", "m_bIsStateMachineLayer", true, value);
}
uint64_t GCNmLayerBlendNode__LayerDefinition_t::GetBlendMode() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CNmLayerBlendNode__LayerDefinition_t->BlendMode(ptr=%p)", m_ptr));
    return GetSchemaValue<uint64_t>(m_ptr, "CNmLayerBlendNode__LayerDefinition_t", "m_blendMode");
}
void GCNmLayerBlendNode__LayerDefinition_t::SetBlendMode(uint64_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CNmLayerBlendNode__LayerDefinition_t->BlendMode(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CNmLayerBlendNode__LayerDefinition_t", "m_blendMode", true, value);
}
void* GCNmLayerBlendNode__LayerDefinition_t::GetPtr() {
    return m_ptr;
}
std::string GCNmLayerBlendNode__LayerDefinition_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCNmLayerBlendNode__LayerDefinition_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCNmLayerBlendNode__LayerDefinition_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCNmLayerBlendNode__LayerDefinition_t>("CNmLayerBlendNode__LayerDefinition_t")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("InputNodeIdx", &GCNmLayerBlendNode__LayerDefinition_t::GetInputNodeIdx, &GCNmLayerBlendNode__LayerDefinition_t::SetInputNodeIdx)
        .addProperty("WeightValueNodeIdx", &GCNmLayerBlendNode__LayerDefinition_t::GetWeightValueNodeIdx, &GCNmLayerBlendNode__LayerDefinition_t::SetWeightValueNodeIdx)
        .addProperty("BoneMaskValueNodeIdx", &GCNmLayerBlendNode__LayerDefinition_t::GetBoneMaskValueNodeIdx, &GCNmLayerBlendNode__LayerDefinition_t::SetBoneMaskValueNodeIdx)
        .addProperty("RootMotionWeightValueNodeIdx", &GCNmLayerBlendNode__LayerDefinition_t::GetRootMotionWeightValueNodeIdx, &GCNmLayerBlendNode__LayerDefinition_t::SetRootMotionWeightValueNodeIdx)
        .addProperty("IsSynchronized", &GCNmLayerBlendNode__LayerDefinition_t::GetIsSynchronized, &GCNmLayerBlendNode__LayerDefinition_t::SetIsSynchronized)
        .addProperty("IgnoreEvents", &GCNmLayerBlendNode__LayerDefinition_t::GetIgnoreEvents, &GCNmLayerBlendNode__LayerDefinition_t::SetIgnoreEvents)
        .addProperty("IsStateMachineLayer", &GCNmLayerBlendNode__LayerDefinition_t::GetIsStateMachineLayer, &GCNmLayerBlendNode__LayerDefinition_t::SetIsStateMachineLayer)
        .addProperty("BlendMode", &GCNmLayerBlendNode__LayerDefinition_t::GetBlendMode, &GCNmLayerBlendNode__LayerDefinition_t::SetBlendMode)
        .addFunction("ToPtr", &GCNmLayerBlendNode__LayerDefinition_t::ToPtr)
        .addFunction("IsValid", &GCNmLayerBlendNode__LayerDefinition_t::IsValid)
        .endClass();
}
GCAnimSequenceParams::GCAnimSequenceParams(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCAnimSequenceParams::GCAnimSequenceParams(void *ptr) {
    m_ptr = ptr;
}
float GCAnimSequenceParams::GetFadeInTime() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CAnimSequenceParams->FadeInTime(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CAnimSequenceParams", "m_flFadeInTime");
}
void GCAnimSequenceParams::SetFadeInTime(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CAnimSequenceParams->FadeInTime(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CAnimSequenceParams", "m_flFadeInTime", false, value);
}
float GCAnimSequenceParams::GetFadeOutTime() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CAnimSequenceParams->FadeOutTime(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CAnimSequenceParams", "m_flFadeOutTime");
}
void GCAnimSequenceParams::SetFadeOutTime(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CAnimSequenceParams->FadeOutTime(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CAnimSequenceParams", "m_flFadeOutTime", false, value);
}
void* GCAnimSequenceParams::GetPtr() {
    return m_ptr;
}
std::string GCAnimSequenceParams::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCAnimSequenceParams::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCAnimSequenceParams(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCAnimSequenceParams>("CAnimSequenceParams")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("FadeInTime", &GCAnimSequenceParams::GetFadeInTime, &GCAnimSequenceParams::SetFadeInTime)
        .addProperty("FadeOutTime", &GCAnimSequenceParams::GetFadeOutTime, &GCAnimSequenceParams::SetFadeOutTime)
        .addFunction("ToPtr", &GCAnimSequenceParams::ToPtr)
        .addFunction("IsValid", &GCAnimSequenceParams::IsValid)
        .endClass();
}
GCDemoSettingsComponentUpdater::GCDemoSettingsComponentUpdater(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCDemoSettingsComponentUpdater::GCDemoSettingsComponentUpdater(void *ptr) {
    m_ptr = ptr;
}
GCAnimDemoCaptureSettings GCDemoSettingsComponentUpdater::GetSettings() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CDemoSettingsComponentUpdater->Settings(ptr=%p)", m_ptr));
    GCAnimDemoCaptureSettings value(GetSchemaPtr(m_ptr, "CDemoSettingsComponentUpdater", "m_settings"));
    return value;
}
void GCDemoSettingsComponentUpdater::SetSettings(GCAnimDemoCaptureSettings value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CDemoSettingsComponentUpdater->Settings(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Settings' is not possible.\n");
}
void* GCDemoSettingsComponentUpdater::GetPtr() {
    return m_ptr;
}
std::string GCDemoSettingsComponentUpdater::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCDemoSettingsComponentUpdater::IsValid() {
    return (m_ptr != nullptr);
}
GCAnimComponentUpdater GCDemoSettingsComponentUpdater::GetParent() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CDemoSettingsComponentUpdater::GetParent(ptr=%p)", m_ptr));
    GCAnimComponentUpdater value(m_ptr);
    return value;
}
void GCDemoSettingsComponentUpdater::SetParent(GCAnimComponentUpdater value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CDemoSettingsComponentUpdater::SetParent(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCDemoSettingsComponentUpdater(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCDemoSettingsComponentUpdater>("CDemoSettingsComponentUpdater")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Settings", &GCDemoSettingsComponentUpdater::GetSettings, &GCDemoSettingsComponentUpdater::SetSettings)
        .addProperty("Parent", &GCDemoSettingsComponentUpdater::GetParent, &GCDemoSettingsComponentUpdater::SetParent)
        .addFunction("ToPtr", &GCDemoSettingsComponentUpdater::ToPtr)
        .addFunction("IsValid", &GCDemoSettingsComponentUpdater::IsValid)
        .endClass();
}
GCompositeMaterialAssemblyProcedure_t::GCompositeMaterialAssemblyProcedure_t(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCompositeMaterialAssemblyProcedure_t::GCompositeMaterialAssemblyProcedure_t(void *ptr) {
    m_ptr = ptr;
}
std::vector<GCompositeMaterialMatchFilter_t> GCompositeMaterialAssemblyProcedure_t::GetMatchFilters() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CompositeMaterialAssemblyProcedure_t->MatchFilters(ptr=%p)", m_ptr));
    CUtlVector<GCompositeMaterialMatchFilter_t>* vec = GetSchemaValue<CUtlVector<GCompositeMaterialMatchFilter_t>*>(m_ptr, "CompositeMaterialAssemblyProcedure_t", "m_vecMatchFilters"); std::vector<GCompositeMaterialMatchFilter_t> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCompositeMaterialAssemblyProcedure_t::SetMatchFilters(std::vector<GCompositeMaterialMatchFilter_t> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CompositeMaterialAssemblyProcedure_t->MatchFilters(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<GCompositeMaterialMatchFilter_t>(m_ptr, "CompositeMaterialAssemblyProcedure_t", "m_vecMatchFilters", true, value);
}
std::vector<GCompositeMaterialInputContainer_t> GCompositeMaterialAssemblyProcedure_t::GetCompositeInputContainers() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CompositeMaterialAssemblyProcedure_t->CompositeInputContainers(ptr=%p)", m_ptr));
    CUtlVector<GCompositeMaterialInputContainer_t>* vec = GetSchemaValue<CUtlVector<GCompositeMaterialInputContainer_t>*>(m_ptr, "CompositeMaterialAssemblyProcedure_t", "m_vecCompositeInputContainers"); std::vector<GCompositeMaterialInputContainer_t> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCompositeMaterialAssemblyProcedure_t::SetCompositeInputContainers(std::vector<GCompositeMaterialInputContainer_t> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CompositeMaterialAssemblyProcedure_t->CompositeInputContainers(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<GCompositeMaterialInputContainer_t>(m_ptr, "CompositeMaterialAssemblyProcedure_t", "m_vecCompositeInputContainers", true, value);
}
std::vector<GCompMatPropertyMutator_t> GCompositeMaterialAssemblyProcedure_t::GetPropertyMutators() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CompositeMaterialAssemblyProcedure_t->PropertyMutators(ptr=%p)", m_ptr));
    CUtlVector<GCompMatPropertyMutator_t>* vec = GetSchemaValue<CUtlVector<GCompMatPropertyMutator_t>*>(m_ptr, "CompositeMaterialAssemblyProcedure_t", "m_vecPropertyMutators"); std::vector<GCompMatPropertyMutator_t> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCompositeMaterialAssemblyProcedure_t::SetPropertyMutators(std::vector<GCompMatPropertyMutator_t> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CompositeMaterialAssemblyProcedure_t->PropertyMutators(ptr=%p)", m_ptr));
    SetSchemaValueCUtlVector<GCompMatPropertyMutator_t>(m_ptr, "CompositeMaterialAssemblyProcedure_t", "m_vecPropertyMutators", true, value);
}
void* GCompositeMaterialAssemblyProcedure_t::GetPtr() {
    return m_ptr;
}
std::string GCompositeMaterialAssemblyProcedure_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCompositeMaterialAssemblyProcedure_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCompositeMaterialAssemblyProcedure_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCompositeMaterialAssemblyProcedure_t>("CompositeMaterialAssemblyProcedure_t")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("MatchFilters", &GCompositeMaterialAssemblyProcedure_t::GetMatchFilters, &GCompositeMaterialAssemblyProcedure_t::SetMatchFilters)
        .addProperty("CompositeInputContainers", &GCompositeMaterialAssemblyProcedure_t::GetCompositeInputContainers, &GCompositeMaterialAssemblyProcedure_t::SetCompositeInputContainers)
        .addProperty("PropertyMutators", &GCompositeMaterialAssemblyProcedure_t::GetPropertyMutators, &GCompositeMaterialAssemblyProcedure_t::SetPropertyMutators)
        .addFunction("ToPtr", &GCompositeMaterialAssemblyProcedure_t::ToPtr)
        .addFunction("IsValid", &GCompositeMaterialAssemblyProcedure_t::IsValid)
        .endClass();
}
GCTaskHandshakeAnimTag::GCTaskHandshakeAnimTag(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCTaskHandshakeAnimTag::GCTaskHandshakeAnimTag(void *ptr) {
    m_ptr = ptr;
}
void* GCTaskHandshakeAnimTag::GetPtr() {
    return m_ptr;
}
std::string GCTaskHandshakeAnimTag::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCTaskHandshakeAnimTag::IsValid() {
    return (m_ptr != nullptr);
}
GCHandshakeAnimTagBase GCTaskHandshakeAnimTag::GetParent() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CTaskHandshakeAnimTag::GetParent(ptr=%p)", m_ptr));
    GCHandshakeAnimTagBase value(m_ptr);
    return value;
}
void GCTaskHandshakeAnimTag::SetParent(GCHandshakeAnimTagBase value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CTaskHandshakeAnimTag::SetParent(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCTaskHandshakeAnimTag(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCTaskHandshakeAnimTag>("CTaskHandshakeAnimTag")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Parent", &GCTaskHandshakeAnimTag::GetParent, &GCTaskHandshakeAnimTag::SetParent)
        .addFunction("ToPtr", &GCTaskHandshakeAnimTag::ToPtr)
        .addFunction("IsValid", &GCTaskHandshakeAnimTag::IsValid)
        .endClass();
}
GEventClientPauseSimulate_t::GEventClientPauseSimulate_t(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GEventClientPauseSimulate_t::GEventClientPauseSimulate_t(void *ptr) {
    m_ptr = ptr;
}
void* GEventClientPauseSimulate_t::GetPtr() {
    return m_ptr;
}
std::string GEventClientPauseSimulate_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GEventClientPauseSimulate_t::IsValid() {
    return (m_ptr != nullptr);
}
GEventSimulate_t GEventClientPauseSimulate_t::GetParent() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("EventClientPauseSimulate_t::GetParent(ptr=%p)", m_ptr));
    GEventSimulate_t value(m_ptr);
    return value;
}
void GEventClientPauseSimulate_t::SetParent(GEventSimulate_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("EventClientPauseSimulate_t::SetParent(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassEventClientPauseSimulate_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GEventClientPauseSimulate_t>("EventClientPauseSimulate_t")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("Parent", &GEventClientPauseSimulate_t::GetParent, &GEventClientPauseSimulate_t::SetParent)
        .addFunction("ToPtr", &GEventClientPauseSimulate_t::ToPtr)
        .addFunction("IsValid", &GEventClientPauseSimulate_t::IsValid)
        .endClass();
}
GCFireOverlay::GCFireOverlay(std::string ptr, lua_State* state) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
    plugin_name = FetchPluginName(state);
}
GCFireOverlay::GCFireOverlay(void *ptr) {
    m_ptr = ptr;
}
std::vector<Vector> GCFireOverlay::GetBaseColors() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CFireOverlay->BaseColors(ptr=%p,size=4)", m_ptr));
    Vector* outValue = (Vector*)GetSchemaPtr(m_ptr, "CFireOverlay", "m_vBaseColors"); std::vector<Vector> ret; for(int i = 0; i < 4; i++) { ret.push_back(outValue[i]); } return ret;
}
void GCFireOverlay::SetBaseColors(std::vector<Vector> value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CFireOverlay->BaseColors(ptr=%p,size=4)", m_ptr));
    if(value.size() != 4) return PLUGIN_PRINT("Schema SDK", "Field 'BaseColors' needs to have 4 values.\n");
    auto val = GetSchemaValuePtr<Vector>(m_ptr, "CFireOverlay", "m_vBaseColors");
    for(size_t i = 0; i < value.size(); i++) val[i] = value[i];
}
float GCFireOverlay::GetScale() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CFireOverlay->Scale(ptr=%p)", m_ptr));
    return GetSchemaValue<float>(m_ptr, "CFireOverlay", "m_flScale");
}
void GCFireOverlay::SetScale(float value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CFireOverlay->Scale(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CFireOverlay", "m_flScale", false, value);
}
int32_t GCFireOverlay::GetGUID() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Get: CFireOverlay->GUID(ptr=%p)", m_ptr));
    return GetSchemaValue<int32_t>(m_ptr, "CFireOverlay", "m_nGUID");
}
void GCFireOverlay::SetGUID(int32_t value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("SDK Set: CFireOverlay->GUID(ptr=%p)", m_ptr));
    SetSchemaValue(m_ptr, "CFireOverlay", "m_nGUID", false, value);
}
void* GCFireOverlay::GetPtr() {
    return m_ptr;
}
std::string GCFireOverlay::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCFireOverlay::IsValid() {
    return (m_ptr != nullptr);
}
GCGlowOverlay GCFireOverlay::GetParent() const {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CFireOverlay::GetParent(ptr=%p)", m_ptr));
    GCGlowOverlay value(m_ptr);
    return value;
}
void GCFireOverlay::SetParent(GCGlowOverlay value) {
    REGISTER_CALLSTACK(this->plugin_name, string_format("CFireOverlay::SetParent(ptr=%p)", m_ptr));
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCFireOverlay(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCFireOverlay>("CFireOverlay")
        .addConstructor<void (*)(std::string, lua_State*)>()
        .addProperty("BaseColors", &GCFireOverlay::GetBaseColors, &GCFireOverlay::SetBaseColors)
        .addProperty("Scale", &GCFireOverlay::GetScale, &GCFireOverlay::SetScale)
        .addProperty("GUID", &GCFireOverlay::GetGUID, &GCFireOverlay::SetGUID)
        .addProperty("Parent", &GCFireOverlay::GetParent, &GCFireOverlay::SetParent)
        .addFunction("ToPtr", &GCFireOverlay::ToPtr)
        .addFunction("IsValid", &GCFireOverlay::IsValid)
        .endClass();
}