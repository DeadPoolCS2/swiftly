#include "classes.h"

#include "../../../../sdk/entity/CBaseEntity.h"
#include "../../../../sdk/entity/CBasePlayerController.h"
#include "../../../../sdk/entity/CBaseModelEntity.h"
#include "../../../../sdk/entity/CRecipientFilters.h"
#include "../../../../player/PlayerManager.h"

GCFuncNavObstruction::GCFuncNavObstruction(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCFuncNavObstruction::GCFuncNavObstruction(void *ptr) {
    m_ptr = ptr;
}
bool GCFuncNavObstruction::GetDisabled() const {
    return GetSchemaValue<bool>(m_ptr, "CFuncNavObstruction", "m_bDisabled");
}
void GCFuncNavObstruction::SetDisabled(bool value) {
    SetSchemaValue(m_ptr, "CFuncNavObstruction", "m_bDisabled", false, value);
}
void* GCFuncNavObstruction::GetPtr() {
    return m_ptr;
}
std::string GCFuncNavObstruction::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCFuncNavObstruction::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseModelEntity GCFuncNavObstruction::GetParent() const {
    GCBaseModelEntity value(m_ptr);
    return value;
}
void GCFuncNavObstruction::SetParent(GCBaseModelEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCFuncNavObstruction(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCFuncNavObstruction>("CFuncNavObstruction")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Disabled", &GCFuncNavObstruction::GetDisabled, &GCFuncNavObstruction::SetDisabled)
        .addProperty("Parent", &GCFuncNavObstruction::GetParent, &GCFuncNavObstruction::SetParent)
        .addFunction("ToPtr", &GCFuncNavObstruction::ToPtr)
        .addFunction("IsValid", &GCFuncNavObstruction::IsValid)
        .endClass();
}
GCTriggerImpact::GCTriggerImpact(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCTriggerImpact::GCTriggerImpact(void *ptr) {
    m_ptr = ptr;
}
float GCTriggerImpact::GetMagnitude() const {
    return GetSchemaValue<float>(m_ptr, "CTriggerImpact", "m_flMagnitude");
}
void GCTriggerImpact::SetMagnitude(float value) {
    SetSchemaValue(m_ptr, "CTriggerImpact", "m_flMagnitude", false, value);
}
float GCTriggerImpact::GetNoise() const {
    return GetSchemaValue<float>(m_ptr, "CTriggerImpact", "m_flNoise");
}
void GCTriggerImpact::SetNoise(float value) {
    SetSchemaValue(m_ptr, "CTriggerImpact", "m_flNoise", false, value);
}
float GCTriggerImpact::GetViewkick() const {
    return GetSchemaValue<float>(m_ptr, "CTriggerImpact", "m_flViewkick");
}
void GCTriggerImpact::SetViewkick(float value) {
    SetSchemaValue(m_ptr, "CTriggerImpact", "m_flViewkick", false, value);
}
void* GCTriggerImpact::GetPtr() {
    return m_ptr;
}
std::string GCTriggerImpact::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCTriggerImpact::IsValid() {
    return (m_ptr != nullptr);
}
GCTriggerMultiple GCTriggerImpact::GetParent() const {
    GCTriggerMultiple value(m_ptr);
    return value;
}
void GCTriggerImpact::SetParent(GCTriggerMultiple value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCTriggerImpact(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCTriggerImpact>("CTriggerImpact")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Magnitude", &GCTriggerImpact::GetMagnitude, &GCTriggerImpact::SetMagnitude)
        .addProperty("Noise", &GCTriggerImpact::GetNoise, &GCTriggerImpact::SetNoise)
        .addProperty("Viewkick", &GCTriggerImpact::GetViewkick, &GCTriggerImpact::SetViewkick)
        .addProperty("Parent", &GCTriggerImpact::GetParent, &GCTriggerImpact::SetParent)
        .addFunction("ToPtr", &GCTriggerImpact::ToPtr)
        .addFunction("IsValid", &GCTriggerImpact::IsValid)
        .endClass();
}
GCSun::GCSun(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCSun::GCSun(void *ptr) {
    m_ptr = ptr;
}
Vector GCSun::GetDirection() const {
    return GetSchemaValue<Vector>(m_ptr, "CSun", "m_vDirection");
}
void GCSun::SetDirection(Vector value) {
    SetSchemaValue(m_ptr, "CSun", "m_vDirection", false, value);
}
Color GCSun::GetOverlay() const {
    return GetSchemaValue<Color>(m_ptr, "CSun", "m_clrOverlay");
}
void GCSun::SetOverlay(Color value) {
    SetSchemaValue(m_ptr, "CSun", "m_clrOverlay", false, value);
}
std::string GCSun::GetEffectName() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CSun", "m_iszEffectName").String();
}
void GCSun::SetEffectName(std::string value) {
    SetSchemaValue(m_ptr, "CSun", "m_iszEffectName", false, CUtlSymbolLarge(value.c_str()));
}
std::string GCSun::GetSSEffectName() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CSun", "m_iszSSEffectName").String();
}
void GCSun::SetSSEffectName(std::string value) {
    SetSchemaValue(m_ptr, "CSun", "m_iszSSEffectName", false, CUtlSymbolLarge(value.c_str()));
}
bool GCSun::GetOn() const {
    return GetSchemaValue<bool>(m_ptr, "CSun", "m_bOn");
}
void GCSun::SetOn(bool value) {
    SetSchemaValue(m_ptr, "CSun", "m_bOn", false, value);
}
bool GCSun::GetBmaxColor() const {
    return GetSchemaValue<bool>(m_ptr, "CSun", "m_bmaxColor");
}
void GCSun::SetBmaxColor(bool value) {
    SetSchemaValue(m_ptr, "CSun", "m_bmaxColor", false, value);
}
float GCSun::GetSize() const {
    return GetSchemaValue<float>(m_ptr, "CSun", "m_flSize");
}
void GCSun::SetSize(float value) {
    SetSchemaValue(m_ptr, "CSun", "m_flSize", false, value);
}
float GCSun::GetRotation() const {
    return GetSchemaValue<float>(m_ptr, "CSun", "m_flRotation");
}
void GCSun::SetRotation(float value) {
    SetSchemaValue(m_ptr, "CSun", "m_flRotation", false, value);
}
float GCSun::GetHazeScale() const {
    return GetSchemaValue<float>(m_ptr, "CSun", "m_flHazeScale");
}
void GCSun::SetHazeScale(float value) {
    SetSchemaValue(m_ptr, "CSun", "m_flHazeScale", false, value);
}
float GCSun::GetAlphaHaze() const {
    return GetSchemaValue<float>(m_ptr, "CSun", "m_flAlphaHaze");
}
void GCSun::SetAlphaHaze(float value) {
    SetSchemaValue(m_ptr, "CSun", "m_flAlphaHaze", false, value);
}
float GCSun::GetAlphaHdr() const {
    return GetSchemaValue<float>(m_ptr, "CSun", "m_flAlphaHdr");
}
void GCSun::SetAlphaHdr(float value) {
    SetSchemaValue(m_ptr, "CSun", "m_flAlphaHdr", false, value);
}
float GCSun::GetAlphaScale() const {
    return GetSchemaValue<float>(m_ptr, "CSun", "m_flAlphaScale");
}
void GCSun::SetAlphaScale(float value) {
    SetSchemaValue(m_ptr, "CSun", "m_flAlphaScale", false, value);
}
float GCSun::GetHDRColorScale() const {
    return GetSchemaValue<float>(m_ptr, "CSun", "m_flHDRColorScale");
}
void GCSun::SetHDRColorScale(float value) {
    SetSchemaValue(m_ptr, "CSun", "m_flHDRColorScale", false, value);
}
float GCSun::GetFarZScale() const {
    return GetSchemaValue<float>(m_ptr, "CSun", "m_flFarZScale");
}
void GCSun::SetFarZScale(float value) {
    SetSchemaValue(m_ptr, "CSun", "m_flFarZScale", false, value);
}
void* GCSun::GetPtr() {
    return m_ptr;
}
std::string GCSun::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCSun::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseModelEntity GCSun::GetParent() const {
    GCBaseModelEntity value(m_ptr);
    return value;
}
void GCSun::SetParent(GCBaseModelEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCSun(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCSun>("CSun")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Direction", &GCSun::GetDirection, &GCSun::SetDirection)
        .addProperty("Overlay", &GCSun::GetOverlay, &GCSun::SetOverlay)
        .addProperty("EffectName", &GCSun::GetEffectName, &GCSun::SetEffectName)
        .addProperty("SSEffectName", &GCSun::GetSSEffectName, &GCSun::SetSSEffectName)
        .addProperty("On", &GCSun::GetOn, &GCSun::SetOn)
        .addProperty("BmaxColor", &GCSun::GetBmaxColor, &GCSun::SetBmaxColor)
        .addProperty("Size", &GCSun::GetSize, &GCSun::SetSize)
        .addProperty("Rotation", &GCSun::GetRotation, &GCSun::SetRotation)
        .addProperty("HazeScale", &GCSun::GetHazeScale, &GCSun::SetHazeScale)
        .addProperty("AlphaHaze", &GCSun::GetAlphaHaze, &GCSun::SetAlphaHaze)
        .addProperty("AlphaHdr", &GCSun::GetAlphaHdr, &GCSun::SetAlphaHdr)
        .addProperty("AlphaScale", &GCSun::GetAlphaScale, &GCSun::SetAlphaScale)
        .addProperty("HDRColorScale", &GCSun::GetHDRColorScale, &GCSun::SetHDRColorScale)
        .addProperty("FarZScale", &GCSun::GetFarZScale, &GCSun::SetFarZScale)
        .addProperty("Parent", &GCSun::GetParent, &GCSun::SetParent)
        .addFunction("ToPtr", &GCSun::ToPtr)
        .addFunction("IsValid", &GCSun::IsValid)
        .endClass();
}
GCTriggerDetectBulletFire::GCTriggerDetectBulletFire(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCTriggerDetectBulletFire::GCTriggerDetectBulletFire(void *ptr) {
    m_ptr = ptr;
}
bool GCTriggerDetectBulletFire::GetPlayerFireOnly() const {
    return GetSchemaValue<bool>(m_ptr, "CTriggerDetectBulletFire", "m_bPlayerFireOnly");
}
void GCTriggerDetectBulletFire::SetPlayerFireOnly(bool value) {
    SetSchemaValue(m_ptr, "CTriggerDetectBulletFire", "m_bPlayerFireOnly", false, value);
}
GCEntityIOOutput GCTriggerDetectBulletFire::GetOnDetectedBulletFire() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CTriggerDetectBulletFire", "m_OnDetectedBulletFire"));
    return value;
}
void GCTriggerDetectBulletFire::SetOnDetectedBulletFire(GCEntityIOOutput value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'OnDetectedBulletFire' is not possible.\n");
}
void* GCTriggerDetectBulletFire::GetPtr() {
    return m_ptr;
}
std::string GCTriggerDetectBulletFire::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCTriggerDetectBulletFire::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseTrigger GCTriggerDetectBulletFire::GetParent() const {
    GCBaseTrigger value(m_ptr);
    return value;
}
void GCTriggerDetectBulletFire::SetParent(GCBaseTrigger value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCTriggerDetectBulletFire(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCTriggerDetectBulletFire>("CTriggerDetectBulletFire")
        .addConstructor<void (*)(std::string)>()
        .addProperty("PlayerFireOnly", &GCTriggerDetectBulletFire::GetPlayerFireOnly, &GCTriggerDetectBulletFire::SetPlayerFireOnly)
        .addProperty("OnDetectedBulletFire", &GCTriggerDetectBulletFire::GetOnDetectedBulletFire, &GCTriggerDetectBulletFire::SetOnDetectedBulletFire)
        .addProperty("Parent", &GCTriggerDetectBulletFire::GetParent, &GCTriggerDetectBulletFire::SetParent)
        .addFunction("ToPtr", &GCTriggerDetectBulletFire::ToPtr)
        .addFunction("IsValid", &GCTriggerDetectBulletFire::IsValid)
        .endClass();
}
GCWorld::GCWorld(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCWorld::GCWorld(void *ptr) {
    m_ptr = ptr;
}
void* GCWorld::GetPtr() {
    return m_ptr;
}
std::string GCWorld::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCWorld::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseModelEntity GCWorld::GetParent() const {
    GCBaseModelEntity value(m_ptr);
    return value;
}
void GCWorld::SetParent(GCBaseModelEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCWorld(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCWorld>("CWorld")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCWorld::GetParent, &GCWorld::SetParent)
        .addFunction("ToPtr", &GCWorld::ToPtr)
        .addFunction("IsValid", &GCWorld::IsValid)
        .endClass();
}
GCPointGiveAmmo::GCPointGiveAmmo(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCPointGiveAmmo::GCPointGiveAmmo(void *ptr) {
    m_ptr = ptr;
}
GCBaseEntity GCPointGiveAmmo::GetActivator() const {
    GCBaseEntity value((void*)(GetSchemaValue<CHandle<CEntityInstance>>(m_ptr, "CPointGiveAmmo", "m_pActivator").Get()));
    return value;
}
void GCPointGiveAmmo::SetActivator(GCBaseEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Activator' is not possible.\n");
}
void* GCPointGiveAmmo::GetPtr() {
    return m_ptr;
}
std::string GCPointGiveAmmo::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCPointGiveAmmo::IsValid() {
    return (m_ptr != nullptr);
}
GCPointEntity GCPointGiveAmmo::GetParent() const {
    GCPointEntity value(m_ptr);
    return value;
}
void GCPointGiveAmmo::SetParent(GCPointEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCPointGiveAmmo(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCPointGiveAmmo>("CPointGiveAmmo")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Activator", &GCPointGiveAmmo::GetActivator, &GCPointGiveAmmo::SetActivator)
        .addProperty("Parent", &GCPointGiveAmmo::GetParent, &GCPointGiveAmmo::SetParent)
        .addFunction("ToPtr", &GCPointGiveAmmo::ToPtr)
        .addFunction("IsValid", &GCPointGiveAmmo::IsValid)
        .endClass();
}
GCFuncMoveLinear::GCFuncMoveLinear(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCFuncMoveLinear::GCFuncMoveLinear(void *ptr) {
    m_ptr = ptr;
}
uint64_t GCFuncMoveLinear::GetAuthoredPosition() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CFuncMoveLinear", "m_authoredPosition");
}
void GCFuncMoveLinear::SetAuthoredPosition(uint64_t value) {
    SetSchemaValue(m_ptr, "CFuncMoveLinear", "m_authoredPosition", false, value);
}
QAngle GCFuncMoveLinear::GetMoveEntitySpace() const {
    return GetSchemaValue<QAngle>(m_ptr, "CFuncMoveLinear", "m_angMoveEntitySpace");
}
void GCFuncMoveLinear::SetMoveEntitySpace(QAngle value) {
    SetSchemaValue(m_ptr, "CFuncMoveLinear", "m_angMoveEntitySpace", false, value);
}
Vector GCFuncMoveLinear::GetMoveDirParentSpace() const {
    return GetSchemaValue<Vector>(m_ptr, "CFuncMoveLinear", "m_vecMoveDirParentSpace");
}
void GCFuncMoveLinear::SetMoveDirParentSpace(Vector value) {
    SetSchemaValue(m_ptr, "CFuncMoveLinear", "m_vecMoveDirParentSpace", false, value);
}
std::string GCFuncMoveLinear::GetSoundStart() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CFuncMoveLinear", "m_soundStart").String();
}
void GCFuncMoveLinear::SetSoundStart(std::string value) {
    SetSchemaValue(m_ptr, "CFuncMoveLinear", "m_soundStart", false, CUtlSymbolLarge(value.c_str()));
}
std::string GCFuncMoveLinear::GetSoundStop() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CFuncMoveLinear", "m_soundStop").String();
}
void GCFuncMoveLinear::SetSoundStop(std::string value) {
    SetSchemaValue(m_ptr, "CFuncMoveLinear", "m_soundStop", false, CUtlSymbolLarge(value.c_str()));
}
std::string GCFuncMoveLinear::GetCurrentSound() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CFuncMoveLinear", "m_currentSound").String();
}
void GCFuncMoveLinear::SetCurrentSound(std::string value) {
    SetSchemaValue(m_ptr, "CFuncMoveLinear", "m_currentSound", false, CUtlSymbolLarge(value.c_str()));
}
float GCFuncMoveLinear::GetBlockDamage() const {
    return GetSchemaValue<float>(m_ptr, "CFuncMoveLinear", "m_flBlockDamage");
}
void GCFuncMoveLinear::SetBlockDamage(float value) {
    SetSchemaValue(m_ptr, "CFuncMoveLinear", "m_flBlockDamage", false, value);
}
float GCFuncMoveLinear::GetStartPosition() const {
    return GetSchemaValue<float>(m_ptr, "CFuncMoveLinear", "m_flStartPosition");
}
void GCFuncMoveLinear::SetStartPosition(float value) {
    SetSchemaValue(m_ptr, "CFuncMoveLinear", "m_flStartPosition", false, value);
}
GCEntityIOOutput GCFuncMoveLinear::GetOnFullyOpen() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CFuncMoveLinear", "m_OnFullyOpen"));
    return value;
}
void GCFuncMoveLinear::SetOnFullyOpen(GCEntityIOOutput value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'OnFullyOpen' is not possible.\n");
}
GCEntityIOOutput GCFuncMoveLinear::GetOnFullyClosed() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CFuncMoveLinear", "m_OnFullyClosed"));
    return value;
}
void GCFuncMoveLinear::SetOnFullyClosed(GCEntityIOOutput value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'OnFullyClosed' is not possible.\n");
}
bool GCFuncMoveLinear::GetCreateMovableNavMesh() const {
    return GetSchemaValue<bool>(m_ptr, "CFuncMoveLinear", "m_bCreateMovableNavMesh");
}
void GCFuncMoveLinear::SetCreateMovableNavMesh(bool value) {
    SetSchemaValue(m_ptr, "CFuncMoveLinear", "m_bCreateMovableNavMesh", false, value);
}
bool GCFuncMoveLinear::GetCreateNavObstacle() const {
    return GetSchemaValue<bool>(m_ptr, "CFuncMoveLinear", "m_bCreateNavObstacle");
}
void GCFuncMoveLinear::SetCreateNavObstacle(bool value) {
    SetSchemaValue(m_ptr, "CFuncMoveLinear", "m_bCreateNavObstacle", false, value);
}
void* GCFuncMoveLinear::GetPtr() {
    return m_ptr;
}
std::string GCFuncMoveLinear::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCFuncMoveLinear::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseToggle GCFuncMoveLinear::GetParent() const {
    GCBaseToggle value(m_ptr);
    return value;
}
void GCFuncMoveLinear::SetParent(GCBaseToggle value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCFuncMoveLinear(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCFuncMoveLinear>("CFuncMoveLinear")
        .addConstructor<void (*)(std::string)>()
        .addProperty("AuthoredPosition", &GCFuncMoveLinear::GetAuthoredPosition, &GCFuncMoveLinear::SetAuthoredPosition)
        .addProperty("MoveEntitySpace", &GCFuncMoveLinear::GetMoveEntitySpace, &GCFuncMoveLinear::SetMoveEntitySpace)
        .addProperty("MoveDirParentSpace", &GCFuncMoveLinear::GetMoveDirParentSpace, &GCFuncMoveLinear::SetMoveDirParentSpace)
        .addProperty("SoundStart", &GCFuncMoveLinear::GetSoundStart, &GCFuncMoveLinear::SetSoundStart)
        .addProperty("SoundStop", &GCFuncMoveLinear::GetSoundStop, &GCFuncMoveLinear::SetSoundStop)
        .addProperty("CurrentSound", &GCFuncMoveLinear::GetCurrentSound, &GCFuncMoveLinear::SetCurrentSound)
        .addProperty("BlockDamage", &GCFuncMoveLinear::GetBlockDamage, &GCFuncMoveLinear::SetBlockDamage)
        .addProperty("StartPosition", &GCFuncMoveLinear::GetStartPosition, &GCFuncMoveLinear::SetStartPosition)
        .addProperty("OnFullyOpen", &GCFuncMoveLinear::GetOnFullyOpen, &GCFuncMoveLinear::SetOnFullyOpen)
        .addProperty("OnFullyClosed", &GCFuncMoveLinear::GetOnFullyClosed, &GCFuncMoveLinear::SetOnFullyClosed)
        .addProperty("CreateMovableNavMesh", &GCFuncMoveLinear::GetCreateMovableNavMesh, &GCFuncMoveLinear::SetCreateMovableNavMesh)
        .addProperty("CreateNavObstacle", &GCFuncMoveLinear::GetCreateNavObstacle, &GCFuncMoveLinear::SetCreateNavObstacle)
        .addProperty("Parent", &GCFuncMoveLinear::GetParent, &GCFuncMoveLinear::SetParent)
        .addFunction("ToPtr", &GCFuncMoveLinear::ToPtr)
        .addFunction("IsValid", &GCFuncMoveLinear::IsValid)
        .endClass();
}
GCPathParticleRope::GCPathParticleRope(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCPathParticleRope::GCPathParticleRope(void *ptr) {
    m_ptr = ptr;
}
bool GCPathParticleRope::GetStartActive() const {
    return GetSchemaValue<bool>(m_ptr, "CPathParticleRope", "m_bStartActive");
}
void GCPathParticleRope::SetStartActive(bool value) {
    SetSchemaValue(m_ptr, "CPathParticleRope", "m_bStartActive", false, value);
}
float GCPathParticleRope::GetMaxSimulationTime() const {
    return GetSchemaValue<float>(m_ptr, "CPathParticleRope", "m_flMaxSimulationTime");
}
void GCPathParticleRope::SetMaxSimulationTime(float value) {
    SetSchemaValue(m_ptr, "CPathParticleRope", "m_flMaxSimulationTime", false, value);
}
std::string GCPathParticleRope::GetEffectName() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CPathParticleRope", "m_iszEffectName").String();
}
void GCPathParticleRope::SetEffectName(std::string value) {
    SetSchemaValue(m_ptr, "CPathParticleRope", "m_iszEffectName", false, CUtlSymbolLarge(value.c_str()));
}
std::vector<CUtlSymbolLarge> GCPathParticleRope::GetPathNodes_Name() const {
    CUtlVector<CUtlSymbolLarge>* vec = GetSchemaValue<CUtlVector<CUtlSymbolLarge>*>(m_ptr, "CPathParticleRope", "m_PathNodes_Name"); std::vector<CUtlSymbolLarge> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCPathParticleRope::SetPathNodes_Name(std::vector<CUtlSymbolLarge> value) {
    SetSchemaValueCUtlVector<CUtlSymbolLarge>(m_ptr, "CPathParticleRope", "m_PathNodes_Name", false, value);
}
float GCPathParticleRope::GetParticleSpacing() const {
    return GetSchemaValue<float>(m_ptr, "CPathParticleRope", "m_flParticleSpacing");
}
void GCPathParticleRope::SetParticleSpacing(float value) {
    SetSchemaValue(m_ptr, "CPathParticleRope", "m_flParticleSpacing", false, value);
}
float GCPathParticleRope::GetSlack() const {
    return GetSchemaValue<float>(m_ptr, "CPathParticleRope", "m_flSlack");
}
void GCPathParticleRope::SetSlack(float value) {
    SetSchemaValue(m_ptr, "CPathParticleRope", "m_flSlack", false, value);
}
float GCPathParticleRope::GetRadius() const {
    return GetSchemaValue<float>(m_ptr, "CPathParticleRope", "m_flRadius");
}
void GCPathParticleRope::SetRadius(float value) {
    SetSchemaValue(m_ptr, "CPathParticleRope", "m_flRadius", false, value);
}
Color GCPathParticleRope::GetColorTint() const {
    return GetSchemaValue<Color>(m_ptr, "CPathParticleRope", "m_ColorTint");
}
void GCPathParticleRope::SetColorTint(Color value) {
    SetSchemaValue(m_ptr, "CPathParticleRope", "m_ColorTint", false, value);
}
int32_t GCPathParticleRope::GetEffectState() const {
    return GetSchemaValue<int32_t>(m_ptr, "CPathParticleRope", "m_nEffectState");
}
void GCPathParticleRope::SetEffectState(int32_t value) {
    SetSchemaValue(m_ptr, "CPathParticleRope", "m_nEffectState", false, value);
}
std::vector<Vector> GCPathParticleRope::GetPathNodes_Position() const {
    CUtlVector<Vector>* vec = GetSchemaValue<CUtlVector<Vector>*>(m_ptr, "CPathParticleRope", "m_PathNodes_Position"); std::vector<Vector> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCPathParticleRope::SetPathNodes_Position(std::vector<Vector> value) {
    SetSchemaValueCUtlVector<Vector>(m_ptr, "CPathParticleRope", "m_PathNodes_Position", false, value);
}
std::vector<Vector> GCPathParticleRope::GetPathNodes_TangentIn() const {
    CUtlVector<Vector>* vec = GetSchemaValue<CUtlVector<Vector>*>(m_ptr, "CPathParticleRope", "m_PathNodes_TangentIn"); std::vector<Vector> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCPathParticleRope::SetPathNodes_TangentIn(std::vector<Vector> value) {
    SetSchemaValueCUtlVector<Vector>(m_ptr, "CPathParticleRope", "m_PathNodes_TangentIn", false, value);
}
std::vector<Vector> GCPathParticleRope::GetPathNodes_TangentOut() const {
    CUtlVector<Vector>* vec = GetSchemaValue<CUtlVector<Vector>*>(m_ptr, "CPathParticleRope", "m_PathNodes_TangentOut"); std::vector<Vector> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCPathParticleRope::SetPathNodes_TangentOut(std::vector<Vector> value) {
    SetSchemaValueCUtlVector<Vector>(m_ptr, "CPathParticleRope", "m_PathNodes_TangentOut", false, value);
}
std::vector<Vector> GCPathParticleRope::GetPathNodes_Color() const {
    CUtlVector<Vector>* vec = GetSchemaValue<CUtlVector<Vector>*>(m_ptr, "CPathParticleRope", "m_PathNodes_Color"); std::vector<Vector> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCPathParticleRope::SetPathNodes_Color(std::vector<Vector> value) {
    SetSchemaValueCUtlVector<Vector>(m_ptr, "CPathParticleRope", "m_PathNodes_Color", false, value);
}
std::vector<bool> GCPathParticleRope::GetPathNodes_PinEnabled() const {
    CUtlVector<bool>* vec = GetSchemaValue<CUtlVector<bool>*>(m_ptr, "CPathParticleRope", "m_PathNodes_PinEnabled"); std::vector<bool> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCPathParticleRope::SetPathNodes_PinEnabled(std::vector<bool> value) {
    SetSchemaValueCUtlVector<bool>(m_ptr, "CPathParticleRope", "m_PathNodes_PinEnabled", false, value);
}
std::vector<float32> GCPathParticleRope::GetPathNodes_RadiusScale() const {
    CUtlVector<float32>* vec = GetSchemaValue<CUtlVector<float32>*>(m_ptr, "CPathParticleRope", "m_PathNodes_RadiusScale"); std::vector<float32> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCPathParticleRope::SetPathNodes_RadiusScale(std::vector<float32> value) {
    SetSchemaValueCUtlVector<float32>(m_ptr, "CPathParticleRope", "m_PathNodes_RadiusScale", false, value);
}
void* GCPathParticleRope::GetPtr() {
    return m_ptr;
}
std::string GCPathParticleRope::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCPathParticleRope::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseEntity GCPathParticleRope::GetParent() const {
    GCBaseEntity value(m_ptr);
    return value;
}
void GCPathParticleRope::SetParent(GCBaseEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCPathParticleRope(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCPathParticleRope>("CPathParticleRope")
        .addConstructor<void (*)(std::string)>()
        .addProperty("StartActive", &GCPathParticleRope::GetStartActive, &GCPathParticleRope::SetStartActive)
        .addProperty("MaxSimulationTime", &GCPathParticleRope::GetMaxSimulationTime, &GCPathParticleRope::SetMaxSimulationTime)
        .addProperty("EffectName", &GCPathParticleRope::GetEffectName, &GCPathParticleRope::SetEffectName)
        .addProperty("PathNodes_Name", &GCPathParticleRope::GetPathNodes_Name, &GCPathParticleRope::SetPathNodes_Name)
        .addProperty("ParticleSpacing", &GCPathParticleRope::GetParticleSpacing, &GCPathParticleRope::SetParticleSpacing)
        .addProperty("Slack", &GCPathParticleRope::GetSlack, &GCPathParticleRope::SetSlack)
        .addProperty("Radius", &GCPathParticleRope::GetRadius, &GCPathParticleRope::SetRadius)
        .addProperty("ColorTint", &GCPathParticleRope::GetColorTint, &GCPathParticleRope::SetColorTint)
        .addProperty("EffectState", &GCPathParticleRope::GetEffectState, &GCPathParticleRope::SetEffectState)
        .addProperty("PathNodes_Position", &GCPathParticleRope::GetPathNodes_Position, &GCPathParticleRope::SetPathNodes_Position)
        .addProperty("PathNodes_TangentIn", &GCPathParticleRope::GetPathNodes_TangentIn, &GCPathParticleRope::SetPathNodes_TangentIn)
        .addProperty("PathNodes_TangentOut", &GCPathParticleRope::GetPathNodes_TangentOut, &GCPathParticleRope::SetPathNodes_TangentOut)
        .addProperty("PathNodes_Color", &GCPathParticleRope::GetPathNodes_Color, &GCPathParticleRope::SetPathNodes_Color)
        .addProperty("PathNodes_PinEnabled", &GCPathParticleRope::GetPathNodes_PinEnabled, &GCPathParticleRope::SetPathNodes_PinEnabled)
        .addProperty("PathNodes_RadiusScale", &GCPathParticleRope::GetPathNodes_RadiusScale, &GCPathParticleRope::SetPathNodes_RadiusScale)
        .addProperty("Parent", &GCPathParticleRope::GetParent, &GCPathParticleRope::SetParent)
        .addFunction("ToPtr", &GCPathParticleRope::ToPtr)
        .addFunction("IsValid", &GCPathParticleRope::IsValid)
        .endClass();
}
GCPlayerVisibility::GCPlayerVisibility(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCPlayerVisibility::GCPlayerVisibility(void *ptr) {
    m_ptr = ptr;
}
float GCPlayerVisibility::GetVisibilityStrength() const {
    return GetSchemaValue<float>(m_ptr, "CPlayerVisibility", "m_flVisibilityStrength");
}
void GCPlayerVisibility::SetVisibilityStrength(float value) {
    SetSchemaValue(m_ptr, "CPlayerVisibility", "m_flVisibilityStrength", false, value);
}
float GCPlayerVisibility::GetFogDistanceMultiplier() const {
    return GetSchemaValue<float>(m_ptr, "CPlayerVisibility", "m_flFogDistanceMultiplier");
}
void GCPlayerVisibility::SetFogDistanceMultiplier(float value) {
    SetSchemaValue(m_ptr, "CPlayerVisibility", "m_flFogDistanceMultiplier", false, value);
}
float GCPlayerVisibility::GetFogMaxDensityMultiplier() const {
    return GetSchemaValue<float>(m_ptr, "CPlayerVisibility", "m_flFogMaxDensityMultiplier");
}
void GCPlayerVisibility::SetFogMaxDensityMultiplier(float value) {
    SetSchemaValue(m_ptr, "CPlayerVisibility", "m_flFogMaxDensityMultiplier", false, value);
}
float GCPlayerVisibility::GetFadeTime() const {
    return GetSchemaValue<float>(m_ptr, "CPlayerVisibility", "m_flFadeTime");
}
void GCPlayerVisibility::SetFadeTime(float value) {
    SetSchemaValue(m_ptr, "CPlayerVisibility", "m_flFadeTime", false, value);
}
bool GCPlayerVisibility::GetStartDisabled() const {
    return GetSchemaValue<bool>(m_ptr, "CPlayerVisibility", "m_bStartDisabled");
}
void GCPlayerVisibility::SetStartDisabled(bool value) {
    SetSchemaValue(m_ptr, "CPlayerVisibility", "m_bStartDisabled", false, value);
}
bool GCPlayerVisibility::GetIsEnabled() const {
    return GetSchemaValue<bool>(m_ptr, "CPlayerVisibility", "m_bIsEnabled");
}
void GCPlayerVisibility::SetIsEnabled(bool value) {
    SetSchemaValue(m_ptr, "CPlayerVisibility", "m_bIsEnabled", false, value);
}
void* GCPlayerVisibility::GetPtr() {
    return m_ptr;
}
std::string GCPlayerVisibility::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCPlayerVisibility::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseEntity GCPlayerVisibility::GetParent() const {
    GCBaseEntity value(m_ptr);
    return value;
}
void GCPlayerVisibility::SetParent(GCBaseEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCPlayerVisibility(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCPlayerVisibility>("CPlayerVisibility")
        .addConstructor<void (*)(std::string)>()
        .addProperty("VisibilityStrength", &GCPlayerVisibility::GetVisibilityStrength, &GCPlayerVisibility::SetVisibilityStrength)
        .addProperty("FogDistanceMultiplier", &GCPlayerVisibility::GetFogDistanceMultiplier, &GCPlayerVisibility::SetFogDistanceMultiplier)
        .addProperty("FogMaxDensityMultiplier", &GCPlayerVisibility::GetFogMaxDensityMultiplier, &GCPlayerVisibility::SetFogMaxDensityMultiplier)
        .addProperty("FadeTime", &GCPlayerVisibility::GetFadeTime, &GCPlayerVisibility::SetFadeTime)
        .addProperty("StartDisabled", &GCPlayerVisibility::GetStartDisabled, &GCPlayerVisibility::SetStartDisabled)
        .addProperty("IsEnabled", &GCPlayerVisibility::GetIsEnabled, &GCPlayerVisibility::SetIsEnabled)
        .addProperty("Parent", &GCPlayerVisibility::GetParent, &GCPlayerVisibility::SetParent)
        .addFunction("ToPtr", &GCPlayerVisibility::ToPtr)
        .addFunction("IsValid", &GCPlayerVisibility::IsValid)
        .endClass();
}
GCPointTeleport::GCPointTeleport(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCPointTeleport::GCPointTeleport(void *ptr) {
    m_ptr = ptr;
}
Vector GCPointTeleport::GetSaveOrigin() const {
    return GetSchemaValue<Vector>(m_ptr, "CPointTeleport", "m_vSaveOrigin");
}
void GCPointTeleport::SetSaveOrigin(Vector value) {
    SetSchemaValue(m_ptr, "CPointTeleport", "m_vSaveOrigin", false, value);
}
QAngle GCPointTeleport::GetSaveAngles() const {
    return GetSchemaValue<QAngle>(m_ptr, "CPointTeleport", "m_vSaveAngles");
}
void GCPointTeleport::SetSaveAngles(QAngle value) {
    SetSchemaValue(m_ptr, "CPointTeleport", "m_vSaveAngles", false, value);
}
bool GCPointTeleport::GetTeleportParentedEntities() const {
    return GetSchemaValue<bool>(m_ptr, "CPointTeleport", "m_bTeleportParentedEntities");
}
void GCPointTeleport::SetTeleportParentedEntities(bool value) {
    SetSchemaValue(m_ptr, "CPointTeleport", "m_bTeleportParentedEntities", false, value);
}
bool GCPointTeleport::GetTeleportUseCurrentAngle() const {
    return GetSchemaValue<bool>(m_ptr, "CPointTeleport", "m_bTeleportUseCurrentAngle");
}
void GCPointTeleport::SetTeleportUseCurrentAngle(bool value) {
    SetSchemaValue(m_ptr, "CPointTeleport", "m_bTeleportUseCurrentAngle", false, value);
}
void* GCPointTeleport::GetPtr() {
    return m_ptr;
}
std::string GCPointTeleport::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCPointTeleport::IsValid() {
    return (m_ptr != nullptr);
}
GCServerOnlyPointEntity GCPointTeleport::GetParent() const {
    GCServerOnlyPointEntity value(m_ptr);
    return value;
}
void GCPointTeleport::SetParent(GCServerOnlyPointEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCPointTeleport(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCPointTeleport>("CPointTeleport")
        .addConstructor<void (*)(std::string)>()
        .addProperty("SaveOrigin", &GCPointTeleport::GetSaveOrigin, &GCPointTeleport::SetSaveOrigin)
        .addProperty("SaveAngles", &GCPointTeleport::GetSaveAngles, &GCPointTeleport::SetSaveAngles)
        .addProperty("TeleportParentedEntities", &GCPointTeleport::GetTeleportParentedEntities, &GCPointTeleport::SetTeleportParentedEntities)
        .addProperty("TeleportUseCurrentAngle", &GCPointTeleport::GetTeleportUseCurrentAngle, &GCPointTeleport::SetTeleportUseCurrentAngle)
        .addProperty("Parent", &GCPointTeleport::GetParent, &GCPointTeleport::SetParent)
        .addFunction("ToPtr", &GCPointTeleport::ToPtr)
        .addFunction("IsValid", &GCPointTeleport::IsValid)
        .endClass();
}
GCAK47::GCAK47(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCAK47::GCAK47(void *ptr) {
    m_ptr = ptr;
}
void* GCAK47::GetPtr() {
    return m_ptr;
}
std::string GCAK47::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCAK47::IsValid() {
    return (m_ptr != nullptr);
}
GCCSWeaponBaseGun GCAK47::GetParent() const {
    GCCSWeaponBaseGun value(m_ptr);
    return value;
}
void GCAK47::SetParent(GCCSWeaponBaseGun value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCAK47(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCAK47>("CAK47")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCAK47::GetParent, &GCAK47::SetParent)
        .addFunction("ToPtr", &GCAK47::ToPtr)
        .addFunction("IsValid", &GCAK47::IsValid)
        .endClass();
}
GCTriggerTeleport::GCTriggerTeleport(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCTriggerTeleport::GCTriggerTeleport(void *ptr) {
    m_ptr = ptr;
}
std::string GCTriggerTeleport::GetLandmark() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CTriggerTeleport", "m_iLandmark").String();
}
void GCTriggerTeleport::SetLandmark(std::string value) {
    SetSchemaValue(m_ptr, "CTriggerTeleport", "m_iLandmark", false, CUtlSymbolLarge(value.c_str()));
}
bool GCTriggerTeleport::GetUseLandmarkAngles() const {
    return GetSchemaValue<bool>(m_ptr, "CTriggerTeleport", "m_bUseLandmarkAngles");
}
void GCTriggerTeleport::SetUseLandmarkAngles(bool value) {
    SetSchemaValue(m_ptr, "CTriggerTeleport", "m_bUseLandmarkAngles", false, value);
}
bool GCTriggerTeleport::GetMirrorPlayer() const {
    return GetSchemaValue<bool>(m_ptr, "CTriggerTeleport", "m_bMirrorPlayer");
}
void GCTriggerTeleport::SetMirrorPlayer(bool value) {
    SetSchemaValue(m_ptr, "CTriggerTeleport", "m_bMirrorPlayer", false, value);
}
void* GCTriggerTeleport::GetPtr() {
    return m_ptr;
}
std::string GCTriggerTeleport::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCTriggerTeleport::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseTrigger GCTriggerTeleport::GetParent() const {
    GCBaseTrigger value(m_ptr);
    return value;
}
void GCTriggerTeleport::SetParent(GCBaseTrigger value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCTriggerTeleport(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCTriggerTeleport>("CTriggerTeleport")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Landmark", &GCTriggerTeleport::GetLandmark, &GCTriggerTeleport::SetLandmark)
        .addProperty("UseLandmarkAngles", &GCTriggerTeleport::GetUseLandmarkAngles, &GCTriggerTeleport::SetUseLandmarkAngles)
        .addProperty("MirrorPlayer", &GCTriggerTeleport::GetMirrorPlayer, &GCTriggerTeleport::SetMirrorPlayer)
        .addProperty("Parent", &GCTriggerTeleport::GetParent, &GCTriggerTeleport::SetParent)
        .addFunction("ToPtr", &GCTriggerTeleport::ToPtr)
        .addFunction("IsValid", &GCTriggerTeleport::IsValid)
        .endClass();
}
GCCSObserver_CameraServices::GCCSObserver_CameraServices(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCCSObserver_CameraServices::GCCSObserver_CameraServices(void *ptr) {
    m_ptr = ptr;
}
void* GCCSObserver_CameraServices::GetPtr() {
    return m_ptr;
}
std::string GCCSObserver_CameraServices::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCCSObserver_CameraServices::IsValid() {
    return (m_ptr != nullptr);
}
GCCSPlayerBase_CameraServices GCCSObserver_CameraServices::GetParent() const {
    GCCSPlayerBase_CameraServices value(m_ptr);
    return value;
}
void GCCSObserver_CameraServices::SetParent(GCCSPlayerBase_CameraServices value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCCSObserver_CameraServices(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCCSObserver_CameraServices>("CCSObserver_CameraServices")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCCSObserver_CameraServices::GetParent, &GCCSObserver_CameraServices::SetParent)
        .addFunction("ToPtr", &GCCSObserver_CameraServices::ToPtr)
        .addFunction("IsValid", &GCCSObserver_CameraServices::IsValid)
        .endClass();
}
GCCSGO_TeamIntroTerroristPosition::GCCSGO_TeamIntroTerroristPosition(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCCSGO_TeamIntroTerroristPosition::GCCSGO_TeamIntroTerroristPosition(void *ptr) {
    m_ptr = ptr;
}
void* GCCSGO_TeamIntroTerroristPosition::GetPtr() {
    return m_ptr;
}
std::string GCCSGO_TeamIntroTerroristPosition::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCCSGO_TeamIntroTerroristPosition::IsValid() {
    return (m_ptr != nullptr);
}
GCCSGO_TeamIntroCharacterPosition GCCSGO_TeamIntroTerroristPosition::GetParent() const {
    GCCSGO_TeamIntroCharacterPosition value(m_ptr);
    return value;
}
void GCCSGO_TeamIntroTerroristPosition::SetParent(GCCSGO_TeamIntroCharacterPosition value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCCSGO_TeamIntroTerroristPosition(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCCSGO_TeamIntroTerroristPosition>("CCSGO_TeamIntroTerroristPosition")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCCSGO_TeamIntroTerroristPosition::GetParent, &GCCSGO_TeamIntroTerroristPosition::SetParent)
        .addFunction("ToPtr", &GCCSGO_TeamIntroTerroristPosition::ToPtr)
        .addFunction("IsValid", &GCCSGO_TeamIntroTerroristPosition::IsValid)
        .endClass();
}
GCFuncMover::GCFuncMover(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCFuncMover::GCFuncMover(void *ptr) {
    m_ptr = ptr;
}
std::string GCFuncMover::GetPathName() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CFuncMover", "m_iszPathName").String();
}
void GCFuncMover::SetPathName(std::string value) {
    SetSchemaValue(m_ptr, "CFuncMover", "m_iszPathName", false, CUtlSymbolLarge(value.c_str()));
}
GCPathMover GCFuncMover::GetPathMover() const {
    GCPathMover value((void*)(GetSchemaValue<CHandle<CEntityInstance>>(m_ptr, "CFuncMover", "m_hPathMover").Get()));
    return value;
}
void GCFuncMover::SetPathMover(GCPathMover value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'PathMover' is not possible.\n");
}
std::string GCFuncMover::GetPathNodeStart() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CFuncMover", "m_iszPathNodeStart").String();
}
void GCFuncMover::SetPathNodeStart(std::string value) {
    SetSchemaValue(m_ptr, "CFuncMover", "m_iszPathNodeStart", false, CUtlSymbolLarge(value.c_str()));
}
GCFuncMover GCFuncMover::GetMoveType() const {
    GCFuncMover value(GetSchemaPtr(m_ptr, "CFuncMover", "m_eMoveType"));
    return value;
}
void GCFuncMover::SetMoveType(GCFuncMover value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'MoveType' is not possible.\n");
}
bool GCFuncMover::GetIsReversing() const {
    return GetSchemaValue<bool>(m_ptr, "CFuncMover", "m_bIsReversing");
}
void GCFuncMover::SetIsReversing(bool value) {
    SetSchemaValue(m_ptr, "CFuncMover", "m_bIsReversing", false, value);
}
Vector GCFuncMover::GetTarget() const {
    return GetSchemaValue<Vector>(m_ptr, "CFuncMover", "m_vTarget");
}
void GCFuncMover::SetTarget(Vector value) {
    SetSchemaValue(m_ptr, "CFuncMover", "m_vTarget", false, value);
}
float GCFuncMover::GetStartSpeed() const {
    return GetSchemaValue<float>(m_ptr, "CFuncMover", "m_flStartSpeed");
}
void GCFuncMover::SetStartSpeed(float value) {
    SetSchemaValue(m_ptr, "CFuncMover", "m_flStartSpeed", false, value);
}
float GCFuncMover::GetPathLocation() const {
    return GetSchemaValue<float>(m_ptr, "CFuncMover", "m_flPathLocation");
}
void GCFuncMover::SetPathLocation(float value) {
    SetSchemaValue(m_ptr, "CFuncMover", "m_flPathLocation", false, value);
}
float GCFuncMover::GetT() const {
    return GetSchemaValue<float>(m_ptr, "CFuncMover", "m_flT");
}
void GCFuncMover::SetT(float value) {
    SetSchemaValue(m_ptr, "CFuncMover", "m_flT", false, value);
}
int32_t GCFuncMover::GetCurrentNodeIndex() const {
    return GetSchemaValue<int32_t>(m_ptr, "CFuncMover", "m_nCurrentNodeIndex");
}
void GCFuncMover::SetCurrentNodeIndex(int32_t value) {
    SetSchemaValue(m_ptr, "CFuncMover", "m_nCurrentNodeIndex", false, value);
}
int32_t GCFuncMover::GetPreviousNodeIndex() const {
    return GetSchemaValue<int32_t>(m_ptr, "CFuncMover", "m_nPreviousNodeIndex");
}
void GCFuncMover::SetPreviousNodeIndex(int32_t value) {
    SetSchemaValue(m_ptr, "CFuncMover", "m_nPreviousNodeIndex", false, value);
}
bool GCFuncMover::GetFixedOrientation() const {
    return GetSchemaValue<bool>(m_ptr, "CFuncMover", "m_bFixedOrientation");
}
void GCFuncMover::SetFixedOrientation(bool value) {
    SetSchemaValue(m_ptr, "CFuncMover", "m_bFixedOrientation", false, value);
}
bool GCFuncMover::GetFixedPitch() const {
    return GetSchemaValue<bool>(m_ptr, "CFuncMover", "m_bFixedPitch");
}
void GCFuncMover::SetFixedPitch(bool value) {
    SetSchemaValue(m_ptr, "CFuncMover", "m_bFixedPitch", false, value);
}
uint64_t GCFuncMover::GetSolidType() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CFuncMover", "m_eSolidType");
}
void GCFuncMover::SetSolidType(uint64_t value) {
    SetSchemaValue(m_ptr, "CFuncMover", "m_eSolidType", false, value);
}
bool GCFuncMover::GetIsMoving() const {
    return GetSchemaValue<bool>(m_ptr, "CFuncMover", "m_bIsMoving");
}
void GCFuncMover::SetIsMoving(bool value) {
    SetSchemaValue(m_ptr, "CFuncMover", "m_bIsMoving", false, value);
}
float GCFuncMover::GetTimeToReachMaxSpeed() const {
    return GetSchemaValue<float>(m_ptr, "CFuncMover", "m_flTimeToReachMaxSpeed");
}
void GCFuncMover::SetTimeToReachMaxSpeed(float value) {
    SetSchemaValue(m_ptr, "CFuncMover", "m_flTimeToReachMaxSpeed", false, value);
}
float GCFuncMover::GetTimeToReachZeroSpeed() const {
    return GetSchemaValue<float>(m_ptr, "CFuncMover", "m_flTimeToReachZeroSpeed");
}
void GCFuncMover::SetTimeToReachZeroSpeed(float value) {
    SetSchemaValue(m_ptr, "CFuncMover", "m_flTimeToReachZeroSpeed", false, value);
}
float GCFuncMover::GetTimeMovementStart() const {
    return GetSchemaValue<float>(m_ptr, "CFuncMover", "m_flTimeMovementStart");
}
void GCFuncMover::SetTimeMovementStart(float value) {
    SetSchemaValue(m_ptr, "CFuncMover", "m_flTimeMovementStart", false, value);
}
float GCFuncMover::GetTimeMovementStop() const {
    return GetSchemaValue<float>(m_ptr, "CFuncMover", "m_flTimeMovementStop");
}
void GCFuncMover::SetTimeMovementStop(float value) {
    SetSchemaValue(m_ptr, "CFuncMover", "m_flTimeMovementStop", false, value);
}
GCMoverPathNode GCFuncMover::GetStopAtNode() const {
    GCMoverPathNode value((void*)(GetSchemaValue<CHandle<CEntityInstance>>(m_ptr, "CFuncMover", "m_hStopAtNode").Get()));
    return value;
}
void GCFuncMover::SetStopAtNode(GCMoverPathNode value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'StopAtNode' is not possible.\n");
}
float GCFuncMover::GetPathLocationToBeginStop() const {
    return GetSchemaValue<float>(m_ptr, "CFuncMover", "m_flPathLocationToBeginStop");
}
void GCFuncMover::SetPathLocationToBeginStop(float value) {
    SetSchemaValue(m_ptr, "CFuncMover", "m_flPathLocationToBeginStop", false, value);
}
bool GCFuncMover::GetMatchPathNodeUp() const {
    return GetSchemaValue<bool>(m_ptr, "CFuncMover", "m_bMatchPathNodeUp");
}
void GCFuncMover::SetMatchPathNodeUp(bool value) {
    SetSchemaValue(m_ptr, "CFuncMover", "m_bMatchPathNodeUp", false, value);
}
bool GCFuncMover::GetFacePlayer() const {
    return GetSchemaValue<bool>(m_ptr, "CFuncMover", "m_bFacePlayer");
}
void GCFuncMover::SetFacePlayer(bool value) {
    SetSchemaValue(m_ptr, "CFuncMover", "m_bFacePlayer", false, value);
}
float GCFuncMover::GetTimeStartRoll() const {
    return GetSchemaValue<float>(m_ptr, "CFuncMover", "m_flTimeStartRoll");
}
void GCFuncMover::SetTimeStartRoll(float value) {
    SetSchemaValue(m_ptr, "CFuncMover", "m_flTimeStartRoll", false, value);
}
Vector GCFuncMover::GetOriginalUp() const {
    return GetSchemaValue<Vector>(m_ptr, "CFuncMover", "m_vOriginalUp");
}
void GCFuncMover::SetOriginalUp(Vector value) {
    SetSchemaValue(m_ptr, "CFuncMover", "m_vOriginalUp", false, value);
}
float GCFuncMover::GetTimeToRollToNewUp() const {
    return GetSchemaValue<float>(m_ptr, "CFuncMover", "m_flTimeToRollToNewUp");
}
void GCFuncMover::SetTimeToRollToNewUp(float value) {
    SetSchemaValue(m_ptr, "CFuncMover", "m_flTimeToRollToNewUp", false, value);
}
void* GCFuncMover::GetPtr() {
    return m_ptr;
}
std::string GCFuncMover::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCFuncMover::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseModelEntity GCFuncMover::GetParent() const {
    GCBaseModelEntity value(m_ptr);
    return value;
}
void GCFuncMover::SetParent(GCBaseModelEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCFuncMover(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCFuncMover>("CFuncMover")
        .addConstructor<void (*)(std::string)>()
        .addProperty("PathName", &GCFuncMover::GetPathName, &GCFuncMover::SetPathName)
        .addProperty("PathMover", &GCFuncMover::GetPathMover, &GCFuncMover::SetPathMover)
        .addProperty("PathNodeStart", &GCFuncMover::GetPathNodeStart, &GCFuncMover::SetPathNodeStart)
        .addProperty("MoveType", &GCFuncMover::GetMoveType, &GCFuncMover::SetMoveType)
        .addProperty("IsReversing", &GCFuncMover::GetIsReversing, &GCFuncMover::SetIsReversing)
        .addProperty("Target", &GCFuncMover::GetTarget, &GCFuncMover::SetTarget)
        .addProperty("StartSpeed", &GCFuncMover::GetStartSpeed, &GCFuncMover::SetStartSpeed)
        .addProperty("PathLocation", &GCFuncMover::GetPathLocation, &GCFuncMover::SetPathLocation)
        .addProperty("T", &GCFuncMover::GetT, &GCFuncMover::SetT)
        .addProperty("CurrentNodeIndex", &GCFuncMover::GetCurrentNodeIndex, &GCFuncMover::SetCurrentNodeIndex)
        .addProperty("PreviousNodeIndex", &GCFuncMover::GetPreviousNodeIndex, &GCFuncMover::SetPreviousNodeIndex)
        .addProperty("FixedOrientation", &GCFuncMover::GetFixedOrientation, &GCFuncMover::SetFixedOrientation)
        .addProperty("FixedPitch", &GCFuncMover::GetFixedPitch, &GCFuncMover::SetFixedPitch)
        .addProperty("SolidType", &GCFuncMover::GetSolidType, &GCFuncMover::SetSolidType)
        .addProperty("IsMoving", &GCFuncMover::GetIsMoving, &GCFuncMover::SetIsMoving)
        .addProperty("TimeToReachMaxSpeed", &GCFuncMover::GetTimeToReachMaxSpeed, &GCFuncMover::SetTimeToReachMaxSpeed)
        .addProperty("TimeToReachZeroSpeed", &GCFuncMover::GetTimeToReachZeroSpeed, &GCFuncMover::SetTimeToReachZeroSpeed)
        .addProperty("TimeMovementStart", &GCFuncMover::GetTimeMovementStart, &GCFuncMover::SetTimeMovementStart)
        .addProperty("TimeMovementStop", &GCFuncMover::GetTimeMovementStop, &GCFuncMover::SetTimeMovementStop)
        .addProperty("StopAtNode", &GCFuncMover::GetStopAtNode, &GCFuncMover::SetStopAtNode)
        .addProperty("PathLocationToBeginStop", &GCFuncMover::GetPathLocationToBeginStop, &GCFuncMover::SetPathLocationToBeginStop)
        .addProperty("MatchPathNodeUp", &GCFuncMover::GetMatchPathNodeUp, &GCFuncMover::SetMatchPathNodeUp)
        .addProperty("FacePlayer", &GCFuncMover::GetFacePlayer, &GCFuncMover::SetFacePlayer)
        .addProperty("TimeStartRoll", &GCFuncMover::GetTimeStartRoll, &GCFuncMover::SetTimeStartRoll)
        .addProperty("OriginalUp", &GCFuncMover::GetOriginalUp, &GCFuncMover::SetOriginalUp)
        .addProperty("TimeToRollToNewUp", &GCFuncMover::GetTimeToRollToNewUp, &GCFuncMover::SetTimeToRollToNewUp)
        .addProperty("Parent", &GCFuncMover::GetParent, &GCFuncMover::SetParent)
        .addFunction("ToPtr", &GCFuncMover::ToPtr)
        .addFunction("IsValid", &GCFuncMover::IsValid)
        .endClass();
}
GCCSPlayer_CameraServices::GCCSPlayer_CameraServices(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCCSPlayer_CameraServices::GCCSPlayer_CameraServices(void *ptr) {
    m_ptr = ptr;
}
void* GCCSPlayer_CameraServices::GetPtr() {
    return m_ptr;
}
std::string GCCSPlayer_CameraServices::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCCSPlayer_CameraServices::IsValid() {
    return (m_ptr != nullptr);
}
GCCSPlayerBase_CameraServices GCCSPlayer_CameraServices::GetParent() const {
    GCCSPlayerBase_CameraServices value(m_ptr);
    return value;
}
void GCCSPlayer_CameraServices::SetParent(GCCSPlayerBase_CameraServices value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCCSPlayer_CameraServices(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCCSPlayer_CameraServices>("CCSPlayer_CameraServices")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCCSPlayer_CameraServices::GetParent, &GCCSPlayer_CameraServices::SetParent)
        .addFunction("ToPtr", &GCCSPlayer_CameraServices::ToPtr)
        .addFunction("IsValid", &GCCSPlayer_CameraServices::IsValid)
        .endClass();
}
GCHEGrenade::GCHEGrenade(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCHEGrenade::GCHEGrenade(void *ptr) {
    m_ptr = ptr;
}
void* GCHEGrenade::GetPtr() {
    return m_ptr;
}
std::string GCHEGrenade::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCHEGrenade::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseCSGrenade GCHEGrenade::GetParent() const {
    GCBaseCSGrenade value(m_ptr);
    return value;
}
void GCHEGrenade::SetParent(GCBaseCSGrenade value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCHEGrenade(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCHEGrenade>("CHEGrenade")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCHEGrenade::GetParent, &GCHEGrenade::SetParent)
        .addFunction("ToPtr", &GCHEGrenade::ToPtr)
        .addFunction("IsValid", &GCHEGrenade::IsValid)
        .endClass();
}
GCGameEnd::GCGameEnd(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCGameEnd::GCGameEnd(void *ptr) {
    m_ptr = ptr;
}
void* GCGameEnd::GetPtr() {
    return m_ptr;
}
std::string GCGameEnd::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCGameEnd::IsValid() {
    return (m_ptr != nullptr);
}
GCRulePointEntity GCGameEnd::GetParent() const {
    GCRulePointEntity value(m_ptr);
    return value;
}
void GCGameEnd::SetParent(GCRulePointEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCGameEnd(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCGameEnd>("CGameEnd")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCGameEnd::GetParent, &GCGameEnd::SetParent)
        .addFunction("ToPtr", &GCGameEnd::ToPtr)
        .addFunction("IsValid", &GCGameEnd::IsValid)
        .endClass();
}
GCTriggerCallback::GCTriggerCallback(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCTriggerCallback::GCTriggerCallback(void *ptr) {
    m_ptr = ptr;
}
void* GCTriggerCallback::GetPtr() {
    return m_ptr;
}
std::string GCTriggerCallback::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCTriggerCallback::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseTrigger GCTriggerCallback::GetParent() const {
    GCBaseTrigger value(m_ptr);
    return value;
}
void GCTriggerCallback::SetParent(GCBaseTrigger value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCTriggerCallback(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCTriggerCallback>("CTriggerCallback")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCTriggerCallback::GetParent, &GCTriggerCallback::SetParent)
        .addFunction("ToPtr", &GCTriggerCallback::ToPtr)
        .addFunction("IsValid", &GCTriggerCallback::IsValid)
        .endClass();
}
GCBubbling::GCBubbling(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCBubbling::GCBubbling(void *ptr) {
    m_ptr = ptr;
}
int32_t GCBubbling::GetDensity() const {
    return GetSchemaValue<int32_t>(m_ptr, "CBubbling", "m_density");
}
void GCBubbling::SetDensity(int32_t value) {
    SetSchemaValue(m_ptr, "CBubbling", "m_density", false, value);
}
int32_t GCBubbling::GetFrequency() const {
    return GetSchemaValue<int32_t>(m_ptr, "CBubbling", "m_frequency");
}
void GCBubbling::SetFrequency(int32_t value) {
    SetSchemaValue(m_ptr, "CBubbling", "m_frequency", false, value);
}
int32_t GCBubbling::GetState() const {
    return GetSchemaValue<int32_t>(m_ptr, "CBubbling", "m_state");
}
void GCBubbling::SetState(int32_t value) {
    SetSchemaValue(m_ptr, "CBubbling", "m_state", false, value);
}
void* GCBubbling::GetPtr() {
    return m_ptr;
}
std::string GCBubbling::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCBubbling::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseModelEntity GCBubbling::GetParent() const {
    GCBaseModelEntity value(m_ptr);
    return value;
}
void GCBubbling::SetParent(GCBaseModelEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCBubbling(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCBubbling>("CBubbling")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Density", &GCBubbling::GetDensity, &GCBubbling::SetDensity)
        .addProperty("Frequency", &GCBubbling::GetFrequency, &GCBubbling::SetFrequency)
        .addProperty("State", &GCBubbling::GetState, &GCBubbling::SetState)
        .addProperty("Parent", &GCBubbling::GetParent, &GCBubbling::SetParent)
        .addFunction("ToPtr", &GCBubbling::ToPtr)
        .addFunction("IsValid", &GCBubbling::IsValid)
        .endClass();
}
GCTeamplayRules::GCTeamplayRules(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCTeamplayRules::GCTeamplayRules(void *ptr) {
    m_ptr = ptr;
}
void* GCTeamplayRules::GetPtr() {
    return m_ptr;
}
std::string GCTeamplayRules::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCTeamplayRules::IsValid() {
    return (m_ptr != nullptr);
}
GCMultiplayRules GCTeamplayRules::GetParent() const {
    GCMultiplayRules value(m_ptr);
    return value;
}
void GCTeamplayRules::SetParent(GCMultiplayRules value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCTeamplayRules(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCTeamplayRules>("CTeamplayRules")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCTeamplayRules::GetParent, &GCTeamplayRules::SetParent)
        .addFunction("ToPtr", &GCTeamplayRules::ToPtr)
        .addFunction("IsValid", &GCTeamplayRules::IsValid)
        .endClass();
}
GCPhysicsPropOverride::GCPhysicsPropOverride(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCPhysicsPropOverride::GCPhysicsPropOverride(void *ptr) {
    m_ptr = ptr;
}
void* GCPhysicsPropOverride::GetPtr() {
    return m_ptr;
}
std::string GCPhysicsPropOverride::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCPhysicsPropOverride::IsValid() {
    return (m_ptr != nullptr);
}
GCPhysicsProp GCPhysicsPropOverride::GetParent() const {
    GCPhysicsProp value(m_ptr);
    return value;
}
void GCPhysicsPropOverride::SetParent(GCPhysicsProp value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCPhysicsPropOverride(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCPhysicsPropOverride>("CPhysicsPropOverride")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCPhysicsPropOverride::GetParent, &GCPhysicsPropOverride::SetParent)
        .addFunction("ToPtr", &GCPhysicsPropOverride::ToPtr)
        .addFunction("IsValid", &GCPhysicsPropOverride::IsValid)
        .endClass();
}
GCAI_ChangeHintGroup::GCAI_ChangeHintGroup(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCAI_ChangeHintGroup::GCAI_ChangeHintGroup(void *ptr) {
    m_ptr = ptr;
}
int32_t GCAI_ChangeHintGroup::GetSearchType() const {
    return GetSchemaValue<int32_t>(m_ptr, "CAI_ChangeHintGroup", "m_iSearchType");
}
void GCAI_ChangeHintGroup::SetSearchType(int32_t value) {
    SetSchemaValue(m_ptr, "CAI_ChangeHintGroup", "m_iSearchType", false, value);
}
std::string GCAI_ChangeHintGroup::GetStrSearchName() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CAI_ChangeHintGroup", "m_strSearchName").String();
}
void GCAI_ChangeHintGroup::SetStrSearchName(std::string value) {
    SetSchemaValue(m_ptr, "CAI_ChangeHintGroup", "m_strSearchName", false, CUtlSymbolLarge(value.c_str()));
}
std::string GCAI_ChangeHintGroup::GetStrNewHintGroup() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CAI_ChangeHintGroup", "m_strNewHintGroup").String();
}
void GCAI_ChangeHintGroup::SetStrNewHintGroup(std::string value) {
    SetSchemaValue(m_ptr, "CAI_ChangeHintGroup", "m_strNewHintGroup", false, CUtlSymbolLarge(value.c_str()));
}
float GCAI_ChangeHintGroup::GetRadius() const {
    return GetSchemaValue<float>(m_ptr, "CAI_ChangeHintGroup", "m_flRadius");
}
void GCAI_ChangeHintGroup::SetRadius(float value) {
    SetSchemaValue(m_ptr, "CAI_ChangeHintGroup", "m_flRadius", false, value);
}
void* GCAI_ChangeHintGroup::GetPtr() {
    return m_ptr;
}
std::string GCAI_ChangeHintGroup::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCAI_ChangeHintGroup::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseEntity GCAI_ChangeHintGroup::GetParent() const {
    GCBaseEntity value(m_ptr);
    return value;
}
void GCAI_ChangeHintGroup::SetParent(GCBaseEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCAI_ChangeHintGroup(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCAI_ChangeHintGroup>("CAI_ChangeHintGroup")
        .addConstructor<void (*)(std::string)>()
        .addProperty("SearchType", &GCAI_ChangeHintGroup::GetSearchType, &GCAI_ChangeHintGroup::SetSearchType)
        .addProperty("StrSearchName", &GCAI_ChangeHintGroup::GetStrSearchName, &GCAI_ChangeHintGroup::SetStrSearchName)
        .addProperty("StrNewHintGroup", &GCAI_ChangeHintGroup::GetStrNewHintGroup, &GCAI_ChangeHintGroup::SetStrNewHintGroup)
        .addProperty("Radius", &GCAI_ChangeHintGroup::GetRadius, &GCAI_ChangeHintGroup::SetRadius)
        .addProperty("Parent", &GCAI_ChangeHintGroup::GetParent, &GCAI_ChangeHintGroup::SetParent)
        .addFunction("ToPtr", &GCAI_ChangeHintGroup::ToPtr)
        .addFunction("IsValid", &GCAI_ChangeHintGroup::IsValid)
        .endClass();
}
GCColorCorrectionVolume::GCColorCorrectionVolume(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCColorCorrectionVolume::GCColorCorrectionVolume(void *ptr) {
    m_ptr = ptr;
}
bool GCColorCorrectionVolume::GetEnabled() const {
    return GetSchemaValue<bool>(m_ptr, "CColorCorrectionVolume", "m_bEnabled");
}
void GCColorCorrectionVolume::SetEnabled(bool value) {
    SetSchemaValue(m_ptr, "CColorCorrectionVolume", "m_bEnabled", false, value);
}
float GCColorCorrectionVolume::GetMaxWeight() const {
    return GetSchemaValue<float>(m_ptr, "CColorCorrectionVolume", "m_MaxWeight");
}
void GCColorCorrectionVolume::SetMaxWeight(float value) {
    SetSchemaValue(m_ptr, "CColorCorrectionVolume", "m_MaxWeight", false, value);
}
float GCColorCorrectionVolume::GetFadeDuration() const {
    return GetSchemaValue<float>(m_ptr, "CColorCorrectionVolume", "m_FadeDuration");
}
void GCColorCorrectionVolume::SetFadeDuration(float value) {
    SetSchemaValue(m_ptr, "CColorCorrectionVolume", "m_FadeDuration", false, value);
}
bool GCColorCorrectionVolume::GetStartDisabled() const {
    return GetSchemaValue<bool>(m_ptr, "CColorCorrectionVolume", "m_bStartDisabled");
}
void GCColorCorrectionVolume::SetStartDisabled(bool value) {
    SetSchemaValue(m_ptr, "CColorCorrectionVolume", "m_bStartDisabled", false, value);
}
float GCColorCorrectionVolume::GetWeight() const {
    return GetSchemaValue<float>(m_ptr, "CColorCorrectionVolume", "m_Weight");
}
void GCColorCorrectionVolume::SetWeight(float value) {
    SetSchemaValue(m_ptr, "CColorCorrectionVolume", "m_Weight", false, value);
}
std::string GCColorCorrectionVolume::GetLookupFilename() const {
    return GetSchemaValuePtr<char>(m_ptr, "CColorCorrectionVolume", "m_lookupFilename");
}
void GCColorCorrectionVolume::SetLookupFilename(std::string value) {
    WriteSchemaPtrValue(m_ptr, "CColorCorrectionVolume", "m_lookupFilename", false, reinterpret_cast<byte*>(const_cast<char*>(value.c_str())), 512);
}
float GCColorCorrectionVolume::GetLastEnterWeight() const {
    return GetSchemaValue<float>(m_ptr, "CColorCorrectionVolume", "m_LastEnterWeight");
}
void GCColorCorrectionVolume::SetLastEnterWeight(float value) {
    SetSchemaValue(m_ptr, "CColorCorrectionVolume", "m_LastEnterWeight", false, value);
}
float GCColorCorrectionVolume::GetLastEnterTime() const {
    return GetSchemaValue<float>(m_ptr, "CColorCorrectionVolume", "m_LastEnterTime");
}
void GCColorCorrectionVolume::SetLastEnterTime(float value) {
    SetSchemaValue(m_ptr, "CColorCorrectionVolume", "m_LastEnterTime", false, value);
}
float GCColorCorrectionVolume::GetLastExitWeight() const {
    return GetSchemaValue<float>(m_ptr, "CColorCorrectionVolume", "m_LastExitWeight");
}
void GCColorCorrectionVolume::SetLastExitWeight(float value) {
    SetSchemaValue(m_ptr, "CColorCorrectionVolume", "m_LastExitWeight", false, value);
}
float GCColorCorrectionVolume::GetLastExitTime() const {
    return GetSchemaValue<float>(m_ptr, "CColorCorrectionVolume", "m_LastExitTime");
}
void GCColorCorrectionVolume::SetLastExitTime(float value) {
    SetSchemaValue(m_ptr, "CColorCorrectionVolume", "m_LastExitTime", false, value);
}
void* GCColorCorrectionVolume::GetPtr() {
    return m_ptr;
}
std::string GCColorCorrectionVolume::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCColorCorrectionVolume::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseTrigger GCColorCorrectionVolume::GetParent() const {
    GCBaseTrigger value(m_ptr);
    return value;
}
void GCColorCorrectionVolume::SetParent(GCBaseTrigger value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCColorCorrectionVolume(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCColorCorrectionVolume>("CColorCorrectionVolume")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Enabled", &GCColorCorrectionVolume::GetEnabled, &GCColorCorrectionVolume::SetEnabled)
        .addProperty("MaxWeight", &GCColorCorrectionVolume::GetMaxWeight, &GCColorCorrectionVolume::SetMaxWeight)
        .addProperty("FadeDuration", &GCColorCorrectionVolume::GetFadeDuration, &GCColorCorrectionVolume::SetFadeDuration)
        .addProperty("StartDisabled", &GCColorCorrectionVolume::GetStartDisabled, &GCColorCorrectionVolume::SetStartDisabled)
        .addProperty("Weight", &GCColorCorrectionVolume::GetWeight, &GCColorCorrectionVolume::SetWeight)
        .addProperty("LookupFilename", &GCColorCorrectionVolume::GetLookupFilename, &GCColorCorrectionVolume::SetLookupFilename)
        .addProperty("LastEnterWeight", &GCColorCorrectionVolume::GetLastEnterWeight, &GCColorCorrectionVolume::SetLastEnterWeight)
        .addProperty("LastEnterTime", &GCColorCorrectionVolume::GetLastEnterTime, &GCColorCorrectionVolume::SetLastEnterTime)
        .addProperty("LastExitWeight", &GCColorCorrectionVolume::GetLastExitWeight, &GCColorCorrectionVolume::SetLastExitWeight)
        .addProperty("LastExitTime", &GCColorCorrectionVolume::GetLastExitTime, &GCColorCorrectionVolume::SetLastExitTime)
        .addProperty("Parent", &GCColorCorrectionVolume::GetParent, &GCColorCorrectionVolume::SetParent)
        .addFunction("ToPtr", &GCColorCorrectionVolume::ToPtr)
        .addFunction("IsValid", &GCColorCorrectionVolume::IsValid)
        .endClass();
}
GCFilterEnemy::GCFilterEnemy(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCFilterEnemy::GCFilterEnemy(void *ptr) {
    m_ptr = ptr;
}
std::string GCFilterEnemy::GetEnemyName() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CFilterEnemy", "m_iszEnemyName").String();
}
void GCFilterEnemy::SetEnemyName(std::string value) {
    SetSchemaValue(m_ptr, "CFilterEnemy", "m_iszEnemyName", false, CUtlSymbolLarge(value.c_str()));
}
float GCFilterEnemy::GetRadius() const {
    return GetSchemaValue<float>(m_ptr, "CFilterEnemy", "m_flRadius");
}
void GCFilterEnemy::SetRadius(float value) {
    SetSchemaValue(m_ptr, "CFilterEnemy", "m_flRadius", false, value);
}
float GCFilterEnemy::GetOuterRadius() const {
    return GetSchemaValue<float>(m_ptr, "CFilterEnemy", "m_flOuterRadius");
}
void GCFilterEnemy::SetOuterRadius(float value) {
    SetSchemaValue(m_ptr, "CFilterEnemy", "m_flOuterRadius", false, value);
}
int32_t GCFilterEnemy::GetMaxSquadmatesPerEnemy() const {
    return GetSchemaValue<int32_t>(m_ptr, "CFilterEnemy", "m_nMaxSquadmatesPerEnemy");
}
void GCFilterEnemy::SetMaxSquadmatesPerEnemy(int32_t value) {
    SetSchemaValue(m_ptr, "CFilterEnemy", "m_nMaxSquadmatesPerEnemy", false, value);
}
std::string GCFilterEnemy::GetPlayerName() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CFilterEnemy", "m_iszPlayerName").String();
}
void GCFilterEnemy::SetPlayerName(std::string value) {
    SetSchemaValue(m_ptr, "CFilterEnemy", "m_iszPlayerName", false, CUtlSymbolLarge(value.c_str()));
}
void* GCFilterEnemy::GetPtr() {
    return m_ptr;
}
std::string GCFilterEnemy::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCFilterEnemy::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseFilter GCFilterEnemy::GetParent() const {
    GCBaseFilter value(m_ptr);
    return value;
}
void GCFilterEnemy::SetParent(GCBaseFilter value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCFilterEnemy(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCFilterEnemy>("CFilterEnemy")
        .addConstructor<void (*)(std::string)>()
        .addProperty("EnemyName", &GCFilterEnemy::GetEnemyName, &GCFilterEnemy::SetEnemyName)
        .addProperty("Radius", &GCFilterEnemy::GetRadius, &GCFilterEnemy::SetRadius)
        .addProperty("OuterRadius", &GCFilterEnemy::GetOuterRadius, &GCFilterEnemy::SetOuterRadius)
        .addProperty("MaxSquadmatesPerEnemy", &GCFilterEnemy::GetMaxSquadmatesPerEnemy, &GCFilterEnemy::SetMaxSquadmatesPerEnemy)
        .addProperty("PlayerName", &GCFilterEnemy::GetPlayerName, &GCFilterEnemy::SetPlayerName)
        .addProperty("Parent", &GCFilterEnemy::GetParent, &GCFilterEnemy::SetParent)
        .addFunction("ToPtr", &GCFilterEnemy::ToPtr)
        .addFunction("IsValid", &GCFilterEnemy::IsValid)
        .endClass();
}
GCShower::GCShower(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCShower::GCShower(void *ptr) {
    m_ptr = ptr;
}
void* GCShower::GetPtr() {
    return m_ptr;
}
std::string GCShower::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCShower::IsValid() {
    return (m_ptr != nullptr);
}
GCModelPointEntity GCShower::GetParent() const {
    GCModelPointEntity value(m_ptr);
    return value;
}
void GCShower::SetParent(GCModelPointEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCShower(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCShower>("CShower")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCShower::GetParent, &GCShower::SetParent)
        .addFunction("ToPtr", &GCShower::ToPtr)
        .addFunction("IsValid", &GCShower::IsValid)
        .endClass();
}
GCEnvCubemapFog::GCEnvCubemapFog(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCEnvCubemapFog::GCEnvCubemapFog(void *ptr) {
    m_ptr = ptr;
}
float GCEnvCubemapFog::GetEndDistance() const {
    return GetSchemaValue<float>(m_ptr, "CEnvCubemapFog", "m_flEndDistance");
}
void GCEnvCubemapFog::SetEndDistance(float value) {
    SetSchemaValue(m_ptr, "CEnvCubemapFog", "m_flEndDistance", false, value);
}
float GCEnvCubemapFog::GetStartDistance() const {
    return GetSchemaValue<float>(m_ptr, "CEnvCubemapFog", "m_flStartDistance");
}
void GCEnvCubemapFog::SetStartDistance(float value) {
    SetSchemaValue(m_ptr, "CEnvCubemapFog", "m_flStartDistance", false, value);
}
float GCEnvCubemapFog::GetFogFalloffExponent() const {
    return GetSchemaValue<float>(m_ptr, "CEnvCubemapFog", "m_flFogFalloffExponent");
}
void GCEnvCubemapFog::SetFogFalloffExponent(float value) {
    SetSchemaValue(m_ptr, "CEnvCubemapFog", "m_flFogFalloffExponent", false, value);
}
bool GCEnvCubemapFog::GetHeightFogEnabled() const {
    return GetSchemaValue<bool>(m_ptr, "CEnvCubemapFog", "m_bHeightFogEnabled");
}
void GCEnvCubemapFog::SetHeightFogEnabled(bool value) {
    SetSchemaValue(m_ptr, "CEnvCubemapFog", "m_bHeightFogEnabled", false, value);
}
float GCEnvCubemapFog::GetFogHeightWidth() const {
    return GetSchemaValue<float>(m_ptr, "CEnvCubemapFog", "m_flFogHeightWidth");
}
void GCEnvCubemapFog::SetFogHeightWidth(float value) {
    SetSchemaValue(m_ptr, "CEnvCubemapFog", "m_flFogHeightWidth", false, value);
}
float GCEnvCubemapFog::GetFogHeightEnd() const {
    return GetSchemaValue<float>(m_ptr, "CEnvCubemapFog", "m_flFogHeightEnd");
}
void GCEnvCubemapFog::SetFogHeightEnd(float value) {
    SetSchemaValue(m_ptr, "CEnvCubemapFog", "m_flFogHeightEnd", false, value);
}
float GCEnvCubemapFog::GetFogHeightStart() const {
    return GetSchemaValue<float>(m_ptr, "CEnvCubemapFog", "m_flFogHeightStart");
}
void GCEnvCubemapFog::SetFogHeightStart(float value) {
    SetSchemaValue(m_ptr, "CEnvCubemapFog", "m_flFogHeightStart", false, value);
}
float GCEnvCubemapFog::GetFogHeightExponent() const {
    return GetSchemaValue<float>(m_ptr, "CEnvCubemapFog", "m_flFogHeightExponent");
}
void GCEnvCubemapFog::SetFogHeightExponent(float value) {
    SetSchemaValue(m_ptr, "CEnvCubemapFog", "m_flFogHeightExponent", false, value);
}
float GCEnvCubemapFog::GetLODBias() const {
    return GetSchemaValue<float>(m_ptr, "CEnvCubemapFog", "m_flLODBias");
}
void GCEnvCubemapFog::SetLODBias(float value) {
    SetSchemaValue(m_ptr, "CEnvCubemapFog", "m_flLODBias", false, value);
}
bool GCEnvCubemapFog::GetActive() const {
    return GetSchemaValue<bool>(m_ptr, "CEnvCubemapFog", "m_bActive");
}
void GCEnvCubemapFog::SetActive(bool value) {
    SetSchemaValue(m_ptr, "CEnvCubemapFog", "m_bActive", false, value);
}
bool GCEnvCubemapFog::GetStartDisabled() const {
    return GetSchemaValue<bool>(m_ptr, "CEnvCubemapFog", "m_bStartDisabled");
}
void GCEnvCubemapFog::SetStartDisabled(bool value) {
    SetSchemaValue(m_ptr, "CEnvCubemapFog", "m_bStartDisabled", false, value);
}
float GCEnvCubemapFog::GetFogMaxOpacity() const {
    return GetSchemaValue<float>(m_ptr, "CEnvCubemapFog", "m_flFogMaxOpacity");
}
void GCEnvCubemapFog::SetFogMaxOpacity(float value) {
    SetSchemaValue(m_ptr, "CEnvCubemapFog", "m_flFogMaxOpacity", false, value);
}
int32_t GCEnvCubemapFog::GetCubemapSourceType() const {
    return GetSchemaValue<int32_t>(m_ptr, "CEnvCubemapFog", "m_nCubemapSourceType");
}
void GCEnvCubemapFog::SetCubemapSourceType(int32_t value) {
    SetSchemaValue(m_ptr, "CEnvCubemapFog", "m_nCubemapSourceType", false, value);
}
std::string GCEnvCubemapFog::GetSkyEntity() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CEnvCubemapFog", "m_iszSkyEntity").String();
}
void GCEnvCubemapFog::SetSkyEntity(std::string value) {
    SetSchemaValue(m_ptr, "CEnvCubemapFog", "m_iszSkyEntity", false, CUtlSymbolLarge(value.c_str()));
}
bool GCEnvCubemapFog::GetHasHeightFogEnd() const {
    return GetSchemaValue<bool>(m_ptr, "CEnvCubemapFog", "m_bHasHeightFogEnd");
}
void GCEnvCubemapFog::SetHasHeightFogEnd(bool value) {
    SetSchemaValue(m_ptr, "CEnvCubemapFog", "m_bHasHeightFogEnd", false, value);
}
bool GCEnvCubemapFog::GetFirstTime() const {
    return GetSchemaValue<bool>(m_ptr, "CEnvCubemapFog", "m_bFirstTime");
}
void GCEnvCubemapFog::SetFirstTime(bool value) {
    SetSchemaValue(m_ptr, "CEnvCubemapFog", "m_bFirstTime", false, value);
}
void* GCEnvCubemapFog::GetPtr() {
    return m_ptr;
}
std::string GCEnvCubemapFog::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCEnvCubemapFog::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseEntity GCEnvCubemapFog::GetParent() const {
    GCBaseEntity value(m_ptr);
    return value;
}
void GCEnvCubemapFog::SetParent(GCBaseEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCEnvCubemapFog(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCEnvCubemapFog>("CEnvCubemapFog")
        .addConstructor<void (*)(std::string)>()
        .addProperty("EndDistance", &GCEnvCubemapFog::GetEndDistance, &GCEnvCubemapFog::SetEndDistance)
        .addProperty("StartDistance", &GCEnvCubemapFog::GetStartDistance, &GCEnvCubemapFog::SetStartDistance)
        .addProperty("FogFalloffExponent", &GCEnvCubemapFog::GetFogFalloffExponent, &GCEnvCubemapFog::SetFogFalloffExponent)
        .addProperty("HeightFogEnabled", &GCEnvCubemapFog::GetHeightFogEnabled, &GCEnvCubemapFog::SetHeightFogEnabled)
        .addProperty("FogHeightWidth", &GCEnvCubemapFog::GetFogHeightWidth, &GCEnvCubemapFog::SetFogHeightWidth)
        .addProperty("FogHeightEnd", &GCEnvCubemapFog::GetFogHeightEnd, &GCEnvCubemapFog::SetFogHeightEnd)
        .addProperty("FogHeightStart", &GCEnvCubemapFog::GetFogHeightStart, &GCEnvCubemapFog::SetFogHeightStart)
        .addProperty("FogHeightExponent", &GCEnvCubemapFog::GetFogHeightExponent, &GCEnvCubemapFog::SetFogHeightExponent)
        .addProperty("LODBias", &GCEnvCubemapFog::GetLODBias, &GCEnvCubemapFog::SetLODBias)
        .addProperty("Active", &GCEnvCubemapFog::GetActive, &GCEnvCubemapFog::SetActive)
        .addProperty("StartDisabled", &GCEnvCubemapFog::GetStartDisabled, &GCEnvCubemapFog::SetStartDisabled)
        .addProperty("FogMaxOpacity", &GCEnvCubemapFog::GetFogMaxOpacity, &GCEnvCubemapFog::SetFogMaxOpacity)
        .addProperty("CubemapSourceType", &GCEnvCubemapFog::GetCubemapSourceType, &GCEnvCubemapFog::SetCubemapSourceType)
        .addProperty("SkyEntity", &GCEnvCubemapFog::GetSkyEntity, &GCEnvCubemapFog::SetSkyEntity)
        .addProperty("HasHeightFogEnd", &GCEnvCubemapFog::GetHasHeightFogEnd, &GCEnvCubemapFog::SetHasHeightFogEnd)
        .addProperty("FirstTime", &GCEnvCubemapFog::GetFirstTime, &GCEnvCubemapFog::SetFirstTime)
        .addProperty("Parent", &GCEnvCubemapFog::GetParent, &GCEnvCubemapFog::SetParent)
        .addFunction("ToPtr", &GCEnvCubemapFog::ToPtr)
        .addFunction("IsValid", &GCEnvCubemapFog::IsValid)
        .endClass();
}
GCBaseButton::GCBaseButton(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCBaseButton::GCBaseButton(void *ptr) {
    m_ptr = ptr;
}
QAngle GCBaseButton::GetMoveEntitySpace() const {
    return GetSchemaValue<QAngle>(m_ptr, "CBaseButton", "m_angMoveEntitySpace");
}
void GCBaseButton::SetMoveEntitySpace(QAngle value) {
    SetSchemaValue(m_ptr, "CBaseButton", "m_angMoveEntitySpace", false, value);
}
bool GCBaseButton::GetStayPushed() const {
    return GetSchemaValue<bool>(m_ptr, "CBaseButton", "m_fStayPushed");
}
void GCBaseButton::SetStayPushed(bool value) {
    SetSchemaValue(m_ptr, "CBaseButton", "m_fStayPushed", false, value);
}
bool GCBaseButton::GetRotating() const {
    return GetSchemaValue<bool>(m_ptr, "CBaseButton", "m_fRotating");
}
void GCBaseButton::SetRotating(bool value) {
    SetSchemaValue(m_ptr, "CBaseButton", "m_fRotating", false, value);
}
Glocksound_t GCBaseButton::GetLs() const {
    Glocksound_t value(GetSchemaPtr(m_ptr, "CBaseButton", "m_ls"));
    return value;
}
void GCBaseButton::SetLs(Glocksound_t value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Ls' is not possible.\n");
}
std::string GCBaseButton::GetUseSound() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CBaseButton", "m_sUseSound").String();
}
void GCBaseButton::SetUseSound(std::string value) {
    SetSchemaValue(m_ptr, "CBaseButton", "m_sUseSound", false, CUtlSymbolLarge(value.c_str()));
}
std::string GCBaseButton::GetLockedSound() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CBaseButton", "m_sLockedSound").String();
}
void GCBaseButton::SetLockedSound(std::string value) {
    SetSchemaValue(m_ptr, "CBaseButton", "m_sLockedSound", false, CUtlSymbolLarge(value.c_str()));
}
std::string GCBaseButton::GetUnlockedSound() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CBaseButton", "m_sUnlockedSound").String();
}
void GCBaseButton::SetUnlockedSound(std::string value) {
    SetSchemaValue(m_ptr, "CBaseButton", "m_sUnlockedSound", false, CUtlSymbolLarge(value.c_str()));
}
std::string GCBaseButton::GetOverrideAnticipationName() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CBaseButton", "m_sOverrideAnticipationName").String();
}
void GCBaseButton::SetOverrideAnticipationName(std::string value) {
    SetSchemaValue(m_ptr, "CBaseButton", "m_sOverrideAnticipationName", false, CUtlSymbolLarge(value.c_str()));
}
bool GCBaseButton::GetLocked() const {
    return GetSchemaValue<bool>(m_ptr, "CBaseButton", "m_bLocked");
}
void GCBaseButton::SetLocked(bool value) {
    SetSchemaValue(m_ptr, "CBaseButton", "m_bLocked", false, value);
}
bool GCBaseButton::GetDisabled() const {
    return GetSchemaValue<bool>(m_ptr, "CBaseButton", "m_bDisabled");
}
void GCBaseButton::SetDisabled(bool value) {
    SetSchemaValue(m_ptr, "CBaseButton", "m_bDisabled", false, value);
}
float GCBaseButton::GetUseLockedTime() const {
    return GetSchemaValue<float>(m_ptr, "CBaseButton", "m_flUseLockedTime");
}
void GCBaseButton::SetUseLockedTime(float value) {
    SetSchemaValue(m_ptr, "CBaseButton", "m_flUseLockedTime", false, value);
}
bool GCBaseButton::GetSolidBsp() const {
    return GetSchemaValue<bool>(m_ptr, "CBaseButton", "m_bSolidBsp");
}
void GCBaseButton::SetSolidBsp(bool value) {
    SetSchemaValue(m_ptr, "CBaseButton", "m_bSolidBsp", false, value);
}
GCEntityIOOutput GCBaseButton::GetOnDamaged() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CBaseButton", "m_OnDamaged"));
    return value;
}
void GCBaseButton::SetOnDamaged(GCEntityIOOutput value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'OnDamaged' is not possible.\n");
}
GCEntityIOOutput GCBaseButton::GetOnPressed() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CBaseButton", "m_OnPressed"));
    return value;
}
void GCBaseButton::SetOnPressed(GCEntityIOOutput value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'OnPressed' is not possible.\n");
}
GCEntityIOOutput GCBaseButton::GetOnUseLocked() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CBaseButton", "m_OnUseLocked"));
    return value;
}
void GCBaseButton::SetOnUseLocked(GCEntityIOOutput value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'OnUseLocked' is not possible.\n");
}
GCEntityIOOutput GCBaseButton::GetOnIn() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CBaseButton", "m_OnIn"));
    return value;
}
void GCBaseButton::SetOnIn(GCEntityIOOutput value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'OnIn' is not possible.\n");
}
GCEntityIOOutput GCBaseButton::GetOnOut() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CBaseButton", "m_OnOut"));
    return value;
}
void GCBaseButton::SetOnOut(GCEntityIOOutput value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'OnOut' is not possible.\n");
}
int32_t GCBaseButton::GetState() const {
    return GetSchemaValue<int32_t>(m_ptr, "CBaseButton", "m_nState");
}
void GCBaseButton::SetState(int32_t value) {
    SetSchemaValue(m_ptr, "CBaseButton", "m_nState", false, value);
}
GCEntityInstance GCBaseButton::GetConstraint() const {
    GCEntityInstance value((void*)(GetSchemaValue<CHandle<CEntityInstance>>(m_ptr, "CBaseButton", "m_hConstraint").Get()));
    return value;
}
void GCBaseButton::SetConstraint(GCEntityInstance value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Constraint' is not possible.\n");
}
GCEntityInstance GCBaseButton::GetConstraintParent() const {
    GCEntityInstance value((void*)(GetSchemaValue<CHandle<CEntityInstance>>(m_ptr, "CBaseButton", "m_hConstraintParent").Get()));
    return value;
}
void GCBaseButton::SetConstraintParent(GCEntityInstance value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'ConstraintParent' is not possible.\n");
}
bool GCBaseButton::GetForceNpcExclude() const {
    return GetSchemaValue<bool>(m_ptr, "CBaseButton", "m_bForceNpcExclude");
}
void GCBaseButton::SetForceNpcExclude(bool value) {
    SetSchemaValue(m_ptr, "CBaseButton", "m_bForceNpcExclude", false, value);
}
std::string GCBaseButton::GetGlowEntity() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CBaseButton", "m_sGlowEntity").String();
}
void GCBaseButton::SetGlowEntity(std::string value) {
    SetSchemaValue(m_ptr, "CBaseButton", "m_sGlowEntity", false, CUtlSymbolLarge(value.c_str()));
}
GCBaseModelEntity GCBaseButton::GetGlowEntity1() const {
    GCBaseModelEntity value((void*)(GetSchemaValue<CHandle<CEntityInstance>>(m_ptr, "CBaseButton", "m_glowEntity").Get()));
    return value;
}
void GCBaseButton::SetGlowEntity1(GCBaseModelEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'GlowEntity1' is not possible.\n");
}
bool GCBaseButton::GetUsable() const {
    return GetSchemaValue<bool>(m_ptr, "CBaseButton", "m_usable");
}
void GCBaseButton::SetUsable(bool value) {
    SetSchemaValue(m_ptr, "CBaseButton", "m_usable", false, value);
}
std::string GCBaseButton::GetDisplayText() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CBaseButton", "m_szDisplayText").String();
}
void GCBaseButton::SetDisplayText(std::string value) {
    SetSchemaValue(m_ptr, "CBaseButton", "m_szDisplayText", false, CUtlSymbolLarge(value.c_str()));
}
void* GCBaseButton::GetPtr() {
    return m_ptr;
}
std::string GCBaseButton::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCBaseButton::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseToggle GCBaseButton::GetParent() const {
    GCBaseToggle value(m_ptr);
    return value;
}
void GCBaseButton::SetParent(GCBaseToggle value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCBaseButton(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCBaseButton>("CBaseButton")
        .addConstructor<void (*)(std::string)>()
        .addProperty("MoveEntitySpace", &GCBaseButton::GetMoveEntitySpace, &GCBaseButton::SetMoveEntitySpace)
        .addProperty("StayPushed", &GCBaseButton::GetStayPushed, &GCBaseButton::SetStayPushed)
        .addProperty("Rotating", &GCBaseButton::GetRotating, &GCBaseButton::SetRotating)
        .addProperty("Ls", &GCBaseButton::GetLs, &GCBaseButton::SetLs)
        .addProperty("UseSound", &GCBaseButton::GetUseSound, &GCBaseButton::SetUseSound)
        .addProperty("LockedSound", &GCBaseButton::GetLockedSound, &GCBaseButton::SetLockedSound)
        .addProperty("UnlockedSound", &GCBaseButton::GetUnlockedSound, &GCBaseButton::SetUnlockedSound)
        .addProperty("OverrideAnticipationName", &GCBaseButton::GetOverrideAnticipationName, &GCBaseButton::SetOverrideAnticipationName)
        .addProperty("Locked", &GCBaseButton::GetLocked, &GCBaseButton::SetLocked)
        .addProperty("Disabled", &GCBaseButton::GetDisabled, &GCBaseButton::SetDisabled)
        .addProperty("UseLockedTime", &GCBaseButton::GetUseLockedTime, &GCBaseButton::SetUseLockedTime)
        .addProperty("SolidBsp", &GCBaseButton::GetSolidBsp, &GCBaseButton::SetSolidBsp)
        .addProperty("OnDamaged", &GCBaseButton::GetOnDamaged, &GCBaseButton::SetOnDamaged)
        .addProperty("OnPressed", &GCBaseButton::GetOnPressed, &GCBaseButton::SetOnPressed)
        .addProperty("OnUseLocked", &GCBaseButton::GetOnUseLocked, &GCBaseButton::SetOnUseLocked)
        .addProperty("OnIn", &GCBaseButton::GetOnIn, &GCBaseButton::SetOnIn)
        .addProperty("OnOut", &GCBaseButton::GetOnOut, &GCBaseButton::SetOnOut)
        .addProperty("State", &GCBaseButton::GetState, &GCBaseButton::SetState)
        .addProperty("Constraint", &GCBaseButton::GetConstraint, &GCBaseButton::SetConstraint)
        .addProperty("ConstraintParent", &GCBaseButton::GetConstraintParent, &GCBaseButton::SetConstraintParent)
        .addProperty("ForceNpcExclude", &GCBaseButton::GetForceNpcExclude, &GCBaseButton::SetForceNpcExclude)
        .addProperty("GlowEntity", &GCBaseButton::GetGlowEntity, &GCBaseButton::SetGlowEntity)
        .addProperty("GlowEntity1", &GCBaseButton::GetGlowEntity1, &GCBaseButton::SetGlowEntity1)
        .addProperty("Usable", &GCBaseButton::GetUsable, &GCBaseButton::SetUsable)
        .addProperty("DisplayText", &GCBaseButton::GetDisplayText, &GCBaseButton::SetDisplayText)
        .addProperty("Parent", &GCBaseButton::GetParent, &GCBaseButton::SetParent)
        .addFunction("ToPtr", &GCBaseButton::ToPtr)
        .addFunction("IsValid", &GCBaseButton::IsValid)
        .endClass();
}
GCEnvExplosion::GCEnvExplosion(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCEnvExplosion::GCEnvExplosion(void *ptr) {
    m_ptr = ptr;
}
int32_t GCEnvExplosion::GetMagnitude() const {
    return GetSchemaValue<int32_t>(m_ptr, "CEnvExplosion", "m_iMagnitude");
}
void GCEnvExplosion::SetMagnitude(int32_t value) {
    SetSchemaValue(m_ptr, "CEnvExplosion", "m_iMagnitude", false, value);
}
float GCEnvExplosion::GetPlayerDamage() const {
    return GetSchemaValue<float>(m_ptr, "CEnvExplosion", "m_flPlayerDamage");
}
void GCEnvExplosion::SetPlayerDamage(float value) {
    SetSchemaValue(m_ptr, "CEnvExplosion", "m_flPlayerDamage", false, value);
}
int32_t GCEnvExplosion::GetRadiusOverride() const {
    return GetSchemaValue<int32_t>(m_ptr, "CEnvExplosion", "m_iRadiusOverride");
}
void GCEnvExplosion::SetRadiusOverride(int32_t value) {
    SetSchemaValue(m_ptr, "CEnvExplosion", "m_iRadiusOverride", false, value);
}
float GCEnvExplosion::GetInnerRadius() const {
    return GetSchemaValue<float>(m_ptr, "CEnvExplosion", "m_flInnerRadius");
}
void GCEnvExplosion::SetInnerRadius(float value) {
    SetSchemaValue(m_ptr, "CEnvExplosion", "m_flInnerRadius", false, value);
}
int32_t GCEnvExplosion::GetSpriteScale() const {
    return GetSchemaValue<int32_t>(m_ptr, "CEnvExplosion", "m_spriteScale");
}
void GCEnvExplosion::SetSpriteScale(int32_t value) {
    SetSchemaValue(m_ptr, "CEnvExplosion", "m_spriteScale", false, value);
}
float GCEnvExplosion::GetDamageForce() const {
    return GetSchemaValue<float>(m_ptr, "CEnvExplosion", "m_flDamageForce");
}
void GCEnvExplosion::SetDamageForce(float value) {
    SetSchemaValue(m_ptr, "CEnvExplosion", "m_flDamageForce", false, value);
}
GCBaseEntity GCEnvExplosion::GetInflictor() const {
    GCBaseEntity value((void*)(GetSchemaValue<CHandle<CEntityInstance>>(m_ptr, "CEnvExplosion", "m_hInflictor").Get()));
    return value;
}
void GCEnvExplosion::SetInflictor(GCBaseEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Inflictor' is not possible.\n");
}
int32_t GCEnvExplosion::GetCustomDamageType() const {
    return GetSchemaValue<int32_t>(m_ptr, "CEnvExplosion", "m_iCustomDamageType");
}
void GCEnvExplosion::SetCustomDamageType(int32_t value) {
    SetSchemaValue(m_ptr, "CEnvExplosion", "m_iCustomDamageType", false, value);
}
std::string GCEnvExplosion::GetExplosionType() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CEnvExplosion", "m_iszExplosionType").String();
}
void GCEnvExplosion::SetExplosionType(std::string value) {
    SetSchemaValue(m_ptr, "CEnvExplosion", "m_iszExplosionType", false, CUtlSymbolLarge(value.c_str()));
}
std::string GCEnvExplosion::GetCustomEffectName() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CEnvExplosion", "m_iszCustomEffectName").String();
}
void GCEnvExplosion::SetCustomEffectName(std::string value) {
    SetSchemaValue(m_ptr, "CEnvExplosion", "m_iszCustomEffectName", false, CUtlSymbolLarge(value.c_str()));
}
std::string GCEnvExplosion::GetCustomSoundName() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CEnvExplosion", "m_iszCustomSoundName").String();
}
void GCEnvExplosion::SetCustomSoundName(std::string value) {
    SetSchemaValue(m_ptr, "CEnvExplosion", "m_iszCustomSoundName", false, CUtlSymbolLarge(value.c_str()));
}
uint64_t GCEnvExplosion::GetClassIgnore() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CEnvExplosion", "m_iClassIgnore");
}
void GCEnvExplosion::SetClassIgnore(uint64_t value) {
    SetSchemaValue(m_ptr, "CEnvExplosion", "m_iClassIgnore", false, value);
}
uint64_t GCEnvExplosion::GetClassIgnore2() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CEnvExplosion", "m_iClassIgnore2");
}
void GCEnvExplosion::SetClassIgnore2(uint64_t value) {
    SetSchemaValue(m_ptr, "CEnvExplosion", "m_iClassIgnore2", false, value);
}
std::string GCEnvExplosion::GetEntityIgnoreName() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CEnvExplosion", "m_iszEntityIgnoreName").String();
}
void GCEnvExplosion::SetEntityIgnoreName(std::string value) {
    SetSchemaValue(m_ptr, "CEnvExplosion", "m_iszEntityIgnoreName", false, CUtlSymbolLarge(value.c_str()));
}
GCBaseEntity GCEnvExplosion::GetEntityIgnore() const {
    GCBaseEntity value((void*)(GetSchemaValue<CHandle<CEntityInstance>>(m_ptr, "CEnvExplosion", "m_hEntityIgnore").Get()));
    return value;
}
void GCEnvExplosion::SetEntityIgnore(GCBaseEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'EntityIgnore' is not possible.\n");
}
void* GCEnvExplosion::GetPtr() {
    return m_ptr;
}
std::string GCEnvExplosion::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCEnvExplosion::IsValid() {
    return (m_ptr != nullptr);
}
GCModelPointEntity GCEnvExplosion::GetParent() const {
    GCModelPointEntity value(m_ptr);
    return value;
}
void GCEnvExplosion::SetParent(GCModelPointEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCEnvExplosion(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCEnvExplosion>("CEnvExplosion")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Magnitude", &GCEnvExplosion::GetMagnitude, &GCEnvExplosion::SetMagnitude)
        .addProperty("PlayerDamage", &GCEnvExplosion::GetPlayerDamage, &GCEnvExplosion::SetPlayerDamage)
        .addProperty("RadiusOverride", &GCEnvExplosion::GetRadiusOverride, &GCEnvExplosion::SetRadiusOverride)
        .addProperty("InnerRadius", &GCEnvExplosion::GetInnerRadius, &GCEnvExplosion::SetInnerRadius)
        .addProperty("SpriteScale", &GCEnvExplosion::GetSpriteScale, &GCEnvExplosion::SetSpriteScale)
        .addProperty("DamageForce", &GCEnvExplosion::GetDamageForce, &GCEnvExplosion::SetDamageForce)
        .addProperty("Inflictor", &GCEnvExplosion::GetInflictor, &GCEnvExplosion::SetInflictor)
        .addProperty("CustomDamageType", &GCEnvExplosion::GetCustomDamageType, &GCEnvExplosion::SetCustomDamageType)
        .addProperty("ExplosionType", &GCEnvExplosion::GetExplosionType, &GCEnvExplosion::SetExplosionType)
        .addProperty("CustomEffectName", &GCEnvExplosion::GetCustomEffectName, &GCEnvExplosion::SetCustomEffectName)
        .addProperty("CustomSoundName", &GCEnvExplosion::GetCustomSoundName, &GCEnvExplosion::SetCustomSoundName)
        .addProperty("ClassIgnore", &GCEnvExplosion::GetClassIgnore, &GCEnvExplosion::SetClassIgnore)
        .addProperty("ClassIgnore2", &GCEnvExplosion::GetClassIgnore2, &GCEnvExplosion::SetClassIgnore2)
        .addProperty("EntityIgnoreName", &GCEnvExplosion::GetEntityIgnoreName, &GCEnvExplosion::SetEntityIgnoreName)
        .addProperty("EntityIgnore", &GCEnvExplosion::GetEntityIgnore, &GCEnvExplosion::SetEntityIgnore)
        .addProperty("Parent", &GCEnvExplosion::GetParent, &GCEnvExplosion::SetParent)
        .addFunction("ToPtr", &GCEnvExplosion::ToPtr)
        .addFunction("IsValid", &GCEnvExplosion::IsValid)
        .endClass();
}
GCSoundEventAABBEntity::GCSoundEventAABBEntity(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCSoundEventAABBEntity::GCSoundEventAABBEntity(void *ptr) {
    m_ptr = ptr;
}
Vector GCSoundEventAABBEntity::GetMins() const {
    return GetSchemaValue<Vector>(m_ptr, "CSoundEventAABBEntity", "m_vMins");
}
void GCSoundEventAABBEntity::SetMins(Vector value) {
    SetSchemaValue(m_ptr, "CSoundEventAABBEntity", "m_vMins", false, value);
}
Vector GCSoundEventAABBEntity::GetMaxs() const {
    return GetSchemaValue<Vector>(m_ptr, "CSoundEventAABBEntity", "m_vMaxs");
}
void GCSoundEventAABBEntity::SetMaxs(Vector value) {
    SetSchemaValue(m_ptr, "CSoundEventAABBEntity", "m_vMaxs", false, value);
}
void* GCSoundEventAABBEntity::GetPtr() {
    return m_ptr;
}
std::string GCSoundEventAABBEntity::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCSoundEventAABBEntity::IsValid() {
    return (m_ptr != nullptr);
}
GCSoundEventEntity GCSoundEventAABBEntity::GetParent() const {
    GCSoundEventEntity value(m_ptr);
    return value;
}
void GCSoundEventAABBEntity::SetParent(GCSoundEventEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCSoundEventAABBEntity(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCSoundEventAABBEntity>("CSoundEventAABBEntity")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Mins", &GCSoundEventAABBEntity::GetMins, &GCSoundEventAABBEntity::SetMins)
        .addProperty("Maxs", &GCSoundEventAABBEntity::GetMaxs, &GCSoundEventAABBEntity::SetMaxs)
        .addProperty("Parent", &GCSoundEventAABBEntity::GetParent, &GCSoundEventAABBEntity::SetParent)
        .addFunction("ToPtr", &GCSoundEventAABBEntity::ToPtr)
        .addFunction("IsValid", &GCSoundEventAABBEntity::IsValid)
        .endClass();
}
GCTriggerLook::GCTriggerLook(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCTriggerLook::GCTriggerLook(void *ptr) {
    m_ptr = ptr;
}
GCBaseEntity GCTriggerLook::GetLookTarget() const {
    GCBaseEntity value((void*)(GetSchemaValue<CHandle<CEntityInstance>>(m_ptr, "CTriggerLook", "m_hLookTarget").Get()));
    return value;
}
void GCTriggerLook::SetLookTarget(GCBaseEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'LookTarget' is not possible.\n");
}
float GCTriggerLook::GetFieldOfView() const {
    return GetSchemaValue<float>(m_ptr, "CTriggerLook", "m_flFieldOfView");
}
void GCTriggerLook::SetFieldOfView(float value) {
    SetSchemaValue(m_ptr, "CTriggerLook", "m_flFieldOfView", false, value);
}
float GCTriggerLook::GetLookTime() const {
    return GetSchemaValue<float>(m_ptr, "CTriggerLook", "m_flLookTime");
}
void GCTriggerLook::SetLookTime(float value) {
    SetSchemaValue(m_ptr, "CTriggerLook", "m_flLookTime", false, value);
}
float GCTriggerLook::GetLookTimeTotal() const {
    return GetSchemaValue<float>(m_ptr, "CTriggerLook", "m_flLookTimeTotal");
}
void GCTriggerLook::SetLookTimeTotal(float value) {
    SetSchemaValue(m_ptr, "CTriggerLook", "m_flLookTimeTotal", false, value);
}
float GCTriggerLook::GetLookTimeLast() const {
    return GetSchemaValue<float>(m_ptr, "CTriggerLook", "m_flLookTimeLast");
}
void GCTriggerLook::SetLookTimeLast(float value) {
    SetSchemaValue(m_ptr, "CTriggerLook", "m_flLookTimeLast", false, value);
}
float GCTriggerLook::GetTimeoutDuration() const {
    return GetSchemaValue<float>(m_ptr, "CTriggerLook", "m_flTimeoutDuration");
}
void GCTriggerLook::SetTimeoutDuration(float value) {
    SetSchemaValue(m_ptr, "CTriggerLook", "m_flTimeoutDuration", false, value);
}
bool GCTriggerLook::GetTimeoutFired() const {
    return GetSchemaValue<bool>(m_ptr, "CTriggerLook", "m_bTimeoutFired");
}
void GCTriggerLook::SetTimeoutFired(bool value) {
    SetSchemaValue(m_ptr, "CTriggerLook", "m_bTimeoutFired", false, value);
}
bool GCTriggerLook::GetIsLooking() const {
    return GetSchemaValue<bool>(m_ptr, "CTriggerLook", "m_bIsLooking");
}
void GCTriggerLook::SetIsLooking(bool value) {
    SetSchemaValue(m_ptr, "CTriggerLook", "m_bIsLooking", false, value);
}
bool GCTriggerLook::Get2DFOV() const {
    return GetSchemaValue<bool>(m_ptr, "CTriggerLook", "m_b2DFOV");
}
void GCTriggerLook::Set2DFOV(bool value) {
    SetSchemaValue(m_ptr, "CTriggerLook", "m_b2DFOV", false, value);
}
bool GCTriggerLook::GetUseVelocity() const {
    return GetSchemaValue<bool>(m_ptr, "CTriggerLook", "m_bUseVelocity");
}
void GCTriggerLook::SetUseVelocity(bool value) {
    SetSchemaValue(m_ptr, "CTriggerLook", "m_bUseVelocity", false, value);
}
bool GCTriggerLook::GetTestOcclusion() const {
    return GetSchemaValue<bool>(m_ptr, "CTriggerLook", "m_bTestOcclusion");
}
void GCTriggerLook::SetTestOcclusion(bool value) {
    SetSchemaValue(m_ptr, "CTriggerLook", "m_bTestOcclusion", false, value);
}
GCEntityIOOutput GCTriggerLook::GetOnTimeout() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CTriggerLook", "m_OnTimeout"));
    return value;
}
void GCTriggerLook::SetOnTimeout(GCEntityIOOutput value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'OnTimeout' is not possible.\n");
}
GCEntityIOOutput GCTriggerLook::GetOnStartLook() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CTriggerLook", "m_OnStartLook"));
    return value;
}
void GCTriggerLook::SetOnStartLook(GCEntityIOOutput value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'OnStartLook' is not possible.\n");
}
GCEntityIOOutput GCTriggerLook::GetOnEndLook() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CTriggerLook", "m_OnEndLook"));
    return value;
}
void GCTriggerLook::SetOnEndLook(GCEntityIOOutput value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'OnEndLook' is not possible.\n");
}
void* GCTriggerLook::GetPtr() {
    return m_ptr;
}
std::string GCTriggerLook::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCTriggerLook::IsValid() {
    return (m_ptr != nullptr);
}
GCTriggerOnce GCTriggerLook::GetParent() const {
    GCTriggerOnce value(m_ptr);
    return value;
}
void GCTriggerLook::SetParent(GCTriggerOnce value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCTriggerLook(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCTriggerLook>("CTriggerLook")
        .addConstructor<void (*)(std::string)>()
        .addProperty("LookTarget", &GCTriggerLook::GetLookTarget, &GCTriggerLook::SetLookTarget)
        .addProperty("FieldOfView", &GCTriggerLook::GetFieldOfView, &GCTriggerLook::SetFieldOfView)
        .addProperty("LookTime", &GCTriggerLook::GetLookTime, &GCTriggerLook::SetLookTime)
        .addProperty("LookTimeTotal", &GCTriggerLook::GetLookTimeTotal, &GCTriggerLook::SetLookTimeTotal)
        .addProperty("LookTimeLast", &GCTriggerLook::GetLookTimeLast, &GCTriggerLook::SetLookTimeLast)
        .addProperty("TimeoutDuration", &GCTriggerLook::GetTimeoutDuration, &GCTriggerLook::SetTimeoutDuration)
        .addProperty("TimeoutFired", &GCTriggerLook::GetTimeoutFired, &GCTriggerLook::SetTimeoutFired)
        .addProperty("IsLooking", &GCTriggerLook::GetIsLooking, &GCTriggerLook::SetIsLooking)
        .addProperty("2DFOV", &GCTriggerLook::Get2DFOV, &GCTriggerLook::Set2DFOV)
        .addProperty("UseVelocity", &GCTriggerLook::GetUseVelocity, &GCTriggerLook::SetUseVelocity)
        .addProperty("TestOcclusion", &GCTriggerLook::GetTestOcclusion, &GCTriggerLook::SetTestOcclusion)
        .addProperty("OnTimeout", &GCTriggerLook::GetOnTimeout, &GCTriggerLook::SetOnTimeout)
        .addProperty("OnStartLook", &GCTriggerLook::GetOnStartLook, &GCTriggerLook::SetOnStartLook)
        .addProperty("OnEndLook", &GCTriggerLook::GetOnEndLook, &GCTriggerLook::SetOnEndLook)
        .addProperty("Parent", &GCTriggerLook::GetParent, &GCTriggerLook::SetParent)
        .addFunction("ToPtr", &GCTriggerLook::ToPtr)
        .addFunction("IsValid", &GCTriggerLook::IsValid)
        .endClass();
}
GCEntitySubclassVDataBase::GCEntitySubclassVDataBase(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCEntitySubclassVDataBase::GCEntitySubclassVDataBase(void *ptr) {
    m_ptr = ptr;
}
void* GCEntitySubclassVDataBase::GetPtr() {
    return m_ptr;
}
std::string GCEntitySubclassVDataBase::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCEntitySubclassVDataBase::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCEntitySubclassVDataBase(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCEntitySubclassVDataBase>("CEntitySubclassVDataBase")
        .addConstructor<void (*)(std::string)>()
        .addFunction("ToPtr", &GCEntitySubclassVDataBase::ToPtr)
        .addFunction("IsValid", &GCEntitySubclassVDataBase::IsValid)
        .endClass();
}
GCLogicProximity::GCLogicProximity(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCLogicProximity::GCLogicProximity(void *ptr) {
    m_ptr = ptr;
}
void* GCLogicProximity::GetPtr() {
    return m_ptr;
}
std::string GCLogicProximity::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCLogicProximity::IsValid() {
    return (m_ptr != nullptr);
}
GCPointEntity GCLogicProximity::GetParent() const {
    GCPointEntity value(m_ptr);
    return value;
}
void GCLogicProximity::SetParent(GCPointEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCLogicProximity(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCLogicProximity>("CLogicProximity")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCLogicProximity::GetParent, &GCLogicProximity::SetParent)
        .addFunction("ToPtr", &GCLogicProximity::ToPtr)
        .addFunction("IsValid", &GCLogicProximity::IsValid)
        .endClass();
}
GCPointClientUIWorldPanel::GCPointClientUIWorldPanel(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCPointClientUIWorldPanel::GCPointClientUIWorldPanel(void *ptr) {
    m_ptr = ptr;
}
bool GCPointClientUIWorldPanel::GetIgnoreInput() const {
    return GetSchemaValue<bool>(m_ptr, "CPointClientUIWorldPanel", "m_bIgnoreInput");
}
void GCPointClientUIWorldPanel::SetIgnoreInput(bool value) {
    SetSchemaValue(m_ptr, "CPointClientUIWorldPanel", "m_bIgnoreInput", false, value);
}
bool GCPointClientUIWorldPanel::GetLit() const {
    return GetSchemaValue<bool>(m_ptr, "CPointClientUIWorldPanel", "m_bLit");
}
void GCPointClientUIWorldPanel::SetLit(bool value) {
    SetSchemaValue(m_ptr, "CPointClientUIWorldPanel", "m_bLit", false, value);
}
bool GCPointClientUIWorldPanel::GetFollowPlayerAcrossTeleport() const {
    return GetSchemaValue<bool>(m_ptr, "CPointClientUIWorldPanel", "m_bFollowPlayerAcrossTeleport");
}
void GCPointClientUIWorldPanel::SetFollowPlayerAcrossTeleport(bool value) {
    SetSchemaValue(m_ptr, "CPointClientUIWorldPanel", "m_bFollowPlayerAcrossTeleport", false, value);
}
float GCPointClientUIWorldPanel::GetWidth() const {
    return GetSchemaValue<float>(m_ptr, "CPointClientUIWorldPanel", "m_flWidth");
}
void GCPointClientUIWorldPanel::SetWidth(float value) {
    SetSchemaValue(m_ptr, "CPointClientUIWorldPanel", "m_flWidth", false, value);
}
float GCPointClientUIWorldPanel::GetHeight() const {
    return GetSchemaValue<float>(m_ptr, "CPointClientUIWorldPanel", "m_flHeight");
}
void GCPointClientUIWorldPanel::SetHeight(float value) {
    SetSchemaValue(m_ptr, "CPointClientUIWorldPanel", "m_flHeight", false, value);
}
float GCPointClientUIWorldPanel::GetDPI() const {
    return GetSchemaValue<float>(m_ptr, "CPointClientUIWorldPanel", "m_flDPI");
}
void GCPointClientUIWorldPanel::SetDPI(float value) {
    SetSchemaValue(m_ptr, "CPointClientUIWorldPanel", "m_flDPI", false, value);
}
float GCPointClientUIWorldPanel::GetInteractDistance() const {
    return GetSchemaValue<float>(m_ptr, "CPointClientUIWorldPanel", "m_flInteractDistance");
}
void GCPointClientUIWorldPanel::SetInteractDistance(float value) {
    SetSchemaValue(m_ptr, "CPointClientUIWorldPanel", "m_flInteractDistance", false, value);
}
float GCPointClientUIWorldPanel::GetDepthOffset() const {
    return GetSchemaValue<float>(m_ptr, "CPointClientUIWorldPanel", "m_flDepthOffset");
}
void GCPointClientUIWorldPanel::SetDepthOffset(float value) {
    SetSchemaValue(m_ptr, "CPointClientUIWorldPanel", "m_flDepthOffset", false, value);
}
uint32_t GCPointClientUIWorldPanel::GetOwnerContext() const {
    return GetSchemaValue<uint32_t>(m_ptr, "CPointClientUIWorldPanel", "m_unOwnerContext");
}
void GCPointClientUIWorldPanel::SetOwnerContext(uint32_t value) {
    SetSchemaValue(m_ptr, "CPointClientUIWorldPanel", "m_unOwnerContext", false, value);
}
uint32_t GCPointClientUIWorldPanel::GetHorizontalAlign() const {
    return GetSchemaValue<uint32_t>(m_ptr, "CPointClientUIWorldPanel", "m_unHorizontalAlign");
}
void GCPointClientUIWorldPanel::SetHorizontalAlign(uint32_t value) {
    SetSchemaValue(m_ptr, "CPointClientUIWorldPanel", "m_unHorizontalAlign", false, value);
}
uint32_t GCPointClientUIWorldPanel::GetVerticalAlign() const {
    return GetSchemaValue<uint32_t>(m_ptr, "CPointClientUIWorldPanel", "m_unVerticalAlign");
}
void GCPointClientUIWorldPanel::SetVerticalAlign(uint32_t value) {
    SetSchemaValue(m_ptr, "CPointClientUIWorldPanel", "m_unVerticalAlign", false, value);
}
uint32_t GCPointClientUIWorldPanel::GetOrientation() const {
    return GetSchemaValue<uint32_t>(m_ptr, "CPointClientUIWorldPanel", "m_unOrientation");
}
void GCPointClientUIWorldPanel::SetOrientation(uint32_t value) {
    SetSchemaValue(m_ptr, "CPointClientUIWorldPanel", "m_unOrientation", false, value);
}
bool GCPointClientUIWorldPanel::GetAllowInteractionFromAllSceneWorlds() const {
    return GetSchemaValue<bool>(m_ptr, "CPointClientUIWorldPanel", "m_bAllowInteractionFromAllSceneWorlds");
}
void GCPointClientUIWorldPanel::SetAllowInteractionFromAllSceneWorlds(bool value) {
    SetSchemaValue(m_ptr, "CPointClientUIWorldPanel", "m_bAllowInteractionFromAllSceneWorlds", false, value);
}
std::vector<CUtlSymbolLarge> GCPointClientUIWorldPanel::GetCSSClasses() const {
    CUtlVector<CUtlSymbolLarge>* vec = GetSchemaValue<CUtlVector<CUtlSymbolLarge>*>(m_ptr, "CPointClientUIWorldPanel", "m_vecCSSClasses"); std::vector<CUtlSymbolLarge> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCPointClientUIWorldPanel::SetCSSClasses(std::vector<CUtlSymbolLarge> value) {
    SetSchemaValueCUtlVector<CUtlSymbolLarge>(m_ptr, "CPointClientUIWorldPanel", "m_vecCSSClasses", false, value);
}
bool GCPointClientUIWorldPanel::GetOpaque() const {
    return GetSchemaValue<bool>(m_ptr, "CPointClientUIWorldPanel", "m_bOpaque");
}
void GCPointClientUIWorldPanel::SetOpaque(bool value) {
    SetSchemaValue(m_ptr, "CPointClientUIWorldPanel", "m_bOpaque", false, value);
}
bool GCPointClientUIWorldPanel::GetNoDepth() const {
    return GetSchemaValue<bool>(m_ptr, "CPointClientUIWorldPanel", "m_bNoDepth");
}
void GCPointClientUIWorldPanel::SetNoDepth(bool value) {
    SetSchemaValue(m_ptr, "CPointClientUIWorldPanel", "m_bNoDepth", false, value);
}
bool GCPointClientUIWorldPanel::GetRenderBackface() const {
    return GetSchemaValue<bool>(m_ptr, "CPointClientUIWorldPanel", "m_bRenderBackface");
}
void GCPointClientUIWorldPanel::SetRenderBackface(bool value) {
    SetSchemaValue(m_ptr, "CPointClientUIWorldPanel", "m_bRenderBackface", false, value);
}
bool GCPointClientUIWorldPanel::GetUseOffScreenIndicator() const {
    return GetSchemaValue<bool>(m_ptr, "CPointClientUIWorldPanel", "m_bUseOffScreenIndicator");
}
void GCPointClientUIWorldPanel::SetUseOffScreenIndicator(bool value) {
    SetSchemaValue(m_ptr, "CPointClientUIWorldPanel", "m_bUseOffScreenIndicator", false, value);
}
bool GCPointClientUIWorldPanel::GetExcludeFromSaveGames() const {
    return GetSchemaValue<bool>(m_ptr, "CPointClientUIWorldPanel", "m_bExcludeFromSaveGames");
}
void GCPointClientUIWorldPanel::SetExcludeFromSaveGames(bool value) {
    SetSchemaValue(m_ptr, "CPointClientUIWorldPanel", "m_bExcludeFromSaveGames", false, value);
}
bool GCPointClientUIWorldPanel::GetGrabbable() const {
    return GetSchemaValue<bool>(m_ptr, "CPointClientUIWorldPanel", "m_bGrabbable");
}
void GCPointClientUIWorldPanel::SetGrabbable(bool value) {
    SetSchemaValue(m_ptr, "CPointClientUIWorldPanel", "m_bGrabbable", false, value);
}
bool GCPointClientUIWorldPanel::GetOnlyRenderToTexture() const {
    return GetSchemaValue<bool>(m_ptr, "CPointClientUIWorldPanel", "m_bOnlyRenderToTexture");
}
void GCPointClientUIWorldPanel::SetOnlyRenderToTexture(bool value) {
    SetSchemaValue(m_ptr, "CPointClientUIWorldPanel", "m_bOnlyRenderToTexture", false, value);
}
bool GCPointClientUIWorldPanel::GetDisableMipGen() const {
    return GetSchemaValue<bool>(m_ptr, "CPointClientUIWorldPanel", "m_bDisableMipGen");
}
void GCPointClientUIWorldPanel::SetDisableMipGen(bool value) {
    SetSchemaValue(m_ptr, "CPointClientUIWorldPanel", "m_bDisableMipGen", false, value);
}
int32_t GCPointClientUIWorldPanel::GetExplicitImageLayout() const {
    return GetSchemaValue<int32_t>(m_ptr, "CPointClientUIWorldPanel", "m_nExplicitImageLayout");
}
void GCPointClientUIWorldPanel::SetExplicitImageLayout(int32_t value) {
    SetSchemaValue(m_ptr, "CPointClientUIWorldPanel", "m_nExplicitImageLayout", false, value);
}
void* GCPointClientUIWorldPanel::GetPtr() {
    return m_ptr;
}
std::string GCPointClientUIWorldPanel::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCPointClientUIWorldPanel::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseClientUIEntity GCPointClientUIWorldPanel::GetParent() const {
    GCBaseClientUIEntity value(m_ptr);
    return value;
}
void GCPointClientUIWorldPanel::SetParent(GCBaseClientUIEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCPointClientUIWorldPanel(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCPointClientUIWorldPanel>("CPointClientUIWorldPanel")
        .addConstructor<void (*)(std::string)>()
        .addProperty("IgnoreInput", &GCPointClientUIWorldPanel::GetIgnoreInput, &GCPointClientUIWorldPanel::SetIgnoreInput)
        .addProperty("Lit", &GCPointClientUIWorldPanel::GetLit, &GCPointClientUIWorldPanel::SetLit)
        .addProperty("FollowPlayerAcrossTeleport", &GCPointClientUIWorldPanel::GetFollowPlayerAcrossTeleport, &GCPointClientUIWorldPanel::SetFollowPlayerAcrossTeleport)
        .addProperty("Width", &GCPointClientUIWorldPanel::GetWidth, &GCPointClientUIWorldPanel::SetWidth)
        .addProperty("Height", &GCPointClientUIWorldPanel::GetHeight, &GCPointClientUIWorldPanel::SetHeight)
        .addProperty("DPI", &GCPointClientUIWorldPanel::GetDPI, &GCPointClientUIWorldPanel::SetDPI)
        .addProperty("InteractDistance", &GCPointClientUIWorldPanel::GetInteractDistance, &GCPointClientUIWorldPanel::SetInteractDistance)
        .addProperty("DepthOffset", &GCPointClientUIWorldPanel::GetDepthOffset, &GCPointClientUIWorldPanel::SetDepthOffset)
        .addProperty("OwnerContext", &GCPointClientUIWorldPanel::GetOwnerContext, &GCPointClientUIWorldPanel::SetOwnerContext)
        .addProperty("HorizontalAlign", &GCPointClientUIWorldPanel::GetHorizontalAlign, &GCPointClientUIWorldPanel::SetHorizontalAlign)
        .addProperty("VerticalAlign", &GCPointClientUIWorldPanel::GetVerticalAlign, &GCPointClientUIWorldPanel::SetVerticalAlign)
        .addProperty("Orientation", &GCPointClientUIWorldPanel::GetOrientation, &GCPointClientUIWorldPanel::SetOrientation)
        .addProperty("AllowInteractionFromAllSceneWorlds", &GCPointClientUIWorldPanel::GetAllowInteractionFromAllSceneWorlds, &GCPointClientUIWorldPanel::SetAllowInteractionFromAllSceneWorlds)
        .addProperty("CSSClasses", &GCPointClientUIWorldPanel::GetCSSClasses, &GCPointClientUIWorldPanel::SetCSSClasses)
        .addProperty("Opaque", &GCPointClientUIWorldPanel::GetOpaque, &GCPointClientUIWorldPanel::SetOpaque)
        .addProperty("NoDepth", &GCPointClientUIWorldPanel::GetNoDepth, &GCPointClientUIWorldPanel::SetNoDepth)
        .addProperty("RenderBackface", &GCPointClientUIWorldPanel::GetRenderBackface, &GCPointClientUIWorldPanel::SetRenderBackface)
        .addProperty("UseOffScreenIndicator", &GCPointClientUIWorldPanel::GetUseOffScreenIndicator, &GCPointClientUIWorldPanel::SetUseOffScreenIndicator)
        .addProperty("ExcludeFromSaveGames", &GCPointClientUIWorldPanel::GetExcludeFromSaveGames, &GCPointClientUIWorldPanel::SetExcludeFromSaveGames)
        .addProperty("Grabbable", &GCPointClientUIWorldPanel::GetGrabbable, &GCPointClientUIWorldPanel::SetGrabbable)
        .addProperty("OnlyRenderToTexture", &GCPointClientUIWorldPanel::GetOnlyRenderToTexture, &GCPointClientUIWorldPanel::SetOnlyRenderToTexture)
        .addProperty("DisableMipGen", &GCPointClientUIWorldPanel::GetDisableMipGen, &GCPointClientUIWorldPanel::SetDisableMipGen)
        .addProperty("ExplicitImageLayout", &GCPointClientUIWorldPanel::GetExplicitImageLayout, &GCPointClientUIWorldPanel::SetExplicitImageLayout)
        .addProperty("Parent", &GCPointClientUIWorldPanel::GetParent, &GCPointClientUIWorldPanel::SetParent)
        .addFunction("ToPtr", &GCPointClientUIWorldPanel::ToPtr)
        .addFunction("IsValid", &GCPointClientUIWorldPanel::IsValid)
        .endClass();
}
GCFilterContext::GCFilterContext(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCFilterContext::GCFilterContext(void *ptr) {
    m_ptr = ptr;
}
std::string GCFilterContext::GetFilterContext() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CFilterContext", "m_iFilterContext").String();
}
void GCFilterContext::SetFilterContext(std::string value) {
    SetSchemaValue(m_ptr, "CFilterContext", "m_iFilterContext", false, CUtlSymbolLarge(value.c_str()));
}
void* GCFilterContext::GetPtr() {
    return m_ptr;
}
std::string GCFilterContext::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCFilterContext::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseFilter GCFilterContext::GetParent() const {
    GCBaseFilter value(m_ptr);
    return value;
}
void GCFilterContext::SetParent(GCBaseFilter value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCFilterContext(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCFilterContext>("CFilterContext")
        .addConstructor<void (*)(std::string)>()
        .addProperty("FilterContext", &GCFilterContext::GetFilterContext, &GCFilterContext::SetFilterContext)
        .addProperty("Parent", &GCFilterContext::GetParent, &GCFilterContext::SetParent)
        .addFunction("ToPtr", &GCFilterContext::ToPtr)
        .addFunction("IsValid", &GCFilterContext::IsValid)
        .endClass();
}
GCPathParticleRopeAlias_path_particle_rope_clientside::GCPathParticleRopeAlias_path_particle_rope_clientside(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCPathParticleRopeAlias_path_particle_rope_clientside::GCPathParticleRopeAlias_path_particle_rope_clientside(void *ptr) {
    m_ptr = ptr;
}
void* GCPathParticleRopeAlias_path_particle_rope_clientside::GetPtr() {
    return m_ptr;
}
std::string GCPathParticleRopeAlias_path_particle_rope_clientside::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCPathParticleRopeAlias_path_particle_rope_clientside::IsValid() {
    return (m_ptr != nullptr);
}
GCPathParticleRope GCPathParticleRopeAlias_path_particle_rope_clientside::GetParent() const {
    GCPathParticleRope value(m_ptr);
    return value;
}
void GCPathParticleRopeAlias_path_particle_rope_clientside::SetParent(GCPathParticleRope value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCPathParticleRopeAlias_path_particle_rope_clientside(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCPathParticleRopeAlias_path_particle_rope_clientside>("CPathParticleRopeAlias_path_particle_rope_clientside")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCPathParticleRopeAlias_path_particle_rope_clientside::GetParent, &GCPathParticleRopeAlias_path_particle_rope_clientside::SetParent)
        .addFunction("ToPtr", &GCPathParticleRopeAlias_path_particle_rope_clientside::ToPtr)
        .addFunction("IsValid", &GCPathParticleRopeAlias_path_particle_rope_clientside::IsValid)
        .endClass();
}
GCTriggerBuoyancy::GCTriggerBuoyancy(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCTriggerBuoyancy::GCTriggerBuoyancy(void *ptr) {
    m_ptr = ptr;
}
GCBuoyancyHelper GCTriggerBuoyancy::GetBuoyancyHelper() const {
    GCBuoyancyHelper value(GetSchemaPtr(m_ptr, "CTriggerBuoyancy", "m_BuoyancyHelper"));
    return value;
}
void GCTriggerBuoyancy::SetBuoyancyHelper(GCBuoyancyHelper value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'BuoyancyHelper' is not possible.\n");
}
float GCTriggerBuoyancy::GetFluidDensity() const {
    return GetSchemaValue<float>(m_ptr, "CTriggerBuoyancy", "m_flFluidDensity");
}
void GCTriggerBuoyancy::SetFluidDensity(float value) {
    SetSchemaValue(m_ptr, "CTriggerBuoyancy", "m_flFluidDensity", false, value);
}
void* GCTriggerBuoyancy::GetPtr() {
    return m_ptr;
}
std::string GCTriggerBuoyancy::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCTriggerBuoyancy::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseTrigger GCTriggerBuoyancy::GetParent() const {
    GCBaseTrigger value(m_ptr);
    return value;
}
void GCTriggerBuoyancy::SetParent(GCBaseTrigger value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCTriggerBuoyancy(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCTriggerBuoyancy>("CTriggerBuoyancy")
        .addConstructor<void (*)(std::string)>()
        .addProperty("BuoyancyHelper", &GCTriggerBuoyancy::GetBuoyancyHelper, &GCTriggerBuoyancy::SetBuoyancyHelper)
        .addProperty("FluidDensity", &GCTriggerBuoyancy::GetFluidDensity, &GCTriggerBuoyancy::SetFluidDensity)
        .addProperty("Parent", &GCTriggerBuoyancy::GetParent, &GCTriggerBuoyancy::SetParent)
        .addFunction("ToPtr", &GCTriggerBuoyancy::ToPtr)
        .addFunction("IsValid", &GCTriggerBuoyancy::IsValid)
        .endClass();
}
GCFilterAttributeInt::GCFilterAttributeInt(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCFilterAttributeInt::GCFilterAttributeInt(void *ptr) {
    m_ptr = ptr;
}
uint32_t GCFilterAttributeInt::GetAttributeName() const {
    return GetSchemaValue<CUtlStringToken>(m_ptr, "CFilterAttributeInt", "m_sAttributeName").m_nHashCode;
}
void GCFilterAttributeInt::SetAttributeName(uint32_t value) {
    SetSchemaValue(m_ptr, "CFilterAttributeInt", "m_sAttributeName", false, CUtlStringToken(value));
}
void* GCFilterAttributeInt::GetPtr() {
    return m_ptr;
}
std::string GCFilterAttributeInt::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCFilterAttributeInt::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseFilter GCFilterAttributeInt::GetParent() const {
    GCBaseFilter value(m_ptr);
    return value;
}
void GCFilterAttributeInt::SetParent(GCBaseFilter value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCFilterAttributeInt(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCFilterAttributeInt>("CFilterAttributeInt")
        .addConstructor<void (*)(std::string)>()
        .addProperty("AttributeName", &GCFilterAttributeInt::GetAttributeName, &GCFilterAttributeInt::SetAttributeName)
        .addProperty("Parent", &GCFilterAttributeInt::GetParent, &GCFilterAttributeInt::SetParent)
        .addFunction("ToPtr", &GCFilterAttributeInt::ToPtr)
        .addFunction("IsValid", &GCFilterAttributeInt::IsValid)
        .endClass();
}
GCCSPlayer_ActionTrackingServices::GCCSPlayer_ActionTrackingServices(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCCSPlayer_ActionTrackingServices::GCCSPlayer_ActionTrackingServices(void *ptr) {
    m_ptr = ptr;
}
GCBasePlayerWeapon GCCSPlayer_ActionTrackingServices::GetLastWeaponBeforeC4AutoSwitch() const {
    GCBasePlayerWeapon value((void*)(GetSchemaValue<CHandle<CEntityInstance>>(m_ptr, "CCSPlayer_ActionTrackingServices", "m_hLastWeaponBeforeC4AutoSwitch").Get()));
    return value;
}
void GCCSPlayer_ActionTrackingServices::SetLastWeaponBeforeC4AutoSwitch(GCBasePlayerWeapon value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'LastWeaponBeforeC4AutoSwitch' is not possible.\n");
}
bool GCCSPlayer_ActionTrackingServices::GetIsRescuing() const {
    return GetSchemaValue<bool>(m_ptr, "CCSPlayer_ActionTrackingServices", "m_bIsRescuing");
}
void GCCSPlayer_ActionTrackingServices::SetIsRescuing(bool value) {
    SetSchemaValue(m_ptr, "CCSPlayer_ActionTrackingServices", "m_bIsRescuing", false, value);
}
GWeaponPurchaseTracker_t GCCSPlayer_ActionTrackingServices::GetWeaponPurchasesThisMatch() const {
    GWeaponPurchaseTracker_t value(GetSchemaPtr(m_ptr, "CCSPlayer_ActionTrackingServices", "m_weaponPurchasesThisMatch"));
    return value;
}
void GCCSPlayer_ActionTrackingServices::SetWeaponPurchasesThisMatch(GWeaponPurchaseTracker_t value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'WeaponPurchasesThisMatch' is not possible.\n");
}
GWeaponPurchaseTracker_t GCCSPlayer_ActionTrackingServices::GetWeaponPurchasesThisRound() const {
    GWeaponPurchaseTracker_t value(GetSchemaPtr(m_ptr, "CCSPlayer_ActionTrackingServices", "m_weaponPurchasesThisRound"));
    return value;
}
void GCCSPlayer_ActionTrackingServices::SetWeaponPurchasesThisRound(GWeaponPurchaseTracker_t value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'WeaponPurchasesThisRound' is not possible.\n");
}
void* GCCSPlayer_ActionTrackingServices::GetPtr() {
    return m_ptr;
}
std::string GCCSPlayer_ActionTrackingServices::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCCSPlayer_ActionTrackingServices::IsValid() {
    return (m_ptr != nullptr);
}
GCPlayerPawnComponent GCCSPlayer_ActionTrackingServices::GetParent() const {
    GCPlayerPawnComponent value(m_ptr);
    return value;
}
void GCCSPlayer_ActionTrackingServices::SetParent(GCPlayerPawnComponent value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCCSPlayer_ActionTrackingServices(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCCSPlayer_ActionTrackingServices>("CCSPlayer_ActionTrackingServices")
        .addConstructor<void (*)(std::string)>()
        .addProperty("LastWeaponBeforeC4AutoSwitch", &GCCSPlayer_ActionTrackingServices::GetLastWeaponBeforeC4AutoSwitch, &GCCSPlayer_ActionTrackingServices::SetLastWeaponBeforeC4AutoSwitch)
        .addProperty("IsRescuing", &GCCSPlayer_ActionTrackingServices::GetIsRescuing, &GCCSPlayer_ActionTrackingServices::SetIsRescuing)
        .addProperty("WeaponPurchasesThisMatch", &GCCSPlayer_ActionTrackingServices::GetWeaponPurchasesThisMatch, &GCCSPlayer_ActionTrackingServices::SetWeaponPurchasesThisMatch)
        .addProperty("WeaponPurchasesThisRound", &GCCSPlayer_ActionTrackingServices::GetWeaponPurchasesThisRound, &GCCSPlayer_ActionTrackingServices::SetWeaponPurchasesThisRound)
        .addProperty("Parent", &GCCSPlayer_ActionTrackingServices::GetParent, &GCCSPlayer_ActionTrackingServices::SetParent)
        .addFunction("ToPtr", &GCCSPlayer_ActionTrackingServices::ToPtr)
        .addFunction("IsValid", &GCCSPlayer_ActionTrackingServices::IsValid)
        .endClass();
}
GCAISound::GCAISound(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCAISound::GCAISound(void *ptr) {
    m_ptr = ptr;
}
uint64_t GCAISound::GetSoundType() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CAISound", "m_iSoundType");
}
void GCAISound::SetSoundType(uint64_t value) {
    SetSchemaValue(m_ptr, "CAISound", "m_iSoundType", false, value);
}
uint64_t GCAISound::GetSoundFlags() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CAISound", "m_iSoundFlags");
}
void GCAISound::SetSoundFlags(uint64_t value) {
    SetSchemaValue(m_ptr, "CAISound", "m_iSoundFlags", false, value);
}
int32_t GCAISound::GetVolume() const {
    return GetSchemaValue<int32_t>(m_ptr, "CAISound", "m_iVolume");
}
void GCAISound::SetVolume(int32_t value) {
    SetSchemaValue(m_ptr, "CAISound", "m_iVolume", false, value);
}
int32_t GCAISound::GetSoundIndex() const {
    return GetSchemaValue<int32_t>(m_ptr, "CAISound", "m_iSoundIndex");
}
void GCAISound::SetSoundIndex(int32_t value) {
    SetSchemaValue(m_ptr, "CAISound", "m_iSoundIndex", false, value);
}
float GCAISound::GetDuration() const {
    return GetSchemaValue<float>(m_ptr, "CAISound", "m_flDuration");
}
void GCAISound::SetDuration(float value) {
    SetSchemaValue(m_ptr, "CAISound", "m_flDuration", false, value);
}
std::string GCAISound::GetProxyEntityName() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CAISound", "m_iszProxyEntityName").String();
}
void GCAISound::SetProxyEntityName(std::string value) {
    SetSchemaValue(m_ptr, "CAISound", "m_iszProxyEntityName", false, CUtlSymbolLarge(value.c_str()));
}
void* GCAISound::GetPtr() {
    return m_ptr;
}
std::string GCAISound::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCAISound::IsValid() {
    return (m_ptr != nullptr);
}
GCPointEntity GCAISound::GetParent() const {
    GCPointEntity value(m_ptr);
    return value;
}
void GCAISound::SetParent(GCPointEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCAISound(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCAISound>("CAISound")
        .addConstructor<void (*)(std::string)>()
        .addProperty("SoundType", &GCAISound::GetSoundType, &GCAISound::SetSoundType)
        .addProperty("SoundFlags", &GCAISound::GetSoundFlags, &GCAISound::SetSoundFlags)
        .addProperty("Volume", &GCAISound::GetVolume, &GCAISound::SetVolume)
        .addProperty("SoundIndex", &GCAISound::GetSoundIndex, &GCAISound::SetSoundIndex)
        .addProperty("Duration", &GCAISound::GetDuration, &GCAISound::SetDuration)
        .addProperty("ProxyEntityName", &GCAISound::GetProxyEntityName, &GCAISound::SetProxyEntityName)
        .addProperty("Parent", &GCAISound::GetParent, &GCAISound::SetParent)
        .addFunction("ToPtr", &GCAISound::ToPtr)
        .addFunction("IsValid", &GCAISound::IsValid)
        .endClass();
}
GCPointEntityFinder::GCPointEntityFinder(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCPointEntityFinder::GCPointEntityFinder(void *ptr) {
    m_ptr = ptr;
}
GCBaseEntity GCPointEntityFinder::GetEntity() const {
    GCBaseEntity value((void*)(GetSchemaValue<CHandle<CEntityInstance>>(m_ptr, "CPointEntityFinder", "m_hEntity").Get()));
    return value;
}
void GCPointEntityFinder::SetEntity(GCBaseEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Entity' is not possible.\n");
}
std::string GCPointEntityFinder::GetFilterName() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CPointEntityFinder", "m_iFilterName").String();
}
void GCPointEntityFinder::SetFilterName(std::string value) {
    SetSchemaValue(m_ptr, "CPointEntityFinder", "m_iFilterName", false, CUtlSymbolLarge(value.c_str()));
}
GCBaseFilter GCPointEntityFinder::GetFilter() const {
    GCBaseFilter value((void*)(GetSchemaValue<CHandle<CEntityInstance>>(m_ptr, "CPointEntityFinder", "m_hFilter").Get()));
    return value;
}
void GCPointEntityFinder::SetFilter(GCBaseFilter value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Filter' is not possible.\n");
}
std::string GCPointEntityFinder::GetRefName() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CPointEntityFinder", "m_iRefName").String();
}
void GCPointEntityFinder::SetRefName(std::string value) {
    SetSchemaValue(m_ptr, "CPointEntityFinder", "m_iRefName", false, CUtlSymbolLarge(value.c_str()));
}
GCBaseEntity GCPointEntityFinder::GetReference() const {
    GCBaseEntity value((void*)(GetSchemaValue<CHandle<CEntityInstance>>(m_ptr, "CPointEntityFinder", "m_hReference").Get()));
    return value;
}
void GCPointEntityFinder::SetReference(GCBaseEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Reference' is not possible.\n");
}
uint64_t GCPointEntityFinder::GetFindMethod() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CPointEntityFinder", "m_FindMethod");
}
void GCPointEntityFinder::SetFindMethod(uint64_t value) {
    SetSchemaValue(m_ptr, "CPointEntityFinder", "m_FindMethod", false, value);
}
GCEntityIOOutput GCPointEntityFinder::GetOnFoundEntity() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CPointEntityFinder", "m_OnFoundEntity"));
    return value;
}
void GCPointEntityFinder::SetOnFoundEntity(GCEntityIOOutput value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'OnFoundEntity' is not possible.\n");
}
void* GCPointEntityFinder::GetPtr() {
    return m_ptr;
}
std::string GCPointEntityFinder::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCPointEntityFinder::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseEntity GCPointEntityFinder::GetParent() const {
    GCBaseEntity value(m_ptr);
    return value;
}
void GCPointEntityFinder::SetParent(GCBaseEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCPointEntityFinder(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCPointEntityFinder>("CPointEntityFinder")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Entity", &GCPointEntityFinder::GetEntity, &GCPointEntityFinder::SetEntity)
        .addProperty("FilterName", &GCPointEntityFinder::GetFilterName, &GCPointEntityFinder::SetFilterName)
        .addProperty("Filter", &GCPointEntityFinder::GetFilter, &GCPointEntityFinder::SetFilter)
        .addProperty("RefName", &GCPointEntityFinder::GetRefName, &GCPointEntityFinder::SetRefName)
        .addProperty("Reference", &GCPointEntityFinder::GetReference, &GCPointEntityFinder::SetReference)
        .addProperty("FindMethod", &GCPointEntityFinder::GetFindMethod, &GCPointEntityFinder::SetFindMethod)
        .addProperty("OnFoundEntity", &GCPointEntityFinder::GetOnFoundEntity, &GCPointEntityFinder::SetOnFoundEntity)
        .addProperty("Parent", &GCPointEntityFinder::GetParent, &GCPointEntityFinder::SetParent)
        .addFunction("ToPtr", &GCPointEntityFinder::ToPtr)
        .addFunction("IsValid", &GCPointEntityFinder::IsValid)
        .endClass();
}
Gshard_model_desc_t::Gshard_model_desc_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
Gshard_model_desc_t::Gshard_model_desc_t(void *ptr) {
    m_ptr = ptr;
}
int32_t Gshard_model_desc_t::GetModelID() const {
    return GetSchemaValue<int32_t>(m_ptr, "shard_model_desc_t", "m_nModelID");
}
void Gshard_model_desc_t::SetModelID(int32_t value) {
    SetSchemaValue(m_ptr, "shard_model_desc_t", "m_nModelID", true, value);
}
uint64_t Gshard_model_desc_t::GetSolid() const {
    return GetSchemaValue<uint64_t>(m_ptr, "shard_model_desc_t", "m_solid");
}
void Gshard_model_desc_t::SetSolid(uint64_t value) {
    SetSchemaValue(m_ptr, "shard_model_desc_t", "m_solid", true, value);
}
uint64_t Gshard_model_desc_t::GetShatterPanelMode() const {
    return GetSchemaValue<uint64_t>(m_ptr, "shard_model_desc_t", "m_ShatterPanelMode");
}
void Gshard_model_desc_t::SetShatterPanelMode(uint64_t value) {
    SetSchemaValue(m_ptr, "shard_model_desc_t", "m_ShatterPanelMode", true, value);
}
Vector2D Gshard_model_desc_t::GetPanelSize() const {
    return GetSchemaValue<Vector2D>(m_ptr, "shard_model_desc_t", "m_vecPanelSize");
}
void Gshard_model_desc_t::SetPanelSize(Vector2D value) {
    SetSchemaValue(m_ptr, "shard_model_desc_t", "m_vecPanelSize", true, value);
}
Vector2D Gshard_model_desc_t::GetStressPositionA() const {
    return GetSchemaValue<Vector2D>(m_ptr, "shard_model_desc_t", "m_vecStressPositionA");
}
void Gshard_model_desc_t::SetStressPositionA(Vector2D value) {
    SetSchemaValue(m_ptr, "shard_model_desc_t", "m_vecStressPositionA", true, value);
}
Vector2D Gshard_model_desc_t::GetStressPositionB() const {
    return GetSchemaValue<Vector2D>(m_ptr, "shard_model_desc_t", "m_vecStressPositionB");
}
void Gshard_model_desc_t::SetStressPositionB(Vector2D value) {
    SetSchemaValue(m_ptr, "shard_model_desc_t", "m_vecStressPositionB", true, value);
}
std::vector<Vector2D> Gshard_model_desc_t::GetPanelVertices() const {
    CUtlVector<Vector2D>* vec = GetSchemaValue<CUtlVector<Vector2D>*>(m_ptr, "shard_model_desc_t", "m_vecPanelVertices"); std::vector<Vector2D> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void Gshard_model_desc_t::SetPanelVertices(std::vector<Vector2D> value) {
    SetSchemaValueCUtlVector<Vector2D>(m_ptr, "shard_model_desc_t", "m_vecPanelVertices", true, value);
}
float Gshard_model_desc_t::GetGlassHalfThickness() const {
    return GetSchemaValue<float>(m_ptr, "shard_model_desc_t", "m_flGlassHalfThickness");
}
void Gshard_model_desc_t::SetGlassHalfThickness(float value) {
    SetSchemaValue(m_ptr, "shard_model_desc_t", "m_flGlassHalfThickness", true, value);
}
bool Gshard_model_desc_t::GetHasParent() const {
    return GetSchemaValue<bool>(m_ptr, "shard_model_desc_t", "m_bHasParent");
}
void Gshard_model_desc_t::SetHasParent(bool value) {
    SetSchemaValue(m_ptr, "shard_model_desc_t", "m_bHasParent", true, value);
}
bool Gshard_model_desc_t::GetParentFrozen() const {
    return GetSchemaValue<bool>(m_ptr, "shard_model_desc_t", "m_bParentFrozen");
}
void Gshard_model_desc_t::SetParentFrozen(bool value) {
    SetSchemaValue(m_ptr, "shard_model_desc_t", "m_bParentFrozen", true, value);
}
uint32_t Gshard_model_desc_t::GetSurfacePropStringToken() const {
    return GetSchemaValue<CUtlStringToken>(m_ptr, "shard_model_desc_t", "m_SurfacePropStringToken").m_nHashCode;
}
void Gshard_model_desc_t::SetSurfacePropStringToken(uint32_t value) {
    SetSchemaValue(m_ptr, "shard_model_desc_t", "m_SurfacePropStringToken", true, CUtlStringToken(value));
}
void* Gshard_model_desc_t::GetPtr() {
    return m_ptr;
}
std::string Gshard_model_desc_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool Gshard_model_desc_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassshard_model_desc_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<Gshard_model_desc_t>("shard_model_desc_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("ModelID", &Gshard_model_desc_t::GetModelID, &Gshard_model_desc_t::SetModelID)
        .addProperty("Solid", &Gshard_model_desc_t::GetSolid, &Gshard_model_desc_t::SetSolid)
        .addProperty("ShatterPanelMode", &Gshard_model_desc_t::GetShatterPanelMode, &Gshard_model_desc_t::SetShatterPanelMode)
        .addProperty("PanelSize", &Gshard_model_desc_t::GetPanelSize, &Gshard_model_desc_t::SetPanelSize)
        .addProperty("StressPositionA", &Gshard_model_desc_t::GetStressPositionA, &Gshard_model_desc_t::SetStressPositionA)
        .addProperty("StressPositionB", &Gshard_model_desc_t::GetStressPositionB, &Gshard_model_desc_t::SetStressPositionB)
        .addProperty("PanelVertices", &Gshard_model_desc_t::GetPanelVertices, &Gshard_model_desc_t::SetPanelVertices)
        .addProperty("GlassHalfThickness", &Gshard_model_desc_t::GetGlassHalfThickness, &Gshard_model_desc_t::SetGlassHalfThickness)
        .addProperty("HasParent", &Gshard_model_desc_t::GetHasParent, &Gshard_model_desc_t::SetHasParent)
        .addProperty("ParentFrozen", &Gshard_model_desc_t::GetParentFrozen, &Gshard_model_desc_t::SetParentFrozen)
        .addProperty("SurfacePropStringToken", &Gshard_model_desc_t::GetSurfacePropStringToken, &Gshard_model_desc_t::SetSurfacePropStringToken)
        .addFunction("ToPtr", &Gshard_model_desc_t::ToPtr)
        .addFunction("IsValid", &Gshard_model_desc_t::IsValid)
        .endClass();
}
GCPhysicsPropRespawnable::GCPhysicsPropRespawnable(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCPhysicsPropRespawnable::GCPhysicsPropRespawnable(void *ptr) {
    m_ptr = ptr;
}
Vector GCPhysicsPropRespawnable::GetOriginalSpawnOrigin() const {
    return GetSchemaValue<Vector>(m_ptr, "CPhysicsPropRespawnable", "m_vOriginalSpawnOrigin");
}
void GCPhysicsPropRespawnable::SetOriginalSpawnOrigin(Vector value) {
    SetSchemaValue(m_ptr, "CPhysicsPropRespawnable", "m_vOriginalSpawnOrigin", false, value);
}
QAngle GCPhysicsPropRespawnable::GetOriginalSpawnAngles() const {
    return GetSchemaValue<QAngle>(m_ptr, "CPhysicsPropRespawnable", "m_vOriginalSpawnAngles");
}
void GCPhysicsPropRespawnable::SetOriginalSpawnAngles(QAngle value) {
    SetSchemaValue(m_ptr, "CPhysicsPropRespawnable", "m_vOriginalSpawnAngles", false, value);
}
Vector GCPhysicsPropRespawnable::GetOriginalMins() const {
    return GetSchemaValue<Vector>(m_ptr, "CPhysicsPropRespawnable", "m_vOriginalMins");
}
void GCPhysicsPropRespawnable::SetOriginalMins(Vector value) {
    SetSchemaValue(m_ptr, "CPhysicsPropRespawnable", "m_vOriginalMins", false, value);
}
Vector GCPhysicsPropRespawnable::GetOriginalMaxs() const {
    return GetSchemaValue<Vector>(m_ptr, "CPhysicsPropRespawnable", "m_vOriginalMaxs");
}
void GCPhysicsPropRespawnable::SetOriginalMaxs(Vector value) {
    SetSchemaValue(m_ptr, "CPhysicsPropRespawnable", "m_vOriginalMaxs", false, value);
}
float GCPhysicsPropRespawnable::GetRespawnDuration() const {
    return GetSchemaValue<float>(m_ptr, "CPhysicsPropRespawnable", "m_flRespawnDuration");
}
void GCPhysicsPropRespawnable::SetRespawnDuration(float value) {
    SetSchemaValue(m_ptr, "CPhysicsPropRespawnable", "m_flRespawnDuration", false, value);
}
void* GCPhysicsPropRespawnable::GetPtr() {
    return m_ptr;
}
std::string GCPhysicsPropRespawnable::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCPhysicsPropRespawnable::IsValid() {
    return (m_ptr != nullptr);
}
GCPhysicsProp GCPhysicsPropRespawnable::GetParent() const {
    GCPhysicsProp value(m_ptr);
    return value;
}
void GCPhysicsPropRespawnable::SetParent(GCPhysicsProp value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCPhysicsPropRespawnable(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCPhysicsPropRespawnable>("CPhysicsPropRespawnable")
        .addConstructor<void (*)(std::string)>()
        .addProperty("OriginalSpawnOrigin", &GCPhysicsPropRespawnable::GetOriginalSpawnOrigin, &GCPhysicsPropRespawnable::SetOriginalSpawnOrigin)
        .addProperty("OriginalSpawnAngles", &GCPhysicsPropRespawnable::GetOriginalSpawnAngles, &GCPhysicsPropRespawnable::SetOriginalSpawnAngles)
        .addProperty("OriginalMins", &GCPhysicsPropRespawnable::GetOriginalMins, &GCPhysicsPropRespawnable::SetOriginalMins)
        .addProperty("OriginalMaxs", &GCPhysicsPropRespawnable::GetOriginalMaxs, &GCPhysicsPropRespawnable::SetOriginalMaxs)
        .addProperty("RespawnDuration", &GCPhysicsPropRespawnable::GetRespawnDuration, &GCPhysicsPropRespawnable::SetRespawnDuration)
        .addProperty("Parent", &GCPhysicsPropRespawnable::GetParent, &GCPhysicsPropRespawnable::SetParent)
        .addFunction("ToPtr", &GCPhysicsPropRespawnable::ToPtr)
        .addFunction("IsValid", &GCPhysicsPropRespawnable::IsValid)
        .endClass();
}
GCEnvSky::GCEnvSky(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCEnvSky::GCEnvSky(void *ptr) {
    m_ptr = ptr;
}
bool GCEnvSky::GetStartDisabled() const {
    return GetSchemaValue<bool>(m_ptr, "CEnvSky", "m_bStartDisabled");
}
void GCEnvSky::SetStartDisabled(bool value) {
    SetSchemaValue(m_ptr, "CEnvSky", "m_bStartDisabled", false, value);
}
Color GCEnvSky::GetTintColor() const {
    return GetSchemaValue<Color>(m_ptr, "CEnvSky", "m_vTintColor");
}
void GCEnvSky::SetTintColor(Color value) {
    SetSchemaValue(m_ptr, "CEnvSky", "m_vTintColor", false, value);
}
Color GCEnvSky::GetTintColorLightingOnly() const {
    return GetSchemaValue<Color>(m_ptr, "CEnvSky", "m_vTintColorLightingOnly");
}
void GCEnvSky::SetTintColorLightingOnly(Color value) {
    SetSchemaValue(m_ptr, "CEnvSky", "m_vTintColorLightingOnly", false, value);
}
float GCEnvSky::GetBrightnessScale() const {
    return GetSchemaValue<float>(m_ptr, "CEnvSky", "m_flBrightnessScale");
}
void GCEnvSky::SetBrightnessScale(float value) {
    SetSchemaValue(m_ptr, "CEnvSky", "m_flBrightnessScale", false, value);
}
int32_t GCEnvSky::GetFogType() const {
    return GetSchemaValue<int32_t>(m_ptr, "CEnvSky", "m_nFogType");
}
void GCEnvSky::SetFogType(int32_t value) {
    SetSchemaValue(m_ptr, "CEnvSky", "m_nFogType", false, value);
}
float GCEnvSky::GetFogMinStart() const {
    return GetSchemaValue<float>(m_ptr, "CEnvSky", "m_flFogMinStart");
}
void GCEnvSky::SetFogMinStart(float value) {
    SetSchemaValue(m_ptr, "CEnvSky", "m_flFogMinStart", false, value);
}
float GCEnvSky::GetFogMinEnd() const {
    return GetSchemaValue<float>(m_ptr, "CEnvSky", "m_flFogMinEnd");
}
void GCEnvSky::SetFogMinEnd(float value) {
    SetSchemaValue(m_ptr, "CEnvSky", "m_flFogMinEnd", false, value);
}
float GCEnvSky::GetFogMaxStart() const {
    return GetSchemaValue<float>(m_ptr, "CEnvSky", "m_flFogMaxStart");
}
void GCEnvSky::SetFogMaxStart(float value) {
    SetSchemaValue(m_ptr, "CEnvSky", "m_flFogMaxStart", false, value);
}
float GCEnvSky::GetFogMaxEnd() const {
    return GetSchemaValue<float>(m_ptr, "CEnvSky", "m_flFogMaxEnd");
}
void GCEnvSky::SetFogMaxEnd(float value) {
    SetSchemaValue(m_ptr, "CEnvSky", "m_flFogMaxEnd", false, value);
}
bool GCEnvSky::GetEnabled() const {
    return GetSchemaValue<bool>(m_ptr, "CEnvSky", "m_bEnabled");
}
void GCEnvSky::SetEnabled(bool value) {
    SetSchemaValue(m_ptr, "CEnvSky", "m_bEnabled", false, value);
}
void* GCEnvSky::GetPtr() {
    return m_ptr;
}
std::string GCEnvSky::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCEnvSky::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseModelEntity GCEnvSky::GetParent() const {
    GCBaseModelEntity value(m_ptr);
    return value;
}
void GCEnvSky::SetParent(GCBaseModelEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCEnvSky(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCEnvSky>("CEnvSky")
        .addConstructor<void (*)(std::string)>()
        .addProperty("StartDisabled", &GCEnvSky::GetStartDisabled, &GCEnvSky::SetStartDisabled)
        .addProperty("TintColor", &GCEnvSky::GetTintColor, &GCEnvSky::SetTintColor)
        .addProperty("TintColorLightingOnly", &GCEnvSky::GetTintColorLightingOnly, &GCEnvSky::SetTintColorLightingOnly)
        .addProperty("BrightnessScale", &GCEnvSky::GetBrightnessScale, &GCEnvSky::SetBrightnessScale)
        .addProperty("FogType", &GCEnvSky::GetFogType, &GCEnvSky::SetFogType)
        .addProperty("FogMinStart", &GCEnvSky::GetFogMinStart, &GCEnvSky::SetFogMinStart)
        .addProperty("FogMinEnd", &GCEnvSky::GetFogMinEnd, &GCEnvSky::SetFogMinEnd)
        .addProperty("FogMaxStart", &GCEnvSky::GetFogMaxStart, &GCEnvSky::SetFogMaxStart)
        .addProperty("FogMaxEnd", &GCEnvSky::GetFogMaxEnd, &GCEnvSky::SetFogMaxEnd)
        .addProperty("Enabled", &GCEnvSky::GetEnabled, &GCEnvSky::SetEnabled)
        .addProperty("Parent", &GCEnvSky::GetParent, &GCEnvSky::SetParent)
        .addFunction("ToPtr", &GCEnvSky::ToPtr)
        .addFunction("IsValid", &GCEnvSky::IsValid)
        .endClass();
}
GCPointVelocitySensor::GCPointVelocitySensor(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCPointVelocitySensor::GCPointVelocitySensor(void *ptr) {
    m_ptr = ptr;
}
GCBaseEntity GCPointVelocitySensor::GetTargetEntity() const {
    GCBaseEntity value((void*)(GetSchemaValue<CHandle<CEntityInstance>>(m_ptr, "CPointVelocitySensor", "m_hTargetEntity").Get()));
    return value;
}
void GCPointVelocitySensor::SetTargetEntity(GCBaseEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'TargetEntity' is not possible.\n");
}
Vector GCPointVelocitySensor::GetAxis() const {
    return GetSchemaValue<Vector>(m_ptr, "CPointVelocitySensor", "m_vecAxis");
}
void GCPointVelocitySensor::SetAxis(Vector value) {
    SetSchemaValue(m_ptr, "CPointVelocitySensor", "m_vecAxis", false, value);
}
bool GCPointVelocitySensor::GetEnabled() const {
    return GetSchemaValue<bool>(m_ptr, "CPointVelocitySensor", "m_bEnabled");
}
void GCPointVelocitySensor::SetEnabled(bool value) {
    SetSchemaValue(m_ptr, "CPointVelocitySensor", "m_bEnabled", false, value);
}
float GCPointVelocitySensor::GetPrevVelocity() const {
    return GetSchemaValue<float>(m_ptr, "CPointVelocitySensor", "m_fPrevVelocity");
}
void GCPointVelocitySensor::SetPrevVelocity(float value) {
    SetSchemaValue(m_ptr, "CPointVelocitySensor", "m_fPrevVelocity", false, value);
}
float GCPointVelocitySensor::GetAvgInterval() const {
    return GetSchemaValue<float>(m_ptr, "CPointVelocitySensor", "m_flAvgInterval");
}
void GCPointVelocitySensor::SetAvgInterval(float value) {
    SetSchemaValue(m_ptr, "CPointVelocitySensor", "m_flAvgInterval", false, value);
}
void* GCPointVelocitySensor::GetPtr() {
    return m_ptr;
}
std::string GCPointVelocitySensor::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCPointVelocitySensor::IsValid() {
    return (m_ptr != nullptr);
}
GCPointEntity GCPointVelocitySensor::GetParent() const {
    GCPointEntity value(m_ptr);
    return value;
}
void GCPointVelocitySensor::SetParent(GCPointEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCPointVelocitySensor(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCPointVelocitySensor>("CPointVelocitySensor")
        .addConstructor<void (*)(std::string)>()
        .addProperty("TargetEntity", &GCPointVelocitySensor::GetTargetEntity, &GCPointVelocitySensor::SetTargetEntity)
        .addProperty("Axis", &GCPointVelocitySensor::GetAxis, &GCPointVelocitySensor::SetAxis)
        .addProperty("Enabled", &GCPointVelocitySensor::GetEnabled, &GCPointVelocitySensor::SetEnabled)
        .addProperty("PrevVelocity", &GCPointVelocitySensor::GetPrevVelocity, &GCPointVelocitySensor::SetPrevVelocity)
        .addProperty("AvgInterval", &GCPointVelocitySensor::GetAvgInterval, &GCPointVelocitySensor::SetAvgInterval)
        .addProperty("Parent", &GCPointVelocitySensor::GetParent, &GCPointVelocitySensor::SetParent)
        .addFunction("ToPtr", &GCPointVelocitySensor::ToPtr)
        .addFunction("IsValid", &GCPointVelocitySensor::IsValid)
        .endClass();
}
GCFilterMassGreater::GCFilterMassGreater(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCFilterMassGreater::GCFilterMassGreater(void *ptr) {
    m_ptr = ptr;
}
float GCFilterMassGreater::GetFilterMass() const {
    return GetSchemaValue<float>(m_ptr, "CFilterMassGreater", "m_fFilterMass");
}
void GCFilterMassGreater::SetFilterMass(float value) {
    SetSchemaValue(m_ptr, "CFilterMassGreater", "m_fFilterMass", false, value);
}
void* GCFilterMassGreater::GetPtr() {
    return m_ptr;
}
std::string GCFilterMassGreater::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCFilterMassGreater::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseFilter GCFilterMassGreater::GetParent() const {
    GCBaseFilter value(m_ptr);
    return value;
}
void GCFilterMassGreater::SetParent(GCBaseFilter value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCFilterMassGreater(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCFilterMassGreater>("CFilterMassGreater")
        .addConstructor<void (*)(std::string)>()
        .addProperty("FilterMass", &GCFilterMassGreater::GetFilterMass, &GCFilterMassGreater::SetFilterMass)
        .addProperty("Parent", &GCFilterMassGreater::GetParent, &GCFilterMassGreater::SetParent)
        .addFunction("ToPtr", &GCFilterMassGreater::ToPtr)
        .addFunction("IsValid", &GCFilterMassGreater::IsValid)
        .endClass();
}
GFilterTeam::GFilterTeam(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GFilterTeam::GFilterTeam(void *ptr) {
    m_ptr = ptr;
}
int32_t GFilterTeam::GetFilterTeam() const {
    return GetSchemaValue<int32_t>(m_ptr, "FilterTeam", "m_iFilterTeam");
}
void GFilterTeam::SetFilterTeam(int32_t value) {
    SetSchemaValue(m_ptr, "FilterTeam", "m_iFilterTeam", false, value);
}
void* GFilterTeam::GetPtr() {
    return m_ptr;
}
std::string GFilterTeam::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GFilterTeam::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseFilter GFilterTeam::GetParent() const {
    GCBaseFilter value(m_ptr);
    return value;
}
void GFilterTeam::SetParent(GCBaseFilter value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassFilterTeam(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GFilterTeam>("FilterTeam")
        .addConstructor<void (*)(std::string)>()
        .addProperty("FilterTeam", &GFilterTeam::GetFilterTeam, &GFilterTeam::SetFilterTeam)
        .addProperty("Parent", &GFilterTeam::GetParent, &GFilterTeam::SetParent)
        .addFunction("ToPtr", &GFilterTeam::ToPtr)
        .addFunction("IsValid", &GFilterTeam::IsValid)
        .endClass();
}
GCFuncTankTrain::GCFuncTankTrain(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCFuncTankTrain::GCFuncTankTrain(void *ptr) {
    m_ptr = ptr;
}
GCEntityIOOutput GCFuncTankTrain::GetOnDeath() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CFuncTankTrain", "m_OnDeath"));
    return value;
}
void GCFuncTankTrain::SetOnDeath(GCEntityIOOutput value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'OnDeath' is not possible.\n");
}
void* GCFuncTankTrain::GetPtr() {
    return m_ptr;
}
std::string GCFuncTankTrain::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCFuncTankTrain::IsValid() {
    return (m_ptr != nullptr);
}
GCFuncTrackTrain GCFuncTankTrain::GetParent() const {
    GCFuncTrackTrain value(m_ptr);
    return value;
}
void GCFuncTankTrain::SetParent(GCFuncTrackTrain value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCFuncTankTrain(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCFuncTankTrain>("CFuncTankTrain")
        .addConstructor<void (*)(std::string)>()
        .addProperty("OnDeath", &GCFuncTankTrain::GetOnDeath, &GCFuncTankTrain::SetOnDeath)
        .addProperty("Parent", &GCFuncTankTrain::GetParent, &GCFuncTankTrain::SetParent)
        .addFunction("ToPtr", &GCFuncTankTrain::ToPtr)
        .addFunction("IsValid", &GCFuncTankTrain::IsValid)
        .endClass();
}
GCNullEntity::GCNullEntity(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCNullEntity::GCNullEntity(void *ptr) {
    m_ptr = ptr;
}
void* GCNullEntity::GetPtr() {
    return m_ptr;
}
std::string GCNullEntity::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCNullEntity::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseEntity GCNullEntity::GetParent() const {
    GCBaseEntity value(m_ptr);
    return value;
}
void GCNullEntity::SetParent(GCBaseEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCNullEntity(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCNullEntity>("CNullEntity")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCNullEntity::GetParent, &GCNullEntity::SetParent)
        .addFunction("ToPtr", &GCNullEntity::ToPtr)
        .addFunction("IsValid", &GCNullEntity::IsValid)
        .endClass();
}
GCCSPointScriptExtensions_observer::GCCSPointScriptExtensions_observer(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCCSPointScriptExtensions_observer::GCCSPointScriptExtensions_observer(void *ptr) {
    m_ptr = ptr;
}
void* GCCSPointScriptExtensions_observer::GetPtr() {
    return m_ptr;
}
std::string GCCSPointScriptExtensions_observer::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCCSPointScriptExtensions_observer::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCCSPointScriptExtensions_observer(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCCSPointScriptExtensions_observer>("CCSPointScriptExtensions_observer")
        .addConstructor<void (*)(std::string)>()
        .addFunction("ToPtr", &GCCSPointScriptExtensions_observer::ToPtr)
        .addFunction("IsValid", &GCCSPointScriptExtensions_observer::IsValid)
        .endClass();
}
GCMarkupVolumeTagged::GCMarkupVolumeTagged(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCMarkupVolumeTagged::GCMarkupVolumeTagged(void *ptr) {
    m_ptr = ptr;
}
bool GCMarkupVolumeTagged::GetIsGroup() const {
    return GetSchemaValue<bool>(m_ptr, "CMarkupVolumeTagged", "m_bIsGroup");
}
void GCMarkupVolumeTagged::SetIsGroup(bool value) {
    SetSchemaValue(m_ptr, "CMarkupVolumeTagged", "m_bIsGroup", false, value);
}
bool GCMarkupVolumeTagged::GetGroupByPrefab() const {
    return GetSchemaValue<bool>(m_ptr, "CMarkupVolumeTagged", "m_bGroupByPrefab");
}
void GCMarkupVolumeTagged::SetGroupByPrefab(bool value) {
    SetSchemaValue(m_ptr, "CMarkupVolumeTagged", "m_bGroupByPrefab", false, value);
}
bool GCMarkupVolumeTagged::GetGroupByVolume() const {
    return GetSchemaValue<bool>(m_ptr, "CMarkupVolumeTagged", "m_bGroupByVolume");
}
void GCMarkupVolumeTagged::SetGroupByVolume(bool value) {
    SetSchemaValue(m_ptr, "CMarkupVolumeTagged", "m_bGroupByVolume", false, value);
}
bool GCMarkupVolumeTagged::GetGroupOtherGroups() const {
    return GetSchemaValue<bool>(m_ptr, "CMarkupVolumeTagged", "m_bGroupOtherGroups");
}
void GCMarkupVolumeTagged::SetGroupOtherGroups(bool value) {
    SetSchemaValue(m_ptr, "CMarkupVolumeTagged", "m_bGroupOtherGroups", false, value);
}
bool GCMarkupVolumeTagged::GetIsInGroup() const {
    return GetSchemaValue<bool>(m_ptr, "CMarkupVolumeTagged", "m_bIsInGroup");
}
void GCMarkupVolumeTagged::SetIsInGroup(bool value) {
    SetSchemaValue(m_ptr, "CMarkupVolumeTagged", "m_bIsInGroup", false, value);
}
void* GCMarkupVolumeTagged::GetPtr() {
    return m_ptr;
}
std::string GCMarkupVolumeTagged::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCMarkupVolumeTagged::IsValid() {
    return (m_ptr != nullptr);
}
GCMarkupVolume GCMarkupVolumeTagged::GetParent() const {
    GCMarkupVolume value(m_ptr);
    return value;
}
void GCMarkupVolumeTagged::SetParent(GCMarkupVolume value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCMarkupVolumeTagged(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCMarkupVolumeTagged>("CMarkupVolumeTagged")
        .addConstructor<void (*)(std::string)>()
        .addProperty("IsGroup", &GCMarkupVolumeTagged::GetIsGroup, &GCMarkupVolumeTagged::SetIsGroup)
        .addProperty("GroupByPrefab", &GCMarkupVolumeTagged::GetGroupByPrefab, &GCMarkupVolumeTagged::SetGroupByPrefab)
        .addProperty("GroupByVolume", &GCMarkupVolumeTagged::GetGroupByVolume, &GCMarkupVolumeTagged::SetGroupByVolume)
        .addProperty("GroupOtherGroups", &GCMarkupVolumeTagged::GetGroupOtherGroups, &GCMarkupVolumeTagged::SetGroupOtherGroups)
        .addProperty("IsInGroup", &GCMarkupVolumeTagged::GetIsInGroup, &GCMarkupVolumeTagged::SetIsInGroup)
        .addProperty("Parent", &GCMarkupVolumeTagged::GetParent, &GCMarkupVolumeTagged::SetParent)
        .addFunction("ToPtr", &GCMarkupVolumeTagged::ToPtr)
        .addFunction("IsValid", &GCMarkupVolumeTagged::IsValid)
        .endClass();
}
GCBuyZone::GCBuyZone(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCBuyZone::GCBuyZone(void *ptr) {
    m_ptr = ptr;
}
int32_t GCBuyZone::GetLegacyTeamNum() const {
    return GetSchemaValue<int32_t>(m_ptr, "CBuyZone", "m_LegacyTeamNum");
}
void GCBuyZone::SetLegacyTeamNum(int32_t value) {
    SetSchemaValue(m_ptr, "CBuyZone", "m_LegacyTeamNum", false, value);
}
void* GCBuyZone::GetPtr() {
    return m_ptr;
}
std::string GCBuyZone::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCBuyZone::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseTrigger GCBuyZone::GetParent() const {
    GCBaseTrigger value(m_ptr);
    return value;
}
void GCBuyZone::SetParent(GCBaseTrigger value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCBuyZone(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCBuyZone>("CBuyZone")
        .addConstructor<void (*)(std::string)>()
        .addProperty("LegacyTeamNum", &GCBuyZone::GetLegacyTeamNum, &GCBuyZone::SetLegacyTeamNum)
        .addProperty("Parent", &GCBuyZone::GetParent, &GCBuyZone::SetParent)
        .addFunction("ToPtr", &GCBuyZone::ToPtr)
        .addFunction("IsValid", &GCBuyZone::IsValid)
        .endClass();
}
GCPointTemplate::GCPointTemplate(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCPointTemplate::GCPointTemplate(void *ptr) {
    m_ptr = ptr;
}
std::string GCPointTemplate::GetWorldName() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CPointTemplate", "m_iszWorldName").String();
}
void GCPointTemplate::SetWorldName(std::string value) {
    SetSchemaValue(m_ptr, "CPointTemplate", "m_iszWorldName", false, CUtlSymbolLarge(value.c_str()));
}
std::string GCPointTemplate::GetSource2EntityLumpName() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CPointTemplate", "m_iszSource2EntityLumpName").String();
}
void GCPointTemplate::SetSource2EntityLumpName(std::string value) {
    SetSchemaValue(m_ptr, "CPointTemplate", "m_iszSource2EntityLumpName", false, CUtlSymbolLarge(value.c_str()));
}
std::string GCPointTemplate::GetEntityFilterName() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CPointTemplate", "m_iszEntityFilterName").String();
}
void GCPointTemplate::SetEntityFilterName(std::string value) {
    SetSchemaValue(m_ptr, "CPointTemplate", "m_iszEntityFilterName", false, CUtlSymbolLarge(value.c_str()));
}
float GCPointTemplate::GetTimeoutInterval() const {
    return GetSchemaValue<float>(m_ptr, "CPointTemplate", "m_flTimeoutInterval");
}
void GCPointTemplate::SetTimeoutInterval(float value) {
    SetSchemaValue(m_ptr, "CPointTemplate", "m_flTimeoutInterval", false, value);
}
bool GCPointTemplate::GetAsynchronouslySpawnEntities() const {
    return GetSchemaValue<bool>(m_ptr, "CPointTemplate", "m_bAsynchronouslySpawnEntities");
}
void GCPointTemplate::SetAsynchronouslySpawnEntities(bool value) {
    SetSchemaValue(m_ptr, "CPointTemplate", "m_bAsynchronouslySpawnEntities", false, value);
}
GCEntityIOOutput GCPointTemplate::GetOutputOnSpawned() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CPointTemplate", "m_pOutputOnSpawned"));
    return value;
}
void GCPointTemplate::SetOutputOnSpawned(GCEntityIOOutput value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'OutputOnSpawned' is not possible.\n");
}
uint64_t GCPointTemplate::GetClientOnlyEntityBehavior() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CPointTemplate", "m_clientOnlyEntityBehavior");
}
void GCPointTemplate::SetClientOnlyEntityBehavior(uint64_t value) {
    SetSchemaValue(m_ptr, "CPointTemplate", "m_clientOnlyEntityBehavior", false, value);
}
uint64_t GCPointTemplate::GetOwnerSpawnGroupType() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CPointTemplate", "m_ownerSpawnGroupType");
}
void GCPointTemplate::SetOwnerSpawnGroupType(uint64_t value) {
    SetSchemaValue(m_ptr, "CPointTemplate", "m_ownerSpawnGroupType", false, value);
}
std::vector<uint32> GCPointTemplate::GetCreatedSpawnGroupHandles() const {
    CUtlVector<uint32>* vec = GetSchemaValue<CUtlVector<uint32>*>(m_ptr, "CPointTemplate", "m_createdSpawnGroupHandles"); std::vector<uint32> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCPointTemplate::SetCreatedSpawnGroupHandles(std::vector<uint32> value) {
    SetSchemaValueCUtlVector<uint32>(m_ptr, "CPointTemplate", "m_createdSpawnGroupHandles", false, value);
}
std::vector<GCEntityInstance> GCPointTemplate::GetSpawnedEntityHandles() const {
    CUtlVector<CHandle<CEntityInstance>>* vec = GetSchemaValue<CUtlVector<CHandle<CEntityInstance>>*>(m_ptr, "CPointTemplate", "m_SpawnedEntityHandles"); 
    std::vector<GCEntityInstance> outVec; 
    for(int i = 0; i < vec->Count(); i++) { 
        outVec.push_back(GCEntityInstance((void*)(vec->Element(i).Get()))); 
    } 
    return outVec;
}
void GCPointTemplate::SetSpawnedEntityHandles(std::vector<GCEntityInstance> value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'SpawnedEntityHandles' is not possible.\n");
}
void* GCPointTemplate::GetPtr() {
    return m_ptr;
}
std::string GCPointTemplate::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCPointTemplate::IsValid() {
    return (m_ptr != nullptr);
}
GCLogicalEntity GCPointTemplate::GetParent() const {
    GCLogicalEntity value(m_ptr);
    return value;
}
void GCPointTemplate::SetParent(GCLogicalEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCPointTemplate(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCPointTemplate>("CPointTemplate")
        .addConstructor<void (*)(std::string)>()
        .addProperty("WorldName", &GCPointTemplate::GetWorldName, &GCPointTemplate::SetWorldName)
        .addProperty("Source2EntityLumpName", &GCPointTemplate::GetSource2EntityLumpName, &GCPointTemplate::SetSource2EntityLumpName)
        .addProperty("EntityFilterName", &GCPointTemplate::GetEntityFilterName, &GCPointTemplate::SetEntityFilterName)
        .addProperty("TimeoutInterval", &GCPointTemplate::GetTimeoutInterval, &GCPointTemplate::SetTimeoutInterval)
        .addProperty("AsynchronouslySpawnEntities", &GCPointTemplate::GetAsynchronouslySpawnEntities, &GCPointTemplate::SetAsynchronouslySpawnEntities)
        .addProperty("OutputOnSpawned", &GCPointTemplate::GetOutputOnSpawned, &GCPointTemplate::SetOutputOnSpawned)
        .addProperty("ClientOnlyEntityBehavior", &GCPointTemplate::GetClientOnlyEntityBehavior, &GCPointTemplate::SetClientOnlyEntityBehavior)
        .addProperty("OwnerSpawnGroupType", &GCPointTemplate::GetOwnerSpawnGroupType, &GCPointTemplate::SetOwnerSpawnGroupType)
        .addProperty("CreatedSpawnGroupHandles", &GCPointTemplate::GetCreatedSpawnGroupHandles, &GCPointTemplate::SetCreatedSpawnGroupHandles)
        .addProperty("SpawnedEntityHandles", &GCPointTemplate::GetSpawnedEntityHandles, &GCPointTemplate::SetSpawnedEntityHandles)
        .addProperty("Parent", &GCPointTemplate::GetParent, &GCPointTemplate::SetParent)
        .addFunction("ToPtr", &GCPointTemplate::ToPtr)
        .addFunction("IsValid", &GCPointTemplate::IsValid)
        .endClass();
}
GCTripWireFire::GCTripWireFire(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCTripWireFire::GCTripWireFire(void *ptr) {
    m_ptr = ptr;
}
void* GCTripWireFire::GetPtr() {
    return m_ptr;
}
std::string GCTripWireFire::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCTripWireFire::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseCSGrenade GCTripWireFire::GetParent() const {
    GCBaseCSGrenade value(m_ptr);
    return value;
}
void GCTripWireFire::SetParent(GCBaseCSGrenade value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCTripWireFire(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCTripWireFire>("CTripWireFire")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCTripWireFire::GetParent, &GCTripWireFire::SetParent)
        .addFunction("ToPtr", &GCTripWireFire::ToPtr)
        .addFunction("IsValid", &GCTripWireFire::IsValid)
        .endClass();
}
GCPhysForce::GCPhysForce(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCPhysForce::GCPhysForce(void *ptr) {
    m_ptr = ptr;
}
std::string GCPhysForce::GetNameAttach() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CPhysForce", "m_nameAttach").String();
}
void GCPhysForce::SetNameAttach(std::string value) {
    SetSchemaValue(m_ptr, "CPhysForce", "m_nameAttach", false, CUtlSymbolLarge(value.c_str()));
}
float GCPhysForce::GetForce() const {
    return GetSchemaValue<float>(m_ptr, "CPhysForce", "m_force");
}
void GCPhysForce::SetForce(float value) {
    SetSchemaValue(m_ptr, "CPhysForce", "m_force", false, value);
}
float GCPhysForce::GetForceTime() const {
    return GetSchemaValue<float>(m_ptr, "CPhysForce", "m_forceTime");
}
void GCPhysForce::SetForceTime(float value) {
    SetSchemaValue(m_ptr, "CPhysForce", "m_forceTime", false, value);
}
GCBaseEntity GCPhysForce::GetAttachedObject() const {
    GCBaseEntity value((void*)(GetSchemaValue<CHandle<CEntityInstance>>(m_ptr, "CPhysForce", "m_attachedObject").Get()));
    return value;
}
void GCPhysForce::SetAttachedObject(GCBaseEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'AttachedObject' is not possible.\n");
}
bool GCPhysForce::GetWasRestored() const {
    return GetSchemaValue<bool>(m_ptr, "CPhysForce", "m_wasRestored");
}
void GCPhysForce::SetWasRestored(bool value) {
    SetSchemaValue(m_ptr, "CPhysForce", "m_wasRestored", false, value);
}
GCConstantForceController GCPhysForce::GetIntegrator() const {
    GCConstantForceController value(GetSchemaPtr(m_ptr, "CPhysForce", "m_integrator"));
    return value;
}
void GCPhysForce::SetIntegrator(GCConstantForceController value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Integrator' is not possible.\n");
}
void* GCPhysForce::GetPtr() {
    return m_ptr;
}
std::string GCPhysForce::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCPhysForce::IsValid() {
    return (m_ptr != nullptr);
}
GCPointEntity GCPhysForce::GetParent() const {
    GCPointEntity value(m_ptr);
    return value;
}
void GCPhysForce::SetParent(GCPointEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCPhysForce(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCPhysForce>("CPhysForce")
        .addConstructor<void (*)(std::string)>()
        .addProperty("NameAttach", &GCPhysForce::GetNameAttach, &GCPhysForce::SetNameAttach)
        .addProperty("Force", &GCPhysForce::GetForce, &GCPhysForce::SetForce)
        .addProperty("ForceTime", &GCPhysForce::GetForceTime, &GCPhysForce::SetForceTime)
        .addProperty("AttachedObject", &GCPhysForce::GetAttachedObject, &GCPhysForce::SetAttachedObject)
        .addProperty("WasRestored", &GCPhysForce::GetWasRestored, &GCPhysForce::SetWasRestored)
        .addProperty("Integrator", &GCPhysForce::GetIntegrator, &GCPhysForce::SetIntegrator)
        .addProperty("Parent", &GCPhysForce::GetParent, &GCPhysForce::SetParent)
        .addFunction("ToPtr", &GCPhysForce::ToPtr)
        .addFunction("IsValid", &GCPhysForce::IsValid)
        .endClass();
}
GCLogicDistanceAutosave::GCLogicDistanceAutosave(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCLogicDistanceAutosave::GCLogicDistanceAutosave(void *ptr) {
    m_ptr = ptr;
}
std::string GCLogicDistanceAutosave::GetTargetEntity() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CLogicDistanceAutosave", "m_iszTargetEntity").String();
}
void GCLogicDistanceAutosave::SetTargetEntity(std::string value) {
    SetSchemaValue(m_ptr, "CLogicDistanceAutosave", "m_iszTargetEntity", false, CUtlSymbolLarge(value.c_str()));
}
float GCLogicDistanceAutosave::GetDistanceToPlayer() const {
    return GetSchemaValue<float>(m_ptr, "CLogicDistanceAutosave", "m_flDistanceToPlayer");
}
void GCLogicDistanceAutosave::SetDistanceToPlayer(float value) {
    SetSchemaValue(m_ptr, "CLogicDistanceAutosave", "m_flDistanceToPlayer", false, value);
}
bool GCLogicDistanceAutosave::GetForceNewLevelUnit() const {
    return GetSchemaValue<bool>(m_ptr, "CLogicDistanceAutosave", "m_bForceNewLevelUnit");
}
void GCLogicDistanceAutosave::SetForceNewLevelUnit(bool value) {
    SetSchemaValue(m_ptr, "CLogicDistanceAutosave", "m_bForceNewLevelUnit", false, value);
}
bool GCLogicDistanceAutosave::GetCheckCough() const {
    return GetSchemaValue<bool>(m_ptr, "CLogicDistanceAutosave", "m_bCheckCough");
}
void GCLogicDistanceAutosave::SetCheckCough(bool value) {
    SetSchemaValue(m_ptr, "CLogicDistanceAutosave", "m_bCheckCough", false, value);
}
bool GCLogicDistanceAutosave::GetThinkDangerous() const {
    return GetSchemaValue<bool>(m_ptr, "CLogicDistanceAutosave", "m_bThinkDangerous");
}
void GCLogicDistanceAutosave::SetThinkDangerous(bool value) {
    SetSchemaValue(m_ptr, "CLogicDistanceAutosave", "m_bThinkDangerous", false, value);
}
float GCLogicDistanceAutosave::GetDangerousTime() const {
    return GetSchemaValue<float>(m_ptr, "CLogicDistanceAutosave", "m_flDangerousTime");
}
void GCLogicDistanceAutosave::SetDangerousTime(float value) {
    SetSchemaValue(m_ptr, "CLogicDistanceAutosave", "m_flDangerousTime", false, value);
}
void* GCLogicDistanceAutosave::GetPtr() {
    return m_ptr;
}
std::string GCLogicDistanceAutosave::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCLogicDistanceAutosave::IsValid() {
    return (m_ptr != nullptr);
}
GCLogicalEntity GCLogicDistanceAutosave::GetParent() const {
    GCLogicalEntity value(m_ptr);
    return value;
}
void GCLogicDistanceAutosave::SetParent(GCLogicalEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCLogicDistanceAutosave(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCLogicDistanceAutosave>("CLogicDistanceAutosave")
        .addConstructor<void (*)(std::string)>()
        .addProperty("TargetEntity", &GCLogicDistanceAutosave::GetTargetEntity, &GCLogicDistanceAutosave::SetTargetEntity)
        .addProperty("DistanceToPlayer", &GCLogicDistanceAutosave::GetDistanceToPlayer, &GCLogicDistanceAutosave::SetDistanceToPlayer)
        .addProperty("ForceNewLevelUnit", &GCLogicDistanceAutosave::GetForceNewLevelUnit, &GCLogicDistanceAutosave::SetForceNewLevelUnit)
        .addProperty("CheckCough", &GCLogicDistanceAutosave::GetCheckCough, &GCLogicDistanceAutosave::SetCheckCough)
        .addProperty("ThinkDangerous", &GCLogicDistanceAutosave::GetThinkDangerous, &GCLogicDistanceAutosave::SetThinkDangerous)
        .addProperty("DangerousTime", &GCLogicDistanceAutosave::GetDangerousTime, &GCLogicDistanceAutosave::SetDangerousTime)
        .addProperty("Parent", &GCLogicDistanceAutosave::GetParent, &GCLogicDistanceAutosave::SetParent)
        .addFunction("ToPtr", &GCLogicDistanceAutosave::ToPtr)
        .addFunction("IsValid", &GCLogicDistanceAutosave::IsValid)
        .endClass();
}
GCInfoDynamicShadowHint::GCInfoDynamicShadowHint(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCInfoDynamicShadowHint::GCInfoDynamicShadowHint(void *ptr) {
    m_ptr = ptr;
}
bool GCInfoDynamicShadowHint::GetDisabled() const {
    return GetSchemaValue<bool>(m_ptr, "CInfoDynamicShadowHint", "m_bDisabled");
}
void GCInfoDynamicShadowHint::SetDisabled(bool value) {
    SetSchemaValue(m_ptr, "CInfoDynamicShadowHint", "m_bDisabled", false, value);
}
float GCInfoDynamicShadowHint::GetRange() const {
    return GetSchemaValue<float>(m_ptr, "CInfoDynamicShadowHint", "m_flRange");
}
void GCInfoDynamicShadowHint::SetRange(float value) {
    SetSchemaValue(m_ptr, "CInfoDynamicShadowHint", "m_flRange", false, value);
}
int32_t GCInfoDynamicShadowHint::GetImportance() const {
    return GetSchemaValue<int32_t>(m_ptr, "CInfoDynamicShadowHint", "m_nImportance");
}
void GCInfoDynamicShadowHint::SetImportance(int32_t value) {
    SetSchemaValue(m_ptr, "CInfoDynamicShadowHint", "m_nImportance", false, value);
}
int32_t GCInfoDynamicShadowHint::GetLightChoice() const {
    return GetSchemaValue<int32_t>(m_ptr, "CInfoDynamicShadowHint", "m_nLightChoice");
}
void GCInfoDynamicShadowHint::SetLightChoice(int32_t value) {
    SetSchemaValue(m_ptr, "CInfoDynamicShadowHint", "m_nLightChoice", false, value);
}
GCBaseEntity GCInfoDynamicShadowHint::GetLight() const {
    GCBaseEntity value((void*)(GetSchemaValue<CHandle<CEntityInstance>>(m_ptr, "CInfoDynamicShadowHint", "m_hLight").Get()));
    return value;
}
void GCInfoDynamicShadowHint::SetLight(GCBaseEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Light' is not possible.\n");
}
void* GCInfoDynamicShadowHint::GetPtr() {
    return m_ptr;
}
std::string GCInfoDynamicShadowHint::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCInfoDynamicShadowHint::IsValid() {
    return (m_ptr != nullptr);
}
GCPointEntity GCInfoDynamicShadowHint::GetParent() const {
    GCPointEntity value(m_ptr);
    return value;
}
void GCInfoDynamicShadowHint::SetParent(GCPointEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCInfoDynamicShadowHint(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCInfoDynamicShadowHint>("CInfoDynamicShadowHint")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Disabled", &GCInfoDynamicShadowHint::GetDisabled, &GCInfoDynamicShadowHint::SetDisabled)
        .addProperty("Range", &GCInfoDynamicShadowHint::GetRange, &GCInfoDynamicShadowHint::SetRange)
        .addProperty("Importance", &GCInfoDynamicShadowHint::GetImportance, &GCInfoDynamicShadowHint::SetImportance)
        .addProperty("LightChoice", &GCInfoDynamicShadowHint::GetLightChoice, &GCInfoDynamicShadowHint::SetLightChoice)
        .addProperty("Light", &GCInfoDynamicShadowHint::GetLight, &GCInfoDynamicShadowHint::SetLight)
        .addProperty("Parent", &GCInfoDynamicShadowHint::GetParent, &GCInfoDynamicShadowHint::SetParent)
        .addFunction("ToPtr", &GCInfoDynamicShadowHint::ToPtr)
        .addFunction("IsValid", &GCInfoDynamicShadowHint::IsValid)
        .endClass();
}
GCSoundOpvarSetOBBEntity::GCSoundOpvarSetOBBEntity(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCSoundOpvarSetOBBEntity::GCSoundOpvarSetOBBEntity(void *ptr) {
    m_ptr = ptr;
}
void* GCSoundOpvarSetOBBEntity::GetPtr() {
    return m_ptr;
}
std::string GCSoundOpvarSetOBBEntity::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCSoundOpvarSetOBBEntity::IsValid() {
    return (m_ptr != nullptr);
}
GCSoundOpvarSetAABBEntity GCSoundOpvarSetOBBEntity::GetParent() const {
    GCSoundOpvarSetAABBEntity value(m_ptr);
    return value;
}
void GCSoundOpvarSetOBBEntity::SetParent(GCSoundOpvarSetAABBEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCSoundOpvarSetOBBEntity(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCSoundOpvarSetOBBEntity>("CSoundOpvarSetOBBEntity")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCSoundOpvarSetOBBEntity::GetParent, &GCSoundOpvarSetOBBEntity::SetParent)
        .addFunction("ToPtr", &GCSoundOpvarSetOBBEntity::ToPtr)
        .addFunction("IsValid", &GCSoundOpvarSetOBBEntity::IsValid)
        .endClass();
}
GCEnvWindShared__WindVariationEvent_t::GCEnvWindShared__WindVariationEvent_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCEnvWindShared__WindVariationEvent_t::GCEnvWindShared__WindVariationEvent_t(void *ptr) {
    m_ptr = ptr;
}
float GCEnvWindShared__WindVariationEvent_t::GetWindAngleVariation() const {
    return GetSchemaValue<float>(m_ptr, "CEnvWindShared__WindVariationEvent_t", "m_flWindAngleVariation");
}
void GCEnvWindShared__WindVariationEvent_t::SetWindAngleVariation(float value) {
    SetSchemaValue(m_ptr, "CEnvWindShared__WindVariationEvent_t", "m_flWindAngleVariation", true, value);
}
float GCEnvWindShared__WindVariationEvent_t::GetWindSpeedVariation() const {
    return GetSchemaValue<float>(m_ptr, "CEnvWindShared__WindVariationEvent_t", "m_flWindSpeedVariation");
}
void GCEnvWindShared__WindVariationEvent_t::SetWindSpeedVariation(float value) {
    SetSchemaValue(m_ptr, "CEnvWindShared__WindVariationEvent_t", "m_flWindSpeedVariation", true, value);
}
void* GCEnvWindShared__WindVariationEvent_t::GetPtr() {
    return m_ptr;
}
std::string GCEnvWindShared__WindVariationEvent_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCEnvWindShared__WindVariationEvent_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCEnvWindShared__WindVariationEvent_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCEnvWindShared__WindVariationEvent_t>("CEnvWindShared__WindVariationEvent_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("WindAngleVariation", &GCEnvWindShared__WindVariationEvent_t::GetWindAngleVariation, &GCEnvWindShared__WindVariationEvent_t::SetWindAngleVariation)
        .addProperty("WindSpeedVariation", &GCEnvWindShared__WindVariationEvent_t::GetWindSpeedVariation, &GCEnvWindShared__WindVariationEvent_t::SetWindSpeedVariation)
        .addFunction("ToPtr", &GCEnvWindShared__WindVariationEvent_t::ToPtr)
        .addFunction("IsValid", &GCEnvWindShared__WindVariationEvent_t::IsValid)
        .endClass();
}
GCTakeDamageInfoAPI::GCTakeDamageInfoAPI(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCTakeDamageInfoAPI::GCTakeDamageInfoAPI(void *ptr) {
    m_ptr = ptr;
}
void* GCTakeDamageInfoAPI::GetPtr() {
    return m_ptr;
}
std::string GCTakeDamageInfoAPI::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCTakeDamageInfoAPI::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCTakeDamageInfoAPI(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCTakeDamageInfoAPI>("CTakeDamageInfoAPI")
        .addConstructor<void (*)(std::string)>()
        .addFunction("ToPtr", &GCTakeDamageInfoAPI::ToPtr)
        .addFunction("IsValid", &GCTakeDamageInfoAPI::IsValid)
        .endClass();
}
GCScriptTriggerOnce::GCScriptTriggerOnce(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCScriptTriggerOnce::GCScriptTriggerOnce(void *ptr) {
    m_ptr = ptr;
}
Vector GCScriptTriggerOnce::GetExtent() const {
    return GetSchemaValue<Vector>(m_ptr, "CScriptTriggerOnce", "m_vExtent");
}
void GCScriptTriggerOnce::SetExtent(Vector value) {
    SetSchemaValue(m_ptr, "CScriptTriggerOnce", "m_vExtent", false, value);
}
void* GCScriptTriggerOnce::GetPtr() {
    return m_ptr;
}
std::string GCScriptTriggerOnce::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCScriptTriggerOnce::IsValid() {
    return (m_ptr != nullptr);
}
GCTriggerOnce GCScriptTriggerOnce::GetParent() const {
    GCTriggerOnce value(m_ptr);
    return value;
}
void GCScriptTriggerOnce::SetParent(GCTriggerOnce value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCScriptTriggerOnce(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCScriptTriggerOnce>("CScriptTriggerOnce")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Extent", &GCScriptTriggerOnce::GetExtent, &GCScriptTriggerOnce::SetExtent)
        .addProperty("Parent", &GCScriptTriggerOnce::GetParent, &GCScriptTriggerOnce::SetParent)
        .addFunction("ToPtr", &GCScriptTriggerOnce::ToPtr)
        .addFunction("IsValid", &GCScriptTriggerOnce::IsValid)
        .endClass();
}
GCNavWalkable::GCNavWalkable(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCNavWalkable::GCNavWalkable(void *ptr) {
    m_ptr = ptr;
}
void* GCNavWalkable::GetPtr() {
    return m_ptr;
}
std::string GCNavWalkable::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCNavWalkable::IsValid() {
    return (m_ptr != nullptr);
}
GCPointEntity GCNavWalkable::GetParent() const {
    GCPointEntity value(m_ptr);
    return value;
}
void GCNavWalkable::SetParent(GCPointEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCNavWalkable(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCNavWalkable>("CNavWalkable")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCNavWalkable::GetParent, &GCNavWalkable::SetParent)
        .addFunction("ToPtr", &GCNavWalkable::ToPtr)
        .addFunction("IsValid", &GCNavWalkable::IsValid)
        .endClass();
}
GCFuncMonitor::GCFuncMonitor(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCFuncMonitor::GCFuncMonitor(void *ptr) {
    m_ptr = ptr;
}
std::string GCFuncMonitor::GetTargetCamera() const {
    return GetSchemaValue<CUtlString>(m_ptr, "CFuncMonitor", "m_targetCamera").Get();
}
void GCFuncMonitor::SetTargetCamera(std::string value) {
    SetSchemaValue(m_ptr, "CFuncMonitor", "m_targetCamera", false, CUtlString(value.c_str()));
}
int32_t GCFuncMonitor::GetResolutionEnum() const {
    return GetSchemaValue<int32_t>(m_ptr, "CFuncMonitor", "m_nResolutionEnum");
}
void GCFuncMonitor::SetResolutionEnum(int32_t value) {
    SetSchemaValue(m_ptr, "CFuncMonitor", "m_nResolutionEnum", false, value);
}
bool GCFuncMonitor::GetRenderShadows() const {
    return GetSchemaValue<bool>(m_ptr, "CFuncMonitor", "m_bRenderShadows");
}
void GCFuncMonitor::SetRenderShadows(bool value) {
    SetSchemaValue(m_ptr, "CFuncMonitor", "m_bRenderShadows", false, value);
}
bool GCFuncMonitor::GetUseUniqueColorTarget() const {
    return GetSchemaValue<bool>(m_ptr, "CFuncMonitor", "m_bUseUniqueColorTarget");
}
void GCFuncMonitor::SetUseUniqueColorTarget(bool value) {
    SetSchemaValue(m_ptr, "CFuncMonitor", "m_bUseUniqueColorTarget", false, value);
}
std::string GCFuncMonitor::GetBrushModelName() const {
    return GetSchemaValue<CUtlString>(m_ptr, "CFuncMonitor", "m_brushModelName").Get();
}
void GCFuncMonitor::SetBrushModelName(std::string value) {
    SetSchemaValue(m_ptr, "CFuncMonitor", "m_brushModelName", false, CUtlString(value.c_str()));
}
GCBaseEntity GCFuncMonitor::GetTargetCamera1() const {
    GCBaseEntity value((void*)(GetSchemaValue<CHandle<CEntityInstance>>(m_ptr, "CFuncMonitor", "m_hTargetCamera").Get()));
    return value;
}
void GCFuncMonitor::SetTargetCamera1(GCBaseEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'TargetCamera1' is not possible.\n");
}
bool GCFuncMonitor::GetEnabled() const {
    return GetSchemaValue<bool>(m_ptr, "CFuncMonitor", "m_bEnabled");
}
void GCFuncMonitor::SetEnabled(bool value) {
    SetSchemaValue(m_ptr, "CFuncMonitor", "m_bEnabled", false, value);
}
bool GCFuncMonitor::GetDraw3DSkybox() const {
    return GetSchemaValue<bool>(m_ptr, "CFuncMonitor", "m_bDraw3DSkybox");
}
void GCFuncMonitor::SetDraw3DSkybox(bool value) {
    SetSchemaValue(m_ptr, "CFuncMonitor", "m_bDraw3DSkybox", false, value);
}
bool GCFuncMonitor::GetStartEnabled() const {
    return GetSchemaValue<bool>(m_ptr, "CFuncMonitor", "m_bStartEnabled");
}
void GCFuncMonitor::SetStartEnabled(bool value) {
    SetSchemaValue(m_ptr, "CFuncMonitor", "m_bStartEnabled", false, value);
}
void* GCFuncMonitor::GetPtr() {
    return m_ptr;
}
std::string GCFuncMonitor::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCFuncMonitor::IsValid() {
    return (m_ptr != nullptr);
}
GCFuncBrush GCFuncMonitor::GetParent() const {
    GCFuncBrush value(m_ptr);
    return value;
}
void GCFuncMonitor::SetParent(GCFuncBrush value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCFuncMonitor(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCFuncMonitor>("CFuncMonitor")
        .addConstructor<void (*)(std::string)>()
        .addProperty("TargetCamera", &GCFuncMonitor::GetTargetCamera, &GCFuncMonitor::SetTargetCamera)
        .addProperty("ResolutionEnum", &GCFuncMonitor::GetResolutionEnum, &GCFuncMonitor::SetResolutionEnum)
        .addProperty("RenderShadows", &GCFuncMonitor::GetRenderShadows, &GCFuncMonitor::SetRenderShadows)
        .addProperty("UseUniqueColorTarget", &GCFuncMonitor::GetUseUniqueColorTarget, &GCFuncMonitor::SetUseUniqueColorTarget)
        .addProperty("BrushModelName", &GCFuncMonitor::GetBrushModelName, &GCFuncMonitor::SetBrushModelName)
        .addProperty("TargetCamera1", &GCFuncMonitor::GetTargetCamera1, &GCFuncMonitor::SetTargetCamera1)
        .addProperty("Enabled", &GCFuncMonitor::GetEnabled, &GCFuncMonitor::SetEnabled)
        .addProperty("Draw3DSkybox", &GCFuncMonitor::GetDraw3DSkybox, &GCFuncMonitor::SetDraw3DSkybox)
        .addProperty("StartEnabled", &GCFuncMonitor::GetStartEnabled, &GCFuncMonitor::SetStartEnabled)
        .addProperty("Parent", &GCFuncMonitor::GetParent, &GCFuncMonitor::SetParent)
        .addFunction("ToPtr", &GCFuncMonitor::ToPtr)
        .addFunction("IsValid", &GCFuncMonitor::IsValid)
        .endClass();
}
GCFlashbangProjectile::GCFlashbangProjectile(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCFlashbangProjectile::GCFlashbangProjectile(void *ptr) {
    m_ptr = ptr;
}
float GCFlashbangProjectile::GetTimeToDetonate() const {
    return GetSchemaValue<float>(m_ptr, "CFlashbangProjectile", "m_flTimeToDetonate");
}
void GCFlashbangProjectile::SetTimeToDetonate(float value) {
    SetSchemaValue(m_ptr, "CFlashbangProjectile", "m_flTimeToDetonate", false, value);
}
uint32_t GCFlashbangProjectile::GetNumOpponentsHit() const {
    return GetSchemaValue<uint32_t>(m_ptr, "CFlashbangProjectile", "m_numOpponentsHit");
}
void GCFlashbangProjectile::SetNumOpponentsHit(uint32_t value) {
    SetSchemaValue(m_ptr, "CFlashbangProjectile", "m_numOpponentsHit", false, value);
}
uint32_t GCFlashbangProjectile::GetNumTeammatesHit() const {
    return GetSchemaValue<uint32_t>(m_ptr, "CFlashbangProjectile", "m_numTeammatesHit");
}
void GCFlashbangProjectile::SetNumTeammatesHit(uint32_t value) {
    SetSchemaValue(m_ptr, "CFlashbangProjectile", "m_numTeammatesHit", false, value);
}
void* GCFlashbangProjectile::GetPtr() {
    return m_ptr;
}
std::string GCFlashbangProjectile::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCFlashbangProjectile::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseCSGrenadeProjectile GCFlashbangProjectile::GetParent() const {
    GCBaseCSGrenadeProjectile value(m_ptr);
    return value;
}
void GCFlashbangProjectile::SetParent(GCBaseCSGrenadeProjectile value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCFlashbangProjectile(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCFlashbangProjectile>("CFlashbangProjectile")
        .addConstructor<void (*)(std::string)>()
        .addProperty("TimeToDetonate", &GCFlashbangProjectile::GetTimeToDetonate, &GCFlashbangProjectile::SetTimeToDetonate)
        .addProperty("NumOpponentsHit", &GCFlashbangProjectile::GetNumOpponentsHit, &GCFlashbangProjectile::SetNumOpponentsHit)
        .addProperty("NumTeammatesHit", &GCFlashbangProjectile::GetNumTeammatesHit, &GCFlashbangProjectile::SetNumTeammatesHit)
        .addProperty("Parent", &GCFlashbangProjectile::GetParent, &GCFlashbangProjectile::SetParent)
        .addFunction("ToPtr", &GCFlashbangProjectile::ToPtr)
        .addFunction("IsValid", &GCFlashbangProjectile::IsValid)
        .endClass();
}
GCPointClientUIWorldTextPanel::GCPointClientUIWorldTextPanel(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCPointClientUIWorldTextPanel::GCPointClientUIWorldTextPanel(void *ptr) {
    m_ptr = ptr;
}
std::string GCPointClientUIWorldTextPanel::GetMessageText() const {
    return GetSchemaValuePtr<char>(m_ptr, "CPointClientUIWorldTextPanel", "m_messageText");
}
void GCPointClientUIWorldTextPanel::SetMessageText(std::string value) {
    WriteSchemaPtrValue(m_ptr, "CPointClientUIWorldTextPanel", "m_messageText", false, reinterpret_cast<byte*>(const_cast<char*>(value.c_str())), 512);
}
void* GCPointClientUIWorldTextPanel::GetPtr() {
    return m_ptr;
}
std::string GCPointClientUIWorldTextPanel::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCPointClientUIWorldTextPanel::IsValid() {
    return (m_ptr != nullptr);
}
GCPointClientUIWorldPanel GCPointClientUIWorldTextPanel::GetParent() const {
    GCPointClientUIWorldPanel value(m_ptr);
    return value;
}
void GCPointClientUIWorldTextPanel::SetParent(GCPointClientUIWorldPanel value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCPointClientUIWorldTextPanel(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCPointClientUIWorldTextPanel>("CPointClientUIWorldTextPanel")
        .addConstructor<void (*)(std::string)>()
        .addProperty("MessageText", &GCPointClientUIWorldTextPanel::GetMessageText, &GCPointClientUIWorldTextPanel::SetMessageText)
        .addProperty("Parent", &GCPointClientUIWorldTextPanel::GetParent, &GCPointClientUIWorldTextPanel::SetParent)
        .addFunction("ToPtr", &GCPointClientUIWorldTextPanel::ToPtr)
        .addFunction("IsValid", &GCPointClientUIWorldTextPanel::IsValid)
        .endClass();
}
GCInfoInstructorHintTarget::GCInfoInstructorHintTarget(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCInfoInstructorHintTarget::GCInfoInstructorHintTarget(void *ptr) {
    m_ptr = ptr;
}
void* GCInfoInstructorHintTarget::GetPtr() {
    return m_ptr;
}
std::string GCInfoInstructorHintTarget::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCInfoInstructorHintTarget::IsValid() {
    return (m_ptr != nullptr);
}
GCPointEntity GCInfoInstructorHintTarget::GetParent() const {
    GCPointEntity value(m_ptr);
    return value;
}
void GCInfoInstructorHintTarget::SetParent(GCPointEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCInfoInstructorHintTarget(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCInfoInstructorHintTarget>("CInfoInstructorHintTarget")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCInfoInstructorHintTarget::GetParent, &GCInfoInstructorHintTarget::SetParent)
        .addFunction("ToPtr", &GCInfoInstructorHintTarget::ToPtr)
        .addFunction("IsValid", &GCInfoInstructorHintTarget::IsValid)
        .endClass();
}
GCCSPlayer_HostageServices::GCCSPlayer_HostageServices(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCCSPlayer_HostageServices::GCCSPlayer_HostageServices(void *ptr) {
    m_ptr = ptr;
}
GCBaseEntity GCCSPlayer_HostageServices::GetCarriedHostage() const {
    GCBaseEntity value((void*)(GetSchemaValue<CHandle<CEntityInstance>>(m_ptr, "CCSPlayer_HostageServices", "m_hCarriedHostage").Get()));
    return value;
}
void GCCSPlayer_HostageServices::SetCarriedHostage(GCBaseEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'CarriedHostage' is not possible.\n");
}
GCBaseEntity GCCSPlayer_HostageServices::GetCarriedHostageProp() const {
    GCBaseEntity value((void*)(GetSchemaValue<CHandle<CEntityInstance>>(m_ptr, "CCSPlayer_HostageServices", "m_hCarriedHostageProp").Get()));
    return value;
}
void GCCSPlayer_HostageServices::SetCarriedHostageProp(GCBaseEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'CarriedHostageProp' is not possible.\n");
}
void* GCCSPlayer_HostageServices::GetPtr() {
    return m_ptr;
}
std::string GCCSPlayer_HostageServices::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCCSPlayer_HostageServices::IsValid() {
    return (m_ptr != nullptr);
}
GCPlayerPawnComponent GCCSPlayer_HostageServices::GetParent() const {
    GCPlayerPawnComponent value(m_ptr);
    return value;
}
void GCCSPlayer_HostageServices::SetParent(GCPlayerPawnComponent value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCCSPlayer_HostageServices(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCCSPlayer_HostageServices>("CCSPlayer_HostageServices")
        .addConstructor<void (*)(std::string)>()
        .addProperty("CarriedHostage", &GCCSPlayer_HostageServices::GetCarriedHostage, &GCCSPlayer_HostageServices::SetCarriedHostage)
        .addProperty("CarriedHostageProp", &GCCSPlayer_HostageServices::GetCarriedHostageProp, &GCCSPlayer_HostageServices::SetCarriedHostageProp)
        .addProperty("Parent", &GCCSPlayer_HostageServices::GetParent, &GCCSPlayer_HostageServices::SetParent)
        .addFunction("ToPtr", &GCCSPlayer_HostageServices::ToPtr)
        .addFunction("IsValid", &GCCSPlayer_HostageServices::IsValid)
        .endClass();
}
GCWeaponSSG08::GCWeaponSSG08(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCWeaponSSG08::GCWeaponSSG08(void *ptr) {
    m_ptr = ptr;
}
void* GCWeaponSSG08::GetPtr() {
    return m_ptr;
}
std::string GCWeaponSSG08::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCWeaponSSG08::IsValid() {
    return (m_ptr != nullptr);
}
GCCSWeaponBaseGun GCWeaponSSG08::GetParent() const {
    GCCSWeaponBaseGun value(m_ptr);
    return value;
}
void GCWeaponSSG08::SetParent(GCCSWeaponBaseGun value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCWeaponSSG08(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCWeaponSSG08>("CWeaponSSG08")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCWeaponSSG08::GetParent, &GCWeaponSSG08::SetParent)
        .addFunction("ToPtr", &GCWeaponSSG08::ToPtr)
        .addFunction("IsValid", &GCWeaponSSG08::IsValid)
        .endClass();
}
GCBreachCharge::GCBreachCharge(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCBreachCharge::GCBreachCharge(void *ptr) {
    m_ptr = ptr;
}
void* GCBreachCharge::GetPtr() {
    return m_ptr;
}
std::string GCBreachCharge::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCBreachCharge::IsValid() {
    return (m_ptr != nullptr);
}
GCCSWeaponBase GCBreachCharge::GetParent() const {
    GCCSWeaponBase value(m_ptr);
    return value;
}
void GCBreachCharge::SetParent(GCCSWeaponBase value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCBreachCharge(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCBreachCharge>("CBreachCharge")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCBreachCharge::GetParent, &GCBreachCharge::SetParent)
        .addFunction("ToPtr", &GCBreachCharge::ToPtr)
        .addFunction("IsValid", &GCBreachCharge::IsValid)
        .endClass();
}
GCLogicBranch::GCLogicBranch(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCLogicBranch::GCLogicBranch(void *ptr) {
    m_ptr = ptr;
}
bool GCLogicBranch::GetInValue() const {
    return GetSchemaValue<bool>(m_ptr, "CLogicBranch", "m_bInValue");
}
void GCLogicBranch::SetInValue(bool value) {
    SetSchemaValue(m_ptr, "CLogicBranch", "m_bInValue", false, value);
}
GCEntityIOOutput GCLogicBranch::GetOnTrue() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CLogicBranch", "m_OnTrue"));
    return value;
}
void GCLogicBranch::SetOnTrue(GCEntityIOOutput value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'OnTrue' is not possible.\n");
}
GCEntityIOOutput GCLogicBranch::GetOnFalse() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CLogicBranch", "m_OnFalse"));
    return value;
}
void GCLogicBranch::SetOnFalse(GCEntityIOOutput value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'OnFalse' is not possible.\n");
}
void* GCLogicBranch::GetPtr() {
    return m_ptr;
}
std::string GCLogicBranch::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCLogicBranch::IsValid() {
    return (m_ptr != nullptr);
}
GCLogicalEntity GCLogicBranch::GetParent() const {
    GCLogicalEntity value(m_ptr);
    return value;
}
void GCLogicBranch::SetParent(GCLogicalEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCLogicBranch(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCLogicBranch>("CLogicBranch")
        .addConstructor<void (*)(std::string)>()
        .addProperty("InValue", &GCLogicBranch::GetInValue, &GCLogicBranch::SetInValue)
        .addProperty("OnTrue", &GCLogicBranch::GetOnTrue, &GCLogicBranch::SetOnTrue)
        .addProperty("OnFalse", &GCLogicBranch::GetOnFalse, &GCLogicBranch::SetOnFalse)
        .addProperty("Parent", &GCLogicBranch::GetParent, &GCLogicBranch::SetParent)
        .addFunction("ToPtr", &GCLogicBranch::ToPtr)
        .addFunction("IsValid", &GCLogicBranch::IsValid)
        .endClass();
}
GCWeaponUMP45::GCWeaponUMP45(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCWeaponUMP45::GCWeaponUMP45(void *ptr) {
    m_ptr = ptr;
}
void* GCWeaponUMP45::GetPtr() {
    return m_ptr;
}
std::string GCWeaponUMP45::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCWeaponUMP45::IsValid() {
    return (m_ptr != nullptr);
}
GCCSWeaponBaseGun GCWeaponUMP45::GetParent() const {
    GCCSWeaponBaseGun value(m_ptr);
    return value;
}
void GCWeaponUMP45::SetParent(GCCSWeaponBaseGun value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCWeaponUMP45(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCWeaponUMP45>("CWeaponUMP45")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCWeaponUMP45::GetParent, &GCWeaponUMP45::SetParent)
        .addFunction("ToPtr", &GCWeaponUMP45::ToPtr)
        .addFunction("IsValid", &GCWeaponUMP45::IsValid)
        .endClass();
}
GCSpriteAlias_env_glow::GCSpriteAlias_env_glow(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCSpriteAlias_env_glow::GCSpriteAlias_env_glow(void *ptr) {
    m_ptr = ptr;
}
void* GCSpriteAlias_env_glow::GetPtr() {
    return m_ptr;
}
std::string GCSpriteAlias_env_glow::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCSpriteAlias_env_glow::IsValid() {
    return (m_ptr != nullptr);
}
GCSprite GCSpriteAlias_env_glow::GetParent() const {
    GCSprite value(m_ptr);
    return value;
}
void GCSpriteAlias_env_glow::SetParent(GCSprite value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCSpriteAlias_env_glow(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCSpriteAlias_env_glow>("CSpriteAlias_env_glow")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCSpriteAlias_env_glow::GetParent, &GCSpriteAlias_env_glow::SetParent)
        .addFunction("ToPtr", &GCSpriteAlias_env_glow::ToPtr)
        .addFunction("IsValid", &GCSpriteAlias_env_glow::IsValid)
        .endClass();
}
GCPhysicalButton::GCPhysicalButton(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCPhysicalButton::GCPhysicalButton(void *ptr) {
    m_ptr = ptr;
}
void* GCPhysicalButton::GetPtr() {
    return m_ptr;
}
std::string GCPhysicalButton::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCPhysicalButton::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseButton GCPhysicalButton::GetParent() const {
    GCBaseButton value(m_ptr);
    return value;
}
void GCPhysicalButton::SetParent(GCBaseButton value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCPhysicalButton(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCPhysicalButton>("CPhysicalButton")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCPhysicalButton::GetParent, &GCPhysicalButton::SetParent)
        .addFunction("ToPtr", &GCPhysicalButton::ToPtr)
        .addFunction("IsValid", &GCPhysicalButton::IsValid)
        .endClass();
}
GCPhysLength::GCPhysLength(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCPhysLength::GCPhysLength(void *ptr) {
    m_ptr = ptr;
}
std::vector<Vector> GCPhysLength::GetOffset() const {
    Vector* outValue = (Vector*)GetSchemaPtr(m_ptr, "CPhysLength", "m_offset"); std::vector<Vector> ret; for(int i = 0; i < 2; i++) { ret.push_back(outValue[i]); } return ret;
}
void GCPhysLength::SetOffset(std::vector<Vector> value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Offset' is not possible.\n");
}
Vector GCPhysLength::GetAttach() const {
    return GetSchemaValue<Vector>(m_ptr, "CPhysLength", "m_vecAttach");
}
void GCPhysLength::SetAttach(Vector value) {
    SetSchemaValue(m_ptr, "CPhysLength", "m_vecAttach", false, value);
}
float GCPhysLength::GetAddLength() const {
    return GetSchemaValue<float>(m_ptr, "CPhysLength", "m_addLength");
}
void GCPhysLength::SetAddLength(float value) {
    SetSchemaValue(m_ptr, "CPhysLength", "m_addLength", false, value);
}
float GCPhysLength::GetMinLength() const {
    return GetSchemaValue<float>(m_ptr, "CPhysLength", "m_minLength");
}
void GCPhysLength::SetMinLength(float value) {
    SetSchemaValue(m_ptr, "CPhysLength", "m_minLength", false, value);
}
float GCPhysLength::GetTotalLength() const {
    return GetSchemaValue<float>(m_ptr, "CPhysLength", "m_totalLength");
}
void GCPhysLength::SetTotalLength(float value) {
    SetSchemaValue(m_ptr, "CPhysLength", "m_totalLength", false, value);
}
bool GCPhysLength::GetEnableCollision() const {
    return GetSchemaValue<bool>(m_ptr, "CPhysLength", "m_bEnableCollision");
}
void GCPhysLength::SetEnableCollision(bool value) {
    SetSchemaValue(m_ptr, "CPhysLength", "m_bEnableCollision", false, value);
}
void* GCPhysLength::GetPtr() {
    return m_ptr;
}
std::string GCPhysLength::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCPhysLength::IsValid() {
    return (m_ptr != nullptr);
}
GCPhysConstraint GCPhysLength::GetParent() const {
    GCPhysConstraint value(m_ptr);
    return value;
}
void GCPhysLength::SetParent(GCPhysConstraint value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCPhysLength(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCPhysLength>("CPhysLength")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Offset", &GCPhysLength::GetOffset, &GCPhysLength::SetOffset)
        .addProperty("Attach", &GCPhysLength::GetAttach, &GCPhysLength::SetAttach)
        .addProperty("AddLength", &GCPhysLength::GetAddLength, &GCPhysLength::SetAddLength)
        .addProperty("MinLength", &GCPhysLength::GetMinLength, &GCPhysLength::SetMinLength)
        .addProperty("TotalLength", &GCPhysLength::GetTotalLength, &GCPhysLength::SetTotalLength)
        .addProperty("EnableCollision", &GCPhysLength::GetEnableCollision, &GCPhysLength::SetEnableCollision)
        .addProperty("Parent", &GCPhysLength::GetParent, &GCPhysLength::SetParent)
        .addFunction("ToPtr", &GCPhysLength::ToPtr)
        .addFunction("IsValid", &GCPhysLength::IsValid)
        .endClass();
}
GCLogicNPCCounterOBB::GCLogicNPCCounterOBB(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCLogicNPCCounterOBB::GCLogicNPCCounterOBB(void *ptr) {
    m_ptr = ptr;
}
void* GCLogicNPCCounterOBB::GetPtr() {
    return m_ptr;
}
std::string GCLogicNPCCounterOBB::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCLogicNPCCounterOBB::IsValid() {
    return (m_ptr != nullptr);
}
GCLogicNPCCounterAABB GCLogicNPCCounterOBB::GetParent() const {
    GCLogicNPCCounterAABB value(m_ptr);
    return value;
}
void GCLogicNPCCounterOBB::SetParent(GCLogicNPCCounterAABB value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCLogicNPCCounterOBB(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCLogicNPCCounterOBB>("CLogicNPCCounterOBB")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCLogicNPCCounterOBB::GetParent, &GCLogicNPCCounterOBB::SetParent)
        .addFunction("ToPtr", &GCLogicNPCCounterOBB::ToPtr)
        .addFunction("IsValid", &GCLogicNPCCounterOBB::IsValid)
        .endClass();
}
GCCSGOViewModel::GCCSGOViewModel(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCCSGOViewModel::GCCSGOViewModel(void *ptr) {
    m_ptr = ptr;
}
bool GCCSGOViewModel::GetShouldIgnoreOffsetAndAccuracy() const {
    return GetSchemaValue<bool>(m_ptr, "CCSGOViewModel", "m_bShouldIgnoreOffsetAndAccuracy");
}
void GCCSGOViewModel::SetShouldIgnoreOffsetAndAccuracy(bool value) {
    SetSchemaValue(m_ptr, "CCSGOViewModel", "m_bShouldIgnoreOffsetAndAccuracy", false, value);
}
uint32_t GCCSGOViewModel::GetWeaponParity() const {
    return GetSchemaValue<uint32_t>(m_ptr, "CCSGOViewModel", "m_nWeaponParity");
}
void GCCSGOViewModel::SetWeaponParity(uint32_t value) {
    SetSchemaValue(m_ptr, "CCSGOViewModel", "m_nWeaponParity", false, value);
}
uint32_t GCCSGOViewModel::GetOldWeaponParity() const {
    return GetSchemaValue<uint32_t>(m_ptr, "CCSGOViewModel", "m_nOldWeaponParity");
}
void GCCSGOViewModel::SetOldWeaponParity(uint32_t value) {
    SetSchemaValue(m_ptr, "CCSGOViewModel", "m_nOldWeaponParity", false, value);
}
void* GCCSGOViewModel::GetPtr() {
    return m_ptr;
}
std::string GCCSGOViewModel::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCCSGOViewModel::IsValid() {
    return (m_ptr != nullptr);
}
GCPredictedViewModel GCCSGOViewModel::GetParent() const {
    GCPredictedViewModel value(m_ptr);
    return value;
}
void GCCSGOViewModel::SetParent(GCPredictedViewModel value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCCSGOViewModel(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCCSGOViewModel>("CCSGOViewModel")
        .addConstructor<void (*)(std::string)>()
        .addProperty("ShouldIgnoreOffsetAndAccuracy", &GCCSGOViewModel::GetShouldIgnoreOffsetAndAccuracy, &GCCSGOViewModel::SetShouldIgnoreOffsetAndAccuracy)
        .addProperty("WeaponParity", &GCCSGOViewModel::GetWeaponParity, &GCCSGOViewModel::SetWeaponParity)
        .addProperty("OldWeaponParity", &GCCSGOViewModel::GetOldWeaponParity, &GCCSGOViewModel::SetOldWeaponParity)
        .addProperty("Parent", &GCCSGOViewModel::GetParent, &GCCSGOViewModel::SetParent)
        .addFunction("ToPtr", &GCCSGOViewModel::ToPtr)
        .addFunction("IsValid", &GCCSGOViewModel::IsValid)
        .endClass();
}
GCWeaponShield::GCWeaponShield(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCWeaponShield::GCWeaponShield(void *ptr) {
    m_ptr = ptr;
}
float GCWeaponShield::GetBulletDamageAbsorbed() const {
    return GetSchemaValue<float>(m_ptr, "CWeaponShield", "m_flBulletDamageAbsorbed");
}
void GCWeaponShield::SetBulletDamageAbsorbed(float value) {
    SetSchemaValue(m_ptr, "CWeaponShield", "m_flBulletDamageAbsorbed", false, value);
}
float GCWeaponShield::GetLastBulletHitSoundTime() const {
    return GetSchemaValue<float>(m_ptr, "CWeaponShield", "m_flLastBulletHitSoundTime");
}
void GCWeaponShield::SetLastBulletHitSoundTime(float value) {
    SetSchemaValue(m_ptr, "CWeaponShield", "m_flLastBulletHitSoundTime", false, value);
}
float GCWeaponShield::GetDisplayHealth() const {
    return GetSchemaValue<float>(m_ptr, "CWeaponShield", "m_flDisplayHealth");
}
void GCWeaponShield::SetDisplayHealth(float value) {
    SetSchemaValue(m_ptr, "CWeaponShield", "m_flDisplayHealth", false, value);
}
void* GCWeaponShield::GetPtr() {
    return m_ptr;
}
std::string GCWeaponShield::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCWeaponShield::IsValid() {
    return (m_ptr != nullptr);
}
GCCSWeaponBaseGun GCWeaponShield::GetParent() const {
    GCCSWeaponBaseGun value(m_ptr);
    return value;
}
void GCWeaponShield::SetParent(GCCSWeaponBaseGun value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCWeaponShield(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCWeaponShield>("CWeaponShield")
        .addConstructor<void (*)(std::string)>()
        .addProperty("BulletDamageAbsorbed", &GCWeaponShield::GetBulletDamageAbsorbed, &GCWeaponShield::SetBulletDamageAbsorbed)
        .addProperty("LastBulletHitSoundTime", &GCWeaponShield::GetLastBulletHitSoundTime, &GCWeaponShield::SetLastBulletHitSoundTime)
        .addProperty("DisplayHealth", &GCWeaponShield::GetDisplayHealth, &GCWeaponShield::SetDisplayHealth)
        .addProperty("Parent", &GCWeaponShield::GetParent, &GCWeaponShield::SetParent)
        .addFunction("ToPtr", &GCWeaponShield::ToPtr)
        .addFunction("IsValid", &GCWeaponShield::IsValid)
        .endClass();
}
GCBlood::GCBlood(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCBlood::GCBlood(void *ptr) {
    m_ptr = ptr;
}
QAngle GCBlood::GetSprayAngles() const {
    return GetSchemaValue<QAngle>(m_ptr, "CBlood", "m_vecSprayAngles");
}
void GCBlood::SetSprayAngles(QAngle value) {
    SetSchemaValue(m_ptr, "CBlood", "m_vecSprayAngles", false, value);
}
Vector GCBlood::GetSprayDir() const {
    return GetSchemaValue<Vector>(m_ptr, "CBlood", "m_vecSprayDir");
}
void GCBlood::SetSprayDir(Vector value) {
    SetSchemaValue(m_ptr, "CBlood", "m_vecSprayDir", false, value);
}
float GCBlood::GetAmount() const {
    return GetSchemaValue<float>(m_ptr, "CBlood", "m_flAmount");
}
void GCBlood::SetAmount(float value) {
    SetSchemaValue(m_ptr, "CBlood", "m_flAmount", false, value);
}
uint64_t GCBlood::GetColor() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CBlood", "m_Color");
}
void GCBlood::SetColor(uint64_t value) {
    SetSchemaValue(m_ptr, "CBlood", "m_Color", false, value);
}
void* GCBlood::GetPtr() {
    return m_ptr;
}
std::string GCBlood::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCBlood::IsValid() {
    return (m_ptr != nullptr);
}
GCPointEntity GCBlood::GetParent() const {
    GCPointEntity value(m_ptr);
    return value;
}
void GCBlood::SetParent(GCPointEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCBlood(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCBlood>("CBlood")
        .addConstructor<void (*)(std::string)>()
        .addProperty("SprayAngles", &GCBlood::GetSprayAngles, &GCBlood::SetSprayAngles)
        .addProperty("SprayDir", &GCBlood::GetSprayDir, &GCBlood::SetSprayDir)
        .addProperty("Amount", &GCBlood::GetAmount, &GCBlood::SetAmount)
        .addProperty("Color", &GCBlood::GetColor, &GCBlood::SetColor)
        .addProperty("Parent", &GCBlood::GetParent, &GCBlood::SetParent)
        .addFunction("ToPtr", &GCBlood::ToPtr)
        .addFunction("IsValid", &GCBlood::IsValid)
        .endClass();
}
GCEnvFade::GCEnvFade(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCEnvFade::GCEnvFade(void *ptr) {
    m_ptr = ptr;
}
Color GCEnvFade::GetFadeColor() const {
    return GetSchemaValue<Color>(m_ptr, "CEnvFade", "m_fadeColor");
}
void GCEnvFade::SetFadeColor(Color value) {
    SetSchemaValue(m_ptr, "CEnvFade", "m_fadeColor", false, value);
}
float GCEnvFade::GetDuration() const {
    return GetSchemaValue<float>(m_ptr, "CEnvFade", "m_Duration");
}
void GCEnvFade::SetDuration(float value) {
    SetSchemaValue(m_ptr, "CEnvFade", "m_Duration", false, value);
}
float GCEnvFade::GetHoldDuration() const {
    return GetSchemaValue<float>(m_ptr, "CEnvFade", "m_HoldDuration");
}
void GCEnvFade::SetHoldDuration(float value) {
    SetSchemaValue(m_ptr, "CEnvFade", "m_HoldDuration", false, value);
}
GCEntityIOOutput GCEnvFade::GetOnBeginFade() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CEnvFade", "m_OnBeginFade"));
    return value;
}
void GCEnvFade::SetOnBeginFade(GCEntityIOOutput value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'OnBeginFade' is not possible.\n");
}
void* GCEnvFade::GetPtr() {
    return m_ptr;
}
std::string GCEnvFade::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCEnvFade::IsValid() {
    return (m_ptr != nullptr);
}
GCLogicalEntity GCEnvFade::GetParent() const {
    GCLogicalEntity value(m_ptr);
    return value;
}
void GCEnvFade::SetParent(GCLogicalEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCEnvFade(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCEnvFade>("CEnvFade")
        .addConstructor<void (*)(std::string)>()
        .addProperty("FadeColor", &GCEnvFade::GetFadeColor, &GCEnvFade::SetFadeColor)
        .addProperty("Duration", &GCEnvFade::GetDuration, &GCEnvFade::SetDuration)
        .addProperty("HoldDuration", &GCEnvFade::GetHoldDuration, &GCEnvFade::SetHoldDuration)
        .addProperty("OnBeginFade", &GCEnvFade::GetOnBeginFade, &GCEnvFade::SetOnBeginFade)
        .addProperty("Parent", &GCEnvFade::GetParent, &GCEnvFade::SetParent)
        .addFunction("ToPtr", &GCEnvFade::ToPtr)
        .addFunction("IsValid", &GCEnvFade::IsValid)
        .endClass();
}
GCDynamicPropAlias_cable_dynamic::GCDynamicPropAlias_cable_dynamic(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCDynamicPropAlias_cable_dynamic::GCDynamicPropAlias_cable_dynamic(void *ptr) {
    m_ptr = ptr;
}
void* GCDynamicPropAlias_cable_dynamic::GetPtr() {
    return m_ptr;
}
std::string GCDynamicPropAlias_cable_dynamic::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCDynamicPropAlias_cable_dynamic::IsValid() {
    return (m_ptr != nullptr);
}
GCDynamicProp GCDynamicPropAlias_cable_dynamic::GetParent() const {
    GCDynamicProp value(m_ptr);
    return value;
}
void GCDynamicPropAlias_cable_dynamic::SetParent(GCDynamicProp value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCDynamicPropAlias_cable_dynamic(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCDynamicPropAlias_cable_dynamic>("CDynamicPropAlias_cable_dynamic")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCDynamicPropAlias_cable_dynamic::GetParent, &GCDynamicPropAlias_cable_dynamic::SetParent)
        .addFunction("ToPtr", &GCDynamicPropAlias_cable_dynamic::ToPtr)
        .addFunction("IsValid", &GCDynamicPropAlias_cable_dynamic::IsValid)
        .endClass();
}
GCCSPlayer_BuyServices::GCCSPlayer_BuyServices(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCCSPlayer_BuyServices::GCCSPlayer_BuyServices(void *ptr) {
    m_ptr = ptr;
}
std::vector<GSellbackPurchaseEntry_t> GCCSPlayer_BuyServices::GetSellbackPurchaseEntries() const {
    CUtlVector<GSellbackPurchaseEntry_t>* vec = GetSchemaValue<CUtlVector<GSellbackPurchaseEntry_t>*>(m_ptr, "CCSPlayer_BuyServices", "m_vecSellbackPurchaseEntries"); std::vector<GSellbackPurchaseEntry_t> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCCSPlayer_BuyServices::SetSellbackPurchaseEntries(std::vector<GSellbackPurchaseEntry_t> value) {
    SetSchemaValueCUtlVector<GSellbackPurchaseEntry_t>(m_ptr, "CCSPlayer_BuyServices", "m_vecSellbackPurchaseEntries", false, value);
}
void* GCCSPlayer_BuyServices::GetPtr() {
    return m_ptr;
}
std::string GCCSPlayer_BuyServices::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCCSPlayer_BuyServices::IsValid() {
    return (m_ptr != nullptr);
}
GCPlayerPawnComponent GCCSPlayer_BuyServices::GetParent() const {
    GCPlayerPawnComponent value(m_ptr);
    return value;
}
void GCCSPlayer_BuyServices::SetParent(GCPlayerPawnComponent value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCCSPlayer_BuyServices(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCCSPlayer_BuyServices>("CCSPlayer_BuyServices")
        .addConstructor<void (*)(std::string)>()
        .addProperty("SellbackPurchaseEntries", &GCCSPlayer_BuyServices::GetSellbackPurchaseEntries, &GCCSPlayer_BuyServices::SetSellbackPurchaseEntries)
        .addProperty("Parent", &GCCSPlayer_BuyServices::GetParent, &GCCSPlayer_BuyServices::SetParent)
        .addFunction("ToPtr", &GCCSPlayer_BuyServices::ToPtr)
        .addFunction("IsValid", &GCCSPlayer_BuyServices::IsValid)
        .endClass();
}
GCHostageExpresserShim::GCHostageExpresserShim(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCHostageExpresserShim::GCHostageExpresserShim(void *ptr) {
    m_ptr = ptr;
}
GCAI_Expresser GCHostageExpresserShim::GetExpresser() const {
    GCAI_Expresser value(*(void**)GetSchemaPtr(m_ptr, "CHostageExpresserShim", "m_pExpresser"));
    return value;
}
void GCHostageExpresserShim::SetExpresser(GCAI_Expresser value) {
    SetSchemaValue(m_ptr, "CHostageExpresserShim","m_pExpresser", false, (char*)value.GetPtr());
}
void* GCHostageExpresserShim::GetPtr() {
    return m_ptr;
}
std::string GCHostageExpresserShim::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCHostageExpresserShim::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseCombatCharacter GCHostageExpresserShim::GetParent() const {
    GCBaseCombatCharacter value(m_ptr);
    return value;
}
void GCHostageExpresserShim::SetParent(GCBaseCombatCharacter value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCHostageExpresserShim(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCHostageExpresserShim>("CHostageExpresserShim")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Expresser", &GCHostageExpresserShim::GetExpresser, &GCHostageExpresserShim::SetExpresser)
        .addProperty("Parent", &GCHostageExpresserShim::GetParent, &GCHostageExpresserShim::SetParent)
        .addFunction("ToPtr", &GCHostageExpresserShim::ToPtr)
        .addFunction("IsValid", &GCHostageExpresserShim::IsValid)
        .endClass();
}
GCInferno::GCInferno(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCInferno::GCInferno(void *ptr) {
    m_ptr = ptr;
}
std::vector<Vector> GCInferno::GetFirePositions() const {
    Vector* outValue = (Vector*)GetSchemaPtr(m_ptr, "CInferno", "m_firePositions"); std::vector<Vector> ret; for(int i = 0; i < 64; i++) { ret.push_back(outValue[i]); } return ret;
}
void GCInferno::SetFirePositions(std::vector<Vector> value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'FirePositions' is not possible.\n");
}
std::vector<Vector> GCInferno::GetFireParentPositions() const {
    Vector* outValue = (Vector*)GetSchemaPtr(m_ptr, "CInferno", "m_fireParentPositions"); std::vector<Vector> ret; for(int i = 0; i < 64; i++) { ret.push_back(outValue[i]); } return ret;
}
void GCInferno::SetFireParentPositions(std::vector<Vector> value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'FireParentPositions' is not possible.\n");
}
std::vector<bool> GCInferno::GetFireIsBurning() const {
    bool* outValue = (bool*)GetSchemaPtr(m_ptr, "CInferno", "m_bFireIsBurning"); std::vector<bool> ret; for(int i = 0; i < 64; i++) { ret.push_back(outValue[i]); } return ret;
}
void GCInferno::SetFireIsBurning(std::vector<bool> value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'FireIsBurning' is not possible.\n");
}
std::vector<Vector> GCInferno::GetBurnNormal() const {
    Vector* outValue = (Vector*)GetSchemaPtr(m_ptr, "CInferno", "m_BurnNormal"); std::vector<Vector> ret; for(int i = 0; i < 64; i++) { ret.push_back(outValue[i]); } return ret;
}
void GCInferno::SetBurnNormal(std::vector<Vector> value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'BurnNormal' is not possible.\n");
}
int32_t GCInferno::GetFireCount() const {
    return GetSchemaValue<int32_t>(m_ptr, "CInferno", "m_fireCount");
}
void GCInferno::SetFireCount(int32_t value) {
    SetSchemaValue(m_ptr, "CInferno", "m_fireCount", false, value);
}
int32_t GCInferno::GetInfernoType() const {
    return GetSchemaValue<int32_t>(m_ptr, "CInferno", "m_nInfernoType");
}
void GCInferno::SetInfernoType(int32_t value) {
    SetSchemaValue(m_ptr, "CInferno", "m_nInfernoType", false, value);
}
int32_t GCInferno::GetFireEffectTickBegin() const {
    return GetSchemaValue<int32_t>(m_ptr, "CInferno", "m_nFireEffectTickBegin");
}
void GCInferno::SetFireEffectTickBegin(int32_t value) {
    SetSchemaValue(m_ptr, "CInferno", "m_nFireEffectTickBegin", false, value);
}
float GCInferno::GetFireLifetime() const {
    return GetSchemaValue<float>(m_ptr, "CInferno", "m_nFireLifetime");
}
void GCInferno::SetFireLifetime(float value) {
    SetSchemaValue(m_ptr, "CInferno", "m_nFireLifetime", false, value);
}
bool GCInferno::GetInPostEffectTime() const {
    return GetSchemaValue<bool>(m_ptr, "CInferno", "m_bInPostEffectTime");
}
void GCInferno::SetInPostEffectTime(bool value) {
    SetSchemaValue(m_ptr, "CInferno", "m_bInPostEffectTime", false, value);
}
int32_t GCInferno::GetFiresExtinguishCount() const {
    return GetSchemaValue<int32_t>(m_ptr, "CInferno", "m_nFiresExtinguishCount");
}
void GCInferno::SetFiresExtinguishCount(int32_t value) {
    SetSchemaValue(m_ptr, "CInferno", "m_nFiresExtinguishCount", false, value);
}
bool GCInferno::GetWasCreatedInSmoke() const {
    return GetSchemaValue<bool>(m_ptr, "CInferno", "m_bWasCreatedInSmoke");
}
void GCInferno::SetWasCreatedInSmoke(bool value) {
    SetSchemaValue(m_ptr, "CInferno", "m_bWasCreatedInSmoke", false, value);
}
GExtent GCInferno::GetExtent() const {
    GExtent value(GetSchemaPtr(m_ptr, "CInferno", "m_extent"));
    return value;
}
void GCInferno::SetExtent(GExtent value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Extent' is not possible.\n");
}
GCountdownTimer GCInferno::GetDamageTimer() const {
    GCountdownTimer value(GetSchemaPtr(m_ptr, "CInferno", "m_damageTimer"));
    return value;
}
void GCInferno::SetDamageTimer(GCountdownTimer value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'DamageTimer' is not possible.\n");
}
GCountdownTimer GCInferno::GetDamageRampTimer() const {
    GCountdownTimer value(GetSchemaPtr(m_ptr, "CInferno", "m_damageRampTimer"));
    return value;
}
void GCInferno::SetDamageRampTimer(GCountdownTimer value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'DamageRampTimer' is not possible.\n");
}
Vector GCInferno::GetSplashVelocity() const {
    return GetSchemaValue<Vector>(m_ptr, "CInferno", "m_splashVelocity");
}
void GCInferno::SetSplashVelocity(Vector value) {
    SetSchemaValue(m_ptr, "CInferno", "m_splashVelocity", false, value);
}
Vector GCInferno::GetInitialSplashVelocity() const {
    return GetSchemaValue<Vector>(m_ptr, "CInferno", "m_InitialSplashVelocity");
}
void GCInferno::SetInitialSplashVelocity(Vector value) {
    SetSchemaValue(m_ptr, "CInferno", "m_InitialSplashVelocity", false, value);
}
Vector GCInferno::GetStartPos() const {
    return GetSchemaValue<Vector>(m_ptr, "CInferno", "m_startPos");
}
void GCInferno::SetStartPos(Vector value) {
    SetSchemaValue(m_ptr, "CInferno", "m_startPos", false, value);
}
Vector GCInferno::GetOriginalSpawnLocation() const {
    return GetSchemaValue<Vector>(m_ptr, "CInferno", "m_vecOriginalSpawnLocation");
}
void GCInferno::SetOriginalSpawnLocation(Vector value) {
    SetSchemaValue(m_ptr, "CInferno", "m_vecOriginalSpawnLocation", false, value);
}
GIntervalTimer GCInferno::GetActiveTimer() const {
    GIntervalTimer value(GetSchemaPtr(m_ptr, "CInferno", "m_activeTimer"));
    return value;
}
void GCInferno::SetActiveTimer(GIntervalTimer value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'ActiveTimer' is not possible.\n");
}
int32_t GCInferno::GetFireSpawnOffset() const {
    return GetSchemaValue<int32_t>(m_ptr, "CInferno", "m_fireSpawnOffset");
}
void GCInferno::SetFireSpawnOffset(int32_t value) {
    SetSchemaValue(m_ptr, "CInferno", "m_fireSpawnOffset", false, value);
}
int32_t GCInferno::GetMaxFlames() const {
    return GetSchemaValue<int32_t>(m_ptr, "CInferno", "m_nMaxFlames");
}
void GCInferno::SetMaxFlames(int32_t value) {
    SetSchemaValue(m_ptr, "CInferno", "m_nMaxFlames", false, value);
}
int32_t GCInferno::GetSpreadCount() const {
    return GetSchemaValue<int32_t>(m_ptr, "CInferno", "m_nSpreadCount");
}
void GCInferno::SetSpreadCount(int32_t value) {
    SetSchemaValue(m_ptr, "CInferno", "m_nSpreadCount", false, value);
}
GCountdownTimer GCInferno::GetBookkeepingTimer() const {
    GCountdownTimer value(GetSchemaPtr(m_ptr, "CInferno", "m_BookkeepingTimer"));
    return value;
}
void GCInferno::SetBookkeepingTimer(GCountdownTimer value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'BookkeepingTimer' is not possible.\n");
}
GCountdownTimer GCInferno::GetNextSpreadTimer() const {
    GCountdownTimer value(GetSchemaPtr(m_ptr, "CInferno", "m_NextSpreadTimer"));
    return value;
}
void GCInferno::SetNextSpreadTimer(GCountdownTimer value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'NextSpreadTimer' is not possible.\n");
}
uint16_t GCInferno::GetSourceItemDefIndex() const {
    return GetSchemaValue<uint16_t>(m_ptr, "CInferno", "m_nSourceItemDefIndex");
}
void GCInferno::SetSourceItemDefIndex(uint16_t value) {
    SetSchemaValue(m_ptr, "CInferno", "m_nSourceItemDefIndex", false, value);
}
void* GCInferno::GetPtr() {
    return m_ptr;
}
std::string GCInferno::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCInferno::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseModelEntity GCInferno::GetParent() const {
    GCBaseModelEntity value(m_ptr);
    return value;
}
void GCInferno::SetParent(GCBaseModelEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCInferno(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCInferno>("CInferno")
        .addConstructor<void (*)(std::string)>()
        .addProperty("FirePositions", &GCInferno::GetFirePositions, &GCInferno::SetFirePositions)
        .addProperty("FireParentPositions", &GCInferno::GetFireParentPositions, &GCInferno::SetFireParentPositions)
        .addProperty("FireIsBurning", &GCInferno::GetFireIsBurning, &GCInferno::SetFireIsBurning)
        .addProperty("BurnNormal", &GCInferno::GetBurnNormal, &GCInferno::SetBurnNormal)
        .addProperty("FireCount", &GCInferno::GetFireCount, &GCInferno::SetFireCount)
        .addProperty("InfernoType", &GCInferno::GetInfernoType, &GCInferno::SetInfernoType)
        .addProperty("FireEffectTickBegin", &GCInferno::GetFireEffectTickBegin, &GCInferno::SetFireEffectTickBegin)
        .addProperty("FireLifetime", &GCInferno::GetFireLifetime, &GCInferno::SetFireLifetime)
        .addProperty("InPostEffectTime", &GCInferno::GetInPostEffectTime, &GCInferno::SetInPostEffectTime)
        .addProperty("FiresExtinguishCount", &GCInferno::GetFiresExtinguishCount, &GCInferno::SetFiresExtinguishCount)
        .addProperty("WasCreatedInSmoke", &GCInferno::GetWasCreatedInSmoke, &GCInferno::SetWasCreatedInSmoke)
        .addProperty("Extent", &GCInferno::GetExtent, &GCInferno::SetExtent)
        .addProperty("DamageTimer", &GCInferno::GetDamageTimer, &GCInferno::SetDamageTimer)
        .addProperty("DamageRampTimer", &GCInferno::GetDamageRampTimer, &GCInferno::SetDamageRampTimer)
        .addProperty("SplashVelocity", &GCInferno::GetSplashVelocity, &GCInferno::SetSplashVelocity)
        .addProperty("InitialSplashVelocity", &GCInferno::GetInitialSplashVelocity, &GCInferno::SetInitialSplashVelocity)
        .addProperty("StartPos", &GCInferno::GetStartPos, &GCInferno::SetStartPos)
        .addProperty("OriginalSpawnLocation", &GCInferno::GetOriginalSpawnLocation, &GCInferno::SetOriginalSpawnLocation)
        .addProperty("ActiveTimer", &GCInferno::GetActiveTimer, &GCInferno::SetActiveTimer)
        .addProperty("FireSpawnOffset", &GCInferno::GetFireSpawnOffset, &GCInferno::SetFireSpawnOffset)
        .addProperty("MaxFlames", &GCInferno::GetMaxFlames, &GCInferno::SetMaxFlames)
        .addProperty("SpreadCount", &GCInferno::GetSpreadCount, &GCInferno::SetSpreadCount)
        .addProperty("BookkeepingTimer", &GCInferno::GetBookkeepingTimer, &GCInferno::SetBookkeepingTimer)
        .addProperty("NextSpreadTimer", &GCInferno::GetNextSpreadTimer, &GCInferno::SetNextSpreadTimer)
        .addProperty("SourceItemDefIndex", &GCInferno::GetSourceItemDefIndex, &GCInferno::SetSourceItemDefIndex)
        .addProperty("Parent", &GCInferno::GetParent, &GCInferno::SetParent)
        .addFunction("ToPtr", &GCInferno::ToPtr)
        .addFunction("IsValid", &GCInferno::IsValid)
        .endClass();
}
GCEnvGlobal::GCEnvGlobal(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCEnvGlobal::GCEnvGlobal(void *ptr) {
    m_ptr = ptr;
}
std::string GCEnvGlobal::GetGlobalstate() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CEnvGlobal", "m_globalstate").String();
}
void GCEnvGlobal::SetGlobalstate(std::string value) {
    SetSchemaValue(m_ptr, "CEnvGlobal", "m_globalstate", false, CUtlSymbolLarge(value.c_str()));
}
int32_t GCEnvGlobal::GetTriggermode() const {
    return GetSchemaValue<int32_t>(m_ptr, "CEnvGlobal", "m_triggermode");
}
void GCEnvGlobal::SetTriggermode(int32_t value) {
    SetSchemaValue(m_ptr, "CEnvGlobal", "m_triggermode", false, value);
}
int32_t GCEnvGlobal::GetInitialstate() const {
    return GetSchemaValue<int32_t>(m_ptr, "CEnvGlobal", "m_initialstate");
}
void GCEnvGlobal::SetInitialstate(int32_t value) {
    SetSchemaValue(m_ptr, "CEnvGlobal", "m_initialstate", false, value);
}
int32_t GCEnvGlobal::GetCounter() const {
    return GetSchemaValue<int32_t>(m_ptr, "CEnvGlobal", "m_counter");
}
void GCEnvGlobal::SetCounter(int32_t value) {
    SetSchemaValue(m_ptr, "CEnvGlobal", "m_counter", false, value);
}
void* GCEnvGlobal::GetPtr() {
    return m_ptr;
}
std::string GCEnvGlobal::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCEnvGlobal::IsValid() {
    return (m_ptr != nullptr);
}
GCLogicalEntity GCEnvGlobal::GetParent() const {
    GCLogicalEntity value(m_ptr);
    return value;
}
void GCEnvGlobal::SetParent(GCLogicalEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCEnvGlobal(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCEnvGlobal>("CEnvGlobal")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Globalstate", &GCEnvGlobal::GetGlobalstate, &GCEnvGlobal::SetGlobalstate)
        .addProperty("Triggermode", &GCEnvGlobal::GetTriggermode, &GCEnvGlobal::SetTriggermode)
        .addProperty("Initialstate", &GCEnvGlobal::GetInitialstate, &GCEnvGlobal::SetInitialstate)
        .addProperty("Counter", &GCEnvGlobal::GetCounter, &GCEnvGlobal::SetCounter)
        .addProperty("Parent", &GCEnvGlobal::GetParent, &GCEnvGlobal::SetParent)
        .addFunction("ToPtr", &GCEnvGlobal::ToPtr)
        .addFunction("IsValid", &GCEnvGlobal::IsValid)
        .endClass();
}
GCFilterName::GCFilterName(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCFilterName::GCFilterName(void *ptr) {
    m_ptr = ptr;
}
std::string GCFilterName::GetFilterName() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CFilterName", "m_iFilterName").String();
}
void GCFilterName::SetFilterName(std::string value) {
    SetSchemaValue(m_ptr, "CFilterName", "m_iFilterName", false, CUtlSymbolLarge(value.c_str()));
}
void* GCFilterName::GetPtr() {
    return m_ptr;
}
std::string GCFilterName::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCFilterName::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseFilter GCFilterName::GetParent() const {
    GCBaseFilter value(m_ptr);
    return value;
}
void GCFilterName::SetParent(GCBaseFilter value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCFilterName(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCFilterName>("CFilterName")
        .addConstructor<void (*)(std::string)>()
        .addProperty("FilterName", &GCFilterName::GetFilterName, &GCFilterName::SetFilterName)
        .addProperty("Parent", &GCFilterName::GetParent, &GCFilterName::SetParent)
        .addFunction("ToPtr", &GCFilterName::ToPtr)
        .addFunction("IsValid", &GCFilterName::IsValid)
        .endClass();
}
GCCSTeam::GCCSTeam(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCCSTeam::GCCSTeam(void *ptr) {
    m_ptr = ptr;
}
int32_t GCCSTeam::GetLastRecievedShorthandedRoundBonus() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSTeam", "m_nLastRecievedShorthandedRoundBonus");
}
void GCCSTeam::SetLastRecievedShorthandedRoundBonus(int32_t value) {
    SetSchemaValue(m_ptr, "CCSTeam", "m_nLastRecievedShorthandedRoundBonus", false, value);
}
int32_t GCCSTeam::GetShorthandedRoundBonusStartRound() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSTeam", "m_nShorthandedRoundBonusStartRound");
}
void GCCSTeam::SetShorthandedRoundBonusStartRound(int32_t value) {
    SetSchemaValue(m_ptr, "CCSTeam", "m_nShorthandedRoundBonusStartRound", false, value);
}
bool GCCSTeam::GetSurrendered() const {
    return GetSchemaValue<bool>(m_ptr, "CCSTeam", "m_bSurrendered");
}
void GCCSTeam::SetSurrendered(bool value) {
    SetSchemaValue(m_ptr, "CCSTeam", "m_bSurrendered", false, value);
}
std::string GCCSTeam::GetTeamMatchStat() const {
    return GetSchemaValuePtr<char>(m_ptr, "CCSTeam", "m_szTeamMatchStat");
}
void GCCSTeam::SetTeamMatchStat(std::string value) {
    WriteSchemaPtrValue(m_ptr, "CCSTeam", "m_szTeamMatchStat", false, reinterpret_cast<byte*>(const_cast<char*>(value.c_str())), 512);
}
int32_t GCCSTeam::GetNumMapVictories() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSTeam", "m_numMapVictories");
}
void GCCSTeam::SetNumMapVictories(int32_t value) {
    SetSchemaValue(m_ptr, "CCSTeam", "m_numMapVictories", false, value);
}
int32_t GCCSTeam::GetScoreFirstHalf() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSTeam", "m_scoreFirstHalf");
}
void GCCSTeam::SetScoreFirstHalf(int32_t value) {
    SetSchemaValue(m_ptr, "CCSTeam", "m_scoreFirstHalf", false, value);
}
int32_t GCCSTeam::GetScoreSecondHalf() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSTeam", "m_scoreSecondHalf");
}
void GCCSTeam::SetScoreSecondHalf(int32_t value) {
    SetSchemaValue(m_ptr, "CCSTeam", "m_scoreSecondHalf", false, value);
}
int32_t GCCSTeam::GetScoreOvertime() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSTeam", "m_scoreOvertime");
}
void GCCSTeam::SetScoreOvertime(int32_t value) {
    SetSchemaValue(m_ptr, "CCSTeam", "m_scoreOvertime", false, value);
}
std::string GCCSTeam::GetClanTeamname() const {
    return GetSchemaValuePtr<char>(m_ptr, "CCSTeam", "m_szClanTeamname");
}
void GCCSTeam::SetClanTeamname(std::string value) {
    WriteSchemaPtrValue(m_ptr, "CCSTeam", "m_szClanTeamname", false, reinterpret_cast<byte*>(const_cast<char*>(value.c_str())), 129);
}
uint32_t GCCSTeam::GetClanID() const {
    return GetSchemaValue<uint32_t>(m_ptr, "CCSTeam", "m_iClanID");
}
void GCCSTeam::SetClanID(uint32_t value) {
    SetSchemaValue(m_ptr, "CCSTeam", "m_iClanID", false, value);
}
std::string GCCSTeam::GetTeamFlagImage() const {
    return GetSchemaValuePtr<char>(m_ptr, "CCSTeam", "m_szTeamFlagImage");
}
void GCCSTeam::SetTeamFlagImage(std::string value) {
    WriteSchemaPtrValue(m_ptr, "CCSTeam", "m_szTeamFlagImage", false, reinterpret_cast<byte*>(const_cast<char*>(value.c_str())), 8);
}
std::string GCCSTeam::GetTeamLogoImage() const {
    return GetSchemaValuePtr<char>(m_ptr, "CCSTeam", "m_szTeamLogoImage");
}
void GCCSTeam::SetTeamLogoImage(std::string value) {
    WriteSchemaPtrValue(m_ptr, "CCSTeam", "m_szTeamLogoImage", false, reinterpret_cast<byte*>(const_cast<char*>(value.c_str())), 8);
}
float GCCSTeam::GetNextResourceTime() const {
    return GetSchemaValue<float>(m_ptr, "CCSTeam", "m_flNextResourceTime");
}
void GCCSTeam::SetNextResourceTime(float value) {
    SetSchemaValue(m_ptr, "CCSTeam", "m_flNextResourceTime", false, value);
}
int32_t GCCSTeam::GetLastUpdateSentAt() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSTeam", "m_iLastUpdateSentAt");
}
void GCCSTeam::SetLastUpdateSentAt(int32_t value) {
    SetSchemaValue(m_ptr, "CCSTeam", "m_iLastUpdateSentAt", false, value);
}
void* GCCSTeam::GetPtr() {
    return m_ptr;
}
std::string GCCSTeam::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCCSTeam::IsValid() {
    return (m_ptr != nullptr);
}
GCTeam GCCSTeam::GetParent() const {
    GCTeam value(m_ptr);
    return value;
}
void GCCSTeam::SetParent(GCTeam value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCCSTeam(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCCSTeam>("CCSTeam")
        .addConstructor<void (*)(std::string)>()
        .addProperty("LastRecievedShorthandedRoundBonus", &GCCSTeam::GetLastRecievedShorthandedRoundBonus, &GCCSTeam::SetLastRecievedShorthandedRoundBonus)
        .addProperty("ShorthandedRoundBonusStartRound", &GCCSTeam::GetShorthandedRoundBonusStartRound, &GCCSTeam::SetShorthandedRoundBonusStartRound)
        .addProperty("Surrendered", &GCCSTeam::GetSurrendered, &GCCSTeam::SetSurrendered)
        .addProperty("TeamMatchStat", &GCCSTeam::GetTeamMatchStat, &GCCSTeam::SetTeamMatchStat)
        .addProperty("NumMapVictories", &GCCSTeam::GetNumMapVictories, &GCCSTeam::SetNumMapVictories)
        .addProperty("ScoreFirstHalf", &GCCSTeam::GetScoreFirstHalf, &GCCSTeam::SetScoreFirstHalf)
        .addProperty("ScoreSecondHalf", &GCCSTeam::GetScoreSecondHalf, &GCCSTeam::SetScoreSecondHalf)
        .addProperty("ScoreOvertime", &GCCSTeam::GetScoreOvertime, &GCCSTeam::SetScoreOvertime)
        .addProperty("ClanTeamname", &GCCSTeam::GetClanTeamname, &GCCSTeam::SetClanTeamname)
        .addProperty("ClanID", &GCCSTeam::GetClanID, &GCCSTeam::SetClanID)
        .addProperty("TeamFlagImage", &GCCSTeam::GetTeamFlagImage, &GCCSTeam::SetTeamFlagImage)
        .addProperty("TeamLogoImage", &GCCSTeam::GetTeamLogoImage, &GCCSTeam::SetTeamLogoImage)
        .addProperty("NextResourceTime", &GCCSTeam::GetNextResourceTime, &GCCSTeam::SetNextResourceTime)
        .addProperty("LastUpdateSentAt", &GCCSTeam::GetLastUpdateSentAt, &GCCSTeam::SetLastUpdateSentAt)
        .addProperty("Parent", &GCCSTeam::GetParent, &GCCSTeam::SetParent)
        .addFunction("ToPtr", &GCCSTeam::ToPtr)
        .addFunction("IsValid", &GCCSTeam::IsValid)
        .endClass();
}
GCWeaponUSPSilencer::GCWeaponUSPSilencer(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCWeaponUSPSilencer::GCWeaponUSPSilencer(void *ptr) {
    m_ptr = ptr;
}
void* GCWeaponUSPSilencer::GetPtr() {
    return m_ptr;
}
std::string GCWeaponUSPSilencer::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCWeaponUSPSilencer::IsValid() {
    return (m_ptr != nullptr);
}
GCCSWeaponBaseGun GCWeaponUSPSilencer::GetParent() const {
    GCCSWeaponBaseGun value(m_ptr);
    return value;
}
void GCWeaponUSPSilencer::SetParent(GCCSWeaponBaseGun value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCWeaponUSPSilencer(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCWeaponUSPSilencer>("CWeaponUSPSilencer")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCWeaponUSPSilencer::GetParent, &GCWeaponUSPSilencer::SetParent)
        .addFunction("ToPtr", &GCWeaponUSPSilencer::ToPtr)
        .addFunction("IsValid", &GCWeaponUSPSilencer::IsValid)
        .endClass();
}
GCSpriteOriented::GCSpriteOriented(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCSpriteOriented::GCSpriteOriented(void *ptr) {
    m_ptr = ptr;
}
void* GCSpriteOriented::GetPtr() {
    return m_ptr;
}
std::string GCSpriteOriented::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCSpriteOriented::IsValid() {
    return (m_ptr != nullptr);
}
GCSprite GCSpriteOriented::GetParent() const {
    GCSprite value(m_ptr);
    return value;
}
void GCSpriteOriented::SetParent(GCSprite value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCSpriteOriented(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCSpriteOriented>("CSpriteOriented")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCSpriteOriented::GetParent, &GCSpriteOriented::SetParent)
        .addFunction("ToPtr", &GCSpriteOriented::ToPtr)
        .addFunction("IsValid", &GCSpriteOriented::IsValid)
        .endClass();
}
GCTriggerGravity::GCTriggerGravity(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCTriggerGravity::GCTriggerGravity(void *ptr) {
    m_ptr = ptr;
}
void* GCTriggerGravity::GetPtr() {
    return m_ptr;
}
std::string GCTriggerGravity::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCTriggerGravity::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseTrigger GCTriggerGravity::GetParent() const {
    GCBaseTrigger value(m_ptr);
    return value;
}
void GCTriggerGravity::SetParent(GCBaseTrigger value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCTriggerGravity(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCTriggerGravity>("CTriggerGravity")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCTriggerGravity::GetParent, &GCTriggerGravity::SetParent)
        .addFunction("ToPtr", &GCTriggerGravity::ToPtr)
        .addFunction("IsValid", &GCTriggerGravity::IsValid)
        .endClass();
}
GCServerRagdollTrigger::GCServerRagdollTrigger(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCServerRagdollTrigger::GCServerRagdollTrigger(void *ptr) {
    m_ptr = ptr;
}
void* GCServerRagdollTrigger::GetPtr() {
    return m_ptr;
}
std::string GCServerRagdollTrigger::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCServerRagdollTrigger::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseTrigger GCServerRagdollTrigger::GetParent() const {
    GCBaseTrigger value(m_ptr);
    return value;
}
void GCServerRagdollTrigger::SetParent(GCBaseTrigger value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCServerRagdollTrigger(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCServerRagdollTrigger>("CServerRagdollTrigger")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCServerRagdollTrigger::GetParent, &GCServerRagdollTrigger::SetParent)
        .addFunction("ToPtr", &GCServerRagdollTrigger::ToPtr)
        .addFunction("IsValid", &GCServerRagdollTrigger::IsValid)
        .endClass();
}
GCInfoDynamicShadowHintBox::GCInfoDynamicShadowHintBox(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCInfoDynamicShadowHintBox::GCInfoDynamicShadowHintBox(void *ptr) {
    m_ptr = ptr;
}
Vector GCInfoDynamicShadowHintBox::GetBoxMins() const {
    return GetSchemaValue<Vector>(m_ptr, "CInfoDynamicShadowHintBox", "m_vBoxMins");
}
void GCInfoDynamicShadowHintBox::SetBoxMins(Vector value) {
    SetSchemaValue(m_ptr, "CInfoDynamicShadowHintBox", "m_vBoxMins", false, value);
}
Vector GCInfoDynamicShadowHintBox::GetBoxMaxs() const {
    return GetSchemaValue<Vector>(m_ptr, "CInfoDynamicShadowHintBox", "m_vBoxMaxs");
}
void GCInfoDynamicShadowHintBox::SetBoxMaxs(Vector value) {
    SetSchemaValue(m_ptr, "CInfoDynamicShadowHintBox", "m_vBoxMaxs", false, value);
}
void* GCInfoDynamicShadowHintBox::GetPtr() {
    return m_ptr;
}
std::string GCInfoDynamicShadowHintBox::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCInfoDynamicShadowHintBox::IsValid() {
    return (m_ptr != nullptr);
}
GCInfoDynamicShadowHint GCInfoDynamicShadowHintBox::GetParent() const {
    GCInfoDynamicShadowHint value(m_ptr);
    return value;
}
void GCInfoDynamicShadowHintBox::SetParent(GCInfoDynamicShadowHint value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCInfoDynamicShadowHintBox(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCInfoDynamicShadowHintBox>("CInfoDynamicShadowHintBox")
        .addConstructor<void (*)(std::string)>()
        .addProperty("BoxMins", &GCInfoDynamicShadowHintBox::GetBoxMins, &GCInfoDynamicShadowHintBox::SetBoxMins)
        .addProperty("BoxMaxs", &GCInfoDynamicShadowHintBox::GetBoxMaxs, &GCInfoDynamicShadowHintBox::SetBoxMaxs)
        .addProperty("Parent", &GCInfoDynamicShadowHintBox::GetParent, &GCInfoDynamicShadowHintBox::SetParent)
        .addFunction("ToPtr", &GCInfoDynamicShadowHintBox::ToPtr)
        .addFunction("IsValid", &GCInfoDynamicShadowHintBox::IsValid)
        .endClass();
}
GCPathMover::GCPathMover(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCPathMover::GCPathMover(void *ptr) {
    m_ptr = ptr;
}
float GCPathMover::GetPathLength() const {
    return GetSchemaValue<float>(m_ptr, "CPathMover", "m_flPathLength");
}
void GCPathMover::SetPathLength(float value) {
    SetSchemaValue(m_ptr, "CPathMover", "m_flPathLength", false, value);
}
bool GCPathMover::GetClosedLoop() const {
    return GetSchemaValue<bool>(m_ptr, "CPathMover", "m_bClosedLoop");
}
void GCPathMover::SetClosedLoop(bool value) {
    SetSchemaValue(m_ptr, "CPathMover", "m_bClosedLoop", false, value);
}
void* GCPathMover::GetPtr() {
    return m_ptr;
}
std::string GCPathMover::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCPathMover::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseEntity GCPathMover::GetParent() const {
    GCBaseEntity value(m_ptr);
    return value;
}
void GCPathMover::SetParent(GCBaseEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCPathMover(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCPathMover>("CPathMover")
        .addConstructor<void (*)(std::string)>()
        .addProperty("PathLength", &GCPathMover::GetPathLength, &GCPathMover::SetPathLength)
        .addProperty("ClosedLoop", &GCPathMover::GetClosedLoop, &GCPathMover::SetClosedLoop)
        .addProperty("Parent", &GCPathMover::GetParent, &GCPathMover::SetParent)
        .addFunction("ToPtr", &GCPathMover::ToPtr)
        .addFunction("IsValid", &GCPathMover::IsValid)
        .endClass();
}
GCFlashbang::GCFlashbang(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCFlashbang::GCFlashbang(void *ptr) {
    m_ptr = ptr;
}
void* GCFlashbang::GetPtr() {
    return m_ptr;
}
std::string GCFlashbang::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCFlashbang::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseCSGrenade GCFlashbang::GetParent() const {
    GCBaseCSGrenade value(m_ptr);
    return value;
}
void GCFlashbang::SetParent(GCBaseCSGrenade value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCFlashbang(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCFlashbang>("CFlashbang")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCFlashbang::GetParent, &GCFlashbang::SetParent)
        .addFunction("ToPtr", &GCFlashbang::ToPtr)
        .addFunction("IsValid", &GCFlashbang::IsValid)
        .endClass();
}
GCWeaponAug::GCWeaponAug(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCWeaponAug::GCWeaponAug(void *ptr) {
    m_ptr = ptr;
}
void* GCWeaponAug::GetPtr() {
    return m_ptr;
}
std::string GCWeaponAug::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCWeaponAug::IsValid() {
    return (m_ptr != nullptr);
}
GCCSWeaponBaseGun GCWeaponAug::GetParent() const {
    GCCSWeaponBaseGun value(m_ptr);
    return value;
}
void GCWeaponAug::SetParent(GCCSWeaponBaseGun value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCWeaponAug(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCWeaponAug>("CWeaponAug")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCWeaponAug::GetParent, &GCWeaponAug::SetParent)
        .addFunction("ToPtr", &GCWeaponAug::ToPtr)
        .addFunction("IsValid", &GCWeaponAug::IsValid)
        .endClass();
}
GCIncendiaryGrenade::GCIncendiaryGrenade(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCIncendiaryGrenade::GCIncendiaryGrenade(void *ptr) {
    m_ptr = ptr;
}
void* GCIncendiaryGrenade::GetPtr() {
    return m_ptr;
}
std::string GCIncendiaryGrenade::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCIncendiaryGrenade::IsValid() {
    return (m_ptr != nullptr);
}
GCMolotovGrenade GCIncendiaryGrenade::GetParent() const {
    GCMolotovGrenade value(m_ptr);
    return value;
}
void GCIncendiaryGrenade::SetParent(GCMolotovGrenade value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCIncendiaryGrenade(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCIncendiaryGrenade>("CIncendiaryGrenade")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCIncendiaryGrenade::GetParent, &GCIncendiaryGrenade::SetParent)
        .addFunction("ToPtr", &GCIncendiaryGrenade::ToPtr)
        .addFunction("IsValid", &GCIncendiaryGrenade::IsValid)
        .endClass();
}
GCChangeLevel::GCChangeLevel(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCChangeLevel::GCChangeLevel(void *ptr) {
    m_ptr = ptr;
}
std::string GCChangeLevel::GetMapName() const {
    return GetSchemaValue<CUtlString>(m_ptr, "CChangeLevel", "m_sMapName").Get();
}
void GCChangeLevel::SetMapName(std::string value) {
    SetSchemaValue(m_ptr, "CChangeLevel", "m_sMapName", false, CUtlString(value.c_str()));
}
std::string GCChangeLevel::GetLandmarkName() const {
    return GetSchemaValue<CUtlString>(m_ptr, "CChangeLevel", "m_sLandmarkName").Get();
}
void GCChangeLevel::SetLandmarkName(std::string value) {
    SetSchemaValue(m_ptr, "CChangeLevel", "m_sLandmarkName", false, CUtlString(value.c_str()));
}
GCEntityIOOutput GCChangeLevel::GetOnChangeLevel() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CChangeLevel", "m_OnChangeLevel"));
    return value;
}
void GCChangeLevel::SetOnChangeLevel(GCEntityIOOutput value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'OnChangeLevel' is not possible.\n");
}
bool GCChangeLevel::GetTouched() const {
    return GetSchemaValue<bool>(m_ptr, "CChangeLevel", "m_bTouched");
}
void GCChangeLevel::SetTouched(bool value) {
    SetSchemaValue(m_ptr, "CChangeLevel", "m_bTouched", false, value);
}
bool GCChangeLevel::GetNoTouch() const {
    return GetSchemaValue<bool>(m_ptr, "CChangeLevel", "m_bNoTouch");
}
void GCChangeLevel::SetNoTouch(bool value) {
    SetSchemaValue(m_ptr, "CChangeLevel", "m_bNoTouch", false, value);
}
bool GCChangeLevel::GetNewChapter() const {
    return GetSchemaValue<bool>(m_ptr, "CChangeLevel", "m_bNewChapter");
}
void GCChangeLevel::SetNewChapter(bool value) {
    SetSchemaValue(m_ptr, "CChangeLevel", "m_bNewChapter", false, value);
}
bool GCChangeLevel::GetOnChangeLevelFired() const {
    return GetSchemaValue<bool>(m_ptr, "CChangeLevel", "m_bOnChangeLevelFired");
}
void GCChangeLevel::SetOnChangeLevelFired(bool value) {
    SetSchemaValue(m_ptr, "CChangeLevel", "m_bOnChangeLevelFired", false, value);
}
void* GCChangeLevel::GetPtr() {
    return m_ptr;
}
std::string GCChangeLevel::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCChangeLevel::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseTrigger GCChangeLevel::GetParent() const {
    GCBaseTrigger value(m_ptr);
    return value;
}
void GCChangeLevel::SetParent(GCBaseTrigger value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCChangeLevel(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCChangeLevel>("CChangeLevel")
        .addConstructor<void (*)(std::string)>()
        .addProperty("MapName", &GCChangeLevel::GetMapName, &GCChangeLevel::SetMapName)
        .addProperty("LandmarkName", &GCChangeLevel::GetLandmarkName, &GCChangeLevel::SetLandmarkName)
        .addProperty("OnChangeLevel", &GCChangeLevel::GetOnChangeLevel, &GCChangeLevel::SetOnChangeLevel)
        .addProperty("Touched", &GCChangeLevel::GetTouched, &GCChangeLevel::SetTouched)
        .addProperty("NoTouch", &GCChangeLevel::GetNoTouch, &GCChangeLevel::SetNoTouch)
        .addProperty("NewChapter", &GCChangeLevel::GetNewChapter, &GCChangeLevel::SetNewChapter)
        .addProperty("OnChangeLevelFired", &GCChangeLevel::GetOnChangeLevelFired, &GCChangeLevel::SetOnChangeLevelFired)
        .addProperty("Parent", &GCChangeLevel::GetParent, &GCChangeLevel::SetParent)
        .addFunction("ToPtr", &GCChangeLevel::ToPtr)
        .addFunction("IsValid", &GCChangeLevel::IsValid)
        .endClass();
}
GCTriggerLerpObject::GCTriggerLerpObject(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCTriggerLerpObject::GCTriggerLerpObject(void *ptr) {
    m_ptr = ptr;
}
std::string GCTriggerLerpObject::GetLerpTarget() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CTriggerLerpObject", "m_iszLerpTarget").String();
}
void GCTriggerLerpObject::SetLerpTarget(std::string value) {
    SetSchemaValue(m_ptr, "CTriggerLerpObject", "m_iszLerpTarget", false, CUtlSymbolLarge(value.c_str()));
}
GCBaseEntity GCTriggerLerpObject::GetLerpTarget1() const {
    GCBaseEntity value((void*)(GetSchemaValue<CHandle<CEntityInstance>>(m_ptr, "CTriggerLerpObject", "m_hLerpTarget").Get()));
    return value;
}
void GCTriggerLerpObject::SetLerpTarget1(GCBaseEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'LerpTarget1' is not possible.\n");
}
std::string GCTriggerLerpObject::GetLerpTargetAttachment() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CTriggerLerpObject", "m_iszLerpTargetAttachment").String();
}
void GCTriggerLerpObject::SetLerpTargetAttachment(std::string value) {
    SetSchemaValue(m_ptr, "CTriggerLerpObject", "m_iszLerpTargetAttachment", false, CUtlSymbolLarge(value.c_str()));
}
float GCTriggerLerpObject::GetLerpDuration() const {
    return GetSchemaValue<float>(m_ptr, "CTriggerLerpObject", "m_flLerpDuration");
}
void GCTriggerLerpObject::SetLerpDuration(float value) {
    SetSchemaValue(m_ptr, "CTriggerLerpObject", "m_flLerpDuration", false, value);
}
bool GCTriggerLerpObject::GetLerpRestoreMoveType() const {
    return GetSchemaValue<bool>(m_ptr, "CTriggerLerpObject", "m_bLerpRestoreMoveType");
}
void GCTriggerLerpObject::SetLerpRestoreMoveType(bool value) {
    SetSchemaValue(m_ptr, "CTriggerLerpObject", "m_bLerpRestoreMoveType", false, value);
}
bool GCTriggerLerpObject::GetSingleLerpObject() const {
    return GetSchemaValue<bool>(m_ptr, "CTriggerLerpObject", "m_bSingleLerpObject");
}
void GCTriggerLerpObject::SetSingleLerpObject(bool value) {
    SetSchemaValue(m_ptr, "CTriggerLerpObject", "m_bSingleLerpObject", false, value);
}
std::vector<Glerpdata_t> GCTriggerLerpObject::GetLerpingObjects() const {
    CUtlVector<Glerpdata_t>* vec = GetSchemaValue<CUtlVector<Glerpdata_t>*>(m_ptr, "CTriggerLerpObject", "m_vecLerpingObjects"); std::vector<Glerpdata_t> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCTriggerLerpObject::SetLerpingObjects(std::vector<Glerpdata_t> value) {
    SetSchemaValueCUtlVector<Glerpdata_t>(m_ptr, "CTriggerLerpObject", "m_vecLerpingObjects", false, value);
}
std::string GCTriggerLerpObject::GetLerpEffect() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CTriggerLerpObject", "m_iszLerpEffect").String();
}
void GCTriggerLerpObject::SetLerpEffect(std::string value) {
    SetSchemaValue(m_ptr, "CTriggerLerpObject", "m_iszLerpEffect", false, CUtlSymbolLarge(value.c_str()));
}
std::string GCTriggerLerpObject::GetLerpSound() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CTriggerLerpObject", "m_iszLerpSound").String();
}
void GCTriggerLerpObject::SetLerpSound(std::string value) {
    SetSchemaValue(m_ptr, "CTriggerLerpObject", "m_iszLerpSound", false, CUtlSymbolLarge(value.c_str()));
}
bool GCTriggerLerpObject::GetAttachTouchingObject() const {
    return GetSchemaValue<bool>(m_ptr, "CTriggerLerpObject", "m_bAttachTouchingObject");
}
void GCTriggerLerpObject::SetAttachTouchingObject(bool value) {
    SetSchemaValue(m_ptr, "CTriggerLerpObject", "m_bAttachTouchingObject", false, value);
}
GCBaseEntity GCTriggerLerpObject::GetEntityToWaitForDisconnect() const {
    GCBaseEntity value((void*)(GetSchemaValue<CHandle<CEntityInstance>>(m_ptr, "CTriggerLerpObject", "m_hEntityToWaitForDisconnect").Get()));
    return value;
}
void GCTriggerLerpObject::SetEntityToWaitForDisconnect(GCBaseEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'EntityToWaitForDisconnect' is not possible.\n");
}
GCEntityIOOutput GCTriggerLerpObject::GetOnLerpStarted() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CTriggerLerpObject", "m_OnLerpStarted"));
    return value;
}
void GCTriggerLerpObject::SetOnLerpStarted(GCEntityIOOutput value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'OnLerpStarted' is not possible.\n");
}
GCEntityIOOutput GCTriggerLerpObject::GetOnLerpFinished() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CTriggerLerpObject", "m_OnLerpFinished"));
    return value;
}
void GCTriggerLerpObject::SetOnLerpFinished(GCEntityIOOutput value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'OnLerpFinished' is not possible.\n");
}
void* GCTriggerLerpObject::GetPtr() {
    return m_ptr;
}
std::string GCTriggerLerpObject::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCTriggerLerpObject::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseTrigger GCTriggerLerpObject::GetParent() const {
    GCBaseTrigger value(m_ptr);
    return value;
}
void GCTriggerLerpObject::SetParent(GCBaseTrigger value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCTriggerLerpObject(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCTriggerLerpObject>("CTriggerLerpObject")
        .addConstructor<void (*)(std::string)>()
        .addProperty("LerpTarget", &GCTriggerLerpObject::GetLerpTarget, &GCTriggerLerpObject::SetLerpTarget)
        .addProperty("LerpTarget1", &GCTriggerLerpObject::GetLerpTarget1, &GCTriggerLerpObject::SetLerpTarget1)
        .addProperty("LerpTargetAttachment", &GCTriggerLerpObject::GetLerpTargetAttachment, &GCTriggerLerpObject::SetLerpTargetAttachment)
        .addProperty("LerpDuration", &GCTriggerLerpObject::GetLerpDuration, &GCTriggerLerpObject::SetLerpDuration)
        .addProperty("LerpRestoreMoveType", &GCTriggerLerpObject::GetLerpRestoreMoveType, &GCTriggerLerpObject::SetLerpRestoreMoveType)
        .addProperty("SingleLerpObject", &GCTriggerLerpObject::GetSingleLerpObject, &GCTriggerLerpObject::SetSingleLerpObject)
        .addProperty("LerpingObjects", &GCTriggerLerpObject::GetLerpingObjects, &GCTriggerLerpObject::SetLerpingObjects)
        .addProperty("LerpEffect", &GCTriggerLerpObject::GetLerpEffect, &GCTriggerLerpObject::SetLerpEffect)
        .addProperty("LerpSound", &GCTriggerLerpObject::GetLerpSound, &GCTriggerLerpObject::SetLerpSound)
        .addProperty("AttachTouchingObject", &GCTriggerLerpObject::GetAttachTouchingObject, &GCTriggerLerpObject::SetAttachTouchingObject)
        .addProperty("EntityToWaitForDisconnect", &GCTriggerLerpObject::GetEntityToWaitForDisconnect, &GCTriggerLerpObject::SetEntityToWaitForDisconnect)
        .addProperty("OnLerpStarted", &GCTriggerLerpObject::GetOnLerpStarted, &GCTriggerLerpObject::SetOnLerpStarted)
        .addProperty("OnLerpFinished", &GCTriggerLerpObject::GetOnLerpFinished, &GCTriggerLerpObject::SetOnLerpFinished)
        .addProperty("Parent", &GCTriggerLerpObject::GetParent, &GCTriggerLerpObject::SetParent)
        .addFunction("ToPtr", &GCTriggerLerpObject::ToPtr)
        .addFunction("IsValid", &GCTriggerLerpObject::IsValid)
        .endClass();
}
GCTriggerSoundscape::GCTriggerSoundscape(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCTriggerSoundscape::GCTriggerSoundscape(void *ptr) {
    m_ptr = ptr;
}
GCEnvSoundscapeTriggerable GCTriggerSoundscape::GetSoundscape() const {
    GCEnvSoundscapeTriggerable value((void*)(GetSchemaValue<CHandle<CEntityInstance>>(m_ptr, "CTriggerSoundscape", "m_hSoundscape").Get()));
    return value;
}
void GCTriggerSoundscape::SetSoundscape(GCEnvSoundscapeTriggerable value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Soundscape' is not possible.\n");
}
std::string GCTriggerSoundscape::GetSoundscapeName() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CTriggerSoundscape", "m_SoundscapeName").String();
}
void GCTriggerSoundscape::SetSoundscapeName(std::string value) {
    SetSchemaValue(m_ptr, "CTriggerSoundscape", "m_SoundscapeName", false, CUtlSymbolLarge(value.c_str()));
}
void* GCTriggerSoundscape::GetPtr() {
    return m_ptr;
}
std::string GCTriggerSoundscape::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCTriggerSoundscape::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseTrigger GCTriggerSoundscape::GetParent() const {
    GCBaseTrigger value(m_ptr);
    return value;
}
void GCTriggerSoundscape::SetParent(GCBaseTrigger value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCTriggerSoundscape(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCTriggerSoundscape>("CTriggerSoundscape")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Soundscape", &GCTriggerSoundscape::GetSoundscape, &GCTriggerSoundscape::SetSoundscape)
        .addProperty("SoundscapeName", &GCTriggerSoundscape::GetSoundscapeName, &GCTriggerSoundscape::SetSoundscapeName)
        .addProperty("Parent", &GCTriggerSoundscape::GetParent, &GCTriggerSoundscape::SetParent)
        .addFunction("ToPtr", &GCTriggerSoundscape::ToPtr)
        .addFunction("IsValid", &GCTriggerSoundscape::IsValid)
        .endClass();
}
GCLogicScript::GCLogicScript(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCLogicScript::GCLogicScript(void *ptr) {
    m_ptr = ptr;
}
void* GCLogicScript::GetPtr() {
    return m_ptr;
}
std::string GCLogicScript::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCLogicScript::IsValid() {
    return (m_ptr != nullptr);
}
GCPointEntity GCLogicScript::GetParent() const {
    GCPointEntity value(m_ptr);
    return value;
}
void GCLogicScript::SetParent(GCPointEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCLogicScript(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCLogicScript>("CLogicScript")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCLogicScript::GetParent, &GCLogicScript::SetParent)
        .addFunction("ToPtr", &GCLogicScript::ToPtr)
        .addFunction("IsValid", &GCLogicScript::IsValid)
        .endClass();
}
GCWeaponFiveSeven::GCWeaponFiveSeven(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCWeaponFiveSeven::GCWeaponFiveSeven(void *ptr) {
    m_ptr = ptr;
}
void* GCWeaponFiveSeven::GetPtr() {
    return m_ptr;
}
std::string GCWeaponFiveSeven::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCWeaponFiveSeven::IsValid() {
    return (m_ptr != nullptr);
}
GCCSWeaponBaseGun GCWeaponFiveSeven::GetParent() const {
    GCCSWeaponBaseGun value(m_ptr);
    return value;
}
void GCWeaponFiveSeven::SetParent(GCCSWeaponBaseGun value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCWeaponFiveSeven(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCWeaponFiveSeven>("CWeaponFiveSeven")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCWeaponFiveSeven::GetParent, &GCWeaponFiveSeven::SetParent)
        .addFunction("ToPtr", &GCWeaponFiveSeven::ToPtr)
        .addFunction("IsValid", &GCWeaponFiveSeven::IsValid)
        .endClass();
}
GCTriggerBrush::GCTriggerBrush(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCTriggerBrush::GCTriggerBrush(void *ptr) {
    m_ptr = ptr;
}
GCEntityIOOutput GCTriggerBrush::GetOnStartTouch() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CTriggerBrush", "m_OnStartTouch"));
    return value;
}
void GCTriggerBrush::SetOnStartTouch(GCEntityIOOutput value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'OnStartTouch' is not possible.\n");
}
GCEntityIOOutput GCTriggerBrush::GetOnEndTouch() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CTriggerBrush", "m_OnEndTouch"));
    return value;
}
void GCTriggerBrush::SetOnEndTouch(GCEntityIOOutput value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'OnEndTouch' is not possible.\n");
}
GCEntityIOOutput GCTriggerBrush::GetOnUse() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CTriggerBrush", "m_OnUse"));
    return value;
}
void GCTriggerBrush::SetOnUse(GCEntityIOOutput value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'OnUse' is not possible.\n");
}
int32_t GCTriggerBrush::GetInputFilter() const {
    return GetSchemaValue<int32_t>(m_ptr, "CTriggerBrush", "m_iInputFilter");
}
void GCTriggerBrush::SetInputFilter(int32_t value) {
    SetSchemaValue(m_ptr, "CTriggerBrush", "m_iInputFilter", false, value);
}
int32_t GCTriggerBrush::GetDontMessageParent() const {
    return GetSchemaValue<int32_t>(m_ptr, "CTriggerBrush", "m_iDontMessageParent");
}
void GCTriggerBrush::SetDontMessageParent(int32_t value) {
    SetSchemaValue(m_ptr, "CTriggerBrush", "m_iDontMessageParent", false, value);
}
void* GCTriggerBrush::GetPtr() {
    return m_ptr;
}
std::string GCTriggerBrush::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCTriggerBrush::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseModelEntity GCTriggerBrush::GetParent() const {
    GCBaseModelEntity value(m_ptr);
    return value;
}
void GCTriggerBrush::SetParent(GCBaseModelEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCTriggerBrush(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCTriggerBrush>("CTriggerBrush")
        .addConstructor<void (*)(std::string)>()
        .addProperty("OnStartTouch", &GCTriggerBrush::GetOnStartTouch, &GCTriggerBrush::SetOnStartTouch)
        .addProperty("OnEndTouch", &GCTriggerBrush::GetOnEndTouch, &GCTriggerBrush::SetOnEndTouch)
        .addProperty("OnUse", &GCTriggerBrush::GetOnUse, &GCTriggerBrush::SetOnUse)
        .addProperty("InputFilter", &GCTriggerBrush::GetInputFilter, &GCTriggerBrush::SetInputFilter)
        .addProperty("DontMessageParent", &GCTriggerBrush::GetDontMessageParent, &GCTriggerBrush::SetDontMessageParent)
        .addProperty("Parent", &GCTriggerBrush::GetParent, &GCTriggerBrush::SetParent)
        .addFunction("ToPtr", &GCTriggerBrush::ToPtr)
        .addFunction("IsValid", &GCTriggerBrush::IsValid)
        .endClass();
}
GCPhysicsEntitySolver::GCPhysicsEntitySolver(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCPhysicsEntitySolver::GCPhysicsEntitySolver(void *ptr) {
    m_ptr = ptr;
}
GCBaseEntity GCPhysicsEntitySolver::GetMovingEntity() const {
    GCBaseEntity value((void*)(GetSchemaValue<CHandle<CEntityInstance>>(m_ptr, "CPhysicsEntitySolver", "m_hMovingEntity").Get()));
    return value;
}
void GCPhysicsEntitySolver::SetMovingEntity(GCBaseEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'MovingEntity' is not possible.\n");
}
GCBaseEntity GCPhysicsEntitySolver::GetPhysicsBlocker() const {
    GCBaseEntity value((void*)(GetSchemaValue<CHandle<CEntityInstance>>(m_ptr, "CPhysicsEntitySolver", "m_hPhysicsBlocker").Get()));
    return value;
}
void GCPhysicsEntitySolver::SetPhysicsBlocker(GCBaseEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'PhysicsBlocker' is not possible.\n");
}
float GCPhysicsEntitySolver::GetSeparationDuration() const {
    return GetSchemaValue<float>(m_ptr, "CPhysicsEntitySolver", "m_separationDuration");
}
void GCPhysicsEntitySolver::SetSeparationDuration(float value) {
    SetSchemaValue(m_ptr, "CPhysicsEntitySolver", "m_separationDuration", false, value);
}
float GCPhysicsEntitySolver::GetCancelTime() const {
    return GetSchemaValue<float>(m_ptr, "CPhysicsEntitySolver", "m_cancelTime");
}
void GCPhysicsEntitySolver::SetCancelTime(float value) {
    SetSchemaValue(m_ptr, "CPhysicsEntitySolver", "m_cancelTime", false, value);
}
void* GCPhysicsEntitySolver::GetPtr() {
    return m_ptr;
}
std::string GCPhysicsEntitySolver::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCPhysicsEntitySolver::IsValid() {
    return (m_ptr != nullptr);
}
GCLogicalEntity GCPhysicsEntitySolver::GetParent() const {
    GCLogicalEntity value(m_ptr);
    return value;
}
void GCPhysicsEntitySolver::SetParent(GCLogicalEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCPhysicsEntitySolver(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCPhysicsEntitySolver>("CPhysicsEntitySolver")
        .addConstructor<void (*)(std::string)>()
        .addProperty("MovingEntity", &GCPhysicsEntitySolver::GetMovingEntity, &GCPhysicsEntitySolver::SetMovingEntity)
        .addProperty("PhysicsBlocker", &GCPhysicsEntitySolver::GetPhysicsBlocker, &GCPhysicsEntitySolver::SetPhysicsBlocker)
        .addProperty("SeparationDuration", &GCPhysicsEntitySolver::GetSeparationDuration, &GCPhysicsEntitySolver::SetSeparationDuration)
        .addProperty("CancelTime", &GCPhysicsEntitySolver::GetCancelTime, &GCPhysicsEntitySolver::SetCancelTime)
        .addProperty("Parent", &GCPhysicsEntitySolver::GetParent, &GCPhysicsEntitySolver::SetParent)
        .addFunction("ToPtr", &GCPhysicsEntitySolver::ToPtr)
        .addFunction("IsValid", &GCPhysicsEntitySolver::IsValid)
        .endClass();
}
GCNetworkedSequenceOperation::GCNetworkedSequenceOperation(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCNetworkedSequenceOperation::GCNetworkedSequenceOperation(void *ptr) {
    m_ptr = ptr;
}
float GCNetworkedSequenceOperation::GetPrevCycle() const {
    return GetSchemaValue<float>(m_ptr, "CNetworkedSequenceOperation", "m_flPrevCycle");
}
void GCNetworkedSequenceOperation::SetPrevCycle(float value) {
    SetSchemaValue(m_ptr, "CNetworkedSequenceOperation", "m_flPrevCycle", false, value);
}
float GCNetworkedSequenceOperation::GetCycle() const {
    return GetSchemaValue<float>(m_ptr, "CNetworkedSequenceOperation", "m_flCycle");
}
void GCNetworkedSequenceOperation::SetCycle(float value) {
    SetSchemaValue(m_ptr, "CNetworkedSequenceOperation", "m_flCycle", false, value);
}
float GCNetworkedSequenceOperation::GetWeight() const {
    return GetSchemaValue<float>(m_ptr, "CNetworkedSequenceOperation", "m_flWeight");
}
void GCNetworkedSequenceOperation::SetWeight(float value) {
    SetSchemaValue(m_ptr, "CNetworkedSequenceOperation", "m_flWeight", false, value);
}
bool GCNetworkedSequenceOperation::GetSequenceChangeNetworked() const {
    return GetSchemaValue<bool>(m_ptr, "CNetworkedSequenceOperation", "m_bSequenceChangeNetworked");
}
void GCNetworkedSequenceOperation::SetSequenceChangeNetworked(bool value) {
    SetSchemaValue(m_ptr, "CNetworkedSequenceOperation", "m_bSequenceChangeNetworked", false, value);
}
bool GCNetworkedSequenceOperation::GetDiscontinuity() const {
    return GetSchemaValue<bool>(m_ptr, "CNetworkedSequenceOperation", "m_bDiscontinuity");
}
void GCNetworkedSequenceOperation::SetDiscontinuity(bool value) {
    SetSchemaValue(m_ptr, "CNetworkedSequenceOperation", "m_bDiscontinuity", false, value);
}
float GCNetworkedSequenceOperation::GetPrevCycleFromDiscontinuity() const {
    return GetSchemaValue<float>(m_ptr, "CNetworkedSequenceOperation", "m_flPrevCycleFromDiscontinuity");
}
void GCNetworkedSequenceOperation::SetPrevCycleFromDiscontinuity(float value) {
    SetSchemaValue(m_ptr, "CNetworkedSequenceOperation", "m_flPrevCycleFromDiscontinuity", false, value);
}
float GCNetworkedSequenceOperation::GetPrevCycleForAnimEventDetection() const {
    return GetSchemaValue<float>(m_ptr, "CNetworkedSequenceOperation", "m_flPrevCycleForAnimEventDetection");
}
void GCNetworkedSequenceOperation::SetPrevCycleForAnimEventDetection(float value) {
    SetSchemaValue(m_ptr, "CNetworkedSequenceOperation", "m_flPrevCycleForAnimEventDetection", false, value);
}
void* GCNetworkedSequenceOperation::GetPtr() {
    return m_ptr;
}
std::string GCNetworkedSequenceOperation::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCNetworkedSequenceOperation::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCNetworkedSequenceOperation(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCNetworkedSequenceOperation>("CNetworkedSequenceOperation")
        .addConstructor<void (*)(std::string)>()
        .addProperty("PrevCycle", &GCNetworkedSequenceOperation::GetPrevCycle, &GCNetworkedSequenceOperation::SetPrevCycle)
        .addProperty("Cycle", &GCNetworkedSequenceOperation::GetCycle, &GCNetworkedSequenceOperation::SetCycle)
        .addProperty("Weight", &GCNetworkedSequenceOperation::GetWeight, &GCNetworkedSequenceOperation::SetWeight)
        .addProperty("SequenceChangeNetworked", &GCNetworkedSequenceOperation::GetSequenceChangeNetworked, &GCNetworkedSequenceOperation::SetSequenceChangeNetworked)
        .addProperty("Discontinuity", &GCNetworkedSequenceOperation::GetDiscontinuity, &GCNetworkedSequenceOperation::SetDiscontinuity)
        .addProperty("PrevCycleFromDiscontinuity", &GCNetworkedSequenceOperation::GetPrevCycleFromDiscontinuity, &GCNetworkedSequenceOperation::SetPrevCycleFromDiscontinuity)
        .addProperty("PrevCycleForAnimEventDetection", &GCNetworkedSequenceOperation::GetPrevCycleForAnimEventDetection, &GCNetworkedSequenceOperation::SetPrevCycleForAnimEventDetection)
        .addFunction("ToPtr", &GCNetworkedSequenceOperation::ToPtr)
        .addFunction("IsValid", &GCNetworkedSequenceOperation::IsValid)
        .endClass();
}
GCPointWorldText::GCPointWorldText(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCPointWorldText::GCPointWorldText(void *ptr) {
    m_ptr = ptr;
}
std::string GCPointWorldText::GetMessageText() const {
    return GetSchemaValuePtr<char>(m_ptr, "CPointWorldText", "m_messageText");
}
void GCPointWorldText::SetMessageText(std::string value) {
    WriteSchemaPtrValue(m_ptr, "CPointWorldText", "m_messageText", false, reinterpret_cast<byte*>(const_cast<char*>(value.c_str())), 512);
}
std::string GCPointWorldText::GetFontName() const {
    return GetSchemaValuePtr<char>(m_ptr, "CPointWorldText", "m_FontName");
}
void GCPointWorldText::SetFontName(std::string value) {
    WriteSchemaPtrValue(m_ptr, "CPointWorldText", "m_FontName", false, reinterpret_cast<byte*>(const_cast<char*>(value.c_str())), 64);
}
bool GCPointWorldText::GetEnabled() const {
    return GetSchemaValue<bool>(m_ptr, "CPointWorldText", "m_bEnabled");
}
void GCPointWorldText::SetEnabled(bool value) {
    SetSchemaValue(m_ptr, "CPointWorldText", "m_bEnabled", false, value);
}
bool GCPointWorldText::GetFullbright() const {
    return GetSchemaValue<bool>(m_ptr, "CPointWorldText", "m_bFullbright");
}
void GCPointWorldText::SetFullbright(bool value) {
    SetSchemaValue(m_ptr, "CPointWorldText", "m_bFullbright", false, value);
}
float GCPointWorldText::GetWorldUnitsPerPx() const {
    return GetSchemaValue<float>(m_ptr, "CPointWorldText", "m_flWorldUnitsPerPx");
}
void GCPointWorldText::SetWorldUnitsPerPx(float value) {
    SetSchemaValue(m_ptr, "CPointWorldText", "m_flWorldUnitsPerPx", false, value);
}
float GCPointWorldText::GetFontSize() const {
    return GetSchemaValue<float>(m_ptr, "CPointWorldText", "m_flFontSize");
}
void GCPointWorldText::SetFontSize(float value) {
    SetSchemaValue(m_ptr, "CPointWorldText", "m_flFontSize", false, value);
}
float GCPointWorldText::GetDepthOffset() const {
    return GetSchemaValue<float>(m_ptr, "CPointWorldText", "m_flDepthOffset");
}
void GCPointWorldText::SetDepthOffset(float value) {
    SetSchemaValue(m_ptr, "CPointWorldText", "m_flDepthOffset", false, value);
}
Color GCPointWorldText::GetColor() const {
    return GetSchemaValue<Color>(m_ptr, "CPointWorldText", "m_Color");
}
void GCPointWorldText::SetColor(Color value) {
    SetSchemaValue(m_ptr, "CPointWorldText", "m_Color", false, value);
}
uint64_t GCPointWorldText::GetJustifyHorizontal() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CPointWorldText", "m_nJustifyHorizontal");
}
void GCPointWorldText::SetJustifyHorizontal(uint64_t value) {
    SetSchemaValue(m_ptr, "CPointWorldText", "m_nJustifyHorizontal", false, value);
}
uint64_t GCPointWorldText::GetJustifyVertical() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CPointWorldText", "m_nJustifyVertical");
}
void GCPointWorldText::SetJustifyVertical(uint64_t value) {
    SetSchemaValue(m_ptr, "CPointWorldText", "m_nJustifyVertical", false, value);
}
uint64_t GCPointWorldText::GetReorientMode() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CPointWorldText", "m_nReorientMode");
}
void GCPointWorldText::SetReorientMode(uint64_t value) {
    SetSchemaValue(m_ptr, "CPointWorldText", "m_nReorientMode", false, value);
}
void* GCPointWorldText::GetPtr() {
    return m_ptr;
}
std::string GCPointWorldText::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCPointWorldText::IsValid() {
    return (m_ptr != nullptr);
}
GCModelPointEntity GCPointWorldText::GetParent() const {
    GCModelPointEntity value(m_ptr);
    return value;
}
void GCPointWorldText::SetParent(GCModelPointEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCPointWorldText(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCPointWorldText>("CPointWorldText")
        .addConstructor<void (*)(std::string)>()
        .addProperty("MessageText", &GCPointWorldText::GetMessageText, &GCPointWorldText::SetMessageText)
        .addProperty("FontName", &GCPointWorldText::GetFontName, &GCPointWorldText::SetFontName)
        .addProperty("Enabled", &GCPointWorldText::GetEnabled, &GCPointWorldText::SetEnabled)
        .addProperty("Fullbright", &GCPointWorldText::GetFullbright, &GCPointWorldText::SetFullbright)
        .addProperty("WorldUnitsPerPx", &GCPointWorldText::GetWorldUnitsPerPx, &GCPointWorldText::SetWorldUnitsPerPx)
        .addProperty("FontSize", &GCPointWorldText::GetFontSize, &GCPointWorldText::SetFontSize)
        .addProperty("DepthOffset", &GCPointWorldText::GetDepthOffset, &GCPointWorldText::SetDepthOffset)
        .addProperty("Color", &GCPointWorldText::GetColor, &GCPointWorldText::SetColor)
        .addProperty("JustifyHorizontal", &GCPointWorldText::GetJustifyHorizontal, &GCPointWorldText::SetJustifyHorizontal)
        .addProperty("JustifyVertical", &GCPointWorldText::GetJustifyVertical, &GCPointWorldText::SetJustifyVertical)
        .addProperty("ReorientMode", &GCPointWorldText::GetReorientMode, &GCPointWorldText::SetReorientMode)
        .addProperty("Parent", &GCPointWorldText::GetParent, &GCPointWorldText::SetParent)
        .addFunction("ToPtr", &GCPointWorldText::ToPtr)
        .addFunction("IsValid", &GCPointWorldText::IsValid)
        .endClass();
}
GCSoundAreaEntityOrientedBox::GCSoundAreaEntityOrientedBox(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCSoundAreaEntityOrientedBox::GCSoundAreaEntityOrientedBox(void *ptr) {
    m_ptr = ptr;
}
Vector GCSoundAreaEntityOrientedBox::GetMin() const {
    return GetSchemaValue<Vector>(m_ptr, "CSoundAreaEntityOrientedBox", "m_vMin");
}
void GCSoundAreaEntityOrientedBox::SetMin(Vector value) {
    SetSchemaValue(m_ptr, "CSoundAreaEntityOrientedBox", "m_vMin", false, value);
}
Vector GCSoundAreaEntityOrientedBox::GetMax() const {
    return GetSchemaValue<Vector>(m_ptr, "CSoundAreaEntityOrientedBox", "m_vMax");
}
void GCSoundAreaEntityOrientedBox::SetMax(Vector value) {
    SetSchemaValue(m_ptr, "CSoundAreaEntityOrientedBox", "m_vMax", false, value);
}
void* GCSoundAreaEntityOrientedBox::GetPtr() {
    return m_ptr;
}
std::string GCSoundAreaEntityOrientedBox::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCSoundAreaEntityOrientedBox::IsValid() {
    return (m_ptr != nullptr);
}
GCSoundAreaEntityBase GCSoundAreaEntityOrientedBox::GetParent() const {
    GCSoundAreaEntityBase value(m_ptr);
    return value;
}
void GCSoundAreaEntityOrientedBox::SetParent(GCSoundAreaEntityBase value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCSoundAreaEntityOrientedBox(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCSoundAreaEntityOrientedBox>("CSoundAreaEntityOrientedBox")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Min", &GCSoundAreaEntityOrientedBox::GetMin, &GCSoundAreaEntityOrientedBox::SetMin)
        .addProperty("Max", &GCSoundAreaEntityOrientedBox::GetMax, &GCSoundAreaEntityOrientedBox::SetMax)
        .addProperty("Parent", &GCSoundAreaEntityOrientedBox::GetParent, &GCSoundAreaEntityOrientedBox::SetParent)
        .addFunction("ToPtr", &GCSoundAreaEntityOrientedBox::ToPtr)
        .addFunction("IsValid", &GCSoundAreaEntityOrientedBox::IsValid)
        .endClass();
}
GCTriggerPhysics::GCTriggerPhysics(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCTriggerPhysics::GCTriggerPhysics(void *ptr) {
    m_ptr = ptr;
}
float GCTriggerPhysics::GetGravityScale() const {
    return GetSchemaValue<float>(m_ptr, "CTriggerPhysics", "m_gravityScale");
}
void GCTriggerPhysics::SetGravityScale(float value) {
    SetSchemaValue(m_ptr, "CTriggerPhysics", "m_gravityScale", false, value);
}
float GCTriggerPhysics::GetLinearLimit() const {
    return GetSchemaValue<float>(m_ptr, "CTriggerPhysics", "m_linearLimit");
}
void GCTriggerPhysics::SetLinearLimit(float value) {
    SetSchemaValue(m_ptr, "CTriggerPhysics", "m_linearLimit", false, value);
}
float GCTriggerPhysics::GetLinearDamping() const {
    return GetSchemaValue<float>(m_ptr, "CTriggerPhysics", "m_linearDamping");
}
void GCTriggerPhysics::SetLinearDamping(float value) {
    SetSchemaValue(m_ptr, "CTriggerPhysics", "m_linearDamping", false, value);
}
float GCTriggerPhysics::GetAngularLimit() const {
    return GetSchemaValue<float>(m_ptr, "CTriggerPhysics", "m_angularLimit");
}
void GCTriggerPhysics::SetAngularLimit(float value) {
    SetSchemaValue(m_ptr, "CTriggerPhysics", "m_angularLimit", false, value);
}
float GCTriggerPhysics::GetAngularDamping() const {
    return GetSchemaValue<float>(m_ptr, "CTriggerPhysics", "m_angularDamping");
}
void GCTriggerPhysics::SetAngularDamping(float value) {
    SetSchemaValue(m_ptr, "CTriggerPhysics", "m_angularDamping", false, value);
}
float GCTriggerPhysics::GetLinearForce() const {
    return GetSchemaValue<float>(m_ptr, "CTriggerPhysics", "m_linearForce");
}
void GCTriggerPhysics::SetLinearForce(float value) {
    SetSchemaValue(m_ptr, "CTriggerPhysics", "m_linearForce", false, value);
}
float GCTriggerPhysics::GetFrequency() const {
    return GetSchemaValue<float>(m_ptr, "CTriggerPhysics", "m_flFrequency");
}
void GCTriggerPhysics::SetFrequency(float value) {
    SetSchemaValue(m_ptr, "CTriggerPhysics", "m_flFrequency", false, value);
}
float GCTriggerPhysics::GetDampingRatio() const {
    return GetSchemaValue<float>(m_ptr, "CTriggerPhysics", "m_flDampingRatio");
}
void GCTriggerPhysics::SetDampingRatio(float value) {
    SetSchemaValue(m_ptr, "CTriggerPhysics", "m_flDampingRatio", false, value);
}
Vector GCTriggerPhysics::GetLinearForcePointAt() const {
    return GetSchemaValue<Vector>(m_ptr, "CTriggerPhysics", "m_vecLinearForcePointAt");
}
void GCTriggerPhysics::SetLinearForcePointAt(Vector value) {
    SetSchemaValue(m_ptr, "CTriggerPhysics", "m_vecLinearForcePointAt", false, value);
}
bool GCTriggerPhysics::GetCollapseToForcePoint() const {
    return GetSchemaValue<bool>(m_ptr, "CTriggerPhysics", "m_bCollapseToForcePoint");
}
void GCTriggerPhysics::SetCollapseToForcePoint(bool value) {
    SetSchemaValue(m_ptr, "CTriggerPhysics", "m_bCollapseToForcePoint", false, value);
}
Vector GCTriggerPhysics::GetLinearForcePointAtWorld() const {
    return GetSchemaValue<Vector>(m_ptr, "CTriggerPhysics", "m_vecLinearForcePointAtWorld");
}
void GCTriggerPhysics::SetLinearForcePointAtWorld(Vector value) {
    SetSchemaValue(m_ptr, "CTriggerPhysics", "m_vecLinearForcePointAtWorld", false, value);
}
Vector GCTriggerPhysics::GetLinearForceDirection() const {
    return GetSchemaValue<Vector>(m_ptr, "CTriggerPhysics", "m_vecLinearForceDirection");
}
void GCTriggerPhysics::SetLinearForceDirection(Vector value) {
    SetSchemaValue(m_ptr, "CTriggerPhysics", "m_vecLinearForceDirection", false, value);
}
bool GCTriggerPhysics::GetConvertToDebrisWhenPossible() const {
    return GetSchemaValue<bool>(m_ptr, "CTriggerPhysics", "m_bConvertToDebrisWhenPossible");
}
void GCTriggerPhysics::SetConvertToDebrisWhenPossible(bool value) {
    SetSchemaValue(m_ptr, "CTriggerPhysics", "m_bConvertToDebrisWhenPossible", false, value);
}
void* GCTriggerPhysics::GetPtr() {
    return m_ptr;
}
std::string GCTriggerPhysics::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCTriggerPhysics::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseTrigger GCTriggerPhysics::GetParent() const {
    GCBaseTrigger value(m_ptr);
    return value;
}
void GCTriggerPhysics::SetParent(GCBaseTrigger value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCTriggerPhysics(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCTriggerPhysics>("CTriggerPhysics")
        .addConstructor<void (*)(std::string)>()
        .addProperty("GravityScale", &GCTriggerPhysics::GetGravityScale, &GCTriggerPhysics::SetGravityScale)
        .addProperty("LinearLimit", &GCTriggerPhysics::GetLinearLimit, &GCTriggerPhysics::SetLinearLimit)
        .addProperty("LinearDamping", &GCTriggerPhysics::GetLinearDamping, &GCTriggerPhysics::SetLinearDamping)
        .addProperty("AngularLimit", &GCTriggerPhysics::GetAngularLimit, &GCTriggerPhysics::SetAngularLimit)
        .addProperty("AngularDamping", &GCTriggerPhysics::GetAngularDamping, &GCTriggerPhysics::SetAngularDamping)
        .addProperty("LinearForce", &GCTriggerPhysics::GetLinearForce, &GCTriggerPhysics::SetLinearForce)
        .addProperty("Frequency", &GCTriggerPhysics::GetFrequency, &GCTriggerPhysics::SetFrequency)
        .addProperty("DampingRatio", &GCTriggerPhysics::GetDampingRatio, &GCTriggerPhysics::SetDampingRatio)
        .addProperty("LinearForcePointAt", &GCTriggerPhysics::GetLinearForcePointAt, &GCTriggerPhysics::SetLinearForcePointAt)
        .addProperty("CollapseToForcePoint", &GCTriggerPhysics::GetCollapseToForcePoint, &GCTriggerPhysics::SetCollapseToForcePoint)
        .addProperty("LinearForcePointAtWorld", &GCTriggerPhysics::GetLinearForcePointAtWorld, &GCTriggerPhysics::SetLinearForcePointAtWorld)
        .addProperty("LinearForceDirection", &GCTriggerPhysics::GetLinearForceDirection, &GCTriggerPhysics::SetLinearForceDirection)
        .addProperty("ConvertToDebrisWhenPossible", &GCTriggerPhysics::GetConvertToDebrisWhenPossible, &GCTriggerPhysics::SetConvertToDebrisWhenPossible)
        .addProperty("Parent", &GCTriggerPhysics::GetParent, &GCTriggerPhysics::SetParent)
        .addFunction("ToPtr", &GCTriggerPhysics::ToPtr)
        .addFunction("IsValid", &GCTriggerPhysics::IsValid)
        .endClass();
}
GEntityRenderAttribute_t::GEntityRenderAttribute_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GEntityRenderAttribute_t::GEntityRenderAttribute_t(void *ptr) {
    m_ptr = ptr;
}
uint32_t GEntityRenderAttribute_t::GetID() const {
    return GetSchemaValue<CUtlStringToken>(m_ptr, "EntityRenderAttribute_t", "m_ID").m_nHashCode;
}
void GEntityRenderAttribute_t::SetID(uint32_t value) {
    SetSchemaValue(m_ptr, "EntityRenderAttribute_t", "m_ID", true, CUtlStringToken(value));
}
Vector4D GEntityRenderAttribute_t::GetValues() const {
    return GetSchemaValue<Vector4D>(m_ptr, "EntityRenderAttribute_t", "m_Values");
}
void GEntityRenderAttribute_t::SetValues(Vector4D value) {
    SetSchemaValue(m_ptr, "EntityRenderAttribute_t", "m_Values", true, value);
}
void* GEntityRenderAttribute_t::GetPtr() {
    return m_ptr;
}
std::string GEntityRenderAttribute_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GEntityRenderAttribute_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassEntityRenderAttribute_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GEntityRenderAttribute_t>("EntityRenderAttribute_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("ID", &GEntityRenderAttribute_t::GetID, &GEntityRenderAttribute_t::SetID)
        .addProperty("Values", &GEntityRenderAttribute_t::GetValues, &GEntityRenderAttribute_t::SetValues)
        .addFunction("ToPtr", &GEntityRenderAttribute_t::ToPtr)
        .addFunction("IsValid", &GEntityRenderAttribute_t::IsValid)
        .endClass();
}
GCPointBroadcastClientCommand::GCPointBroadcastClientCommand(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCPointBroadcastClientCommand::GCPointBroadcastClientCommand(void *ptr) {
    m_ptr = ptr;
}
void* GCPointBroadcastClientCommand::GetPtr() {
    return m_ptr;
}
std::string GCPointBroadcastClientCommand::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCPointBroadcastClientCommand::IsValid() {
    return (m_ptr != nullptr);
}
GCPointEntity GCPointBroadcastClientCommand::GetParent() const {
    GCPointEntity value(m_ptr);
    return value;
}
void GCPointBroadcastClientCommand::SetParent(GCPointEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCPointBroadcastClientCommand(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCPointBroadcastClientCommand>("CPointBroadcastClientCommand")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCPointBroadcastClientCommand::GetParent, &GCPointBroadcastClientCommand::SetParent)
        .addFunction("ToPtr", &GCPointBroadcastClientCommand::ToPtr)
        .addFunction("IsValid", &GCPointBroadcastClientCommand::IsValid)
        .endClass();
}
GCFuncShatterglass::GCFuncShatterglass(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCFuncShatterglass::GCFuncShatterglass(void *ptr) {
    m_ptr = ptr;
}
std::vector<uint32> GCFuncShatterglass::GetShatterGlassShards() const {
    CUtlVector<uint32>* vec = GetSchemaValue<CUtlVector<uint32>*>(m_ptr, "CFuncShatterglass", "m_vecShatterGlassShards"); std::vector<uint32> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCFuncShatterglass::SetShatterGlassShards(std::vector<uint32> value) {
    SetSchemaValueCUtlVector<uint32>(m_ptr, "CFuncShatterglass", "m_vecShatterGlassShards", false, value);
}
Vector2D GCFuncShatterglass::GetPanelSize() const {
    return GetSchemaValue<Vector2D>(m_ptr, "CFuncShatterglass", "m_PanelSize");
}
void GCFuncShatterglass::SetPanelSize(Vector2D value) {
    SetSchemaValue(m_ptr, "CFuncShatterglass", "m_PanelSize", false, value);
}
Vector GCFuncShatterglass::GetPanelNormalWs() const {
    return GetSchemaValue<Vector>(m_ptr, "CFuncShatterglass", "m_vecPanelNormalWs");
}
void GCFuncShatterglass::SetPanelNormalWs(Vector value) {
    SetSchemaValue(m_ptr, "CFuncShatterglass", "m_vecPanelNormalWs", false, value);
}
int32_t GCFuncShatterglass::GetNumShardsEverCreated() const {
    return GetSchemaValue<int32_t>(m_ptr, "CFuncShatterglass", "m_nNumShardsEverCreated");
}
void GCFuncShatterglass::SetNumShardsEverCreated(int32_t value) {
    SetSchemaValue(m_ptr, "CFuncShatterglass", "m_nNumShardsEverCreated", false, value);
}
float GCFuncShatterglass::GetLastShatterSoundEmitTime() const {
    return GetSchemaValue<float>(m_ptr, "CFuncShatterglass", "m_flLastShatterSoundEmitTime");
}
void GCFuncShatterglass::SetLastShatterSoundEmitTime(float value) {
    SetSchemaValue(m_ptr, "CFuncShatterglass", "m_flLastShatterSoundEmitTime", false, value);
}
float GCFuncShatterglass::GetLastCleanupTime() const {
    return GetSchemaValue<float>(m_ptr, "CFuncShatterglass", "m_flLastCleanupTime");
}
void GCFuncShatterglass::SetLastCleanupTime(float value) {
    SetSchemaValue(m_ptr, "CFuncShatterglass", "m_flLastCleanupTime", false, value);
}
float GCFuncShatterglass::GetInitAtTime() const {
    return GetSchemaValue<float>(m_ptr, "CFuncShatterglass", "m_flInitAtTime");
}
void GCFuncShatterglass::SetInitAtTime(float value) {
    SetSchemaValue(m_ptr, "CFuncShatterglass", "m_flInitAtTime", false, value);
}
float GCFuncShatterglass::GetGlassThickness() const {
    return GetSchemaValue<float>(m_ptr, "CFuncShatterglass", "m_flGlassThickness");
}
void GCFuncShatterglass::SetGlassThickness(float value) {
    SetSchemaValue(m_ptr, "CFuncShatterglass", "m_flGlassThickness", false, value);
}
float GCFuncShatterglass::GetSpawnInvulnerability() const {
    return GetSchemaValue<float>(m_ptr, "CFuncShatterglass", "m_flSpawnInvulnerability");
}
void GCFuncShatterglass::SetSpawnInvulnerability(float value) {
    SetSchemaValue(m_ptr, "CFuncShatterglass", "m_flSpawnInvulnerability", false, value);
}
bool GCFuncShatterglass::GetBreakSilent() const {
    return GetSchemaValue<bool>(m_ptr, "CFuncShatterglass", "m_bBreakSilent");
}
void GCFuncShatterglass::SetBreakSilent(bool value) {
    SetSchemaValue(m_ptr, "CFuncShatterglass", "m_bBreakSilent", false, value);
}
bool GCFuncShatterglass::GetBreakShardless() const {
    return GetSchemaValue<bool>(m_ptr, "CFuncShatterglass", "m_bBreakShardless");
}
void GCFuncShatterglass::SetBreakShardless(bool value) {
    SetSchemaValue(m_ptr, "CFuncShatterglass", "m_bBreakShardless", false, value);
}
bool GCFuncShatterglass::GetBroken() const {
    return GetSchemaValue<bool>(m_ptr, "CFuncShatterglass", "m_bBroken");
}
void GCFuncShatterglass::SetBroken(bool value) {
    SetSchemaValue(m_ptr, "CFuncShatterglass", "m_bBroken", false, value);
}
bool GCFuncShatterglass::GetHasRateLimitedShards() const {
    return GetSchemaValue<bool>(m_ptr, "CFuncShatterglass", "m_bHasRateLimitedShards");
}
void GCFuncShatterglass::SetHasRateLimitedShards(bool value) {
    SetSchemaValue(m_ptr, "CFuncShatterglass", "m_bHasRateLimitedShards", false, value);
}
bool GCFuncShatterglass::GetGlassNavIgnore() const {
    return GetSchemaValue<bool>(m_ptr, "CFuncShatterglass", "m_bGlassNavIgnore");
}
void GCFuncShatterglass::SetGlassNavIgnore(bool value) {
    SetSchemaValue(m_ptr, "CFuncShatterglass", "m_bGlassNavIgnore", false, value);
}
bool GCFuncShatterglass::GetGlassInFrame() const {
    return GetSchemaValue<bool>(m_ptr, "CFuncShatterglass", "m_bGlassInFrame");
}
void GCFuncShatterglass::SetGlassInFrame(bool value) {
    SetSchemaValue(m_ptr, "CFuncShatterglass", "m_bGlassInFrame", false, value);
}
bool GCFuncShatterglass::GetStartBroken() const {
    return GetSchemaValue<bool>(m_ptr, "CFuncShatterglass", "m_bStartBroken");
}
void GCFuncShatterglass::SetStartBroken(bool value) {
    SetSchemaValue(m_ptr, "CFuncShatterglass", "m_bStartBroken", false, value);
}
uint32_t GCFuncShatterglass::GetInitialDamageType() const {
    return GetSchemaValue<uint32_t>(m_ptr, "CFuncShatterglass", "m_iInitialDamageType");
}
void GCFuncShatterglass::SetInitialDamageType(uint32_t value) {
    SetSchemaValue(m_ptr, "CFuncShatterglass", "m_iInitialDamageType", false, value);
}
std::string GCFuncShatterglass::GetDamagePositioningEntityName01() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CFuncShatterglass", "m_szDamagePositioningEntityName01").String();
}
void GCFuncShatterglass::SetDamagePositioningEntityName01(std::string value) {
    SetSchemaValue(m_ptr, "CFuncShatterglass", "m_szDamagePositioningEntityName01", false, CUtlSymbolLarge(value.c_str()));
}
std::string GCFuncShatterglass::GetDamagePositioningEntityName02() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CFuncShatterglass", "m_szDamagePositioningEntityName02").String();
}
void GCFuncShatterglass::SetDamagePositioningEntityName02(std::string value) {
    SetSchemaValue(m_ptr, "CFuncShatterglass", "m_szDamagePositioningEntityName02", false, CUtlSymbolLarge(value.c_str()));
}
std::string GCFuncShatterglass::GetDamagePositioningEntityName03() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CFuncShatterglass", "m_szDamagePositioningEntityName03").String();
}
void GCFuncShatterglass::SetDamagePositioningEntityName03(std::string value) {
    SetSchemaValue(m_ptr, "CFuncShatterglass", "m_szDamagePositioningEntityName03", false, CUtlSymbolLarge(value.c_str()));
}
std::string GCFuncShatterglass::GetDamagePositioningEntityName04() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CFuncShatterglass", "m_szDamagePositioningEntityName04").String();
}
void GCFuncShatterglass::SetDamagePositioningEntityName04(std::string value) {
    SetSchemaValue(m_ptr, "CFuncShatterglass", "m_szDamagePositioningEntityName04", false, CUtlSymbolLarge(value.c_str()));
}
std::vector<Vector> GCFuncShatterglass::GetInitialDamagePositions() const {
    CUtlVector<Vector>* vec = GetSchemaValue<CUtlVector<Vector>*>(m_ptr, "CFuncShatterglass", "m_vInitialDamagePositions"); std::vector<Vector> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCFuncShatterglass::SetInitialDamagePositions(std::vector<Vector> value) {
    SetSchemaValueCUtlVector<Vector>(m_ptr, "CFuncShatterglass", "m_vInitialDamagePositions", false, value);
}
std::vector<Vector> GCFuncShatterglass::GetExtraDamagePositions() const {
    CUtlVector<Vector>* vec = GetSchemaValue<CUtlVector<Vector>*>(m_ptr, "CFuncShatterglass", "m_vExtraDamagePositions"); std::vector<Vector> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCFuncShatterglass::SetExtraDamagePositions(std::vector<Vector> value) {
    SetSchemaValueCUtlVector<Vector>(m_ptr, "CFuncShatterglass", "m_vExtraDamagePositions", false, value);
}
GCEntityIOOutput GCFuncShatterglass::GetOnBroken() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CFuncShatterglass", "m_OnBroken"));
    return value;
}
void GCFuncShatterglass::SetOnBroken(GCEntityIOOutput value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'OnBroken' is not possible.\n");
}
uint32_t GCFuncShatterglass::GetSurfaceType() const {
    return GetSchemaValue<uint32_t>(m_ptr, "CFuncShatterglass", "m_iSurfaceType");
}
void GCFuncShatterglass::SetSurfaceType(uint32_t value) {
    SetSchemaValue(m_ptr, "CFuncShatterglass", "m_iSurfaceType", false, value);
}
void* GCFuncShatterglass::GetPtr() {
    return m_ptr;
}
std::string GCFuncShatterglass::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCFuncShatterglass::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseModelEntity GCFuncShatterglass::GetParent() const {
    GCBaseModelEntity value(m_ptr);
    return value;
}
void GCFuncShatterglass::SetParent(GCBaseModelEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCFuncShatterglass(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCFuncShatterglass>("CFuncShatterglass")
        .addConstructor<void (*)(std::string)>()
        .addProperty("ShatterGlassShards", &GCFuncShatterglass::GetShatterGlassShards, &GCFuncShatterglass::SetShatterGlassShards)
        .addProperty("PanelSize", &GCFuncShatterglass::GetPanelSize, &GCFuncShatterglass::SetPanelSize)
        .addProperty("PanelNormalWs", &GCFuncShatterglass::GetPanelNormalWs, &GCFuncShatterglass::SetPanelNormalWs)
        .addProperty("NumShardsEverCreated", &GCFuncShatterglass::GetNumShardsEverCreated, &GCFuncShatterglass::SetNumShardsEverCreated)
        .addProperty("LastShatterSoundEmitTime", &GCFuncShatterglass::GetLastShatterSoundEmitTime, &GCFuncShatterglass::SetLastShatterSoundEmitTime)
        .addProperty("LastCleanupTime", &GCFuncShatterglass::GetLastCleanupTime, &GCFuncShatterglass::SetLastCleanupTime)
        .addProperty("InitAtTime", &GCFuncShatterglass::GetInitAtTime, &GCFuncShatterglass::SetInitAtTime)
        .addProperty("GlassThickness", &GCFuncShatterglass::GetGlassThickness, &GCFuncShatterglass::SetGlassThickness)
        .addProperty("SpawnInvulnerability", &GCFuncShatterglass::GetSpawnInvulnerability, &GCFuncShatterglass::SetSpawnInvulnerability)
        .addProperty("BreakSilent", &GCFuncShatterglass::GetBreakSilent, &GCFuncShatterglass::SetBreakSilent)
        .addProperty("BreakShardless", &GCFuncShatterglass::GetBreakShardless, &GCFuncShatterglass::SetBreakShardless)
        .addProperty("Broken", &GCFuncShatterglass::GetBroken, &GCFuncShatterglass::SetBroken)
        .addProperty("HasRateLimitedShards", &GCFuncShatterglass::GetHasRateLimitedShards, &GCFuncShatterglass::SetHasRateLimitedShards)
        .addProperty("GlassNavIgnore", &GCFuncShatterglass::GetGlassNavIgnore, &GCFuncShatterglass::SetGlassNavIgnore)
        .addProperty("GlassInFrame", &GCFuncShatterglass::GetGlassInFrame, &GCFuncShatterglass::SetGlassInFrame)
        .addProperty("StartBroken", &GCFuncShatterglass::GetStartBroken, &GCFuncShatterglass::SetStartBroken)
        .addProperty("InitialDamageType", &GCFuncShatterglass::GetInitialDamageType, &GCFuncShatterglass::SetInitialDamageType)
        .addProperty("DamagePositioningEntityName01", &GCFuncShatterglass::GetDamagePositioningEntityName01, &GCFuncShatterglass::SetDamagePositioningEntityName01)
        .addProperty("DamagePositioningEntityName02", &GCFuncShatterglass::GetDamagePositioningEntityName02, &GCFuncShatterglass::SetDamagePositioningEntityName02)
        .addProperty("DamagePositioningEntityName03", &GCFuncShatterglass::GetDamagePositioningEntityName03, &GCFuncShatterglass::SetDamagePositioningEntityName03)
        .addProperty("DamagePositioningEntityName04", &GCFuncShatterglass::GetDamagePositioningEntityName04, &GCFuncShatterglass::SetDamagePositioningEntityName04)
        .addProperty("InitialDamagePositions", &GCFuncShatterglass::GetInitialDamagePositions, &GCFuncShatterglass::SetInitialDamagePositions)
        .addProperty("ExtraDamagePositions", &GCFuncShatterglass::GetExtraDamagePositions, &GCFuncShatterglass::SetExtraDamagePositions)
        .addProperty("OnBroken", &GCFuncShatterglass::GetOnBroken, &GCFuncShatterglass::SetOnBroken)
        .addProperty("SurfaceType", &GCFuncShatterglass::GetSurfaceType, &GCFuncShatterglass::SetSurfaceType)
        .addProperty("Parent", &GCFuncShatterglass::GetParent, &GCFuncShatterglass::SetParent)
        .addFunction("ToPtr", &GCFuncShatterglass::ToPtr)
        .addFunction("IsValid", &GCFuncShatterglass::IsValid)
        .endClass();
}
GCRotButton::GCRotButton(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCRotButton::GCRotButton(void *ptr) {
    m_ptr = ptr;
}
void* GCRotButton::GetPtr() {
    return m_ptr;
}
std::string GCRotButton::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCRotButton::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseButton GCRotButton::GetParent() const {
    GCBaseButton value(m_ptr);
    return value;
}
void GCRotButton::SetParent(GCBaseButton value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCRotButton(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCRotButton>("CRotButton")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCRotButton::GetParent, &GCRotButton::SetParent)
        .addFunction("ToPtr", &GCRotButton::ToPtr)
        .addFunction("IsValid", &GCRotButton::IsValid)
        .endClass();
}
GCSoundEventSphereEntity::GCSoundEventSphereEntity(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCSoundEventSphereEntity::GCSoundEventSphereEntity(void *ptr) {
    m_ptr = ptr;
}
float GCSoundEventSphereEntity::GetRadius() const {
    return GetSchemaValue<float>(m_ptr, "CSoundEventSphereEntity", "m_flRadius");
}
void GCSoundEventSphereEntity::SetRadius(float value) {
    SetSchemaValue(m_ptr, "CSoundEventSphereEntity", "m_flRadius", false, value);
}
void* GCSoundEventSphereEntity::GetPtr() {
    return m_ptr;
}
std::string GCSoundEventSphereEntity::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCSoundEventSphereEntity::IsValid() {
    return (m_ptr != nullptr);
}
GCSoundEventEntity GCSoundEventSphereEntity::GetParent() const {
    GCSoundEventEntity value(m_ptr);
    return value;
}
void GCSoundEventSphereEntity::SetParent(GCSoundEventEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCSoundEventSphereEntity(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCSoundEventSphereEntity>("CSoundEventSphereEntity")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Radius", &GCSoundEventSphereEntity::GetRadius, &GCSoundEventSphereEntity::SetRadius)
        .addProperty("Parent", &GCSoundEventSphereEntity::GetParent, &GCSoundEventSphereEntity::SetParent)
        .addFunction("ToPtr", &GCSoundEventSphereEntity::ToPtr)
        .addFunction("IsValid", &GCSoundEventSphereEntity::IsValid)
        .endClass();
}
GCWeaponHKP2000::GCWeaponHKP2000(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCWeaponHKP2000::GCWeaponHKP2000(void *ptr) {
    m_ptr = ptr;
}
void* GCWeaponHKP2000::GetPtr() {
    return m_ptr;
}
std::string GCWeaponHKP2000::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCWeaponHKP2000::IsValid() {
    return (m_ptr != nullptr);
}
GCCSWeaponBaseGun GCWeaponHKP2000::GetParent() const {
    GCCSWeaponBaseGun value(m_ptr);
    return value;
}
void GCWeaponHKP2000::SetParent(GCCSWeaponBaseGun value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCWeaponHKP2000(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCWeaponHKP2000>("CWeaponHKP2000")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCWeaponHKP2000::GetParent, &GCWeaponHKP2000::SetParent)
        .addFunction("ToPtr", &GCWeaponHKP2000::ToPtr)
        .addFunction("IsValid", &GCWeaponHKP2000::IsValid)
        .endClass();
}
GCPlantedC4::GCPlantedC4(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCPlantedC4::GCPlantedC4(void *ptr) {
    m_ptr = ptr;
}
bool GCPlantedC4::GetBombTicking() const {
    return GetSchemaValue<bool>(m_ptr, "CPlantedC4", "m_bBombTicking");
}
void GCPlantedC4::SetBombTicking(bool value) {
    SetSchemaValue(m_ptr, "CPlantedC4", "m_bBombTicking", false, value);
}
float GCPlantedC4::GetC4Blow() const {
    return GetSchemaValue<float>(m_ptr, "CPlantedC4", "m_flC4Blow");
}
void GCPlantedC4::SetC4Blow(float value) {
    SetSchemaValue(m_ptr, "CPlantedC4", "m_flC4Blow", false, value);
}
int32_t GCPlantedC4::GetBombSite() const {
    return GetSchemaValue<int32_t>(m_ptr, "CPlantedC4", "m_nBombSite");
}
void GCPlantedC4::SetBombSite(int32_t value) {
    SetSchemaValue(m_ptr, "CPlantedC4", "m_nBombSite", false, value);
}
int32_t GCPlantedC4::GetSourceSoundscapeHash() const {
    return GetSchemaValue<int32_t>(m_ptr, "CPlantedC4", "m_nSourceSoundscapeHash");
}
void GCPlantedC4::SetSourceSoundscapeHash(int32_t value) {
    SetSchemaValue(m_ptr, "CPlantedC4", "m_nSourceSoundscapeHash", false, value);
}
GCEntityIOOutput GCPlantedC4::GetOnBombDefused() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CPlantedC4", "m_OnBombDefused"));
    return value;
}
void GCPlantedC4::SetOnBombDefused(GCEntityIOOutput value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'OnBombDefused' is not possible.\n");
}
GCEntityIOOutput GCPlantedC4::GetOnBombBeginDefuse() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CPlantedC4", "m_OnBombBeginDefuse"));
    return value;
}
void GCPlantedC4::SetOnBombBeginDefuse(GCEntityIOOutput value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'OnBombBeginDefuse' is not possible.\n");
}
GCEntityIOOutput GCPlantedC4::GetOnBombDefuseAborted() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CPlantedC4", "m_OnBombDefuseAborted"));
    return value;
}
void GCPlantedC4::SetOnBombDefuseAborted(GCEntityIOOutput value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'OnBombDefuseAborted' is not possible.\n");
}
bool GCPlantedC4::GetCannotBeDefused() const {
    return GetSchemaValue<bool>(m_ptr, "CPlantedC4", "m_bCannotBeDefused");
}
void GCPlantedC4::SetCannotBeDefused(bool value) {
    SetSchemaValue(m_ptr, "CPlantedC4", "m_bCannotBeDefused", false, value);
}
GEntitySpottedState_t GCPlantedC4::GetEntitySpottedState() const {
    GEntitySpottedState_t value(GetSchemaPtr(m_ptr, "CPlantedC4", "m_entitySpottedState"));
    return value;
}
void GCPlantedC4::SetEntitySpottedState(GEntitySpottedState_t value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'EntitySpottedState' is not possible.\n");
}
int32_t GCPlantedC4::GetSpotRules() const {
    return GetSchemaValue<int32_t>(m_ptr, "CPlantedC4", "m_nSpotRules");
}
void GCPlantedC4::SetSpotRules(int32_t value) {
    SetSchemaValue(m_ptr, "CPlantedC4", "m_nSpotRules", false, value);
}
bool GCPlantedC4::GetTrainingPlacedByPlayer() const {
    return GetSchemaValue<bool>(m_ptr, "CPlantedC4", "m_bTrainingPlacedByPlayer");
}
void GCPlantedC4::SetTrainingPlacedByPlayer(bool value) {
    SetSchemaValue(m_ptr, "CPlantedC4", "m_bTrainingPlacedByPlayer", false, value);
}
bool GCPlantedC4::GetHasExploded() const {
    return GetSchemaValue<bool>(m_ptr, "CPlantedC4", "m_bHasExploded");
}
void GCPlantedC4::SetHasExploded(bool value) {
    SetSchemaValue(m_ptr, "CPlantedC4", "m_bHasExploded", false, value);
}
float GCPlantedC4::GetTimerLength() const {
    return GetSchemaValue<float>(m_ptr, "CPlantedC4", "m_flTimerLength");
}
void GCPlantedC4::SetTimerLength(float value) {
    SetSchemaValue(m_ptr, "CPlantedC4", "m_flTimerLength", false, value);
}
bool GCPlantedC4::GetBeingDefused() const {
    return GetSchemaValue<bool>(m_ptr, "CPlantedC4", "m_bBeingDefused");
}
void GCPlantedC4::SetBeingDefused(bool value) {
    SetSchemaValue(m_ptr, "CPlantedC4", "m_bBeingDefused", false, value);
}
float GCPlantedC4::GetLastDefuseTime() const {
    return GetSchemaValue<float>(m_ptr, "CPlantedC4", "m_fLastDefuseTime");
}
void GCPlantedC4::SetLastDefuseTime(float value) {
    SetSchemaValue(m_ptr, "CPlantedC4", "m_fLastDefuseTime", false, value);
}
float GCPlantedC4::GetDefuseLength() const {
    return GetSchemaValue<float>(m_ptr, "CPlantedC4", "m_flDefuseLength");
}
void GCPlantedC4::SetDefuseLength(float value) {
    SetSchemaValue(m_ptr, "CPlantedC4", "m_flDefuseLength", false, value);
}
float GCPlantedC4::GetDefuseCountDown() const {
    return GetSchemaValue<float>(m_ptr, "CPlantedC4", "m_flDefuseCountDown");
}
void GCPlantedC4::SetDefuseCountDown(float value) {
    SetSchemaValue(m_ptr, "CPlantedC4", "m_flDefuseCountDown", false, value);
}
bool GCPlantedC4::GetBombDefused() const {
    return GetSchemaValue<bool>(m_ptr, "CPlantedC4", "m_bBombDefused");
}
void GCPlantedC4::SetBombDefused(bool value) {
    SetSchemaValue(m_ptr, "CPlantedC4", "m_bBombDefused", false, value);
}
GCCSPlayerPawn GCPlantedC4::GetBombDefuser() const {
    GCCSPlayerPawn value((void*)(GetSchemaValue<CHandle<CEntityInstance>>(m_ptr, "CPlantedC4", "m_hBombDefuser").Get()));
    return value;
}
void GCPlantedC4::SetBombDefuser(GCCSPlayerPawn value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'BombDefuser' is not possible.\n");
}
GCBaseEntity GCPlantedC4::GetControlPanel() const {
    GCBaseEntity value((void*)(GetSchemaValue<CHandle<CEntityInstance>>(m_ptr, "CPlantedC4", "m_hControlPanel").Get()));
    return value;
}
void GCPlantedC4::SetControlPanel(GCBaseEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'ControlPanel' is not possible.\n");
}
int32_t GCPlantedC4::GetProgressBarTime() const {
    return GetSchemaValue<int32_t>(m_ptr, "CPlantedC4", "m_iProgressBarTime");
}
void GCPlantedC4::SetProgressBarTime(int32_t value) {
    SetSchemaValue(m_ptr, "CPlantedC4", "m_iProgressBarTime", false, value);
}
bool GCPlantedC4::GetVoiceAlertFired() const {
    return GetSchemaValue<bool>(m_ptr, "CPlantedC4", "m_bVoiceAlertFired");
}
void GCPlantedC4::SetVoiceAlertFired(bool value) {
    SetSchemaValue(m_ptr, "CPlantedC4", "m_bVoiceAlertFired", false, value);
}
std::vector<bool> GCPlantedC4::GetVoiceAlertPlayed() const {
    bool* outValue = (bool*)GetSchemaPtr(m_ptr, "CPlantedC4", "m_bVoiceAlertPlayed"); std::vector<bool> ret; for(int i = 0; i < 4; i++) { ret.push_back(outValue[i]); } return ret;
}
void GCPlantedC4::SetVoiceAlertPlayed(std::vector<bool> value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'VoiceAlertPlayed' is not possible.\n");
}
float GCPlantedC4::GetNextBotBeepTime() const {
    return GetSchemaValue<float>(m_ptr, "CPlantedC4", "m_flNextBotBeepTime");
}
void GCPlantedC4::SetNextBotBeepTime(float value) {
    SetSchemaValue(m_ptr, "CPlantedC4", "m_flNextBotBeepTime", false, value);
}
QAngle GCPlantedC4::GetCatchUpToPlayerEye() const {
    return GetSchemaValue<QAngle>(m_ptr, "CPlantedC4", "m_angCatchUpToPlayerEye");
}
void GCPlantedC4::SetCatchUpToPlayerEye(QAngle value) {
    SetSchemaValue(m_ptr, "CPlantedC4", "m_angCatchUpToPlayerEye", false, value);
}
float GCPlantedC4::GetLastSpinDetectionTime() const {
    return GetSchemaValue<float>(m_ptr, "CPlantedC4", "m_flLastSpinDetectionTime");
}
void GCPlantedC4::SetLastSpinDetectionTime(float value) {
    SetSchemaValue(m_ptr, "CPlantedC4", "m_flLastSpinDetectionTime", false, value);
}
void* GCPlantedC4::GetPtr() {
    return m_ptr;
}
std::string GCPlantedC4::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCPlantedC4::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseAnimGraph GCPlantedC4::GetParent() const {
    GCBaseAnimGraph value(m_ptr);
    return value;
}
void GCPlantedC4::SetParent(GCBaseAnimGraph value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCPlantedC4(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCPlantedC4>("CPlantedC4")
        .addConstructor<void (*)(std::string)>()
        .addProperty("BombTicking", &GCPlantedC4::GetBombTicking, &GCPlantedC4::SetBombTicking)
        .addProperty("C4Blow", &GCPlantedC4::GetC4Blow, &GCPlantedC4::SetC4Blow)
        .addProperty("BombSite", &GCPlantedC4::GetBombSite, &GCPlantedC4::SetBombSite)
        .addProperty("SourceSoundscapeHash", &GCPlantedC4::GetSourceSoundscapeHash, &GCPlantedC4::SetSourceSoundscapeHash)
        .addProperty("OnBombDefused", &GCPlantedC4::GetOnBombDefused, &GCPlantedC4::SetOnBombDefused)
        .addProperty("OnBombBeginDefuse", &GCPlantedC4::GetOnBombBeginDefuse, &GCPlantedC4::SetOnBombBeginDefuse)
        .addProperty("OnBombDefuseAborted", &GCPlantedC4::GetOnBombDefuseAborted, &GCPlantedC4::SetOnBombDefuseAborted)
        .addProperty("CannotBeDefused", &GCPlantedC4::GetCannotBeDefused, &GCPlantedC4::SetCannotBeDefused)
        .addProperty("EntitySpottedState", &GCPlantedC4::GetEntitySpottedState, &GCPlantedC4::SetEntitySpottedState)
        .addProperty("SpotRules", &GCPlantedC4::GetSpotRules, &GCPlantedC4::SetSpotRules)
        .addProperty("TrainingPlacedByPlayer", &GCPlantedC4::GetTrainingPlacedByPlayer, &GCPlantedC4::SetTrainingPlacedByPlayer)
        .addProperty("HasExploded", &GCPlantedC4::GetHasExploded, &GCPlantedC4::SetHasExploded)
        .addProperty("TimerLength", &GCPlantedC4::GetTimerLength, &GCPlantedC4::SetTimerLength)
        .addProperty("BeingDefused", &GCPlantedC4::GetBeingDefused, &GCPlantedC4::SetBeingDefused)
        .addProperty("LastDefuseTime", &GCPlantedC4::GetLastDefuseTime, &GCPlantedC4::SetLastDefuseTime)
        .addProperty("DefuseLength", &GCPlantedC4::GetDefuseLength, &GCPlantedC4::SetDefuseLength)
        .addProperty("DefuseCountDown", &GCPlantedC4::GetDefuseCountDown, &GCPlantedC4::SetDefuseCountDown)
        .addProperty("BombDefused", &GCPlantedC4::GetBombDefused, &GCPlantedC4::SetBombDefused)
        .addProperty("BombDefuser", &GCPlantedC4::GetBombDefuser, &GCPlantedC4::SetBombDefuser)
        .addProperty("ControlPanel", &GCPlantedC4::GetControlPanel, &GCPlantedC4::SetControlPanel)
        .addProperty("ProgressBarTime", &GCPlantedC4::GetProgressBarTime, &GCPlantedC4::SetProgressBarTime)
        .addProperty("VoiceAlertFired", &GCPlantedC4::GetVoiceAlertFired, &GCPlantedC4::SetVoiceAlertFired)
        .addProperty("VoiceAlertPlayed", &GCPlantedC4::GetVoiceAlertPlayed, &GCPlantedC4::SetVoiceAlertPlayed)
        .addProperty("NextBotBeepTime", &GCPlantedC4::GetNextBotBeepTime, &GCPlantedC4::SetNextBotBeepTime)
        .addProperty("CatchUpToPlayerEye", &GCPlantedC4::GetCatchUpToPlayerEye, &GCPlantedC4::SetCatchUpToPlayerEye)
        .addProperty("LastSpinDetectionTime", &GCPlantedC4::GetLastSpinDetectionTime, &GCPlantedC4::SetLastSpinDetectionTime)
        .addProperty("Parent", &GCPlantedC4::GetParent, &GCPlantedC4::SetParent)
        .addFunction("ToPtr", &GCPlantedC4::ToPtr)
        .addFunction("IsValid", &GCPlantedC4::IsValid)
        .endClass();
}
GCPointClientUIDialog::GCPointClientUIDialog(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCPointClientUIDialog::GCPointClientUIDialog(void *ptr) {
    m_ptr = ptr;
}
GCBaseEntity GCPointClientUIDialog::GetActivator() const {
    GCBaseEntity value((void*)(GetSchemaValue<CHandle<CEntityInstance>>(m_ptr, "CPointClientUIDialog", "m_hActivator").Get()));
    return value;
}
void GCPointClientUIDialog::SetActivator(GCBaseEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Activator' is not possible.\n");
}
bool GCPointClientUIDialog::GetStartEnabled() const {
    return GetSchemaValue<bool>(m_ptr, "CPointClientUIDialog", "m_bStartEnabled");
}
void GCPointClientUIDialog::SetStartEnabled(bool value) {
    SetSchemaValue(m_ptr, "CPointClientUIDialog", "m_bStartEnabled", false, value);
}
void* GCPointClientUIDialog::GetPtr() {
    return m_ptr;
}
std::string GCPointClientUIDialog::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCPointClientUIDialog::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseClientUIEntity GCPointClientUIDialog::GetParent() const {
    GCBaseClientUIEntity value(m_ptr);
    return value;
}
void GCPointClientUIDialog::SetParent(GCBaseClientUIEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCPointClientUIDialog(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCPointClientUIDialog>("CPointClientUIDialog")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Activator", &GCPointClientUIDialog::GetActivator, &GCPointClientUIDialog::SetActivator)
        .addProperty("StartEnabled", &GCPointClientUIDialog::GetStartEnabled, &GCPointClientUIDialog::SetStartEnabled)
        .addProperty("Parent", &GCPointClientUIDialog::GetParent, &GCPointClientUIDialog::SetParent)
        .addFunction("ToPtr", &GCPointClientUIDialog::ToPtr)
        .addFunction("IsValid", &GCPointClientUIDialog::IsValid)
        .endClass();
}
GCEnvSplash::GCEnvSplash(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCEnvSplash::GCEnvSplash(void *ptr) {
    m_ptr = ptr;
}
float GCEnvSplash::GetScale() const {
    return GetSchemaValue<float>(m_ptr, "CEnvSplash", "m_flScale");
}
void GCEnvSplash::SetScale(float value) {
    SetSchemaValue(m_ptr, "CEnvSplash", "m_flScale", false, value);
}
void* GCEnvSplash::GetPtr() {
    return m_ptr;
}
std::string GCEnvSplash::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCEnvSplash::IsValid() {
    return (m_ptr != nullptr);
}
GCPointEntity GCEnvSplash::GetParent() const {
    GCPointEntity value(m_ptr);
    return value;
}
void GCEnvSplash::SetParent(GCPointEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCEnvSplash(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCEnvSplash>("CEnvSplash")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Scale", &GCEnvSplash::GetScale, &GCEnvSplash::SetScale)
        .addProperty("Parent", &GCEnvSplash::GetParent, &GCEnvSplash::SetParent)
        .addFunction("ToPtr", &GCEnvSplash::ToPtr)
        .addFunction("IsValid", &GCEnvSplash::IsValid)
        .endClass();
}
GCSkyCamera::GCSkyCamera(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCSkyCamera::GCSkyCamera(void *ptr) {
    m_ptr = ptr;
}
Gsky3dparams_t GCSkyCamera::GetSkyboxData() const {
    Gsky3dparams_t value(GetSchemaPtr(m_ptr, "CSkyCamera", "m_skyboxData"));
    return value;
}
void GCSkyCamera::SetSkyboxData(Gsky3dparams_t value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'SkyboxData' is not possible.\n");
}
uint32_t GCSkyCamera::GetSkyboxSlotToken() const {
    return GetSchemaValue<CUtlStringToken>(m_ptr, "CSkyCamera", "m_skyboxSlotToken").m_nHashCode;
}
void GCSkyCamera::SetSkyboxSlotToken(uint32_t value) {
    SetSchemaValue(m_ptr, "CSkyCamera", "m_skyboxSlotToken", false, CUtlStringToken(value));
}
bool GCSkyCamera::GetUseAngles() const {
    return GetSchemaValue<bool>(m_ptr, "CSkyCamera", "m_bUseAngles");
}
void GCSkyCamera::SetUseAngles(bool value) {
    SetSchemaValue(m_ptr, "CSkyCamera", "m_bUseAngles", false, value);
}
GCSkyCamera GCSkyCamera::GetNext() const {
    GCSkyCamera value(*(void**)GetSchemaPtr(m_ptr, "CSkyCamera", "m_pNext"));
    return value;
}
void GCSkyCamera::SetNext(GCSkyCamera value) {
    SetSchemaValue(m_ptr, "CSkyCamera","m_pNext", false, (char*)value.GetPtr());
}
void* GCSkyCamera::GetPtr() {
    return m_ptr;
}
std::string GCSkyCamera::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCSkyCamera::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseEntity GCSkyCamera::GetParent() const {
    GCBaseEntity value(m_ptr);
    return value;
}
void GCSkyCamera::SetParent(GCBaseEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCSkyCamera(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCSkyCamera>("CSkyCamera")
        .addConstructor<void (*)(std::string)>()
        .addProperty("SkyboxData", &GCSkyCamera::GetSkyboxData, &GCSkyCamera::SetSkyboxData)
        .addProperty("SkyboxSlotToken", &GCSkyCamera::GetSkyboxSlotToken, &GCSkyCamera::SetSkyboxSlotToken)
        .addProperty("UseAngles", &GCSkyCamera::GetUseAngles, &GCSkyCamera::SetUseAngles)
        .addProperty("Next", &GCSkyCamera::GetNext, &GCSkyCamera::SetNext)
        .addProperty("Parent", &GCSkyCamera::GetParent, &GCSkyCamera::SetParent)
        .addFunction("ToPtr", &GCSkyCamera::ToPtr)
        .addFunction("IsValid", &GCSkyCamera::IsValid)
        .endClass();
}
GCWeaponNOVA::GCWeaponNOVA(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCWeaponNOVA::GCWeaponNOVA(void *ptr) {
    m_ptr = ptr;
}
void* GCWeaponNOVA::GetPtr() {
    return m_ptr;
}
std::string GCWeaponNOVA::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCWeaponNOVA::IsValid() {
    return (m_ptr != nullptr);
}
GCCSWeaponBase GCWeaponNOVA::GetParent() const {
    GCCSWeaponBase value(m_ptr);
    return value;
}
void GCWeaponNOVA::SetParent(GCCSWeaponBase value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCWeaponNOVA(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCWeaponNOVA>("CWeaponNOVA")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCWeaponNOVA::GetParent, &GCWeaponNOVA::SetParent)
        .addFunction("ToPtr", &GCWeaponNOVA::ToPtr)
        .addFunction("IsValid", &GCWeaponNOVA::IsValid)
        .endClass();
}
GCPointCameraVFOV::GCPointCameraVFOV(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCPointCameraVFOV::GCPointCameraVFOV(void *ptr) {
    m_ptr = ptr;
}
float GCPointCameraVFOV::GetVerticalFOV() const {
    return GetSchemaValue<float>(m_ptr, "CPointCameraVFOV", "m_flVerticalFOV");
}
void GCPointCameraVFOV::SetVerticalFOV(float value) {
    SetSchemaValue(m_ptr, "CPointCameraVFOV", "m_flVerticalFOV", false, value);
}
void* GCPointCameraVFOV::GetPtr() {
    return m_ptr;
}
std::string GCPointCameraVFOV::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCPointCameraVFOV::IsValid() {
    return (m_ptr != nullptr);
}
GCPointCamera GCPointCameraVFOV::GetParent() const {
    GCPointCamera value(m_ptr);
    return value;
}
void GCPointCameraVFOV::SetParent(GCPointCamera value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCPointCameraVFOV(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCPointCameraVFOV>("CPointCameraVFOV")
        .addConstructor<void (*)(std::string)>()
        .addProperty("VerticalFOV", &GCPointCameraVFOV::GetVerticalFOV, &GCPointCameraVFOV::SetVerticalFOV)
        .addProperty("Parent", &GCPointCameraVFOV::GetParent, &GCPointCameraVFOV::SetParent)
        .addFunction("ToPtr", &GCPointCameraVFOV::ToPtr)
        .addFunction("IsValid", &GCPointCameraVFOV::IsValid)
        .endClass();
}
GCWeaponTaser::GCWeaponTaser(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCWeaponTaser::GCWeaponTaser(void *ptr) {
    m_ptr = ptr;
}
float GCWeaponTaser::GetFireTime() const {
    return GetSchemaValue<float>(m_ptr, "CWeaponTaser", "m_fFireTime");
}
void GCWeaponTaser::SetFireTime(float value) {
    SetSchemaValue(m_ptr, "CWeaponTaser", "m_fFireTime", false, value);
}
int32_t GCWeaponTaser::GetLastAttackTick() const {
    return GetSchemaValue<int32_t>(m_ptr, "CWeaponTaser", "m_nLastAttackTick");
}
void GCWeaponTaser::SetLastAttackTick(int32_t value) {
    SetSchemaValue(m_ptr, "CWeaponTaser", "m_nLastAttackTick", false, value);
}
void* GCWeaponTaser::GetPtr() {
    return m_ptr;
}
std::string GCWeaponTaser::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCWeaponTaser::IsValid() {
    return (m_ptr != nullptr);
}
GCCSWeaponBaseGun GCWeaponTaser::GetParent() const {
    GCCSWeaponBaseGun value(m_ptr);
    return value;
}
void GCWeaponTaser::SetParent(GCCSWeaponBaseGun value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCWeaponTaser(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCWeaponTaser>("CWeaponTaser")
        .addConstructor<void (*)(std::string)>()
        .addProperty("FireTime", &GCWeaponTaser::GetFireTime, &GCWeaponTaser::SetFireTime)
        .addProperty("LastAttackTick", &GCWeaponTaser::GetLastAttackTick, &GCWeaponTaser::SetLastAttackTick)
        .addProperty("Parent", &GCWeaponTaser::GetParent, &GCWeaponTaser::SetParent)
        .addFunction("ToPtr", &GCWeaponTaser::ToPtr)
        .addFunction("IsValid", &GCWeaponTaser::IsValid)
        .endClass();
}
GCWaterBullet::GCWaterBullet(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCWaterBullet::GCWaterBullet(void *ptr) {
    m_ptr = ptr;
}
void* GCWaterBullet::GetPtr() {
    return m_ptr;
}
std::string GCWaterBullet::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCWaterBullet::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseAnimGraph GCWaterBullet::GetParent() const {
    GCBaseAnimGraph value(m_ptr);
    return value;
}
void GCWaterBullet::SetParent(GCBaseAnimGraph value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCWaterBullet(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCWaterBullet>("CWaterBullet")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCWaterBullet::GetParent, &GCWaterBullet::SetParent)
        .addFunction("ToPtr", &GCWaterBullet::ToPtr)
        .addFunction("IsValid", &GCWaterBullet::IsValid)
        .endClass();
}
GCMarkupVolumeWithRef::GCMarkupVolumeWithRef(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCMarkupVolumeWithRef::GCMarkupVolumeWithRef(void *ptr) {
    m_ptr = ptr;
}
bool GCMarkupVolumeWithRef::GetUseRef() const {
    return GetSchemaValue<bool>(m_ptr, "CMarkupVolumeWithRef", "m_bUseRef");
}
void GCMarkupVolumeWithRef::SetUseRef(bool value) {
    SetSchemaValue(m_ptr, "CMarkupVolumeWithRef", "m_bUseRef", false, value);
}
Vector GCMarkupVolumeWithRef::GetRefPos() const {
    return GetSchemaValue<Vector>(m_ptr, "CMarkupVolumeWithRef", "m_vRefPos");
}
void GCMarkupVolumeWithRef::SetRefPos(Vector value) {
    SetSchemaValue(m_ptr, "CMarkupVolumeWithRef", "m_vRefPos", false, value);
}
float GCMarkupVolumeWithRef::GetRefDot() const {
    return GetSchemaValue<float>(m_ptr, "CMarkupVolumeWithRef", "m_flRefDot");
}
void GCMarkupVolumeWithRef::SetRefDot(float value) {
    SetSchemaValue(m_ptr, "CMarkupVolumeWithRef", "m_flRefDot", false, value);
}
void* GCMarkupVolumeWithRef::GetPtr() {
    return m_ptr;
}
std::string GCMarkupVolumeWithRef::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCMarkupVolumeWithRef::IsValid() {
    return (m_ptr != nullptr);
}
GCMarkupVolumeTagged GCMarkupVolumeWithRef::GetParent() const {
    GCMarkupVolumeTagged value(m_ptr);
    return value;
}
void GCMarkupVolumeWithRef::SetParent(GCMarkupVolumeTagged value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCMarkupVolumeWithRef(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCMarkupVolumeWithRef>("CMarkupVolumeWithRef")
        .addConstructor<void (*)(std::string)>()
        .addProperty("UseRef", &GCMarkupVolumeWithRef::GetUseRef, &GCMarkupVolumeWithRef::SetUseRef)
        .addProperty("RefPos", &GCMarkupVolumeWithRef::GetRefPos, &GCMarkupVolumeWithRef::SetRefPos)
        .addProperty("RefDot", &GCMarkupVolumeWithRef::GetRefDot, &GCMarkupVolumeWithRef::SetRefDot)
        .addProperty("Parent", &GCMarkupVolumeWithRef::GetParent, &GCMarkupVolumeWithRef::SetParent)
        .addFunction("ToPtr", &GCMarkupVolumeWithRef::ToPtr)
        .addFunction("IsValid", &GCMarkupVolumeWithRef::IsValid)
        .endClass();
}
GCMessage::GCMessage(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCMessage::GCMessage(void *ptr) {
    m_ptr = ptr;
}
std::string GCMessage::GetMessage() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CMessage", "m_iszMessage").String();
}
void GCMessage::SetMessage(std::string value) {
    SetSchemaValue(m_ptr, "CMessage", "m_iszMessage", false, CUtlSymbolLarge(value.c_str()));
}
float GCMessage::GetMessageVolume() const {
    return GetSchemaValue<float>(m_ptr, "CMessage", "m_MessageVolume");
}
void GCMessage::SetMessageVolume(float value) {
    SetSchemaValue(m_ptr, "CMessage", "m_MessageVolume", false, value);
}
int32_t GCMessage::GetMessageAttenuation() const {
    return GetSchemaValue<int32_t>(m_ptr, "CMessage", "m_MessageAttenuation");
}
void GCMessage::SetMessageAttenuation(int32_t value) {
    SetSchemaValue(m_ptr, "CMessage", "m_MessageAttenuation", false, value);
}
float GCMessage::GetRadius() const {
    return GetSchemaValue<float>(m_ptr, "CMessage", "m_Radius");
}
void GCMessage::SetRadius(float value) {
    SetSchemaValue(m_ptr, "CMessage", "m_Radius", false, value);
}
std::string GCMessage::GetNoise() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CMessage", "m_sNoise").String();
}
void GCMessage::SetNoise(std::string value) {
    SetSchemaValue(m_ptr, "CMessage", "m_sNoise", false, CUtlSymbolLarge(value.c_str()));
}
GCEntityIOOutput GCMessage::GetOnShowMessage() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CMessage", "m_OnShowMessage"));
    return value;
}
void GCMessage::SetOnShowMessage(GCEntityIOOutput value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'OnShowMessage' is not possible.\n");
}
void* GCMessage::GetPtr() {
    return m_ptr;
}
std::string GCMessage::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCMessage::IsValid() {
    return (m_ptr != nullptr);
}
GCPointEntity GCMessage::GetParent() const {
    GCPointEntity value(m_ptr);
    return value;
}
void GCMessage::SetParent(GCPointEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCMessage(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCMessage>("CMessage")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Message", &GCMessage::GetMessage, &GCMessage::SetMessage)
        .addProperty("MessageVolume", &GCMessage::GetMessageVolume, &GCMessage::SetMessageVolume)
        .addProperty("MessageAttenuation", &GCMessage::GetMessageAttenuation, &GCMessage::SetMessageAttenuation)
        .addProperty("Radius", &GCMessage::GetRadius, &GCMessage::SetRadius)
        .addProperty("Noise", &GCMessage::GetNoise, &GCMessage::SetNoise)
        .addProperty("OnShowMessage", &GCMessage::GetOnShowMessage, &GCMessage::SetOnShowMessage)
        .addProperty("Parent", &GCMessage::GetParent, &GCMessage::SetParent)
        .addFunction("ToPtr", &GCMessage::ToPtr)
        .addFunction("IsValid", &GCMessage::IsValid)
        .endClass();
}
GCLogicGameEventListener::GCLogicGameEventListener(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCLogicGameEventListener::GCLogicGameEventListener(void *ptr) {
    m_ptr = ptr;
}
GCEntityIOOutput GCLogicGameEventListener::GetOnEventFired() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CLogicGameEventListener", "m_OnEventFired"));
    return value;
}
void GCLogicGameEventListener::SetOnEventFired(GCEntityIOOutput value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'OnEventFired' is not possible.\n");
}
std::string GCLogicGameEventListener::GetGameEventName() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CLogicGameEventListener", "m_iszGameEventName").String();
}
void GCLogicGameEventListener::SetGameEventName(std::string value) {
    SetSchemaValue(m_ptr, "CLogicGameEventListener", "m_iszGameEventName", false, CUtlSymbolLarge(value.c_str()));
}
std::string GCLogicGameEventListener::GetGameEventItem() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CLogicGameEventListener", "m_iszGameEventItem").String();
}
void GCLogicGameEventListener::SetGameEventItem(std::string value) {
    SetSchemaValue(m_ptr, "CLogicGameEventListener", "m_iszGameEventItem", false, CUtlSymbolLarge(value.c_str()));
}
bool GCLogicGameEventListener::GetEnabled() const {
    return GetSchemaValue<bool>(m_ptr, "CLogicGameEventListener", "m_bEnabled");
}
void GCLogicGameEventListener::SetEnabled(bool value) {
    SetSchemaValue(m_ptr, "CLogicGameEventListener", "m_bEnabled", false, value);
}
bool GCLogicGameEventListener::GetStartDisabled() const {
    return GetSchemaValue<bool>(m_ptr, "CLogicGameEventListener", "m_bStartDisabled");
}
void GCLogicGameEventListener::SetStartDisabled(bool value) {
    SetSchemaValue(m_ptr, "CLogicGameEventListener", "m_bStartDisabled", false, value);
}
void* GCLogicGameEventListener::GetPtr() {
    return m_ptr;
}
std::string GCLogicGameEventListener::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCLogicGameEventListener::IsValid() {
    return (m_ptr != nullptr);
}
GCLogicalEntity GCLogicGameEventListener::GetParent() const {
    GCLogicalEntity value(m_ptr);
    return value;
}
void GCLogicGameEventListener::SetParent(GCLogicalEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCLogicGameEventListener(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCLogicGameEventListener>("CLogicGameEventListener")
        .addConstructor<void (*)(std::string)>()
        .addProperty("OnEventFired", &GCLogicGameEventListener::GetOnEventFired, &GCLogicGameEventListener::SetOnEventFired)
        .addProperty("GameEventName", &GCLogicGameEventListener::GetGameEventName, &GCLogicGameEventListener::SetGameEventName)
        .addProperty("GameEventItem", &GCLogicGameEventListener::GetGameEventItem, &GCLogicGameEventListener::SetGameEventItem)
        .addProperty("Enabled", &GCLogicGameEventListener::GetEnabled, &GCLogicGameEventListener::SetEnabled)
        .addProperty("StartDisabled", &GCLogicGameEventListener::GetStartDisabled, &GCLogicGameEventListener::SetStartDisabled)
        .addProperty("Parent", &GCLogicGameEventListener::GetParent, &GCLogicGameEventListener::SetParent)
        .addFunction("ToPtr", &GCLogicGameEventListener::ToPtr)
        .addFunction("IsValid", &GCLogicGameEventListener::IsValid)
        .endClass();
}
GCPushable::GCPushable(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCPushable::GCPushable(void *ptr) {
    m_ptr = ptr;
}
void* GCPushable::GetPtr() {
    return m_ptr;
}
std::string GCPushable::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCPushable::IsValid() {
    return (m_ptr != nullptr);
}
GCBreakable GCPushable::GetParent() const {
    GCBreakable value(m_ptr);
    return value;
}
void GCPushable::SetParent(GCBreakable value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCPushable(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCPushable>("CPushable")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCPushable::GetParent, &GCPushable::SetParent)
        .addFunction("ToPtr", &GCPushable::ToPtr)
        .addFunction("IsValid", &GCPushable::IsValid)
        .endClass();
}
GCTriggerRemove::GCTriggerRemove(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCTriggerRemove::GCTriggerRemove(void *ptr) {
    m_ptr = ptr;
}
GCEntityIOOutput GCTriggerRemove::GetOnRemove() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CTriggerRemove", "m_OnRemove"));
    return value;
}
void GCTriggerRemove::SetOnRemove(GCEntityIOOutput value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'OnRemove' is not possible.\n");
}
void* GCTriggerRemove::GetPtr() {
    return m_ptr;
}
std::string GCTriggerRemove::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCTriggerRemove::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseTrigger GCTriggerRemove::GetParent() const {
    GCBaseTrigger value(m_ptr);
    return value;
}
void GCTriggerRemove::SetParent(GCBaseTrigger value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCTriggerRemove(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCTriggerRemove>("CTriggerRemove")
        .addConstructor<void (*)(std::string)>()
        .addProperty("OnRemove", &GCTriggerRemove::GetOnRemove, &GCTriggerRemove::SetOnRemove)
        .addProperty("Parent", &GCTriggerRemove::GetParent, &GCTriggerRemove::SetParent)
        .addFunction("ToPtr", &GCTriggerRemove::ToPtr)
        .addFunction("IsValid", &GCTriggerRemove::IsValid)
        .endClass();
}
GCInfoTarget::GCInfoTarget(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCInfoTarget::GCInfoTarget(void *ptr) {
    m_ptr = ptr;
}
void* GCInfoTarget::GetPtr() {
    return m_ptr;
}
std::string GCInfoTarget::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCInfoTarget::IsValid() {
    return (m_ptr != nullptr);
}
GCPointEntity GCInfoTarget::GetParent() const {
    GCPointEntity value(m_ptr);
    return value;
}
void GCInfoTarget::SetParent(GCPointEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCInfoTarget(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCInfoTarget>("CInfoTarget")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCInfoTarget::GetParent, &GCInfoTarget::SetParent)
        .addFunction("ToPtr", &GCInfoTarget::ToPtr)
        .addFunction("IsValid", &GCInfoTarget::IsValid)
        .endClass();
}
GCMomentaryRotButton::GCMomentaryRotButton(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCMomentaryRotButton::GCMomentaryRotButton(void *ptr) {
    m_ptr = ptr;
}
GCEntityIOOutput GCMomentaryRotButton::GetOnUnpressed() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CMomentaryRotButton", "m_OnUnpressed"));
    return value;
}
void GCMomentaryRotButton::SetOnUnpressed(GCEntityIOOutput value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'OnUnpressed' is not possible.\n");
}
GCEntityIOOutput GCMomentaryRotButton::GetOnFullyOpen() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CMomentaryRotButton", "m_OnFullyOpen"));
    return value;
}
void GCMomentaryRotButton::SetOnFullyOpen(GCEntityIOOutput value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'OnFullyOpen' is not possible.\n");
}
GCEntityIOOutput GCMomentaryRotButton::GetOnFullyClosed() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CMomentaryRotButton", "m_OnFullyClosed"));
    return value;
}
void GCMomentaryRotButton::SetOnFullyClosed(GCEntityIOOutput value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'OnFullyClosed' is not possible.\n");
}
GCEntityIOOutput GCMomentaryRotButton::GetOnReachedPosition() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CMomentaryRotButton", "m_OnReachedPosition"));
    return value;
}
void GCMomentaryRotButton::SetOnReachedPosition(GCEntityIOOutput value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'OnReachedPosition' is not possible.\n");
}
int32_t GCMomentaryRotButton::GetLastUsed() const {
    return GetSchemaValue<int32_t>(m_ptr, "CMomentaryRotButton", "m_lastUsed");
}
void GCMomentaryRotButton::SetLastUsed(int32_t value) {
    SetSchemaValue(m_ptr, "CMomentaryRotButton", "m_lastUsed", false, value);
}
QAngle GCMomentaryRotButton::GetStart() const {
    return GetSchemaValue<QAngle>(m_ptr, "CMomentaryRotButton", "m_start");
}
void GCMomentaryRotButton::SetStart(QAngle value) {
    SetSchemaValue(m_ptr, "CMomentaryRotButton", "m_start", false, value);
}
QAngle GCMomentaryRotButton::GetEnd() const {
    return GetSchemaValue<QAngle>(m_ptr, "CMomentaryRotButton", "m_end");
}
void GCMomentaryRotButton::SetEnd(QAngle value) {
    SetSchemaValue(m_ptr, "CMomentaryRotButton", "m_end", false, value);
}
float GCMomentaryRotButton::GetIdealYaw() const {
    return GetSchemaValue<float>(m_ptr, "CMomentaryRotButton", "m_IdealYaw");
}
void GCMomentaryRotButton::SetIdealYaw(float value) {
    SetSchemaValue(m_ptr, "CMomentaryRotButton", "m_IdealYaw", false, value);
}
std::string GCMomentaryRotButton::GetNoise() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CMomentaryRotButton", "m_sNoise").String();
}
void GCMomentaryRotButton::SetNoise(std::string value) {
    SetSchemaValue(m_ptr, "CMomentaryRotButton", "m_sNoise", false, CUtlSymbolLarge(value.c_str()));
}
bool GCMomentaryRotButton::GetUpdateTarget() const {
    return GetSchemaValue<bool>(m_ptr, "CMomentaryRotButton", "m_bUpdateTarget");
}
void GCMomentaryRotButton::SetUpdateTarget(bool value) {
    SetSchemaValue(m_ptr, "CMomentaryRotButton", "m_bUpdateTarget", false, value);
}
int32_t GCMomentaryRotButton::GetDirection() const {
    return GetSchemaValue<int32_t>(m_ptr, "CMomentaryRotButton", "m_direction");
}
void GCMomentaryRotButton::SetDirection(int32_t value) {
    SetSchemaValue(m_ptr, "CMomentaryRotButton", "m_direction", false, value);
}
float GCMomentaryRotButton::GetReturnSpeed() const {
    return GetSchemaValue<float>(m_ptr, "CMomentaryRotButton", "m_returnSpeed");
}
void GCMomentaryRotButton::SetReturnSpeed(float value) {
    SetSchemaValue(m_ptr, "CMomentaryRotButton", "m_returnSpeed", false, value);
}
float GCMomentaryRotButton::GetStartPosition() const {
    return GetSchemaValue<float>(m_ptr, "CMomentaryRotButton", "m_flStartPosition");
}
void GCMomentaryRotButton::SetStartPosition(float value) {
    SetSchemaValue(m_ptr, "CMomentaryRotButton", "m_flStartPosition", false, value);
}
void* GCMomentaryRotButton::GetPtr() {
    return m_ptr;
}
std::string GCMomentaryRotButton::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCMomentaryRotButton::IsValid() {
    return (m_ptr != nullptr);
}
GCRotButton GCMomentaryRotButton::GetParent() const {
    GCRotButton value(m_ptr);
    return value;
}
void GCMomentaryRotButton::SetParent(GCRotButton value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCMomentaryRotButton(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCMomentaryRotButton>("CMomentaryRotButton")
        .addConstructor<void (*)(std::string)>()
        .addProperty("OnUnpressed", &GCMomentaryRotButton::GetOnUnpressed, &GCMomentaryRotButton::SetOnUnpressed)
        .addProperty("OnFullyOpen", &GCMomentaryRotButton::GetOnFullyOpen, &GCMomentaryRotButton::SetOnFullyOpen)
        .addProperty("OnFullyClosed", &GCMomentaryRotButton::GetOnFullyClosed, &GCMomentaryRotButton::SetOnFullyClosed)
        .addProperty("OnReachedPosition", &GCMomentaryRotButton::GetOnReachedPosition, &GCMomentaryRotButton::SetOnReachedPosition)
        .addProperty("LastUsed", &GCMomentaryRotButton::GetLastUsed, &GCMomentaryRotButton::SetLastUsed)
        .addProperty("Start", &GCMomentaryRotButton::GetStart, &GCMomentaryRotButton::SetStart)
        .addProperty("End", &GCMomentaryRotButton::GetEnd, &GCMomentaryRotButton::SetEnd)
        .addProperty("IdealYaw", &GCMomentaryRotButton::GetIdealYaw, &GCMomentaryRotButton::SetIdealYaw)
        .addProperty("Noise", &GCMomentaryRotButton::GetNoise, &GCMomentaryRotButton::SetNoise)
        .addProperty("UpdateTarget", &GCMomentaryRotButton::GetUpdateTarget, &GCMomentaryRotButton::SetUpdateTarget)
        .addProperty("Direction", &GCMomentaryRotButton::GetDirection, &GCMomentaryRotButton::SetDirection)
        .addProperty("ReturnSpeed", &GCMomentaryRotButton::GetReturnSpeed, &GCMomentaryRotButton::SetReturnSpeed)
        .addProperty("StartPosition", &GCMomentaryRotButton::GetStartPosition, &GCMomentaryRotButton::SetStartPosition)
        .addProperty("Parent", &GCMomentaryRotButton::GetParent, &GCMomentaryRotButton::SetParent)
        .addFunction("ToPtr", &GCMomentaryRotButton::ToPtr)
        .addFunction("IsValid", &GCMomentaryRotButton::IsValid)
        .endClass();
}
GCPropDoorRotating::GCPropDoorRotating(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCPropDoorRotating::GCPropDoorRotating(void *ptr) {
    m_ptr = ptr;
}
Vector GCPropDoorRotating::GetAxis() const {
    return GetSchemaValue<Vector>(m_ptr, "CPropDoorRotating", "m_vecAxis");
}
void GCPropDoorRotating::SetAxis(Vector value) {
    SetSchemaValue(m_ptr, "CPropDoorRotating", "m_vecAxis", false, value);
}
float GCPropDoorRotating::GetDistance() const {
    return GetSchemaValue<float>(m_ptr, "CPropDoorRotating", "m_flDistance");
}
void GCPropDoorRotating::SetDistance(float value) {
    SetSchemaValue(m_ptr, "CPropDoorRotating", "m_flDistance", false, value);
}
uint64_t GCPropDoorRotating::GetSpawnPosition() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CPropDoorRotating", "m_eSpawnPosition");
}
void GCPropDoorRotating::SetSpawnPosition(uint64_t value) {
    SetSchemaValue(m_ptr, "CPropDoorRotating", "m_eSpawnPosition", false, value);
}
uint64_t GCPropDoorRotating::GetOpenDirection() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CPropDoorRotating", "m_eOpenDirection");
}
void GCPropDoorRotating::SetOpenDirection(uint64_t value) {
    SetSchemaValue(m_ptr, "CPropDoorRotating", "m_eOpenDirection", false, value);
}
uint64_t GCPropDoorRotating::GetCurrentOpenDirection() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CPropDoorRotating", "m_eCurrentOpenDirection");
}
void GCPropDoorRotating::SetCurrentOpenDirection(uint64_t value) {
    SetSchemaValue(m_ptr, "CPropDoorRotating", "m_eCurrentOpenDirection", false, value);
}
float GCPropDoorRotating::GetAjarAngle() const {
    return GetSchemaValue<float>(m_ptr, "CPropDoorRotating", "m_flAjarAngle");
}
void GCPropDoorRotating::SetAjarAngle(float value) {
    SetSchemaValue(m_ptr, "CPropDoorRotating", "m_flAjarAngle", false, value);
}
QAngle GCPropDoorRotating::GetRotationAjarDeprecated() const {
    return GetSchemaValue<QAngle>(m_ptr, "CPropDoorRotating", "m_angRotationAjarDeprecated");
}
void GCPropDoorRotating::SetRotationAjarDeprecated(QAngle value) {
    SetSchemaValue(m_ptr, "CPropDoorRotating", "m_angRotationAjarDeprecated", false, value);
}
QAngle GCPropDoorRotating::GetRotationClosed() const {
    return GetSchemaValue<QAngle>(m_ptr, "CPropDoorRotating", "m_angRotationClosed");
}
void GCPropDoorRotating::SetRotationClosed(QAngle value) {
    SetSchemaValue(m_ptr, "CPropDoorRotating", "m_angRotationClosed", false, value);
}
QAngle GCPropDoorRotating::GetRotationOpenForward() const {
    return GetSchemaValue<QAngle>(m_ptr, "CPropDoorRotating", "m_angRotationOpenForward");
}
void GCPropDoorRotating::SetRotationOpenForward(QAngle value) {
    SetSchemaValue(m_ptr, "CPropDoorRotating", "m_angRotationOpenForward", false, value);
}
QAngle GCPropDoorRotating::GetRotationOpenBack() const {
    return GetSchemaValue<QAngle>(m_ptr, "CPropDoorRotating", "m_angRotationOpenBack");
}
void GCPropDoorRotating::SetRotationOpenBack(QAngle value) {
    SetSchemaValue(m_ptr, "CPropDoorRotating", "m_angRotationOpenBack", false, value);
}
QAngle GCPropDoorRotating::GetGoal() const {
    return GetSchemaValue<QAngle>(m_ptr, "CPropDoorRotating", "m_angGoal");
}
void GCPropDoorRotating::SetGoal(QAngle value) {
    SetSchemaValue(m_ptr, "CPropDoorRotating", "m_angGoal", false, value);
}
Vector GCPropDoorRotating::GetForwardBoundsMin() const {
    return GetSchemaValue<Vector>(m_ptr, "CPropDoorRotating", "m_vecForwardBoundsMin");
}
void GCPropDoorRotating::SetForwardBoundsMin(Vector value) {
    SetSchemaValue(m_ptr, "CPropDoorRotating", "m_vecForwardBoundsMin", false, value);
}
Vector GCPropDoorRotating::GetForwardBoundsMax() const {
    return GetSchemaValue<Vector>(m_ptr, "CPropDoorRotating", "m_vecForwardBoundsMax");
}
void GCPropDoorRotating::SetForwardBoundsMax(Vector value) {
    SetSchemaValue(m_ptr, "CPropDoorRotating", "m_vecForwardBoundsMax", false, value);
}
Vector GCPropDoorRotating::GetBackBoundsMin() const {
    return GetSchemaValue<Vector>(m_ptr, "CPropDoorRotating", "m_vecBackBoundsMin");
}
void GCPropDoorRotating::SetBackBoundsMin(Vector value) {
    SetSchemaValue(m_ptr, "CPropDoorRotating", "m_vecBackBoundsMin", false, value);
}
Vector GCPropDoorRotating::GetBackBoundsMax() const {
    return GetSchemaValue<Vector>(m_ptr, "CPropDoorRotating", "m_vecBackBoundsMax");
}
void GCPropDoorRotating::SetBackBoundsMax(Vector value) {
    SetSchemaValue(m_ptr, "CPropDoorRotating", "m_vecBackBoundsMax", false, value);
}
bool GCPropDoorRotating::GetAjarDoorShouldntAlwaysOpen() const {
    return GetSchemaValue<bool>(m_ptr, "CPropDoorRotating", "m_bAjarDoorShouldntAlwaysOpen");
}
void GCPropDoorRotating::SetAjarDoorShouldntAlwaysOpen(bool value) {
    SetSchemaValue(m_ptr, "CPropDoorRotating", "m_bAjarDoorShouldntAlwaysOpen", false, value);
}
GCEntityBlocker GCPropDoorRotating::GetEntityBlocker() const {
    GCEntityBlocker value((void*)(GetSchemaValue<CHandle<CEntityInstance>>(m_ptr, "CPropDoorRotating", "m_hEntityBlocker").Get()));
    return value;
}
void GCPropDoorRotating::SetEntityBlocker(GCEntityBlocker value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'EntityBlocker' is not possible.\n");
}
void* GCPropDoorRotating::GetPtr() {
    return m_ptr;
}
std::string GCPropDoorRotating::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCPropDoorRotating::IsValid() {
    return (m_ptr != nullptr);
}
GCBasePropDoor GCPropDoorRotating::GetParent() const {
    GCBasePropDoor value(m_ptr);
    return value;
}
void GCPropDoorRotating::SetParent(GCBasePropDoor value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCPropDoorRotating(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCPropDoorRotating>("CPropDoorRotating")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Axis", &GCPropDoorRotating::GetAxis, &GCPropDoorRotating::SetAxis)
        .addProperty("Distance", &GCPropDoorRotating::GetDistance, &GCPropDoorRotating::SetDistance)
        .addProperty("SpawnPosition", &GCPropDoorRotating::GetSpawnPosition, &GCPropDoorRotating::SetSpawnPosition)
        .addProperty("OpenDirection", &GCPropDoorRotating::GetOpenDirection, &GCPropDoorRotating::SetOpenDirection)
        .addProperty("CurrentOpenDirection", &GCPropDoorRotating::GetCurrentOpenDirection, &GCPropDoorRotating::SetCurrentOpenDirection)
        .addProperty("AjarAngle", &GCPropDoorRotating::GetAjarAngle, &GCPropDoorRotating::SetAjarAngle)
        .addProperty("RotationAjarDeprecated", &GCPropDoorRotating::GetRotationAjarDeprecated, &GCPropDoorRotating::SetRotationAjarDeprecated)
        .addProperty("RotationClosed", &GCPropDoorRotating::GetRotationClosed, &GCPropDoorRotating::SetRotationClosed)
        .addProperty("RotationOpenForward", &GCPropDoorRotating::GetRotationOpenForward, &GCPropDoorRotating::SetRotationOpenForward)
        .addProperty("RotationOpenBack", &GCPropDoorRotating::GetRotationOpenBack, &GCPropDoorRotating::SetRotationOpenBack)
        .addProperty("Goal", &GCPropDoorRotating::GetGoal, &GCPropDoorRotating::SetGoal)
        .addProperty("ForwardBoundsMin", &GCPropDoorRotating::GetForwardBoundsMin, &GCPropDoorRotating::SetForwardBoundsMin)
        .addProperty("ForwardBoundsMax", &GCPropDoorRotating::GetForwardBoundsMax, &GCPropDoorRotating::SetForwardBoundsMax)
        .addProperty("BackBoundsMin", &GCPropDoorRotating::GetBackBoundsMin, &GCPropDoorRotating::SetBackBoundsMin)
        .addProperty("BackBoundsMax", &GCPropDoorRotating::GetBackBoundsMax, &GCPropDoorRotating::SetBackBoundsMax)
        .addProperty("AjarDoorShouldntAlwaysOpen", &GCPropDoorRotating::GetAjarDoorShouldntAlwaysOpen, &GCPropDoorRotating::SetAjarDoorShouldntAlwaysOpen)
        .addProperty("EntityBlocker", &GCPropDoorRotating::GetEntityBlocker, &GCPropDoorRotating::SetEntityBlocker)
        .addProperty("Parent", &GCPropDoorRotating::GetParent, &GCPropDoorRotating::SetParent)
        .addFunction("ToPtr", &GCPropDoorRotating::ToPtr)
        .addFunction("IsValid", &GCPropDoorRotating::IsValid)
        .endClass();
}
Ghudtextparms_t::Ghudtextparms_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
Ghudtextparms_t::Ghudtextparms_t(void *ptr) {
    m_ptr = ptr;
}
Color Ghudtextparms_t::GetColor1() const {
    return GetSchemaValue<Color>(m_ptr, "hudtextparms_t", "color1");
}
void Ghudtextparms_t::SetColor1(Color value) {
    SetSchemaValue(m_ptr, "hudtextparms_t", "color1", true, value);
}
Color Ghudtextparms_t::GetColor2() const {
    return GetSchemaValue<Color>(m_ptr, "hudtextparms_t", "color2");
}
void Ghudtextparms_t::SetColor2(Color value) {
    SetSchemaValue(m_ptr, "hudtextparms_t", "color2", true, value);
}
uint32_t Ghudtextparms_t::GetEffect() const {
    return GetSchemaValue<uint32_t>(m_ptr, "hudtextparms_t", "effect");
}
void Ghudtextparms_t::SetEffect(uint32_t value) {
    SetSchemaValue(m_ptr, "hudtextparms_t", "effect", true, value);
}
uint32_t Ghudtextparms_t::GetChannel() const {
    return GetSchemaValue<uint32_t>(m_ptr, "hudtextparms_t", "channel");
}
void Ghudtextparms_t::SetChannel(uint32_t value) {
    SetSchemaValue(m_ptr, "hudtextparms_t", "channel", true, value);
}
float Ghudtextparms_t::GetX() const {
    return GetSchemaValue<float>(m_ptr, "hudtextparms_t", "x");
}
void Ghudtextparms_t::SetX(float value) {
    SetSchemaValue(m_ptr, "hudtextparms_t", "x", true, value);
}
float Ghudtextparms_t::GetY() const {
    return GetSchemaValue<float>(m_ptr, "hudtextparms_t", "y");
}
void Ghudtextparms_t::SetY(float value) {
    SetSchemaValue(m_ptr, "hudtextparms_t", "y", true, value);
}
void* Ghudtextparms_t::GetPtr() {
    return m_ptr;
}
std::string Ghudtextparms_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool Ghudtextparms_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClasshudtextparms_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<Ghudtextparms_t>("hudtextparms_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Color1", &Ghudtextparms_t::GetColor1, &Ghudtextparms_t::SetColor1)
        .addProperty("Color2", &Ghudtextparms_t::GetColor2, &Ghudtextparms_t::SetColor2)
        .addProperty("Effect", &Ghudtextparms_t::GetEffect, &Ghudtextparms_t::SetEffect)
        .addProperty("Channel", &Ghudtextparms_t::GetChannel, &Ghudtextparms_t::SetChannel)
        .addProperty("X", &Ghudtextparms_t::GetX, &Ghudtextparms_t::SetX)
        .addProperty("Y", &Ghudtextparms_t::GetY, &Ghudtextparms_t::SetY)
        .addFunction("ToPtr", &Ghudtextparms_t::ToPtr)
        .addFunction("IsValid", &Ghudtextparms_t::IsValid)
        .endClass();
}
GCWeaponMP5SD::GCWeaponMP5SD(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCWeaponMP5SD::GCWeaponMP5SD(void *ptr) {
    m_ptr = ptr;
}
void* GCWeaponMP5SD::GetPtr() {
    return m_ptr;
}
std::string GCWeaponMP5SD::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCWeaponMP5SD::IsValid() {
    return (m_ptr != nullptr);
}
GCCSWeaponBaseGun GCWeaponMP5SD::GetParent() const {
    GCCSWeaponBaseGun value(m_ptr);
    return value;
}
void GCWeaponMP5SD::SetParent(GCCSWeaponBaseGun value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCWeaponMP5SD(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCWeaponMP5SD>("CWeaponMP5SD")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCWeaponMP5SD::GetParent, &GCWeaponMP5SD::SetParent)
        .addFunction("ToPtr", &GCWeaponMP5SD::ToPtr)
        .addFunction("IsValid", &GCWeaponMP5SD::IsValid)
        .endClass();
}
GCTextureBasedAnimatable::GCTextureBasedAnimatable(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCTextureBasedAnimatable::GCTextureBasedAnimatable(void *ptr) {
    m_ptr = ptr;
}
bool GCTextureBasedAnimatable::GetLoop() const {
    return GetSchemaValue<bool>(m_ptr, "CTextureBasedAnimatable", "m_bLoop");
}
void GCTextureBasedAnimatable::SetLoop(bool value) {
    SetSchemaValue(m_ptr, "CTextureBasedAnimatable", "m_bLoop", false, value);
}
float GCTextureBasedAnimatable::GetFPS() const {
    return GetSchemaValue<float>(m_ptr, "CTextureBasedAnimatable", "m_flFPS");
}
void GCTextureBasedAnimatable::SetFPS(float value) {
    SetSchemaValue(m_ptr, "CTextureBasedAnimatable", "m_flFPS", false, value);
}
Vector GCTextureBasedAnimatable::GetAnimationBoundsMin() const {
    return GetSchemaValue<Vector>(m_ptr, "CTextureBasedAnimatable", "m_vAnimationBoundsMin");
}
void GCTextureBasedAnimatable::SetAnimationBoundsMin(Vector value) {
    SetSchemaValue(m_ptr, "CTextureBasedAnimatable", "m_vAnimationBoundsMin", false, value);
}
Vector GCTextureBasedAnimatable::GetAnimationBoundsMax() const {
    return GetSchemaValue<Vector>(m_ptr, "CTextureBasedAnimatable", "m_vAnimationBoundsMax");
}
void GCTextureBasedAnimatable::SetAnimationBoundsMax(Vector value) {
    SetSchemaValue(m_ptr, "CTextureBasedAnimatable", "m_vAnimationBoundsMax", false, value);
}
float GCTextureBasedAnimatable::GetStartTime() const {
    return GetSchemaValue<float>(m_ptr, "CTextureBasedAnimatable", "m_flStartTime");
}
void GCTextureBasedAnimatable::SetStartTime(float value) {
    SetSchemaValue(m_ptr, "CTextureBasedAnimatable", "m_flStartTime", false, value);
}
float GCTextureBasedAnimatable::GetStartFrame() const {
    return GetSchemaValue<float>(m_ptr, "CTextureBasedAnimatable", "m_flStartFrame");
}
void GCTextureBasedAnimatable::SetStartFrame(float value) {
    SetSchemaValue(m_ptr, "CTextureBasedAnimatable", "m_flStartFrame", false, value);
}
void* GCTextureBasedAnimatable::GetPtr() {
    return m_ptr;
}
std::string GCTextureBasedAnimatable::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCTextureBasedAnimatable::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseModelEntity GCTextureBasedAnimatable::GetParent() const {
    GCBaseModelEntity value(m_ptr);
    return value;
}
void GCTextureBasedAnimatable::SetParent(GCBaseModelEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCTextureBasedAnimatable(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCTextureBasedAnimatable>("CTextureBasedAnimatable")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Loop", &GCTextureBasedAnimatable::GetLoop, &GCTextureBasedAnimatable::SetLoop)
        .addProperty("FPS", &GCTextureBasedAnimatable::GetFPS, &GCTextureBasedAnimatable::SetFPS)
        .addProperty("AnimationBoundsMin", &GCTextureBasedAnimatable::GetAnimationBoundsMin, &GCTextureBasedAnimatable::SetAnimationBoundsMin)
        .addProperty("AnimationBoundsMax", &GCTextureBasedAnimatable::GetAnimationBoundsMax, &GCTextureBasedAnimatable::SetAnimationBoundsMax)
        .addProperty("StartTime", &GCTextureBasedAnimatable::GetStartTime, &GCTextureBasedAnimatable::SetStartTime)
        .addProperty("StartFrame", &GCTextureBasedAnimatable::GetStartFrame, &GCTextureBasedAnimatable::SetStartFrame)
        .addProperty("Parent", &GCTextureBasedAnimatable::GetParent, &GCTextureBasedAnimatable::SetParent)
        .addFunction("ToPtr", &GCTextureBasedAnimatable::ToPtr)
        .addFunction("IsValid", &GCTextureBasedAnimatable::IsValid)
        .endClass();
}
GCMarkupVolumeTagged_NavGame::GCMarkupVolumeTagged_NavGame(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCMarkupVolumeTagged_NavGame::GCMarkupVolumeTagged_NavGame(void *ptr) {
    m_ptr = ptr;
}
bool GCMarkupVolumeTagged_NavGame::GetFloodFillAttribute() const {
    return GetSchemaValue<bool>(m_ptr, "CMarkupVolumeTagged_NavGame", "m_bFloodFillAttribute");
}
void GCMarkupVolumeTagged_NavGame::SetFloodFillAttribute(bool value) {
    SetSchemaValue(m_ptr, "CMarkupVolumeTagged_NavGame", "m_bFloodFillAttribute", false, value);
}
void* GCMarkupVolumeTagged_NavGame::GetPtr() {
    return m_ptr;
}
std::string GCMarkupVolumeTagged_NavGame::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCMarkupVolumeTagged_NavGame::IsValid() {
    return (m_ptr != nullptr);
}
GCMarkupVolumeWithRef GCMarkupVolumeTagged_NavGame::GetParent() const {
    GCMarkupVolumeWithRef value(m_ptr);
    return value;
}
void GCMarkupVolumeTagged_NavGame::SetParent(GCMarkupVolumeWithRef value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCMarkupVolumeTagged_NavGame(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCMarkupVolumeTagged_NavGame>("CMarkupVolumeTagged_NavGame")
        .addConstructor<void (*)(std::string)>()
        .addProperty("FloodFillAttribute", &GCMarkupVolumeTagged_NavGame::GetFloodFillAttribute, &GCMarkupVolumeTagged_NavGame::SetFloodFillAttribute)
        .addProperty("Parent", &GCMarkupVolumeTagged_NavGame::GetParent, &GCMarkupVolumeTagged_NavGame::SetParent)
        .addFunction("ToPtr", &GCMarkupVolumeTagged_NavGame::ToPtr)
        .addFunction("IsValid", &GCMarkupVolumeTagged_NavGame::IsValid)
        .endClass();
}
GCPhysThruster::GCPhysThruster(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCPhysThruster::GCPhysThruster(void *ptr) {
    m_ptr = ptr;
}
Vector GCPhysThruster::GetLocalOrigin() const {
    return GetSchemaValue<Vector>(m_ptr, "CPhysThruster", "m_localOrigin");
}
void GCPhysThruster::SetLocalOrigin(Vector value) {
    SetSchemaValue(m_ptr, "CPhysThruster", "m_localOrigin", false, value);
}
void* GCPhysThruster::GetPtr() {
    return m_ptr;
}
std::string GCPhysThruster::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCPhysThruster::IsValid() {
    return (m_ptr != nullptr);
}
GCPhysForce GCPhysThruster::GetParent() const {
    GCPhysForce value(m_ptr);
    return value;
}
void GCPhysThruster::SetParent(GCPhysForce value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCPhysThruster(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCPhysThruster>("CPhysThruster")
        .addConstructor<void (*)(std::string)>()
        .addProperty("LocalOrigin", &GCPhysThruster::GetLocalOrigin, &GCPhysThruster::SetLocalOrigin)
        .addProperty("Parent", &GCPhysThruster::GetParent, &GCPhysThruster::SetParent)
        .addFunction("ToPtr", &GCPhysThruster::ToPtr)
        .addFunction("IsValid", &GCPhysThruster::IsValid)
        .endClass();
}
GCCSPointScriptExtensions_player::GCCSPointScriptExtensions_player(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCCSPointScriptExtensions_player::GCCSPointScriptExtensions_player(void *ptr) {
    m_ptr = ptr;
}
void* GCCSPointScriptExtensions_player::GetPtr() {
    return m_ptr;
}
std::string GCCSPointScriptExtensions_player::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCCSPointScriptExtensions_player::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCCSPointScriptExtensions_player(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCCSPointScriptExtensions_player>("CCSPointScriptExtensions_player")
        .addConstructor<void (*)(std::string)>()
        .addFunction("ToPtr", &GCCSPointScriptExtensions_player::ToPtr)
        .addFunction("IsValid", &GCCSPointScriptExtensions_player::IsValid)
        .endClass();
}
GCCitadelSoundOpvarSetOBB::GCCitadelSoundOpvarSetOBB(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCCitadelSoundOpvarSetOBB::GCCitadelSoundOpvarSetOBB(void *ptr) {
    m_ptr = ptr;
}
std::string GCCitadelSoundOpvarSetOBB::GetStackName() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CCitadelSoundOpvarSetOBB", "m_iszStackName").String();
}
void GCCitadelSoundOpvarSetOBB::SetStackName(std::string value) {
    SetSchemaValue(m_ptr, "CCitadelSoundOpvarSetOBB", "m_iszStackName", false, CUtlSymbolLarge(value.c_str()));
}
std::string GCCitadelSoundOpvarSetOBB::GetOperatorName() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CCitadelSoundOpvarSetOBB", "m_iszOperatorName").String();
}
void GCCitadelSoundOpvarSetOBB::SetOperatorName(std::string value) {
    SetSchemaValue(m_ptr, "CCitadelSoundOpvarSetOBB", "m_iszOperatorName", false, CUtlSymbolLarge(value.c_str()));
}
std::string GCCitadelSoundOpvarSetOBB::GetOpvarName() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CCitadelSoundOpvarSetOBB", "m_iszOpvarName").String();
}
void GCCitadelSoundOpvarSetOBB::SetOpvarName(std::string value) {
    SetSchemaValue(m_ptr, "CCitadelSoundOpvarSetOBB", "m_iszOpvarName", false, CUtlSymbolLarge(value.c_str()));
}
Vector GCCitadelSoundOpvarSetOBB::GetDistanceInnerMins() const {
    return GetSchemaValue<Vector>(m_ptr, "CCitadelSoundOpvarSetOBB", "m_vDistanceInnerMins");
}
void GCCitadelSoundOpvarSetOBB::SetDistanceInnerMins(Vector value) {
    SetSchemaValue(m_ptr, "CCitadelSoundOpvarSetOBB", "m_vDistanceInnerMins", false, value);
}
Vector GCCitadelSoundOpvarSetOBB::GetDistanceInnerMaxs() const {
    return GetSchemaValue<Vector>(m_ptr, "CCitadelSoundOpvarSetOBB", "m_vDistanceInnerMaxs");
}
void GCCitadelSoundOpvarSetOBB::SetDistanceInnerMaxs(Vector value) {
    SetSchemaValue(m_ptr, "CCitadelSoundOpvarSetOBB", "m_vDistanceInnerMaxs", false, value);
}
Vector GCCitadelSoundOpvarSetOBB::GetDistanceOuterMins() const {
    return GetSchemaValue<Vector>(m_ptr, "CCitadelSoundOpvarSetOBB", "m_vDistanceOuterMins");
}
void GCCitadelSoundOpvarSetOBB::SetDistanceOuterMins(Vector value) {
    SetSchemaValue(m_ptr, "CCitadelSoundOpvarSetOBB", "m_vDistanceOuterMins", false, value);
}
Vector GCCitadelSoundOpvarSetOBB::GetDistanceOuterMaxs() const {
    return GetSchemaValue<Vector>(m_ptr, "CCitadelSoundOpvarSetOBB", "m_vDistanceOuterMaxs");
}
void GCCitadelSoundOpvarSetOBB::SetDistanceOuterMaxs(Vector value) {
    SetSchemaValue(m_ptr, "CCitadelSoundOpvarSetOBB", "m_vDistanceOuterMaxs", false, value);
}
int32_t GCCitadelSoundOpvarSetOBB::GetAABBDirection() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCitadelSoundOpvarSetOBB", "m_nAABBDirection");
}
void GCCitadelSoundOpvarSetOBB::SetAABBDirection(int32_t value) {
    SetSchemaValue(m_ptr, "CCitadelSoundOpvarSetOBB", "m_nAABBDirection", false, value);
}
void* GCCitadelSoundOpvarSetOBB::GetPtr() {
    return m_ptr;
}
std::string GCCitadelSoundOpvarSetOBB::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCCitadelSoundOpvarSetOBB::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseEntity GCCitadelSoundOpvarSetOBB::GetParent() const {
    GCBaseEntity value(m_ptr);
    return value;
}
void GCCitadelSoundOpvarSetOBB::SetParent(GCBaseEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCCitadelSoundOpvarSetOBB(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCCitadelSoundOpvarSetOBB>("CCitadelSoundOpvarSetOBB")
        .addConstructor<void (*)(std::string)>()
        .addProperty("StackName", &GCCitadelSoundOpvarSetOBB::GetStackName, &GCCitadelSoundOpvarSetOBB::SetStackName)
        .addProperty("OperatorName", &GCCitadelSoundOpvarSetOBB::GetOperatorName, &GCCitadelSoundOpvarSetOBB::SetOperatorName)
        .addProperty("OpvarName", &GCCitadelSoundOpvarSetOBB::GetOpvarName, &GCCitadelSoundOpvarSetOBB::SetOpvarName)
        .addProperty("DistanceInnerMins", &GCCitadelSoundOpvarSetOBB::GetDistanceInnerMins, &GCCitadelSoundOpvarSetOBB::SetDistanceInnerMins)
        .addProperty("DistanceInnerMaxs", &GCCitadelSoundOpvarSetOBB::GetDistanceInnerMaxs, &GCCitadelSoundOpvarSetOBB::SetDistanceInnerMaxs)
        .addProperty("DistanceOuterMins", &GCCitadelSoundOpvarSetOBB::GetDistanceOuterMins, &GCCitadelSoundOpvarSetOBB::SetDistanceOuterMins)
        .addProperty("DistanceOuterMaxs", &GCCitadelSoundOpvarSetOBB::GetDistanceOuterMaxs, &GCCitadelSoundOpvarSetOBB::SetDistanceOuterMaxs)
        .addProperty("AABBDirection", &GCCitadelSoundOpvarSetOBB::GetAABBDirection, &GCCitadelSoundOpvarSetOBB::SetAABBDirection)
        .addProperty("Parent", &GCCitadelSoundOpvarSetOBB::GetParent, &GCCitadelSoundOpvarSetOBB::SetParent)
        .addFunction("ToPtr", &GCCitadelSoundOpvarSetOBB::ToPtr)
        .addFunction("IsValid", &GCCitadelSoundOpvarSetOBB::IsValid)
        .endClass();
}
GSellbackPurchaseEntry_t::GSellbackPurchaseEntry_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GSellbackPurchaseEntry_t::GSellbackPurchaseEntry_t(void *ptr) {
    m_ptr = ptr;
}
uint16_t GSellbackPurchaseEntry_t::GetDefIdx() const {
    return GetSchemaValue<uint16_t>(m_ptr, "SellbackPurchaseEntry_t", "m_unDefIdx");
}
void GSellbackPurchaseEntry_t::SetDefIdx(uint16_t value) {
    SetSchemaValue(m_ptr, "SellbackPurchaseEntry_t", "m_unDefIdx", true, value);
}
int32_t GSellbackPurchaseEntry_t::GetCost() const {
    return GetSchemaValue<int32_t>(m_ptr, "SellbackPurchaseEntry_t", "m_nCost");
}
void GSellbackPurchaseEntry_t::SetCost(int32_t value) {
    SetSchemaValue(m_ptr, "SellbackPurchaseEntry_t", "m_nCost", true, value);
}
int32_t GSellbackPurchaseEntry_t::GetPrevArmor() const {
    return GetSchemaValue<int32_t>(m_ptr, "SellbackPurchaseEntry_t", "m_nPrevArmor");
}
void GSellbackPurchaseEntry_t::SetPrevArmor(int32_t value) {
    SetSchemaValue(m_ptr, "SellbackPurchaseEntry_t", "m_nPrevArmor", true, value);
}
bool GSellbackPurchaseEntry_t::GetPrevHelmet() const {
    return GetSchemaValue<bool>(m_ptr, "SellbackPurchaseEntry_t", "m_bPrevHelmet");
}
void GSellbackPurchaseEntry_t::SetPrevHelmet(bool value) {
    SetSchemaValue(m_ptr, "SellbackPurchaseEntry_t", "m_bPrevHelmet", true, value);
}
GCEntityInstance GSellbackPurchaseEntry_t::GetItem() const {
    GCEntityInstance value((void*)(GetSchemaValue<CHandle<CEntityInstance>>(m_ptr, "SellbackPurchaseEntry_t", "m_hItem").Get()));
    return value;
}
void GSellbackPurchaseEntry_t::SetItem(GCEntityInstance value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Item' is not possible.\n");
}
void* GSellbackPurchaseEntry_t::GetPtr() {
    return m_ptr;
}
std::string GSellbackPurchaseEntry_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GSellbackPurchaseEntry_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassSellbackPurchaseEntry_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GSellbackPurchaseEntry_t>("SellbackPurchaseEntry_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("DefIdx", &GSellbackPurchaseEntry_t::GetDefIdx, &GSellbackPurchaseEntry_t::SetDefIdx)
        .addProperty("Cost", &GSellbackPurchaseEntry_t::GetCost, &GSellbackPurchaseEntry_t::SetCost)
        .addProperty("PrevArmor", &GSellbackPurchaseEntry_t::GetPrevArmor, &GSellbackPurchaseEntry_t::SetPrevArmor)
        .addProperty("PrevHelmet", &GSellbackPurchaseEntry_t::GetPrevHelmet, &GSellbackPurchaseEntry_t::SetPrevHelmet)
        .addProperty("Item", &GSellbackPurchaseEntry_t::GetItem, &GSellbackPurchaseEntry_t::SetItem)
        .addFunction("ToPtr", &GSellbackPurchaseEntry_t::ToPtr)
        .addFunction("IsValid", &GSellbackPurchaseEntry_t::IsValid)
        .endClass();
}
GCWeaponFamas::GCWeaponFamas(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCWeaponFamas::GCWeaponFamas(void *ptr) {
    m_ptr = ptr;
}
void* GCWeaponFamas::GetPtr() {
    return m_ptr;
}
std::string GCWeaponFamas::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCWeaponFamas::IsValid() {
    return (m_ptr != nullptr);
}
GCCSWeaponBaseGun GCWeaponFamas::GetParent() const {
    GCCSWeaponBaseGun value(m_ptr);
    return value;
}
void GCWeaponFamas::SetParent(GCCSWeaponBaseGun value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCWeaponFamas(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCWeaponFamas>("CWeaponFamas")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCWeaponFamas::GetParent, &GCWeaponFamas::SetParent)
        .addFunction("ToPtr", &GCWeaponFamas::ToPtr)
        .addFunction("IsValid", &GCWeaponFamas::IsValid)
        .endClass();
}
GCShatterGlassShardPhysics::GCShatterGlassShardPhysics(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCShatterGlassShardPhysics::GCShatterGlassShardPhysics(void *ptr) {
    m_ptr = ptr;
}
bool GCShatterGlassShardPhysics::GetDebris() const {
    return GetSchemaValue<bool>(m_ptr, "CShatterGlassShardPhysics", "m_bDebris");
}
void GCShatterGlassShardPhysics::SetDebris(bool value) {
    SetSchemaValue(m_ptr, "CShatterGlassShardPhysics", "m_bDebris", false, value);
}
uint32_t GCShatterGlassShardPhysics::GetParentShard() const {
    return GetSchemaValue<uint32_t>(m_ptr, "CShatterGlassShardPhysics", "m_hParentShard");
}
void GCShatterGlassShardPhysics::SetParentShard(uint32_t value) {
    SetSchemaValue(m_ptr, "CShatterGlassShardPhysics", "m_hParentShard", false, value);
}
Gshard_model_desc_t GCShatterGlassShardPhysics::GetShardDesc() const {
    Gshard_model_desc_t value(GetSchemaPtr(m_ptr, "CShatterGlassShardPhysics", "m_ShardDesc"));
    return value;
}
void GCShatterGlassShardPhysics::SetShardDesc(Gshard_model_desc_t value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'ShardDesc' is not possible.\n");
}
void* GCShatterGlassShardPhysics::GetPtr() {
    return m_ptr;
}
std::string GCShatterGlassShardPhysics::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCShatterGlassShardPhysics::IsValid() {
    return (m_ptr != nullptr);
}
GCPhysicsProp GCShatterGlassShardPhysics::GetParent() const {
    GCPhysicsProp value(m_ptr);
    return value;
}
void GCShatterGlassShardPhysics::SetParent(GCPhysicsProp value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCShatterGlassShardPhysics(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCShatterGlassShardPhysics>("CShatterGlassShardPhysics")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Debris", &GCShatterGlassShardPhysics::GetDebris, &GCShatterGlassShardPhysics::SetDebris)
        .addProperty("ParentShard", &GCShatterGlassShardPhysics::GetParentShard, &GCShatterGlassShardPhysics::SetParentShard)
        .addProperty("ShardDesc", &GCShatterGlassShardPhysics::GetShardDesc, &GCShatterGlassShardPhysics::SetShardDesc)
        .addProperty("Parent", &GCShatterGlassShardPhysics::GetParent, &GCShatterGlassShardPhysics::SetParent)
        .addFunction("ToPtr", &GCShatterGlassShardPhysics::ToPtr)
        .addFunction("IsValid", &GCShatterGlassShardPhysics::IsValid)
        .endClass();
}
GCFilterModel::GCFilterModel(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCFilterModel::GCFilterModel(void *ptr) {
    m_ptr = ptr;
}
std::string GCFilterModel::GetFilterModel() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CFilterModel", "m_iFilterModel").String();
}
void GCFilterModel::SetFilterModel(std::string value) {
    SetSchemaValue(m_ptr, "CFilterModel", "m_iFilterModel", false, CUtlSymbolLarge(value.c_str()));
}
void* GCFilterModel::GetPtr() {
    return m_ptr;
}
std::string GCFilterModel::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCFilterModel::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseFilter GCFilterModel::GetParent() const {
    GCBaseFilter value(m_ptr);
    return value;
}
void GCFilterModel::SetParent(GCBaseFilter value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCFilterModel(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCFilterModel>("CFilterModel")
        .addConstructor<void (*)(std::string)>()
        .addProperty("FilterModel", &GCFilterModel::GetFilterModel, &GCFilterModel::SetFilterModel)
        .addProperty("Parent", &GCFilterModel::GetParent, &GCFilterModel::SetParent)
        .addFunction("ToPtr", &GCFilterModel::ToPtr)
        .addFunction("IsValid", &GCFilterModel::IsValid)
        .endClass();
}
GCCSPlayerPawnBase::GCCSPlayerPawnBase(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCCSPlayerPawnBase::GCCSPlayerPawnBase(void *ptr) {
    m_ptr = ptr;
}
GCTouchExpansionComponent GCCSPlayerPawnBase::GetCTouchExpansionComponent() const {
    GCTouchExpansionComponent value(GetSchemaPtr(m_ptr, "CCSPlayerPawnBase", "m_CTouchExpansionComponent"));
    return value;
}
void GCCSPlayerPawnBase::SetCTouchExpansionComponent(GCTouchExpansionComponent value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'CTouchExpansionComponent' is not possible.\n");
}
GCCSPlayer_PingServices GCCSPlayerPawnBase::GetPingServices() const {
    GCCSPlayer_PingServices value(*(void**)GetSchemaPtr(m_ptr, "CCSPlayerPawnBase", "m_pPingServices"));
    return value;
}
void GCCSPlayerPawnBase::SetPingServices(GCCSPlayer_PingServices value) {
    SetSchemaValue(m_ptr, "CCSPlayerPawnBase","m_pPingServices", false, (char*)value.GetPtr());
}
GCPlayer_ViewModelServices GCCSPlayerPawnBase::GetViewModelServices() const {
    GCPlayer_ViewModelServices value(*(void**)GetSchemaPtr(m_ptr, "CCSPlayerPawnBase", "m_pViewModelServices"));
    return value;
}
void GCCSPlayerPawnBase::SetViewModelServices(GCPlayer_ViewModelServices value) {
    SetSchemaValue(m_ptr, "CCSPlayerPawnBase","m_pViewModelServices", false, (char*)value.GetPtr());
}
float GCCSPlayerPawnBase::GetBlindUntilTime() const {
    return GetSchemaValue<float>(m_ptr, "CCSPlayerPawnBase", "m_blindUntilTime");
}
void GCCSPlayerPawnBase::SetBlindUntilTime(float value) {
    SetSchemaValue(m_ptr, "CCSPlayerPawnBase", "m_blindUntilTime", false, value);
}
float GCCSPlayerPawnBase::GetBlindStartTime() const {
    return GetSchemaValue<float>(m_ptr, "CCSPlayerPawnBase", "m_blindStartTime");
}
void GCCSPlayerPawnBase::SetBlindStartTime(float value) {
    SetSchemaValue(m_ptr, "CCSPlayerPawnBase", "m_blindStartTime", false, value);
}
uint64_t GCCSPlayerPawnBase::GetPlayerState() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CCSPlayerPawnBase", "m_iPlayerState");
}
void GCCSPlayerPawnBase::SetPlayerState(uint64_t value) {
    SetSchemaValue(m_ptr, "CCSPlayerPawnBase", "m_iPlayerState", false, value);
}
bool GCCSPlayerPawnBase::GetRespawning() const {
    return GetSchemaValue<bool>(m_ptr, "CCSPlayerPawnBase", "m_bRespawning");
}
void GCCSPlayerPawnBase::SetRespawning(bool value) {
    SetSchemaValue(m_ptr, "CCSPlayerPawnBase", "m_bRespawning", false, value);
}
float GCCSPlayerPawnBase::GetImmuneToGunGameDamageTime() const {
    return GetSchemaValue<float>(m_ptr, "CCSPlayerPawnBase", "m_fImmuneToGunGameDamageTime");
}
void GCCSPlayerPawnBase::SetImmuneToGunGameDamageTime(float value) {
    SetSchemaValue(m_ptr, "CCSPlayerPawnBase", "m_fImmuneToGunGameDamageTime", false, value);
}
bool GCCSPlayerPawnBase::GetGunGameImmunity() const {
    return GetSchemaValue<bool>(m_ptr, "CCSPlayerPawnBase", "m_bGunGameImmunity");
}
void GCCSPlayerPawnBase::SetGunGameImmunity(bool value) {
    SetSchemaValue(m_ptr, "CCSPlayerPawnBase", "m_bGunGameImmunity", false, value);
}
float GCCSPlayerPawnBase::GetMolotovDamageTime() const {
    return GetSchemaValue<float>(m_ptr, "CCSPlayerPawnBase", "m_fMolotovDamageTime");
}
void GCCSPlayerPawnBase::SetMolotovDamageTime(float value) {
    SetSchemaValue(m_ptr, "CCSPlayerPawnBase", "m_fMolotovDamageTime", false, value);
}
bool GCCSPlayerPawnBase::GetHasMovedSinceSpawn() const {
    return GetSchemaValue<bool>(m_ptr, "CCSPlayerPawnBase", "m_bHasMovedSinceSpawn");
}
void GCCSPlayerPawnBase::SetHasMovedSinceSpawn(bool value) {
    SetSchemaValue(m_ptr, "CCSPlayerPawnBase", "m_bHasMovedSinceSpawn", false, value);
}
int32_t GCCSPlayerPawnBase::GetNumSpawns() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSPlayerPawnBase", "m_iNumSpawns");
}
void GCCSPlayerPawnBase::SetNumSpawns(int32_t value) {
    SetSchemaValue(m_ptr, "CCSPlayerPawnBase", "m_iNumSpawns", false, value);
}
float GCCSPlayerPawnBase::GetIdleTimeSinceLastAction() const {
    return GetSchemaValue<float>(m_ptr, "CCSPlayerPawnBase", "m_flIdleTimeSinceLastAction");
}
void GCCSPlayerPawnBase::SetIdleTimeSinceLastAction(float value) {
    SetSchemaValue(m_ptr, "CCSPlayerPawnBase", "m_flIdleTimeSinceLastAction", false, value);
}
float GCCSPlayerPawnBase::GetNextRadarUpdateTime() const {
    return GetSchemaValue<float>(m_ptr, "CCSPlayerPawnBase", "m_fNextRadarUpdateTime");
}
void GCCSPlayerPawnBase::SetNextRadarUpdateTime(float value) {
    SetSchemaValue(m_ptr, "CCSPlayerPawnBase", "m_fNextRadarUpdateTime", false, value);
}
float GCCSPlayerPawnBase::GetFlashDuration() const {
    return GetSchemaValue<float>(m_ptr, "CCSPlayerPawnBase", "m_flFlashDuration");
}
void GCCSPlayerPawnBase::SetFlashDuration(float value) {
    SetSchemaValue(m_ptr, "CCSPlayerPawnBase", "m_flFlashDuration", false, value);
}
float GCCSPlayerPawnBase::GetFlashMaxAlpha() const {
    return GetSchemaValue<float>(m_ptr, "CCSPlayerPawnBase", "m_flFlashMaxAlpha");
}
void GCCSPlayerPawnBase::SetFlashMaxAlpha(float value) {
    SetSchemaValue(m_ptr, "CCSPlayerPawnBase", "m_flFlashMaxAlpha", false, value);
}
float GCCSPlayerPawnBase::GetProgressBarStartTime() const {
    return GetSchemaValue<float>(m_ptr, "CCSPlayerPawnBase", "m_flProgressBarStartTime");
}
void GCCSPlayerPawnBase::SetProgressBarStartTime(float value) {
    SetSchemaValue(m_ptr, "CCSPlayerPawnBase", "m_flProgressBarStartTime", false, value);
}
int32_t GCCSPlayerPawnBase::GetProgressBarDuration() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSPlayerPawnBase", "m_iProgressBarDuration");
}
void GCCSPlayerPawnBase::SetProgressBarDuration(int32_t value) {
    SetSchemaValue(m_ptr, "CCSPlayerPawnBase", "m_iProgressBarDuration", false, value);
}
QAngle GCCSPlayerPawnBase::GetEyeAngles() const {
    return GetSchemaValue<QAngle>(m_ptr, "CCSPlayerPawnBase", "m_angEyeAngles");
}
void GCCSPlayerPawnBase::SetEyeAngles(QAngle value) {
    SetSchemaValue(m_ptr, "CCSPlayerPawnBase", "m_angEyeAngles", false, value);
}
int32_t GCCSPlayerPawnBase::GetNumEnemiesAtRoundStart() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSPlayerPawnBase", "m_NumEnemiesAtRoundStart");
}
void GCCSPlayerPawnBase::SetNumEnemiesAtRoundStart(int32_t value) {
    SetSchemaValue(m_ptr, "CCSPlayerPawnBase", "m_NumEnemiesAtRoundStart", false, value);
}
bool GCCSPlayerPawnBase::GetWasNotKilledNaturally() const {
    return GetSchemaValue<bool>(m_ptr, "CCSPlayerPawnBase", "m_wasNotKilledNaturally");
}
void GCCSPlayerPawnBase::SetWasNotKilledNaturally(bool value) {
    SetSchemaValue(m_ptr, "CCSPlayerPawnBase", "m_wasNotKilledNaturally", false, value);
}
bool GCCSPlayerPawnBase::GetCommittingSuicideOnTeamChange() const {
    return GetSchemaValue<bool>(m_ptr, "CCSPlayerPawnBase", "m_bCommittingSuicideOnTeamChange");
}
void GCCSPlayerPawnBase::SetCommittingSuicideOnTeamChange(bool value) {
    SetSchemaValue(m_ptr, "CCSPlayerPawnBase", "m_bCommittingSuicideOnTeamChange", false, value);
}
GCCSPlayerController GCCSPlayerPawnBase::GetOriginalController() const {
    GCCSPlayerController value((void*)(GetSchemaValue<CHandle<CEntityInstance>>(m_ptr, "CCSPlayerPawnBase", "m_hOriginalController").Get()));
    return value;
}
void GCCSPlayerPawnBase::SetOriginalController(GCCSPlayerController value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'OriginalController' is not possible.\n");
}
void* GCCSPlayerPawnBase::GetPtr() {
    return m_ptr;
}
std::string GCCSPlayerPawnBase::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCCSPlayerPawnBase::IsValid() {
    return (m_ptr != nullptr);
}
GCBasePlayerPawn GCCSPlayerPawnBase::GetParent() const {
    GCBasePlayerPawn value(m_ptr);
    return value;
}
void GCCSPlayerPawnBase::SetParent(GCBasePlayerPawn value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCCSPlayerPawnBase(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCCSPlayerPawnBase>("CCSPlayerPawnBase")
        .addConstructor<void (*)(std::string)>()
        .addProperty("CTouchExpansionComponent", &GCCSPlayerPawnBase::GetCTouchExpansionComponent, &GCCSPlayerPawnBase::SetCTouchExpansionComponent)
        .addProperty("PingServices", &GCCSPlayerPawnBase::GetPingServices, &GCCSPlayerPawnBase::SetPingServices)
        .addProperty("ViewModelServices", &GCCSPlayerPawnBase::GetViewModelServices, &GCCSPlayerPawnBase::SetViewModelServices)
        .addProperty("BlindUntilTime", &GCCSPlayerPawnBase::GetBlindUntilTime, &GCCSPlayerPawnBase::SetBlindUntilTime)
        .addProperty("BlindStartTime", &GCCSPlayerPawnBase::GetBlindStartTime, &GCCSPlayerPawnBase::SetBlindStartTime)
        .addProperty("PlayerState", &GCCSPlayerPawnBase::GetPlayerState, &GCCSPlayerPawnBase::SetPlayerState)
        .addProperty("Respawning", &GCCSPlayerPawnBase::GetRespawning, &GCCSPlayerPawnBase::SetRespawning)
        .addProperty("ImmuneToGunGameDamageTime", &GCCSPlayerPawnBase::GetImmuneToGunGameDamageTime, &GCCSPlayerPawnBase::SetImmuneToGunGameDamageTime)
        .addProperty("GunGameImmunity", &GCCSPlayerPawnBase::GetGunGameImmunity, &GCCSPlayerPawnBase::SetGunGameImmunity)
        .addProperty("MolotovDamageTime", &GCCSPlayerPawnBase::GetMolotovDamageTime, &GCCSPlayerPawnBase::SetMolotovDamageTime)
        .addProperty("HasMovedSinceSpawn", &GCCSPlayerPawnBase::GetHasMovedSinceSpawn, &GCCSPlayerPawnBase::SetHasMovedSinceSpawn)
        .addProperty("NumSpawns", &GCCSPlayerPawnBase::GetNumSpawns, &GCCSPlayerPawnBase::SetNumSpawns)
        .addProperty("IdleTimeSinceLastAction", &GCCSPlayerPawnBase::GetIdleTimeSinceLastAction, &GCCSPlayerPawnBase::SetIdleTimeSinceLastAction)
        .addProperty("NextRadarUpdateTime", &GCCSPlayerPawnBase::GetNextRadarUpdateTime, &GCCSPlayerPawnBase::SetNextRadarUpdateTime)
        .addProperty("FlashDuration", &GCCSPlayerPawnBase::GetFlashDuration, &GCCSPlayerPawnBase::SetFlashDuration)
        .addProperty("FlashMaxAlpha", &GCCSPlayerPawnBase::GetFlashMaxAlpha, &GCCSPlayerPawnBase::SetFlashMaxAlpha)
        .addProperty("ProgressBarStartTime", &GCCSPlayerPawnBase::GetProgressBarStartTime, &GCCSPlayerPawnBase::SetProgressBarStartTime)
        .addProperty("ProgressBarDuration", &GCCSPlayerPawnBase::GetProgressBarDuration, &GCCSPlayerPawnBase::SetProgressBarDuration)
        .addProperty("EyeAngles", &GCCSPlayerPawnBase::GetEyeAngles, &GCCSPlayerPawnBase::SetEyeAngles)
        .addProperty("NumEnemiesAtRoundStart", &GCCSPlayerPawnBase::GetNumEnemiesAtRoundStart, &GCCSPlayerPawnBase::SetNumEnemiesAtRoundStart)
        .addProperty("WasNotKilledNaturally", &GCCSPlayerPawnBase::GetWasNotKilledNaturally, &GCCSPlayerPawnBase::SetWasNotKilledNaturally)
        .addProperty("CommittingSuicideOnTeamChange", &GCCSPlayerPawnBase::GetCommittingSuicideOnTeamChange, &GCCSPlayerPawnBase::SetCommittingSuicideOnTeamChange)
        .addProperty("OriginalController", &GCCSPlayerPawnBase::GetOriginalController, &GCCSPlayerPawnBase::SetOriginalController)
        .addProperty("Parent", &GCCSPlayerPawnBase::GetParent, &GCCSPlayerPawnBase::SetParent)
        .addFunction("ToPtr", &GCCSPlayerPawnBase::ToPtr)
        .addFunction("IsValid", &GCCSPlayerPawnBase::IsValid)
        .endClass();
}
GCPathTrack::GCPathTrack(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCPathTrack::GCPathTrack(void *ptr) {
    m_ptr = ptr;
}
GCPathTrack GCPathTrack::GetPnext() const {
    GCPathTrack value(*(void**)GetSchemaPtr(m_ptr, "CPathTrack", "m_pnext"));
    return value;
}
void GCPathTrack::SetPnext(GCPathTrack value) {
    SetSchemaValue(m_ptr, "CPathTrack","m_pnext", false, (char*)value.GetPtr());
}
GCPathTrack GCPathTrack::GetPprevious() const {
    GCPathTrack value(*(void**)GetSchemaPtr(m_ptr, "CPathTrack", "m_pprevious"));
    return value;
}
void GCPathTrack::SetPprevious(GCPathTrack value) {
    SetSchemaValue(m_ptr, "CPathTrack","m_pprevious", false, (char*)value.GetPtr());
}
GCPathTrack GCPathTrack::GetPaltpath() const {
    GCPathTrack value(*(void**)GetSchemaPtr(m_ptr, "CPathTrack", "m_paltpath"));
    return value;
}
void GCPathTrack::SetPaltpath(GCPathTrack value) {
    SetSchemaValue(m_ptr, "CPathTrack","m_paltpath", false, (char*)value.GetPtr());
}
float GCPathTrack::GetRadius() const {
    return GetSchemaValue<float>(m_ptr, "CPathTrack", "m_flRadius");
}
void GCPathTrack::SetRadius(float value) {
    SetSchemaValue(m_ptr, "CPathTrack", "m_flRadius", false, value);
}
float GCPathTrack::GetLength() const {
    return GetSchemaValue<float>(m_ptr, "CPathTrack", "m_length");
}
void GCPathTrack::SetLength(float value) {
    SetSchemaValue(m_ptr, "CPathTrack", "m_length", false, value);
}
std::string GCPathTrack::GetAltName() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CPathTrack", "m_altName").String();
}
void GCPathTrack::SetAltName(std::string value) {
    SetSchemaValue(m_ptr, "CPathTrack", "m_altName", false, CUtlSymbolLarge(value.c_str()));
}
int32_t GCPathTrack::GetIterVal() const {
    return GetSchemaValue<int32_t>(m_ptr, "CPathTrack", "m_nIterVal");
}
void GCPathTrack::SetIterVal(int32_t value) {
    SetSchemaValue(m_ptr, "CPathTrack", "m_nIterVal", false, value);
}
uint64_t GCPathTrack::GetOrientationType() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CPathTrack", "m_eOrientationType");
}
void GCPathTrack::SetOrientationType(uint64_t value) {
    SetSchemaValue(m_ptr, "CPathTrack", "m_eOrientationType", false, value);
}
GCEntityIOOutput GCPathTrack::GetOnPass() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CPathTrack", "m_OnPass"));
    return value;
}
void GCPathTrack::SetOnPass(GCEntityIOOutput value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'OnPass' is not possible.\n");
}
void* GCPathTrack::GetPtr() {
    return m_ptr;
}
std::string GCPathTrack::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCPathTrack::IsValid() {
    return (m_ptr != nullptr);
}
GCPointEntity GCPathTrack::GetParent() const {
    GCPointEntity value(m_ptr);
    return value;
}
void GCPathTrack::SetParent(GCPointEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCPathTrack(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCPathTrack>("CPathTrack")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Pnext", &GCPathTrack::GetPnext, &GCPathTrack::SetPnext)
        .addProperty("Pprevious", &GCPathTrack::GetPprevious, &GCPathTrack::SetPprevious)
        .addProperty("Paltpath", &GCPathTrack::GetPaltpath, &GCPathTrack::SetPaltpath)
        .addProperty("Radius", &GCPathTrack::GetRadius, &GCPathTrack::SetRadius)
        .addProperty("Length", &GCPathTrack::GetLength, &GCPathTrack::SetLength)
        .addProperty("AltName", &GCPathTrack::GetAltName, &GCPathTrack::SetAltName)
        .addProperty("IterVal", &GCPathTrack::GetIterVal, &GCPathTrack::SetIterVal)
        .addProperty("OrientationType", &GCPathTrack::GetOrientationType, &GCPathTrack::SetOrientationType)
        .addProperty("OnPass", &GCPathTrack::GetOnPass, &GCPathTrack::SetOnPass)
        .addProperty("Parent", &GCPathTrack::GetParent, &GCPathTrack::SetParent)
        .addFunction("ToPtr", &GCPathTrack::ToPtr)
        .addFunction("IsValid", &GCPathTrack::IsValid)
        .endClass();
}
GCLogicDistanceCheck::GCLogicDistanceCheck(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCLogicDistanceCheck::GCLogicDistanceCheck(void *ptr) {
    m_ptr = ptr;
}
std::string GCLogicDistanceCheck::GetEntityA() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CLogicDistanceCheck", "m_iszEntityA").String();
}
void GCLogicDistanceCheck::SetEntityA(std::string value) {
    SetSchemaValue(m_ptr, "CLogicDistanceCheck", "m_iszEntityA", false, CUtlSymbolLarge(value.c_str()));
}
std::string GCLogicDistanceCheck::GetEntityB() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CLogicDistanceCheck", "m_iszEntityB").String();
}
void GCLogicDistanceCheck::SetEntityB(std::string value) {
    SetSchemaValue(m_ptr, "CLogicDistanceCheck", "m_iszEntityB", false, CUtlSymbolLarge(value.c_str()));
}
float GCLogicDistanceCheck::GetZone1Distance() const {
    return GetSchemaValue<float>(m_ptr, "CLogicDistanceCheck", "m_flZone1Distance");
}
void GCLogicDistanceCheck::SetZone1Distance(float value) {
    SetSchemaValue(m_ptr, "CLogicDistanceCheck", "m_flZone1Distance", false, value);
}
float GCLogicDistanceCheck::GetZone2Distance() const {
    return GetSchemaValue<float>(m_ptr, "CLogicDistanceCheck", "m_flZone2Distance");
}
void GCLogicDistanceCheck::SetZone2Distance(float value) {
    SetSchemaValue(m_ptr, "CLogicDistanceCheck", "m_flZone2Distance", false, value);
}
GCEntityIOOutput GCLogicDistanceCheck::GetInZone1() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CLogicDistanceCheck", "m_InZone1"));
    return value;
}
void GCLogicDistanceCheck::SetInZone1(GCEntityIOOutput value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'InZone1' is not possible.\n");
}
GCEntityIOOutput GCLogicDistanceCheck::GetInZone2() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CLogicDistanceCheck", "m_InZone2"));
    return value;
}
void GCLogicDistanceCheck::SetInZone2(GCEntityIOOutput value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'InZone2' is not possible.\n");
}
GCEntityIOOutput GCLogicDistanceCheck::GetInZone3() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CLogicDistanceCheck", "m_InZone3"));
    return value;
}
void GCLogicDistanceCheck::SetInZone3(GCEntityIOOutput value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'InZone3' is not possible.\n");
}
void* GCLogicDistanceCheck::GetPtr() {
    return m_ptr;
}
std::string GCLogicDistanceCheck::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCLogicDistanceCheck::IsValid() {
    return (m_ptr != nullptr);
}
GCLogicalEntity GCLogicDistanceCheck::GetParent() const {
    GCLogicalEntity value(m_ptr);
    return value;
}
void GCLogicDistanceCheck::SetParent(GCLogicalEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCLogicDistanceCheck(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCLogicDistanceCheck>("CLogicDistanceCheck")
        .addConstructor<void (*)(std::string)>()
        .addProperty("EntityA", &GCLogicDistanceCheck::GetEntityA, &GCLogicDistanceCheck::SetEntityA)
        .addProperty("EntityB", &GCLogicDistanceCheck::GetEntityB, &GCLogicDistanceCheck::SetEntityB)
        .addProperty("Zone1Distance", &GCLogicDistanceCheck::GetZone1Distance, &GCLogicDistanceCheck::SetZone1Distance)
        .addProperty("Zone2Distance", &GCLogicDistanceCheck::GetZone2Distance, &GCLogicDistanceCheck::SetZone2Distance)
        .addProperty("InZone1", &GCLogicDistanceCheck::GetInZone1, &GCLogicDistanceCheck::SetInZone1)
        .addProperty("InZone2", &GCLogicDistanceCheck::GetInZone2, &GCLogicDistanceCheck::SetInZone2)
        .addProperty("InZone3", &GCLogicDistanceCheck::GetInZone3, &GCLogicDistanceCheck::SetInZone3)
        .addProperty("Parent", &GCLogicDistanceCheck::GetParent, &GCLogicDistanceCheck::SetParent)
        .addFunction("ToPtr", &GCLogicDistanceCheck::ToPtr)
        .addFunction("IsValid", &GCLogicDistanceCheck::IsValid)
        .endClass();
}
GCOmniLight::GCOmniLight(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCOmniLight::GCOmniLight(void *ptr) {
    m_ptr = ptr;
}
float GCOmniLight::GetInnerAngle() const {
    return GetSchemaValue<float>(m_ptr, "COmniLight", "m_flInnerAngle");
}
void GCOmniLight::SetInnerAngle(float value) {
    SetSchemaValue(m_ptr, "COmniLight", "m_flInnerAngle", false, value);
}
float GCOmniLight::GetOuterAngle() const {
    return GetSchemaValue<float>(m_ptr, "COmniLight", "m_flOuterAngle");
}
void GCOmniLight::SetOuterAngle(float value) {
    SetSchemaValue(m_ptr, "COmniLight", "m_flOuterAngle", false, value);
}
bool GCOmniLight::GetShowLight() const {
    return GetSchemaValue<bool>(m_ptr, "COmniLight", "m_bShowLight");
}
void GCOmniLight::SetShowLight(bool value) {
    SetSchemaValue(m_ptr, "COmniLight", "m_bShowLight", false, value);
}
void* GCOmniLight::GetPtr() {
    return m_ptr;
}
std::string GCOmniLight::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCOmniLight::IsValid() {
    return (m_ptr != nullptr);
}
GCBarnLight GCOmniLight::GetParent() const {
    GCBarnLight value(m_ptr);
    return value;
}
void GCOmniLight::SetParent(GCBarnLight value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCOmniLight(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCOmniLight>("COmniLight")
        .addConstructor<void (*)(std::string)>()
        .addProperty("InnerAngle", &GCOmniLight::GetInnerAngle, &GCOmniLight::SetInnerAngle)
        .addProperty("OuterAngle", &GCOmniLight::GetOuterAngle, &GCOmniLight::SetOuterAngle)
        .addProperty("ShowLight", &GCOmniLight::GetShowLight, &GCOmniLight::SetShowLight)
        .addProperty("Parent", &GCOmniLight::GetParent, &GCOmniLight::SetParent)
        .addFunction("ToPtr", &GCOmniLight::ToPtr)
        .addFunction("IsValid", &GCOmniLight::IsValid)
        .endClass();
}
GCInfoOffscreenPanoramaTexture::GCInfoOffscreenPanoramaTexture(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCInfoOffscreenPanoramaTexture::GCInfoOffscreenPanoramaTexture(void *ptr) {
    m_ptr = ptr;
}
bool GCInfoOffscreenPanoramaTexture::GetDisabled() const {
    return GetSchemaValue<bool>(m_ptr, "CInfoOffscreenPanoramaTexture", "m_bDisabled");
}
void GCInfoOffscreenPanoramaTexture::SetDisabled(bool value) {
    SetSchemaValue(m_ptr, "CInfoOffscreenPanoramaTexture", "m_bDisabled", false, value);
}
int32_t GCInfoOffscreenPanoramaTexture::GetResolutionX() const {
    return GetSchemaValue<int32_t>(m_ptr, "CInfoOffscreenPanoramaTexture", "m_nResolutionX");
}
void GCInfoOffscreenPanoramaTexture::SetResolutionX(int32_t value) {
    SetSchemaValue(m_ptr, "CInfoOffscreenPanoramaTexture", "m_nResolutionX", false, value);
}
int32_t GCInfoOffscreenPanoramaTexture::GetResolutionY() const {
    return GetSchemaValue<int32_t>(m_ptr, "CInfoOffscreenPanoramaTexture", "m_nResolutionY");
}
void GCInfoOffscreenPanoramaTexture::SetResolutionY(int32_t value) {
    SetSchemaValue(m_ptr, "CInfoOffscreenPanoramaTexture", "m_nResolutionY", false, value);
}
std::string GCInfoOffscreenPanoramaTexture::GetLayoutFileName() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CInfoOffscreenPanoramaTexture", "m_szLayoutFileName").String();
}
void GCInfoOffscreenPanoramaTexture::SetLayoutFileName(std::string value) {
    SetSchemaValue(m_ptr, "CInfoOffscreenPanoramaTexture", "m_szLayoutFileName", false, CUtlSymbolLarge(value.c_str()));
}
std::string GCInfoOffscreenPanoramaTexture::GetRenderAttrName() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CInfoOffscreenPanoramaTexture", "m_RenderAttrName").String();
}
void GCInfoOffscreenPanoramaTexture::SetRenderAttrName(std::string value) {
    SetSchemaValue(m_ptr, "CInfoOffscreenPanoramaTexture", "m_RenderAttrName", false, CUtlSymbolLarge(value.c_str()));
}
std::vector<GCBaseModelEntity> GCInfoOffscreenPanoramaTexture::GetTargetEntities() const {
    CUtlVector<CHandle<CEntityInstance>>* vec = GetSchemaValue<CUtlVector<CHandle<CEntityInstance>>*>(m_ptr, "CInfoOffscreenPanoramaTexture", "m_TargetEntities"); 
    std::vector<GCBaseModelEntity> outVec; 
    for(int i = 0; i < vec->Count(); i++) { 
        outVec.push_back(GCBaseModelEntity((void*)(vec->Element(i).Get()))); 
    } 
    return outVec;
}
void GCInfoOffscreenPanoramaTexture::SetTargetEntities(std::vector<GCBaseModelEntity> value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'TargetEntities' is not possible.\n");
}
int32_t GCInfoOffscreenPanoramaTexture::GetTargetChangeCount() const {
    return GetSchemaValue<int32_t>(m_ptr, "CInfoOffscreenPanoramaTexture", "m_nTargetChangeCount");
}
void GCInfoOffscreenPanoramaTexture::SetTargetChangeCount(int32_t value) {
    SetSchemaValue(m_ptr, "CInfoOffscreenPanoramaTexture", "m_nTargetChangeCount", false, value);
}
std::vector<CUtlSymbolLarge> GCInfoOffscreenPanoramaTexture::GetCSSClasses() const {
    CUtlVector<CUtlSymbolLarge>* vec = GetSchemaValue<CUtlVector<CUtlSymbolLarge>*>(m_ptr, "CInfoOffscreenPanoramaTexture", "m_vecCSSClasses"); std::vector<CUtlSymbolLarge> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCInfoOffscreenPanoramaTexture::SetCSSClasses(std::vector<CUtlSymbolLarge> value) {
    SetSchemaValueCUtlVector<CUtlSymbolLarge>(m_ptr, "CInfoOffscreenPanoramaTexture", "m_vecCSSClasses", false, value);
}
std::string GCInfoOffscreenPanoramaTexture::GetTargetsName() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CInfoOffscreenPanoramaTexture", "m_szTargetsName").String();
}
void GCInfoOffscreenPanoramaTexture::SetTargetsName(std::string value) {
    SetSchemaValue(m_ptr, "CInfoOffscreenPanoramaTexture", "m_szTargetsName", false, CUtlSymbolLarge(value.c_str()));
}
void* GCInfoOffscreenPanoramaTexture::GetPtr() {
    return m_ptr;
}
std::string GCInfoOffscreenPanoramaTexture::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCInfoOffscreenPanoramaTexture::IsValid() {
    return (m_ptr != nullptr);
}
GCPointEntity GCInfoOffscreenPanoramaTexture::GetParent() const {
    GCPointEntity value(m_ptr);
    return value;
}
void GCInfoOffscreenPanoramaTexture::SetParent(GCPointEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCInfoOffscreenPanoramaTexture(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCInfoOffscreenPanoramaTexture>("CInfoOffscreenPanoramaTexture")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Disabled", &GCInfoOffscreenPanoramaTexture::GetDisabled, &GCInfoOffscreenPanoramaTexture::SetDisabled)
        .addProperty("ResolutionX", &GCInfoOffscreenPanoramaTexture::GetResolutionX, &GCInfoOffscreenPanoramaTexture::SetResolutionX)
        .addProperty("ResolutionY", &GCInfoOffscreenPanoramaTexture::GetResolutionY, &GCInfoOffscreenPanoramaTexture::SetResolutionY)
        .addProperty("LayoutFileName", &GCInfoOffscreenPanoramaTexture::GetLayoutFileName, &GCInfoOffscreenPanoramaTexture::SetLayoutFileName)
        .addProperty("RenderAttrName", &GCInfoOffscreenPanoramaTexture::GetRenderAttrName, &GCInfoOffscreenPanoramaTexture::SetRenderAttrName)
        .addProperty("TargetEntities", &GCInfoOffscreenPanoramaTexture::GetTargetEntities, &GCInfoOffscreenPanoramaTexture::SetTargetEntities)
        .addProperty("TargetChangeCount", &GCInfoOffscreenPanoramaTexture::GetTargetChangeCount, &GCInfoOffscreenPanoramaTexture::SetTargetChangeCount)
        .addProperty("CSSClasses", &GCInfoOffscreenPanoramaTexture::GetCSSClasses, &GCInfoOffscreenPanoramaTexture::SetCSSClasses)
        .addProperty("TargetsName", &GCInfoOffscreenPanoramaTexture::GetTargetsName, &GCInfoOffscreenPanoramaTexture::SetTargetsName)
        .addProperty("Parent", &GCInfoOffscreenPanoramaTexture::GetParent, &GCInfoOffscreenPanoramaTexture::SetParent)
        .addFunction("ToPtr", &GCInfoOffscreenPanoramaTexture::ToPtr)
        .addFunction("IsValid", &GCInfoOffscreenPanoramaTexture::IsValid)
        .endClass();
}
GCInfoVisibilityBox::GCInfoVisibilityBox(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCInfoVisibilityBox::GCInfoVisibilityBox(void *ptr) {
    m_ptr = ptr;
}
int32_t GCInfoVisibilityBox::GetMode() const {
    return GetSchemaValue<int32_t>(m_ptr, "CInfoVisibilityBox", "m_nMode");
}
void GCInfoVisibilityBox::SetMode(int32_t value) {
    SetSchemaValue(m_ptr, "CInfoVisibilityBox", "m_nMode", false, value);
}
Vector GCInfoVisibilityBox::GetBoxSize() const {
    return GetSchemaValue<Vector>(m_ptr, "CInfoVisibilityBox", "m_vBoxSize");
}
void GCInfoVisibilityBox::SetBoxSize(Vector value) {
    SetSchemaValue(m_ptr, "CInfoVisibilityBox", "m_vBoxSize", false, value);
}
bool GCInfoVisibilityBox::GetEnabled() const {
    return GetSchemaValue<bool>(m_ptr, "CInfoVisibilityBox", "m_bEnabled");
}
void GCInfoVisibilityBox::SetEnabled(bool value) {
    SetSchemaValue(m_ptr, "CInfoVisibilityBox", "m_bEnabled", false, value);
}
void* GCInfoVisibilityBox::GetPtr() {
    return m_ptr;
}
std::string GCInfoVisibilityBox::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCInfoVisibilityBox::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseEntity GCInfoVisibilityBox::GetParent() const {
    GCBaseEntity value(m_ptr);
    return value;
}
void GCInfoVisibilityBox::SetParent(GCBaseEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCInfoVisibilityBox(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCInfoVisibilityBox>("CInfoVisibilityBox")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Mode", &GCInfoVisibilityBox::GetMode, &GCInfoVisibilityBox::SetMode)
        .addProperty("BoxSize", &GCInfoVisibilityBox::GetBoxSize, &GCInfoVisibilityBox::SetBoxSize)
        .addProperty("Enabled", &GCInfoVisibilityBox::GetEnabled, &GCInfoVisibilityBox::SetEnabled)
        .addProperty("Parent", &GCInfoVisibilityBox::GetParent, &GCInfoVisibilityBox::SetParent)
        .addFunction("ToPtr", &GCInfoVisibilityBox::ToPtr)
        .addFunction("IsValid", &GCInfoVisibilityBox::IsValid)
        .endClass();
}
GCGamePlayerEquip::GCGamePlayerEquip(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCGamePlayerEquip::GCGamePlayerEquip(void *ptr) {
    m_ptr = ptr;
}
void* GCGamePlayerEquip::GetPtr() {
    return m_ptr;
}
std::string GCGamePlayerEquip::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCGamePlayerEquip::IsValid() {
    return (m_ptr != nullptr);
}
GCRulePointEntity GCGamePlayerEquip::GetParent() const {
    GCRulePointEntity value(m_ptr);
    return value;
}
void GCGamePlayerEquip::SetParent(GCRulePointEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCGamePlayerEquip(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCGamePlayerEquip>("CGamePlayerEquip")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCGamePlayerEquip::GetParent, &GCGamePlayerEquip::SetParent)
        .addFunction("ToPtr", &GCGamePlayerEquip::ToPtr)
        .addFunction("IsValid", &GCGamePlayerEquip::IsValid)
        .endClass();
}
GCInfoTargetServerOnly::GCInfoTargetServerOnly(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCInfoTargetServerOnly::GCInfoTargetServerOnly(void *ptr) {
    m_ptr = ptr;
}
void* GCInfoTargetServerOnly::GetPtr() {
    return m_ptr;
}
std::string GCInfoTargetServerOnly::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCInfoTargetServerOnly::IsValid() {
    return (m_ptr != nullptr);
}
GCServerOnlyPointEntity GCInfoTargetServerOnly::GetParent() const {
    GCServerOnlyPointEntity value(m_ptr);
    return value;
}
void GCInfoTargetServerOnly::SetParent(GCServerOnlyPointEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCInfoTargetServerOnly(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCInfoTargetServerOnly>("CInfoTargetServerOnly")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCInfoTargetServerOnly::GetParent, &GCInfoTargetServerOnly::SetParent)
        .addFunction("ToPtr", &GCInfoTargetServerOnly::ToPtr)
        .addFunction("IsValid", &GCInfoTargetServerOnly::IsValid)
        .endClass();
}
GCSoundOpvarSetPathCornerEntity::GCSoundOpvarSetPathCornerEntity(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCSoundOpvarSetPathCornerEntity::GCSoundOpvarSetPathCornerEntity(void *ptr) {
    m_ptr = ptr;
}
float GCSoundOpvarSetPathCornerEntity::GetDistMinSqr() const {
    return GetSchemaValue<float>(m_ptr, "CSoundOpvarSetPathCornerEntity", "m_flDistMinSqr");
}
void GCSoundOpvarSetPathCornerEntity::SetDistMinSqr(float value) {
    SetSchemaValue(m_ptr, "CSoundOpvarSetPathCornerEntity", "m_flDistMinSqr", false, value);
}
float GCSoundOpvarSetPathCornerEntity::GetDistMaxSqr() const {
    return GetSchemaValue<float>(m_ptr, "CSoundOpvarSetPathCornerEntity", "m_flDistMaxSqr");
}
void GCSoundOpvarSetPathCornerEntity::SetDistMaxSqr(float value) {
    SetSchemaValue(m_ptr, "CSoundOpvarSetPathCornerEntity", "m_flDistMaxSqr", false, value);
}
std::string GCSoundOpvarSetPathCornerEntity::GetPathCornerEntityName() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CSoundOpvarSetPathCornerEntity", "m_iszPathCornerEntityName").String();
}
void GCSoundOpvarSetPathCornerEntity::SetPathCornerEntityName(std::string value) {
    SetSchemaValue(m_ptr, "CSoundOpvarSetPathCornerEntity", "m_iszPathCornerEntityName", false, CUtlSymbolLarge(value.c_str()));
}
void* GCSoundOpvarSetPathCornerEntity::GetPtr() {
    return m_ptr;
}
std::string GCSoundOpvarSetPathCornerEntity::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCSoundOpvarSetPathCornerEntity::IsValid() {
    return (m_ptr != nullptr);
}
GCSoundOpvarSetPointEntity GCSoundOpvarSetPathCornerEntity::GetParent() const {
    GCSoundOpvarSetPointEntity value(m_ptr);
    return value;
}
void GCSoundOpvarSetPathCornerEntity::SetParent(GCSoundOpvarSetPointEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCSoundOpvarSetPathCornerEntity(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCSoundOpvarSetPathCornerEntity>("CSoundOpvarSetPathCornerEntity")
        .addConstructor<void (*)(std::string)>()
        .addProperty("DistMinSqr", &GCSoundOpvarSetPathCornerEntity::GetDistMinSqr, &GCSoundOpvarSetPathCornerEntity::SetDistMinSqr)
        .addProperty("DistMaxSqr", &GCSoundOpvarSetPathCornerEntity::GetDistMaxSqr, &GCSoundOpvarSetPathCornerEntity::SetDistMaxSqr)
        .addProperty("PathCornerEntityName", &GCSoundOpvarSetPathCornerEntity::GetPathCornerEntityName, &GCSoundOpvarSetPathCornerEntity::SetPathCornerEntityName)
        .addProperty("Parent", &GCSoundOpvarSetPathCornerEntity::GetParent, &GCSoundOpvarSetPathCornerEntity::SetParent)
        .addFunction("ToPtr", &GCSoundOpvarSetPathCornerEntity::ToPtr)
        .addFunction("IsValid", &GCSoundOpvarSetPathCornerEntity::IsValid)
        .endClass();
}
GCCSPlayer_WeaponServices::GCCSPlayer_WeaponServices(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCCSPlayer_WeaponServices::GCCSPlayer_WeaponServices(void *ptr) {
    m_ptr = ptr;
}
float GCCSPlayer_WeaponServices::GetNextAttack() const {
    return GetSchemaValue<float>(m_ptr, "CCSPlayer_WeaponServices", "m_flNextAttack");
}
void GCCSPlayer_WeaponServices::SetNextAttack(float value) {
    SetSchemaValue(m_ptr, "CCSPlayer_WeaponServices", "m_flNextAttack", false, value);
}
bool GCCSPlayer_WeaponServices::GetIsLookingAtWeapon() const {
    return GetSchemaValue<bool>(m_ptr, "CCSPlayer_WeaponServices", "m_bIsLookingAtWeapon");
}
void GCCSPlayer_WeaponServices::SetIsLookingAtWeapon(bool value) {
    SetSchemaValue(m_ptr, "CCSPlayer_WeaponServices", "m_bIsLookingAtWeapon", false, value);
}
bool GCCSPlayer_WeaponServices::GetIsHoldingLookAtWeapon() const {
    return GetSchemaValue<bool>(m_ptr, "CCSPlayer_WeaponServices", "m_bIsHoldingLookAtWeapon");
}
void GCCSPlayer_WeaponServices::SetIsHoldingLookAtWeapon(bool value) {
    SetSchemaValue(m_ptr, "CCSPlayer_WeaponServices", "m_bIsHoldingLookAtWeapon", false, value);
}
GCBasePlayerWeapon GCCSPlayer_WeaponServices::GetSavedWeapon() const {
    GCBasePlayerWeapon value((void*)(GetSchemaValue<CHandle<CEntityInstance>>(m_ptr, "CCSPlayer_WeaponServices", "m_hSavedWeapon").Get()));
    return value;
}
void GCCSPlayer_WeaponServices::SetSavedWeapon(GCBasePlayerWeapon value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'SavedWeapon' is not possible.\n");
}
int32_t GCCSPlayer_WeaponServices::GetTimeToMelee() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSPlayer_WeaponServices", "m_nTimeToMelee");
}
void GCCSPlayer_WeaponServices::SetTimeToMelee(int32_t value) {
    SetSchemaValue(m_ptr, "CCSPlayer_WeaponServices", "m_nTimeToMelee", false, value);
}
int32_t GCCSPlayer_WeaponServices::GetTimeToSecondary() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSPlayer_WeaponServices", "m_nTimeToSecondary");
}
void GCCSPlayer_WeaponServices::SetTimeToSecondary(int32_t value) {
    SetSchemaValue(m_ptr, "CCSPlayer_WeaponServices", "m_nTimeToSecondary", false, value);
}
int32_t GCCSPlayer_WeaponServices::GetTimeToPrimary() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSPlayer_WeaponServices", "m_nTimeToPrimary");
}
void GCCSPlayer_WeaponServices::SetTimeToPrimary(int32_t value) {
    SetSchemaValue(m_ptr, "CCSPlayer_WeaponServices", "m_nTimeToPrimary", false, value);
}
int32_t GCCSPlayer_WeaponServices::GetTimeToSniperRifle() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSPlayer_WeaponServices", "m_nTimeToSniperRifle");
}
void GCCSPlayer_WeaponServices::SetTimeToSniperRifle(int32_t value) {
    SetSchemaValue(m_ptr, "CCSPlayer_WeaponServices", "m_nTimeToSniperRifle", false, value);
}
bool GCCSPlayer_WeaponServices::GetIsBeingGivenItem() const {
    return GetSchemaValue<bool>(m_ptr, "CCSPlayer_WeaponServices", "m_bIsBeingGivenItem");
}
void GCCSPlayer_WeaponServices::SetIsBeingGivenItem(bool value) {
    SetSchemaValue(m_ptr, "CCSPlayer_WeaponServices", "m_bIsBeingGivenItem", false, value);
}
bool GCCSPlayer_WeaponServices::GetIsPickingUpItemWithUse() const {
    return GetSchemaValue<bool>(m_ptr, "CCSPlayer_WeaponServices", "m_bIsPickingUpItemWithUse");
}
void GCCSPlayer_WeaponServices::SetIsPickingUpItemWithUse(bool value) {
    SetSchemaValue(m_ptr, "CCSPlayer_WeaponServices", "m_bIsPickingUpItemWithUse", false, value);
}
bool GCCSPlayer_WeaponServices::GetPickedUpWeapon() const {
    return GetSchemaValue<bool>(m_ptr, "CCSPlayer_WeaponServices", "m_bPickedUpWeapon");
}
void GCCSPlayer_WeaponServices::SetPickedUpWeapon(bool value) {
    SetSchemaValue(m_ptr, "CCSPlayer_WeaponServices", "m_bPickedUpWeapon", false, value);
}
bool GCCSPlayer_WeaponServices::GetDisableAutoDeploy() const {
    return GetSchemaValue<bool>(m_ptr, "CCSPlayer_WeaponServices", "m_bDisableAutoDeploy");
}
void GCCSPlayer_WeaponServices::SetDisableAutoDeploy(bool value) {
    SetSchemaValue(m_ptr, "CCSPlayer_WeaponServices", "m_bDisableAutoDeploy", false, value);
}
bool GCCSPlayer_WeaponServices::GetIsPickingUpGroundWeapon() const {
    return GetSchemaValue<bool>(m_ptr, "CCSPlayer_WeaponServices", "m_bIsPickingUpGroundWeapon");
}
void GCCSPlayer_WeaponServices::SetIsPickingUpGroundWeapon(bool value) {
    SetSchemaValue(m_ptr, "CCSPlayer_WeaponServices", "m_bIsPickingUpGroundWeapon", false, value);
}
uint32_t GCCSPlayer_WeaponServices::GetOldShootPositionHistoryCount() const {
    return GetSchemaValue<uint32_t>(m_ptr, "CCSPlayer_WeaponServices", "m_nOldShootPositionHistoryCount");
}
void GCCSPlayer_WeaponServices::SetOldShootPositionHistoryCount(uint32_t value) {
    SetSchemaValue(m_ptr, "CCSPlayer_WeaponServices", "m_nOldShootPositionHistoryCount", false, value);
}
uint32_t GCCSPlayer_WeaponServices::GetOldInputHistoryCount() const {
    return GetSchemaValue<uint32_t>(m_ptr, "CCSPlayer_WeaponServices", "m_nOldInputHistoryCount");
}
void GCCSPlayer_WeaponServices::SetOldInputHistoryCount(uint32_t value) {
    SetSchemaValue(m_ptr, "CCSPlayer_WeaponServices", "m_nOldInputHistoryCount", false, value);
}
void* GCCSPlayer_WeaponServices::GetPtr() {
    return m_ptr;
}
std::string GCCSPlayer_WeaponServices::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCCSPlayer_WeaponServices::IsValid() {
    return (m_ptr != nullptr);
}
GCPlayer_WeaponServices GCCSPlayer_WeaponServices::GetParent() const {
    GCPlayer_WeaponServices value(m_ptr);
    return value;
}
void GCCSPlayer_WeaponServices::SetParent(GCPlayer_WeaponServices value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCCSPlayer_WeaponServices(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCCSPlayer_WeaponServices>("CCSPlayer_WeaponServices")
        .addConstructor<void (*)(std::string)>()
        .addProperty("NextAttack", &GCCSPlayer_WeaponServices::GetNextAttack, &GCCSPlayer_WeaponServices::SetNextAttack)
        .addProperty("IsLookingAtWeapon", &GCCSPlayer_WeaponServices::GetIsLookingAtWeapon, &GCCSPlayer_WeaponServices::SetIsLookingAtWeapon)
        .addProperty("IsHoldingLookAtWeapon", &GCCSPlayer_WeaponServices::GetIsHoldingLookAtWeapon, &GCCSPlayer_WeaponServices::SetIsHoldingLookAtWeapon)
        .addProperty("SavedWeapon", &GCCSPlayer_WeaponServices::GetSavedWeapon, &GCCSPlayer_WeaponServices::SetSavedWeapon)
        .addProperty("TimeToMelee", &GCCSPlayer_WeaponServices::GetTimeToMelee, &GCCSPlayer_WeaponServices::SetTimeToMelee)
        .addProperty("TimeToSecondary", &GCCSPlayer_WeaponServices::GetTimeToSecondary, &GCCSPlayer_WeaponServices::SetTimeToSecondary)
        .addProperty("TimeToPrimary", &GCCSPlayer_WeaponServices::GetTimeToPrimary, &GCCSPlayer_WeaponServices::SetTimeToPrimary)
        .addProperty("TimeToSniperRifle", &GCCSPlayer_WeaponServices::GetTimeToSniperRifle, &GCCSPlayer_WeaponServices::SetTimeToSniperRifle)
        .addProperty("IsBeingGivenItem", &GCCSPlayer_WeaponServices::GetIsBeingGivenItem, &GCCSPlayer_WeaponServices::SetIsBeingGivenItem)
        .addProperty("IsPickingUpItemWithUse", &GCCSPlayer_WeaponServices::GetIsPickingUpItemWithUse, &GCCSPlayer_WeaponServices::SetIsPickingUpItemWithUse)
        .addProperty("PickedUpWeapon", &GCCSPlayer_WeaponServices::GetPickedUpWeapon, &GCCSPlayer_WeaponServices::SetPickedUpWeapon)
        .addProperty("DisableAutoDeploy", &GCCSPlayer_WeaponServices::GetDisableAutoDeploy, &GCCSPlayer_WeaponServices::SetDisableAutoDeploy)
        .addProperty("IsPickingUpGroundWeapon", &GCCSPlayer_WeaponServices::GetIsPickingUpGroundWeapon, &GCCSPlayer_WeaponServices::SetIsPickingUpGroundWeapon)
        .addProperty("OldShootPositionHistoryCount", &GCCSPlayer_WeaponServices::GetOldShootPositionHistoryCount, &GCCSPlayer_WeaponServices::SetOldShootPositionHistoryCount)
        .addProperty("OldInputHistoryCount", &GCCSPlayer_WeaponServices::GetOldInputHistoryCount, &GCCSPlayer_WeaponServices::SetOldInputHistoryCount)
        .addProperty("Parent", &GCCSPlayer_WeaponServices::GetParent, &GCCSPlayer_WeaponServices::SetParent)
        .addFunction("ToPtr", &GCCSPlayer_WeaponServices::ToPtr)
        .addFunction("IsValid", &GCCSPlayer_WeaponServices::IsValid)
        .endClass();
}
GCEntityFlame::GCEntityFlame(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCEntityFlame::GCEntityFlame(void *ptr) {
    m_ptr = ptr;
}
GCBaseEntity GCEntityFlame::GetEntAttached() const {
    GCBaseEntity value((void*)(GetSchemaValue<CHandle<CEntityInstance>>(m_ptr, "CEntityFlame", "m_hEntAttached").Get()));
    return value;
}
void GCEntityFlame::SetEntAttached(GCBaseEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'EntAttached' is not possible.\n");
}
bool GCEntityFlame::GetCheapEffect() const {
    return GetSchemaValue<bool>(m_ptr, "CEntityFlame", "m_bCheapEffect");
}
void GCEntityFlame::SetCheapEffect(bool value) {
    SetSchemaValue(m_ptr, "CEntityFlame", "m_bCheapEffect", false, value);
}
float GCEntityFlame::GetSize() const {
    return GetSchemaValue<float>(m_ptr, "CEntityFlame", "m_flSize");
}
void GCEntityFlame::SetSize(float value) {
    SetSchemaValue(m_ptr, "CEntityFlame", "m_flSize", false, value);
}
bool GCEntityFlame::GetUseHitboxes() const {
    return GetSchemaValue<bool>(m_ptr, "CEntityFlame", "m_bUseHitboxes");
}
void GCEntityFlame::SetUseHitboxes(bool value) {
    SetSchemaValue(m_ptr, "CEntityFlame", "m_bUseHitboxes", false, value);
}
int32_t GCEntityFlame::GetNumHitboxFires() const {
    return GetSchemaValue<int32_t>(m_ptr, "CEntityFlame", "m_iNumHitboxFires");
}
void GCEntityFlame::SetNumHitboxFires(int32_t value) {
    SetSchemaValue(m_ptr, "CEntityFlame", "m_iNumHitboxFires", false, value);
}
float GCEntityFlame::GetHitboxFireScale() const {
    return GetSchemaValue<float>(m_ptr, "CEntityFlame", "m_flHitboxFireScale");
}
void GCEntityFlame::SetHitboxFireScale(float value) {
    SetSchemaValue(m_ptr, "CEntityFlame", "m_flHitboxFireScale", false, value);
}
float GCEntityFlame::GetLifetime() const {
    return GetSchemaValue<float>(m_ptr, "CEntityFlame", "m_flLifetime");
}
void GCEntityFlame::SetLifetime(float value) {
    SetSchemaValue(m_ptr, "CEntityFlame", "m_flLifetime", false, value);
}
GCBaseEntity GCEntityFlame::GetAttacker() const {
    GCBaseEntity value((void*)(GetSchemaValue<CHandle<CEntityInstance>>(m_ptr, "CEntityFlame", "m_hAttacker").Get()));
    return value;
}
void GCEntityFlame::SetAttacker(GCBaseEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Attacker' is not possible.\n");
}
int32_t GCEntityFlame::GetDangerSound() const {
    return GetSchemaValue<int32_t>(m_ptr, "CEntityFlame", "m_iDangerSound");
}
void GCEntityFlame::SetDangerSound(int32_t value) {
    SetSchemaValue(m_ptr, "CEntityFlame", "m_iDangerSound", false, value);
}
float GCEntityFlame::GetDirectDamagePerSecond() const {
    return GetSchemaValue<float>(m_ptr, "CEntityFlame", "m_flDirectDamagePerSecond");
}
void GCEntityFlame::SetDirectDamagePerSecond(float value) {
    SetSchemaValue(m_ptr, "CEntityFlame", "m_flDirectDamagePerSecond", false, value);
}
int32_t GCEntityFlame::GetCustomDamageType() const {
    return GetSchemaValue<int32_t>(m_ptr, "CEntityFlame", "m_iCustomDamageType");
}
void GCEntityFlame::SetCustomDamageType(int32_t value) {
    SetSchemaValue(m_ptr, "CEntityFlame", "m_iCustomDamageType", false, value);
}
void* GCEntityFlame::GetPtr() {
    return m_ptr;
}
std::string GCEntityFlame::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCEntityFlame::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseEntity GCEntityFlame::GetParent() const {
    GCBaseEntity value(m_ptr);
    return value;
}
void GCEntityFlame::SetParent(GCBaseEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCEntityFlame(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCEntityFlame>("CEntityFlame")
        .addConstructor<void (*)(std::string)>()
        .addProperty("EntAttached", &GCEntityFlame::GetEntAttached, &GCEntityFlame::SetEntAttached)
        .addProperty("CheapEffect", &GCEntityFlame::GetCheapEffect, &GCEntityFlame::SetCheapEffect)
        .addProperty("Size", &GCEntityFlame::GetSize, &GCEntityFlame::SetSize)
        .addProperty("UseHitboxes", &GCEntityFlame::GetUseHitboxes, &GCEntityFlame::SetUseHitboxes)
        .addProperty("NumHitboxFires", &GCEntityFlame::GetNumHitboxFires, &GCEntityFlame::SetNumHitboxFires)
        .addProperty("HitboxFireScale", &GCEntityFlame::GetHitboxFireScale, &GCEntityFlame::SetHitboxFireScale)
        .addProperty("Lifetime", &GCEntityFlame::GetLifetime, &GCEntityFlame::SetLifetime)
        .addProperty("Attacker", &GCEntityFlame::GetAttacker, &GCEntityFlame::SetAttacker)
        .addProperty("DangerSound", &GCEntityFlame::GetDangerSound, &GCEntityFlame::SetDangerSound)
        .addProperty("DirectDamagePerSecond", &GCEntityFlame::GetDirectDamagePerSecond, &GCEntityFlame::SetDirectDamagePerSecond)
        .addProperty("CustomDamageType", &GCEntityFlame::GetCustomDamageType, &GCEntityFlame::SetCustomDamageType)
        .addProperty("Parent", &GCEntityFlame::GetParent, &GCEntityFlame::SetParent)
        .addFunction("ToPtr", &GCEntityFlame::ToPtr)
        .addFunction("IsValid", &GCEntityFlame::IsValid)
        .endClass();
}
GCWeaponMP9::GCWeaponMP9(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCWeaponMP9::GCWeaponMP9(void *ptr) {
    m_ptr = ptr;
}
void* GCWeaponMP9::GetPtr() {
    return m_ptr;
}
std::string GCWeaponMP9::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCWeaponMP9::IsValid() {
    return (m_ptr != nullptr);
}
GCCSWeaponBaseGun GCWeaponMP9::GetParent() const {
    GCCSWeaponBaseGun value(m_ptr);
    return value;
}
void GCWeaponMP9::SetParent(GCCSWeaponBaseGun value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCWeaponMP9(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCWeaponMP9>("CWeaponMP9")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCWeaponMP9::GetParent, &GCWeaponMP9::SetParent)
        .addFunction("ToPtr", &GCWeaponMP9::ToPtr)
        .addFunction("IsValid", &GCWeaponMP9::IsValid)
        .endClass();
}
GCCSBot::GCCSBot(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCCSBot::GCCSBot(void *ptr) {
    m_ptr = ptr;
}
Vector GCCSBot::GetEyePosition() const {
    return GetSchemaValue<Vector>(m_ptr, "CCSBot", "m_eyePosition");
}
void GCCSBot::SetEyePosition(Vector value) {
    SetSchemaValue(m_ptr, "CCSBot", "m_eyePosition", false, value);
}
std::string GCCSBot::GetName() const {
    return GetSchemaValuePtr<char>(m_ptr, "CCSBot", "m_name");
}
void GCCSBot::SetName(std::string value) {
    WriteSchemaPtrValue(m_ptr, "CCSBot", "m_name", false, reinterpret_cast<byte*>(const_cast<char*>(value.c_str())), 64);
}
float GCCSBot::GetCombatRange() const {
    return GetSchemaValue<float>(m_ptr, "CCSBot", "m_combatRange");
}
void GCCSBot::SetCombatRange(float value) {
    SetSchemaValue(m_ptr, "CCSBot", "m_combatRange", false, value);
}
bool GCCSBot::GetIsRogue() const {
    return GetSchemaValue<bool>(m_ptr, "CCSBot", "m_isRogue");
}
void GCCSBot::SetIsRogue(bool value) {
    SetSchemaValue(m_ptr, "CCSBot", "m_isRogue", false, value);
}
GCountdownTimer GCCSBot::GetRogueTimer() const {
    GCountdownTimer value(GetSchemaPtr(m_ptr, "CCSBot", "m_rogueTimer"));
    return value;
}
void GCCSBot::SetRogueTimer(GCountdownTimer value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'RogueTimer' is not possible.\n");
}
bool GCCSBot::GetDiedLastRound() const {
    return GetSchemaValue<bool>(m_ptr, "CCSBot", "m_diedLastRound");
}
void GCCSBot::SetDiedLastRound(bool value) {
    SetSchemaValue(m_ptr, "CCSBot", "m_diedLastRound", false, value);
}
float GCCSBot::GetSafeTime() const {
    return GetSchemaValue<float>(m_ptr, "CCSBot", "m_safeTime");
}
void GCCSBot::SetSafeTime(float value) {
    SetSchemaValue(m_ptr, "CCSBot", "m_safeTime", false, value);
}
bool GCCSBot::GetWasSafe() const {
    return GetSchemaValue<bool>(m_ptr, "CCSBot", "m_wasSafe");
}
void GCCSBot::SetWasSafe(bool value) {
    SetSchemaValue(m_ptr, "CCSBot", "m_wasSafe", false, value);
}
bool GCCSBot::GetBlindFire() const {
    return GetSchemaValue<bool>(m_ptr, "CCSBot", "m_blindFire");
}
void GCCSBot::SetBlindFire(bool value) {
    SetSchemaValue(m_ptr, "CCSBot", "m_blindFire", false, value);
}
GCountdownTimer GCCSBot::GetSurpriseTimer() const {
    GCountdownTimer value(GetSchemaPtr(m_ptr, "CCSBot", "m_surpriseTimer"));
    return value;
}
void GCCSBot::SetSurpriseTimer(GCountdownTimer value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'SurpriseTimer' is not possible.\n");
}
bool GCCSBot::GetAllowActive() const {
    return GetSchemaValue<bool>(m_ptr, "CCSBot", "m_bAllowActive");
}
void GCCSBot::SetAllowActive(bool value) {
    SetSchemaValue(m_ptr, "CCSBot", "m_bAllowActive", false, value);
}
bool GCCSBot::GetIsFollowing() const {
    return GetSchemaValue<bool>(m_ptr, "CCSBot", "m_isFollowing");
}
void GCCSBot::SetIsFollowing(bool value) {
    SetSchemaValue(m_ptr, "CCSBot", "m_isFollowing", false, value);
}
GCCSPlayerPawn GCCSBot::GetLeader() const {
    GCCSPlayerPawn value((void*)(GetSchemaValue<CHandle<CEntityInstance>>(m_ptr, "CCSBot", "m_leader").Get()));
    return value;
}
void GCCSBot::SetLeader(GCCSPlayerPawn value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Leader' is not possible.\n");
}
float GCCSBot::GetFollowTimestamp() const {
    return GetSchemaValue<float>(m_ptr, "CCSBot", "m_followTimestamp");
}
void GCCSBot::SetFollowTimestamp(float value) {
    SetSchemaValue(m_ptr, "CCSBot", "m_followTimestamp", false, value);
}
float GCCSBot::GetAllowAutoFollowTime() const {
    return GetSchemaValue<float>(m_ptr, "CCSBot", "m_allowAutoFollowTime");
}
void GCCSBot::SetAllowAutoFollowTime(float value) {
    SetSchemaValue(m_ptr, "CCSBot", "m_allowAutoFollowTime", false, value);
}
GCountdownTimer GCCSBot::GetHurryTimer() const {
    GCountdownTimer value(GetSchemaPtr(m_ptr, "CCSBot", "m_hurryTimer"));
    return value;
}
void GCCSBot::SetHurryTimer(GCountdownTimer value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'HurryTimer' is not possible.\n");
}
GCountdownTimer GCCSBot::GetAlertTimer() const {
    GCountdownTimer value(GetSchemaPtr(m_ptr, "CCSBot", "m_alertTimer"));
    return value;
}
void GCCSBot::SetAlertTimer(GCountdownTimer value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'AlertTimer' is not possible.\n");
}
GCountdownTimer GCCSBot::GetSneakTimer() const {
    GCountdownTimer value(GetSchemaPtr(m_ptr, "CCSBot", "m_sneakTimer"));
    return value;
}
void GCCSBot::SetSneakTimer(GCountdownTimer value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'SneakTimer' is not possible.\n");
}
GCountdownTimer GCCSBot::GetPanicTimer() const {
    GCountdownTimer value(GetSchemaPtr(m_ptr, "CCSBot", "m_panicTimer"));
    return value;
}
void GCCSBot::SetPanicTimer(GCountdownTimer value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'PanicTimer' is not possible.\n");
}
float GCCSBot::GetStateTimestamp() const {
    return GetSchemaValue<float>(m_ptr, "CCSBot", "m_stateTimestamp");
}
void GCCSBot::SetStateTimestamp(float value) {
    SetSchemaValue(m_ptr, "CCSBot", "m_stateTimestamp", false, value);
}
bool GCCSBot::GetIsAttacking() const {
    return GetSchemaValue<bool>(m_ptr, "CCSBot", "m_isAttacking");
}
void GCCSBot::SetIsAttacking(bool value) {
    SetSchemaValue(m_ptr, "CCSBot", "m_isAttacking", false, value);
}
bool GCCSBot::GetIsOpeningDoor() const {
    return GetSchemaValue<bool>(m_ptr, "CCSBot", "m_isOpeningDoor");
}
void GCCSBot::SetIsOpeningDoor(bool value) {
    SetSchemaValue(m_ptr, "CCSBot", "m_isOpeningDoor", false, value);
}
GCBaseEntity GCCSBot::GetTaskEntity() const {
    GCBaseEntity value((void*)(GetSchemaValue<CHandle<CEntityInstance>>(m_ptr, "CCSBot", "m_taskEntity").Get()));
    return value;
}
void GCCSBot::SetTaskEntity(GCBaseEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'TaskEntity' is not possible.\n");
}
Vector GCCSBot::GetGoalPosition() const {
    return GetSchemaValue<Vector>(m_ptr, "CCSBot", "m_goalPosition");
}
void GCCSBot::SetGoalPosition(Vector value) {
    SetSchemaValue(m_ptr, "CCSBot", "m_goalPosition", false, value);
}
GCBaseEntity GCCSBot::GetGoalEntity() const {
    GCBaseEntity value((void*)(GetSchemaValue<CHandle<CEntityInstance>>(m_ptr, "CCSBot", "m_goalEntity").Get()));
    return value;
}
void GCCSBot::SetGoalEntity(GCBaseEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'GoalEntity' is not possible.\n");
}
GCBaseEntity GCCSBot::GetAvoid() const {
    GCBaseEntity value((void*)(GetSchemaValue<CHandle<CEntityInstance>>(m_ptr, "CCSBot", "m_avoid").Get()));
    return value;
}
void GCCSBot::SetAvoid(GCBaseEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Avoid' is not possible.\n");
}
float GCCSBot::GetAvoidTimestamp() const {
    return GetSchemaValue<float>(m_ptr, "CCSBot", "m_avoidTimestamp");
}
void GCCSBot::SetAvoidTimestamp(float value) {
    SetSchemaValue(m_ptr, "CCSBot", "m_avoidTimestamp", false, value);
}
bool GCCSBot::GetIsStopping() const {
    return GetSchemaValue<bool>(m_ptr, "CCSBot", "m_isStopping");
}
void GCCSBot::SetIsStopping(bool value) {
    SetSchemaValue(m_ptr, "CCSBot", "m_isStopping", false, value);
}
bool GCCSBot::GetHasVisitedEnemySpawn() const {
    return GetSchemaValue<bool>(m_ptr, "CCSBot", "m_hasVisitedEnemySpawn");
}
void GCCSBot::SetHasVisitedEnemySpawn(bool value) {
    SetSchemaValue(m_ptr, "CCSBot", "m_hasVisitedEnemySpawn", false, value);
}
GIntervalTimer GCCSBot::GetStillTimer() const {
    GIntervalTimer value(GetSchemaPtr(m_ptr, "CCSBot", "m_stillTimer"));
    return value;
}
void GCCSBot::SetStillTimer(GIntervalTimer value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'StillTimer' is not possible.\n");
}
bool GCCSBot::GetEyeAnglesUnderPathFinderControl() const {
    return GetSchemaValue<bool>(m_ptr, "CCSBot", "m_bEyeAnglesUnderPathFinderControl");
}
void GCCSBot::SetEyeAnglesUnderPathFinderControl(bool value) {
    SetSchemaValue(m_ptr, "CCSBot", "m_bEyeAnglesUnderPathFinderControl", false, value);
}
int32_t GCCSBot::GetPathIndex() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSBot", "m_pathIndex");
}
void GCCSBot::SetPathIndex(int32_t value) {
    SetSchemaValue(m_ptr, "CCSBot", "m_pathIndex", false, value);
}
float GCCSBot::GetAreaEnteredTimestamp() const {
    return GetSchemaValue<float>(m_ptr, "CCSBot", "m_areaEnteredTimestamp");
}
void GCCSBot::SetAreaEnteredTimestamp(float value) {
    SetSchemaValue(m_ptr, "CCSBot", "m_areaEnteredTimestamp", false, value);
}
GCountdownTimer GCCSBot::GetRepathTimer() const {
    GCountdownTimer value(GetSchemaPtr(m_ptr, "CCSBot", "m_repathTimer"));
    return value;
}
void GCCSBot::SetRepathTimer(GCountdownTimer value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'RepathTimer' is not possible.\n");
}
GCountdownTimer GCCSBot::GetAvoidFriendTimer() const {
    GCountdownTimer value(GetSchemaPtr(m_ptr, "CCSBot", "m_avoidFriendTimer"));
    return value;
}
void GCCSBot::SetAvoidFriendTimer(GCountdownTimer value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'AvoidFriendTimer' is not possible.\n");
}
bool GCCSBot::GetIsFriendInTheWay() const {
    return GetSchemaValue<bool>(m_ptr, "CCSBot", "m_isFriendInTheWay");
}
void GCCSBot::SetIsFriendInTheWay(bool value) {
    SetSchemaValue(m_ptr, "CCSBot", "m_isFriendInTheWay", false, value);
}
GCountdownTimer GCCSBot::GetPoliteTimer() const {
    GCountdownTimer value(GetSchemaPtr(m_ptr, "CCSBot", "m_politeTimer"));
    return value;
}
void GCCSBot::SetPoliteTimer(GCountdownTimer value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'PoliteTimer' is not possible.\n");
}
bool GCCSBot::GetIsWaitingBehindFriend() const {
    return GetSchemaValue<bool>(m_ptr, "CCSBot", "m_isWaitingBehindFriend");
}
void GCCSBot::SetIsWaitingBehindFriend(bool value) {
    SetSchemaValue(m_ptr, "CCSBot", "m_isWaitingBehindFriend", false, value);
}
float GCCSBot::GetPathLadderEnd() const {
    return GetSchemaValue<float>(m_ptr, "CCSBot", "m_pathLadderEnd");
}
void GCCSBot::SetPathLadderEnd(float value) {
    SetSchemaValue(m_ptr, "CCSBot", "m_pathLadderEnd", false, value);
}
GCountdownTimer GCCSBot::GetMustRunTimer() const {
    GCountdownTimer value(GetSchemaPtr(m_ptr, "CCSBot", "m_mustRunTimer"));
    return value;
}
void GCCSBot::SetMustRunTimer(GCountdownTimer value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'MustRunTimer' is not possible.\n");
}
GCountdownTimer GCCSBot::GetWaitTimer() const {
    GCountdownTimer value(GetSchemaPtr(m_ptr, "CCSBot", "m_waitTimer"));
    return value;
}
void GCCSBot::SetWaitTimer(GCountdownTimer value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'WaitTimer' is not possible.\n");
}
GCountdownTimer GCCSBot::GetUpdateTravelDistanceTimer() const {
    GCountdownTimer value(GetSchemaPtr(m_ptr, "CCSBot", "m_updateTravelDistanceTimer"));
    return value;
}
void GCCSBot::SetUpdateTravelDistanceTimer(GCountdownTimer value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'UpdateTravelDistanceTimer' is not possible.\n");
}
std::vector<float> GCCSBot::GetPlayerTravelDistance() const {
    float* outValue = (float*)GetSchemaPtr(m_ptr, "CCSBot", "m_playerTravelDistance"); std::vector<float> ret; for(int i = 0; i < 64; i++) { ret.push_back(outValue[i]); } return ret;
}
void GCCSBot::SetPlayerTravelDistance(std::vector<float> value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'PlayerTravelDistance' is not possible.\n");
}
uint32_t GCCSBot::GetTravelDistancePhase() const {
    return GetSchemaValue<uint32_t>(m_ptr, "CCSBot", "m_travelDistancePhase");
}
void GCCSBot::SetTravelDistancePhase(uint32_t value) {
    SetSchemaValue(m_ptr, "CCSBot", "m_travelDistancePhase", false, value);
}
uint32_t GCCSBot::GetHostageEscortCount() const {
    return GetSchemaValue<uint32_t>(m_ptr, "CCSBot", "m_hostageEscortCount");
}
void GCCSBot::SetHostageEscortCount(uint32_t value) {
    SetSchemaValue(m_ptr, "CCSBot", "m_hostageEscortCount", false, value);
}
float GCCSBot::GetHostageEscortCountTimestamp() const {
    return GetSchemaValue<float>(m_ptr, "CCSBot", "m_hostageEscortCountTimestamp");
}
void GCCSBot::SetHostageEscortCountTimestamp(float value) {
    SetSchemaValue(m_ptr, "CCSBot", "m_hostageEscortCountTimestamp", false, value);
}
int32_t GCCSBot::GetDesiredTeam() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSBot", "m_desiredTeam");
}
void GCCSBot::SetDesiredTeam(int32_t value) {
    SetSchemaValue(m_ptr, "CCSBot", "m_desiredTeam", false, value);
}
bool GCCSBot::GetHasJoined() const {
    return GetSchemaValue<bool>(m_ptr, "CCSBot", "m_hasJoined");
}
void GCCSBot::SetHasJoined(bool value) {
    SetSchemaValue(m_ptr, "CCSBot", "m_hasJoined", false, value);
}
bool GCCSBot::GetIsWaitingForHostage() const {
    return GetSchemaValue<bool>(m_ptr, "CCSBot", "m_isWaitingForHostage");
}
void GCCSBot::SetIsWaitingForHostage(bool value) {
    SetSchemaValue(m_ptr, "CCSBot", "m_isWaitingForHostage", false, value);
}
GCountdownTimer GCCSBot::GetInhibitWaitingForHostageTimer() const {
    GCountdownTimer value(GetSchemaPtr(m_ptr, "CCSBot", "m_inhibitWaitingForHostageTimer"));
    return value;
}
void GCCSBot::SetInhibitWaitingForHostageTimer(GCountdownTimer value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'InhibitWaitingForHostageTimer' is not possible.\n");
}
GCountdownTimer GCCSBot::GetWaitForHostageTimer() const {
    GCountdownTimer value(GetSchemaPtr(m_ptr, "CCSBot", "m_waitForHostageTimer"));
    return value;
}
void GCCSBot::SetWaitForHostageTimer(GCountdownTimer value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'WaitForHostageTimer' is not possible.\n");
}
Vector GCCSBot::GetNoisePosition() const {
    return GetSchemaValue<Vector>(m_ptr, "CCSBot", "m_noisePosition");
}
void GCCSBot::SetNoisePosition(Vector value) {
    SetSchemaValue(m_ptr, "CCSBot", "m_noisePosition", false, value);
}
float GCCSBot::GetNoiseTravelDistance() const {
    return GetSchemaValue<float>(m_ptr, "CCSBot", "m_noiseTravelDistance");
}
void GCCSBot::SetNoiseTravelDistance(float value) {
    SetSchemaValue(m_ptr, "CCSBot", "m_noiseTravelDistance", false, value);
}
float GCCSBot::GetNoiseTimestamp() const {
    return GetSchemaValue<float>(m_ptr, "CCSBot", "m_noiseTimestamp");
}
void GCCSBot::SetNoiseTimestamp(float value) {
    SetSchemaValue(m_ptr, "CCSBot", "m_noiseTimestamp", false, value);
}
GCCSPlayerPawn GCCSBot::GetNoiseSource() const {
    GCCSPlayerPawn value(*(void**)GetSchemaPtr(m_ptr, "CCSBot", "m_noiseSource"));
    return value;
}
void GCCSBot::SetNoiseSource(GCCSPlayerPawn value) {
    SetSchemaValue(m_ptr, "CCSBot","m_noiseSource", false, (char*)value.GetPtr());
}
GCountdownTimer GCCSBot::GetNoiseBendTimer() const {
    GCountdownTimer value(GetSchemaPtr(m_ptr, "CCSBot", "m_noiseBendTimer"));
    return value;
}
void GCCSBot::SetNoiseBendTimer(GCountdownTimer value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'NoiseBendTimer' is not possible.\n");
}
Vector GCCSBot::GetBentNoisePosition() const {
    return GetSchemaValue<Vector>(m_ptr, "CCSBot", "m_bentNoisePosition");
}
void GCCSBot::SetBentNoisePosition(Vector value) {
    SetSchemaValue(m_ptr, "CCSBot", "m_bentNoisePosition", false, value);
}
bool GCCSBot::GetBendNoisePositionValid() const {
    return GetSchemaValue<bool>(m_ptr, "CCSBot", "m_bendNoisePositionValid");
}
void GCCSBot::SetBendNoisePositionValid(bool value) {
    SetSchemaValue(m_ptr, "CCSBot", "m_bendNoisePositionValid", false, value);
}
float GCCSBot::GetLookAroundStateTimestamp() const {
    return GetSchemaValue<float>(m_ptr, "CCSBot", "m_lookAroundStateTimestamp");
}
void GCCSBot::SetLookAroundStateTimestamp(float value) {
    SetSchemaValue(m_ptr, "CCSBot", "m_lookAroundStateTimestamp", false, value);
}
float GCCSBot::GetLookAheadAngle() const {
    return GetSchemaValue<float>(m_ptr, "CCSBot", "m_lookAheadAngle");
}
void GCCSBot::SetLookAheadAngle(float value) {
    SetSchemaValue(m_ptr, "CCSBot", "m_lookAheadAngle", false, value);
}
float GCCSBot::GetForwardAngle() const {
    return GetSchemaValue<float>(m_ptr, "CCSBot", "m_forwardAngle");
}
void GCCSBot::SetForwardAngle(float value) {
    SetSchemaValue(m_ptr, "CCSBot", "m_forwardAngle", false, value);
}
float GCCSBot::GetInhibitLookAroundTimestamp() const {
    return GetSchemaValue<float>(m_ptr, "CCSBot", "m_inhibitLookAroundTimestamp");
}
void GCCSBot::SetInhibitLookAroundTimestamp(float value) {
    SetSchemaValue(m_ptr, "CCSBot", "m_inhibitLookAroundTimestamp", false, value);
}
Vector GCCSBot::GetLookAtSpot() const {
    return GetSchemaValue<Vector>(m_ptr, "CCSBot", "m_lookAtSpot");
}
void GCCSBot::SetLookAtSpot(Vector value) {
    SetSchemaValue(m_ptr, "CCSBot", "m_lookAtSpot", false, value);
}
float GCCSBot::GetLookAtSpotDuration() const {
    return GetSchemaValue<float>(m_ptr, "CCSBot", "m_lookAtSpotDuration");
}
void GCCSBot::SetLookAtSpotDuration(float value) {
    SetSchemaValue(m_ptr, "CCSBot", "m_lookAtSpotDuration", false, value);
}
float GCCSBot::GetLookAtSpotTimestamp() const {
    return GetSchemaValue<float>(m_ptr, "CCSBot", "m_lookAtSpotTimestamp");
}
void GCCSBot::SetLookAtSpotTimestamp(float value) {
    SetSchemaValue(m_ptr, "CCSBot", "m_lookAtSpotTimestamp", false, value);
}
float GCCSBot::GetLookAtSpotAngleTolerance() const {
    return GetSchemaValue<float>(m_ptr, "CCSBot", "m_lookAtSpotAngleTolerance");
}
void GCCSBot::SetLookAtSpotAngleTolerance(float value) {
    SetSchemaValue(m_ptr, "CCSBot", "m_lookAtSpotAngleTolerance", false, value);
}
bool GCCSBot::GetLookAtSpotClearIfClose() const {
    return GetSchemaValue<bool>(m_ptr, "CCSBot", "m_lookAtSpotClearIfClose");
}
void GCCSBot::SetLookAtSpotClearIfClose(bool value) {
    SetSchemaValue(m_ptr, "CCSBot", "m_lookAtSpotClearIfClose", false, value);
}
bool GCCSBot::GetLookAtSpotAttack() const {
    return GetSchemaValue<bool>(m_ptr, "CCSBot", "m_lookAtSpotAttack");
}
void GCCSBot::SetLookAtSpotAttack(bool value) {
    SetSchemaValue(m_ptr, "CCSBot", "m_lookAtSpotAttack", false, value);
}
std::string GCCSBot::GetLookAtDesc() const {
    return GetSchemaValuePtr<char>(m_ptr, "CCSBot", "m_lookAtDesc");
}
void GCCSBot::SetLookAtDesc(std::string value) {
    WriteSchemaPtrValue(m_ptr, "CCSBot", "m_lookAtDesc", false, reinterpret_cast<byte*>(const_cast<char*>(value.c_str())), value.size());
}
float GCCSBot::GetPeripheralTimestamp() const {
    return GetSchemaValue<float>(m_ptr, "CCSBot", "m_peripheralTimestamp");
}
void GCCSBot::SetPeripheralTimestamp(float value) {
    SetSchemaValue(m_ptr, "CCSBot", "m_peripheralTimestamp", false, value);
}
uint32_t GCCSBot::GetApproachPointCount() const {
    return GetSchemaValue<uint32_t>(m_ptr, "CCSBot", "m_approachPointCount");
}
void GCCSBot::SetApproachPointCount(uint32_t value) {
    SetSchemaValue(m_ptr, "CCSBot", "m_approachPointCount", false, value);
}
Vector GCCSBot::GetApproachPointViewPosition() const {
    return GetSchemaValue<Vector>(m_ptr, "CCSBot", "m_approachPointViewPosition");
}
void GCCSBot::SetApproachPointViewPosition(Vector value) {
    SetSchemaValue(m_ptr, "CCSBot", "m_approachPointViewPosition", false, value);
}
GIntervalTimer GCCSBot::GetViewSteadyTimer() const {
    GIntervalTimer value(GetSchemaPtr(m_ptr, "CCSBot", "m_viewSteadyTimer"));
    return value;
}
void GCCSBot::SetViewSteadyTimer(GIntervalTimer value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'ViewSteadyTimer' is not possible.\n");
}
GCountdownTimer GCCSBot::GetTossGrenadeTimer() const {
    GCountdownTimer value(GetSchemaPtr(m_ptr, "CCSBot", "m_tossGrenadeTimer"));
    return value;
}
void GCCSBot::SetTossGrenadeTimer(GCountdownTimer value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'TossGrenadeTimer' is not possible.\n");
}
GCountdownTimer GCCSBot::GetIsAvoidingGrenade() const {
    GCountdownTimer value(GetSchemaPtr(m_ptr, "CCSBot", "m_isAvoidingGrenade"));
    return value;
}
void GCCSBot::SetIsAvoidingGrenade(GCountdownTimer value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'IsAvoidingGrenade' is not possible.\n");
}
float GCCSBot::GetSpotCheckTimestamp() const {
    return GetSchemaValue<float>(m_ptr, "CCSBot", "m_spotCheckTimestamp");
}
void GCCSBot::SetSpotCheckTimestamp(float value) {
    SetSchemaValue(m_ptr, "CCSBot", "m_spotCheckTimestamp", false, value);
}
int32_t GCCSBot::GetCheckedHidingSpotCount() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSBot", "m_checkedHidingSpotCount");
}
void GCCSBot::SetCheckedHidingSpotCount(int32_t value) {
    SetSchemaValue(m_ptr, "CCSBot", "m_checkedHidingSpotCount", false, value);
}
float GCCSBot::GetLookPitch() const {
    return GetSchemaValue<float>(m_ptr, "CCSBot", "m_lookPitch");
}
void GCCSBot::SetLookPitch(float value) {
    SetSchemaValue(m_ptr, "CCSBot", "m_lookPitch", false, value);
}
float GCCSBot::GetLookPitchVel() const {
    return GetSchemaValue<float>(m_ptr, "CCSBot", "m_lookPitchVel");
}
void GCCSBot::SetLookPitchVel(float value) {
    SetSchemaValue(m_ptr, "CCSBot", "m_lookPitchVel", false, value);
}
float GCCSBot::GetLookYaw() const {
    return GetSchemaValue<float>(m_ptr, "CCSBot", "m_lookYaw");
}
void GCCSBot::SetLookYaw(float value) {
    SetSchemaValue(m_ptr, "CCSBot", "m_lookYaw", false, value);
}
float GCCSBot::GetLookYawVel() const {
    return GetSchemaValue<float>(m_ptr, "CCSBot", "m_lookYawVel");
}
void GCCSBot::SetLookYawVel(float value) {
    SetSchemaValue(m_ptr, "CCSBot", "m_lookYawVel", false, value);
}
Vector GCCSBot::GetTargetSpot() const {
    return GetSchemaValue<Vector>(m_ptr, "CCSBot", "m_targetSpot");
}
void GCCSBot::SetTargetSpot(Vector value) {
    SetSchemaValue(m_ptr, "CCSBot", "m_targetSpot", false, value);
}
Vector GCCSBot::GetTargetSpotVelocity() const {
    return GetSchemaValue<Vector>(m_ptr, "CCSBot", "m_targetSpotVelocity");
}
void GCCSBot::SetTargetSpotVelocity(Vector value) {
    SetSchemaValue(m_ptr, "CCSBot", "m_targetSpotVelocity", false, value);
}
Vector GCCSBot::GetTargetSpotPredicted() const {
    return GetSchemaValue<Vector>(m_ptr, "CCSBot", "m_targetSpotPredicted");
}
void GCCSBot::SetTargetSpotPredicted(Vector value) {
    SetSchemaValue(m_ptr, "CCSBot", "m_targetSpotPredicted", false, value);
}
QAngle GCCSBot::GetAimError() const {
    return GetSchemaValue<QAngle>(m_ptr, "CCSBot", "m_aimError");
}
void GCCSBot::SetAimError(QAngle value) {
    SetSchemaValue(m_ptr, "CCSBot", "m_aimError", false, value);
}
QAngle GCCSBot::GetAimGoal() const {
    return GetSchemaValue<QAngle>(m_ptr, "CCSBot", "m_aimGoal");
}
void GCCSBot::SetAimGoal(QAngle value) {
    SetSchemaValue(m_ptr, "CCSBot", "m_aimGoal", false, value);
}
float GCCSBot::GetTargetSpotTime() const {
    return GetSchemaValue<float>(m_ptr, "CCSBot", "m_targetSpotTime");
}
void GCCSBot::SetTargetSpotTime(float value) {
    SetSchemaValue(m_ptr, "CCSBot", "m_targetSpotTime", false, value);
}
float GCCSBot::GetAimFocus() const {
    return GetSchemaValue<float>(m_ptr, "CCSBot", "m_aimFocus");
}
void GCCSBot::SetAimFocus(float value) {
    SetSchemaValue(m_ptr, "CCSBot", "m_aimFocus", false, value);
}
float GCCSBot::GetAimFocusInterval() const {
    return GetSchemaValue<float>(m_ptr, "CCSBot", "m_aimFocusInterval");
}
void GCCSBot::SetAimFocusInterval(float value) {
    SetSchemaValue(m_ptr, "CCSBot", "m_aimFocusInterval", false, value);
}
float GCCSBot::GetAimFocusNextUpdate() const {
    return GetSchemaValue<float>(m_ptr, "CCSBot", "m_aimFocusNextUpdate");
}
void GCCSBot::SetAimFocusNextUpdate(float value) {
    SetSchemaValue(m_ptr, "CCSBot", "m_aimFocusNextUpdate", false, value);
}
GCountdownTimer GCCSBot::GetIgnoreEnemiesTimer() const {
    GCountdownTimer value(GetSchemaPtr(m_ptr, "CCSBot", "m_ignoreEnemiesTimer"));
    return value;
}
void GCCSBot::SetIgnoreEnemiesTimer(GCountdownTimer value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'IgnoreEnemiesTimer' is not possible.\n");
}
GCCSPlayerPawn GCCSBot::GetEnemy() const {
    GCCSPlayerPawn value((void*)(GetSchemaValue<CHandle<CEntityInstance>>(m_ptr, "CCSBot", "m_enemy").Get()));
    return value;
}
void GCCSBot::SetEnemy(GCCSPlayerPawn value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Enemy' is not possible.\n");
}
bool GCCSBot::GetIsEnemyVisible() const {
    return GetSchemaValue<bool>(m_ptr, "CCSBot", "m_isEnemyVisible");
}
void GCCSBot::SetIsEnemyVisible(bool value) {
    SetSchemaValue(m_ptr, "CCSBot", "m_isEnemyVisible", false, value);
}
uint32_t GCCSBot::GetVisibleEnemyParts() const {
    return GetSchemaValue<uint32_t>(m_ptr, "CCSBot", "m_visibleEnemyParts");
}
void GCCSBot::SetVisibleEnemyParts(uint32_t value) {
    SetSchemaValue(m_ptr, "CCSBot", "m_visibleEnemyParts", false, value);
}
Vector GCCSBot::GetLastEnemyPosition() const {
    return GetSchemaValue<Vector>(m_ptr, "CCSBot", "m_lastEnemyPosition");
}
void GCCSBot::SetLastEnemyPosition(Vector value) {
    SetSchemaValue(m_ptr, "CCSBot", "m_lastEnemyPosition", false, value);
}
float GCCSBot::GetLastSawEnemyTimestamp() const {
    return GetSchemaValue<float>(m_ptr, "CCSBot", "m_lastSawEnemyTimestamp");
}
void GCCSBot::SetLastSawEnemyTimestamp(float value) {
    SetSchemaValue(m_ptr, "CCSBot", "m_lastSawEnemyTimestamp", false, value);
}
float GCCSBot::GetFirstSawEnemyTimestamp() const {
    return GetSchemaValue<float>(m_ptr, "CCSBot", "m_firstSawEnemyTimestamp");
}
void GCCSBot::SetFirstSawEnemyTimestamp(float value) {
    SetSchemaValue(m_ptr, "CCSBot", "m_firstSawEnemyTimestamp", false, value);
}
float GCCSBot::GetCurrentEnemyAcquireTimestamp() const {
    return GetSchemaValue<float>(m_ptr, "CCSBot", "m_currentEnemyAcquireTimestamp");
}
void GCCSBot::SetCurrentEnemyAcquireTimestamp(float value) {
    SetSchemaValue(m_ptr, "CCSBot", "m_currentEnemyAcquireTimestamp", false, value);
}
float GCCSBot::GetEnemyDeathTimestamp() const {
    return GetSchemaValue<float>(m_ptr, "CCSBot", "m_enemyDeathTimestamp");
}
void GCCSBot::SetEnemyDeathTimestamp(float value) {
    SetSchemaValue(m_ptr, "CCSBot", "m_enemyDeathTimestamp", false, value);
}
float GCCSBot::GetFriendDeathTimestamp() const {
    return GetSchemaValue<float>(m_ptr, "CCSBot", "m_friendDeathTimestamp");
}
void GCCSBot::SetFriendDeathTimestamp(float value) {
    SetSchemaValue(m_ptr, "CCSBot", "m_friendDeathTimestamp", false, value);
}
bool GCCSBot::GetIsLastEnemyDead() const {
    return GetSchemaValue<bool>(m_ptr, "CCSBot", "m_isLastEnemyDead");
}
void GCCSBot::SetIsLastEnemyDead(bool value) {
    SetSchemaValue(m_ptr, "CCSBot", "m_isLastEnemyDead", false, value);
}
int32_t GCCSBot::GetNearbyEnemyCount() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSBot", "m_nearbyEnemyCount");
}
void GCCSBot::SetNearbyEnemyCount(int32_t value) {
    SetSchemaValue(m_ptr, "CCSBot", "m_nearbyEnemyCount", false, value);
}
GCCSPlayerPawn GCCSBot::GetBomber() const {
    GCCSPlayerPawn value((void*)(GetSchemaValue<CHandle<CEntityInstance>>(m_ptr, "CCSBot", "m_bomber").Get()));
    return value;
}
void GCCSBot::SetBomber(GCCSPlayerPawn value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Bomber' is not possible.\n");
}
int32_t GCCSBot::GetNearbyFriendCount() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSBot", "m_nearbyFriendCount");
}
void GCCSBot::SetNearbyFriendCount(int32_t value) {
    SetSchemaValue(m_ptr, "CCSBot", "m_nearbyFriendCount", false, value);
}
GCCSPlayerPawn GCCSBot::GetClosestVisibleFriend() const {
    GCCSPlayerPawn value((void*)(GetSchemaValue<CHandle<CEntityInstance>>(m_ptr, "CCSBot", "m_closestVisibleFriend").Get()));
    return value;
}
void GCCSBot::SetClosestVisibleFriend(GCCSPlayerPawn value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'ClosestVisibleFriend' is not possible.\n");
}
GCCSPlayerPawn GCCSBot::GetClosestVisibleHumanFriend() const {
    GCCSPlayerPawn value((void*)(GetSchemaValue<CHandle<CEntityInstance>>(m_ptr, "CCSBot", "m_closestVisibleHumanFriend").Get()));
    return value;
}
void GCCSBot::SetClosestVisibleHumanFriend(GCCSPlayerPawn value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'ClosestVisibleHumanFriend' is not possible.\n");
}
GIntervalTimer GCCSBot::GetAttentionInterval() const {
    GIntervalTimer value(GetSchemaPtr(m_ptr, "CCSBot", "m_attentionInterval"));
    return value;
}
void GCCSBot::SetAttentionInterval(GIntervalTimer value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'AttentionInterval' is not possible.\n");
}
GCCSPlayerPawn GCCSBot::GetAttacker() const {
    GCCSPlayerPawn value((void*)(GetSchemaValue<CHandle<CEntityInstance>>(m_ptr, "CCSBot", "m_attacker").Get()));
    return value;
}
void GCCSBot::SetAttacker(GCCSPlayerPawn value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Attacker' is not possible.\n");
}
float GCCSBot::GetAttackedTimestamp() const {
    return GetSchemaValue<float>(m_ptr, "CCSBot", "m_attackedTimestamp");
}
void GCCSBot::SetAttackedTimestamp(float value) {
    SetSchemaValue(m_ptr, "CCSBot", "m_attackedTimestamp", false, value);
}
GIntervalTimer GCCSBot::GetBurnedByFlamesTimer() const {
    GIntervalTimer value(GetSchemaPtr(m_ptr, "CCSBot", "m_burnedByFlamesTimer"));
    return value;
}
void GCCSBot::SetBurnedByFlamesTimer(GIntervalTimer value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'BurnedByFlamesTimer' is not possible.\n");
}
int32_t GCCSBot::GetLastVictimID() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSBot", "m_lastVictimID");
}
void GCCSBot::SetLastVictimID(int32_t value) {
    SetSchemaValue(m_ptr, "CCSBot", "m_lastVictimID", false, value);
}
bool GCCSBot::GetIsAimingAtEnemy() const {
    return GetSchemaValue<bool>(m_ptr, "CCSBot", "m_isAimingAtEnemy");
}
void GCCSBot::SetIsAimingAtEnemy(bool value) {
    SetSchemaValue(m_ptr, "CCSBot", "m_isAimingAtEnemy", false, value);
}
bool GCCSBot::GetIsRapidFiring() const {
    return GetSchemaValue<bool>(m_ptr, "CCSBot", "m_isRapidFiring");
}
void GCCSBot::SetIsRapidFiring(bool value) {
    SetSchemaValue(m_ptr, "CCSBot", "m_isRapidFiring", false, value);
}
GIntervalTimer GCCSBot::GetEquipTimer() const {
    GIntervalTimer value(GetSchemaPtr(m_ptr, "CCSBot", "m_equipTimer"));
    return value;
}
void GCCSBot::SetEquipTimer(GIntervalTimer value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'EquipTimer' is not possible.\n");
}
GCountdownTimer GCCSBot::GetZoomTimer() const {
    GCountdownTimer value(GetSchemaPtr(m_ptr, "CCSBot", "m_zoomTimer"));
    return value;
}
void GCCSBot::SetZoomTimer(GCountdownTimer value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'ZoomTimer' is not possible.\n");
}
float GCCSBot::GetFireWeaponTimestamp() const {
    return GetSchemaValue<float>(m_ptr, "CCSBot", "m_fireWeaponTimestamp");
}
void GCCSBot::SetFireWeaponTimestamp(float value) {
    SetSchemaValue(m_ptr, "CCSBot", "m_fireWeaponTimestamp", false, value);
}
GCountdownTimer GCCSBot::GetLookForWeaponsOnGroundTimer() const {
    GCountdownTimer value(GetSchemaPtr(m_ptr, "CCSBot", "m_lookForWeaponsOnGroundTimer"));
    return value;
}
void GCCSBot::SetLookForWeaponsOnGroundTimer(GCountdownTimer value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'LookForWeaponsOnGroundTimer' is not possible.\n");
}
bool GCCSBot::GetIsSleeping() const {
    return GetSchemaValue<bool>(m_ptr, "CCSBot", "m_bIsSleeping");
}
void GCCSBot::SetIsSleeping(bool value) {
    SetSchemaValue(m_ptr, "CCSBot", "m_bIsSleeping", false, value);
}
bool GCCSBot::GetIsEnemySniperVisible() const {
    return GetSchemaValue<bool>(m_ptr, "CCSBot", "m_isEnemySniperVisible");
}
void GCCSBot::SetIsEnemySniperVisible(bool value) {
    SetSchemaValue(m_ptr, "CCSBot", "m_isEnemySniperVisible", false, value);
}
GCountdownTimer GCCSBot::GetSawEnemySniperTimer() const {
    GCountdownTimer value(GetSchemaPtr(m_ptr, "CCSBot", "m_sawEnemySniperTimer"));
    return value;
}
void GCCSBot::SetSawEnemySniperTimer(GCountdownTimer value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'SawEnemySniperTimer' is not possible.\n");
}
uint32_t GCCSBot::GetEnemyQueueIndex() const {
    return GetSchemaValue<uint32_t>(m_ptr, "CCSBot", "m_enemyQueueIndex");
}
void GCCSBot::SetEnemyQueueIndex(uint32_t value) {
    SetSchemaValue(m_ptr, "CCSBot", "m_enemyQueueIndex", false, value);
}
uint32_t GCCSBot::GetEnemyQueueCount() const {
    return GetSchemaValue<uint32_t>(m_ptr, "CCSBot", "m_enemyQueueCount");
}
void GCCSBot::SetEnemyQueueCount(uint32_t value) {
    SetSchemaValue(m_ptr, "CCSBot", "m_enemyQueueCount", false, value);
}
uint32_t GCCSBot::GetEnemyQueueAttendIndex() const {
    return GetSchemaValue<uint32_t>(m_ptr, "CCSBot", "m_enemyQueueAttendIndex");
}
void GCCSBot::SetEnemyQueueAttendIndex(uint32_t value) {
    SetSchemaValue(m_ptr, "CCSBot", "m_enemyQueueAttendIndex", false, value);
}
bool GCCSBot::GetIsStuck() const {
    return GetSchemaValue<bool>(m_ptr, "CCSBot", "m_isStuck");
}
void GCCSBot::SetIsStuck(bool value) {
    SetSchemaValue(m_ptr, "CCSBot", "m_isStuck", false, value);
}
float GCCSBot::GetStuckTimestamp() const {
    return GetSchemaValue<float>(m_ptr, "CCSBot", "m_stuckTimestamp");
}
void GCCSBot::SetStuckTimestamp(float value) {
    SetSchemaValue(m_ptr, "CCSBot", "m_stuckTimestamp", false, value);
}
Vector GCCSBot::GetStuckSpot() const {
    return GetSchemaValue<Vector>(m_ptr, "CCSBot", "m_stuckSpot");
}
void GCCSBot::SetStuckSpot(Vector value) {
    SetSchemaValue(m_ptr, "CCSBot", "m_stuckSpot", false, value);
}
GCountdownTimer GCCSBot::GetWiggleTimer() const {
    GCountdownTimer value(GetSchemaPtr(m_ptr, "CCSBot", "m_wiggleTimer"));
    return value;
}
void GCCSBot::SetWiggleTimer(GCountdownTimer value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'WiggleTimer' is not possible.\n");
}
GCountdownTimer GCCSBot::GetStuckJumpTimer() const {
    GCountdownTimer value(GetSchemaPtr(m_ptr, "CCSBot", "m_stuckJumpTimer"));
    return value;
}
void GCCSBot::SetStuckJumpTimer(GCountdownTimer value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'StuckJumpTimer' is not possible.\n");
}
float GCCSBot::GetNextCleanupCheckTimestamp() const {
    return GetSchemaValue<float>(m_ptr, "CCSBot", "m_nextCleanupCheckTimestamp");
}
void GCCSBot::SetNextCleanupCheckTimestamp(float value) {
    SetSchemaValue(m_ptr, "CCSBot", "m_nextCleanupCheckTimestamp", false, value);
}
std::vector<float> GCCSBot::GetAvgVel() const {
    float* outValue = (float*)GetSchemaPtr(m_ptr, "CCSBot", "m_avgVel"); std::vector<float> ret; for(int i = 0; i < 10; i++) { ret.push_back(outValue[i]); } return ret;
}
void GCCSBot::SetAvgVel(std::vector<float> value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'AvgVel' is not possible.\n");
}
int32_t GCCSBot::GetAvgVelIndex() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSBot", "m_avgVelIndex");
}
void GCCSBot::SetAvgVelIndex(int32_t value) {
    SetSchemaValue(m_ptr, "CCSBot", "m_avgVelIndex", false, value);
}
int32_t GCCSBot::GetAvgVelCount() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSBot", "m_avgVelCount");
}
void GCCSBot::SetAvgVelCount(int32_t value) {
    SetSchemaValue(m_ptr, "CCSBot", "m_avgVelCount", false, value);
}
Vector GCCSBot::GetLastOrigin() const {
    return GetSchemaValue<Vector>(m_ptr, "CCSBot", "m_lastOrigin");
}
void GCCSBot::SetLastOrigin(Vector value) {
    SetSchemaValue(m_ptr, "CCSBot", "m_lastOrigin", false, value);
}
float GCCSBot::GetLastRadioRecievedTimestamp() const {
    return GetSchemaValue<float>(m_ptr, "CCSBot", "m_lastRadioRecievedTimestamp");
}
void GCCSBot::SetLastRadioRecievedTimestamp(float value) {
    SetSchemaValue(m_ptr, "CCSBot", "m_lastRadioRecievedTimestamp", false, value);
}
float GCCSBot::GetLastRadioSentTimestamp() const {
    return GetSchemaValue<float>(m_ptr, "CCSBot", "m_lastRadioSentTimestamp");
}
void GCCSBot::SetLastRadioSentTimestamp(float value) {
    SetSchemaValue(m_ptr, "CCSBot", "m_lastRadioSentTimestamp", false, value);
}
GCCSPlayerPawn GCCSBot::GetRadioSubject() const {
    GCCSPlayerPawn value((void*)(GetSchemaValue<CHandle<CEntityInstance>>(m_ptr, "CCSBot", "m_radioSubject").Get()));
    return value;
}
void GCCSBot::SetRadioSubject(GCCSPlayerPawn value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'RadioSubject' is not possible.\n");
}
Vector GCCSBot::GetRadioPosition() const {
    return GetSchemaValue<Vector>(m_ptr, "CCSBot", "m_radioPosition");
}
void GCCSBot::SetRadioPosition(Vector value) {
    SetSchemaValue(m_ptr, "CCSBot", "m_radioPosition", false, value);
}
float GCCSBot::GetVoiceEndTimestamp() const {
    return GetSchemaValue<float>(m_ptr, "CCSBot", "m_voiceEndTimestamp");
}
void GCCSBot::SetVoiceEndTimestamp(float value) {
    SetSchemaValue(m_ptr, "CCSBot", "m_voiceEndTimestamp", false, value);
}
int32_t GCCSBot::GetLastValidReactionQueueFrame() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSBot", "m_lastValidReactionQueueFrame");
}
void GCCSBot::SetLastValidReactionQueueFrame(int32_t value) {
    SetSchemaValue(m_ptr, "CCSBot", "m_lastValidReactionQueueFrame", false, value);
}
void* GCCSBot::GetPtr() {
    return m_ptr;
}
std::string GCCSBot::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCCSBot::IsValid() {
    return (m_ptr != nullptr);
}
GCBot GCCSBot::GetParent() const {
    GCBot value(m_ptr);
    return value;
}
void GCCSBot::SetParent(GCBot value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCCSBot(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCCSBot>("CCSBot")
        .addConstructor<void (*)(std::string)>()
        .addProperty("EyePosition", &GCCSBot::GetEyePosition, &GCCSBot::SetEyePosition)
        .addProperty("Name", &GCCSBot::GetName, &GCCSBot::SetName)
        .addProperty("CombatRange", &GCCSBot::GetCombatRange, &GCCSBot::SetCombatRange)
        .addProperty("IsRogue", &GCCSBot::GetIsRogue, &GCCSBot::SetIsRogue)
        .addProperty("RogueTimer", &GCCSBot::GetRogueTimer, &GCCSBot::SetRogueTimer)
        .addProperty("DiedLastRound", &GCCSBot::GetDiedLastRound, &GCCSBot::SetDiedLastRound)
        .addProperty("SafeTime", &GCCSBot::GetSafeTime, &GCCSBot::SetSafeTime)
        .addProperty("WasSafe", &GCCSBot::GetWasSafe, &GCCSBot::SetWasSafe)
        .addProperty("BlindFire", &GCCSBot::GetBlindFire, &GCCSBot::SetBlindFire)
        .addProperty("SurpriseTimer", &GCCSBot::GetSurpriseTimer, &GCCSBot::SetSurpriseTimer)
        .addProperty("AllowActive", &GCCSBot::GetAllowActive, &GCCSBot::SetAllowActive)
        .addProperty("IsFollowing", &GCCSBot::GetIsFollowing, &GCCSBot::SetIsFollowing)
        .addProperty("Leader", &GCCSBot::GetLeader, &GCCSBot::SetLeader)
        .addProperty("FollowTimestamp", &GCCSBot::GetFollowTimestamp, &GCCSBot::SetFollowTimestamp)
        .addProperty("AllowAutoFollowTime", &GCCSBot::GetAllowAutoFollowTime, &GCCSBot::SetAllowAutoFollowTime)
        .addProperty("HurryTimer", &GCCSBot::GetHurryTimer, &GCCSBot::SetHurryTimer)
        .addProperty("AlertTimer", &GCCSBot::GetAlertTimer, &GCCSBot::SetAlertTimer)
        .addProperty("SneakTimer", &GCCSBot::GetSneakTimer, &GCCSBot::SetSneakTimer)
        .addProperty("PanicTimer", &GCCSBot::GetPanicTimer, &GCCSBot::SetPanicTimer)
        .addProperty("StateTimestamp", &GCCSBot::GetStateTimestamp, &GCCSBot::SetStateTimestamp)
        .addProperty("IsAttacking", &GCCSBot::GetIsAttacking, &GCCSBot::SetIsAttacking)
        .addProperty("IsOpeningDoor", &GCCSBot::GetIsOpeningDoor, &GCCSBot::SetIsOpeningDoor)
        .addProperty("TaskEntity", &GCCSBot::GetTaskEntity, &GCCSBot::SetTaskEntity)
        .addProperty("GoalPosition", &GCCSBot::GetGoalPosition, &GCCSBot::SetGoalPosition)
        .addProperty("GoalEntity", &GCCSBot::GetGoalEntity, &GCCSBot::SetGoalEntity)
        .addProperty("Avoid", &GCCSBot::GetAvoid, &GCCSBot::SetAvoid)
        .addProperty("AvoidTimestamp", &GCCSBot::GetAvoidTimestamp, &GCCSBot::SetAvoidTimestamp)
        .addProperty("IsStopping", &GCCSBot::GetIsStopping, &GCCSBot::SetIsStopping)
        .addProperty("HasVisitedEnemySpawn", &GCCSBot::GetHasVisitedEnemySpawn, &GCCSBot::SetHasVisitedEnemySpawn)
        .addProperty("StillTimer", &GCCSBot::GetStillTimer, &GCCSBot::SetStillTimer)
        .addProperty("EyeAnglesUnderPathFinderControl", &GCCSBot::GetEyeAnglesUnderPathFinderControl, &GCCSBot::SetEyeAnglesUnderPathFinderControl)
        .addProperty("PathIndex", &GCCSBot::GetPathIndex, &GCCSBot::SetPathIndex)
        .addProperty("AreaEnteredTimestamp", &GCCSBot::GetAreaEnteredTimestamp, &GCCSBot::SetAreaEnteredTimestamp)
        .addProperty("RepathTimer", &GCCSBot::GetRepathTimer, &GCCSBot::SetRepathTimer)
        .addProperty("AvoidFriendTimer", &GCCSBot::GetAvoidFriendTimer, &GCCSBot::SetAvoidFriendTimer)
        .addProperty("IsFriendInTheWay", &GCCSBot::GetIsFriendInTheWay, &GCCSBot::SetIsFriendInTheWay)
        .addProperty("PoliteTimer", &GCCSBot::GetPoliteTimer, &GCCSBot::SetPoliteTimer)
        .addProperty("IsWaitingBehindFriend", &GCCSBot::GetIsWaitingBehindFriend, &GCCSBot::SetIsWaitingBehindFriend)
        .addProperty("PathLadderEnd", &GCCSBot::GetPathLadderEnd, &GCCSBot::SetPathLadderEnd)
        .addProperty("MustRunTimer", &GCCSBot::GetMustRunTimer, &GCCSBot::SetMustRunTimer)
        .addProperty("WaitTimer", &GCCSBot::GetWaitTimer, &GCCSBot::SetWaitTimer)
        .addProperty("UpdateTravelDistanceTimer", &GCCSBot::GetUpdateTravelDistanceTimer, &GCCSBot::SetUpdateTravelDistanceTimer)
        .addProperty("PlayerTravelDistance", &GCCSBot::GetPlayerTravelDistance, &GCCSBot::SetPlayerTravelDistance)
        .addProperty("TravelDistancePhase", &GCCSBot::GetTravelDistancePhase, &GCCSBot::SetTravelDistancePhase)
        .addProperty("HostageEscortCount", &GCCSBot::GetHostageEscortCount, &GCCSBot::SetHostageEscortCount)
        .addProperty("HostageEscortCountTimestamp", &GCCSBot::GetHostageEscortCountTimestamp, &GCCSBot::SetHostageEscortCountTimestamp)
        .addProperty("DesiredTeam", &GCCSBot::GetDesiredTeam, &GCCSBot::SetDesiredTeam)
        .addProperty("HasJoined", &GCCSBot::GetHasJoined, &GCCSBot::SetHasJoined)
        .addProperty("IsWaitingForHostage", &GCCSBot::GetIsWaitingForHostage, &GCCSBot::SetIsWaitingForHostage)
        .addProperty("InhibitWaitingForHostageTimer", &GCCSBot::GetInhibitWaitingForHostageTimer, &GCCSBot::SetInhibitWaitingForHostageTimer)
        .addProperty("WaitForHostageTimer", &GCCSBot::GetWaitForHostageTimer, &GCCSBot::SetWaitForHostageTimer)
        .addProperty("NoisePosition", &GCCSBot::GetNoisePosition, &GCCSBot::SetNoisePosition)
        .addProperty("NoiseTravelDistance", &GCCSBot::GetNoiseTravelDistance, &GCCSBot::SetNoiseTravelDistance)
        .addProperty("NoiseTimestamp", &GCCSBot::GetNoiseTimestamp, &GCCSBot::SetNoiseTimestamp)
        .addProperty("NoiseSource", &GCCSBot::GetNoiseSource, &GCCSBot::SetNoiseSource)
        .addProperty("NoiseBendTimer", &GCCSBot::GetNoiseBendTimer, &GCCSBot::SetNoiseBendTimer)
        .addProperty("BentNoisePosition", &GCCSBot::GetBentNoisePosition, &GCCSBot::SetBentNoisePosition)
        .addProperty("BendNoisePositionValid", &GCCSBot::GetBendNoisePositionValid, &GCCSBot::SetBendNoisePositionValid)
        .addProperty("LookAroundStateTimestamp", &GCCSBot::GetLookAroundStateTimestamp, &GCCSBot::SetLookAroundStateTimestamp)
        .addProperty("LookAheadAngle", &GCCSBot::GetLookAheadAngle, &GCCSBot::SetLookAheadAngle)
        .addProperty("ForwardAngle", &GCCSBot::GetForwardAngle, &GCCSBot::SetForwardAngle)
        .addProperty("InhibitLookAroundTimestamp", &GCCSBot::GetInhibitLookAroundTimestamp, &GCCSBot::SetInhibitLookAroundTimestamp)
        .addProperty("LookAtSpot", &GCCSBot::GetLookAtSpot, &GCCSBot::SetLookAtSpot)
        .addProperty("LookAtSpotDuration", &GCCSBot::GetLookAtSpotDuration, &GCCSBot::SetLookAtSpotDuration)
        .addProperty("LookAtSpotTimestamp", &GCCSBot::GetLookAtSpotTimestamp, &GCCSBot::SetLookAtSpotTimestamp)
        .addProperty("LookAtSpotAngleTolerance", &GCCSBot::GetLookAtSpotAngleTolerance, &GCCSBot::SetLookAtSpotAngleTolerance)
        .addProperty("LookAtSpotClearIfClose", &GCCSBot::GetLookAtSpotClearIfClose, &GCCSBot::SetLookAtSpotClearIfClose)
        .addProperty("LookAtSpotAttack", &GCCSBot::GetLookAtSpotAttack, &GCCSBot::SetLookAtSpotAttack)
        .addProperty("LookAtDesc", &GCCSBot::GetLookAtDesc, &GCCSBot::SetLookAtDesc)
        .addProperty("PeripheralTimestamp", &GCCSBot::GetPeripheralTimestamp, &GCCSBot::SetPeripheralTimestamp)
        .addProperty("ApproachPointCount", &GCCSBot::GetApproachPointCount, &GCCSBot::SetApproachPointCount)
        .addProperty("ApproachPointViewPosition", &GCCSBot::GetApproachPointViewPosition, &GCCSBot::SetApproachPointViewPosition)
        .addProperty("ViewSteadyTimer", &GCCSBot::GetViewSteadyTimer, &GCCSBot::SetViewSteadyTimer)
        .addProperty("TossGrenadeTimer", &GCCSBot::GetTossGrenadeTimer, &GCCSBot::SetTossGrenadeTimer)
        .addProperty("IsAvoidingGrenade", &GCCSBot::GetIsAvoidingGrenade, &GCCSBot::SetIsAvoidingGrenade)
        .addProperty("SpotCheckTimestamp", &GCCSBot::GetSpotCheckTimestamp, &GCCSBot::SetSpotCheckTimestamp)
        .addProperty("CheckedHidingSpotCount", &GCCSBot::GetCheckedHidingSpotCount, &GCCSBot::SetCheckedHidingSpotCount)
        .addProperty("LookPitch", &GCCSBot::GetLookPitch, &GCCSBot::SetLookPitch)
        .addProperty("LookPitchVel", &GCCSBot::GetLookPitchVel, &GCCSBot::SetLookPitchVel)
        .addProperty("LookYaw", &GCCSBot::GetLookYaw, &GCCSBot::SetLookYaw)
        .addProperty("LookYawVel", &GCCSBot::GetLookYawVel, &GCCSBot::SetLookYawVel)
        .addProperty("TargetSpot", &GCCSBot::GetTargetSpot, &GCCSBot::SetTargetSpot)
        .addProperty("TargetSpotVelocity", &GCCSBot::GetTargetSpotVelocity, &GCCSBot::SetTargetSpotVelocity)
        .addProperty("TargetSpotPredicted", &GCCSBot::GetTargetSpotPredicted, &GCCSBot::SetTargetSpotPredicted)
        .addProperty("AimError", &GCCSBot::GetAimError, &GCCSBot::SetAimError)
        .addProperty("AimGoal", &GCCSBot::GetAimGoal, &GCCSBot::SetAimGoal)
        .addProperty("TargetSpotTime", &GCCSBot::GetTargetSpotTime, &GCCSBot::SetTargetSpotTime)
        .addProperty("AimFocus", &GCCSBot::GetAimFocus, &GCCSBot::SetAimFocus)
        .addProperty("AimFocusInterval", &GCCSBot::GetAimFocusInterval, &GCCSBot::SetAimFocusInterval)
        .addProperty("AimFocusNextUpdate", &GCCSBot::GetAimFocusNextUpdate, &GCCSBot::SetAimFocusNextUpdate)
        .addProperty("IgnoreEnemiesTimer", &GCCSBot::GetIgnoreEnemiesTimer, &GCCSBot::SetIgnoreEnemiesTimer)
        .addProperty("Enemy", &GCCSBot::GetEnemy, &GCCSBot::SetEnemy)
        .addProperty("IsEnemyVisible", &GCCSBot::GetIsEnemyVisible, &GCCSBot::SetIsEnemyVisible)
        .addProperty("VisibleEnemyParts", &GCCSBot::GetVisibleEnemyParts, &GCCSBot::SetVisibleEnemyParts)
        .addProperty("LastEnemyPosition", &GCCSBot::GetLastEnemyPosition, &GCCSBot::SetLastEnemyPosition)
        .addProperty("LastSawEnemyTimestamp", &GCCSBot::GetLastSawEnemyTimestamp, &GCCSBot::SetLastSawEnemyTimestamp)
        .addProperty("FirstSawEnemyTimestamp", &GCCSBot::GetFirstSawEnemyTimestamp, &GCCSBot::SetFirstSawEnemyTimestamp)
        .addProperty("CurrentEnemyAcquireTimestamp", &GCCSBot::GetCurrentEnemyAcquireTimestamp, &GCCSBot::SetCurrentEnemyAcquireTimestamp)
        .addProperty("EnemyDeathTimestamp", &GCCSBot::GetEnemyDeathTimestamp, &GCCSBot::SetEnemyDeathTimestamp)
        .addProperty("FriendDeathTimestamp", &GCCSBot::GetFriendDeathTimestamp, &GCCSBot::SetFriendDeathTimestamp)
        .addProperty("IsLastEnemyDead", &GCCSBot::GetIsLastEnemyDead, &GCCSBot::SetIsLastEnemyDead)
        .addProperty("NearbyEnemyCount", &GCCSBot::GetNearbyEnemyCount, &GCCSBot::SetNearbyEnemyCount)
        .addProperty("Bomber", &GCCSBot::GetBomber, &GCCSBot::SetBomber)
        .addProperty("NearbyFriendCount", &GCCSBot::GetNearbyFriendCount, &GCCSBot::SetNearbyFriendCount)
        .addProperty("ClosestVisibleFriend", &GCCSBot::GetClosestVisibleFriend, &GCCSBot::SetClosestVisibleFriend)
        .addProperty("ClosestVisibleHumanFriend", &GCCSBot::GetClosestVisibleHumanFriend, &GCCSBot::SetClosestVisibleHumanFriend)
        .addProperty("AttentionInterval", &GCCSBot::GetAttentionInterval, &GCCSBot::SetAttentionInterval)
        .addProperty("Attacker", &GCCSBot::GetAttacker, &GCCSBot::SetAttacker)
        .addProperty("AttackedTimestamp", &GCCSBot::GetAttackedTimestamp, &GCCSBot::SetAttackedTimestamp)
        .addProperty("BurnedByFlamesTimer", &GCCSBot::GetBurnedByFlamesTimer, &GCCSBot::SetBurnedByFlamesTimer)
        .addProperty("LastVictimID", &GCCSBot::GetLastVictimID, &GCCSBot::SetLastVictimID)
        .addProperty("IsAimingAtEnemy", &GCCSBot::GetIsAimingAtEnemy, &GCCSBot::SetIsAimingAtEnemy)
        .addProperty("IsRapidFiring", &GCCSBot::GetIsRapidFiring, &GCCSBot::SetIsRapidFiring)
        .addProperty("EquipTimer", &GCCSBot::GetEquipTimer, &GCCSBot::SetEquipTimer)
        .addProperty("ZoomTimer", &GCCSBot::GetZoomTimer, &GCCSBot::SetZoomTimer)
        .addProperty("FireWeaponTimestamp", &GCCSBot::GetFireWeaponTimestamp, &GCCSBot::SetFireWeaponTimestamp)
        .addProperty("LookForWeaponsOnGroundTimer", &GCCSBot::GetLookForWeaponsOnGroundTimer, &GCCSBot::SetLookForWeaponsOnGroundTimer)
        .addProperty("IsSleeping", &GCCSBot::GetIsSleeping, &GCCSBot::SetIsSleeping)
        .addProperty("IsEnemySniperVisible", &GCCSBot::GetIsEnemySniperVisible, &GCCSBot::SetIsEnemySniperVisible)
        .addProperty("SawEnemySniperTimer", &GCCSBot::GetSawEnemySniperTimer, &GCCSBot::SetSawEnemySniperTimer)
        .addProperty("EnemyQueueIndex", &GCCSBot::GetEnemyQueueIndex, &GCCSBot::SetEnemyQueueIndex)
        .addProperty("EnemyQueueCount", &GCCSBot::GetEnemyQueueCount, &GCCSBot::SetEnemyQueueCount)
        .addProperty("EnemyQueueAttendIndex", &GCCSBot::GetEnemyQueueAttendIndex, &GCCSBot::SetEnemyQueueAttendIndex)
        .addProperty("IsStuck", &GCCSBot::GetIsStuck, &GCCSBot::SetIsStuck)
        .addProperty("StuckTimestamp", &GCCSBot::GetStuckTimestamp, &GCCSBot::SetStuckTimestamp)
        .addProperty("StuckSpot", &GCCSBot::GetStuckSpot, &GCCSBot::SetStuckSpot)
        .addProperty("WiggleTimer", &GCCSBot::GetWiggleTimer, &GCCSBot::SetWiggleTimer)
        .addProperty("StuckJumpTimer", &GCCSBot::GetStuckJumpTimer, &GCCSBot::SetStuckJumpTimer)
        .addProperty("NextCleanupCheckTimestamp", &GCCSBot::GetNextCleanupCheckTimestamp, &GCCSBot::SetNextCleanupCheckTimestamp)
        .addProperty("AvgVel", &GCCSBot::GetAvgVel, &GCCSBot::SetAvgVel)
        .addProperty("AvgVelIndex", &GCCSBot::GetAvgVelIndex, &GCCSBot::SetAvgVelIndex)
        .addProperty("AvgVelCount", &GCCSBot::GetAvgVelCount, &GCCSBot::SetAvgVelCount)
        .addProperty("LastOrigin", &GCCSBot::GetLastOrigin, &GCCSBot::SetLastOrigin)
        .addProperty("LastRadioRecievedTimestamp", &GCCSBot::GetLastRadioRecievedTimestamp, &GCCSBot::SetLastRadioRecievedTimestamp)
        .addProperty("LastRadioSentTimestamp", &GCCSBot::GetLastRadioSentTimestamp, &GCCSBot::SetLastRadioSentTimestamp)
        .addProperty("RadioSubject", &GCCSBot::GetRadioSubject, &GCCSBot::SetRadioSubject)
        .addProperty("RadioPosition", &GCCSBot::GetRadioPosition, &GCCSBot::SetRadioPosition)
        .addProperty("VoiceEndTimestamp", &GCCSBot::GetVoiceEndTimestamp, &GCCSBot::SetVoiceEndTimestamp)
        .addProperty("LastValidReactionQueueFrame", &GCCSBot::GetLastValidReactionQueueFrame, &GCCSBot::SetLastValidReactionQueueFrame)
        .addProperty("Parent", &GCCSBot::GetParent, &GCCSBot::SetParent)
        .addFunction("ToPtr", &GCCSBot::ToPtr)
        .addFunction("IsValid", &GCCSBot::IsValid)
        .endClass();
}
GCEntityIdentity::GCEntityIdentity(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCEntityIdentity::GCEntityIdentity(void *ptr) {
    m_ptr = ptr;
}
int32_t GCEntityIdentity::GetNameStringableIndex() const {
    return GetSchemaValue<int32_t>(m_ptr, "CEntityIdentity", "m_nameStringableIndex");
}
void GCEntityIdentity::SetNameStringableIndex(int32_t value) {
    SetSchemaValue(m_ptr, "CEntityIdentity", "m_nameStringableIndex", false, value);
}
std::string GCEntityIdentity::GetName() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CEntityIdentity", "m_name").String();
}
void GCEntityIdentity::SetName(std::string value) {
    SetSchemaValue(m_ptr, "CEntityIdentity", "m_name", false, CUtlSymbolLarge(value.c_str()));
}
std::string GCEntityIdentity::GetDesignerName() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CEntityIdentity", "m_designerName").String();
}
void GCEntityIdentity::SetDesignerName(std::string value) {
    SetSchemaValue(m_ptr, "CEntityIdentity", "m_designerName", false, CUtlSymbolLarge(value.c_str()));
}
uint32_t GCEntityIdentity::GetFlags() const {
    return GetSchemaValue<uint32_t>(m_ptr, "CEntityIdentity", "m_flags");
}
void GCEntityIdentity::SetFlags(uint32_t value) {
    SetSchemaValue(m_ptr, "CEntityIdentity", "m_flags", false, value);
}
uint32_t GCEntityIdentity::GetWorldGroupId() const {
    return GetSchemaValue<CUtlStringToken>(m_ptr, "CEntityIdentity", "m_worldGroupId").m_nHashCode;
}
void GCEntityIdentity::SetWorldGroupId(uint32_t value) {
    SetSchemaValue(m_ptr, "CEntityIdentity", "m_worldGroupId", false, CUtlStringToken(value));
}
uint32_t GCEntityIdentity::GetDataObjectTypes() const {
    return GetSchemaValue<uint32_t>(m_ptr, "CEntityIdentity", "m_fDataObjectTypes");
}
void GCEntityIdentity::SetDataObjectTypes(uint32_t value) {
    SetSchemaValue(m_ptr, "CEntityIdentity", "m_fDataObjectTypes", false, value);
}
GChangeAccessorFieldPathIndex_t GCEntityIdentity::GetPathIndex() const {
    GChangeAccessorFieldPathIndex_t value(GetSchemaPtr(m_ptr, "CEntityIdentity", "m_PathIndex"));
    return value;
}
void GCEntityIdentity::SetPathIndex(GChangeAccessorFieldPathIndex_t value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'PathIndex' is not possible.\n");
}
GCEntityIdentity GCEntityIdentity::GetPrev() const {
    GCEntityIdentity value(*(void**)GetSchemaPtr(m_ptr, "CEntityIdentity", "m_pPrev"));
    return value;
}
void GCEntityIdentity::SetPrev(GCEntityIdentity value) {
    SetSchemaValue(m_ptr, "CEntityIdentity","m_pPrev", false, (char*)value.GetPtr());
}
GCEntityIdentity GCEntityIdentity::GetNext() const {
    GCEntityIdentity value(*(void**)GetSchemaPtr(m_ptr, "CEntityIdentity", "m_pNext"));
    return value;
}
void GCEntityIdentity::SetNext(GCEntityIdentity value) {
    SetSchemaValue(m_ptr, "CEntityIdentity","m_pNext", false, (char*)value.GetPtr());
}
GCEntityIdentity GCEntityIdentity::GetPrevByClass() const {
    GCEntityIdentity value(*(void**)GetSchemaPtr(m_ptr, "CEntityIdentity", "m_pPrevByClass"));
    return value;
}
void GCEntityIdentity::SetPrevByClass(GCEntityIdentity value) {
    SetSchemaValue(m_ptr, "CEntityIdentity","m_pPrevByClass", false, (char*)value.GetPtr());
}
GCEntityIdentity GCEntityIdentity::GetNextByClass() const {
    GCEntityIdentity value(*(void**)GetSchemaPtr(m_ptr, "CEntityIdentity", "m_pNextByClass"));
    return value;
}
void GCEntityIdentity::SetNextByClass(GCEntityIdentity value) {
    SetSchemaValue(m_ptr, "CEntityIdentity","m_pNextByClass", false, (char*)value.GetPtr());
}
void* GCEntityIdentity::GetPtr() {
    return m_ptr;
}
std::string GCEntityIdentity::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCEntityIdentity::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCEntityIdentity(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCEntityIdentity>("CEntityIdentity")
        .addConstructor<void (*)(std::string)>()
        .addProperty("NameStringableIndex", &GCEntityIdentity::GetNameStringableIndex, &GCEntityIdentity::SetNameStringableIndex)
        .addProperty("Name", &GCEntityIdentity::GetName, &GCEntityIdentity::SetName)
        .addProperty("DesignerName", &GCEntityIdentity::GetDesignerName, &GCEntityIdentity::SetDesignerName)
        .addProperty("Flags", &GCEntityIdentity::GetFlags, &GCEntityIdentity::SetFlags)
        .addProperty("WorldGroupId", &GCEntityIdentity::GetWorldGroupId, &GCEntityIdentity::SetWorldGroupId)
        .addProperty("DataObjectTypes", &GCEntityIdentity::GetDataObjectTypes, &GCEntityIdentity::SetDataObjectTypes)
        .addProperty("PathIndex", &GCEntityIdentity::GetPathIndex, &GCEntityIdentity::SetPathIndex)
        .addProperty("Prev", &GCEntityIdentity::GetPrev, &GCEntityIdentity::SetPrev)
        .addProperty("Next", &GCEntityIdentity::GetNext, &GCEntityIdentity::SetNext)
        .addProperty("PrevByClass", &GCEntityIdentity::GetPrevByClass, &GCEntityIdentity::SetPrevByClass)
        .addProperty("NextByClass", &GCEntityIdentity::GetNextByClass, &GCEntityIdentity::SetNextByClass)
        .addFunction("ToPtr", &GCEntityIdentity::ToPtr)
        .addFunction("IsValid", &GCEntityIdentity::IsValid)
        .endClass();
}
GCGunTarget::GCGunTarget(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCGunTarget::GCGunTarget(void *ptr) {
    m_ptr = ptr;
}
bool GCGunTarget::GetOn() const {
    return GetSchemaValue<bool>(m_ptr, "CGunTarget", "m_on");
}
void GCGunTarget::SetOn(bool value) {
    SetSchemaValue(m_ptr, "CGunTarget", "m_on", false, value);
}
GCBaseEntity GCGunTarget::GetTargetEnt() const {
    GCBaseEntity value((void*)(GetSchemaValue<CHandle<CEntityInstance>>(m_ptr, "CGunTarget", "m_hTargetEnt").Get()));
    return value;
}
void GCGunTarget::SetTargetEnt(GCBaseEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'TargetEnt' is not possible.\n");
}
GCEntityIOOutput GCGunTarget::GetOnDeath() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CGunTarget", "m_OnDeath"));
    return value;
}
void GCGunTarget::SetOnDeath(GCEntityIOOutput value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'OnDeath' is not possible.\n");
}
void* GCGunTarget::GetPtr() {
    return m_ptr;
}
std::string GCGunTarget::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCGunTarget::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseToggle GCGunTarget::GetParent() const {
    GCBaseToggle value(m_ptr);
    return value;
}
void GCGunTarget::SetParent(GCBaseToggle value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCGunTarget(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCGunTarget>("CGunTarget")
        .addConstructor<void (*)(std::string)>()
        .addProperty("On", &GCGunTarget::GetOn, &GCGunTarget::SetOn)
        .addProperty("TargetEnt", &GCGunTarget::GetTargetEnt, &GCGunTarget::SetTargetEnt)
        .addProperty("OnDeath", &GCGunTarget::GetOnDeath, &GCGunTarget::SetOnDeath)
        .addProperty("Parent", &GCGunTarget::GetParent, &GCGunTarget::SetParent)
        .addFunction("ToPtr", &GCGunTarget::ToPtr)
        .addFunction("IsValid", &GCGunTarget::IsValid)
        .endClass();
}
GCSoundEventParameter::GCSoundEventParameter(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCSoundEventParameter::GCSoundEventParameter(void *ptr) {
    m_ptr = ptr;
}
std::string GCSoundEventParameter::GetParamName() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CSoundEventParameter", "m_iszParamName").String();
}
void GCSoundEventParameter::SetParamName(std::string value) {
    SetSchemaValue(m_ptr, "CSoundEventParameter", "m_iszParamName", false, CUtlSymbolLarge(value.c_str()));
}
float GCSoundEventParameter::GetFloatValue() const {
    return GetSchemaValue<float>(m_ptr, "CSoundEventParameter", "m_flFloatValue");
}
void GCSoundEventParameter::SetFloatValue(float value) {
    SetSchemaValue(m_ptr, "CSoundEventParameter", "m_flFloatValue", false, value);
}
void* GCSoundEventParameter::GetPtr() {
    return m_ptr;
}
std::string GCSoundEventParameter::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCSoundEventParameter::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseEntity GCSoundEventParameter::GetParent() const {
    GCBaseEntity value(m_ptr);
    return value;
}
void GCSoundEventParameter::SetParent(GCBaseEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCSoundEventParameter(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCSoundEventParameter>("CSoundEventParameter")
        .addConstructor<void (*)(std::string)>()
        .addProperty("ParamName", &GCSoundEventParameter::GetParamName, &GCSoundEventParameter::SetParamName)
        .addProperty("FloatValue", &GCSoundEventParameter::GetFloatValue, &GCSoundEventParameter::SetFloatValue)
        .addProperty("Parent", &GCSoundEventParameter::GetParent, &GCSoundEventParameter::SetParent)
        .addFunction("ToPtr", &GCSoundEventParameter::ToPtr)
        .addFunction("IsValid", &GCSoundEventParameter::IsValid)
        .endClass();
}
GCSimpleMarkupVolumeTagged::GCSimpleMarkupVolumeTagged(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCSimpleMarkupVolumeTagged::GCSimpleMarkupVolumeTagged(void *ptr) {
    m_ptr = ptr;
}
void* GCSimpleMarkupVolumeTagged::GetPtr() {
    return m_ptr;
}
std::string GCSimpleMarkupVolumeTagged::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCSimpleMarkupVolumeTagged::IsValid() {
    return (m_ptr != nullptr);
}
GCMarkupVolumeTagged GCSimpleMarkupVolumeTagged::GetParent() const {
    GCMarkupVolumeTagged value(m_ptr);
    return value;
}
void GCSimpleMarkupVolumeTagged::SetParent(GCMarkupVolumeTagged value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCSimpleMarkupVolumeTagged(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCSimpleMarkupVolumeTagged>("CSimpleMarkupVolumeTagged")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCSimpleMarkupVolumeTagged::GetParent, &GCSimpleMarkupVolumeTagged::SetParent)
        .addFunction("ToPtr", &GCSimpleMarkupVolumeTagged::ToPtr)
        .addFunction("IsValid", &GCSimpleMarkupVolumeTagged::IsValid)
        .endClass();
}
GCTestEffect::GCTestEffect(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCTestEffect::GCTestEffect(void *ptr) {
    m_ptr = ptr;
}
int32_t GCTestEffect::GetLoop() const {
    return GetSchemaValue<int32_t>(m_ptr, "CTestEffect", "m_iLoop");
}
void GCTestEffect::SetLoop(int32_t value) {
    SetSchemaValue(m_ptr, "CTestEffect", "m_iLoop", false, value);
}
int32_t GCTestEffect::GetBeam() const {
    return GetSchemaValue<int32_t>(m_ptr, "CTestEffect", "m_iBeam");
}
void GCTestEffect::SetBeam(int32_t value) {
    SetSchemaValue(m_ptr, "CTestEffect", "m_iBeam", false, value);
}
std::vector<GCBeam*> GCTestEffect::GetBeam1() const {
    GCBeam** outValue = (GCBeam**)GetSchemaPtr(m_ptr, "CTestEffect", "m_pBeam"); std::vector<GCBeam*> ret; for(int i = 0; i < 24; i++) { ret.push_back(outValue[i]); } return ret;
}
void GCTestEffect::SetBeam1(std::vector<GCBeam*> value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Beam1' is not possible.\n");
}
std::vector<float> GCTestEffect::GetBeamTime() const {
    float* outValue = (float*)GetSchemaPtr(m_ptr, "CTestEffect", "m_flBeamTime"); std::vector<float> ret; for(int i = 0; i < 24; i++) { ret.push_back(outValue[i]); } return ret;
}
void GCTestEffect::SetBeamTime(std::vector<float> value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'BeamTime' is not possible.\n");
}
float GCTestEffect::GetStartTime() const {
    return GetSchemaValue<float>(m_ptr, "CTestEffect", "m_flStartTime");
}
void GCTestEffect::SetStartTime(float value) {
    SetSchemaValue(m_ptr, "CTestEffect", "m_flStartTime", false, value);
}
void* GCTestEffect::GetPtr() {
    return m_ptr;
}
std::string GCTestEffect::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCTestEffect::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseEntity GCTestEffect::GetParent() const {
    GCBaseEntity value(m_ptr);
    return value;
}
void GCTestEffect::SetParent(GCBaseEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCTestEffect(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCTestEffect>("CTestEffect")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Loop", &GCTestEffect::GetLoop, &GCTestEffect::SetLoop)
        .addProperty("Beam", &GCTestEffect::GetBeam, &GCTestEffect::SetBeam)
        .addProperty("Beam1", &GCTestEffect::GetBeam1, &GCTestEffect::SetBeam1)
        .addProperty("BeamTime", &GCTestEffect::GetBeamTime, &GCTestEffect::SetBeamTime)
        .addProperty("StartTime", &GCTestEffect::GetStartTime, &GCTestEffect::SetStartTime)
        .addProperty("Parent", &GCTestEffect::GetParent, &GCTestEffect::SetParent)
        .addFunction("ToPtr", &GCTestEffect::ToPtr)
        .addFunction("IsValid", &GCTestEffect::IsValid)
        .endClass();
}
GCWeaponM4A1Silencer::GCWeaponM4A1Silencer(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCWeaponM4A1Silencer::GCWeaponM4A1Silencer(void *ptr) {
    m_ptr = ptr;
}
void* GCWeaponM4A1Silencer::GetPtr() {
    return m_ptr;
}
std::string GCWeaponM4A1Silencer::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCWeaponM4A1Silencer::IsValid() {
    return (m_ptr != nullptr);
}
GCCSWeaponBaseGun GCWeaponM4A1Silencer::GetParent() const {
    GCCSWeaponBaseGun value(m_ptr);
    return value;
}
void GCWeaponM4A1Silencer::SetParent(GCCSWeaponBaseGun value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCWeaponM4A1Silencer(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCWeaponM4A1Silencer>("CWeaponM4A1Silencer")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCWeaponM4A1Silencer::GetParent, &GCWeaponM4A1Silencer::SetParent)
        .addFunction("ToPtr", &GCWeaponM4A1Silencer::ToPtr)
        .addFunction("IsValid", &GCWeaponM4A1Silencer::IsValid)
        .endClass();
}
GCScriptNavBlocker::GCScriptNavBlocker(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCScriptNavBlocker::GCScriptNavBlocker(void *ptr) {
    m_ptr = ptr;
}
Vector GCScriptNavBlocker::GetExtent() const {
    return GetSchemaValue<Vector>(m_ptr, "CScriptNavBlocker", "m_vExtent");
}
void GCScriptNavBlocker::SetExtent(Vector value) {
    SetSchemaValue(m_ptr, "CScriptNavBlocker", "m_vExtent", false, value);
}
void* GCScriptNavBlocker::GetPtr() {
    return m_ptr;
}
std::string GCScriptNavBlocker::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCScriptNavBlocker::IsValid() {
    return (m_ptr != nullptr);
}
GCFuncNavBlocker GCScriptNavBlocker::GetParent() const {
    GCFuncNavBlocker value(m_ptr);
    return value;
}
void GCScriptNavBlocker::SetParent(GCFuncNavBlocker value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCScriptNavBlocker(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCScriptNavBlocker>("CScriptNavBlocker")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Extent", &GCScriptNavBlocker::GetExtent, &GCScriptNavBlocker::SetExtent)
        .addProperty("Parent", &GCScriptNavBlocker::GetParent, &GCScriptNavBlocker::SetParent)
        .addFunction("ToPtr", &GCScriptNavBlocker::ToPtr)
        .addFunction("IsValid", &GCScriptNavBlocker::IsValid)
        .endClass();
}
GCConstraintAnchor::GCConstraintAnchor(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCConstraintAnchor::GCConstraintAnchor(void *ptr) {
    m_ptr = ptr;
}
float GCConstraintAnchor::GetMassScale() const {
    return GetSchemaValue<float>(m_ptr, "CConstraintAnchor", "m_massScale");
}
void GCConstraintAnchor::SetMassScale(float value) {
    SetSchemaValue(m_ptr, "CConstraintAnchor", "m_massScale", false, value);
}
void* GCConstraintAnchor::GetPtr() {
    return m_ptr;
}
std::string GCConstraintAnchor::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCConstraintAnchor::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseAnimGraph GCConstraintAnchor::GetParent() const {
    GCBaseAnimGraph value(m_ptr);
    return value;
}
void GCConstraintAnchor::SetParent(GCBaseAnimGraph value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCConstraintAnchor(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCConstraintAnchor>("CConstraintAnchor")
        .addConstructor<void (*)(std::string)>()
        .addProperty("MassScale", &GCConstraintAnchor::GetMassScale, &GCConstraintAnchor::SetMassScale)
        .addProperty("Parent", &GCConstraintAnchor::GetParent, &GCConstraintAnchor::SetParent)
        .addFunction("ToPtr", &GCConstraintAnchor::ToPtr)
        .addFunction("IsValid", &GCConstraintAnchor::IsValid)
        .endClass();
}
GCWeaponTec9::GCWeaponTec9(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCWeaponTec9::GCWeaponTec9(void *ptr) {
    m_ptr = ptr;
}
void* GCWeaponTec9::GetPtr() {
    return m_ptr;
}
std::string GCWeaponTec9::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCWeaponTec9::IsValid() {
    return (m_ptr != nullptr);
}
GCCSWeaponBaseGun GCWeaponTec9::GetParent() const {
    GCCSWeaponBaseGun value(m_ptr);
    return value;
}
void GCWeaponTec9::SetParent(GCCSWeaponBaseGun value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCWeaponTec9(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCWeaponTec9>("CWeaponTec9")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCWeaponTec9::GetParent, &GCWeaponTec9::SetParent)
        .addFunction("ToPtr", &GCWeaponTec9::ToPtr)
        .addFunction("IsValid", &GCWeaponTec9::IsValid)
        .endClass();
}
GCMarkupVolumeTagged_Nav::GCMarkupVolumeTagged_Nav(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCMarkupVolumeTagged_Nav::GCMarkupVolumeTagged_Nav(void *ptr) {
    m_ptr = ptr;
}
void* GCMarkupVolumeTagged_Nav::GetPtr() {
    return m_ptr;
}
std::string GCMarkupVolumeTagged_Nav::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCMarkupVolumeTagged_Nav::IsValid() {
    return (m_ptr != nullptr);
}
GCMarkupVolumeTagged GCMarkupVolumeTagged_Nav::GetParent() const {
    GCMarkupVolumeTagged value(m_ptr);
    return value;
}
void GCMarkupVolumeTagged_Nav::SetParent(GCMarkupVolumeTagged value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCMarkupVolumeTagged_Nav(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCMarkupVolumeTagged_Nav>("CMarkupVolumeTagged_Nav")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCMarkupVolumeTagged_Nav::GetParent, &GCMarkupVolumeTagged_Nav::SetParent)
        .addFunction("ToPtr", &GCMarkupVolumeTagged_Nav::ToPtr)
        .addFunction("IsValid", &GCMarkupVolumeTagged_Nav::IsValid)
        .endClass();
}
GCInstancedSceneEntity::GCInstancedSceneEntity(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCInstancedSceneEntity::GCInstancedSceneEntity(void *ptr) {
    m_ptr = ptr;
}
GCBaseEntity GCInstancedSceneEntity::GetOwner() const {
    GCBaseEntity value((void*)(GetSchemaValue<CHandle<CEntityInstance>>(m_ptr, "CInstancedSceneEntity", "m_hOwner").Get()));
    return value;
}
void GCInstancedSceneEntity::SetOwner(GCBaseEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Owner' is not possible.\n");
}
bool GCInstancedSceneEntity::GetHadOwner() const {
    return GetSchemaValue<bool>(m_ptr, "CInstancedSceneEntity", "m_bHadOwner");
}
void GCInstancedSceneEntity::SetHadOwner(bool value) {
    SetSchemaValue(m_ptr, "CInstancedSceneEntity", "m_bHadOwner", false, value);
}
float GCInstancedSceneEntity::GetPostSpeakDelay() const {
    return GetSchemaValue<float>(m_ptr, "CInstancedSceneEntity", "m_flPostSpeakDelay");
}
void GCInstancedSceneEntity::SetPostSpeakDelay(float value) {
    SetSchemaValue(m_ptr, "CInstancedSceneEntity", "m_flPostSpeakDelay", false, value);
}
float GCInstancedSceneEntity::GetPreDelay() const {
    return GetSchemaValue<float>(m_ptr, "CInstancedSceneEntity", "m_flPreDelay");
}
void GCInstancedSceneEntity::SetPreDelay(float value) {
    SetSchemaValue(m_ptr, "CInstancedSceneEntity", "m_flPreDelay", false, value);
}
bool GCInstancedSceneEntity::GetIsBackground() const {
    return GetSchemaValue<bool>(m_ptr, "CInstancedSceneEntity", "m_bIsBackground");
}
void GCInstancedSceneEntity::SetIsBackground(bool value) {
    SetSchemaValue(m_ptr, "CInstancedSceneEntity", "m_bIsBackground", false, value);
}
bool GCInstancedSceneEntity::GetRemoveOnCompletion() const {
    return GetSchemaValue<bool>(m_ptr, "CInstancedSceneEntity", "m_bRemoveOnCompletion");
}
void GCInstancedSceneEntity::SetRemoveOnCompletion(bool value) {
    SetSchemaValue(m_ptr, "CInstancedSceneEntity", "m_bRemoveOnCompletion", false, value);
}
GCBaseEntity GCInstancedSceneEntity::GetTarget() const {
    GCBaseEntity value((void*)(GetSchemaValue<CHandle<CEntityInstance>>(m_ptr, "CInstancedSceneEntity", "m_hTarget").Get()));
    return value;
}
void GCInstancedSceneEntity::SetTarget(GCBaseEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Target' is not possible.\n");
}
void* GCInstancedSceneEntity::GetPtr() {
    return m_ptr;
}
std::string GCInstancedSceneEntity::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCInstancedSceneEntity::IsValid() {
    return (m_ptr != nullptr);
}
GCSceneEntity GCInstancedSceneEntity::GetParent() const {
    GCSceneEntity value(m_ptr);
    return value;
}
void GCInstancedSceneEntity::SetParent(GCSceneEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCInstancedSceneEntity(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCInstancedSceneEntity>("CInstancedSceneEntity")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Owner", &GCInstancedSceneEntity::GetOwner, &GCInstancedSceneEntity::SetOwner)
        .addProperty("HadOwner", &GCInstancedSceneEntity::GetHadOwner, &GCInstancedSceneEntity::SetHadOwner)
        .addProperty("PostSpeakDelay", &GCInstancedSceneEntity::GetPostSpeakDelay, &GCInstancedSceneEntity::SetPostSpeakDelay)
        .addProperty("PreDelay", &GCInstancedSceneEntity::GetPreDelay, &GCInstancedSceneEntity::SetPreDelay)
        .addProperty("IsBackground", &GCInstancedSceneEntity::GetIsBackground, &GCInstancedSceneEntity::SetIsBackground)
        .addProperty("RemoveOnCompletion", &GCInstancedSceneEntity::GetRemoveOnCompletion, &GCInstancedSceneEntity::SetRemoveOnCompletion)
        .addProperty("Target", &GCInstancedSceneEntity::GetTarget, &GCInstancedSceneEntity::SetTarget)
        .addProperty("Parent", &GCInstancedSceneEntity::GetParent, &GCInstancedSceneEntity::SetParent)
        .addFunction("ToPtr", &GCInstancedSceneEntity::ToPtr)
        .addFunction("IsValid", &GCInstancedSceneEntity::IsValid)
        .endClass();
}
GCLightEnvironmentEntity::GCLightEnvironmentEntity(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCLightEnvironmentEntity::GCLightEnvironmentEntity(void *ptr) {
    m_ptr = ptr;
}
void* GCLightEnvironmentEntity::GetPtr() {
    return m_ptr;
}
std::string GCLightEnvironmentEntity::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCLightEnvironmentEntity::IsValid() {
    return (m_ptr != nullptr);
}
GCLightDirectionalEntity GCLightEnvironmentEntity::GetParent() const {
    GCLightDirectionalEntity value(m_ptr);
    return value;
}
void GCLightEnvironmentEntity::SetParent(GCLightDirectionalEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCLightEnvironmentEntity(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCLightEnvironmentEntity>("CLightEnvironmentEntity")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCLightEnvironmentEntity::GetParent, &GCLightEnvironmentEntity::SetParent)
        .addFunction("ToPtr", &GCLightEnvironmentEntity::ToPtr)
        .addFunction("IsValid", &GCLightEnvironmentEntity::IsValid)
        .endClass();
}
GCLogicActiveAutosave::GCLogicActiveAutosave(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCLogicActiveAutosave::GCLogicActiveAutosave(void *ptr) {
    m_ptr = ptr;
}
int32_t GCLogicActiveAutosave::GetTriggerHitPoints() const {
    return GetSchemaValue<int32_t>(m_ptr, "CLogicActiveAutosave", "m_TriggerHitPoints");
}
void GCLogicActiveAutosave::SetTriggerHitPoints(int32_t value) {
    SetSchemaValue(m_ptr, "CLogicActiveAutosave", "m_TriggerHitPoints", false, value);
}
float GCLogicActiveAutosave::GetTimeToTrigger() const {
    return GetSchemaValue<float>(m_ptr, "CLogicActiveAutosave", "m_flTimeToTrigger");
}
void GCLogicActiveAutosave::SetTimeToTrigger(float value) {
    SetSchemaValue(m_ptr, "CLogicActiveAutosave", "m_flTimeToTrigger", false, value);
}
float GCLogicActiveAutosave::GetStartTime() const {
    return GetSchemaValue<float>(m_ptr, "CLogicActiveAutosave", "m_flStartTime");
}
void GCLogicActiveAutosave::SetStartTime(float value) {
    SetSchemaValue(m_ptr, "CLogicActiveAutosave", "m_flStartTime", false, value);
}
float GCLogicActiveAutosave::GetDangerousTime() const {
    return GetSchemaValue<float>(m_ptr, "CLogicActiveAutosave", "m_flDangerousTime");
}
void GCLogicActiveAutosave::SetDangerousTime(float value) {
    SetSchemaValue(m_ptr, "CLogicActiveAutosave", "m_flDangerousTime", false, value);
}
void* GCLogicActiveAutosave::GetPtr() {
    return m_ptr;
}
std::string GCLogicActiveAutosave::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCLogicActiveAutosave::IsValid() {
    return (m_ptr != nullptr);
}
GCLogicAutosave GCLogicActiveAutosave::GetParent() const {
    GCLogicAutosave value(m_ptr);
    return value;
}
void GCLogicActiveAutosave::SetParent(GCLogicAutosave value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCLogicActiveAutosave(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCLogicActiveAutosave>("CLogicActiveAutosave")
        .addConstructor<void (*)(std::string)>()
        .addProperty("TriggerHitPoints", &GCLogicActiveAutosave::GetTriggerHitPoints, &GCLogicActiveAutosave::SetTriggerHitPoints)
        .addProperty("TimeToTrigger", &GCLogicActiveAutosave::GetTimeToTrigger, &GCLogicActiveAutosave::SetTimeToTrigger)
        .addProperty("StartTime", &GCLogicActiveAutosave::GetStartTime, &GCLogicActiveAutosave::SetStartTime)
        .addProperty("DangerousTime", &GCLogicActiveAutosave::GetDangerousTime, &GCLogicActiveAutosave::SetDangerousTime)
        .addProperty("Parent", &GCLogicActiveAutosave::GetParent, &GCLogicActiveAutosave::SetParent)
        .addFunction("ToPtr", &GCLogicActiveAutosave::ToPtr)
        .addFunction("IsValid", &GCLogicActiveAutosave::IsValid)
        .endClass();
}
GCEnvBeverage::GCEnvBeverage(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCEnvBeverage::GCEnvBeverage(void *ptr) {
    m_ptr = ptr;
}
bool GCEnvBeverage::GetCanInDispenser() const {
    return GetSchemaValue<bool>(m_ptr, "CEnvBeverage", "m_CanInDispenser");
}
void GCEnvBeverage::SetCanInDispenser(bool value) {
    SetSchemaValue(m_ptr, "CEnvBeverage", "m_CanInDispenser", false, value);
}
int32_t GCEnvBeverage::GetBeverageType() const {
    return GetSchemaValue<int32_t>(m_ptr, "CEnvBeverage", "m_nBeverageType");
}
void GCEnvBeverage::SetBeverageType(int32_t value) {
    SetSchemaValue(m_ptr, "CEnvBeverage", "m_nBeverageType", false, value);
}
void* GCEnvBeverage::GetPtr() {
    return m_ptr;
}
std::string GCEnvBeverage::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCEnvBeverage::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseEntity GCEnvBeverage::GetParent() const {
    GCBaseEntity value(m_ptr);
    return value;
}
void GCEnvBeverage::SetParent(GCBaseEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCEnvBeverage(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCEnvBeverage>("CEnvBeverage")
        .addConstructor<void (*)(std::string)>()
        .addProperty("CanInDispenser", &GCEnvBeverage::GetCanInDispenser, &GCEnvBeverage::SetCanInDispenser)
        .addProperty("BeverageType", &GCEnvBeverage::GetBeverageType, &GCEnvBeverage::SetBeverageType)
        .addProperty("Parent", &GCEnvBeverage::GetParent, &GCEnvBeverage::SetParent)
        .addFunction("ToPtr", &GCEnvBeverage::ToPtr)
        .addFunction("IsValid", &GCEnvBeverage::IsValid)
        .endClass();
}
GCWeaponCZ75a::GCWeaponCZ75a(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCWeaponCZ75a::GCWeaponCZ75a(void *ptr) {
    m_ptr = ptr;
}
void* GCWeaponCZ75a::GetPtr() {
    return m_ptr;
}
std::string GCWeaponCZ75a::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCWeaponCZ75a::IsValid() {
    return (m_ptr != nullptr);
}
GCCSWeaponBaseGun GCWeaponCZ75a::GetParent() const {
    GCCSWeaponBaseGun value(m_ptr);
    return value;
}
void GCWeaponCZ75a::SetParent(GCCSWeaponBaseGun value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCWeaponCZ75a(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCWeaponCZ75a>("CWeaponCZ75a")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCWeaponCZ75a::GetParent, &GCWeaponCZ75a::SetParent)
        .addFunction("ToPtr", &GCWeaponCZ75a::ToPtr)
        .addFunction("IsValid", &GCWeaponCZ75a::IsValid)
        .endClass();
}
GCWeaponP250::GCWeaponP250(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCWeaponP250::GCWeaponP250(void *ptr) {
    m_ptr = ptr;
}
void* GCWeaponP250::GetPtr() {
    return m_ptr;
}
std::string GCWeaponP250::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCWeaponP250::IsValid() {
    return (m_ptr != nullptr);
}
GCCSWeaponBaseGun GCWeaponP250::GetParent() const {
    GCCSWeaponBaseGun value(m_ptr);
    return value;
}
void GCWeaponP250::SetParent(GCCSWeaponBaseGun value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCWeaponP250(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCWeaponP250>("CWeaponP250")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCWeaponP250::GetParent, &GCWeaponP250::SetParent)
        .addFunction("ToPtr", &GCWeaponP250::ToPtr)
        .addFunction("IsValid", &GCWeaponP250::IsValid)
        .endClass();
}
GCHostage::GCHostage(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCHostage::GCHostage(void *ptr) {
    m_ptr = ptr;
}
GCEntityIOOutput GCHostage::GetOnHostageBeginGrab() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CHostage", "m_OnHostageBeginGrab"));
    return value;
}
void GCHostage::SetOnHostageBeginGrab(GCEntityIOOutput value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'OnHostageBeginGrab' is not possible.\n");
}
GCEntityIOOutput GCHostage::GetOnFirstPickedUp() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CHostage", "m_OnFirstPickedUp"));
    return value;
}
void GCHostage::SetOnFirstPickedUp(GCEntityIOOutput value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'OnFirstPickedUp' is not possible.\n");
}
GCEntityIOOutput GCHostage::GetOnDroppedNotRescued() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CHostage", "m_OnDroppedNotRescued"));
    return value;
}
void GCHostage::SetOnDroppedNotRescued(GCEntityIOOutput value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'OnDroppedNotRescued' is not possible.\n");
}
GCEntityIOOutput GCHostage::GetOnRescued() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CHostage", "m_OnRescued"));
    return value;
}
void GCHostage::SetOnRescued(GCEntityIOOutput value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'OnRescued' is not possible.\n");
}
GEntitySpottedState_t GCHostage::GetEntitySpottedState() const {
    GEntitySpottedState_t value(GetSchemaPtr(m_ptr, "CHostage", "m_entitySpottedState"));
    return value;
}
void GCHostage::SetEntitySpottedState(GEntitySpottedState_t value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'EntitySpottedState' is not possible.\n");
}
int32_t GCHostage::GetSpotRules() const {
    return GetSchemaValue<int32_t>(m_ptr, "CHostage", "m_nSpotRules");
}
void GCHostage::SetSpotRules(int32_t value) {
    SetSchemaValue(m_ptr, "CHostage", "m_nSpotRules", false, value);
}
uint32_t GCHostage::GetUiHostageSpawnExclusionGroupMask() const {
    return GetSchemaValue<uint32_t>(m_ptr, "CHostage", "m_uiHostageSpawnExclusionGroupMask");
}
void GCHostage::SetUiHostageSpawnExclusionGroupMask(uint32_t value) {
    SetSchemaValue(m_ptr, "CHostage", "m_uiHostageSpawnExclusionGroupMask", false, value);
}
uint32_t GCHostage::GetHostageSpawnRandomFactor() const {
    return GetSchemaValue<uint32_t>(m_ptr, "CHostage", "m_nHostageSpawnRandomFactor");
}
void GCHostage::SetHostageSpawnRandomFactor(uint32_t value) {
    SetSchemaValue(m_ptr, "CHostage", "m_nHostageSpawnRandomFactor", false, value);
}
bool GCHostage::GetRemove() const {
    return GetSchemaValue<bool>(m_ptr, "CHostage", "m_bRemove");
}
void GCHostage::SetRemove(bool value) {
    SetSchemaValue(m_ptr, "CHostage", "m_bRemove", false, value);
}
Vector GCHostage::GetVel() const {
    return GetSchemaValue<Vector>(m_ptr, "CHostage", "m_vel");
}
void GCHostage::SetVel(Vector value) {
    SetSchemaValue(m_ptr, "CHostage", "m_vel", false, value);
}
bool GCHostage::GetIsRescued() const {
    return GetSchemaValue<bool>(m_ptr, "CHostage", "m_isRescued");
}
void GCHostage::SetIsRescued(bool value) {
    SetSchemaValue(m_ptr, "CHostage", "m_isRescued", false, value);
}
bool GCHostage::GetJumpedThisFrame() const {
    return GetSchemaValue<bool>(m_ptr, "CHostage", "m_jumpedThisFrame");
}
void GCHostage::SetJumpedThisFrame(bool value) {
    SetSchemaValue(m_ptr, "CHostage", "m_jumpedThisFrame", false, value);
}
int32_t GCHostage::GetHostageState() const {
    return GetSchemaValue<int32_t>(m_ptr, "CHostage", "m_nHostageState");
}
void GCHostage::SetHostageState(int32_t value) {
    SetSchemaValue(m_ptr, "CHostage", "m_nHostageState", false, value);
}
GCBaseEntity GCHostage::GetLeader() const {
    GCBaseEntity value((void*)(GetSchemaValue<CHandle<CEntityInstance>>(m_ptr, "CHostage", "m_leader").Get()));
    return value;
}
void GCHostage::SetLeader(GCBaseEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Leader' is not possible.\n");
}
GCCSPlayerPawnBase GCHostage::GetLastLeader() const {
    GCCSPlayerPawnBase value((void*)(GetSchemaValue<CHandle<CEntityInstance>>(m_ptr, "CHostage", "m_lastLeader").Get()));
    return value;
}
void GCHostage::SetLastLeader(GCCSPlayerPawnBase value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'LastLeader' is not possible.\n");
}
GCountdownTimer GCHostage::GetReuseTimer() const {
    GCountdownTimer value(GetSchemaPtr(m_ptr, "CHostage", "m_reuseTimer"));
    return value;
}
void GCHostage::SetReuseTimer(GCountdownTimer value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'ReuseTimer' is not possible.\n");
}
bool GCHostage::GetHasBeenUsed() const {
    return GetSchemaValue<bool>(m_ptr, "CHostage", "m_hasBeenUsed");
}
void GCHostage::SetHasBeenUsed(bool value) {
    SetSchemaValue(m_ptr, "CHostage", "m_hasBeenUsed", false, value);
}
Vector GCHostage::GetAccel() const {
    return GetSchemaValue<Vector>(m_ptr, "CHostage", "m_accel");
}
void GCHostage::SetAccel(Vector value) {
    SetSchemaValue(m_ptr, "CHostage", "m_accel", false, value);
}
bool GCHostage::GetIsRunning() const {
    return GetSchemaValue<bool>(m_ptr, "CHostage", "m_isRunning");
}
void GCHostage::SetIsRunning(bool value) {
    SetSchemaValue(m_ptr, "CHostage", "m_isRunning", false, value);
}
bool GCHostage::GetIsCrouching() const {
    return GetSchemaValue<bool>(m_ptr, "CHostage", "m_isCrouching");
}
void GCHostage::SetIsCrouching(bool value) {
    SetSchemaValue(m_ptr, "CHostage", "m_isCrouching", false, value);
}
GCountdownTimer GCHostage::GetJumpTimer() const {
    GCountdownTimer value(GetSchemaPtr(m_ptr, "CHostage", "m_jumpTimer"));
    return value;
}
void GCHostage::SetJumpTimer(GCountdownTimer value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'JumpTimer' is not possible.\n");
}
bool GCHostage::GetIsWaitingForLeader() const {
    return GetSchemaValue<bool>(m_ptr, "CHostage", "m_isWaitingForLeader");
}
void GCHostage::SetIsWaitingForLeader(bool value) {
    SetSchemaValue(m_ptr, "CHostage", "m_isWaitingForLeader", false, value);
}
GCountdownTimer GCHostage::GetRepathTimer() const {
    GCountdownTimer value(GetSchemaPtr(m_ptr, "CHostage", "m_repathTimer"));
    return value;
}
void GCHostage::SetRepathTimer(GCountdownTimer value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'RepathTimer' is not possible.\n");
}
GCountdownTimer GCHostage::GetInhibitDoorTimer() const {
    GCountdownTimer value(GetSchemaPtr(m_ptr, "CHostage", "m_inhibitDoorTimer"));
    return value;
}
void GCHostage::SetInhibitDoorTimer(GCountdownTimer value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'InhibitDoorTimer' is not possible.\n");
}
GCountdownTimer GCHostage::GetInhibitObstacleAvoidanceTimer() const {
    GCountdownTimer value(GetSchemaPtr(m_ptr, "CHostage", "m_inhibitObstacleAvoidanceTimer"));
    return value;
}
void GCHostage::SetInhibitObstacleAvoidanceTimer(GCountdownTimer value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'InhibitObstacleAvoidanceTimer' is not possible.\n");
}
GCountdownTimer GCHostage::GetWiggleTimer() const {
    GCountdownTimer value(GetSchemaPtr(m_ptr, "CHostage", "m_wiggleTimer"));
    return value;
}
void GCHostage::SetWiggleTimer(GCountdownTimer value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'WiggleTimer' is not possible.\n");
}
bool GCHostage::GetIsAdjusted() const {
    return GetSchemaValue<bool>(m_ptr, "CHostage", "m_isAdjusted");
}
void GCHostage::SetIsAdjusted(bool value) {
    SetSchemaValue(m_ptr, "CHostage", "m_isAdjusted", false, value);
}
bool GCHostage::GetHandsHaveBeenCut() const {
    return GetSchemaValue<bool>(m_ptr, "CHostage", "m_bHandsHaveBeenCut");
}
void GCHostage::SetHandsHaveBeenCut(bool value) {
    SetSchemaValue(m_ptr, "CHostage", "m_bHandsHaveBeenCut", false, value);
}
GCCSPlayerPawn GCHostage::GetHostageGrabber() const {
    GCCSPlayerPawn value((void*)(GetSchemaValue<CHandle<CEntityInstance>>(m_ptr, "CHostage", "m_hHostageGrabber").Get()));
    return value;
}
void GCHostage::SetHostageGrabber(GCCSPlayerPawn value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'HostageGrabber' is not possible.\n");
}
float GCHostage::GetLastGrabTime() const {
    return GetSchemaValue<float>(m_ptr, "CHostage", "m_fLastGrabTime");
}
void GCHostage::SetLastGrabTime(float value) {
    SetSchemaValue(m_ptr, "CHostage", "m_fLastGrabTime", false, value);
}
Vector GCHostage::GetPositionWhenStartedDroppingToGround() const {
    return GetSchemaValue<Vector>(m_ptr, "CHostage", "m_vecPositionWhenStartedDroppingToGround");
}
void GCHostage::SetPositionWhenStartedDroppingToGround(Vector value) {
    SetSchemaValue(m_ptr, "CHostage", "m_vecPositionWhenStartedDroppingToGround", false, value);
}
Vector GCHostage::GetGrabbedPos() const {
    return GetSchemaValue<Vector>(m_ptr, "CHostage", "m_vecGrabbedPos");
}
void GCHostage::SetGrabbedPos(Vector value) {
    SetSchemaValue(m_ptr, "CHostage", "m_vecGrabbedPos", false, value);
}
float GCHostage::GetRescueStartTime() const {
    return GetSchemaValue<float>(m_ptr, "CHostage", "m_flRescueStartTime");
}
void GCHostage::SetRescueStartTime(float value) {
    SetSchemaValue(m_ptr, "CHostage", "m_flRescueStartTime", false, value);
}
float GCHostage::GetGrabSuccessTime() const {
    return GetSchemaValue<float>(m_ptr, "CHostage", "m_flGrabSuccessTime");
}
void GCHostage::SetGrabSuccessTime(float value) {
    SetSchemaValue(m_ptr, "CHostage", "m_flGrabSuccessTime", false, value);
}
float GCHostage::GetDropStartTime() const {
    return GetSchemaValue<float>(m_ptr, "CHostage", "m_flDropStartTime");
}
void GCHostage::SetDropStartTime(float value) {
    SetSchemaValue(m_ptr, "CHostage", "m_flDropStartTime", false, value);
}
int32_t GCHostage::GetApproachRewardPayouts() const {
    return GetSchemaValue<int32_t>(m_ptr, "CHostage", "m_nApproachRewardPayouts");
}
void GCHostage::SetApproachRewardPayouts(int32_t value) {
    SetSchemaValue(m_ptr, "CHostage", "m_nApproachRewardPayouts", false, value);
}
int32_t GCHostage::GetPickupEventCount() const {
    return GetSchemaValue<int32_t>(m_ptr, "CHostage", "m_nPickupEventCount");
}
void GCHostage::SetPickupEventCount(int32_t value) {
    SetSchemaValue(m_ptr, "CHostage", "m_nPickupEventCount", false, value);
}
Vector GCHostage::GetSpawnGroundPos() const {
    return GetSchemaValue<Vector>(m_ptr, "CHostage", "m_vecSpawnGroundPos");
}
void GCHostage::SetSpawnGroundPos(Vector value) {
    SetSchemaValue(m_ptr, "CHostage", "m_vecSpawnGroundPos", false, value);
}
Vector GCHostage::GetHostageResetPosition() const {
    return GetSchemaValue<Vector>(m_ptr, "CHostage", "m_vecHostageResetPosition");
}
void GCHostage::SetHostageResetPosition(Vector value) {
    SetSchemaValue(m_ptr, "CHostage", "m_vecHostageResetPosition", false, value);
}
void* GCHostage::GetPtr() {
    return m_ptr;
}
std::string GCHostage::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCHostage::IsValid() {
    return (m_ptr != nullptr);
}
GCHostageExpresserShim GCHostage::GetParent() const {
    GCHostageExpresserShim value(m_ptr);
    return value;
}
void GCHostage::SetParent(GCHostageExpresserShim value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCHostage(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCHostage>("CHostage")
        .addConstructor<void (*)(std::string)>()
        .addProperty("OnHostageBeginGrab", &GCHostage::GetOnHostageBeginGrab, &GCHostage::SetOnHostageBeginGrab)
        .addProperty("OnFirstPickedUp", &GCHostage::GetOnFirstPickedUp, &GCHostage::SetOnFirstPickedUp)
        .addProperty("OnDroppedNotRescued", &GCHostage::GetOnDroppedNotRescued, &GCHostage::SetOnDroppedNotRescued)
        .addProperty("OnRescued", &GCHostage::GetOnRescued, &GCHostage::SetOnRescued)
        .addProperty("EntitySpottedState", &GCHostage::GetEntitySpottedState, &GCHostage::SetEntitySpottedState)
        .addProperty("SpotRules", &GCHostage::GetSpotRules, &GCHostage::SetSpotRules)
        .addProperty("UiHostageSpawnExclusionGroupMask", &GCHostage::GetUiHostageSpawnExclusionGroupMask, &GCHostage::SetUiHostageSpawnExclusionGroupMask)
        .addProperty("HostageSpawnRandomFactor", &GCHostage::GetHostageSpawnRandomFactor, &GCHostage::SetHostageSpawnRandomFactor)
        .addProperty("Remove", &GCHostage::GetRemove, &GCHostage::SetRemove)
        .addProperty("Vel", &GCHostage::GetVel, &GCHostage::SetVel)
        .addProperty("IsRescued", &GCHostage::GetIsRescued, &GCHostage::SetIsRescued)
        .addProperty("JumpedThisFrame", &GCHostage::GetJumpedThisFrame, &GCHostage::SetJumpedThisFrame)
        .addProperty("HostageState", &GCHostage::GetHostageState, &GCHostage::SetHostageState)
        .addProperty("Leader", &GCHostage::GetLeader, &GCHostage::SetLeader)
        .addProperty("LastLeader", &GCHostage::GetLastLeader, &GCHostage::SetLastLeader)
        .addProperty("ReuseTimer", &GCHostage::GetReuseTimer, &GCHostage::SetReuseTimer)
        .addProperty("HasBeenUsed", &GCHostage::GetHasBeenUsed, &GCHostage::SetHasBeenUsed)
        .addProperty("Accel", &GCHostage::GetAccel, &GCHostage::SetAccel)
        .addProperty("IsRunning", &GCHostage::GetIsRunning, &GCHostage::SetIsRunning)
        .addProperty("IsCrouching", &GCHostage::GetIsCrouching, &GCHostage::SetIsCrouching)
        .addProperty("JumpTimer", &GCHostage::GetJumpTimer, &GCHostage::SetJumpTimer)
        .addProperty("IsWaitingForLeader", &GCHostage::GetIsWaitingForLeader, &GCHostage::SetIsWaitingForLeader)
        .addProperty("RepathTimer", &GCHostage::GetRepathTimer, &GCHostage::SetRepathTimer)
        .addProperty("InhibitDoorTimer", &GCHostage::GetInhibitDoorTimer, &GCHostage::SetInhibitDoorTimer)
        .addProperty("InhibitObstacleAvoidanceTimer", &GCHostage::GetInhibitObstacleAvoidanceTimer, &GCHostage::SetInhibitObstacleAvoidanceTimer)
        .addProperty("WiggleTimer", &GCHostage::GetWiggleTimer, &GCHostage::SetWiggleTimer)
        .addProperty("IsAdjusted", &GCHostage::GetIsAdjusted, &GCHostage::SetIsAdjusted)
        .addProperty("HandsHaveBeenCut", &GCHostage::GetHandsHaveBeenCut, &GCHostage::SetHandsHaveBeenCut)
        .addProperty("HostageGrabber", &GCHostage::GetHostageGrabber, &GCHostage::SetHostageGrabber)
        .addProperty("LastGrabTime", &GCHostage::GetLastGrabTime, &GCHostage::SetLastGrabTime)
        .addProperty("PositionWhenStartedDroppingToGround", &GCHostage::GetPositionWhenStartedDroppingToGround, &GCHostage::SetPositionWhenStartedDroppingToGround)
        .addProperty("GrabbedPos", &GCHostage::GetGrabbedPos, &GCHostage::SetGrabbedPos)
        .addProperty("RescueStartTime", &GCHostage::GetRescueStartTime, &GCHostage::SetRescueStartTime)
        .addProperty("GrabSuccessTime", &GCHostage::GetGrabSuccessTime, &GCHostage::SetGrabSuccessTime)
        .addProperty("DropStartTime", &GCHostage::GetDropStartTime, &GCHostage::SetDropStartTime)
        .addProperty("ApproachRewardPayouts", &GCHostage::GetApproachRewardPayouts, &GCHostage::SetApproachRewardPayouts)
        .addProperty("PickupEventCount", &GCHostage::GetPickupEventCount, &GCHostage::SetPickupEventCount)
        .addProperty("SpawnGroundPos", &GCHostage::GetSpawnGroundPos, &GCHostage::SetSpawnGroundPos)
        .addProperty("HostageResetPosition", &GCHostage::GetHostageResetPosition, &GCHostage::SetHostageResetPosition)
        .addProperty("Parent", &GCHostage::GetParent, &GCHostage::SetParent)
        .addFunction("ToPtr", &GCHostage::ToPtr)
        .addFunction("IsValid", &GCHostage::IsValid)
        .endClass();
}
GCScriptTriggerHurt::GCScriptTriggerHurt(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCScriptTriggerHurt::GCScriptTriggerHurt(void *ptr) {
    m_ptr = ptr;
}
Vector GCScriptTriggerHurt::GetExtent() const {
    return GetSchemaValue<Vector>(m_ptr, "CScriptTriggerHurt", "m_vExtent");
}
void GCScriptTriggerHurt::SetExtent(Vector value) {
    SetSchemaValue(m_ptr, "CScriptTriggerHurt", "m_vExtent", false, value);
}
void* GCScriptTriggerHurt::GetPtr() {
    return m_ptr;
}
std::string GCScriptTriggerHurt::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCScriptTriggerHurt::IsValid() {
    return (m_ptr != nullptr);
}
GCTriggerHurt GCScriptTriggerHurt::GetParent() const {
    GCTriggerHurt value(m_ptr);
    return value;
}
void GCScriptTriggerHurt::SetParent(GCTriggerHurt value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCScriptTriggerHurt(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCScriptTriggerHurt>("CScriptTriggerHurt")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Extent", &GCScriptTriggerHurt::GetExtent, &GCScriptTriggerHurt::SetExtent)
        .addProperty("Parent", &GCScriptTriggerHurt::GetParent, &GCScriptTriggerHurt::SetParent)
        .addFunction("ToPtr", &GCScriptTriggerHurt::ToPtr)
        .addFunction("IsValid", &GCScriptTriggerHurt::IsValid)
        .endClass();
}
GCBasePlayerWeaponVData::GCBasePlayerWeaponVData(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCBasePlayerWeaponVData::GCBasePlayerWeaponVData(void *ptr) {
    m_ptr = ptr;
}
bool GCBasePlayerWeaponVData::GetBuiltRightHanded() const {
    return GetSchemaValue<bool>(m_ptr, "CBasePlayerWeaponVData", "m_bBuiltRightHanded");
}
void GCBasePlayerWeaponVData::SetBuiltRightHanded(bool value) {
    SetSchemaValue(m_ptr, "CBasePlayerWeaponVData", "m_bBuiltRightHanded", false, value);
}
bool GCBasePlayerWeaponVData::GetAllowFlipping() const {
    return GetSchemaValue<bool>(m_ptr, "CBasePlayerWeaponVData", "m_bAllowFlipping");
}
void GCBasePlayerWeaponVData::SetAllowFlipping(bool value) {
    SetSchemaValue(m_ptr, "CBasePlayerWeaponVData", "m_bAllowFlipping", false, value);
}
std::string GCBasePlayerWeaponVData::GetMuzzleAttachment() const {
    return GetSchemaValue<CUtlString>(m_ptr, "CBasePlayerWeaponVData", "m_sMuzzleAttachment").Get();
}
void GCBasePlayerWeaponVData::SetMuzzleAttachment(std::string value) {
    SetSchemaValue(m_ptr, "CBasePlayerWeaponVData", "m_sMuzzleAttachment", false, CUtlString(value.c_str()));
}
uint64_t GCBasePlayerWeaponVData::GetFlags() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CBasePlayerWeaponVData", "m_iFlags");
}
void GCBasePlayerWeaponVData::SetFlags(uint64_t value) {
    SetSchemaValue(m_ptr, "CBasePlayerWeaponVData", "m_iFlags", false, value);
}
uint32_t GCBasePlayerWeaponVData::GetPrimaryAmmoType() const {
    return GetSchemaValue<uint32_t>(m_ptr, "CBasePlayerWeaponVData", "m_nPrimaryAmmoType");
}
void GCBasePlayerWeaponVData::SetPrimaryAmmoType(uint32_t value) {
    SetSchemaValue(m_ptr, "CBasePlayerWeaponVData", "m_nPrimaryAmmoType", false, value);
}
uint32_t GCBasePlayerWeaponVData::GetSecondaryAmmoType() const {
    return GetSchemaValue<uint32_t>(m_ptr, "CBasePlayerWeaponVData", "m_nSecondaryAmmoType");
}
void GCBasePlayerWeaponVData::SetSecondaryAmmoType(uint32_t value) {
    SetSchemaValue(m_ptr, "CBasePlayerWeaponVData", "m_nSecondaryAmmoType", false, value);
}
int32_t GCBasePlayerWeaponVData::GetMaxClip1() const {
    return GetSchemaValue<int32_t>(m_ptr, "CBasePlayerWeaponVData", "m_iMaxClip1");
}
void GCBasePlayerWeaponVData::SetMaxClip1(int32_t value) {
    SetSchemaValue(m_ptr, "CBasePlayerWeaponVData", "m_iMaxClip1", false, value);
}
int32_t GCBasePlayerWeaponVData::GetMaxClip2() const {
    return GetSchemaValue<int32_t>(m_ptr, "CBasePlayerWeaponVData", "m_iMaxClip2");
}
void GCBasePlayerWeaponVData::SetMaxClip2(int32_t value) {
    SetSchemaValue(m_ptr, "CBasePlayerWeaponVData", "m_iMaxClip2", false, value);
}
int32_t GCBasePlayerWeaponVData::GetDefaultClip1() const {
    return GetSchemaValue<int32_t>(m_ptr, "CBasePlayerWeaponVData", "m_iDefaultClip1");
}
void GCBasePlayerWeaponVData::SetDefaultClip1(int32_t value) {
    SetSchemaValue(m_ptr, "CBasePlayerWeaponVData", "m_iDefaultClip1", false, value);
}
int32_t GCBasePlayerWeaponVData::GetDefaultClip2() const {
    return GetSchemaValue<int32_t>(m_ptr, "CBasePlayerWeaponVData", "m_iDefaultClip2");
}
void GCBasePlayerWeaponVData::SetDefaultClip2(int32_t value) {
    SetSchemaValue(m_ptr, "CBasePlayerWeaponVData", "m_iDefaultClip2", false, value);
}
int32_t GCBasePlayerWeaponVData::GetWeight() const {
    return GetSchemaValue<int32_t>(m_ptr, "CBasePlayerWeaponVData", "m_iWeight");
}
void GCBasePlayerWeaponVData::SetWeight(int32_t value) {
    SetSchemaValue(m_ptr, "CBasePlayerWeaponVData", "m_iWeight", false, value);
}
bool GCBasePlayerWeaponVData::GetAutoSwitchTo() const {
    return GetSchemaValue<bool>(m_ptr, "CBasePlayerWeaponVData", "m_bAutoSwitchTo");
}
void GCBasePlayerWeaponVData::SetAutoSwitchTo(bool value) {
    SetSchemaValue(m_ptr, "CBasePlayerWeaponVData", "m_bAutoSwitchTo", false, value);
}
bool GCBasePlayerWeaponVData::GetAutoSwitchFrom() const {
    return GetSchemaValue<bool>(m_ptr, "CBasePlayerWeaponVData", "m_bAutoSwitchFrom");
}
void GCBasePlayerWeaponVData::SetAutoSwitchFrom(bool value) {
    SetSchemaValue(m_ptr, "CBasePlayerWeaponVData", "m_bAutoSwitchFrom", false, value);
}
uint64_t GCBasePlayerWeaponVData::GetRumbleEffect() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CBasePlayerWeaponVData", "m_iRumbleEffect");
}
void GCBasePlayerWeaponVData::SetRumbleEffect(uint64_t value) {
    SetSchemaValue(m_ptr, "CBasePlayerWeaponVData", "m_iRumbleEffect", false, value);
}
bool GCBasePlayerWeaponVData::GetLinkedCooldowns() const {
    return GetSchemaValue<bool>(m_ptr, "CBasePlayerWeaponVData", "m_bLinkedCooldowns");
}
void GCBasePlayerWeaponVData::SetLinkedCooldowns(bool value) {
    SetSchemaValue(m_ptr, "CBasePlayerWeaponVData", "m_bLinkedCooldowns", false, value);
}
int32_t GCBasePlayerWeaponVData::GetSlot() const {
    return GetSchemaValue<int32_t>(m_ptr, "CBasePlayerWeaponVData", "m_iSlot");
}
void GCBasePlayerWeaponVData::SetSlot(int32_t value) {
    SetSchemaValue(m_ptr, "CBasePlayerWeaponVData", "m_iSlot", false, value);
}
int32_t GCBasePlayerWeaponVData::GetPosition() const {
    return GetSchemaValue<int32_t>(m_ptr, "CBasePlayerWeaponVData", "m_iPosition");
}
void GCBasePlayerWeaponVData::SetPosition(int32_t value) {
    SetSchemaValue(m_ptr, "CBasePlayerWeaponVData", "m_iPosition", false, value);
}
void* GCBasePlayerWeaponVData::GetPtr() {
    return m_ptr;
}
std::string GCBasePlayerWeaponVData::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCBasePlayerWeaponVData::IsValid() {
    return (m_ptr != nullptr);
}
GCEntitySubclassVDataBase GCBasePlayerWeaponVData::GetParent() const {
    GCEntitySubclassVDataBase value(m_ptr);
    return value;
}
void GCBasePlayerWeaponVData::SetParent(GCEntitySubclassVDataBase value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCBasePlayerWeaponVData(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCBasePlayerWeaponVData>("CBasePlayerWeaponVData")
        .addConstructor<void (*)(std::string)>()
        .addProperty("BuiltRightHanded", &GCBasePlayerWeaponVData::GetBuiltRightHanded, &GCBasePlayerWeaponVData::SetBuiltRightHanded)
        .addProperty("AllowFlipping", &GCBasePlayerWeaponVData::GetAllowFlipping, &GCBasePlayerWeaponVData::SetAllowFlipping)
        .addProperty("MuzzleAttachment", &GCBasePlayerWeaponVData::GetMuzzleAttachment, &GCBasePlayerWeaponVData::SetMuzzleAttachment)
        .addProperty("Flags", &GCBasePlayerWeaponVData::GetFlags, &GCBasePlayerWeaponVData::SetFlags)
        .addProperty("PrimaryAmmoType", &GCBasePlayerWeaponVData::GetPrimaryAmmoType, &GCBasePlayerWeaponVData::SetPrimaryAmmoType)
        .addProperty("SecondaryAmmoType", &GCBasePlayerWeaponVData::GetSecondaryAmmoType, &GCBasePlayerWeaponVData::SetSecondaryAmmoType)
        .addProperty("MaxClip1", &GCBasePlayerWeaponVData::GetMaxClip1, &GCBasePlayerWeaponVData::SetMaxClip1)
        .addProperty("MaxClip2", &GCBasePlayerWeaponVData::GetMaxClip2, &GCBasePlayerWeaponVData::SetMaxClip2)
        .addProperty("DefaultClip1", &GCBasePlayerWeaponVData::GetDefaultClip1, &GCBasePlayerWeaponVData::SetDefaultClip1)
        .addProperty("DefaultClip2", &GCBasePlayerWeaponVData::GetDefaultClip2, &GCBasePlayerWeaponVData::SetDefaultClip2)
        .addProperty("Weight", &GCBasePlayerWeaponVData::GetWeight, &GCBasePlayerWeaponVData::SetWeight)
        .addProperty("AutoSwitchTo", &GCBasePlayerWeaponVData::GetAutoSwitchTo, &GCBasePlayerWeaponVData::SetAutoSwitchTo)
        .addProperty("AutoSwitchFrom", &GCBasePlayerWeaponVData::GetAutoSwitchFrom, &GCBasePlayerWeaponVData::SetAutoSwitchFrom)
        .addProperty("RumbleEffect", &GCBasePlayerWeaponVData::GetRumbleEffect, &GCBasePlayerWeaponVData::SetRumbleEffect)
        .addProperty("LinkedCooldowns", &GCBasePlayerWeaponVData::GetLinkedCooldowns, &GCBasePlayerWeaponVData::SetLinkedCooldowns)
        .addProperty("Slot", &GCBasePlayerWeaponVData::GetSlot, &GCBasePlayerWeaponVData::SetSlot)
        .addProperty("Position", &GCBasePlayerWeaponVData::GetPosition, &GCBasePlayerWeaponVData::SetPosition)
        .addProperty("Parent", &GCBasePlayerWeaponVData::GetParent, &GCBasePlayerWeaponVData::SetParent)
        .addFunction("ToPtr", &GCBasePlayerWeaponVData::ToPtr)
        .addFunction("IsValid", &GCBasePlayerWeaponVData::IsValid)
        .endClass();
}
GCMathColorBlend::GCMathColorBlend(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCMathColorBlend::GCMathColorBlend(void *ptr) {
    m_ptr = ptr;
}
float GCMathColorBlend::GetInMin() const {
    return GetSchemaValue<float>(m_ptr, "CMathColorBlend", "m_flInMin");
}
void GCMathColorBlend::SetInMin(float value) {
    SetSchemaValue(m_ptr, "CMathColorBlend", "m_flInMin", false, value);
}
float GCMathColorBlend::GetInMax() const {
    return GetSchemaValue<float>(m_ptr, "CMathColorBlend", "m_flInMax");
}
void GCMathColorBlend::SetInMax(float value) {
    SetSchemaValue(m_ptr, "CMathColorBlend", "m_flInMax", false, value);
}
Color GCMathColorBlend::GetOutColor1() const {
    return GetSchemaValue<Color>(m_ptr, "CMathColorBlend", "m_OutColor1");
}
void GCMathColorBlend::SetOutColor1(Color value) {
    SetSchemaValue(m_ptr, "CMathColorBlend", "m_OutColor1", false, value);
}
Color GCMathColorBlend::GetOutColor2() const {
    return GetSchemaValue<Color>(m_ptr, "CMathColorBlend", "m_OutColor2");
}
void GCMathColorBlend::SetOutColor2(Color value) {
    SetSchemaValue(m_ptr, "CMathColorBlend", "m_OutColor2", false, value);
}
void* GCMathColorBlend::GetPtr() {
    return m_ptr;
}
std::string GCMathColorBlend::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCMathColorBlend::IsValid() {
    return (m_ptr != nullptr);
}
GCLogicalEntity GCMathColorBlend::GetParent() const {
    GCLogicalEntity value(m_ptr);
    return value;
}
void GCMathColorBlend::SetParent(GCLogicalEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCMathColorBlend(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCMathColorBlend>("CMathColorBlend")
        .addConstructor<void (*)(std::string)>()
        .addProperty("InMin", &GCMathColorBlend::GetInMin, &GCMathColorBlend::SetInMin)
        .addProperty("InMax", &GCMathColorBlend::GetInMax, &GCMathColorBlend::SetInMax)
        .addProperty("OutColor1", &GCMathColorBlend::GetOutColor1, &GCMathColorBlend::SetOutColor1)
        .addProperty("OutColor2", &GCMathColorBlend::GetOutColor2, &GCMathColorBlend::SetOutColor2)
        .addProperty("Parent", &GCMathColorBlend::GetParent, &GCMathColorBlend::SetParent)
        .addFunction("ToPtr", &GCMathColorBlend::ToPtr)
        .addFunction("IsValid", &GCMathColorBlend::IsValid)
        .endClass();
}
GCEnvScreenOverlay::GCEnvScreenOverlay(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCEnvScreenOverlay::GCEnvScreenOverlay(void *ptr) {
    m_ptr = ptr;
}
std::vector<CUtlSymbolLarge> GCEnvScreenOverlay::GetOverlayNames() const {
    CUtlSymbolLarge* outValue = (CUtlSymbolLarge*)GetSchemaPtr(m_ptr, "CEnvScreenOverlay", "m_iszOverlayNames"); std::vector<CUtlSymbolLarge> ret; for(int i = 0; i < 10; i++) { ret.push_back(outValue[i]); } return ret;
}
void GCEnvScreenOverlay::SetOverlayNames(std::vector<CUtlSymbolLarge> value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'OverlayNames' is not possible.\n");
}
std::vector<float> GCEnvScreenOverlay::GetOverlayTimes() const {
    float* outValue = (float*)GetSchemaPtr(m_ptr, "CEnvScreenOverlay", "m_flOverlayTimes"); std::vector<float> ret; for(int i = 0; i < 10; i++) { ret.push_back(outValue[i]); } return ret;
}
void GCEnvScreenOverlay::SetOverlayTimes(std::vector<float> value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'OverlayTimes' is not possible.\n");
}
float GCEnvScreenOverlay::GetStartTime() const {
    return GetSchemaValue<float>(m_ptr, "CEnvScreenOverlay", "m_flStartTime");
}
void GCEnvScreenOverlay::SetStartTime(float value) {
    SetSchemaValue(m_ptr, "CEnvScreenOverlay", "m_flStartTime", false, value);
}
int32_t GCEnvScreenOverlay::GetDesiredOverlay() const {
    return GetSchemaValue<int32_t>(m_ptr, "CEnvScreenOverlay", "m_iDesiredOverlay");
}
void GCEnvScreenOverlay::SetDesiredOverlay(int32_t value) {
    SetSchemaValue(m_ptr, "CEnvScreenOverlay", "m_iDesiredOverlay", false, value);
}
bool GCEnvScreenOverlay::GetIsActive() const {
    return GetSchemaValue<bool>(m_ptr, "CEnvScreenOverlay", "m_bIsActive");
}
void GCEnvScreenOverlay::SetIsActive(bool value) {
    SetSchemaValue(m_ptr, "CEnvScreenOverlay", "m_bIsActive", false, value);
}
void* GCEnvScreenOverlay::GetPtr() {
    return m_ptr;
}
std::string GCEnvScreenOverlay::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCEnvScreenOverlay::IsValid() {
    return (m_ptr != nullptr);
}
GCPointEntity GCEnvScreenOverlay::GetParent() const {
    GCPointEntity value(m_ptr);
    return value;
}
void GCEnvScreenOverlay::SetParent(GCPointEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCEnvScreenOverlay(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCEnvScreenOverlay>("CEnvScreenOverlay")
        .addConstructor<void (*)(std::string)>()
        .addProperty("OverlayNames", &GCEnvScreenOverlay::GetOverlayNames, &GCEnvScreenOverlay::SetOverlayNames)
        .addProperty("OverlayTimes", &GCEnvScreenOverlay::GetOverlayTimes, &GCEnvScreenOverlay::SetOverlayTimes)
        .addProperty("StartTime", &GCEnvScreenOverlay::GetStartTime, &GCEnvScreenOverlay::SetStartTime)
        .addProperty("DesiredOverlay", &GCEnvScreenOverlay::GetDesiredOverlay, &GCEnvScreenOverlay::SetDesiredOverlay)
        .addProperty("IsActive", &GCEnvScreenOverlay::GetIsActive, &GCEnvScreenOverlay::SetIsActive)
        .addProperty("Parent", &GCEnvScreenOverlay::GetParent, &GCEnvScreenOverlay::SetParent)
        .addFunction("ToPtr", &GCEnvScreenOverlay::ToPtr)
        .addFunction("IsValid", &GCEnvScreenOverlay::IsValid)
        .endClass();
}
GCCSPlayerPawn::GCCSPlayerPawn(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCCSPlayerPawn::GCCSPlayerPawn(void *ptr) {
    m_ptr = ptr;
}
GCCSPlayer_BulletServices GCCSPlayerPawn::GetBulletServices() const {
    GCCSPlayer_BulletServices value(*(void**)GetSchemaPtr(m_ptr, "CCSPlayerPawn", "m_pBulletServices"));
    return value;
}
void GCCSPlayerPawn::SetBulletServices(GCCSPlayer_BulletServices value) {
    SetSchemaValue(m_ptr, "CCSPlayerPawn","m_pBulletServices", false, (char*)value.GetPtr());
}
GCCSPlayer_HostageServices GCCSPlayerPawn::GetHostageServices() const {
    GCCSPlayer_HostageServices value(*(void**)GetSchemaPtr(m_ptr, "CCSPlayerPawn", "m_pHostageServices"));
    return value;
}
void GCCSPlayerPawn::SetHostageServices(GCCSPlayer_HostageServices value) {
    SetSchemaValue(m_ptr, "CCSPlayerPawn","m_pHostageServices", false, (char*)value.GetPtr());
}
GCCSPlayer_BuyServices GCCSPlayerPawn::GetBuyServices() const {
    GCCSPlayer_BuyServices value(*(void**)GetSchemaPtr(m_ptr, "CCSPlayerPawn", "m_pBuyServices"));
    return value;
}
void GCCSPlayerPawn::SetBuyServices(GCCSPlayer_BuyServices value) {
    SetSchemaValue(m_ptr, "CCSPlayerPawn","m_pBuyServices", false, (char*)value.GetPtr());
}
GCCSPlayer_ActionTrackingServices GCCSPlayerPawn::GetActionTrackingServices() const {
    GCCSPlayer_ActionTrackingServices value(*(void**)GetSchemaPtr(m_ptr, "CCSPlayerPawn", "m_pActionTrackingServices"));
    return value;
}
void GCCSPlayerPawn::SetActionTrackingServices(GCCSPlayer_ActionTrackingServices value) {
    SetSchemaValue(m_ptr, "CCSPlayerPawn","m_pActionTrackingServices", false, (char*)value.GetPtr());
}
GCCSPlayer_RadioServices GCCSPlayerPawn::GetRadioServices() const {
    GCCSPlayer_RadioServices value(*(void**)GetSchemaPtr(m_ptr, "CCSPlayerPawn", "m_pRadioServices"));
    return value;
}
void GCCSPlayerPawn::SetRadioServices(GCCSPlayer_RadioServices value) {
    SetSchemaValue(m_ptr, "CCSPlayerPawn","m_pRadioServices", false, (char*)value.GetPtr());
}
GCCSPlayer_DamageReactServices GCCSPlayerPawn::GetDamageReactServices() const {
    GCCSPlayer_DamageReactServices value(*(void**)GetSchemaPtr(m_ptr, "CCSPlayerPawn", "m_pDamageReactServices"));
    return value;
}
void GCCSPlayerPawn::SetDamageReactServices(GCCSPlayer_DamageReactServices value) {
    SetSchemaValue(m_ptr, "CCSPlayerPawn","m_pDamageReactServices", false, (char*)value.GetPtr());
}
uint16_t GCCSPlayerPawn::GetCharacterDefIndex() const {
    return GetSchemaValue<uint16_t>(m_ptr, "CCSPlayerPawn", "m_nCharacterDefIndex");
}
void GCCSPlayerPawn::SetCharacterDefIndex(uint16_t value) {
    SetSchemaValue(m_ptr, "CCSPlayerPawn", "m_nCharacterDefIndex", false, value);
}
bool GCCSPlayerPawn::GetHasFemaleVoice() const {
    return GetSchemaValue<bool>(m_ptr, "CCSPlayerPawn", "m_bHasFemaleVoice");
}
void GCCSPlayerPawn::SetHasFemaleVoice(bool value) {
    SetSchemaValue(m_ptr, "CCSPlayerPawn", "m_bHasFemaleVoice", false, value);
}
std::string GCCSPlayerPawn::GetStrVOPrefix() const {
    return GetSchemaValue<CUtlString>(m_ptr, "CCSPlayerPawn", "m_strVOPrefix").Get();
}
void GCCSPlayerPawn::SetStrVOPrefix(std::string value) {
    SetSchemaValue(m_ptr, "CCSPlayerPawn", "m_strVOPrefix", false, CUtlString(value.c_str()));
}
std::string GCCSPlayerPawn::GetLastPlaceName() const {
    return GetSchemaValuePtr<char>(m_ptr, "CCSPlayerPawn", "m_szLastPlaceName");
}
void GCCSPlayerPawn::SetLastPlaceName(std::string value) {
    WriteSchemaPtrValue(m_ptr, "CCSPlayerPawn", "m_szLastPlaceName", false, reinterpret_cast<byte*>(const_cast<char*>(value.c_str())), 18);
}
bool GCCSPlayerPawn::GetInHostageResetZone() const {
    return GetSchemaValue<bool>(m_ptr, "CCSPlayerPawn", "m_bInHostageResetZone");
}
void GCCSPlayerPawn::SetInHostageResetZone(bool value) {
    SetSchemaValue(m_ptr, "CCSPlayerPawn", "m_bInHostageResetZone", false, value);
}
bool GCCSPlayerPawn::GetInBuyZone() const {
    return GetSchemaValue<bool>(m_ptr, "CCSPlayerPawn", "m_bInBuyZone");
}
void GCCSPlayerPawn::SetInBuyZone(bool value) {
    SetSchemaValue(m_ptr, "CCSPlayerPawn", "m_bInBuyZone", false, value);
}
bool GCCSPlayerPawn::GetWasInBuyZone() const {
    return GetSchemaValue<bool>(m_ptr, "CCSPlayerPawn", "m_bWasInBuyZone");
}
void GCCSPlayerPawn::SetWasInBuyZone(bool value) {
    SetSchemaValue(m_ptr, "CCSPlayerPawn", "m_bWasInBuyZone", false, value);
}
bool GCCSPlayerPawn::GetInHostageRescueZone() const {
    return GetSchemaValue<bool>(m_ptr, "CCSPlayerPawn", "m_bInHostageRescueZone");
}
void GCCSPlayerPawn::SetInHostageRescueZone(bool value) {
    SetSchemaValue(m_ptr, "CCSPlayerPawn", "m_bInHostageRescueZone", false, value);
}
bool GCCSPlayerPawn::GetInBombZone() const {
    return GetSchemaValue<bool>(m_ptr, "CCSPlayerPawn", "m_bInBombZone");
}
void GCCSPlayerPawn::SetInBombZone(bool value) {
    SetSchemaValue(m_ptr, "CCSPlayerPawn", "m_bInBombZone", false, value);
}
bool GCCSPlayerPawn::GetWasInHostageRescueZone() const {
    return GetSchemaValue<bool>(m_ptr, "CCSPlayerPawn", "m_bWasInHostageRescueZone");
}
void GCCSPlayerPawn::SetWasInHostageRescueZone(bool value) {
    SetSchemaValue(m_ptr, "CCSPlayerPawn", "m_bWasInHostageRescueZone", false, value);
}
int32_t GCCSPlayerPawn::GetRetakesOffering() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSPlayerPawn", "m_iRetakesOffering");
}
void GCCSPlayerPawn::SetRetakesOffering(int32_t value) {
    SetSchemaValue(m_ptr, "CCSPlayerPawn", "m_iRetakesOffering", false, value);
}
int32_t GCCSPlayerPawn::GetRetakesOfferingCard() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSPlayerPawn", "m_iRetakesOfferingCard");
}
void GCCSPlayerPawn::SetRetakesOfferingCard(int32_t value) {
    SetSchemaValue(m_ptr, "CCSPlayerPawn", "m_iRetakesOfferingCard", false, value);
}
bool GCCSPlayerPawn::GetRetakesHasDefuseKit() const {
    return GetSchemaValue<bool>(m_ptr, "CCSPlayerPawn", "m_bRetakesHasDefuseKit");
}
void GCCSPlayerPawn::SetRetakesHasDefuseKit(bool value) {
    SetSchemaValue(m_ptr, "CCSPlayerPawn", "m_bRetakesHasDefuseKit", false, value);
}
bool GCCSPlayerPawn::GetRetakesMVPLastRound() const {
    return GetSchemaValue<bool>(m_ptr, "CCSPlayerPawn", "m_bRetakesMVPLastRound");
}
void GCCSPlayerPawn::SetRetakesMVPLastRound(bool value) {
    SetSchemaValue(m_ptr, "CCSPlayerPawn", "m_bRetakesMVPLastRound", false, value);
}
int32_t GCCSPlayerPawn::GetRetakesMVPBoostItem() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSPlayerPawn", "m_iRetakesMVPBoostItem");
}
void GCCSPlayerPawn::SetRetakesMVPBoostItem(int32_t value) {
    SetSchemaValue(m_ptr, "CCSPlayerPawn", "m_iRetakesMVPBoostItem", false, value);
}
uint64_t GCCSPlayerPawn::GetRetakesMVPBoostExtraUtility() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CCSPlayerPawn", "m_RetakesMVPBoostExtraUtility");
}
void GCCSPlayerPawn::SetRetakesMVPBoostExtraUtility(uint64_t value) {
    SetSchemaValue(m_ptr, "CCSPlayerPawn", "m_RetakesMVPBoostExtraUtility", false, value);
}
float GCCSPlayerPawn::GetHealthShotBoostExpirationTime() const {
    return GetSchemaValue<float>(m_ptr, "CCSPlayerPawn", "m_flHealthShotBoostExpirationTime");
}
void GCCSPlayerPawn::SetHealthShotBoostExpirationTime(float value) {
    SetSchemaValue(m_ptr, "CCSPlayerPawn", "m_flHealthShotBoostExpirationTime", false, value);
}
float GCCSPlayerPawn::GetLandingTimeSeconds() const {
    return GetSchemaValue<float>(m_ptr, "CCSPlayerPawn", "m_flLandingTimeSeconds");
}
void GCCSPlayerPawn::SetLandingTimeSeconds(float value) {
    SetSchemaValue(m_ptr, "CCSPlayerPawn", "m_flLandingTimeSeconds", false, value);
}
QAngle GCCSPlayerPawn::GetAimPunchAngle() const {
    return GetSchemaValue<QAngle>(m_ptr, "CCSPlayerPawn", "m_aimPunchAngle");
}
void GCCSPlayerPawn::SetAimPunchAngle(QAngle value) {
    SetSchemaValue(m_ptr, "CCSPlayerPawn", "m_aimPunchAngle", false, value);
}
QAngle GCCSPlayerPawn::GetAimPunchAngleVel() const {
    return GetSchemaValue<QAngle>(m_ptr, "CCSPlayerPawn", "m_aimPunchAngleVel");
}
void GCCSPlayerPawn::SetAimPunchAngleVel(QAngle value) {
    SetSchemaValue(m_ptr, "CCSPlayerPawn", "m_aimPunchAngleVel", false, value);
}
int32_t GCCSPlayerPawn::GetAimPunchTickBase() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSPlayerPawn", "m_aimPunchTickBase");
}
void GCCSPlayerPawn::SetAimPunchTickBase(int32_t value) {
    SetSchemaValue(m_ptr, "CCSPlayerPawn", "m_aimPunchTickBase", false, value);
}
float GCCSPlayerPawn::GetAimPunchTickFraction() const {
    return GetSchemaValue<float>(m_ptr, "CCSPlayerPawn", "m_aimPunchTickFraction");
}
void GCCSPlayerPawn::SetAimPunchTickFraction(float value) {
    SetSchemaValue(m_ptr, "CCSPlayerPawn", "m_aimPunchTickFraction", false, value);
}
std::vector<QAngle> GCCSPlayerPawn::GetAimPunchCache() const {
    CUtlVector<QAngle>* vec = GetSchemaValue<CUtlVector<QAngle>*>(m_ptr, "CCSPlayerPawn", "m_aimPunchCache"); std::vector<QAngle> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCCSPlayerPawn::SetAimPunchCache(std::vector<QAngle> value) {
    SetSchemaValueCUtlVector<QAngle>(m_ptr, "CCSPlayerPawn", "m_aimPunchCache", false, value);
}
bool GCCSPlayerPawn::GetIsBuyMenuOpen() const {
    return GetSchemaValue<bool>(m_ptr, "CCSPlayerPawn", "m_bIsBuyMenuOpen");
}
void GCCSPlayerPawn::SetIsBuyMenuOpen(bool value) {
    SetSchemaValue(m_ptr, "CCSPlayerPawn", "m_bIsBuyMenuOpen", false, value);
}
bool GCCSPlayerPawn::GetLastHeadBoneTransformIsValid() const {
    return GetSchemaValue<bool>(m_ptr, "CCSPlayerPawn", "m_bLastHeadBoneTransformIsValid");
}
void GCCSPlayerPawn::SetLastHeadBoneTransformIsValid(bool value) {
    SetSchemaValue(m_ptr, "CCSPlayerPawn", "m_bLastHeadBoneTransformIsValid", false, value);
}
float GCCSPlayerPawn::GetLastLandTime() const {
    return GetSchemaValue<float>(m_ptr, "CCSPlayerPawn", "m_lastLandTime");
}
void GCCSPlayerPawn::SetLastLandTime(float value) {
    SetSchemaValue(m_ptr, "CCSPlayerPawn", "m_lastLandTime", false, value);
}
bool GCCSPlayerPawn::GetOnGroundLastTick() const {
    return GetSchemaValue<bool>(m_ptr, "CCSPlayerPawn", "m_bOnGroundLastTick");
}
void GCCSPlayerPawn::SetOnGroundLastTick(bool value) {
    SetSchemaValue(m_ptr, "CCSPlayerPawn", "m_bOnGroundLastTick", false, value);
}
int32_t GCCSPlayerPawn::GetPlayerLocked() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSPlayerPawn", "m_iPlayerLocked");
}
void GCCSPlayerPawn::SetPlayerLocked(int32_t value) {
    SetSchemaValue(m_ptr, "CCSPlayerPawn", "m_iPlayerLocked", false, value);
}
float GCCSPlayerPawn::GetTimeOfLastInjury() const {
    return GetSchemaValue<float>(m_ptr, "CCSPlayerPawn", "m_flTimeOfLastInjury");
}
void GCCSPlayerPawn::SetTimeOfLastInjury(float value) {
    SetSchemaValue(m_ptr, "CCSPlayerPawn", "m_flTimeOfLastInjury", false, value);
}
float GCCSPlayerPawn::GetNextSprayDecalTime() const {
    return GetSchemaValue<float>(m_ptr, "CCSPlayerPawn", "m_flNextSprayDecalTime");
}
void GCCSPlayerPawn::SetNextSprayDecalTime(float value) {
    SetSchemaValue(m_ptr, "CCSPlayerPawn", "m_flNextSprayDecalTime", false, value);
}
bool GCCSPlayerPawn::GetNextSprayDecalTimeExpedited() const {
    return GetSchemaValue<bool>(m_ptr, "CCSPlayerPawn", "m_bNextSprayDecalTimeExpedited");
}
void GCCSPlayerPawn::SetNextSprayDecalTimeExpedited(bool value) {
    SetSchemaValue(m_ptr, "CCSPlayerPawn", "m_bNextSprayDecalTimeExpedited", false, value);
}
int32_t GCCSPlayerPawn::GetRagdollDamageBone() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSPlayerPawn", "m_nRagdollDamageBone");
}
void GCCSPlayerPawn::SetRagdollDamageBone(int32_t value) {
    SetSchemaValue(m_ptr, "CCSPlayerPawn", "m_nRagdollDamageBone", false, value);
}
Vector GCCSPlayerPawn::GetRagdollDamageForce() const {
    return GetSchemaValue<Vector>(m_ptr, "CCSPlayerPawn", "m_vRagdollDamageForce");
}
void GCCSPlayerPawn::SetRagdollDamageForce(Vector value) {
    SetSchemaValue(m_ptr, "CCSPlayerPawn", "m_vRagdollDamageForce", false, value);
}
Vector GCCSPlayerPawn::GetRagdollDamagePosition() const {
    return GetSchemaValue<Vector>(m_ptr, "CCSPlayerPawn", "m_vRagdollDamagePosition");
}
void GCCSPlayerPawn::SetRagdollDamagePosition(Vector value) {
    SetSchemaValue(m_ptr, "CCSPlayerPawn", "m_vRagdollDamagePosition", false, value);
}
std::string GCCSPlayerPawn::GetRagdollDamageWeaponName() const {
    return GetSchemaValuePtr<char>(m_ptr, "CCSPlayerPawn", "m_szRagdollDamageWeaponName");
}
void GCCSPlayerPawn::SetRagdollDamageWeaponName(std::string value) {
    WriteSchemaPtrValue(m_ptr, "CCSPlayerPawn", "m_szRagdollDamageWeaponName", false, reinterpret_cast<byte*>(const_cast<char*>(value.c_str())), 64);
}
bool GCCSPlayerPawn::GetRagdollDamageHeadshot() const {
    return GetSchemaValue<bool>(m_ptr, "CCSPlayerPawn", "m_bRagdollDamageHeadshot");
}
void GCCSPlayerPawn::SetRagdollDamageHeadshot(bool value) {
    SetSchemaValue(m_ptr, "CCSPlayerPawn", "m_bRagdollDamageHeadshot", false, value);
}
Vector GCCSPlayerPawn::GetRagdollServerOrigin() const {
    return GetSchemaValue<Vector>(m_ptr, "CCSPlayerPawn", "m_vRagdollServerOrigin");
}
void GCCSPlayerPawn::SetRagdollServerOrigin(Vector value) {
    SetSchemaValue(m_ptr, "CCSPlayerPawn", "m_vRagdollServerOrigin", false, value);
}
GCEconItemView GCCSPlayerPawn::GetEconGloves() const {
    GCEconItemView value(GetSchemaPtr(m_ptr, "CCSPlayerPawn", "m_EconGloves"));
    return value;
}
void GCCSPlayerPawn::SetEconGloves(GCEconItemView value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'EconGloves' is not possible.\n");
}
uint32_t GCCSPlayerPawn::GetEconGlovesChanged() const {
    return GetSchemaValue<uint32_t>(m_ptr, "CCSPlayerPawn", "m_nEconGlovesChanged");
}
void GCCSPlayerPawn::SetEconGlovesChanged(uint32_t value) {
    SetSchemaValue(m_ptr, "CCSPlayerPawn", "m_nEconGlovesChanged", false, value);
}
QAngle GCCSPlayerPawn::GetDeathEyeAngles() const {
    return GetSchemaValue<QAngle>(m_ptr, "CCSPlayerPawn", "m_qDeathEyeAngles");
}
void GCCSPlayerPawn::SetDeathEyeAngles(QAngle value) {
    SetSchemaValue(m_ptr, "CCSPlayerPawn", "m_qDeathEyeAngles", false, value);
}
bool GCCSPlayerPawn::GetSkipOneHeadConstraintUpdate() const {
    return GetSchemaValue<bool>(m_ptr, "CCSPlayerPawn", "m_bSkipOneHeadConstraintUpdate");
}
void GCCSPlayerPawn::SetSkipOneHeadConstraintUpdate(bool value) {
    SetSchemaValue(m_ptr, "CCSPlayerPawn", "m_bSkipOneHeadConstraintUpdate", false, value);
}
bool GCCSPlayerPawn::GetLeftHanded() const {
    return GetSchemaValue<bool>(m_ptr, "CCSPlayerPawn", "m_bLeftHanded");
}
void GCCSPlayerPawn::SetLeftHanded(bool value) {
    SetSchemaValue(m_ptr, "CCSPlayerPawn", "m_bLeftHanded", false, value);
}
float GCCSPlayerPawn::GetSwitchedHandednessTime() const {
    return GetSchemaValue<float>(m_ptr, "CCSPlayerPawn", "m_fSwitchedHandednessTime");
}
void GCCSPlayerPawn::SetSwitchedHandednessTime(float value) {
    SetSchemaValue(m_ptr, "CCSPlayerPawn", "m_fSwitchedHandednessTime", false, value);
}
float GCCSPlayerPawn::GetViewmodelOffsetX() const {
    return GetSchemaValue<float>(m_ptr, "CCSPlayerPawn", "m_flViewmodelOffsetX");
}
void GCCSPlayerPawn::SetViewmodelOffsetX(float value) {
    SetSchemaValue(m_ptr, "CCSPlayerPawn", "m_flViewmodelOffsetX", false, value);
}
float GCCSPlayerPawn::GetViewmodelOffsetY() const {
    return GetSchemaValue<float>(m_ptr, "CCSPlayerPawn", "m_flViewmodelOffsetY");
}
void GCCSPlayerPawn::SetViewmodelOffsetY(float value) {
    SetSchemaValue(m_ptr, "CCSPlayerPawn", "m_flViewmodelOffsetY", false, value);
}
float GCCSPlayerPawn::GetViewmodelOffsetZ() const {
    return GetSchemaValue<float>(m_ptr, "CCSPlayerPawn", "m_flViewmodelOffsetZ");
}
void GCCSPlayerPawn::SetViewmodelOffsetZ(float value) {
    SetSchemaValue(m_ptr, "CCSPlayerPawn", "m_flViewmodelOffsetZ", false, value);
}
float GCCSPlayerPawn::GetViewmodelFOV() const {
    return GetSchemaValue<float>(m_ptr, "CCSPlayerPawn", "m_flViewmodelFOV");
}
void GCCSPlayerPawn::SetViewmodelFOV(float value) {
    SetSchemaValue(m_ptr, "CCSPlayerPawn", "m_flViewmodelFOV", false, value);
}
bool GCCSPlayerPawn::GetIsWalking() const {
    return GetSchemaValue<bool>(m_ptr, "CCSPlayerPawn", "m_bIsWalking");
}
void GCCSPlayerPawn::SetIsWalking(bool value) {
    SetSchemaValue(m_ptr, "CCSPlayerPawn", "m_bIsWalking", false, value);
}
float GCCSPlayerPawn::GetLastGivenDefuserTime() const {
    return GetSchemaValue<float>(m_ptr, "CCSPlayerPawn", "m_fLastGivenDefuserTime");
}
void GCCSPlayerPawn::SetLastGivenDefuserTime(float value) {
    SetSchemaValue(m_ptr, "CCSPlayerPawn", "m_fLastGivenDefuserTime", false, value);
}
float GCCSPlayerPawn::GetLastGivenBombTime() const {
    return GetSchemaValue<float>(m_ptr, "CCSPlayerPawn", "m_fLastGivenBombTime");
}
void GCCSPlayerPawn::SetLastGivenBombTime(float value) {
    SetSchemaValue(m_ptr, "CCSPlayerPawn", "m_fLastGivenBombTime", false, value);
}
float GCCSPlayerPawn::GetDealtDamageToEnemyMostRecentTimestamp() const {
    return GetSchemaValue<float>(m_ptr, "CCSPlayerPawn", "m_flDealtDamageToEnemyMostRecentTimestamp");
}
void GCCSPlayerPawn::SetDealtDamageToEnemyMostRecentTimestamp(float value) {
    SetSchemaValue(m_ptr, "CCSPlayerPawn", "m_flDealtDamageToEnemyMostRecentTimestamp", false, value);
}
uint32_t GCCSPlayerPawn::GetDisplayHistoryBits() const {
    return GetSchemaValue<uint32_t>(m_ptr, "CCSPlayerPawn", "m_iDisplayHistoryBits");
}
void GCCSPlayerPawn::SetDisplayHistoryBits(uint32_t value) {
    SetSchemaValue(m_ptr, "CCSPlayerPawn", "m_iDisplayHistoryBits", false, value);
}
float GCCSPlayerPawn::GetLastAttackedTeammate() const {
    return GetSchemaValue<float>(m_ptr, "CCSPlayerPawn", "m_flLastAttackedTeammate");
}
void GCCSPlayerPawn::SetLastAttackedTeammate(float value) {
    SetSchemaValue(m_ptr, "CCSPlayerPawn", "m_flLastAttackedTeammate", false, value);
}
float GCCSPlayerPawn::GetAllowAutoFollowTime() const {
    return GetSchemaValue<float>(m_ptr, "CCSPlayerPawn", "m_allowAutoFollowTime");
}
void GCCSPlayerPawn::SetAllowAutoFollowTime(float value) {
    SetSchemaValue(m_ptr, "CCSPlayerPawn", "m_allowAutoFollowTime", false, value);
}
bool GCCSPlayerPawn::GetResetArmorNextSpawn() const {
    return GetSchemaValue<bool>(m_ptr, "CCSPlayerPawn", "m_bResetArmorNextSpawn");
}
void GCCSPlayerPawn::SetResetArmorNextSpawn(bool value) {
    SetSchemaValue(m_ptr, "CCSPlayerPawn", "m_bResetArmorNextSpawn", false, value);
}
int GCCSPlayerPawn::GetLastKillerIndex() const {
    return GetSchemaValue<CEntityIndex>(m_ptr, "CCSPlayerPawn", "m_nLastKillerIndex").Get();
}
void GCCSPlayerPawn::SetLastKillerIndex(int value) {
    SetSchemaValue(m_ptr, "CCSPlayerPawn", "m_nLastKillerIndex", false, CEntityIndex(value));
}
GEntitySpottedState_t GCCSPlayerPawn::GetEntitySpottedState() const {
    GEntitySpottedState_t value(GetSchemaPtr(m_ptr, "CCSPlayerPawn", "m_entitySpottedState"));
    return value;
}
void GCCSPlayerPawn::SetEntitySpottedState(GEntitySpottedState_t value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'EntitySpottedState' is not possible.\n");
}
int32_t GCCSPlayerPawn::GetSpotRules() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSPlayerPawn", "m_nSpotRules");
}
void GCCSPlayerPawn::SetSpotRules(int32_t value) {
    SetSchemaValue(m_ptr, "CCSPlayerPawn", "m_nSpotRules", false, value);
}
bool GCCSPlayerPawn::GetIsScoped() const {
    return GetSchemaValue<bool>(m_ptr, "CCSPlayerPawn", "m_bIsScoped");
}
void GCCSPlayerPawn::SetIsScoped(bool value) {
    SetSchemaValue(m_ptr, "CCSPlayerPawn", "m_bIsScoped", false, value);
}
bool GCCSPlayerPawn::GetResumeZoom() const {
    return GetSchemaValue<bool>(m_ptr, "CCSPlayerPawn", "m_bResumeZoom");
}
void GCCSPlayerPawn::SetResumeZoom(bool value) {
    SetSchemaValue(m_ptr, "CCSPlayerPawn", "m_bResumeZoom", false, value);
}
bool GCCSPlayerPawn::GetIsDefusing() const {
    return GetSchemaValue<bool>(m_ptr, "CCSPlayerPawn", "m_bIsDefusing");
}
void GCCSPlayerPawn::SetIsDefusing(bool value) {
    SetSchemaValue(m_ptr, "CCSPlayerPawn", "m_bIsDefusing", false, value);
}
bool GCCSPlayerPawn::GetIsGrabbingHostage() const {
    return GetSchemaValue<bool>(m_ptr, "CCSPlayerPawn", "m_bIsGrabbingHostage");
}
void GCCSPlayerPawn::SetIsGrabbingHostage(bool value) {
    SetSchemaValue(m_ptr, "CCSPlayerPawn", "m_bIsGrabbingHostage", false, value);
}
uint64_t GCCSPlayerPawn::GetBlockingUseActionInProgress() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CCSPlayerPawn", "m_iBlockingUseActionInProgress");
}
void GCCSPlayerPawn::SetBlockingUseActionInProgress(uint64_t value) {
    SetSchemaValue(m_ptr, "CCSPlayerPawn", "m_iBlockingUseActionInProgress", false, value);
}
float GCCSPlayerPawn::GetEmitSoundTime() const {
    return GetSchemaValue<float>(m_ptr, "CCSPlayerPawn", "m_flEmitSoundTime");
}
void GCCSPlayerPawn::SetEmitSoundTime(float value) {
    SetSchemaValue(m_ptr, "CCSPlayerPawn", "m_flEmitSoundTime", false, value);
}
bool GCCSPlayerPawn::GetInNoDefuseArea() const {
    return GetSchemaValue<bool>(m_ptr, "CCSPlayerPawn", "m_bInNoDefuseArea");
}
void GCCSPlayerPawn::SetInNoDefuseArea(bool value) {
    SetSchemaValue(m_ptr, "CCSPlayerPawn", "m_bInNoDefuseArea", false, value);
}
int GCCSPlayerPawn::GetBombSiteIndex() const {
    return GetSchemaValue<CEntityIndex>(m_ptr, "CCSPlayerPawn", "m_iBombSiteIndex").Get();
}
void GCCSPlayerPawn::SetBombSiteIndex(int value) {
    SetSchemaValue(m_ptr, "CCSPlayerPawn", "m_iBombSiteIndex", false, CEntityIndex(value));
}
int32_t GCCSPlayerPawn::GetWhichBombZone() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSPlayerPawn", "m_nWhichBombZone");
}
void GCCSPlayerPawn::SetWhichBombZone(int32_t value) {
    SetSchemaValue(m_ptr, "CCSPlayerPawn", "m_nWhichBombZone", false, value);
}
bool GCCSPlayerPawn::GetInBombZoneTrigger() const {
    return GetSchemaValue<bool>(m_ptr, "CCSPlayerPawn", "m_bInBombZoneTrigger");
}
void GCCSPlayerPawn::SetInBombZoneTrigger(bool value) {
    SetSchemaValue(m_ptr, "CCSPlayerPawn", "m_bInBombZoneTrigger", false, value);
}
bool GCCSPlayerPawn::GetWasInBombZoneTrigger() const {
    return GetSchemaValue<bool>(m_ptr, "CCSPlayerPawn", "m_bWasInBombZoneTrigger");
}
void GCCSPlayerPawn::SetWasInBombZoneTrigger(bool value) {
    SetSchemaValue(m_ptr, "CCSPlayerPawn", "m_bWasInBombZoneTrigger", false, value);
}
int32_t GCCSPlayerPawn::GetShotsFired() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSPlayerPawn", "m_iShotsFired");
}
void GCCSPlayerPawn::SetShotsFired(int32_t value) {
    SetSchemaValue(m_ptr, "CCSPlayerPawn", "m_iShotsFired", false, value);
}
float GCCSPlayerPawn::GetFlinchStack() const {
    return GetSchemaValue<float>(m_ptr, "CCSPlayerPawn", "m_flFlinchStack");
}
void GCCSPlayerPawn::SetFlinchStack(float value) {
    SetSchemaValue(m_ptr, "CCSPlayerPawn", "m_flFlinchStack", false, value);
}
float GCCSPlayerPawn::GetVelocityModifier() const {
    return GetSchemaValue<float>(m_ptr, "CCSPlayerPawn", "m_flVelocityModifier");
}
void GCCSPlayerPawn::SetVelocityModifier(float value) {
    SetSchemaValue(m_ptr, "CCSPlayerPawn", "m_flVelocityModifier", false, value);
}
float GCCSPlayerPawn::GetHitHeading() const {
    return GetSchemaValue<float>(m_ptr, "CCSPlayerPawn", "m_flHitHeading");
}
void GCCSPlayerPawn::SetHitHeading(float value) {
    SetSchemaValue(m_ptr, "CCSPlayerPawn", "m_flHitHeading", false, value);
}
int32_t GCCSPlayerPawn::GetHitBodyPart() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSPlayerPawn", "m_nHitBodyPart");
}
void GCCSPlayerPawn::SetHitBodyPart(int32_t value) {
    SetSchemaValue(m_ptr, "CCSPlayerPawn", "m_nHitBodyPart", false, value);
}
Vector GCCSPlayerPawn::GetTotalBulletForce() const {
    return GetSchemaValue<Vector>(m_ptr, "CCSPlayerPawn", "m_vecTotalBulletForce");
}
void GCCSPlayerPawn::SetTotalBulletForce(Vector value) {
    SetSchemaValue(m_ptr, "CCSPlayerPawn", "m_vecTotalBulletForce", false, value);
}
bool GCCSPlayerPawn::GetWaitForNoAttack() const {
    return GetSchemaValue<bool>(m_ptr, "CCSPlayerPawn", "m_bWaitForNoAttack");
}
void GCCSPlayerPawn::SetWaitForNoAttack(bool value) {
    SetSchemaValue(m_ptr, "CCSPlayerPawn", "m_bWaitForNoAttack", false, value);
}
float GCCSPlayerPawn::GetIgnoreLadderJumpTime() const {
    return GetSchemaValue<float>(m_ptr, "CCSPlayerPawn", "m_ignoreLadderJumpTime");
}
void GCCSPlayerPawn::SetIgnoreLadderJumpTime(float value) {
    SetSchemaValue(m_ptr, "CCSPlayerPawn", "m_ignoreLadderJumpTime", false, value);
}
bool GCCSPlayerPawn::GetKilledByHeadshot() const {
    return GetSchemaValue<bool>(m_ptr, "CCSPlayerPawn", "m_bKilledByHeadshot");
}
void GCCSPlayerPawn::SetKilledByHeadshot(bool value) {
    SetSchemaValue(m_ptr, "CCSPlayerPawn", "m_bKilledByHeadshot", false, value);
}
int32_t GCCSPlayerPawn::GetLastHitBox() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSPlayerPawn", "m_LastHitBox");
}
void GCCSPlayerPawn::SetLastHitBox(int32_t value) {
    SetSchemaValue(m_ptr, "CCSPlayerPawn", "m_LastHitBox", false, value);
}
int32_t GCCSPlayerPawn::GetLastHealth() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSPlayerPawn", "m_LastHealth");
}
void GCCSPlayerPawn::SetLastHealth(int32_t value) {
    SetSchemaValue(m_ptr, "CCSPlayerPawn", "m_LastHealth", false, value);
}
GCCSBot GCCSPlayerPawn::GetBot() const {
    GCCSBot value(*(void**)GetSchemaPtr(m_ptr, "CCSPlayerPawn", "m_pBot"));
    return value;
}
void GCCSPlayerPawn::SetBot(GCCSBot value) {
    SetSchemaValue(m_ptr, "CCSPlayerPawn","m_pBot", false, (char*)value.GetPtr());
}
bool GCCSPlayerPawn::GetBotAllowActive() const {
    return GetSchemaValue<bool>(m_ptr, "CCSPlayerPawn", "m_bBotAllowActive");
}
void GCCSPlayerPawn::SetBotAllowActive(bool value) {
    SetSchemaValue(m_ptr, "CCSPlayerPawn", "m_bBotAllowActive", false, value);
}
QAngle GCCSPlayerPawn::GetThirdPersonHeading() const {
    return GetSchemaValue<QAngle>(m_ptr, "CCSPlayerPawn", "m_thirdPersonHeading");
}
void GCCSPlayerPawn::SetThirdPersonHeading(QAngle value) {
    SetSchemaValue(m_ptr, "CCSPlayerPawn", "m_thirdPersonHeading", false, value);
}
float GCCSPlayerPawn::GetSlopeDropOffset() const {
    return GetSchemaValue<float>(m_ptr, "CCSPlayerPawn", "m_flSlopeDropOffset");
}
void GCCSPlayerPawn::SetSlopeDropOffset(float value) {
    SetSchemaValue(m_ptr, "CCSPlayerPawn", "m_flSlopeDropOffset", false, value);
}
float GCCSPlayerPawn::GetSlopeDropHeight() const {
    return GetSchemaValue<float>(m_ptr, "CCSPlayerPawn", "m_flSlopeDropHeight");
}
void GCCSPlayerPawn::SetSlopeDropHeight(float value) {
    SetSchemaValue(m_ptr, "CCSPlayerPawn", "m_flSlopeDropHeight", false, value);
}
Vector GCCSPlayerPawn::GetHeadConstraintOffset() const {
    return GetSchemaValue<Vector>(m_ptr, "CCSPlayerPawn", "m_vHeadConstraintOffset");
}
void GCCSPlayerPawn::SetHeadConstraintOffset(Vector value) {
    SetSchemaValue(m_ptr, "CCSPlayerPawn", "m_vHeadConstraintOffset", false, value);
}
int32_t GCCSPlayerPawn::GetLastPickupPriority() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSPlayerPawn", "m_nLastPickupPriority");
}
void GCCSPlayerPawn::SetLastPickupPriority(int32_t value) {
    SetSchemaValue(m_ptr, "CCSPlayerPawn", "m_nLastPickupPriority", false, value);
}
float GCCSPlayerPawn::GetLastPickupPriorityTime() const {
    return GetSchemaValue<float>(m_ptr, "CCSPlayerPawn", "m_flLastPickupPriorityTime");
}
void GCCSPlayerPawn::SetLastPickupPriorityTime(float value) {
    SetSchemaValue(m_ptr, "CCSPlayerPawn", "m_flLastPickupPriorityTime", false, value);
}
int32_t GCCSPlayerPawn::GetArmorValue() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSPlayerPawn", "m_ArmorValue");
}
void GCCSPlayerPawn::SetArmorValue(int32_t value) {
    SetSchemaValue(m_ptr, "CCSPlayerPawn", "m_ArmorValue", false, value);
}
uint16_t GCCSPlayerPawn::GetCurrentEquipmentValue() const {
    return GetSchemaValue<uint16_t>(m_ptr, "CCSPlayerPawn", "m_unCurrentEquipmentValue");
}
void GCCSPlayerPawn::SetCurrentEquipmentValue(uint16_t value) {
    SetSchemaValue(m_ptr, "CCSPlayerPawn", "m_unCurrentEquipmentValue", false, value);
}
uint16_t GCCSPlayerPawn::GetRoundStartEquipmentValue() const {
    return GetSchemaValue<uint16_t>(m_ptr, "CCSPlayerPawn", "m_unRoundStartEquipmentValue");
}
void GCCSPlayerPawn::SetRoundStartEquipmentValue(uint16_t value) {
    SetSchemaValue(m_ptr, "CCSPlayerPawn", "m_unRoundStartEquipmentValue", false, value);
}
uint16_t GCCSPlayerPawn::GetFreezetimeEndEquipmentValue() const {
    return GetSchemaValue<uint16_t>(m_ptr, "CCSPlayerPawn", "m_unFreezetimeEndEquipmentValue");
}
void GCCSPlayerPawn::SetFreezetimeEndEquipmentValue(uint16_t value) {
    SetSchemaValue(m_ptr, "CCSPlayerPawn", "m_unFreezetimeEndEquipmentValue", false, value);
}
int32_t GCCSPlayerPawn::GetLastWeaponFireUsercmd() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSPlayerPawn", "m_iLastWeaponFireUsercmd");
}
void GCCSPlayerPawn::SetLastWeaponFireUsercmd(int32_t value) {
    SetSchemaValue(m_ptr, "CCSPlayerPawn", "m_iLastWeaponFireUsercmd", false, value);
}
float GCCSPlayerPawn::GetLastFriendlyFireDamageReductionRatio() const {
    return GetSchemaValue<float>(m_ptr, "CCSPlayerPawn", "m_flLastFriendlyFireDamageReductionRatio");
}
void GCCSPlayerPawn::SetLastFriendlyFireDamageReductionRatio(float value) {
    SetSchemaValue(m_ptr, "CCSPlayerPawn", "m_flLastFriendlyFireDamageReductionRatio", false, value);
}
bool GCCSPlayerPawn::GetIsSpawning() const {
    return GetSchemaValue<bool>(m_ptr, "CCSPlayerPawn", "m_bIsSpawning");
}
void GCCSPlayerPawn::SetIsSpawning(bool value) {
    SetSchemaValue(m_ptr, "CCSPlayerPawn", "m_bIsSpawning", false, value);
}
int32_t GCCSPlayerPawn::GetDeathFlags() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSPlayerPawn", "m_iDeathFlags");
}
void GCCSPlayerPawn::SetDeathFlags(int32_t value) {
    SetSchemaValue(m_ptr, "CCSPlayerPawn", "m_iDeathFlags", false, value);
}
bool GCCSPlayerPawn::GetHasDeathInfo() const {
    return GetSchemaValue<bool>(m_ptr, "CCSPlayerPawn", "m_bHasDeathInfo");
}
void GCCSPlayerPawn::SetHasDeathInfo(bool value) {
    SetSchemaValue(m_ptr, "CCSPlayerPawn", "m_bHasDeathInfo", false, value);
}
float GCCSPlayerPawn::GetDeathInfoTime() const {
    return GetSchemaValue<float>(m_ptr, "CCSPlayerPawn", "m_flDeathInfoTime");
}
void GCCSPlayerPawn::SetDeathInfoTime(float value) {
    SetSchemaValue(m_ptr, "CCSPlayerPawn", "m_flDeathInfoTime", false, value);
}
Vector GCCSPlayerPawn::GetDeathInfoOrigin() const {
    return GetSchemaValue<Vector>(m_ptr, "CCSPlayerPawn", "m_vecDeathInfoOrigin");
}
void GCCSPlayerPawn::SetDeathInfoOrigin(Vector value) {
    SetSchemaValue(m_ptr, "CCSPlayerPawn", "m_vecDeathInfoOrigin", false, value);
}
std::vector<uint32_t> GCCSPlayerPawn::GetPlayerPatchEconIndices() const {
    uint32_t* outValue = (uint32_t*)GetSchemaPtr(m_ptr, "CCSPlayerPawn", "m_vecPlayerPatchEconIndices"); std::vector<uint32_t> ret; for(int i = 0; i < 5; i++) { ret.push_back(outValue[i]); } return ret;
}
void GCCSPlayerPawn::SetPlayerPatchEconIndices(std::vector<uint32_t> value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'PlayerPatchEconIndices' is not possible.\n");
}
Color GCCSPlayerPawn::GetGunGameImmunityColor() const {
    return GetSchemaValue<Color>(m_ptr, "CCSPlayerPawn", "m_GunGameImmunityColor");
}
void GCCSPlayerPawn::SetGunGameImmunityColor(Color value) {
    SetSchemaValue(m_ptr, "CCSPlayerPawn", "m_GunGameImmunityColor", false, value);
}
float GCCSPlayerPawn::GetGrenadeParameterStashTime() const {
    return GetSchemaValue<float>(m_ptr, "CCSPlayerPawn", "m_grenadeParameterStashTime");
}
void GCCSPlayerPawn::SetGrenadeParameterStashTime(float value) {
    SetSchemaValue(m_ptr, "CCSPlayerPawn", "m_grenadeParameterStashTime", false, value);
}
bool GCCSPlayerPawn::GetGrenadeParametersStashed() const {
    return GetSchemaValue<bool>(m_ptr, "CCSPlayerPawn", "m_bGrenadeParametersStashed");
}
void GCCSPlayerPawn::SetGrenadeParametersStashed(bool value) {
    SetSchemaValue(m_ptr, "CCSPlayerPawn", "m_bGrenadeParametersStashed", false, value);
}
QAngle GCCSPlayerPawn::GetStashedShootAngles() const {
    return GetSchemaValue<QAngle>(m_ptr, "CCSPlayerPawn", "m_angStashedShootAngles");
}
void GCCSPlayerPawn::SetStashedShootAngles(QAngle value) {
    SetSchemaValue(m_ptr, "CCSPlayerPawn", "m_angStashedShootAngles", false, value);
}
Vector GCCSPlayerPawn::GetStashedGrenadeThrowPosition() const {
    return GetSchemaValue<Vector>(m_ptr, "CCSPlayerPawn", "m_vecStashedGrenadeThrowPosition");
}
void GCCSPlayerPawn::SetStashedGrenadeThrowPosition(Vector value) {
    SetSchemaValue(m_ptr, "CCSPlayerPawn", "m_vecStashedGrenadeThrowPosition", false, value);
}
Vector GCCSPlayerPawn::GetStashedVelocity() const {
    return GetSchemaValue<Vector>(m_ptr, "CCSPlayerPawn", "m_vecStashedVelocity");
}
void GCCSPlayerPawn::SetStashedVelocity(Vector value) {
    SetSchemaValue(m_ptr, "CCSPlayerPawn", "m_vecStashedVelocity", false, value);
}
std::vector<QAngle> GCCSPlayerPawn::GetShootAngleHistory() const {
    QAngle* outValue = (QAngle*)GetSchemaPtr(m_ptr, "CCSPlayerPawn", "m_angShootAngleHistory"); std::vector<QAngle> ret; for(int i = 0; i < 2; i++) { ret.push_back(outValue[i]); } return ret;
}
void GCCSPlayerPawn::SetShootAngleHistory(std::vector<QAngle> value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'ShootAngleHistory' is not possible.\n");
}
std::vector<Vector> GCCSPlayerPawn::GetThrowPositionHistory() const {
    Vector* outValue = (Vector*)GetSchemaPtr(m_ptr, "CCSPlayerPawn", "m_vecThrowPositionHistory"); std::vector<Vector> ret; for(int i = 0; i < 2; i++) { ret.push_back(outValue[i]); } return ret;
}
void GCCSPlayerPawn::SetThrowPositionHistory(std::vector<Vector> value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'ThrowPositionHistory' is not possible.\n");
}
std::vector<Vector> GCCSPlayerPawn::GetVelocityHistory() const {
    Vector* outValue = (Vector*)GetSchemaPtr(m_ptr, "CCSPlayerPawn", "m_vecVelocityHistory"); std::vector<Vector> ret; for(int i = 0; i < 2; i++) { ret.push_back(outValue[i]); } return ret;
}
void GCCSPlayerPawn::SetVelocityHistory(std::vector<Vector> value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'VelocityHistory' is not possible.\n");
}
void* GCCSPlayerPawn::GetPtr() {
    return m_ptr;
}
std::string GCCSPlayerPawn::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCCSPlayerPawn::IsValid() {
    return (m_ptr != nullptr);
}
GCCSPlayerPawnBase GCCSPlayerPawn::GetParent() const {
    GCCSPlayerPawnBase value(m_ptr);
    return value;
}
void GCCSPlayerPawn::SetParent(GCCSPlayerPawnBase value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCCSPlayerPawn(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCCSPlayerPawn>("CCSPlayerPawn")
        .addConstructor<void (*)(std::string)>()
        .addProperty("BulletServices", &GCCSPlayerPawn::GetBulletServices, &GCCSPlayerPawn::SetBulletServices)
        .addProperty("HostageServices", &GCCSPlayerPawn::GetHostageServices, &GCCSPlayerPawn::SetHostageServices)
        .addProperty("BuyServices", &GCCSPlayerPawn::GetBuyServices, &GCCSPlayerPawn::SetBuyServices)
        .addProperty("ActionTrackingServices", &GCCSPlayerPawn::GetActionTrackingServices, &GCCSPlayerPawn::SetActionTrackingServices)
        .addProperty("RadioServices", &GCCSPlayerPawn::GetRadioServices, &GCCSPlayerPawn::SetRadioServices)
        .addProperty("DamageReactServices", &GCCSPlayerPawn::GetDamageReactServices, &GCCSPlayerPawn::SetDamageReactServices)
        .addProperty("CharacterDefIndex", &GCCSPlayerPawn::GetCharacterDefIndex, &GCCSPlayerPawn::SetCharacterDefIndex)
        .addProperty("HasFemaleVoice", &GCCSPlayerPawn::GetHasFemaleVoice, &GCCSPlayerPawn::SetHasFemaleVoice)
        .addProperty("StrVOPrefix", &GCCSPlayerPawn::GetStrVOPrefix, &GCCSPlayerPawn::SetStrVOPrefix)
        .addProperty("LastPlaceName", &GCCSPlayerPawn::GetLastPlaceName, &GCCSPlayerPawn::SetLastPlaceName)
        .addProperty("InHostageResetZone", &GCCSPlayerPawn::GetInHostageResetZone, &GCCSPlayerPawn::SetInHostageResetZone)
        .addProperty("InBuyZone", &GCCSPlayerPawn::GetInBuyZone, &GCCSPlayerPawn::SetInBuyZone)
        .addProperty("WasInBuyZone", &GCCSPlayerPawn::GetWasInBuyZone, &GCCSPlayerPawn::SetWasInBuyZone)
        .addProperty("InHostageRescueZone", &GCCSPlayerPawn::GetInHostageRescueZone, &GCCSPlayerPawn::SetInHostageRescueZone)
        .addProperty("InBombZone", &GCCSPlayerPawn::GetInBombZone, &GCCSPlayerPawn::SetInBombZone)
        .addProperty("WasInHostageRescueZone", &GCCSPlayerPawn::GetWasInHostageRescueZone, &GCCSPlayerPawn::SetWasInHostageRescueZone)
        .addProperty("RetakesOffering", &GCCSPlayerPawn::GetRetakesOffering, &GCCSPlayerPawn::SetRetakesOffering)
        .addProperty("RetakesOfferingCard", &GCCSPlayerPawn::GetRetakesOfferingCard, &GCCSPlayerPawn::SetRetakesOfferingCard)
        .addProperty("RetakesHasDefuseKit", &GCCSPlayerPawn::GetRetakesHasDefuseKit, &GCCSPlayerPawn::SetRetakesHasDefuseKit)
        .addProperty("RetakesMVPLastRound", &GCCSPlayerPawn::GetRetakesMVPLastRound, &GCCSPlayerPawn::SetRetakesMVPLastRound)
        .addProperty("RetakesMVPBoostItem", &GCCSPlayerPawn::GetRetakesMVPBoostItem, &GCCSPlayerPawn::SetRetakesMVPBoostItem)
        .addProperty("RetakesMVPBoostExtraUtility", &GCCSPlayerPawn::GetRetakesMVPBoostExtraUtility, &GCCSPlayerPawn::SetRetakesMVPBoostExtraUtility)
        .addProperty("HealthShotBoostExpirationTime", &GCCSPlayerPawn::GetHealthShotBoostExpirationTime, &GCCSPlayerPawn::SetHealthShotBoostExpirationTime)
        .addProperty("LandingTimeSeconds", &GCCSPlayerPawn::GetLandingTimeSeconds, &GCCSPlayerPawn::SetLandingTimeSeconds)
        .addProperty("AimPunchAngle", &GCCSPlayerPawn::GetAimPunchAngle, &GCCSPlayerPawn::SetAimPunchAngle)
        .addProperty("AimPunchAngleVel", &GCCSPlayerPawn::GetAimPunchAngleVel, &GCCSPlayerPawn::SetAimPunchAngleVel)
        .addProperty("AimPunchTickBase", &GCCSPlayerPawn::GetAimPunchTickBase, &GCCSPlayerPawn::SetAimPunchTickBase)
        .addProperty("AimPunchTickFraction", &GCCSPlayerPawn::GetAimPunchTickFraction, &GCCSPlayerPawn::SetAimPunchTickFraction)
        .addProperty("AimPunchCache", &GCCSPlayerPawn::GetAimPunchCache, &GCCSPlayerPawn::SetAimPunchCache)
        .addProperty("IsBuyMenuOpen", &GCCSPlayerPawn::GetIsBuyMenuOpen, &GCCSPlayerPawn::SetIsBuyMenuOpen)
        .addProperty("LastHeadBoneTransformIsValid", &GCCSPlayerPawn::GetLastHeadBoneTransformIsValid, &GCCSPlayerPawn::SetLastHeadBoneTransformIsValid)
        .addProperty("LastLandTime", &GCCSPlayerPawn::GetLastLandTime, &GCCSPlayerPawn::SetLastLandTime)
        .addProperty("OnGroundLastTick", &GCCSPlayerPawn::GetOnGroundLastTick, &GCCSPlayerPawn::SetOnGroundLastTick)
        .addProperty("PlayerLocked", &GCCSPlayerPawn::GetPlayerLocked, &GCCSPlayerPawn::SetPlayerLocked)
        .addProperty("TimeOfLastInjury", &GCCSPlayerPawn::GetTimeOfLastInjury, &GCCSPlayerPawn::SetTimeOfLastInjury)
        .addProperty("NextSprayDecalTime", &GCCSPlayerPawn::GetNextSprayDecalTime, &GCCSPlayerPawn::SetNextSprayDecalTime)
        .addProperty("NextSprayDecalTimeExpedited", &GCCSPlayerPawn::GetNextSprayDecalTimeExpedited, &GCCSPlayerPawn::SetNextSprayDecalTimeExpedited)
        .addProperty("RagdollDamageBone", &GCCSPlayerPawn::GetRagdollDamageBone, &GCCSPlayerPawn::SetRagdollDamageBone)
        .addProperty("RagdollDamageForce", &GCCSPlayerPawn::GetRagdollDamageForce, &GCCSPlayerPawn::SetRagdollDamageForce)
        .addProperty("RagdollDamagePosition", &GCCSPlayerPawn::GetRagdollDamagePosition, &GCCSPlayerPawn::SetRagdollDamagePosition)
        .addProperty("RagdollDamageWeaponName", &GCCSPlayerPawn::GetRagdollDamageWeaponName, &GCCSPlayerPawn::SetRagdollDamageWeaponName)
        .addProperty("RagdollDamageHeadshot", &GCCSPlayerPawn::GetRagdollDamageHeadshot, &GCCSPlayerPawn::SetRagdollDamageHeadshot)
        .addProperty("RagdollServerOrigin", &GCCSPlayerPawn::GetRagdollServerOrigin, &GCCSPlayerPawn::SetRagdollServerOrigin)
        .addProperty("EconGloves", &GCCSPlayerPawn::GetEconGloves, &GCCSPlayerPawn::SetEconGloves)
        .addProperty("EconGlovesChanged", &GCCSPlayerPawn::GetEconGlovesChanged, &GCCSPlayerPawn::SetEconGlovesChanged)
        .addProperty("DeathEyeAngles", &GCCSPlayerPawn::GetDeathEyeAngles, &GCCSPlayerPawn::SetDeathEyeAngles)
        .addProperty("SkipOneHeadConstraintUpdate", &GCCSPlayerPawn::GetSkipOneHeadConstraintUpdate, &GCCSPlayerPawn::SetSkipOneHeadConstraintUpdate)
        .addProperty("LeftHanded", &GCCSPlayerPawn::GetLeftHanded, &GCCSPlayerPawn::SetLeftHanded)
        .addProperty("SwitchedHandednessTime", &GCCSPlayerPawn::GetSwitchedHandednessTime, &GCCSPlayerPawn::SetSwitchedHandednessTime)
        .addProperty("ViewmodelOffsetX", &GCCSPlayerPawn::GetViewmodelOffsetX, &GCCSPlayerPawn::SetViewmodelOffsetX)
        .addProperty("ViewmodelOffsetY", &GCCSPlayerPawn::GetViewmodelOffsetY, &GCCSPlayerPawn::SetViewmodelOffsetY)
        .addProperty("ViewmodelOffsetZ", &GCCSPlayerPawn::GetViewmodelOffsetZ, &GCCSPlayerPawn::SetViewmodelOffsetZ)
        .addProperty("ViewmodelFOV", &GCCSPlayerPawn::GetViewmodelFOV, &GCCSPlayerPawn::SetViewmodelFOV)
        .addProperty("IsWalking", &GCCSPlayerPawn::GetIsWalking, &GCCSPlayerPawn::SetIsWalking)
        .addProperty("LastGivenDefuserTime", &GCCSPlayerPawn::GetLastGivenDefuserTime, &GCCSPlayerPawn::SetLastGivenDefuserTime)
        .addProperty("LastGivenBombTime", &GCCSPlayerPawn::GetLastGivenBombTime, &GCCSPlayerPawn::SetLastGivenBombTime)
        .addProperty("DealtDamageToEnemyMostRecentTimestamp", &GCCSPlayerPawn::GetDealtDamageToEnemyMostRecentTimestamp, &GCCSPlayerPawn::SetDealtDamageToEnemyMostRecentTimestamp)
        .addProperty("DisplayHistoryBits", &GCCSPlayerPawn::GetDisplayHistoryBits, &GCCSPlayerPawn::SetDisplayHistoryBits)
        .addProperty("LastAttackedTeammate", &GCCSPlayerPawn::GetLastAttackedTeammate, &GCCSPlayerPawn::SetLastAttackedTeammate)
        .addProperty("AllowAutoFollowTime", &GCCSPlayerPawn::GetAllowAutoFollowTime, &GCCSPlayerPawn::SetAllowAutoFollowTime)
        .addProperty("ResetArmorNextSpawn", &GCCSPlayerPawn::GetResetArmorNextSpawn, &GCCSPlayerPawn::SetResetArmorNextSpawn)
        .addProperty("LastKillerIndex", &GCCSPlayerPawn::GetLastKillerIndex, &GCCSPlayerPawn::SetLastKillerIndex)
        .addProperty("EntitySpottedState", &GCCSPlayerPawn::GetEntitySpottedState, &GCCSPlayerPawn::SetEntitySpottedState)
        .addProperty("SpotRules", &GCCSPlayerPawn::GetSpotRules, &GCCSPlayerPawn::SetSpotRules)
        .addProperty("IsScoped", &GCCSPlayerPawn::GetIsScoped, &GCCSPlayerPawn::SetIsScoped)
        .addProperty("ResumeZoom", &GCCSPlayerPawn::GetResumeZoom, &GCCSPlayerPawn::SetResumeZoom)
        .addProperty("IsDefusing", &GCCSPlayerPawn::GetIsDefusing, &GCCSPlayerPawn::SetIsDefusing)
        .addProperty("IsGrabbingHostage", &GCCSPlayerPawn::GetIsGrabbingHostage, &GCCSPlayerPawn::SetIsGrabbingHostage)
        .addProperty("BlockingUseActionInProgress", &GCCSPlayerPawn::GetBlockingUseActionInProgress, &GCCSPlayerPawn::SetBlockingUseActionInProgress)
        .addProperty("EmitSoundTime", &GCCSPlayerPawn::GetEmitSoundTime, &GCCSPlayerPawn::SetEmitSoundTime)
        .addProperty("InNoDefuseArea", &GCCSPlayerPawn::GetInNoDefuseArea, &GCCSPlayerPawn::SetInNoDefuseArea)
        .addProperty("BombSiteIndex", &GCCSPlayerPawn::GetBombSiteIndex, &GCCSPlayerPawn::SetBombSiteIndex)
        .addProperty("WhichBombZone", &GCCSPlayerPawn::GetWhichBombZone, &GCCSPlayerPawn::SetWhichBombZone)
        .addProperty("InBombZoneTrigger", &GCCSPlayerPawn::GetInBombZoneTrigger, &GCCSPlayerPawn::SetInBombZoneTrigger)
        .addProperty("WasInBombZoneTrigger", &GCCSPlayerPawn::GetWasInBombZoneTrigger, &GCCSPlayerPawn::SetWasInBombZoneTrigger)
        .addProperty("ShotsFired", &GCCSPlayerPawn::GetShotsFired, &GCCSPlayerPawn::SetShotsFired)
        .addProperty("FlinchStack", &GCCSPlayerPawn::GetFlinchStack, &GCCSPlayerPawn::SetFlinchStack)
        .addProperty("VelocityModifier", &GCCSPlayerPawn::GetVelocityModifier, &GCCSPlayerPawn::SetVelocityModifier)
        .addProperty("HitHeading", &GCCSPlayerPawn::GetHitHeading, &GCCSPlayerPawn::SetHitHeading)
        .addProperty("HitBodyPart", &GCCSPlayerPawn::GetHitBodyPart, &GCCSPlayerPawn::SetHitBodyPart)
        .addProperty("TotalBulletForce", &GCCSPlayerPawn::GetTotalBulletForce, &GCCSPlayerPawn::SetTotalBulletForce)
        .addProperty("WaitForNoAttack", &GCCSPlayerPawn::GetWaitForNoAttack, &GCCSPlayerPawn::SetWaitForNoAttack)
        .addProperty("IgnoreLadderJumpTime", &GCCSPlayerPawn::GetIgnoreLadderJumpTime, &GCCSPlayerPawn::SetIgnoreLadderJumpTime)
        .addProperty("KilledByHeadshot", &GCCSPlayerPawn::GetKilledByHeadshot, &GCCSPlayerPawn::SetKilledByHeadshot)
        .addProperty("LastHitBox", &GCCSPlayerPawn::GetLastHitBox, &GCCSPlayerPawn::SetLastHitBox)
        .addProperty("LastHealth", &GCCSPlayerPawn::GetLastHealth, &GCCSPlayerPawn::SetLastHealth)
        .addProperty("Bot", &GCCSPlayerPawn::GetBot, &GCCSPlayerPawn::SetBot)
        .addProperty("BotAllowActive", &GCCSPlayerPawn::GetBotAllowActive, &GCCSPlayerPawn::SetBotAllowActive)
        .addProperty("ThirdPersonHeading", &GCCSPlayerPawn::GetThirdPersonHeading, &GCCSPlayerPawn::SetThirdPersonHeading)
        .addProperty("SlopeDropOffset", &GCCSPlayerPawn::GetSlopeDropOffset, &GCCSPlayerPawn::SetSlopeDropOffset)
        .addProperty("SlopeDropHeight", &GCCSPlayerPawn::GetSlopeDropHeight, &GCCSPlayerPawn::SetSlopeDropHeight)
        .addProperty("HeadConstraintOffset", &GCCSPlayerPawn::GetHeadConstraintOffset, &GCCSPlayerPawn::SetHeadConstraintOffset)
        .addProperty("LastPickupPriority", &GCCSPlayerPawn::GetLastPickupPriority, &GCCSPlayerPawn::SetLastPickupPriority)
        .addProperty("LastPickupPriorityTime", &GCCSPlayerPawn::GetLastPickupPriorityTime, &GCCSPlayerPawn::SetLastPickupPriorityTime)
        .addProperty("ArmorValue", &GCCSPlayerPawn::GetArmorValue, &GCCSPlayerPawn::SetArmorValue)
        .addProperty("CurrentEquipmentValue", &GCCSPlayerPawn::GetCurrentEquipmentValue, &GCCSPlayerPawn::SetCurrentEquipmentValue)
        .addProperty("RoundStartEquipmentValue", &GCCSPlayerPawn::GetRoundStartEquipmentValue, &GCCSPlayerPawn::SetRoundStartEquipmentValue)
        .addProperty("FreezetimeEndEquipmentValue", &GCCSPlayerPawn::GetFreezetimeEndEquipmentValue, &GCCSPlayerPawn::SetFreezetimeEndEquipmentValue)
        .addProperty("LastWeaponFireUsercmd", &GCCSPlayerPawn::GetLastWeaponFireUsercmd, &GCCSPlayerPawn::SetLastWeaponFireUsercmd)
        .addProperty("LastFriendlyFireDamageReductionRatio", &GCCSPlayerPawn::GetLastFriendlyFireDamageReductionRatio, &GCCSPlayerPawn::SetLastFriendlyFireDamageReductionRatio)
        .addProperty("IsSpawning", &GCCSPlayerPawn::GetIsSpawning, &GCCSPlayerPawn::SetIsSpawning)
        .addProperty("DeathFlags", &GCCSPlayerPawn::GetDeathFlags, &GCCSPlayerPawn::SetDeathFlags)
        .addProperty("HasDeathInfo", &GCCSPlayerPawn::GetHasDeathInfo, &GCCSPlayerPawn::SetHasDeathInfo)
        .addProperty("DeathInfoTime", &GCCSPlayerPawn::GetDeathInfoTime, &GCCSPlayerPawn::SetDeathInfoTime)
        .addProperty("DeathInfoOrigin", &GCCSPlayerPawn::GetDeathInfoOrigin, &GCCSPlayerPawn::SetDeathInfoOrigin)
        .addProperty("PlayerPatchEconIndices", &GCCSPlayerPawn::GetPlayerPatchEconIndices, &GCCSPlayerPawn::SetPlayerPatchEconIndices)
        .addProperty("GunGameImmunityColor", &GCCSPlayerPawn::GetGunGameImmunityColor, &GCCSPlayerPawn::SetGunGameImmunityColor)
        .addProperty("GrenadeParameterStashTime", &GCCSPlayerPawn::GetGrenadeParameterStashTime, &GCCSPlayerPawn::SetGrenadeParameterStashTime)
        .addProperty("GrenadeParametersStashed", &GCCSPlayerPawn::GetGrenadeParametersStashed, &GCCSPlayerPawn::SetGrenadeParametersStashed)
        .addProperty("StashedShootAngles", &GCCSPlayerPawn::GetStashedShootAngles, &GCCSPlayerPawn::SetStashedShootAngles)
        .addProperty("StashedGrenadeThrowPosition", &GCCSPlayerPawn::GetStashedGrenadeThrowPosition, &GCCSPlayerPawn::SetStashedGrenadeThrowPosition)
        .addProperty("StashedVelocity", &GCCSPlayerPawn::GetStashedVelocity, &GCCSPlayerPawn::SetStashedVelocity)
        .addProperty("ShootAngleHistory", &GCCSPlayerPawn::GetShootAngleHistory, &GCCSPlayerPawn::SetShootAngleHistory)
        .addProperty("ThrowPositionHistory", &GCCSPlayerPawn::GetThrowPositionHistory, &GCCSPlayerPawn::SetThrowPositionHistory)
        .addProperty("VelocityHistory", &GCCSPlayerPawn::GetVelocityHistory, &GCCSPlayerPawn::SetVelocityHistory)
        .addProperty("Parent", &GCCSPlayerPawn::GetParent, &GCCSPlayerPawn::SetParent)
        .addFunction("ToPtr", &GCCSPlayerPawn::ToPtr)
        .addFunction("IsValid", &GCCSPlayerPawn::IsValid)
        .endClass();
}
GCBumpMineProjectile::GCBumpMineProjectile(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCBumpMineProjectile::GCBumpMineProjectile(void *ptr) {
    m_ptr = ptr;
}
void* GCBumpMineProjectile::GetPtr() {
    return m_ptr;
}
std::string GCBumpMineProjectile::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCBumpMineProjectile::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseGrenade GCBumpMineProjectile::GetParent() const {
    GCBaseGrenade value(m_ptr);
    return value;
}
void GCBumpMineProjectile::SetParent(GCBaseGrenade value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCBumpMineProjectile(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCBumpMineProjectile>("CBumpMineProjectile")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCBumpMineProjectile::GetParent, &GCBumpMineProjectile::SetParent)
        .addFunction("ToPtr", &GCBumpMineProjectile::ToPtr)
        .addFunction("IsValid", &GCBumpMineProjectile::IsValid)
        .endClass();
}
GCCSPlayerController::GCCSPlayerController(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCCSPlayerController::GCCSPlayerController(void *ptr) {
    m_ptr = ptr;
}
GCCSPlayerController_InGameMoneyServices GCCSPlayerController::GetInGameMoneyServices() const {
    GCCSPlayerController_InGameMoneyServices value(*(void**)GetSchemaPtr(m_ptr, "CCSPlayerController", "m_pInGameMoneyServices"));
    return value;
}
void GCCSPlayerController::SetInGameMoneyServices(GCCSPlayerController_InGameMoneyServices value) {
    SetSchemaValue(m_ptr, "CCSPlayerController","m_pInGameMoneyServices", false, (char*)value.GetPtr());
}
GCCSPlayerController_InventoryServices GCCSPlayerController::GetInventoryServices() const {
    GCCSPlayerController_InventoryServices value(*(void**)GetSchemaPtr(m_ptr, "CCSPlayerController", "m_pInventoryServices"));
    return value;
}
void GCCSPlayerController::SetInventoryServices(GCCSPlayerController_InventoryServices value) {
    SetSchemaValue(m_ptr, "CCSPlayerController","m_pInventoryServices", false, (char*)value.GetPtr());
}
GCCSPlayerController_ActionTrackingServices GCCSPlayerController::GetActionTrackingServices() const {
    GCCSPlayerController_ActionTrackingServices value(*(void**)GetSchemaPtr(m_ptr, "CCSPlayerController", "m_pActionTrackingServices"));
    return value;
}
void GCCSPlayerController::SetActionTrackingServices(GCCSPlayerController_ActionTrackingServices value) {
    SetSchemaValue(m_ptr, "CCSPlayerController","m_pActionTrackingServices", false, (char*)value.GetPtr());
}
GCCSPlayerController_DamageServices GCCSPlayerController::GetDamageServices() const {
    GCCSPlayerController_DamageServices value(*(void**)GetSchemaPtr(m_ptr, "CCSPlayerController", "m_pDamageServices"));
    return value;
}
void GCCSPlayerController::SetDamageServices(GCCSPlayerController_DamageServices value) {
    SetSchemaValue(m_ptr, "CCSPlayerController","m_pDamageServices", false, (char*)value.GetPtr());
}
uint32_t GCCSPlayerController::GetPing() const {
    return GetSchemaValue<uint32_t>(m_ptr, "CCSPlayerController", "m_iPing");
}
void GCCSPlayerController::SetPing(uint32_t value) {
    SetSchemaValue(m_ptr, "CCSPlayerController", "m_iPing", false, value);
}
bool GCCSPlayerController::GetHasCommunicationAbuseMute() const {
    return GetSchemaValue<bool>(m_ptr, "CCSPlayerController", "m_bHasCommunicationAbuseMute");
}
void GCCSPlayerController::SetHasCommunicationAbuseMute(bool value) {
    SetSchemaValue(m_ptr, "CCSPlayerController", "m_bHasCommunicationAbuseMute", false, value);
}
std::string GCCSPlayerController::GetCrosshairCodes() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CCSPlayerController", "m_szCrosshairCodes").String();
}
void GCCSPlayerController::SetCrosshairCodes(std::string value) {
    SetSchemaValue(m_ptr, "CCSPlayerController", "m_szCrosshairCodes", false, CUtlSymbolLarge(value.c_str()));
}
uint32_t GCCSPlayerController::GetPendingTeamNum() const {
    return GetSchemaValue<uint32_t>(m_ptr, "CCSPlayerController", "m_iPendingTeamNum");
}
void GCCSPlayerController::SetPendingTeamNum(uint32_t value) {
    SetSchemaValue(m_ptr, "CCSPlayerController", "m_iPendingTeamNum", false, value);
}
float GCCSPlayerController::GetForceTeamTime() const {
    return GetSchemaValue<float>(m_ptr, "CCSPlayerController", "m_flForceTeamTime");
}
void GCCSPlayerController::SetForceTeamTime(float value) {
    SetSchemaValue(m_ptr, "CCSPlayerController", "m_flForceTeamTime", false, value);
}
int32_t GCCSPlayerController::GetCompTeammateColor() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSPlayerController", "m_iCompTeammateColor");
}
void GCCSPlayerController::SetCompTeammateColor(int32_t value) {
    SetSchemaValue(m_ptr, "CCSPlayerController", "m_iCompTeammateColor", false, value);
}
bool GCCSPlayerController::GetEverPlayedOnTeam() const {
    return GetSchemaValue<bool>(m_ptr, "CCSPlayerController", "m_bEverPlayedOnTeam");
}
void GCCSPlayerController::SetEverPlayedOnTeam(bool value) {
    SetSchemaValue(m_ptr, "CCSPlayerController", "m_bEverPlayedOnTeam", false, value);
}
bool GCCSPlayerController::GetAttemptedToGetColor() const {
    return GetSchemaValue<bool>(m_ptr, "CCSPlayerController", "m_bAttemptedToGetColor");
}
void GCCSPlayerController::SetAttemptedToGetColor(bool value) {
    SetSchemaValue(m_ptr, "CCSPlayerController", "m_bAttemptedToGetColor", false, value);
}
int32_t GCCSPlayerController::GetTeammatePreferredColor() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSPlayerController", "m_iTeammatePreferredColor");
}
void GCCSPlayerController::SetTeammatePreferredColor(int32_t value) {
    SetSchemaValue(m_ptr, "CCSPlayerController", "m_iTeammatePreferredColor", false, value);
}
bool GCCSPlayerController::GetTeamChanged() const {
    return GetSchemaValue<bool>(m_ptr, "CCSPlayerController", "m_bTeamChanged");
}
void GCCSPlayerController::SetTeamChanged(bool value) {
    SetSchemaValue(m_ptr, "CCSPlayerController", "m_bTeamChanged", false, value);
}
bool GCCSPlayerController::GetInSwitchTeam() const {
    return GetSchemaValue<bool>(m_ptr, "CCSPlayerController", "m_bInSwitchTeam");
}
void GCCSPlayerController::SetInSwitchTeam(bool value) {
    SetSchemaValue(m_ptr, "CCSPlayerController", "m_bInSwitchTeam", false, value);
}
bool GCCSPlayerController::GetHasSeenJoinGame() const {
    return GetSchemaValue<bool>(m_ptr, "CCSPlayerController", "m_bHasSeenJoinGame");
}
void GCCSPlayerController::SetHasSeenJoinGame(bool value) {
    SetSchemaValue(m_ptr, "CCSPlayerController", "m_bHasSeenJoinGame", false, value);
}
bool GCCSPlayerController::GetJustBecameSpectator() const {
    return GetSchemaValue<bool>(m_ptr, "CCSPlayerController", "m_bJustBecameSpectator");
}
void GCCSPlayerController::SetJustBecameSpectator(bool value) {
    SetSchemaValue(m_ptr, "CCSPlayerController", "m_bJustBecameSpectator", false, value);
}
bool GCCSPlayerController::GetSwitchTeamsOnNextRoundReset() const {
    return GetSchemaValue<bool>(m_ptr, "CCSPlayerController", "m_bSwitchTeamsOnNextRoundReset");
}
void GCCSPlayerController::SetSwitchTeamsOnNextRoundReset(bool value) {
    SetSchemaValue(m_ptr, "CCSPlayerController", "m_bSwitchTeamsOnNextRoundReset", false, value);
}
bool GCCSPlayerController::GetRemoveAllItemsOnNextRoundReset() const {
    return GetSchemaValue<bool>(m_ptr, "CCSPlayerController", "m_bRemoveAllItemsOnNextRoundReset");
}
void GCCSPlayerController::SetRemoveAllItemsOnNextRoundReset(bool value) {
    SetSchemaValue(m_ptr, "CCSPlayerController", "m_bRemoveAllItemsOnNextRoundReset", false, value);
}
std::string GCCSPlayerController::GetClan() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CCSPlayerController", "m_szClan").String();
}
void GCCSPlayerController::SetClan(std::string value) {
    SetSchemaValue(m_ptr, "CCSPlayerController", "m_szClan", false, CUtlSymbolLarge(value.c_str()));
}
std::string GCCSPlayerController::GetClanName() const {
    return GetSchemaValuePtr<char>(m_ptr, "CCSPlayerController", "m_szClanName");
}
void GCCSPlayerController::SetClanName(std::string value) {
    WriteSchemaPtrValue(m_ptr, "CCSPlayerController", "m_szClanName", false, reinterpret_cast<byte*>(const_cast<char*>(value.c_str())), 32);
}
int32_t GCCSPlayerController::GetCoachingTeam() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSPlayerController", "m_iCoachingTeam");
}
void GCCSPlayerController::SetCoachingTeam(int32_t value) {
    SetSchemaValue(m_ptr, "CCSPlayerController", "m_iCoachingTeam", false, value);
}
uint64_t GCCSPlayerController::GetPlayerDominated() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CCSPlayerController", "m_nPlayerDominated");
}
void GCCSPlayerController::SetPlayerDominated(uint64_t value) {
    SetSchemaValue(m_ptr, "CCSPlayerController", "m_nPlayerDominated", false, value);
}
uint64_t GCCSPlayerController::GetPlayerDominatingMe() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CCSPlayerController", "m_nPlayerDominatingMe");
}
void GCCSPlayerController::SetPlayerDominatingMe(uint64_t value) {
    SetSchemaValue(m_ptr, "CCSPlayerController", "m_nPlayerDominatingMe", false, value);
}
int32_t GCCSPlayerController::GetCompetitiveRanking() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSPlayerController", "m_iCompetitiveRanking");
}
void GCCSPlayerController::SetCompetitiveRanking(int32_t value) {
    SetSchemaValue(m_ptr, "CCSPlayerController", "m_iCompetitiveRanking", false, value);
}
int32_t GCCSPlayerController::GetCompetitiveWins() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSPlayerController", "m_iCompetitiveWins");
}
void GCCSPlayerController::SetCompetitiveWins(int32_t value) {
    SetSchemaValue(m_ptr, "CCSPlayerController", "m_iCompetitiveWins", false, value);
}
int32_t GCCSPlayerController::GetCompetitiveRankType() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSPlayerController", "m_iCompetitiveRankType");
}
void GCCSPlayerController::SetCompetitiveRankType(int32_t value) {
    SetSchemaValue(m_ptr, "CCSPlayerController", "m_iCompetitiveRankType", false, value);
}
int32_t GCCSPlayerController::GetCompetitiveRankingPredicted_Win() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSPlayerController", "m_iCompetitiveRankingPredicted_Win");
}
void GCCSPlayerController::SetCompetitiveRankingPredicted_Win(int32_t value) {
    SetSchemaValue(m_ptr, "CCSPlayerController", "m_iCompetitiveRankingPredicted_Win", false, value);
}
int32_t GCCSPlayerController::GetCompetitiveRankingPredicted_Loss() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSPlayerController", "m_iCompetitiveRankingPredicted_Loss");
}
void GCCSPlayerController::SetCompetitiveRankingPredicted_Loss(int32_t value) {
    SetSchemaValue(m_ptr, "CCSPlayerController", "m_iCompetitiveRankingPredicted_Loss", false, value);
}
int32_t GCCSPlayerController::GetCompetitiveRankingPredicted_Tie() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSPlayerController", "m_iCompetitiveRankingPredicted_Tie");
}
void GCCSPlayerController::SetCompetitiveRankingPredicted_Tie(int32_t value) {
    SetSchemaValue(m_ptr, "CCSPlayerController", "m_iCompetitiveRankingPredicted_Tie", false, value);
}
int32_t GCCSPlayerController::GetEndMatchNextMapVote() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSPlayerController", "m_nEndMatchNextMapVote");
}
void GCCSPlayerController::SetEndMatchNextMapVote(int32_t value) {
    SetSchemaValue(m_ptr, "CCSPlayerController", "m_nEndMatchNextMapVote", false, value);
}
uint16_t GCCSPlayerController::GetActiveQuestId() const {
    return GetSchemaValue<uint16_t>(m_ptr, "CCSPlayerController", "m_unActiveQuestId");
}
void GCCSPlayerController::SetActiveQuestId(uint16_t value) {
    SetSchemaValue(m_ptr, "CCSPlayerController", "m_unActiveQuestId", false, value);
}
GQuestProgress GCCSPlayerController::GetQuestProgressReason() const {
    GQuestProgress value(GetSchemaPtr(m_ptr, "CCSPlayerController", "m_nQuestProgressReason"));
    return value;
}
void GCCSPlayerController::SetQuestProgressReason(GQuestProgress value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'QuestProgressReason' is not possible.\n");
}
uint32_t GCCSPlayerController::GetPlayerTvControlFlags() const {
    return GetSchemaValue<uint32_t>(m_ptr, "CCSPlayerController", "m_unPlayerTvControlFlags");
}
void GCCSPlayerController::SetPlayerTvControlFlags(uint32_t value) {
    SetSchemaValue(m_ptr, "CCSPlayerController", "m_unPlayerTvControlFlags", false, value);
}
int32_t GCCSPlayerController::GetDraftIndex() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSPlayerController", "m_iDraftIndex");
}
void GCCSPlayerController::SetDraftIndex(int32_t value) {
    SetSchemaValue(m_ptr, "CCSPlayerController", "m_iDraftIndex", false, value);
}
uint32_t GCCSPlayerController::GetMsQueuedModeDisconnectionTimestamp() const {
    return GetSchemaValue<uint32_t>(m_ptr, "CCSPlayerController", "m_msQueuedModeDisconnectionTimestamp");
}
void GCCSPlayerController::SetMsQueuedModeDisconnectionTimestamp(uint32_t value) {
    SetSchemaValue(m_ptr, "CCSPlayerController", "m_msQueuedModeDisconnectionTimestamp", false, value);
}
uint32_t GCCSPlayerController::GetUiAbandonRecordedReason() const {
    return GetSchemaValue<uint32_t>(m_ptr, "CCSPlayerController", "m_uiAbandonRecordedReason");
}
void GCCSPlayerController::SetUiAbandonRecordedReason(uint32_t value) {
    SetSchemaValue(m_ptr, "CCSPlayerController", "m_uiAbandonRecordedReason", false, value);
}
bool GCCSPlayerController::GetCannotBeKicked() const {
    return GetSchemaValue<bool>(m_ptr, "CCSPlayerController", "m_bCannotBeKicked");
}
void GCCSPlayerController::SetCannotBeKicked(bool value) {
    SetSchemaValue(m_ptr, "CCSPlayerController", "m_bCannotBeKicked", false, value);
}
bool GCCSPlayerController::GetEverFullyConnected() const {
    return GetSchemaValue<bool>(m_ptr, "CCSPlayerController", "m_bEverFullyConnected");
}
void GCCSPlayerController::SetEverFullyConnected(bool value) {
    SetSchemaValue(m_ptr, "CCSPlayerController", "m_bEverFullyConnected", false, value);
}
bool GCCSPlayerController::GetAbandonAllowsSurrender() const {
    return GetSchemaValue<bool>(m_ptr, "CCSPlayerController", "m_bAbandonAllowsSurrender");
}
void GCCSPlayerController::SetAbandonAllowsSurrender(bool value) {
    SetSchemaValue(m_ptr, "CCSPlayerController", "m_bAbandonAllowsSurrender", false, value);
}
bool GCCSPlayerController::GetAbandonOffersInstantSurrender() const {
    return GetSchemaValue<bool>(m_ptr, "CCSPlayerController", "m_bAbandonOffersInstantSurrender");
}
void GCCSPlayerController::SetAbandonOffersInstantSurrender(bool value) {
    SetSchemaValue(m_ptr, "CCSPlayerController", "m_bAbandonOffersInstantSurrender", false, value);
}
bool GCCSPlayerController::GetDisconnection1MinWarningPrinted() const {
    return GetSchemaValue<bool>(m_ptr, "CCSPlayerController", "m_bDisconnection1MinWarningPrinted");
}
void GCCSPlayerController::SetDisconnection1MinWarningPrinted(bool value) {
    SetSchemaValue(m_ptr, "CCSPlayerController", "m_bDisconnection1MinWarningPrinted", false, value);
}
bool GCCSPlayerController::GetScoreReported() const {
    return GetSchemaValue<bool>(m_ptr, "CCSPlayerController", "m_bScoreReported");
}
void GCCSPlayerController::SetScoreReported(bool value) {
    SetSchemaValue(m_ptr, "CCSPlayerController", "m_bScoreReported", false, value);
}
int32_t GCCSPlayerController::GetDisconnectionTick() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSPlayerController", "m_nDisconnectionTick");
}
void GCCSPlayerController::SetDisconnectionTick(int32_t value) {
    SetSchemaValue(m_ptr, "CCSPlayerController", "m_nDisconnectionTick", false, value);
}
bool GCCSPlayerController::GetControllingBot() const {
    return GetSchemaValue<bool>(m_ptr, "CCSPlayerController", "m_bControllingBot");
}
void GCCSPlayerController::SetControllingBot(bool value) {
    SetSchemaValue(m_ptr, "CCSPlayerController", "m_bControllingBot", false, value);
}
bool GCCSPlayerController::GetHasControlledBotThisRound() const {
    return GetSchemaValue<bool>(m_ptr, "CCSPlayerController", "m_bHasControlledBotThisRound");
}
void GCCSPlayerController::SetHasControlledBotThisRound(bool value) {
    SetSchemaValue(m_ptr, "CCSPlayerController", "m_bHasControlledBotThisRound", false, value);
}
bool GCCSPlayerController::GetHasBeenControlledByPlayerThisRound() const {
    return GetSchemaValue<bool>(m_ptr, "CCSPlayerController", "m_bHasBeenControlledByPlayerThisRound");
}
void GCCSPlayerController::SetHasBeenControlledByPlayerThisRound(bool value) {
    SetSchemaValue(m_ptr, "CCSPlayerController", "m_bHasBeenControlledByPlayerThisRound", false, value);
}
int32_t GCCSPlayerController::GetBotsControlledThisRound() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSPlayerController", "m_nBotsControlledThisRound");
}
void GCCSPlayerController::SetBotsControlledThisRound(int32_t value) {
    SetSchemaValue(m_ptr, "CCSPlayerController", "m_nBotsControlledThisRound", false, value);
}
bool GCCSPlayerController::GetCanControlObservedBot() const {
    return GetSchemaValue<bool>(m_ptr, "CCSPlayerController", "m_bCanControlObservedBot");
}
void GCCSPlayerController::SetCanControlObservedBot(bool value) {
    SetSchemaValue(m_ptr, "CCSPlayerController", "m_bCanControlObservedBot", false, value);
}
GCCSPlayerPawn GCCSPlayerController::GetPlayerPawn() const {
    GCCSPlayerPawn value((void*)(GetSchemaValue<CHandle<CEntityInstance>>(m_ptr, "CCSPlayerController", "m_hPlayerPawn").Get()));
    return value;
}
void GCCSPlayerController::SetPlayerPawn(GCCSPlayerPawn value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'PlayerPawn' is not possible.\n");
}
GCCSObserverPawn GCCSPlayerController::GetObserverPawn() const {
    GCCSObserverPawn value((void*)(GetSchemaValue<CHandle<CEntityInstance>>(m_ptr, "CCSPlayerController", "m_hObserverPawn").Get()));
    return value;
}
void GCCSPlayerController::SetObserverPawn(GCCSObserverPawn value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'ObserverPawn' is not possible.\n");
}
int32_t GCCSPlayerController::GetDesiredObserverMode() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSPlayerController", "m_DesiredObserverMode");
}
void GCCSPlayerController::SetDesiredObserverMode(int32_t value) {
    SetSchemaValue(m_ptr, "CCSPlayerController", "m_DesiredObserverMode", false, value);
}
GCEntityInstance GCCSPlayerController::GetDesiredObserverTarget() const {
    GCEntityInstance value((void*)(GetSchemaValue<CHandle<CEntityInstance>>(m_ptr, "CCSPlayerController", "m_hDesiredObserverTarget").Get()));
    return value;
}
void GCCSPlayerController::SetDesiredObserverTarget(GCEntityInstance value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'DesiredObserverTarget' is not possible.\n");
}
bool GCCSPlayerController::GetPawnIsAlive() const {
    return GetSchemaValue<bool>(m_ptr, "CCSPlayerController", "m_bPawnIsAlive");
}
void GCCSPlayerController::SetPawnIsAlive(bool value) {
    SetSchemaValue(m_ptr, "CCSPlayerController", "m_bPawnIsAlive", false, value);
}
uint32_t GCCSPlayerController::GetPawnHealth() const {
    return GetSchemaValue<uint32_t>(m_ptr, "CCSPlayerController", "m_iPawnHealth");
}
void GCCSPlayerController::SetPawnHealth(uint32_t value) {
    SetSchemaValue(m_ptr, "CCSPlayerController", "m_iPawnHealth", false, value);
}
int32_t GCCSPlayerController::GetPawnArmor() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSPlayerController", "m_iPawnArmor");
}
void GCCSPlayerController::SetPawnArmor(int32_t value) {
    SetSchemaValue(m_ptr, "CCSPlayerController", "m_iPawnArmor", false, value);
}
bool GCCSPlayerController::GetPawnHasDefuser() const {
    return GetSchemaValue<bool>(m_ptr, "CCSPlayerController", "m_bPawnHasDefuser");
}
void GCCSPlayerController::SetPawnHasDefuser(bool value) {
    SetSchemaValue(m_ptr, "CCSPlayerController", "m_bPawnHasDefuser", false, value);
}
bool GCCSPlayerController::GetPawnHasHelmet() const {
    return GetSchemaValue<bool>(m_ptr, "CCSPlayerController", "m_bPawnHasHelmet");
}
void GCCSPlayerController::SetPawnHasHelmet(bool value) {
    SetSchemaValue(m_ptr, "CCSPlayerController", "m_bPawnHasHelmet", false, value);
}
uint16_t GCCSPlayerController::GetPawnCharacterDefIndex() const {
    return GetSchemaValue<uint16_t>(m_ptr, "CCSPlayerController", "m_nPawnCharacterDefIndex");
}
void GCCSPlayerController::SetPawnCharacterDefIndex(uint16_t value) {
    SetSchemaValue(m_ptr, "CCSPlayerController", "m_nPawnCharacterDefIndex", false, value);
}
int32_t GCCSPlayerController::GetPawnLifetimeStart() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSPlayerController", "m_iPawnLifetimeStart");
}
void GCCSPlayerController::SetPawnLifetimeStart(int32_t value) {
    SetSchemaValue(m_ptr, "CCSPlayerController", "m_iPawnLifetimeStart", false, value);
}
int32_t GCCSPlayerController::GetPawnLifetimeEnd() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSPlayerController", "m_iPawnLifetimeEnd");
}
void GCCSPlayerController::SetPawnLifetimeEnd(int32_t value) {
    SetSchemaValue(m_ptr, "CCSPlayerController", "m_iPawnLifetimeEnd", false, value);
}
int32_t GCCSPlayerController::GetPawnBotDifficulty() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSPlayerController", "m_iPawnBotDifficulty");
}
void GCCSPlayerController::SetPawnBotDifficulty(int32_t value) {
    SetSchemaValue(m_ptr, "CCSPlayerController", "m_iPawnBotDifficulty", false, value);
}
GCCSPlayerController GCCSPlayerController::GetOriginalControllerOfCurrentPawn() const {
    GCCSPlayerController value((void*)(GetSchemaValue<CHandle<CEntityInstance>>(m_ptr, "CCSPlayerController", "m_hOriginalControllerOfCurrentPawn").Get()));
    return value;
}
void GCCSPlayerController::SetOriginalControllerOfCurrentPawn(GCCSPlayerController value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'OriginalControllerOfCurrentPawn' is not possible.\n");
}
int32_t GCCSPlayerController::GetScore() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSPlayerController", "m_iScore");
}
void GCCSPlayerController::SetScore(int32_t value) {
    SetSchemaValue(m_ptr, "CCSPlayerController", "m_iScore", false, value);
}
int32_t GCCSPlayerController::GetRoundScore() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSPlayerController", "m_iRoundScore");
}
void GCCSPlayerController::SetRoundScore(int32_t value) {
    SetSchemaValue(m_ptr, "CCSPlayerController", "m_iRoundScore", false, value);
}
int32_t GCCSPlayerController::GetRoundsWon() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSPlayerController", "m_iRoundsWon");
}
void GCCSPlayerController::SetRoundsWon(int32_t value) {
    SetSchemaValue(m_ptr, "CCSPlayerController", "m_iRoundsWon", false, value);
}
std::vector<EKillTypes_t> GCCSPlayerController::GetKills() const {
    CUtlVector<EKillTypes_t>* vec = GetSchemaValue<CUtlVector<EKillTypes_t>*>(m_ptr, "CCSPlayerController", "m_vecKills"); std::vector<EKillTypes_t> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCCSPlayerController::SetKills(std::vector<EKillTypes_t> value) {
    SetSchemaValueCUtlVector<EKillTypes_t>(m_ptr, "CCSPlayerController", "m_vecKills", false, value);
}
bool GCCSPlayerController::GetMvpNoMusic() const {
    return GetSchemaValue<bool>(m_ptr, "CCSPlayerController", "m_bMvpNoMusic");
}
void GCCSPlayerController::SetMvpNoMusic(bool value) {
    SetSchemaValue(m_ptr, "CCSPlayerController", "m_bMvpNoMusic", false, value);
}
int32_t GCCSPlayerController::GetMvpReason() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSPlayerController", "m_eMvpReason");
}
void GCCSPlayerController::SetMvpReason(int32_t value) {
    SetSchemaValue(m_ptr, "CCSPlayerController", "m_eMvpReason", false, value);
}
int32_t GCCSPlayerController::GetMusicKitID() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSPlayerController", "m_iMusicKitID");
}
void GCCSPlayerController::SetMusicKitID(int32_t value) {
    SetSchemaValue(m_ptr, "CCSPlayerController", "m_iMusicKitID", false, value);
}
int32_t GCCSPlayerController::GetMusicKitMVPs() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSPlayerController", "m_iMusicKitMVPs");
}
void GCCSPlayerController::SetMusicKitMVPs(int32_t value) {
    SetSchemaValue(m_ptr, "CCSPlayerController", "m_iMusicKitMVPs", false, value);
}
int32_t GCCSPlayerController::GetMVPs() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSPlayerController", "m_iMVPs");
}
void GCCSPlayerController::SetMVPs(int32_t value) {
    SetSchemaValue(m_ptr, "CCSPlayerController", "m_iMVPs", false, value);
}
int32_t GCCSPlayerController::GetUpdateCounter() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSPlayerController", "m_nUpdateCounter");
}
void GCCSPlayerController::SetUpdateCounter(int32_t value) {
    SetSchemaValue(m_ptr, "CCSPlayerController", "m_nUpdateCounter", false, value);
}
float GCCSPlayerController::GetSmoothedPing() const {
    return GetSchemaValue<float>(m_ptr, "CCSPlayerController", "m_flSmoothedPing");
}
void GCCSPlayerController::SetSmoothedPing(float value) {
    SetSchemaValue(m_ptr, "CCSPlayerController", "m_flSmoothedPing", false, value);
}
GIntervalTimer GCCSPlayerController::GetLastHeldVoteTimer() const {
    GIntervalTimer value(GetSchemaPtr(m_ptr, "CCSPlayerController", "m_lastHeldVoteTimer"));
    return value;
}
void GCCSPlayerController::SetLastHeldVoteTimer(GIntervalTimer value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'LastHeldVoteTimer' is not possible.\n");
}
bool GCCSPlayerController::GetShowHints() const {
    return GetSchemaValue<bool>(m_ptr, "CCSPlayerController", "m_bShowHints");
}
void GCCSPlayerController::SetShowHints(bool value) {
    SetSchemaValue(m_ptr, "CCSPlayerController", "m_bShowHints", false, value);
}
int32_t GCCSPlayerController::GetNextTimeCheck() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSPlayerController", "m_iNextTimeCheck");
}
void GCCSPlayerController::SetNextTimeCheck(int32_t value) {
    SetSchemaValue(m_ptr, "CCSPlayerController", "m_iNextTimeCheck", false, value);
}
bool GCCSPlayerController::GetJustDidTeamKill() const {
    return GetSchemaValue<bool>(m_ptr, "CCSPlayerController", "m_bJustDidTeamKill");
}
void GCCSPlayerController::SetJustDidTeamKill(bool value) {
    SetSchemaValue(m_ptr, "CCSPlayerController", "m_bJustDidTeamKill", false, value);
}
bool GCCSPlayerController::GetPunishForTeamKill() const {
    return GetSchemaValue<bool>(m_ptr, "CCSPlayerController", "m_bPunishForTeamKill");
}
void GCCSPlayerController::SetPunishForTeamKill(bool value) {
    SetSchemaValue(m_ptr, "CCSPlayerController", "m_bPunishForTeamKill", false, value);
}
bool GCCSPlayerController::GetGaveTeamDamageWarning() const {
    return GetSchemaValue<bool>(m_ptr, "CCSPlayerController", "m_bGaveTeamDamageWarning");
}
void GCCSPlayerController::SetGaveTeamDamageWarning(bool value) {
    SetSchemaValue(m_ptr, "CCSPlayerController", "m_bGaveTeamDamageWarning", false, value);
}
bool GCCSPlayerController::GetGaveTeamDamageWarningThisRound() const {
    return GetSchemaValue<bool>(m_ptr, "CCSPlayerController", "m_bGaveTeamDamageWarningThisRound");
}
void GCCSPlayerController::SetGaveTeamDamageWarningThisRound(bool value) {
    SetSchemaValue(m_ptr, "CCSPlayerController", "m_bGaveTeamDamageWarningThisRound", false, value);
}
double GCCSPlayerController::GetDblLastReceivedPacketPlatFloatTime() const {
    return GetSchemaValue<double>(m_ptr, "CCSPlayerController", "m_dblLastReceivedPacketPlatFloatTime");
}
void GCCSPlayerController::SetDblLastReceivedPacketPlatFloatTime(double value) {
    SetSchemaValue(m_ptr, "CCSPlayerController", "m_dblLastReceivedPacketPlatFloatTime", false, value);
}
float GCCSPlayerController::GetLastTeamDamageWarningTime() const {
    return GetSchemaValue<float>(m_ptr, "CCSPlayerController", "m_LastTeamDamageWarningTime");
}
void GCCSPlayerController::SetLastTeamDamageWarningTime(float value) {
    SetSchemaValue(m_ptr, "CCSPlayerController", "m_LastTeamDamageWarningTime", false, value);
}
float GCCSPlayerController::GetLastTimePlayerWasDisconnectedForPawnsRemove() const {
    return GetSchemaValue<float>(m_ptr, "CCSPlayerController", "m_LastTimePlayerWasDisconnectedForPawnsRemove");
}
void GCCSPlayerController::SetLastTimePlayerWasDisconnectedForPawnsRemove(float value) {
    SetSchemaValue(m_ptr, "CCSPlayerController", "m_LastTimePlayerWasDisconnectedForPawnsRemove", false, value);
}
uint32_t GCCSPlayerController::GetSuspiciousHitCount() const {
    return GetSchemaValue<uint32_t>(m_ptr, "CCSPlayerController", "m_nSuspiciousHitCount");
}
void GCCSPlayerController::SetSuspiciousHitCount(uint32_t value) {
    SetSchemaValue(m_ptr, "CCSPlayerController", "m_nSuspiciousHitCount", false, value);
}
uint32_t GCCSPlayerController::GetNonSuspiciousHitStreak() const {
    return GetSchemaValue<uint32_t>(m_ptr, "CCSPlayerController", "m_nNonSuspiciousHitStreak");
}
void GCCSPlayerController::SetNonSuspiciousHitStreak(uint32_t value) {
    SetSchemaValue(m_ptr, "CCSPlayerController", "m_nNonSuspiciousHitStreak", false, value);
}
void* GCCSPlayerController::GetPtr() {
    return m_ptr;
}
std::string GCCSPlayerController::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCCSPlayerController::IsValid() {
    return (m_ptr != nullptr);
}
GCBasePlayerController GCCSPlayerController::GetParent() const {
    GCBasePlayerController value(m_ptr);
    return value;
}
void GCCSPlayerController::SetParent(GCBasePlayerController value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCCSPlayerController(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCCSPlayerController>("CCSPlayerController")
        .addConstructor<void (*)(std::string)>()
        .addProperty("InGameMoneyServices", &GCCSPlayerController::GetInGameMoneyServices, &GCCSPlayerController::SetInGameMoneyServices)
        .addProperty("InventoryServices", &GCCSPlayerController::GetInventoryServices, &GCCSPlayerController::SetInventoryServices)
        .addProperty("ActionTrackingServices", &GCCSPlayerController::GetActionTrackingServices, &GCCSPlayerController::SetActionTrackingServices)
        .addProperty("DamageServices", &GCCSPlayerController::GetDamageServices, &GCCSPlayerController::SetDamageServices)
        .addProperty("Ping", &GCCSPlayerController::GetPing, &GCCSPlayerController::SetPing)
        .addProperty("HasCommunicationAbuseMute", &GCCSPlayerController::GetHasCommunicationAbuseMute, &GCCSPlayerController::SetHasCommunicationAbuseMute)
        .addProperty("CrosshairCodes", &GCCSPlayerController::GetCrosshairCodes, &GCCSPlayerController::SetCrosshairCodes)
        .addProperty("PendingTeamNum", &GCCSPlayerController::GetPendingTeamNum, &GCCSPlayerController::SetPendingTeamNum)
        .addProperty("ForceTeamTime", &GCCSPlayerController::GetForceTeamTime, &GCCSPlayerController::SetForceTeamTime)
        .addProperty("CompTeammateColor", &GCCSPlayerController::GetCompTeammateColor, &GCCSPlayerController::SetCompTeammateColor)
        .addProperty("EverPlayedOnTeam", &GCCSPlayerController::GetEverPlayedOnTeam, &GCCSPlayerController::SetEverPlayedOnTeam)
        .addProperty("AttemptedToGetColor", &GCCSPlayerController::GetAttemptedToGetColor, &GCCSPlayerController::SetAttemptedToGetColor)
        .addProperty("TeammatePreferredColor", &GCCSPlayerController::GetTeammatePreferredColor, &GCCSPlayerController::SetTeammatePreferredColor)
        .addProperty("TeamChanged", &GCCSPlayerController::GetTeamChanged, &GCCSPlayerController::SetTeamChanged)
        .addProperty("InSwitchTeam", &GCCSPlayerController::GetInSwitchTeam, &GCCSPlayerController::SetInSwitchTeam)
        .addProperty("HasSeenJoinGame", &GCCSPlayerController::GetHasSeenJoinGame, &GCCSPlayerController::SetHasSeenJoinGame)
        .addProperty("JustBecameSpectator", &GCCSPlayerController::GetJustBecameSpectator, &GCCSPlayerController::SetJustBecameSpectator)
        .addProperty("SwitchTeamsOnNextRoundReset", &GCCSPlayerController::GetSwitchTeamsOnNextRoundReset, &GCCSPlayerController::SetSwitchTeamsOnNextRoundReset)
        .addProperty("RemoveAllItemsOnNextRoundReset", &GCCSPlayerController::GetRemoveAllItemsOnNextRoundReset, &GCCSPlayerController::SetRemoveAllItemsOnNextRoundReset)
        .addProperty("Clan", &GCCSPlayerController::GetClan, &GCCSPlayerController::SetClan)
        .addProperty("ClanName", &GCCSPlayerController::GetClanName, &GCCSPlayerController::SetClanName)
        .addProperty("CoachingTeam", &GCCSPlayerController::GetCoachingTeam, &GCCSPlayerController::SetCoachingTeam)
        .addProperty("PlayerDominated", &GCCSPlayerController::GetPlayerDominated, &GCCSPlayerController::SetPlayerDominated)
        .addProperty("PlayerDominatingMe", &GCCSPlayerController::GetPlayerDominatingMe, &GCCSPlayerController::SetPlayerDominatingMe)
        .addProperty("CompetitiveRanking", &GCCSPlayerController::GetCompetitiveRanking, &GCCSPlayerController::SetCompetitiveRanking)
        .addProperty("CompetitiveWins", &GCCSPlayerController::GetCompetitiveWins, &GCCSPlayerController::SetCompetitiveWins)
        .addProperty("CompetitiveRankType", &GCCSPlayerController::GetCompetitiveRankType, &GCCSPlayerController::SetCompetitiveRankType)
        .addProperty("CompetitiveRankingPredicted_Win", &GCCSPlayerController::GetCompetitiveRankingPredicted_Win, &GCCSPlayerController::SetCompetitiveRankingPredicted_Win)
        .addProperty("CompetitiveRankingPredicted_Loss", &GCCSPlayerController::GetCompetitiveRankingPredicted_Loss, &GCCSPlayerController::SetCompetitiveRankingPredicted_Loss)
        .addProperty("CompetitiveRankingPredicted_Tie", &GCCSPlayerController::GetCompetitiveRankingPredicted_Tie, &GCCSPlayerController::SetCompetitiveRankingPredicted_Tie)
        .addProperty("EndMatchNextMapVote", &GCCSPlayerController::GetEndMatchNextMapVote, &GCCSPlayerController::SetEndMatchNextMapVote)
        .addProperty("ActiveQuestId", &GCCSPlayerController::GetActiveQuestId, &GCCSPlayerController::SetActiveQuestId)
        .addProperty("QuestProgressReason", &GCCSPlayerController::GetQuestProgressReason, &GCCSPlayerController::SetQuestProgressReason)
        .addProperty("PlayerTvControlFlags", &GCCSPlayerController::GetPlayerTvControlFlags, &GCCSPlayerController::SetPlayerTvControlFlags)
        .addProperty("DraftIndex", &GCCSPlayerController::GetDraftIndex, &GCCSPlayerController::SetDraftIndex)
        .addProperty("MsQueuedModeDisconnectionTimestamp", &GCCSPlayerController::GetMsQueuedModeDisconnectionTimestamp, &GCCSPlayerController::SetMsQueuedModeDisconnectionTimestamp)
        .addProperty("UiAbandonRecordedReason", &GCCSPlayerController::GetUiAbandonRecordedReason, &GCCSPlayerController::SetUiAbandonRecordedReason)
        .addProperty("CannotBeKicked", &GCCSPlayerController::GetCannotBeKicked, &GCCSPlayerController::SetCannotBeKicked)
        .addProperty("EverFullyConnected", &GCCSPlayerController::GetEverFullyConnected, &GCCSPlayerController::SetEverFullyConnected)
        .addProperty("AbandonAllowsSurrender", &GCCSPlayerController::GetAbandonAllowsSurrender, &GCCSPlayerController::SetAbandonAllowsSurrender)
        .addProperty("AbandonOffersInstantSurrender", &GCCSPlayerController::GetAbandonOffersInstantSurrender, &GCCSPlayerController::SetAbandonOffersInstantSurrender)
        .addProperty("Disconnection1MinWarningPrinted", &GCCSPlayerController::GetDisconnection1MinWarningPrinted, &GCCSPlayerController::SetDisconnection1MinWarningPrinted)
        .addProperty("ScoreReported", &GCCSPlayerController::GetScoreReported, &GCCSPlayerController::SetScoreReported)
        .addProperty("DisconnectionTick", &GCCSPlayerController::GetDisconnectionTick, &GCCSPlayerController::SetDisconnectionTick)
        .addProperty("ControllingBot", &GCCSPlayerController::GetControllingBot, &GCCSPlayerController::SetControllingBot)
        .addProperty("HasControlledBotThisRound", &GCCSPlayerController::GetHasControlledBotThisRound, &GCCSPlayerController::SetHasControlledBotThisRound)
        .addProperty("HasBeenControlledByPlayerThisRound", &GCCSPlayerController::GetHasBeenControlledByPlayerThisRound, &GCCSPlayerController::SetHasBeenControlledByPlayerThisRound)
        .addProperty("BotsControlledThisRound", &GCCSPlayerController::GetBotsControlledThisRound, &GCCSPlayerController::SetBotsControlledThisRound)
        .addProperty("CanControlObservedBot", &GCCSPlayerController::GetCanControlObservedBot, &GCCSPlayerController::SetCanControlObservedBot)
        .addProperty("PlayerPawn", &GCCSPlayerController::GetPlayerPawn, &GCCSPlayerController::SetPlayerPawn)
        .addProperty("ObserverPawn", &GCCSPlayerController::GetObserverPawn, &GCCSPlayerController::SetObserverPawn)
        .addProperty("DesiredObserverMode", &GCCSPlayerController::GetDesiredObserverMode, &GCCSPlayerController::SetDesiredObserverMode)
        .addProperty("DesiredObserverTarget", &GCCSPlayerController::GetDesiredObserverTarget, &GCCSPlayerController::SetDesiredObserverTarget)
        .addProperty("PawnIsAlive", &GCCSPlayerController::GetPawnIsAlive, &GCCSPlayerController::SetPawnIsAlive)
        .addProperty("PawnHealth", &GCCSPlayerController::GetPawnHealth, &GCCSPlayerController::SetPawnHealth)
        .addProperty("PawnArmor", &GCCSPlayerController::GetPawnArmor, &GCCSPlayerController::SetPawnArmor)
        .addProperty("PawnHasDefuser", &GCCSPlayerController::GetPawnHasDefuser, &GCCSPlayerController::SetPawnHasDefuser)
        .addProperty("PawnHasHelmet", &GCCSPlayerController::GetPawnHasHelmet, &GCCSPlayerController::SetPawnHasHelmet)
        .addProperty("PawnCharacterDefIndex", &GCCSPlayerController::GetPawnCharacterDefIndex, &GCCSPlayerController::SetPawnCharacterDefIndex)
        .addProperty("PawnLifetimeStart", &GCCSPlayerController::GetPawnLifetimeStart, &GCCSPlayerController::SetPawnLifetimeStart)
        .addProperty("PawnLifetimeEnd", &GCCSPlayerController::GetPawnLifetimeEnd, &GCCSPlayerController::SetPawnLifetimeEnd)
        .addProperty("PawnBotDifficulty", &GCCSPlayerController::GetPawnBotDifficulty, &GCCSPlayerController::SetPawnBotDifficulty)
        .addProperty("OriginalControllerOfCurrentPawn", &GCCSPlayerController::GetOriginalControllerOfCurrentPawn, &GCCSPlayerController::SetOriginalControllerOfCurrentPawn)
        .addProperty("Score", &GCCSPlayerController::GetScore, &GCCSPlayerController::SetScore)
        .addProperty("RoundScore", &GCCSPlayerController::GetRoundScore, &GCCSPlayerController::SetRoundScore)
        .addProperty("RoundsWon", &GCCSPlayerController::GetRoundsWon, &GCCSPlayerController::SetRoundsWon)
        .addProperty("Kills", &GCCSPlayerController::GetKills, &GCCSPlayerController::SetKills)
        .addProperty("MvpNoMusic", &GCCSPlayerController::GetMvpNoMusic, &GCCSPlayerController::SetMvpNoMusic)
        .addProperty("MvpReason", &GCCSPlayerController::GetMvpReason, &GCCSPlayerController::SetMvpReason)
        .addProperty("MusicKitID", &GCCSPlayerController::GetMusicKitID, &GCCSPlayerController::SetMusicKitID)
        .addProperty("MusicKitMVPs", &GCCSPlayerController::GetMusicKitMVPs, &GCCSPlayerController::SetMusicKitMVPs)
        .addProperty("MVPs", &GCCSPlayerController::GetMVPs, &GCCSPlayerController::SetMVPs)
        .addProperty("UpdateCounter", &GCCSPlayerController::GetUpdateCounter, &GCCSPlayerController::SetUpdateCounter)
        .addProperty("SmoothedPing", &GCCSPlayerController::GetSmoothedPing, &GCCSPlayerController::SetSmoothedPing)
        .addProperty("LastHeldVoteTimer", &GCCSPlayerController::GetLastHeldVoteTimer, &GCCSPlayerController::SetLastHeldVoteTimer)
        .addProperty("ShowHints", &GCCSPlayerController::GetShowHints, &GCCSPlayerController::SetShowHints)
        .addProperty("NextTimeCheck", &GCCSPlayerController::GetNextTimeCheck, &GCCSPlayerController::SetNextTimeCheck)
        .addProperty("JustDidTeamKill", &GCCSPlayerController::GetJustDidTeamKill, &GCCSPlayerController::SetJustDidTeamKill)
        .addProperty("PunishForTeamKill", &GCCSPlayerController::GetPunishForTeamKill, &GCCSPlayerController::SetPunishForTeamKill)
        .addProperty("GaveTeamDamageWarning", &GCCSPlayerController::GetGaveTeamDamageWarning, &GCCSPlayerController::SetGaveTeamDamageWarning)
        .addProperty("GaveTeamDamageWarningThisRound", &GCCSPlayerController::GetGaveTeamDamageWarningThisRound, &GCCSPlayerController::SetGaveTeamDamageWarningThisRound)
        .addProperty("DblLastReceivedPacketPlatFloatTime", &GCCSPlayerController::GetDblLastReceivedPacketPlatFloatTime, &GCCSPlayerController::SetDblLastReceivedPacketPlatFloatTime)
        .addProperty("LastTeamDamageWarningTime", &GCCSPlayerController::GetLastTeamDamageWarningTime, &GCCSPlayerController::SetLastTeamDamageWarningTime)
        .addProperty("LastTimePlayerWasDisconnectedForPawnsRemove", &GCCSPlayerController::GetLastTimePlayerWasDisconnectedForPawnsRemove, &GCCSPlayerController::SetLastTimePlayerWasDisconnectedForPawnsRemove)
        .addProperty("SuspiciousHitCount", &GCCSPlayerController::GetSuspiciousHitCount, &GCCSPlayerController::SetSuspiciousHitCount)
        .addProperty("NonSuspiciousHitStreak", &GCCSPlayerController::GetNonSuspiciousHitStreak, &GCCSPlayerController::SetNonSuspiciousHitStreak)
        .addProperty("Parent", &GCCSPlayerController::GetParent, &GCCSPlayerController::SetParent)
        .addFunction("ToPtr", &GCCSPlayerController::ToPtr)
        .addFunction("IsValid", &GCCSPlayerController::IsValid)
        .endClass();
}
GCChicken::GCChicken(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCChicken::GCChicken(void *ptr) {
    m_ptr = ptr;
}
GCAttributeContainer GCChicken::GetAttributeManager() const {
    GCAttributeContainer value(GetSchemaPtr(m_ptr, "CChicken", "m_AttributeManager"));
    return value;
}
void GCChicken::SetAttributeManager(GCAttributeContainer value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'AttributeManager' is not possible.\n");
}
uint32_t GCChicken::GetActivityFinishedTag() const {
    return GetSchemaValue<CUtlStringToken>(m_ptr, "CChicken", "m_sActivityFinishedTag").m_nHashCode;
}
void GCChicken::SetActivityFinishedTag(uint32_t value) {
    SetSchemaValue(m_ptr, "CChicken", "m_sActivityFinishedTag", false, CUtlStringToken(value));
}
GCountdownTimer GCChicken::GetUpdateTimer() const {
    GCountdownTimer value(GetSchemaPtr(m_ptr, "CChicken", "m_updateTimer"));
    return value;
}
void GCChicken::SetUpdateTimer(GCountdownTimer value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'UpdateTimer' is not possible.\n");
}
Vector GCChicken::GetStuckAnchor() const {
    return GetSchemaValue<Vector>(m_ptr, "CChicken", "m_stuckAnchor");
}
void GCChicken::SetStuckAnchor(Vector value) {
    SetSchemaValue(m_ptr, "CChicken", "m_stuckAnchor", false, value);
}
GCountdownTimer GCChicken::GetStuckTimer() const {
    GCountdownTimer value(GetSchemaPtr(m_ptr, "CChicken", "m_stuckTimer"));
    return value;
}
void GCChicken::SetStuckTimer(GCountdownTimer value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'StuckTimer' is not possible.\n");
}
GCountdownTimer GCChicken::GetCollisionStuckTimer() const {
    GCountdownTimer value(GetSchemaPtr(m_ptr, "CChicken", "m_collisionStuckTimer"));
    return value;
}
void GCChicken::SetCollisionStuckTimer(GCountdownTimer value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'CollisionStuckTimer' is not possible.\n");
}
bool GCChicken::GetIsOnGround() const {
    return GetSchemaValue<bool>(m_ptr, "CChicken", "m_isOnGround");
}
void GCChicken::SetIsOnGround(bool value) {
    SetSchemaValue(m_ptr, "CChicken", "m_isOnGround", false, value);
}
Vector GCChicken::GetFallVelocity() const {
    return GetSchemaValue<Vector>(m_ptr, "CChicken", "m_vFallVelocity");
}
void GCChicken::SetFallVelocity(Vector value) {
    SetSchemaValue(m_ptr, "CChicken", "m_vFallVelocity", false, value);
}
uint64_t GCChicken::GetDesiredActivity() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CChicken", "m_desiredActivity");
}
void GCChicken::SetDesiredActivity(uint64_t value) {
    SetSchemaValue(m_ptr, "CChicken", "m_desiredActivity", false, value);
}
uint64_t GCChicken::GetCurrentActivity() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CChicken", "m_currentActivity");
}
void GCChicken::SetCurrentActivity(uint64_t value) {
    SetSchemaValue(m_ptr, "CChicken", "m_currentActivity", false, value);
}
GCountdownTimer GCChicken::GetActivityTimer() const {
    GCountdownTimer value(GetSchemaPtr(m_ptr, "CChicken", "m_activityTimer"));
    return value;
}
void GCChicken::SetActivityTimer(GCountdownTimer value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'ActivityTimer' is not possible.\n");
}
float GCChicken::GetTurnRate() const {
    return GetSchemaValue<float>(m_ptr, "CChicken", "m_turnRate");
}
void GCChicken::SetTurnRate(float value) {
    SetSchemaValue(m_ptr, "CChicken", "m_turnRate", false, value);
}
GCBaseEntity GCChicken::GetFleeFrom() const {
    GCBaseEntity value((void*)(GetSchemaValue<CHandle<CEntityInstance>>(m_ptr, "CChicken", "m_fleeFrom").Get()));
    return value;
}
void GCChicken::SetFleeFrom(GCBaseEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'FleeFrom' is not possible.\n");
}
GCountdownTimer GCChicken::GetMoveRateThrottleTimer() const {
    GCountdownTimer value(GetSchemaPtr(m_ptr, "CChicken", "m_moveRateThrottleTimer"));
    return value;
}
void GCChicken::SetMoveRateThrottleTimer(GCountdownTimer value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'MoveRateThrottleTimer' is not possible.\n");
}
GCountdownTimer GCChicken::GetStartleTimer() const {
    GCountdownTimer value(GetSchemaPtr(m_ptr, "CChicken", "m_startleTimer"));
    return value;
}
void GCChicken::SetStartleTimer(GCountdownTimer value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'StartleTimer' is not possible.\n");
}
GCountdownTimer GCChicken::GetVocalizeTimer() const {
    GCountdownTimer value(GetSchemaPtr(m_ptr, "CChicken", "m_vocalizeTimer"));
    return value;
}
void GCChicken::SetVocalizeTimer(GCountdownTimer value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'VocalizeTimer' is not possible.\n");
}
float GCChicken::GetWhenZombified() const {
    return GetSchemaValue<float>(m_ptr, "CChicken", "m_flWhenZombified");
}
void GCChicken::SetWhenZombified(float value) {
    SetSchemaValue(m_ptr, "CChicken", "m_flWhenZombified", false, value);
}
bool GCChicken::GetJumpedThisFrame() const {
    return GetSchemaValue<bool>(m_ptr, "CChicken", "m_jumpedThisFrame");
}
void GCChicken::SetJumpedThisFrame(bool value) {
    SetSchemaValue(m_ptr, "CChicken", "m_jumpedThisFrame", false, value);
}
GCCSPlayerPawn GCChicken::GetLeader() const {
    GCCSPlayerPawn value((void*)(GetSchemaValue<CHandle<CEntityInstance>>(m_ptr, "CChicken", "m_leader").Get()));
    return value;
}
void GCChicken::SetLeader(GCCSPlayerPawn value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Leader' is not possible.\n");
}
GCountdownTimer GCChicken::GetReuseTimer() const {
    GCountdownTimer value(GetSchemaPtr(m_ptr, "CChicken", "m_reuseTimer"));
    return value;
}
void GCChicken::SetReuseTimer(GCountdownTimer value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'ReuseTimer' is not possible.\n");
}
bool GCChicken::GetHasBeenUsed() const {
    return GetSchemaValue<bool>(m_ptr, "CChicken", "m_hasBeenUsed");
}
void GCChicken::SetHasBeenUsed(bool value) {
    SetSchemaValue(m_ptr, "CChicken", "m_hasBeenUsed", false, value);
}
GCountdownTimer GCChicken::GetJumpTimer() const {
    GCountdownTimer value(GetSchemaPtr(m_ptr, "CChicken", "m_jumpTimer"));
    return value;
}
void GCChicken::SetJumpTimer(GCountdownTimer value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'JumpTimer' is not possible.\n");
}
float GCChicken::GetLastJumpTime() const {
    return GetSchemaValue<float>(m_ptr, "CChicken", "m_flLastJumpTime");
}
void GCChicken::SetLastJumpTime(float value) {
    SetSchemaValue(m_ptr, "CChicken", "m_flLastJumpTime", false, value);
}
bool GCChicken::GetInJump() const {
    return GetSchemaValue<bool>(m_ptr, "CChicken", "m_bInJump");
}
void GCChicken::SetInJump(bool value) {
    SetSchemaValue(m_ptr, "CChicken", "m_bInJump", false, value);
}
bool GCChicken::GetIsWaitingForLeader() const {
    return GetSchemaValue<bool>(m_ptr, "CChicken", "m_isWaitingForLeader");
}
void GCChicken::SetIsWaitingForLeader(bool value) {
    SetSchemaValue(m_ptr, "CChicken", "m_isWaitingForLeader", false, value);
}
GCountdownTimer GCChicken::GetRepathTimer() const {
    GCountdownTimer value(GetSchemaPtr(m_ptr, "CChicken", "m_repathTimer"));
    return value;
}
void GCChicken::SetRepathTimer(GCountdownTimer value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'RepathTimer' is not possible.\n");
}
GCountdownTimer GCChicken::GetInhibitDoorTimer() const {
    GCountdownTimer value(GetSchemaPtr(m_ptr, "CChicken", "m_inhibitDoorTimer"));
    return value;
}
void GCChicken::SetInhibitDoorTimer(GCountdownTimer value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'InhibitDoorTimer' is not possible.\n");
}
GCountdownTimer GCChicken::GetInhibitObstacleAvoidanceTimer() const {
    GCountdownTimer value(GetSchemaPtr(m_ptr, "CChicken", "m_inhibitObstacleAvoidanceTimer"));
    return value;
}
void GCChicken::SetInhibitObstacleAvoidanceTimer(GCountdownTimer value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'InhibitObstacleAvoidanceTimer' is not possible.\n");
}
Vector GCChicken::GetPathGoal() const {
    return GetSchemaValue<Vector>(m_ptr, "CChicken", "m_vecPathGoal");
}
void GCChicken::SetPathGoal(Vector value) {
    SetSchemaValue(m_ptr, "CChicken", "m_vecPathGoal", false, value);
}
float GCChicken::GetActiveFollowStartTime() const {
    return GetSchemaValue<float>(m_ptr, "CChicken", "m_flActiveFollowStartTime");
}
void GCChicken::SetActiveFollowStartTime(float value) {
    SetSchemaValue(m_ptr, "CChicken", "m_flActiveFollowStartTime", false, value);
}
GCountdownTimer GCChicken::GetFollowMinuteTimer() const {
    GCountdownTimer value(GetSchemaPtr(m_ptr, "CChicken", "m_followMinuteTimer"));
    return value;
}
void GCChicken::SetFollowMinuteTimer(GCountdownTimer value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'FollowMinuteTimer' is not possible.\n");
}
Vector GCChicken::GetLastEggPoopPosition() const {
    return GetSchemaValue<Vector>(m_ptr, "CChicken", "m_vecLastEggPoopPosition");
}
void GCChicken::SetLastEggPoopPosition(Vector value) {
    SetSchemaValue(m_ptr, "CChicken", "m_vecLastEggPoopPosition", false, value);
}
GCountdownTimer GCChicken::GetBlockDirectionTimer() const {
    GCountdownTimer value(GetSchemaPtr(m_ptr, "CChicken", "m_BlockDirectionTimer"));
    return value;
}
void GCChicken::SetBlockDirectionTimer(GCountdownTimer value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'BlockDirectionTimer' is not possible.\n");
}
void* GCChicken::GetPtr() {
    return m_ptr;
}
std::string GCChicken::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCChicken::IsValid() {
    return (m_ptr != nullptr);
}
GCDynamicProp GCChicken::GetParent() const {
    GCDynamicProp value(m_ptr);
    return value;
}
void GCChicken::SetParent(GCDynamicProp value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCChicken(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCChicken>("CChicken")
        .addConstructor<void (*)(std::string)>()
        .addProperty("AttributeManager", &GCChicken::GetAttributeManager, &GCChicken::SetAttributeManager)
        .addProperty("ActivityFinishedTag", &GCChicken::GetActivityFinishedTag, &GCChicken::SetActivityFinishedTag)
        .addProperty("UpdateTimer", &GCChicken::GetUpdateTimer, &GCChicken::SetUpdateTimer)
        .addProperty("StuckAnchor", &GCChicken::GetStuckAnchor, &GCChicken::SetStuckAnchor)
        .addProperty("StuckTimer", &GCChicken::GetStuckTimer, &GCChicken::SetStuckTimer)
        .addProperty("CollisionStuckTimer", &GCChicken::GetCollisionStuckTimer, &GCChicken::SetCollisionStuckTimer)
        .addProperty("IsOnGround", &GCChicken::GetIsOnGround, &GCChicken::SetIsOnGround)
        .addProperty("FallVelocity", &GCChicken::GetFallVelocity, &GCChicken::SetFallVelocity)
        .addProperty("DesiredActivity", &GCChicken::GetDesiredActivity, &GCChicken::SetDesiredActivity)
        .addProperty("CurrentActivity", &GCChicken::GetCurrentActivity, &GCChicken::SetCurrentActivity)
        .addProperty("ActivityTimer", &GCChicken::GetActivityTimer, &GCChicken::SetActivityTimer)
        .addProperty("TurnRate", &GCChicken::GetTurnRate, &GCChicken::SetTurnRate)
        .addProperty("FleeFrom", &GCChicken::GetFleeFrom, &GCChicken::SetFleeFrom)
        .addProperty("MoveRateThrottleTimer", &GCChicken::GetMoveRateThrottleTimer, &GCChicken::SetMoveRateThrottleTimer)
        .addProperty("StartleTimer", &GCChicken::GetStartleTimer, &GCChicken::SetStartleTimer)
        .addProperty("VocalizeTimer", &GCChicken::GetVocalizeTimer, &GCChicken::SetVocalizeTimer)
        .addProperty("WhenZombified", &GCChicken::GetWhenZombified, &GCChicken::SetWhenZombified)
        .addProperty("JumpedThisFrame", &GCChicken::GetJumpedThisFrame, &GCChicken::SetJumpedThisFrame)
        .addProperty("Leader", &GCChicken::GetLeader, &GCChicken::SetLeader)
        .addProperty("ReuseTimer", &GCChicken::GetReuseTimer, &GCChicken::SetReuseTimer)
        .addProperty("HasBeenUsed", &GCChicken::GetHasBeenUsed, &GCChicken::SetHasBeenUsed)
        .addProperty("JumpTimer", &GCChicken::GetJumpTimer, &GCChicken::SetJumpTimer)
        .addProperty("LastJumpTime", &GCChicken::GetLastJumpTime, &GCChicken::SetLastJumpTime)
        .addProperty("InJump", &GCChicken::GetInJump, &GCChicken::SetInJump)
        .addProperty("IsWaitingForLeader", &GCChicken::GetIsWaitingForLeader, &GCChicken::SetIsWaitingForLeader)
        .addProperty("RepathTimer", &GCChicken::GetRepathTimer, &GCChicken::SetRepathTimer)
        .addProperty("InhibitDoorTimer", &GCChicken::GetInhibitDoorTimer, &GCChicken::SetInhibitDoorTimer)
        .addProperty("InhibitObstacleAvoidanceTimer", &GCChicken::GetInhibitObstacleAvoidanceTimer, &GCChicken::SetInhibitObstacleAvoidanceTimer)
        .addProperty("PathGoal", &GCChicken::GetPathGoal, &GCChicken::SetPathGoal)
        .addProperty("ActiveFollowStartTime", &GCChicken::GetActiveFollowStartTime, &GCChicken::SetActiveFollowStartTime)
        .addProperty("FollowMinuteTimer", &GCChicken::GetFollowMinuteTimer, &GCChicken::SetFollowMinuteTimer)
        .addProperty("LastEggPoopPosition", &GCChicken::GetLastEggPoopPosition, &GCChicken::SetLastEggPoopPosition)
        .addProperty("BlockDirectionTimer", &GCChicken::GetBlockDirectionTimer, &GCChicken::SetBlockDirectionTimer)
        .addProperty("Parent", &GCChicken::GetParent, &GCChicken::SetParent)
        .addFunction("ToPtr", &GCChicken::ToPtr)
        .addFunction("IsValid", &GCChicken::IsValid)
        .endClass();
}
GCInfoInstructorHintBombTargetA::GCInfoInstructorHintBombTargetA(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCInfoInstructorHintBombTargetA::GCInfoInstructorHintBombTargetA(void *ptr) {
    m_ptr = ptr;
}
void* GCInfoInstructorHintBombTargetA::GetPtr() {
    return m_ptr;
}
std::string GCInfoInstructorHintBombTargetA::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCInfoInstructorHintBombTargetA::IsValid() {
    return (m_ptr != nullptr);
}
GCPointEntity GCInfoInstructorHintBombTargetA::GetParent() const {
    GCPointEntity value(m_ptr);
    return value;
}
void GCInfoInstructorHintBombTargetA::SetParent(GCPointEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCInfoInstructorHintBombTargetA(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCInfoInstructorHintBombTargetA>("CInfoInstructorHintBombTargetA")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCInfoInstructorHintBombTargetA::GetParent, &GCInfoInstructorHintBombTargetA::SetParent)
        .addFunction("ToPtr", &GCInfoInstructorHintBombTargetA::ToPtr)
        .addFunction("IsValid", &GCInfoInstructorHintBombTargetA::IsValid)
        .endClass();
}
GCWeaponAWP::GCWeaponAWP(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCWeaponAWP::GCWeaponAWP(void *ptr) {
    m_ptr = ptr;
}
void* GCWeaponAWP::GetPtr() {
    return m_ptr;
}
std::string GCWeaponAWP::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCWeaponAWP::IsValid() {
    return (m_ptr != nullptr);
}
GCCSWeaponBaseGun GCWeaponAWP::GetParent() const {
    GCCSWeaponBaseGun value(m_ptr);
    return value;
}
void GCWeaponAWP::SetParent(GCCSWeaponBaseGun value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCWeaponAWP(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCWeaponAWP>("CWeaponAWP")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCWeaponAWP::GetParent, &GCWeaponAWP::SetParent)
        .addFunction("ToPtr", &GCWeaponAWP::ToPtr)
        .addFunction("IsValid", &GCWeaponAWP::IsValid)
        .endClass();
}
GCCSObserverPawn::GCCSObserverPawn(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCCSObserverPawn::GCCSObserverPawn(void *ptr) {
    m_ptr = ptr;
}
void* GCCSObserverPawn::GetPtr() {
    return m_ptr;
}
std::string GCCSObserverPawn::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCCSObserverPawn::IsValid() {
    return (m_ptr != nullptr);
}
GCCSPlayerPawnBase GCCSObserverPawn::GetParent() const {
    GCCSPlayerPawnBase value(m_ptr);
    return value;
}
void GCCSObserverPawn::SetParent(GCCSPlayerPawnBase value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCCSObserverPawn(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCCSObserverPawn>("CCSObserverPawn")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCCSObserverPawn::GetParent, &GCCSObserverPawn::SetParent)
        .addFunction("ToPtr", &GCCSObserverPawn::ToPtr)
        .addFunction("IsValid", &GCCSObserverPawn::IsValid)
        .endClass();
}
GCPostProcessingVolume::GCPostProcessingVolume(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCPostProcessingVolume::GCPostProcessingVolume(void *ptr) {
    m_ptr = ptr;
}
float GCPostProcessingVolume::GetFadeDuration() const {
    return GetSchemaValue<float>(m_ptr, "CPostProcessingVolume", "m_flFadeDuration");
}
void GCPostProcessingVolume::SetFadeDuration(float value) {
    SetSchemaValue(m_ptr, "CPostProcessingVolume", "m_flFadeDuration", false, value);
}
float GCPostProcessingVolume::GetMinLogExposure() const {
    return GetSchemaValue<float>(m_ptr, "CPostProcessingVolume", "m_flMinLogExposure");
}
void GCPostProcessingVolume::SetMinLogExposure(float value) {
    SetSchemaValue(m_ptr, "CPostProcessingVolume", "m_flMinLogExposure", false, value);
}
float GCPostProcessingVolume::GetMaxLogExposure() const {
    return GetSchemaValue<float>(m_ptr, "CPostProcessingVolume", "m_flMaxLogExposure");
}
void GCPostProcessingVolume::SetMaxLogExposure(float value) {
    SetSchemaValue(m_ptr, "CPostProcessingVolume", "m_flMaxLogExposure", false, value);
}
float GCPostProcessingVolume::GetMinExposure() const {
    return GetSchemaValue<float>(m_ptr, "CPostProcessingVolume", "m_flMinExposure");
}
void GCPostProcessingVolume::SetMinExposure(float value) {
    SetSchemaValue(m_ptr, "CPostProcessingVolume", "m_flMinExposure", false, value);
}
float GCPostProcessingVolume::GetMaxExposure() const {
    return GetSchemaValue<float>(m_ptr, "CPostProcessingVolume", "m_flMaxExposure");
}
void GCPostProcessingVolume::SetMaxExposure(float value) {
    SetSchemaValue(m_ptr, "CPostProcessingVolume", "m_flMaxExposure", false, value);
}
float GCPostProcessingVolume::GetExposureCompensation() const {
    return GetSchemaValue<float>(m_ptr, "CPostProcessingVolume", "m_flExposureCompensation");
}
void GCPostProcessingVolume::SetExposureCompensation(float value) {
    SetSchemaValue(m_ptr, "CPostProcessingVolume", "m_flExposureCompensation", false, value);
}
float GCPostProcessingVolume::GetExposureFadeSpeedUp() const {
    return GetSchemaValue<float>(m_ptr, "CPostProcessingVolume", "m_flExposureFadeSpeedUp");
}
void GCPostProcessingVolume::SetExposureFadeSpeedUp(float value) {
    SetSchemaValue(m_ptr, "CPostProcessingVolume", "m_flExposureFadeSpeedUp", false, value);
}
float GCPostProcessingVolume::GetExposureFadeSpeedDown() const {
    return GetSchemaValue<float>(m_ptr, "CPostProcessingVolume", "m_flExposureFadeSpeedDown");
}
void GCPostProcessingVolume::SetExposureFadeSpeedDown(float value) {
    SetSchemaValue(m_ptr, "CPostProcessingVolume", "m_flExposureFadeSpeedDown", false, value);
}
float GCPostProcessingVolume::GetTonemapEVSmoothingRange() const {
    return GetSchemaValue<float>(m_ptr, "CPostProcessingVolume", "m_flTonemapEVSmoothingRange");
}
void GCPostProcessingVolume::SetTonemapEVSmoothingRange(float value) {
    SetSchemaValue(m_ptr, "CPostProcessingVolume", "m_flTonemapEVSmoothingRange", false, value);
}
bool GCPostProcessingVolume::GetMaster() const {
    return GetSchemaValue<bool>(m_ptr, "CPostProcessingVolume", "m_bMaster");
}
void GCPostProcessingVolume::SetMaster(bool value) {
    SetSchemaValue(m_ptr, "CPostProcessingVolume", "m_bMaster", false, value);
}
bool GCPostProcessingVolume::GetExposureControl() const {
    return GetSchemaValue<bool>(m_ptr, "CPostProcessingVolume", "m_bExposureControl");
}
void GCPostProcessingVolume::SetExposureControl(bool value) {
    SetSchemaValue(m_ptr, "CPostProcessingVolume", "m_bExposureControl", false, value);
}
float GCPostProcessingVolume::GetRate() const {
    return GetSchemaValue<float>(m_ptr, "CPostProcessingVolume", "m_flRate");
}
void GCPostProcessingVolume::SetRate(float value) {
    SetSchemaValue(m_ptr, "CPostProcessingVolume", "m_flRate", false, value);
}
float GCPostProcessingVolume::GetTonemapPercentTarget() const {
    return GetSchemaValue<float>(m_ptr, "CPostProcessingVolume", "m_flTonemapPercentTarget");
}
void GCPostProcessingVolume::SetTonemapPercentTarget(float value) {
    SetSchemaValue(m_ptr, "CPostProcessingVolume", "m_flTonemapPercentTarget", false, value);
}
float GCPostProcessingVolume::GetTonemapPercentBrightPixels() const {
    return GetSchemaValue<float>(m_ptr, "CPostProcessingVolume", "m_flTonemapPercentBrightPixels");
}
void GCPostProcessingVolume::SetTonemapPercentBrightPixels(float value) {
    SetSchemaValue(m_ptr, "CPostProcessingVolume", "m_flTonemapPercentBrightPixels", false, value);
}
float GCPostProcessingVolume::GetTonemapMinAvgLum() const {
    return GetSchemaValue<float>(m_ptr, "CPostProcessingVolume", "m_flTonemapMinAvgLum");
}
void GCPostProcessingVolume::SetTonemapMinAvgLum(float value) {
    SetSchemaValue(m_ptr, "CPostProcessingVolume", "m_flTonemapMinAvgLum", false, value);
}
void* GCPostProcessingVolume::GetPtr() {
    return m_ptr;
}
std::string GCPostProcessingVolume::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCPostProcessingVolume::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseTrigger GCPostProcessingVolume::GetParent() const {
    GCBaseTrigger value(m_ptr);
    return value;
}
void GCPostProcessingVolume::SetParent(GCBaseTrigger value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCPostProcessingVolume(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCPostProcessingVolume>("CPostProcessingVolume")
        .addConstructor<void (*)(std::string)>()
        .addProperty("FadeDuration", &GCPostProcessingVolume::GetFadeDuration, &GCPostProcessingVolume::SetFadeDuration)
        .addProperty("MinLogExposure", &GCPostProcessingVolume::GetMinLogExposure, &GCPostProcessingVolume::SetMinLogExposure)
        .addProperty("MaxLogExposure", &GCPostProcessingVolume::GetMaxLogExposure, &GCPostProcessingVolume::SetMaxLogExposure)
        .addProperty("MinExposure", &GCPostProcessingVolume::GetMinExposure, &GCPostProcessingVolume::SetMinExposure)
        .addProperty("MaxExposure", &GCPostProcessingVolume::GetMaxExposure, &GCPostProcessingVolume::SetMaxExposure)
        .addProperty("ExposureCompensation", &GCPostProcessingVolume::GetExposureCompensation, &GCPostProcessingVolume::SetExposureCompensation)
        .addProperty("ExposureFadeSpeedUp", &GCPostProcessingVolume::GetExposureFadeSpeedUp, &GCPostProcessingVolume::SetExposureFadeSpeedUp)
        .addProperty("ExposureFadeSpeedDown", &GCPostProcessingVolume::GetExposureFadeSpeedDown, &GCPostProcessingVolume::SetExposureFadeSpeedDown)
        .addProperty("TonemapEVSmoothingRange", &GCPostProcessingVolume::GetTonemapEVSmoothingRange, &GCPostProcessingVolume::SetTonemapEVSmoothingRange)
        .addProperty("Master", &GCPostProcessingVolume::GetMaster, &GCPostProcessingVolume::SetMaster)
        .addProperty("ExposureControl", &GCPostProcessingVolume::GetExposureControl, &GCPostProcessingVolume::SetExposureControl)
        .addProperty("Rate", &GCPostProcessingVolume::GetRate, &GCPostProcessingVolume::SetRate)
        .addProperty("TonemapPercentTarget", &GCPostProcessingVolume::GetTonemapPercentTarget, &GCPostProcessingVolume::SetTonemapPercentTarget)
        .addProperty("TonemapPercentBrightPixels", &GCPostProcessingVolume::GetTonemapPercentBrightPixels, &GCPostProcessingVolume::SetTonemapPercentBrightPixels)
        .addProperty("TonemapMinAvgLum", &GCPostProcessingVolume::GetTonemapMinAvgLum, &GCPostProcessingVolume::SetTonemapMinAvgLum)
        .addProperty("Parent", &GCPostProcessingVolume::GetParent, &GCPostProcessingVolume::SetParent)
        .addFunction("ToPtr", &GCPostProcessingVolume::ToPtr)
        .addFunction("IsValid", &GCPostProcessingVolume::IsValid)
        .endClass();
}
GCSpotlightEnd::GCSpotlightEnd(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCSpotlightEnd::GCSpotlightEnd(void *ptr) {
    m_ptr = ptr;
}
float GCSpotlightEnd::GetLightScale() const {
    return GetSchemaValue<float>(m_ptr, "CSpotlightEnd", "m_flLightScale");
}
void GCSpotlightEnd::SetLightScale(float value) {
    SetSchemaValue(m_ptr, "CSpotlightEnd", "m_flLightScale", false, value);
}
float GCSpotlightEnd::GetRadius() const {
    return GetSchemaValue<float>(m_ptr, "CSpotlightEnd", "m_Radius");
}
void GCSpotlightEnd::SetRadius(float value) {
    SetSchemaValue(m_ptr, "CSpotlightEnd", "m_Radius", false, value);
}
Vector GCSpotlightEnd::GetSpotlightDir() const {
    return GetSchemaValue<Vector>(m_ptr, "CSpotlightEnd", "m_vSpotlightDir");
}
void GCSpotlightEnd::SetSpotlightDir(Vector value) {
    SetSchemaValue(m_ptr, "CSpotlightEnd", "m_vSpotlightDir", false, value);
}
Vector GCSpotlightEnd::GetSpotlightOrg() const {
    return GetSchemaValue<Vector>(m_ptr, "CSpotlightEnd", "m_vSpotlightOrg");
}
void GCSpotlightEnd::SetSpotlightOrg(Vector value) {
    SetSchemaValue(m_ptr, "CSpotlightEnd", "m_vSpotlightOrg", false, value);
}
void* GCSpotlightEnd::GetPtr() {
    return m_ptr;
}
std::string GCSpotlightEnd::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCSpotlightEnd::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseModelEntity GCSpotlightEnd::GetParent() const {
    GCBaseModelEntity value(m_ptr);
    return value;
}
void GCSpotlightEnd::SetParent(GCBaseModelEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCSpotlightEnd(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCSpotlightEnd>("CSpotlightEnd")
        .addConstructor<void (*)(std::string)>()
        .addProperty("LightScale", &GCSpotlightEnd::GetLightScale, &GCSpotlightEnd::SetLightScale)
        .addProperty("Radius", &GCSpotlightEnd::GetRadius, &GCSpotlightEnd::SetRadius)
        .addProperty("SpotlightDir", &GCSpotlightEnd::GetSpotlightDir, &GCSpotlightEnd::SetSpotlightDir)
        .addProperty("SpotlightOrg", &GCSpotlightEnd::GetSpotlightOrg, &GCSpotlightEnd::SetSpotlightOrg)
        .addProperty("Parent", &GCSpotlightEnd::GetParent, &GCSpotlightEnd::SetParent)
        .addFunction("ToPtr", &GCSpotlightEnd::ToPtr)
        .addFunction("IsValid", &GCSpotlightEnd::IsValid)
        .endClass();
}
GCGamePlayerZone::GCGamePlayerZone(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCGamePlayerZone::GCGamePlayerZone(void *ptr) {
    m_ptr = ptr;
}
GCEntityIOOutput GCGamePlayerZone::GetOnPlayerInZone() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CGamePlayerZone", "m_OnPlayerInZone"));
    return value;
}
void GCGamePlayerZone::SetOnPlayerInZone(GCEntityIOOutput value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'OnPlayerInZone' is not possible.\n");
}
GCEntityIOOutput GCGamePlayerZone::GetOnPlayerOutZone() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CGamePlayerZone", "m_OnPlayerOutZone"));
    return value;
}
void GCGamePlayerZone::SetOnPlayerOutZone(GCEntityIOOutput value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'OnPlayerOutZone' is not possible.\n");
}
void* GCGamePlayerZone::GetPtr() {
    return m_ptr;
}
std::string GCGamePlayerZone::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCGamePlayerZone::IsValid() {
    return (m_ptr != nullptr);
}
GCRuleBrushEntity GCGamePlayerZone::GetParent() const {
    GCRuleBrushEntity value(m_ptr);
    return value;
}
void GCGamePlayerZone::SetParent(GCRuleBrushEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCGamePlayerZone(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCGamePlayerZone>("CGamePlayerZone")
        .addConstructor<void (*)(std::string)>()
        .addProperty("OnPlayerInZone", &GCGamePlayerZone::GetOnPlayerInZone, &GCGamePlayerZone::SetOnPlayerInZone)
        .addProperty("OnPlayerOutZone", &GCGamePlayerZone::GetOnPlayerOutZone, &GCGamePlayerZone::SetOnPlayerOutZone)
        .addProperty("Parent", &GCGamePlayerZone::GetParent, &GCGamePlayerZone::SetParent)
        .addFunction("ToPtr", &GCGamePlayerZone::ToPtr)
        .addFunction("IsValid", &GCGamePlayerZone::IsValid)
        .endClass();
}
GCSensorGrenade::GCSensorGrenade(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCSensorGrenade::GCSensorGrenade(void *ptr) {
    m_ptr = ptr;
}
void* GCSensorGrenade::GetPtr() {
    return m_ptr;
}
std::string GCSensorGrenade::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCSensorGrenade::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseCSGrenade GCSensorGrenade::GetParent() const {
    GCBaseCSGrenade value(m_ptr);
    return value;
}
void GCSensorGrenade::SetParent(GCBaseCSGrenade value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCSensorGrenade(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCSensorGrenade>("CSensorGrenade")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCSensorGrenade::GetParent, &GCSensorGrenade::SetParent)
        .addFunction("ToPtr", &GCSensorGrenade::ToPtr)
        .addFunction("IsValid", &GCSensorGrenade::IsValid)
        .endClass();
}
GCCSGO_WingmanIntroTerroristPosition::GCCSGO_WingmanIntroTerroristPosition(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCCSGO_WingmanIntroTerroristPosition::GCCSGO_WingmanIntroTerroristPosition(void *ptr) {
    m_ptr = ptr;
}
void* GCCSGO_WingmanIntroTerroristPosition::GetPtr() {
    return m_ptr;
}
std::string GCCSGO_WingmanIntroTerroristPosition::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCCSGO_WingmanIntroTerroristPosition::IsValid() {
    return (m_ptr != nullptr);
}
GCCSGO_WingmanIntroCharacterPosition GCCSGO_WingmanIntroTerroristPosition::GetParent() const {
    GCCSGO_WingmanIntroCharacterPosition value(m_ptr);
    return value;
}
void GCCSGO_WingmanIntroTerroristPosition::SetParent(GCCSGO_WingmanIntroCharacterPosition value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCCSGO_WingmanIntroTerroristPosition(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCCSGO_WingmanIntroTerroristPosition>("CCSGO_WingmanIntroTerroristPosition")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCCSGO_WingmanIntroTerroristPosition::GetParent, &GCCSGO_WingmanIntroTerroristPosition::SetParent)
        .addFunction("ToPtr", &GCCSGO_WingmanIntroTerroristPosition::ToPtr)
        .addFunction("IsValid", &GCCSGO_WingmanIntroTerroristPosition::IsValid)
        .endClass();
}
GCTriggerDetectExplosion::GCTriggerDetectExplosion(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCTriggerDetectExplosion::GCTriggerDetectExplosion(void *ptr) {
    m_ptr = ptr;
}
GCEntityIOOutput GCTriggerDetectExplosion::GetOnDetectedExplosion() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CTriggerDetectExplosion", "m_OnDetectedExplosion"));
    return value;
}
void GCTriggerDetectExplosion::SetOnDetectedExplosion(GCEntityIOOutput value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'OnDetectedExplosion' is not possible.\n");
}
void* GCTriggerDetectExplosion::GetPtr() {
    return m_ptr;
}
std::string GCTriggerDetectExplosion::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCTriggerDetectExplosion::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseTrigger GCTriggerDetectExplosion::GetParent() const {
    GCBaseTrigger value(m_ptr);
    return value;
}
void GCTriggerDetectExplosion::SetParent(GCBaseTrigger value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCTriggerDetectExplosion(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCTriggerDetectExplosion>("CTriggerDetectExplosion")
        .addConstructor<void (*)(std::string)>()
        .addProperty("OnDetectedExplosion", &GCTriggerDetectExplosion::GetOnDetectedExplosion, &GCTriggerDetectExplosion::SetOnDetectedExplosion)
        .addProperty("Parent", &GCTriggerDetectExplosion::GetParent, &GCTriggerDetectExplosion::SetParent)
        .addFunction("ToPtr", &GCTriggerDetectExplosion::ToPtr)
        .addFunction("IsValid", &GCTriggerDetectExplosion::IsValid)
        .endClass();
}
GCSoundStackSave::GCSoundStackSave(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCSoundStackSave::GCSoundStackSave(void *ptr) {
    m_ptr = ptr;
}
std::string GCSoundStackSave::GetStackName() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CSoundStackSave", "m_iszStackName").String();
}
void GCSoundStackSave::SetStackName(std::string value) {
    SetSchemaValue(m_ptr, "CSoundStackSave", "m_iszStackName", false, CUtlSymbolLarge(value.c_str()));
}
void* GCSoundStackSave::GetPtr() {
    return m_ptr;
}
std::string GCSoundStackSave::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCSoundStackSave::IsValid() {
    return (m_ptr != nullptr);
}
GCLogicalEntity GCSoundStackSave::GetParent() const {
    GCLogicalEntity value(m_ptr);
    return value;
}
void GCSoundStackSave::SetParent(GCLogicalEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCSoundStackSave(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCSoundStackSave>("CSoundStackSave")
        .addConstructor<void (*)(std::string)>()
        .addProperty("StackName", &GCSoundStackSave::GetStackName, &GCSoundStackSave::SetStackName)
        .addProperty("Parent", &GCSoundStackSave::GetParent, &GCSoundStackSave::SetParent)
        .addFunction("ToPtr", &GCSoundStackSave::ToPtr)
        .addFunction("IsValid", &GCSoundStackSave::IsValid)
        .endClass();
}
GConstraintSoundInfo::GConstraintSoundInfo(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GConstraintSoundInfo::GConstraintSoundInfo(void *ptr) {
    m_ptr = ptr;
}
GVelocitySampler GConstraintSoundInfo::GetSampler() const {
    GVelocitySampler value(GetSchemaPtr(m_ptr, "ConstraintSoundInfo", "m_vSampler"));
    return value;
}
void GConstraintSoundInfo::SetSampler(GVelocitySampler value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Sampler' is not possible.\n");
}
GSimpleConstraintSoundProfile GConstraintSoundInfo::GetSoundProfile() const {
    GSimpleConstraintSoundProfile value(GetSchemaPtr(m_ptr, "ConstraintSoundInfo", "m_soundProfile"));
    return value;
}
void GConstraintSoundInfo::SetSoundProfile(GSimpleConstraintSoundProfile value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'SoundProfile' is not possible.\n");
}
Vector GConstraintSoundInfo::GetForwardAxis() const {
    return GetSchemaValue<Vector>(m_ptr, "ConstraintSoundInfo", "m_forwardAxis");
}
void GConstraintSoundInfo::SetForwardAxis(Vector value) {
    SetSchemaValue(m_ptr, "ConstraintSoundInfo", "m_forwardAxis", false, value);
}
std::string GConstraintSoundInfo::GetTravelSoundFwd() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "ConstraintSoundInfo", "m_iszTravelSoundFwd").String();
}
void GConstraintSoundInfo::SetTravelSoundFwd(std::string value) {
    SetSchemaValue(m_ptr, "ConstraintSoundInfo", "m_iszTravelSoundFwd", false, CUtlSymbolLarge(value.c_str()));
}
std::string GConstraintSoundInfo::GetTravelSoundBack() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "ConstraintSoundInfo", "m_iszTravelSoundBack").String();
}
void GConstraintSoundInfo::SetTravelSoundBack(std::string value) {
    SetSchemaValue(m_ptr, "ConstraintSoundInfo", "m_iszTravelSoundBack", false, CUtlSymbolLarge(value.c_str()));
}
std::vector<CUtlSymbolLarge> GConstraintSoundInfo::GetReversalSounds() const {
    CUtlSymbolLarge* outValue = (CUtlSymbolLarge*)GetSchemaPtr(m_ptr, "ConstraintSoundInfo", "m_iszReversalSounds"); std::vector<CUtlSymbolLarge> ret; for(int i = 0; i < 3; i++) { ret.push_back(outValue[i]); } return ret;
}
void GConstraintSoundInfo::SetReversalSounds(std::vector<CUtlSymbolLarge> value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'ReversalSounds' is not possible.\n");
}
bool GConstraintSoundInfo::GetPlayTravelSound() const {
    return GetSchemaValue<bool>(m_ptr, "ConstraintSoundInfo", "m_bPlayTravelSound");
}
void GConstraintSoundInfo::SetPlayTravelSound(bool value) {
    SetSchemaValue(m_ptr, "ConstraintSoundInfo", "m_bPlayTravelSound", false, value);
}
bool GConstraintSoundInfo::GetPlayReversalSound() const {
    return GetSchemaValue<bool>(m_ptr, "ConstraintSoundInfo", "m_bPlayReversalSound");
}
void GConstraintSoundInfo::SetPlayReversalSound(bool value) {
    SetSchemaValue(m_ptr, "ConstraintSoundInfo", "m_bPlayReversalSound", false, value);
}
void* GConstraintSoundInfo::GetPtr() {
    return m_ptr;
}
std::string GConstraintSoundInfo::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GConstraintSoundInfo::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassConstraintSoundInfo(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GConstraintSoundInfo>("ConstraintSoundInfo")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Sampler", &GConstraintSoundInfo::GetSampler, &GConstraintSoundInfo::SetSampler)
        .addProperty("SoundProfile", &GConstraintSoundInfo::GetSoundProfile, &GConstraintSoundInfo::SetSoundProfile)
        .addProperty("ForwardAxis", &GConstraintSoundInfo::GetForwardAxis, &GConstraintSoundInfo::SetForwardAxis)
        .addProperty("TravelSoundFwd", &GConstraintSoundInfo::GetTravelSoundFwd, &GConstraintSoundInfo::SetTravelSoundFwd)
        .addProperty("TravelSoundBack", &GConstraintSoundInfo::GetTravelSoundBack, &GConstraintSoundInfo::SetTravelSoundBack)
        .addProperty("ReversalSounds", &GConstraintSoundInfo::GetReversalSounds, &GConstraintSoundInfo::SetReversalSounds)
        .addProperty("PlayTravelSound", &GConstraintSoundInfo::GetPlayTravelSound, &GConstraintSoundInfo::SetPlayTravelSound)
        .addProperty("PlayReversalSound", &GConstraintSoundInfo::GetPlayReversalSound, &GConstraintSoundInfo::SetPlayReversalSound)
        .addFunction("ToPtr", &GConstraintSoundInfo::ToPtr)
        .addFunction("IsValid", &GConstraintSoundInfo::IsValid)
        .endClass();
}
GCSingleplayRules::GCSingleplayRules(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCSingleplayRules::GCSingleplayRules(void *ptr) {
    m_ptr = ptr;
}
bool GCSingleplayRules::GetSinglePlayerGameEnding() const {
    return GetSchemaValue<bool>(m_ptr, "CSingleplayRules", "m_bSinglePlayerGameEnding");
}
void GCSingleplayRules::SetSinglePlayerGameEnding(bool value) {
    SetSchemaValue(m_ptr, "CSingleplayRules", "m_bSinglePlayerGameEnding", false, value);
}
void* GCSingleplayRules::GetPtr() {
    return m_ptr;
}
std::string GCSingleplayRules::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCSingleplayRules::IsValid() {
    return (m_ptr != nullptr);
}
GCGameRules GCSingleplayRules::GetParent() const {
    GCGameRules value(m_ptr);
    return value;
}
void GCSingleplayRules::SetParent(GCGameRules value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCSingleplayRules(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCSingleplayRules>("CSingleplayRules")
        .addConstructor<void (*)(std::string)>()
        .addProperty("SinglePlayerGameEnding", &GCSingleplayRules::GetSinglePlayerGameEnding, &GCSingleplayRules::SetSinglePlayerGameEnding)
        .addProperty("Parent", &GCSingleplayRules::GetParent, &GCSingleplayRules::SetParent)
        .addFunction("ToPtr", &GCSingleplayRules::ToPtr)
        .addFunction("IsValid", &GCSingleplayRules::IsValid)
        .endClass();
}
GCFilterProximity::GCFilterProximity(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCFilterProximity::GCFilterProximity(void *ptr) {
    m_ptr = ptr;
}
float GCFilterProximity::GetRadius() const {
    return GetSchemaValue<float>(m_ptr, "CFilterProximity", "m_flRadius");
}
void GCFilterProximity::SetRadius(float value) {
    SetSchemaValue(m_ptr, "CFilterProximity", "m_flRadius", false, value);
}
void* GCFilterProximity::GetPtr() {
    return m_ptr;
}
std::string GCFilterProximity::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCFilterProximity::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseFilter GCFilterProximity::GetParent() const {
    GCBaseFilter value(m_ptr);
    return value;
}
void GCFilterProximity::SetParent(GCBaseFilter value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCFilterProximity(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCFilterProximity>("CFilterProximity")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Radius", &GCFilterProximity::GetRadius, &GCFilterProximity::SetRadius)
        .addProperty("Parent", &GCFilterProximity::GetParent, &GCFilterProximity::SetParent)
        .addFunction("ToPtr", &GCFilterProximity::ToPtr)
        .addFunction("IsValid", &GCFilterProximity::IsValid)
        .endClass();
}
GCEconWearable::GCEconWearable(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCEconWearable::GCEconWearable(void *ptr) {
    m_ptr = ptr;
}
int32_t GCEconWearable::GetForceSkin() const {
    return GetSchemaValue<int32_t>(m_ptr, "CEconWearable", "m_nForceSkin");
}
void GCEconWearable::SetForceSkin(int32_t value) {
    SetSchemaValue(m_ptr, "CEconWearable", "m_nForceSkin", false, value);
}
bool GCEconWearable::GetAlwaysAllow() const {
    return GetSchemaValue<bool>(m_ptr, "CEconWearable", "m_bAlwaysAllow");
}
void GCEconWearable::SetAlwaysAllow(bool value) {
    SetSchemaValue(m_ptr, "CEconWearable", "m_bAlwaysAllow", false, value);
}
void* GCEconWearable::GetPtr() {
    return m_ptr;
}
std::string GCEconWearable::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCEconWearable::IsValid() {
    return (m_ptr != nullptr);
}
GCEconEntity GCEconWearable::GetParent() const {
    GCEconEntity value(m_ptr);
    return value;
}
void GCEconWearable::SetParent(GCEconEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCEconWearable(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCEconWearable>("CEconWearable")
        .addConstructor<void (*)(std::string)>()
        .addProperty("ForceSkin", &GCEconWearable::GetForceSkin, &GCEconWearable::SetForceSkin)
        .addProperty("AlwaysAllow", &GCEconWearable::GetAlwaysAllow, &GCEconWearable::SetAlwaysAllow)
        .addProperty("Parent", &GCEconWearable::GetParent, &GCEconWearable::SetParent)
        .addFunction("ToPtr", &GCEconWearable::ToPtr)
        .addFunction("IsValid", &GCEconWearable::IsValid)
        .endClass();
}
GCCSPlayer_ItemServices::GCCSPlayer_ItemServices(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCCSPlayer_ItemServices::GCCSPlayer_ItemServices(void *ptr) {
    m_ptr = ptr;
}
bool GCCSPlayer_ItemServices::GetHasDefuser() const {
    return GetSchemaValue<bool>(m_ptr, "CCSPlayer_ItemServices", "m_bHasDefuser");
}
void GCCSPlayer_ItemServices::SetHasDefuser(bool value) {
    SetSchemaValue(m_ptr, "CCSPlayer_ItemServices", "m_bHasDefuser", false, value);
}
bool GCCSPlayer_ItemServices::GetHasHelmet() const {
    return GetSchemaValue<bool>(m_ptr, "CCSPlayer_ItemServices", "m_bHasHelmet");
}
void GCCSPlayer_ItemServices::SetHasHelmet(bool value) {
    SetSchemaValue(m_ptr, "CCSPlayer_ItemServices", "m_bHasHelmet", false, value);
}
bool GCCSPlayer_ItemServices::GetHasHeavyArmor() const {
    return GetSchemaValue<bool>(m_ptr, "CCSPlayer_ItemServices", "m_bHasHeavyArmor");
}
void GCCSPlayer_ItemServices::SetHasHeavyArmor(bool value) {
    SetSchemaValue(m_ptr, "CCSPlayer_ItemServices", "m_bHasHeavyArmor", false, value);
}
void* GCCSPlayer_ItemServices::GetPtr() {
    return m_ptr;
}
std::string GCCSPlayer_ItemServices::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCCSPlayer_ItemServices::IsValid() {
    return (m_ptr != nullptr);
}
GCPlayer_ItemServices GCCSPlayer_ItemServices::GetParent() const {
    GCPlayer_ItemServices value(m_ptr);
    return value;
}
void GCCSPlayer_ItemServices::SetParent(GCPlayer_ItemServices value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCCSPlayer_ItemServices(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCCSPlayer_ItemServices>("CCSPlayer_ItemServices")
        .addConstructor<void (*)(std::string)>()
        .addProperty("HasDefuser", &GCCSPlayer_ItemServices::GetHasDefuser, &GCCSPlayer_ItemServices::SetHasDefuser)
        .addProperty("HasHelmet", &GCCSPlayer_ItemServices::GetHasHelmet, &GCCSPlayer_ItemServices::SetHasHelmet)
        .addProperty("HasHeavyArmor", &GCCSPlayer_ItemServices::GetHasHeavyArmor, &GCCSPlayer_ItemServices::SetHasHeavyArmor)
        .addProperty("Parent", &GCCSPlayer_ItemServices::GetParent, &GCCSPlayer_ItemServices::SetParent)
        .addFunction("ToPtr", &GCCSPlayer_ItemServices::ToPtr)
        .addFunction("IsValid", &GCCSPlayer_ItemServices::IsValid)
        .endClass();
}
GCFuncConveyor::GCFuncConveyor(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCFuncConveyor::GCFuncConveyor(void *ptr) {
    m_ptr = ptr;
}
std::string GCFuncConveyor::GetConveyorModels() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CFuncConveyor", "m_szConveyorModels").String();
}
void GCFuncConveyor::SetConveyorModels(std::string value) {
    SetSchemaValue(m_ptr, "CFuncConveyor", "m_szConveyorModels", false, CUtlSymbolLarge(value.c_str()));
}
float GCFuncConveyor::GetTransitionDurationSeconds() const {
    return GetSchemaValue<float>(m_ptr, "CFuncConveyor", "m_flTransitionDurationSeconds");
}
void GCFuncConveyor::SetTransitionDurationSeconds(float value) {
    SetSchemaValue(m_ptr, "CFuncConveyor", "m_flTransitionDurationSeconds", false, value);
}
QAngle GCFuncConveyor::GetMoveEntitySpace() const {
    return GetSchemaValue<QAngle>(m_ptr, "CFuncConveyor", "m_angMoveEntitySpace");
}
void GCFuncConveyor::SetMoveEntitySpace(QAngle value) {
    SetSchemaValue(m_ptr, "CFuncConveyor", "m_angMoveEntitySpace", false, value);
}
Vector GCFuncConveyor::GetMoveDirEntitySpace() const {
    return GetSchemaValue<Vector>(m_ptr, "CFuncConveyor", "m_vecMoveDirEntitySpace");
}
void GCFuncConveyor::SetMoveDirEntitySpace(Vector value) {
    SetSchemaValue(m_ptr, "CFuncConveyor", "m_vecMoveDirEntitySpace", false, value);
}
float GCFuncConveyor::GetTargetSpeed() const {
    return GetSchemaValue<float>(m_ptr, "CFuncConveyor", "m_flTargetSpeed");
}
void GCFuncConveyor::SetTargetSpeed(float value) {
    SetSchemaValue(m_ptr, "CFuncConveyor", "m_flTargetSpeed", false, value);
}
int32 GCFuncConveyor::GetTransitionStartTick() const {
    return GetSchemaValue<int32>(m_ptr, "CFuncConveyor", "m_nTransitionStartTick");
}
void GCFuncConveyor::SetTransitionStartTick(int32 value) {
    SetSchemaValue(m_ptr, "CFuncConveyor", "m_nTransitionStartTick", false, value);
}
int32_t GCFuncConveyor::GetTransitionDurationTicks() const {
    return GetSchemaValue<int32_t>(m_ptr, "CFuncConveyor", "m_nTransitionDurationTicks");
}
void GCFuncConveyor::SetTransitionDurationTicks(int32_t value) {
    SetSchemaValue(m_ptr, "CFuncConveyor", "m_nTransitionDurationTicks", false, value);
}
float GCFuncConveyor::GetTransitionStartSpeed() const {
    return GetSchemaValue<float>(m_ptr, "CFuncConveyor", "m_flTransitionStartSpeed");
}
void GCFuncConveyor::SetTransitionStartSpeed(float value) {
    SetSchemaValue(m_ptr, "CFuncConveyor", "m_flTransitionStartSpeed", false, value);
}
std::vector<GCBaseEntity> GCFuncConveyor::GetConveyorModels1() const {
    CUtlVector<CHandle<CEntityInstance>>* vec = GetSchemaValue<CUtlVector<CHandle<CEntityInstance>>*>(m_ptr, "CFuncConveyor", "m_hConveyorModels"); 
    std::vector<GCBaseEntity> outVec; 
    for(int i = 0; i < vec->Count(); i++) { 
        outVec.push_back(GCBaseEntity((void*)(vec->Element(i).Get()))); 
    } 
    return outVec;
}
void GCFuncConveyor::SetConveyorModels1(std::vector<GCBaseEntity> value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'ConveyorModels1' is not possible.\n");
}
void* GCFuncConveyor::GetPtr() {
    return m_ptr;
}
std::string GCFuncConveyor::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCFuncConveyor::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseModelEntity GCFuncConveyor::GetParent() const {
    GCBaseModelEntity value(m_ptr);
    return value;
}
void GCFuncConveyor::SetParent(GCBaseModelEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCFuncConveyor(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCFuncConveyor>("CFuncConveyor")
        .addConstructor<void (*)(std::string)>()
        .addProperty("ConveyorModels", &GCFuncConveyor::GetConveyorModels, &GCFuncConveyor::SetConveyorModels)
        .addProperty("TransitionDurationSeconds", &GCFuncConveyor::GetTransitionDurationSeconds, &GCFuncConveyor::SetTransitionDurationSeconds)
        .addProperty("MoveEntitySpace", &GCFuncConveyor::GetMoveEntitySpace, &GCFuncConveyor::SetMoveEntitySpace)
        .addProperty("MoveDirEntitySpace", &GCFuncConveyor::GetMoveDirEntitySpace, &GCFuncConveyor::SetMoveDirEntitySpace)
        .addProperty("TargetSpeed", &GCFuncConveyor::GetTargetSpeed, &GCFuncConveyor::SetTargetSpeed)
        .addProperty("TransitionStartTick", &GCFuncConveyor::GetTransitionStartTick, &GCFuncConveyor::SetTransitionStartTick)
        .addProperty("TransitionDurationTicks", &GCFuncConveyor::GetTransitionDurationTicks, &GCFuncConveyor::SetTransitionDurationTicks)
        .addProperty("TransitionStartSpeed", &GCFuncConveyor::GetTransitionStartSpeed, &GCFuncConveyor::SetTransitionStartSpeed)
        .addProperty("ConveyorModels1", &GCFuncConveyor::GetConveyorModels1, &GCFuncConveyor::SetConveyorModels1)
        .addProperty("Parent", &GCFuncConveyor::GetParent, &GCFuncConveyor::SetParent)
        .addFunction("ToPtr", &GCFuncConveyor::ToPtr)
        .addFunction("IsValid", &GCFuncConveyor::IsValid)
        .endClass();
}
GCWeaponMag7::GCWeaponMag7(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCWeaponMag7::GCWeaponMag7(void *ptr) {
    m_ptr = ptr;
}
void* GCWeaponMag7::GetPtr() {
    return m_ptr;
}
std::string GCWeaponMag7::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCWeaponMag7::IsValid() {
    return (m_ptr != nullptr);
}
GCCSWeaponBaseGun GCWeaponMag7::GetParent() const {
    GCCSWeaponBaseGun value(m_ptr);
    return value;
}
void GCWeaponMag7::SetParent(GCCSWeaponBaseGun value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCWeaponMag7(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCWeaponMag7>("CWeaponMag7")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCWeaponMag7::GetParent, &GCWeaponMag7::SetParent)
        .addFunction("ToPtr", &GCWeaponMag7::ToPtr)
        .addFunction("IsValid", &GCWeaponMag7::IsValid)
        .endClass();
}
GCMathCounter::GCMathCounter(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCMathCounter::GCMathCounter(void *ptr) {
    m_ptr = ptr;
}
float GCMathCounter::GetMin() const {
    return GetSchemaValue<float>(m_ptr, "CMathCounter", "m_flMin");
}
void GCMathCounter::SetMin(float value) {
    SetSchemaValue(m_ptr, "CMathCounter", "m_flMin", false, value);
}
float GCMathCounter::GetMax() const {
    return GetSchemaValue<float>(m_ptr, "CMathCounter", "m_flMax");
}
void GCMathCounter::SetMax(float value) {
    SetSchemaValue(m_ptr, "CMathCounter", "m_flMax", false, value);
}
bool GCMathCounter::GetHitMin() const {
    return GetSchemaValue<bool>(m_ptr, "CMathCounter", "m_bHitMin");
}
void GCMathCounter::SetHitMin(bool value) {
    SetSchemaValue(m_ptr, "CMathCounter", "m_bHitMin", false, value);
}
bool GCMathCounter::GetHitMax() const {
    return GetSchemaValue<bool>(m_ptr, "CMathCounter", "m_bHitMax");
}
void GCMathCounter::SetHitMax(bool value) {
    SetSchemaValue(m_ptr, "CMathCounter", "m_bHitMax", false, value);
}
bool GCMathCounter::GetDisabled() const {
    return GetSchemaValue<bool>(m_ptr, "CMathCounter", "m_bDisabled");
}
void GCMathCounter::SetDisabled(bool value) {
    SetSchemaValue(m_ptr, "CMathCounter", "m_bDisabled", false, value);
}
GCEntityIOOutput GCMathCounter::GetOnHitMin() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CMathCounter", "m_OnHitMin"));
    return value;
}
void GCMathCounter::SetOnHitMin(GCEntityIOOutput value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'OnHitMin' is not possible.\n");
}
GCEntityIOOutput GCMathCounter::GetOnHitMax() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CMathCounter", "m_OnHitMax"));
    return value;
}
void GCMathCounter::SetOnHitMax(GCEntityIOOutput value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'OnHitMax' is not possible.\n");
}
GCEntityIOOutput GCMathCounter::GetOnChangedFromMin() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CMathCounter", "m_OnChangedFromMin"));
    return value;
}
void GCMathCounter::SetOnChangedFromMin(GCEntityIOOutput value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'OnChangedFromMin' is not possible.\n");
}
GCEntityIOOutput GCMathCounter::GetOnChangedFromMax() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CMathCounter", "m_OnChangedFromMax"));
    return value;
}
void GCMathCounter::SetOnChangedFromMax(GCEntityIOOutput value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'OnChangedFromMax' is not possible.\n");
}
void* GCMathCounter::GetPtr() {
    return m_ptr;
}
std::string GCMathCounter::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCMathCounter::IsValid() {
    return (m_ptr != nullptr);
}
GCLogicalEntity GCMathCounter::GetParent() const {
    GCLogicalEntity value(m_ptr);
    return value;
}
void GCMathCounter::SetParent(GCLogicalEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCMathCounter(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCMathCounter>("CMathCounter")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Min", &GCMathCounter::GetMin, &GCMathCounter::SetMin)
        .addProperty("Max", &GCMathCounter::GetMax, &GCMathCounter::SetMax)
        .addProperty("HitMin", &GCMathCounter::GetHitMin, &GCMathCounter::SetHitMin)
        .addProperty("HitMax", &GCMathCounter::GetHitMax, &GCMathCounter::SetHitMax)
        .addProperty("Disabled", &GCMathCounter::GetDisabled, &GCMathCounter::SetDisabled)
        .addProperty("OnHitMin", &GCMathCounter::GetOnHitMin, &GCMathCounter::SetOnHitMin)
        .addProperty("OnHitMax", &GCMathCounter::GetOnHitMax, &GCMathCounter::SetOnHitMax)
        .addProperty("OnChangedFromMin", &GCMathCounter::GetOnChangedFromMin, &GCMathCounter::SetOnChangedFromMin)
        .addProperty("OnChangedFromMax", &GCMathCounter::GetOnChangedFromMax, &GCMathCounter::SetOnChangedFromMax)
        .addProperty("Parent", &GCMathCounter::GetParent, &GCMathCounter::SetParent)
        .addFunction("ToPtr", &GCMathCounter::ToPtr)
        .addFunction("IsValid", &GCMathCounter::IsValid)
        .endClass();
}
GCInfoWorldLayer::GCInfoWorldLayer(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCInfoWorldLayer::GCInfoWorldLayer(void *ptr) {
    m_ptr = ptr;
}
GCEntityIOOutput GCInfoWorldLayer::GetOutputOnEntitiesSpawned() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CInfoWorldLayer", "m_pOutputOnEntitiesSpawned"));
    return value;
}
void GCInfoWorldLayer::SetOutputOnEntitiesSpawned(GCEntityIOOutput value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'OutputOnEntitiesSpawned' is not possible.\n");
}
std::string GCInfoWorldLayer::GetWorldName() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CInfoWorldLayer", "m_worldName").String();
}
void GCInfoWorldLayer::SetWorldName(std::string value) {
    SetSchemaValue(m_ptr, "CInfoWorldLayer", "m_worldName", false, CUtlSymbolLarge(value.c_str()));
}
std::string GCInfoWorldLayer::GetLayerName() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CInfoWorldLayer", "m_layerName").String();
}
void GCInfoWorldLayer::SetLayerName(std::string value) {
    SetSchemaValue(m_ptr, "CInfoWorldLayer", "m_layerName", false, CUtlSymbolLarge(value.c_str()));
}
bool GCInfoWorldLayer::GetWorldLayerVisible() const {
    return GetSchemaValue<bool>(m_ptr, "CInfoWorldLayer", "m_bWorldLayerVisible");
}
void GCInfoWorldLayer::SetWorldLayerVisible(bool value) {
    SetSchemaValue(m_ptr, "CInfoWorldLayer", "m_bWorldLayerVisible", false, value);
}
bool GCInfoWorldLayer::GetEntitiesSpawned() const {
    return GetSchemaValue<bool>(m_ptr, "CInfoWorldLayer", "m_bEntitiesSpawned");
}
void GCInfoWorldLayer::SetEntitiesSpawned(bool value) {
    SetSchemaValue(m_ptr, "CInfoWorldLayer", "m_bEntitiesSpawned", false, value);
}
bool GCInfoWorldLayer::GetCreateAsChildSpawnGroup() const {
    return GetSchemaValue<bool>(m_ptr, "CInfoWorldLayer", "m_bCreateAsChildSpawnGroup");
}
void GCInfoWorldLayer::SetCreateAsChildSpawnGroup(bool value) {
    SetSchemaValue(m_ptr, "CInfoWorldLayer", "m_bCreateAsChildSpawnGroup", false, value);
}
uint32_t GCInfoWorldLayer::GetLayerSpawnGroup() const {
    return GetSchemaValue<uint32_t>(m_ptr, "CInfoWorldLayer", "m_hLayerSpawnGroup");
}
void GCInfoWorldLayer::SetLayerSpawnGroup(uint32_t value) {
    SetSchemaValue(m_ptr, "CInfoWorldLayer", "m_hLayerSpawnGroup", false, value);
}
void* GCInfoWorldLayer::GetPtr() {
    return m_ptr;
}
std::string GCInfoWorldLayer::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCInfoWorldLayer::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseEntity GCInfoWorldLayer::GetParent() const {
    GCBaseEntity value(m_ptr);
    return value;
}
void GCInfoWorldLayer::SetParent(GCBaseEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCInfoWorldLayer(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCInfoWorldLayer>("CInfoWorldLayer")
        .addConstructor<void (*)(std::string)>()
        .addProperty("OutputOnEntitiesSpawned", &GCInfoWorldLayer::GetOutputOnEntitiesSpawned, &GCInfoWorldLayer::SetOutputOnEntitiesSpawned)
        .addProperty("WorldName", &GCInfoWorldLayer::GetWorldName, &GCInfoWorldLayer::SetWorldName)
        .addProperty("LayerName", &GCInfoWorldLayer::GetLayerName, &GCInfoWorldLayer::SetLayerName)
        .addProperty("WorldLayerVisible", &GCInfoWorldLayer::GetWorldLayerVisible, &GCInfoWorldLayer::SetWorldLayerVisible)
        .addProperty("EntitiesSpawned", &GCInfoWorldLayer::GetEntitiesSpawned, &GCInfoWorldLayer::SetEntitiesSpawned)
        .addProperty("CreateAsChildSpawnGroup", &GCInfoWorldLayer::GetCreateAsChildSpawnGroup, &GCInfoWorldLayer::SetCreateAsChildSpawnGroup)
        .addProperty("LayerSpawnGroup", &GCInfoWorldLayer::GetLayerSpawnGroup, &GCInfoWorldLayer::SetLayerSpawnGroup)
        .addProperty("Parent", &GCInfoWorldLayer::GetParent, &GCInfoWorldLayer::SetParent)
        .addFunction("ToPtr", &GCInfoWorldLayer::ToPtr)
        .addFunction("IsValid", &GCInfoWorldLayer::IsValid)
        .endClass();
}
GCRectLight::GCRectLight(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCRectLight::GCRectLight(void *ptr) {
    m_ptr = ptr;
}
bool GCRectLight::GetShowLight() const {
    return GetSchemaValue<bool>(m_ptr, "CRectLight", "m_bShowLight");
}
void GCRectLight::SetShowLight(bool value) {
    SetSchemaValue(m_ptr, "CRectLight", "m_bShowLight", false, value);
}
void* GCRectLight::GetPtr() {
    return m_ptr;
}
std::string GCRectLight::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCRectLight::IsValid() {
    return (m_ptr != nullptr);
}
GCBarnLight GCRectLight::GetParent() const {
    GCBarnLight value(m_ptr);
    return value;
}
void GCRectLight::SetParent(GCBarnLight value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCRectLight(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCRectLight>("CRectLight")
        .addConstructor<void (*)(std::string)>()
        .addProperty("ShowLight", &GCRectLight::GetShowLight, &GCRectLight::SetShowLight)
        .addProperty("Parent", &GCRectLight::GetParent, &GCRectLight::SetParent)
        .addFunction("ToPtr", &GCRectLight::ToPtr)
        .addFunction("IsValid", &GCRectLight::IsValid)
        .endClass();
}
GCCSGO_TeamSelectCharacterPosition::GCCSGO_TeamSelectCharacterPosition(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCCSGO_TeamSelectCharacterPosition::GCCSGO_TeamSelectCharacterPosition(void *ptr) {
    m_ptr = ptr;
}
void* GCCSGO_TeamSelectCharacterPosition::GetPtr() {
    return m_ptr;
}
std::string GCCSGO_TeamSelectCharacterPosition::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCCSGO_TeamSelectCharacterPosition::IsValid() {
    return (m_ptr != nullptr);
}
GCCSGO_TeamPreviewCharacterPosition GCCSGO_TeamSelectCharacterPosition::GetParent() const {
    GCCSGO_TeamPreviewCharacterPosition value(m_ptr);
    return value;
}
void GCCSGO_TeamSelectCharacterPosition::SetParent(GCCSGO_TeamPreviewCharacterPosition value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCCSGO_TeamSelectCharacterPosition(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCCSGO_TeamSelectCharacterPosition>("CCSGO_TeamSelectCharacterPosition")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCCSGO_TeamSelectCharacterPosition::GetParent, &GCCSGO_TeamSelectCharacterPosition::SetParent)
        .addFunction("ToPtr", &GCCSGO_TeamSelectCharacterPosition::ToPtr)
        .addFunction("IsValid", &GCCSGO_TeamSelectCharacterPosition::IsValid)
        .endClass();
}
GCBaseDoor::GCBaseDoor(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCBaseDoor::GCBaseDoor(void *ptr) {
    m_ptr = ptr;
}
QAngle GCBaseDoor::GetMoveEntitySpace() const {
    return GetSchemaValue<QAngle>(m_ptr, "CBaseDoor", "m_angMoveEntitySpace");
}
void GCBaseDoor::SetMoveEntitySpace(QAngle value) {
    SetSchemaValue(m_ptr, "CBaseDoor", "m_angMoveEntitySpace", false, value);
}
Vector GCBaseDoor::GetMoveDirParentSpace() const {
    return GetSchemaValue<Vector>(m_ptr, "CBaseDoor", "m_vecMoveDirParentSpace");
}
void GCBaseDoor::SetMoveDirParentSpace(Vector value) {
    SetSchemaValue(m_ptr, "CBaseDoor", "m_vecMoveDirParentSpace", false, value);
}
Glocksound_t GCBaseDoor::GetLs() const {
    Glocksound_t value(GetSchemaPtr(m_ptr, "CBaseDoor", "m_ls"));
    return value;
}
void GCBaseDoor::SetLs(Glocksound_t value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Ls' is not possible.\n");
}
bool GCBaseDoor::GetForceClosed() const {
    return GetSchemaValue<bool>(m_ptr, "CBaseDoor", "m_bForceClosed");
}
void GCBaseDoor::SetForceClosed(bool value) {
    SetSchemaValue(m_ptr, "CBaseDoor", "m_bForceClosed", false, value);
}
bool GCBaseDoor::GetDoorGroup() const {
    return GetSchemaValue<bool>(m_ptr, "CBaseDoor", "m_bDoorGroup");
}
void GCBaseDoor::SetDoorGroup(bool value) {
    SetSchemaValue(m_ptr, "CBaseDoor", "m_bDoorGroup", false, value);
}
bool GCBaseDoor::GetLocked() const {
    return GetSchemaValue<bool>(m_ptr, "CBaseDoor", "m_bLocked");
}
void GCBaseDoor::SetLocked(bool value) {
    SetSchemaValue(m_ptr, "CBaseDoor", "m_bLocked", false, value);
}
bool GCBaseDoor::GetIgnoreDebris() const {
    return GetSchemaValue<bool>(m_ptr, "CBaseDoor", "m_bIgnoreDebris");
}
void GCBaseDoor::SetIgnoreDebris(bool value) {
    SetSchemaValue(m_ptr, "CBaseDoor", "m_bIgnoreDebris", false, value);
}
uint64_t GCBaseDoor::GetSpawnPosition() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CBaseDoor", "m_eSpawnPosition");
}
void GCBaseDoor::SetSpawnPosition(uint64_t value) {
    SetSchemaValue(m_ptr, "CBaseDoor", "m_eSpawnPosition", false, value);
}
float GCBaseDoor::GetBlockDamage() const {
    return GetSchemaValue<float>(m_ptr, "CBaseDoor", "m_flBlockDamage");
}
void GCBaseDoor::SetBlockDamage(float value) {
    SetSchemaValue(m_ptr, "CBaseDoor", "m_flBlockDamage", false, value);
}
std::string GCBaseDoor::GetNoiseMoving() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CBaseDoor", "m_NoiseMoving").String();
}
void GCBaseDoor::SetNoiseMoving(std::string value) {
    SetSchemaValue(m_ptr, "CBaseDoor", "m_NoiseMoving", false, CUtlSymbolLarge(value.c_str()));
}
std::string GCBaseDoor::GetNoiseArrived() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CBaseDoor", "m_NoiseArrived").String();
}
void GCBaseDoor::SetNoiseArrived(std::string value) {
    SetSchemaValue(m_ptr, "CBaseDoor", "m_NoiseArrived", false, CUtlSymbolLarge(value.c_str()));
}
std::string GCBaseDoor::GetNoiseMovingClosed() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CBaseDoor", "m_NoiseMovingClosed").String();
}
void GCBaseDoor::SetNoiseMovingClosed(std::string value) {
    SetSchemaValue(m_ptr, "CBaseDoor", "m_NoiseMovingClosed", false, CUtlSymbolLarge(value.c_str()));
}
std::string GCBaseDoor::GetNoiseArrivedClosed() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CBaseDoor", "m_NoiseArrivedClosed").String();
}
void GCBaseDoor::SetNoiseArrivedClosed(std::string value) {
    SetSchemaValue(m_ptr, "CBaseDoor", "m_NoiseArrivedClosed", false, CUtlSymbolLarge(value.c_str()));
}
std::string GCBaseDoor::GetChainTarget() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CBaseDoor", "m_ChainTarget").String();
}
void GCBaseDoor::SetChainTarget(std::string value) {
    SetSchemaValue(m_ptr, "CBaseDoor", "m_ChainTarget", false, CUtlSymbolLarge(value.c_str()));
}
GCEntityIOOutput GCBaseDoor::GetOnBlockedClosing() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CBaseDoor", "m_OnBlockedClosing"));
    return value;
}
void GCBaseDoor::SetOnBlockedClosing(GCEntityIOOutput value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'OnBlockedClosing' is not possible.\n");
}
GCEntityIOOutput GCBaseDoor::GetOnBlockedOpening() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CBaseDoor", "m_OnBlockedOpening"));
    return value;
}
void GCBaseDoor::SetOnBlockedOpening(GCEntityIOOutput value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'OnBlockedOpening' is not possible.\n");
}
GCEntityIOOutput GCBaseDoor::GetOnUnblockedClosing() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CBaseDoor", "m_OnUnblockedClosing"));
    return value;
}
void GCBaseDoor::SetOnUnblockedClosing(GCEntityIOOutput value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'OnUnblockedClosing' is not possible.\n");
}
GCEntityIOOutput GCBaseDoor::GetOnUnblockedOpening() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CBaseDoor", "m_OnUnblockedOpening"));
    return value;
}
void GCBaseDoor::SetOnUnblockedOpening(GCEntityIOOutput value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'OnUnblockedOpening' is not possible.\n");
}
GCEntityIOOutput GCBaseDoor::GetOnFullyClosed() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CBaseDoor", "m_OnFullyClosed"));
    return value;
}
void GCBaseDoor::SetOnFullyClosed(GCEntityIOOutput value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'OnFullyClosed' is not possible.\n");
}
GCEntityIOOutput GCBaseDoor::GetOnFullyOpen() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CBaseDoor", "m_OnFullyOpen"));
    return value;
}
void GCBaseDoor::SetOnFullyOpen(GCEntityIOOutput value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'OnFullyOpen' is not possible.\n");
}
GCEntityIOOutput GCBaseDoor::GetOnClose() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CBaseDoor", "m_OnClose"));
    return value;
}
void GCBaseDoor::SetOnClose(GCEntityIOOutput value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'OnClose' is not possible.\n");
}
GCEntityIOOutput GCBaseDoor::GetOnOpen() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CBaseDoor", "m_OnOpen"));
    return value;
}
void GCBaseDoor::SetOnOpen(GCEntityIOOutput value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'OnOpen' is not possible.\n");
}
GCEntityIOOutput GCBaseDoor::GetOnLockedUse() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CBaseDoor", "m_OnLockedUse"));
    return value;
}
void GCBaseDoor::SetOnLockedUse(GCEntityIOOutput value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'OnLockedUse' is not possible.\n");
}
bool GCBaseDoor::GetLoopMoveSound() const {
    return GetSchemaValue<bool>(m_ptr, "CBaseDoor", "m_bLoopMoveSound");
}
void GCBaseDoor::SetLoopMoveSound(bool value) {
    SetSchemaValue(m_ptr, "CBaseDoor", "m_bLoopMoveSound", false, value);
}
bool GCBaseDoor::GetCreateNavObstacle() const {
    return GetSchemaValue<bool>(m_ptr, "CBaseDoor", "m_bCreateNavObstacle");
}
void GCBaseDoor::SetCreateNavObstacle(bool value) {
    SetSchemaValue(m_ptr, "CBaseDoor", "m_bCreateNavObstacle", false, value);
}
bool GCBaseDoor::GetIsChaining() const {
    return GetSchemaValue<bool>(m_ptr, "CBaseDoor", "m_isChaining");
}
void GCBaseDoor::SetIsChaining(bool value) {
    SetSchemaValue(m_ptr, "CBaseDoor", "m_isChaining", false, value);
}
bool GCBaseDoor::GetIsUsable() const {
    return GetSchemaValue<bool>(m_ptr, "CBaseDoor", "m_bIsUsable");
}
void GCBaseDoor::SetIsUsable(bool value) {
    SetSchemaValue(m_ptr, "CBaseDoor", "m_bIsUsable", false, value);
}
void* GCBaseDoor::GetPtr() {
    return m_ptr;
}
std::string GCBaseDoor::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCBaseDoor::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseToggle GCBaseDoor::GetParent() const {
    GCBaseToggle value(m_ptr);
    return value;
}
void GCBaseDoor::SetParent(GCBaseToggle value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCBaseDoor(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCBaseDoor>("CBaseDoor")
        .addConstructor<void (*)(std::string)>()
        .addProperty("MoveEntitySpace", &GCBaseDoor::GetMoveEntitySpace, &GCBaseDoor::SetMoveEntitySpace)
        .addProperty("MoveDirParentSpace", &GCBaseDoor::GetMoveDirParentSpace, &GCBaseDoor::SetMoveDirParentSpace)
        .addProperty("Ls", &GCBaseDoor::GetLs, &GCBaseDoor::SetLs)
        .addProperty("ForceClosed", &GCBaseDoor::GetForceClosed, &GCBaseDoor::SetForceClosed)
        .addProperty("DoorGroup", &GCBaseDoor::GetDoorGroup, &GCBaseDoor::SetDoorGroup)
        .addProperty("Locked", &GCBaseDoor::GetLocked, &GCBaseDoor::SetLocked)
        .addProperty("IgnoreDebris", &GCBaseDoor::GetIgnoreDebris, &GCBaseDoor::SetIgnoreDebris)
        .addProperty("SpawnPosition", &GCBaseDoor::GetSpawnPosition, &GCBaseDoor::SetSpawnPosition)
        .addProperty("BlockDamage", &GCBaseDoor::GetBlockDamage, &GCBaseDoor::SetBlockDamage)
        .addProperty("NoiseMoving", &GCBaseDoor::GetNoiseMoving, &GCBaseDoor::SetNoiseMoving)
        .addProperty("NoiseArrived", &GCBaseDoor::GetNoiseArrived, &GCBaseDoor::SetNoiseArrived)
        .addProperty("NoiseMovingClosed", &GCBaseDoor::GetNoiseMovingClosed, &GCBaseDoor::SetNoiseMovingClosed)
        .addProperty("NoiseArrivedClosed", &GCBaseDoor::GetNoiseArrivedClosed, &GCBaseDoor::SetNoiseArrivedClosed)
        .addProperty("ChainTarget", &GCBaseDoor::GetChainTarget, &GCBaseDoor::SetChainTarget)
        .addProperty("OnBlockedClosing", &GCBaseDoor::GetOnBlockedClosing, &GCBaseDoor::SetOnBlockedClosing)
        .addProperty("OnBlockedOpening", &GCBaseDoor::GetOnBlockedOpening, &GCBaseDoor::SetOnBlockedOpening)
        .addProperty("OnUnblockedClosing", &GCBaseDoor::GetOnUnblockedClosing, &GCBaseDoor::SetOnUnblockedClosing)
        .addProperty("OnUnblockedOpening", &GCBaseDoor::GetOnUnblockedOpening, &GCBaseDoor::SetOnUnblockedOpening)
        .addProperty("OnFullyClosed", &GCBaseDoor::GetOnFullyClosed, &GCBaseDoor::SetOnFullyClosed)
        .addProperty("OnFullyOpen", &GCBaseDoor::GetOnFullyOpen, &GCBaseDoor::SetOnFullyOpen)
        .addProperty("OnClose", &GCBaseDoor::GetOnClose, &GCBaseDoor::SetOnClose)
        .addProperty("OnOpen", &GCBaseDoor::GetOnOpen, &GCBaseDoor::SetOnOpen)
        .addProperty("OnLockedUse", &GCBaseDoor::GetOnLockedUse, &GCBaseDoor::SetOnLockedUse)
        .addProperty("LoopMoveSound", &GCBaseDoor::GetLoopMoveSound, &GCBaseDoor::SetLoopMoveSound)
        .addProperty("CreateNavObstacle", &GCBaseDoor::GetCreateNavObstacle, &GCBaseDoor::SetCreateNavObstacle)
        .addProperty("IsChaining", &GCBaseDoor::GetIsChaining, &GCBaseDoor::SetIsChaining)
        .addProperty("IsUsable", &GCBaseDoor::GetIsUsable, &GCBaseDoor::SetIsUsable)
        .addProperty("Parent", &GCBaseDoor::GetParent, &GCBaseDoor::SetParent)
        .addFunction("ToPtr", &GCBaseDoor::ToPtr)
        .addFunction("IsValid", &GCBaseDoor::IsValid)
        .endClass();
}
GCLogicLineToEntity::GCLogicLineToEntity(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCLogicLineToEntity::GCLogicLineToEntity(void *ptr) {
    m_ptr = ptr;
}
std::string GCLogicLineToEntity::GetSourceName() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CLogicLineToEntity", "m_SourceName").String();
}
void GCLogicLineToEntity::SetSourceName(std::string value) {
    SetSchemaValue(m_ptr, "CLogicLineToEntity", "m_SourceName", false, CUtlSymbolLarge(value.c_str()));
}
GCBaseEntity GCLogicLineToEntity::GetStartEntity() const {
    GCBaseEntity value((void*)(GetSchemaValue<CHandle<CEntityInstance>>(m_ptr, "CLogicLineToEntity", "m_StartEntity").Get()));
    return value;
}
void GCLogicLineToEntity::SetStartEntity(GCBaseEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'StartEntity' is not possible.\n");
}
GCBaseEntity GCLogicLineToEntity::GetEndEntity() const {
    GCBaseEntity value((void*)(GetSchemaValue<CHandle<CEntityInstance>>(m_ptr, "CLogicLineToEntity", "m_EndEntity").Get()));
    return value;
}
void GCLogicLineToEntity::SetEndEntity(GCBaseEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'EndEntity' is not possible.\n");
}
void* GCLogicLineToEntity::GetPtr() {
    return m_ptr;
}
std::string GCLogicLineToEntity::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCLogicLineToEntity::IsValid() {
    return (m_ptr != nullptr);
}
GCLogicalEntity GCLogicLineToEntity::GetParent() const {
    GCLogicalEntity value(m_ptr);
    return value;
}
void GCLogicLineToEntity::SetParent(GCLogicalEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCLogicLineToEntity(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCLogicLineToEntity>("CLogicLineToEntity")
        .addConstructor<void (*)(std::string)>()
        .addProperty("SourceName", &GCLogicLineToEntity::GetSourceName, &GCLogicLineToEntity::SetSourceName)
        .addProperty("StartEntity", &GCLogicLineToEntity::GetStartEntity, &GCLogicLineToEntity::SetStartEntity)
        .addProperty("EndEntity", &GCLogicLineToEntity::GetEndEntity, &GCLogicLineToEntity::SetEndEntity)
        .addProperty("Parent", &GCLogicLineToEntity::GetParent, &GCLogicLineToEntity::SetParent)
        .addFunction("ToPtr", &GCLogicLineToEntity::ToPtr)
        .addFunction("IsValid", &GCLogicLineToEntity::IsValid)
        .endClass();
}
GCRetakeGameRules::GCRetakeGameRules(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCRetakeGameRules::GCRetakeGameRules(void *ptr) {
    m_ptr = ptr;
}
int32_t GCRetakeGameRules::GetMatchSeed() const {
    return GetSchemaValue<int32_t>(m_ptr, "CRetakeGameRules", "m_nMatchSeed");
}
void GCRetakeGameRules::SetMatchSeed(int32_t value) {
    SetSchemaValue(m_ptr, "CRetakeGameRules", "m_nMatchSeed", false, value);
}
bool GCRetakeGameRules::GetBlockersPresent() const {
    return GetSchemaValue<bool>(m_ptr, "CRetakeGameRules", "m_bBlockersPresent");
}
void GCRetakeGameRules::SetBlockersPresent(bool value) {
    SetSchemaValue(m_ptr, "CRetakeGameRules", "m_bBlockersPresent", false, value);
}
bool GCRetakeGameRules::GetRoundInProgress() const {
    return GetSchemaValue<bool>(m_ptr, "CRetakeGameRules", "m_bRoundInProgress");
}
void GCRetakeGameRules::SetRoundInProgress(bool value) {
    SetSchemaValue(m_ptr, "CRetakeGameRules", "m_bRoundInProgress", false, value);
}
int32_t GCRetakeGameRules::GetFirstSecondHalfRound() const {
    return GetSchemaValue<int32_t>(m_ptr, "CRetakeGameRules", "m_iFirstSecondHalfRound");
}
void GCRetakeGameRules::SetFirstSecondHalfRound(int32_t value) {
    SetSchemaValue(m_ptr, "CRetakeGameRules", "m_iFirstSecondHalfRound", false, value);
}
int32_t GCRetakeGameRules::GetBombSite() const {
    return GetSchemaValue<int32_t>(m_ptr, "CRetakeGameRules", "m_iBombSite");
}
void GCRetakeGameRules::SetBombSite(int32_t value) {
    SetSchemaValue(m_ptr, "CRetakeGameRules", "m_iBombSite", false, value);
}
void* GCRetakeGameRules::GetPtr() {
    return m_ptr;
}
std::string GCRetakeGameRules::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCRetakeGameRules::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCRetakeGameRules(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCRetakeGameRules>("CRetakeGameRules")
        .addConstructor<void (*)(std::string)>()
        .addProperty("MatchSeed", &GCRetakeGameRules::GetMatchSeed, &GCRetakeGameRules::SetMatchSeed)
        .addProperty("BlockersPresent", &GCRetakeGameRules::GetBlockersPresent, &GCRetakeGameRules::SetBlockersPresent)
        .addProperty("RoundInProgress", &GCRetakeGameRules::GetRoundInProgress, &GCRetakeGameRules::SetRoundInProgress)
        .addProperty("FirstSecondHalfRound", &GCRetakeGameRules::GetFirstSecondHalfRound, &GCRetakeGameRules::SetFirstSecondHalfRound)
        .addProperty("BombSite", &GCRetakeGameRules::GetBombSite, &GCRetakeGameRules::SetBombSite)
        .addFunction("ToPtr", &GCRetakeGameRules::ToPtr)
        .addFunction("IsValid", &GCRetakeGameRules::IsValid)
        .endClass();
}
GCCSGameRulesProxy::GCCSGameRulesProxy(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCCSGameRulesProxy::GCCSGameRulesProxy(void *ptr) {
    m_ptr = ptr;
}
GCCSGameRules GCCSGameRulesProxy::GetGameRules() const {
    GCCSGameRules value(*(void**)GetSchemaPtr(m_ptr, "CCSGameRulesProxy", "m_pGameRules"));
    return value;
}
void GCCSGameRulesProxy::SetGameRules(GCCSGameRules value) {
    SetSchemaValue(m_ptr, "CCSGameRulesProxy","m_pGameRules", false, (char*)value.GetPtr());
}
void* GCCSGameRulesProxy::GetPtr() {
    return m_ptr;
}
std::string GCCSGameRulesProxy::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCCSGameRulesProxy::IsValid() {
    return (m_ptr != nullptr);
}
GCGameRulesProxy GCCSGameRulesProxy::GetParent() const {
    GCGameRulesProxy value(m_ptr);
    return value;
}
void GCCSGameRulesProxy::SetParent(GCGameRulesProxy value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCCSGameRulesProxy(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCCSGameRulesProxy>("CCSGameRulesProxy")
        .addConstructor<void (*)(std::string)>()
        .addProperty("GameRules", &GCCSGameRulesProxy::GetGameRules, &GCCSGameRulesProxy::SetGameRules)
        .addProperty("Parent", &GCCSGameRulesProxy::GetParent, &GCCSGameRulesProxy::SetParent)
        .addFunction("ToPtr", &GCCSGameRulesProxy::ToPtr)
        .addFunction("IsValid", &GCCSGameRulesProxy::IsValid)
        .endClass();
}
GCEnvCubemapBox::GCEnvCubemapBox(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCEnvCubemapBox::GCEnvCubemapBox(void *ptr) {
    m_ptr = ptr;
}
void* GCEnvCubemapBox::GetPtr() {
    return m_ptr;
}
std::string GCEnvCubemapBox::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCEnvCubemapBox::IsValid() {
    return (m_ptr != nullptr);
}
GCEnvCubemap GCEnvCubemapBox::GetParent() const {
    GCEnvCubemap value(m_ptr);
    return value;
}
void GCEnvCubemapBox::SetParent(GCEnvCubemap value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCEnvCubemapBox(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCEnvCubemapBox>("CEnvCubemapBox")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCEnvCubemapBox::GetParent, &GCEnvCubemapBox::SetParent)
        .addFunction("ToPtr", &GCEnvCubemapBox::ToPtr)
        .addFunction("IsValid", &GCEnvCubemapBox::IsValid)
        .endClass();
}
GCCSPlayer_DamageReactServices::GCCSPlayer_DamageReactServices(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCCSPlayer_DamageReactServices::GCCSPlayer_DamageReactServices(void *ptr) {
    m_ptr = ptr;
}
void* GCCSPlayer_DamageReactServices::GetPtr() {
    return m_ptr;
}
std::string GCCSPlayer_DamageReactServices::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCCSPlayer_DamageReactServices::IsValid() {
    return (m_ptr != nullptr);
}
GCPlayerPawnComponent GCCSPlayer_DamageReactServices::GetParent() const {
    GCPlayerPawnComponent value(m_ptr);
    return value;
}
void GCCSPlayer_DamageReactServices::SetParent(GCPlayerPawnComponent value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCCSPlayer_DamageReactServices(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCCSPlayer_DamageReactServices>("CCSPlayer_DamageReactServices")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCCSPlayer_DamageReactServices::GetParent, &GCCSPlayer_DamageReactServices::SetParent)
        .addFunction("ToPtr", &GCCSPlayer_DamageReactServices::ToPtr)
        .addFunction("IsValid", &GCCSPlayer_DamageReactServices::IsValid)
        .endClass();
}
GServerAuthoritativeWeaponSlot_t::GServerAuthoritativeWeaponSlot_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GServerAuthoritativeWeaponSlot_t::GServerAuthoritativeWeaponSlot_t(void *ptr) {
    m_ptr = ptr;
}
uint16_t GServerAuthoritativeWeaponSlot_t::GetClass() const {
    return GetSchemaValue<uint16_t>(m_ptr, "ServerAuthoritativeWeaponSlot_t", "unClass");
}
void GServerAuthoritativeWeaponSlot_t::SetClass(uint16_t value) {
    SetSchemaValue(m_ptr, "ServerAuthoritativeWeaponSlot_t", "unClass", true, value);
}
uint16_t GServerAuthoritativeWeaponSlot_t::GetSlot() const {
    return GetSchemaValue<uint16_t>(m_ptr, "ServerAuthoritativeWeaponSlot_t", "unSlot");
}
void GServerAuthoritativeWeaponSlot_t::SetSlot(uint16_t value) {
    SetSchemaValue(m_ptr, "ServerAuthoritativeWeaponSlot_t", "unSlot", true, value);
}
uint16_t GServerAuthoritativeWeaponSlot_t::GetItemDefIdx() const {
    return GetSchemaValue<uint16_t>(m_ptr, "ServerAuthoritativeWeaponSlot_t", "unItemDefIdx");
}
void GServerAuthoritativeWeaponSlot_t::SetItemDefIdx(uint16_t value) {
    SetSchemaValue(m_ptr, "ServerAuthoritativeWeaponSlot_t", "unItemDefIdx", true, value);
}
void* GServerAuthoritativeWeaponSlot_t::GetPtr() {
    return m_ptr;
}
std::string GServerAuthoritativeWeaponSlot_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GServerAuthoritativeWeaponSlot_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassServerAuthoritativeWeaponSlot_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GServerAuthoritativeWeaponSlot_t>("ServerAuthoritativeWeaponSlot_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Class", &GServerAuthoritativeWeaponSlot_t::GetClass, &GServerAuthoritativeWeaponSlot_t::SetClass)
        .addProperty("Slot", &GServerAuthoritativeWeaponSlot_t::GetSlot, &GServerAuthoritativeWeaponSlot_t::SetSlot)
        .addProperty("ItemDefIdx", &GServerAuthoritativeWeaponSlot_t::GetItemDefIdx, &GServerAuthoritativeWeaponSlot_t::SetItemDefIdx)
        .addFunction("ToPtr", &GServerAuthoritativeWeaponSlot_t::ToPtr)
        .addFunction("IsValid", &GServerAuthoritativeWeaponSlot_t::IsValid)
        .endClass();
}
GCCSGameRules::GCCSGameRules(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCCSGameRules::GCCSGameRules(void *ptr) {
    m_ptr = ptr;
}
bool GCCSGameRules::GetFreezePeriod() const {
    return GetSchemaValue<bool>(m_ptr, "CCSGameRules", "m_bFreezePeriod");
}
void GCCSGameRules::SetFreezePeriod(bool value) {
    SetSchemaValue(m_ptr, "CCSGameRules", "m_bFreezePeriod", false, value);
}
bool GCCSGameRules::GetWarmupPeriod() const {
    return GetSchemaValue<bool>(m_ptr, "CCSGameRules", "m_bWarmupPeriod");
}
void GCCSGameRules::SetWarmupPeriod(bool value) {
    SetSchemaValue(m_ptr, "CCSGameRules", "m_bWarmupPeriod", false, value);
}
float GCCSGameRules::GetWarmupPeriodEnd() const {
    return GetSchemaValue<float>(m_ptr, "CCSGameRules", "m_fWarmupPeriodEnd");
}
void GCCSGameRules::SetWarmupPeriodEnd(float value) {
    SetSchemaValue(m_ptr, "CCSGameRules", "m_fWarmupPeriodEnd", false, value);
}
float GCCSGameRules::GetWarmupPeriodStart() const {
    return GetSchemaValue<float>(m_ptr, "CCSGameRules", "m_fWarmupPeriodStart");
}
void GCCSGameRules::SetWarmupPeriodStart(float value) {
    SetSchemaValue(m_ptr, "CCSGameRules", "m_fWarmupPeriodStart", false, value);
}
bool GCCSGameRules::GetServerPaused() const {
    return GetSchemaValue<bool>(m_ptr, "CCSGameRules", "m_bServerPaused");
}
void GCCSGameRules::SetServerPaused(bool value) {
    SetSchemaValue(m_ptr, "CCSGameRules", "m_bServerPaused", false, value);
}
bool GCCSGameRules::GetTerroristTimeOutActive() const {
    return GetSchemaValue<bool>(m_ptr, "CCSGameRules", "m_bTerroristTimeOutActive");
}
void GCCSGameRules::SetTerroristTimeOutActive(bool value) {
    SetSchemaValue(m_ptr, "CCSGameRules", "m_bTerroristTimeOutActive", false, value);
}
bool GCCSGameRules::GetCTTimeOutActive() const {
    return GetSchemaValue<bool>(m_ptr, "CCSGameRules", "m_bCTTimeOutActive");
}
void GCCSGameRules::SetCTTimeOutActive(bool value) {
    SetSchemaValue(m_ptr, "CCSGameRules", "m_bCTTimeOutActive", false, value);
}
float GCCSGameRules::GetTerroristTimeOutRemaining() const {
    return GetSchemaValue<float>(m_ptr, "CCSGameRules", "m_flTerroristTimeOutRemaining");
}
void GCCSGameRules::SetTerroristTimeOutRemaining(float value) {
    SetSchemaValue(m_ptr, "CCSGameRules", "m_flTerroristTimeOutRemaining", false, value);
}
float GCCSGameRules::GetCTTimeOutRemaining() const {
    return GetSchemaValue<float>(m_ptr, "CCSGameRules", "m_flCTTimeOutRemaining");
}
void GCCSGameRules::SetCTTimeOutRemaining(float value) {
    SetSchemaValue(m_ptr, "CCSGameRules", "m_flCTTimeOutRemaining", false, value);
}
int32_t GCCSGameRules::GetTerroristTimeOuts() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSGameRules", "m_nTerroristTimeOuts");
}
void GCCSGameRules::SetTerroristTimeOuts(int32_t value) {
    SetSchemaValue(m_ptr, "CCSGameRules", "m_nTerroristTimeOuts", false, value);
}
int32_t GCCSGameRules::GetCTTimeOuts() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSGameRules", "m_nCTTimeOuts");
}
void GCCSGameRules::SetCTTimeOuts(int32_t value) {
    SetSchemaValue(m_ptr, "CCSGameRules", "m_nCTTimeOuts", false, value);
}
bool GCCSGameRules::GetTechnicalTimeOut() const {
    return GetSchemaValue<bool>(m_ptr, "CCSGameRules", "m_bTechnicalTimeOut");
}
void GCCSGameRules::SetTechnicalTimeOut(bool value) {
    SetSchemaValue(m_ptr, "CCSGameRules", "m_bTechnicalTimeOut", false, value);
}
bool GCCSGameRules::GetMatchWaitingForResume() const {
    return GetSchemaValue<bool>(m_ptr, "CCSGameRules", "m_bMatchWaitingForResume");
}
void GCCSGameRules::SetMatchWaitingForResume(bool value) {
    SetSchemaValue(m_ptr, "CCSGameRules", "m_bMatchWaitingForResume", false, value);
}
int32_t GCCSGameRules::GetRoundTime() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSGameRules", "m_iRoundTime");
}
void GCCSGameRules::SetRoundTime(int32_t value) {
    SetSchemaValue(m_ptr, "CCSGameRules", "m_iRoundTime", false, value);
}
float GCCSGameRules::GetMatchStartTime() const {
    return GetSchemaValue<float>(m_ptr, "CCSGameRules", "m_fMatchStartTime");
}
void GCCSGameRules::SetMatchStartTime(float value) {
    SetSchemaValue(m_ptr, "CCSGameRules", "m_fMatchStartTime", false, value);
}
float GCCSGameRules::GetRoundStartTime() const {
    return GetSchemaValue<float>(m_ptr, "CCSGameRules", "m_fRoundStartTime");
}
void GCCSGameRules::SetRoundStartTime(float value) {
    SetSchemaValue(m_ptr, "CCSGameRules", "m_fRoundStartTime", false, value);
}
float GCCSGameRules::GetRestartRoundTime() const {
    return GetSchemaValue<float>(m_ptr, "CCSGameRules", "m_flRestartRoundTime");
}
void GCCSGameRules::SetRestartRoundTime(float value) {
    SetSchemaValue(m_ptr, "CCSGameRules", "m_flRestartRoundTime", false, value);
}
bool GCCSGameRules::GetGameRestart() const {
    return GetSchemaValue<bool>(m_ptr, "CCSGameRules", "m_bGameRestart");
}
void GCCSGameRules::SetGameRestart(bool value) {
    SetSchemaValue(m_ptr, "CCSGameRules", "m_bGameRestart", false, value);
}
float GCCSGameRules::GetGameStartTime() const {
    return GetSchemaValue<float>(m_ptr, "CCSGameRules", "m_flGameStartTime");
}
void GCCSGameRules::SetGameStartTime(float value) {
    SetSchemaValue(m_ptr, "CCSGameRules", "m_flGameStartTime", false, value);
}
float GCCSGameRules::GetTimeUntilNextPhaseStarts() const {
    return GetSchemaValue<float>(m_ptr, "CCSGameRules", "m_timeUntilNextPhaseStarts");
}
void GCCSGameRules::SetTimeUntilNextPhaseStarts(float value) {
    SetSchemaValue(m_ptr, "CCSGameRules", "m_timeUntilNextPhaseStarts", false, value);
}
int32_t GCCSGameRules::GetGamePhase() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSGameRules", "m_gamePhase");
}
void GCCSGameRules::SetGamePhase(int32_t value) {
    SetSchemaValue(m_ptr, "CCSGameRules", "m_gamePhase", false, value);
}
int32_t GCCSGameRules::GetTotalRoundsPlayed() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSGameRules", "m_totalRoundsPlayed");
}
void GCCSGameRules::SetTotalRoundsPlayed(int32_t value) {
    SetSchemaValue(m_ptr, "CCSGameRules", "m_totalRoundsPlayed", false, value);
}
int32_t GCCSGameRules::GetRoundsPlayedThisPhase() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSGameRules", "m_nRoundsPlayedThisPhase");
}
void GCCSGameRules::SetRoundsPlayedThisPhase(int32_t value) {
    SetSchemaValue(m_ptr, "CCSGameRules", "m_nRoundsPlayedThisPhase", false, value);
}
int32_t GCCSGameRules::GetOvertimePlaying() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSGameRules", "m_nOvertimePlaying");
}
void GCCSGameRules::SetOvertimePlaying(int32_t value) {
    SetSchemaValue(m_ptr, "CCSGameRules", "m_nOvertimePlaying", false, value);
}
int32_t GCCSGameRules::GetHostagesRemaining() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSGameRules", "m_iHostagesRemaining");
}
void GCCSGameRules::SetHostagesRemaining(int32_t value) {
    SetSchemaValue(m_ptr, "CCSGameRules", "m_iHostagesRemaining", false, value);
}
bool GCCSGameRules::GetAnyHostageReached() const {
    return GetSchemaValue<bool>(m_ptr, "CCSGameRules", "m_bAnyHostageReached");
}
void GCCSGameRules::SetAnyHostageReached(bool value) {
    SetSchemaValue(m_ptr, "CCSGameRules", "m_bAnyHostageReached", false, value);
}
bool GCCSGameRules::GetMapHasBombTarget() const {
    return GetSchemaValue<bool>(m_ptr, "CCSGameRules", "m_bMapHasBombTarget");
}
void GCCSGameRules::SetMapHasBombTarget(bool value) {
    SetSchemaValue(m_ptr, "CCSGameRules", "m_bMapHasBombTarget", false, value);
}
bool GCCSGameRules::GetMapHasRescueZone() const {
    return GetSchemaValue<bool>(m_ptr, "CCSGameRules", "m_bMapHasRescueZone");
}
void GCCSGameRules::SetMapHasRescueZone(bool value) {
    SetSchemaValue(m_ptr, "CCSGameRules", "m_bMapHasRescueZone", false, value);
}
bool GCCSGameRules::GetMapHasBuyZone() const {
    return GetSchemaValue<bool>(m_ptr, "CCSGameRules", "m_bMapHasBuyZone");
}
void GCCSGameRules::SetMapHasBuyZone(bool value) {
    SetSchemaValue(m_ptr, "CCSGameRules", "m_bMapHasBuyZone", false, value);
}
bool GCCSGameRules::GetIsQueuedMatchmaking() const {
    return GetSchemaValue<bool>(m_ptr, "CCSGameRules", "m_bIsQueuedMatchmaking");
}
void GCCSGameRules::SetIsQueuedMatchmaking(bool value) {
    SetSchemaValue(m_ptr, "CCSGameRules", "m_bIsQueuedMatchmaking", false, value);
}
int32_t GCCSGameRules::GetQueuedMatchmakingMode() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSGameRules", "m_nQueuedMatchmakingMode");
}
void GCCSGameRules::SetQueuedMatchmakingMode(int32_t value) {
    SetSchemaValue(m_ptr, "CCSGameRules", "m_nQueuedMatchmakingMode", false, value);
}
bool GCCSGameRules::GetIsValveDS() const {
    return GetSchemaValue<bool>(m_ptr, "CCSGameRules", "m_bIsValveDS");
}
void GCCSGameRules::SetIsValveDS(bool value) {
    SetSchemaValue(m_ptr, "CCSGameRules", "m_bIsValveDS", false, value);
}
bool GCCSGameRules::GetLogoMap() const {
    return GetSchemaValue<bool>(m_ptr, "CCSGameRules", "m_bLogoMap");
}
void GCCSGameRules::SetLogoMap(bool value) {
    SetSchemaValue(m_ptr, "CCSGameRules", "m_bLogoMap", false, value);
}
bool GCCSGameRules::GetPlayAllStepSoundsOnServer() const {
    return GetSchemaValue<bool>(m_ptr, "CCSGameRules", "m_bPlayAllStepSoundsOnServer");
}
void GCCSGameRules::SetPlayAllStepSoundsOnServer(bool value) {
    SetSchemaValue(m_ptr, "CCSGameRules", "m_bPlayAllStepSoundsOnServer", false, value);
}
int32_t GCCSGameRules::GetSpectatorSlotCount() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSGameRules", "m_iSpectatorSlotCount");
}
void GCCSGameRules::SetSpectatorSlotCount(int32_t value) {
    SetSchemaValue(m_ptr, "CCSGameRules", "m_iSpectatorSlotCount", false, value);
}
int32_t GCCSGameRules::GetMatchDevice() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSGameRules", "m_MatchDevice");
}
void GCCSGameRules::SetMatchDevice(int32_t value) {
    SetSchemaValue(m_ptr, "CCSGameRules", "m_MatchDevice", false, value);
}
bool GCCSGameRules::GetHasMatchStarted() const {
    return GetSchemaValue<bool>(m_ptr, "CCSGameRules", "m_bHasMatchStarted");
}
void GCCSGameRules::SetHasMatchStarted(bool value) {
    SetSchemaValue(m_ptr, "CCSGameRules", "m_bHasMatchStarted", false, value);
}
int32_t GCCSGameRules::GetNextMapInMapgroup() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSGameRules", "m_nNextMapInMapgroup");
}
void GCCSGameRules::SetNextMapInMapgroup(int32_t value) {
    SetSchemaValue(m_ptr, "CCSGameRules", "m_nNextMapInMapgroup", false, value);
}
std::string GCCSGameRules::GetTournamentEventName() const {
    return GetSchemaValuePtr<char>(m_ptr, "CCSGameRules", "m_szTournamentEventName");
}
void GCCSGameRules::SetTournamentEventName(std::string value) {
    WriteSchemaPtrValue(m_ptr, "CCSGameRules", "m_szTournamentEventName", false, reinterpret_cast<byte*>(const_cast<char*>(value.c_str())), 512);
}
std::string GCCSGameRules::GetTournamentEventStage() const {
    return GetSchemaValuePtr<char>(m_ptr, "CCSGameRules", "m_szTournamentEventStage");
}
void GCCSGameRules::SetTournamentEventStage(std::string value) {
    WriteSchemaPtrValue(m_ptr, "CCSGameRules", "m_szTournamentEventStage", false, reinterpret_cast<byte*>(const_cast<char*>(value.c_str())), 512);
}
std::string GCCSGameRules::GetMatchStatTxt() const {
    return GetSchemaValuePtr<char>(m_ptr, "CCSGameRules", "m_szMatchStatTxt");
}
void GCCSGameRules::SetMatchStatTxt(std::string value) {
    WriteSchemaPtrValue(m_ptr, "CCSGameRules", "m_szMatchStatTxt", false, reinterpret_cast<byte*>(const_cast<char*>(value.c_str())), 512);
}
std::string GCCSGameRules::GetTournamentPredictionsTxt() const {
    return GetSchemaValuePtr<char>(m_ptr, "CCSGameRules", "m_szTournamentPredictionsTxt");
}
void GCCSGameRules::SetTournamentPredictionsTxt(std::string value) {
    WriteSchemaPtrValue(m_ptr, "CCSGameRules", "m_szTournamentPredictionsTxt", false, reinterpret_cast<byte*>(const_cast<char*>(value.c_str())), 512);
}
int32_t GCCSGameRules::GetTournamentPredictionsPct() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSGameRules", "m_nTournamentPredictionsPct");
}
void GCCSGameRules::SetTournamentPredictionsPct(int32_t value) {
    SetSchemaValue(m_ptr, "CCSGameRules", "m_nTournamentPredictionsPct", false, value);
}
float GCCSGameRules::GetCMMItemDropRevealStartTime() const {
    return GetSchemaValue<float>(m_ptr, "CCSGameRules", "m_flCMMItemDropRevealStartTime");
}
void GCCSGameRules::SetCMMItemDropRevealStartTime(float value) {
    SetSchemaValue(m_ptr, "CCSGameRules", "m_flCMMItemDropRevealStartTime", false, value);
}
float GCCSGameRules::GetCMMItemDropRevealEndTime() const {
    return GetSchemaValue<float>(m_ptr, "CCSGameRules", "m_flCMMItemDropRevealEndTime");
}
void GCCSGameRules::SetCMMItemDropRevealEndTime(float value) {
    SetSchemaValue(m_ptr, "CCSGameRules", "m_flCMMItemDropRevealEndTime", false, value);
}
bool GCCSGameRules::GetIsDroppingItems() const {
    return GetSchemaValue<bool>(m_ptr, "CCSGameRules", "m_bIsDroppingItems");
}
void GCCSGameRules::SetIsDroppingItems(bool value) {
    SetSchemaValue(m_ptr, "CCSGameRules", "m_bIsDroppingItems", false, value);
}
bool GCCSGameRules::GetIsQuestEligible() const {
    return GetSchemaValue<bool>(m_ptr, "CCSGameRules", "m_bIsQuestEligible");
}
void GCCSGameRules::SetIsQuestEligible(bool value) {
    SetSchemaValue(m_ptr, "CCSGameRules", "m_bIsQuestEligible", false, value);
}
bool GCCSGameRules::GetIsHltvActive() const {
    return GetSchemaValue<bool>(m_ptr, "CCSGameRules", "m_bIsHltvActive");
}
void GCCSGameRules::SetIsHltvActive(bool value) {
    SetSchemaValue(m_ptr, "CCSGameRules", "m_bIsHltvActive", false, value);
}
std::vector<uint16_t> GCCSGameRules::GetProhibitedItemIndices() const {
    uint16_t* outValue = (uint16_t*)GetSchemaPtr(m_ptr, "CCSGameRules", "m_arrProhibitedItemIndices"); std::vector<uint16_t> ret; for(int i = 0; i < 100; i++) { ret.push_back(outValue[i]); } return ret;
}
void GCCSGameRules::SetProhibitedItemIndices(std::vector<uint16_t> value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'ProhibitedItemIndices' is not possible.\n");
}
std::vector<uint32_t> GCCSGameRules::GetTournamentActiveCasterAccounts() const {
    uint32_t* outValue = (uint32_t*)GetSchemaPtr(m_ptr, "CCSGameRules", "m_arrTournamentActiveCasterAccounts"); std::vector<uint32_t> ret; for(int i = 0; i < 4; i++) { ret.push_back(outValue[i]); } return ret;
}
void GCCSGameRules::SetTournamentActiveCasterAccounts(std::vector<uint32_t> value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'TournamentActiveCasterAccounts' is not possible.\n");
}
int32_t GCCSGameRules::GetNumBestOfMaps() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSGameRules", "m_numBestOfMaps");
}
void GCCSGameRules::SetNumBestOfMaps(int32_t value) {
    SetSchemaValue(m_ptr, "CCSGameRules", "m_numBestOfMaps", false, value);
}
int32_t GCCSGameRules::GetHalloweenMaskListSeed() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSGameRules", "m_nHalloweenMaskListSeed");
}
void GCCSGameRules::SetHalloweenMaskListSeed(int32_t value) {
    SetSchemaValue(m_ptr, "CCSGameRules", "m_nHalloweenMaskListSeed", false, value);
}
bool GCCSGameRules::GetBombDropped() const {
    return GetSchemaValue<bool>(m_ptr, "CCSGameRules", "m_bBombDropped");
}
void GCCSGameRules::SetBombDropped(bool value) {
    SetSchemaValue(m_ptr, "CCSGameRules", "m_bBombDropped", false, value);
}
bool GCCSGameRules::GetBombPlanted() const {
    return GetSchemaValue<bool>(m_ptr, "CCSGameRules", "m_bBombPlanted");
}
void GCCSGameRules::SetBombPlanted(bool value) {
    SetSchemaValue(m_ptr, "CCSGameRules", "m_bBombPlanted", false, value);
}
int32_t GCCSGameRules::GetRoundWinStatus() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSGameRules", "m_iRoundWinStatus");
}
void GCCSGameRules::SetRoundWinStatus(int32_t value) {
    SetSchemaValue(m_ptr, "CCSGameRules", "m_iRoundWinStatus", false, value);
}
int32_t GCCSGameRules::GetRoundWinReason() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSGameRules", "m_eRoundWinReason");
}
void GCCSGameRules::SetRoundWinReason(int32_t value) {
    SetSchemaValue(m_ptr, "CCSGameRules", "m_eRoundWinReason", false, value);
}
bool GCCSGameRules::GetTCantBuy() const {
    return GetSchemaValue<bool>(m_ptr, "CCSGameRules", "m_bTCantBuy");
}
void GCCSGameRules::SetTCantBuy(bool value) {
    SetSchemaValue(m_ptr, "CCSGameRules", "m_bTCantBuy", false, value);
}
bool GCCSGameRules::GetCTCantBuy() const {
    return GetSchemaValue<bool>(m_ptr, "CCSGameRules", "m_bCTCantBuy");
}
void GCCSGameRules::SetCTCantBuy(bool value) {
    SetSchemaValue(m_ptr, "CCSGameRules", "m_bCTCantBuy", false, value);
}
std::vector<int32_t> GCCSGameRules::GetMatchStats_RoundResults() const {
    int32_t* outValue = (int32_t*)GetSchemaPtr(m_ptr, "CCSGameRules", "m_iMatchStats_RoundResults"); std::vector<int32_t> ret; for(int i = 0; i < 30; i++) { ret.push_back(outValue[i]); } return ret;
}
void GCCSGameRules::SetMatchStats_RoundResults(std::vector<int32_t> value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'MatchStats_RoundResults' is not possible.\n");
}
std::vector<int32_t> GCCSGameRules::GetMatchStats_PlayersAlive_CT() const {
    int32_t* outValue = (int32_t*)GetSchemaPtr(m_ptr, "CCSGameRules", "m_iMatchStats_PlayersAlive_CT"); std::vector<int32_t> ret; for(int i = 0; i < 30; i++) { ret.push_back(outValue[i]); } return ret;
}
void GCCSGameRules::SetMatchStats_PlayersAlive_CT(std::vector<int32_t> value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'MatchStats_PlayersAlive_CT' is not possible.\n");
}
std::vector<int32_t> GCCSGameRules::GetMatchStats_PlayersAlive_T() const {
    int32_t* outValue = (int32_t*)GetSchemaPtr(m_ptr, "CCSGameRules", "m_iMatchStats_PlayersAlive_T"); std::vector<int32_t> ret; for(int i = 0; i < 30; i++) { ret.push_back(outValue[i]); } return ret;
}
void GCCSGameRules::SetMatchStats_PlayersAlive_T(std::vector<int32_t> value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'MatchStats_PlayersAlive_T' is not possible.\n");
}
std::vector<float> GCCSGameRules::GetTeamRespawnWaveTimes() const {
    float* outValue = (float*)GetSchemaPtr(m_ptr, "CCSGameRules", "m_TeamRespawnWaveTimes"); std::vector<float> ret; for(int i = 0; i < 32; i++) { ret.push_back(outValue[i]); } return ret;
}
void GCCSGameRules::SetTeamRespawnWaveTimes(std::vector<float> value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'TeamRespawnWaveTimes' is not possible.\n");
}
std::vector<float> GCCSGameRules::GetNextRespawnWave() const {
    float* outValue = (float*)GetSchemaPtr(m_ptr, "CCSGameRules", "m_flNextRespawnWave"); std::vector<float> ret; for(int i = 0; i < 32; i++) { ret.push_back(outValue[i]); } return ret;
}
void GCCSGameRules::SetNextRespawnWave(std::vector<float> value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'NextRespawnWave' is not possible.\n");
}
int32_t GCCSGameRules::GetServerQuestID() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSGameRules", "m_nServerQuestID");
}
void GCCSGameRules::SetServerQuestID(int32_t value) {
    SetSchemaValue(m_ptr, "CCSGameRules", "m_nServerQuestID", false, value);
}
Vector GCCSGameRules::GetMinimapMins() const {
    return GetSchemaValue<Vector>(m_ptr, "CCSGameRules", "m_vMinimapMins");
}
void GCCSGameRules::SetMinimapMins(Vector value) {
    SetSchemaValue(m_ptr, "CCSGameRules", "m_vMinimapMins", false, value);
}
Vector GCCSGameRules::GetMinimapMaxs() const {
    return GetSchemaValue<Vector>(m_ptr, "CCSGameRules", "m_vMinimapMaxs");
}
void GCCSGameRules::SetMinimapMaxs(Vector value) {
    SetSchemaValue(m_ptr, "CCSGameRules", "m_vMinimapMaxs", false, value);
}
std::vector<float> GCCSGameRules::GetMinimapVerticalSectionHeights() const {
    float* outValue = (float*)GetSchemaPtr(m_ptr, "CCSGameRules", "m_MinimapVerticalSectionHeights"); std::vector<float> ret; for(int i = 0; i < 8; i++) { ret.push_back(outValue[i]); } return ret;
}
void GCCSGameRules::SetMinimapVerticalSectionHeights(std::vector<float> value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'MinimapVerticalSectionHeights' is not possible.\n");
}
bool GCCSGameRules::GetSpawnedTerrorHuntHeavy() const {
    return GetSchemaValue<bool>(m_ptr, "CCSGameRules", "m_bSpawnedTerrorHuntHeavy");
}
void GCCSGameRules::SetSpawnedTerrorHuntHeavy(bool value) {
    SetSchemaValue(m_ptr, "CCSGameRules", "m_bSpawnedTerrorHuntHeavy", false, value);
}
std::vector<int32_t> GCCSGameRules::GetEndMatchMapGroupVoteTypes() const {
    int32_t* outValue = (int32_t*)GetSchemaPtr(m_ptr, "CCSGameRules", "m_nEndMatchMapGroupVoteTypes"); std::vector<int32_t> ret; for(int i = 0; i < 10; i++) { ret.push_back(outValue[i]); } return ret;
}
void GCCSGameRules::SetEndMatchMapGroupVoteTypes(std::vector<int32_t> value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'EndMatchMapGroupVoteTypes' is not possible.\n");
}
std::vector<int32_t> GCCSGameRules::GetEndMatchMapGroupVoteOptions() const {
    int32_t* outValue = (int32_t*)GetSchemaPtr(m_ptr, "CCSGameRules", "m_nEndMatchMapGroupVoteOptions"); std::vector<int32_t> ret; for(int i = 0; i < 10; i++) { ret.push_back(outValue[i]); } return ret;
}
void GCCSGameRules::SetEndMatchMapGroupVoteOptions(std::vector<int32_t> value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'EndMatchMapGroupVoteOptions' is not possible.\n");
}
int32_t GCCSGameRules::GetEndMatchMapVoteWinner() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSGameRules", "m_nEndMatchMapVoteWinner");
}
void GCCSGameRules::SetEndMatchMapVoteWinner(int32_t value) {
    SetSchemaValue(m_ptr, "CCSGameRules", "m_nEndMatchMapVoteWinner", false, value);
}
int32_t GCCSGameRules::GetNumConsecutiveCTLoses() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSGameRules", "m_iNumConsecutiveCTLoses");
}
void GCCSGameRules::SetNumConsecutiveCTLoses(int32_t value) {
    SetSchemaValue(m_ptr, "CCSGameRules", "m_iNumConsecutiveCTLoses", false, value);
}
int32_t GCCSGameRules::GetNumConsecutiveTerroristLoses() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSGameRules", "m_iNumConsecutiveTerroristLoses");
}
void GCCSGameRules::SetNumConsecutiveTerroristLoses(int32_t value) {
    SetSchemaValue(m_ptr, "CCSGameRules", "m_iNumConsecutiveTerroristLoses", false, value);
}
bool GCCSGameRules::GetHasHostageBeenTouched() const {
    return GetSchemaValue<bool>(m_ptr, "CCSGameRules", "m_bHasHostageBeenTouched");
}
void GCCSGameRules::SetHasHostageBeenTouched(bool value) {
    SetSchemaValue(m_ptr, "CCSGameRules", "m_bHasHostageBeenTouched", false, value);
}
float GCCSGameRules::GetIntermissionStartTime() const {
    return GetSchemaValue<float>(m_ptr, "CCSGameRules", "m_flIntermissionStartTime");
}
void GCCSGameRules::SetIntermissionStartTime(float value) {
    SetSchemaValue(m_ptr, "CCSGameRules", "m_flIntermissionStartTime", false, value);
}
float GCCSGameRules::GetIntermissionEndTime() const {
    return GetSchemaValue<float>(m_ptr, "CCSGameRules", "m_flIntermissionEndTime");
}
void GCCSGameRules::SetIntermissionEndTime(float value) {
    SetSchemaValue(m_ptr, "CCSGameRules", "m_flIntermissionEndTime", false, value);
}
bool GCCSGameRules::GetLevelInitialized() const {
    return GetSchemaValue<bool>(m_ptr, "CCSGameRules", "m_bLevelInitialized");
}
void GCCSGameRules::SetLevelInitialized(bool value) {
    SetSchemaValue(m_ptr, "CCSGameRules", "m_bLevelInitialized", false, value);
}
int32_t GCCSGameRules::GetTotalRoundsPlayed1() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSGameRules", "m_iTotalRoundsPlayed");
}
void GCCSGameRules::SetTotalRoundsPlayed1(int32_t value) {
    SetSchemaValue(m_ptr, "CCSGameRules", "m_iTotalRoundsPlayed", false, value);
}
int32_t GCCSGameRules::GetUnBalancedRounds() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSGameRules", "m_iUnBalancedRounds");
}
void GCCSGameRules::SetUnBalancedRounds(int32_t value) {
    SetSchemaValue(m_ptr, "CCSGameRules", "m_iUnBalancedRounds", false, value);
}
bool GCCSGameRules::GetEndMatchOnRoundReset() const {
    return GetSchemaValue<bool>(m_ptr, "CCSGameRules", "m_endMatchOnRoundReset");
}
void GCCSGameRules::SetEndMatchOnRoundReset(bool value) {
    SetSchemaValue(m_ptr, "CCSGameRules", "m_endMatchOnRoundReset", false, value);
}
bool GCCSGameRules::GetEndMatchOnThink() const {
    return GetSchemaValue<bool>(m_ptr, "CCSGameRules", "m_endMatchOnThink");
}
void GCCSGameRules::SetEndMatchOnThink(bool value) {
    SetSchemaValue(m_ptr, "CCSGameRules", "m_endMatchOnThink", false, value);
}
int32_t GCCSGameRules::GetFreezeTime() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSGameRules", "m_iFreezeTime");
}
void GCCSGameRules::SetFreezeTime(int32_t value) {
    SetSchemaValue(m_ptr, "CCSGameRules", "m_iFreezeTime", false, value);
}
int32_t GCCSGameRules::GetNumTerrorist() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSGameRules", "m_iNumTerrorist");
}
void GCCSGameRules::SetNumTerrorist(int32_t value) {
    SetSchemaValue(m_ptr, "CCSGameRules", "m_iNumTerrorist", false, value);
}
int32_t GCCSGameRules::GetNumCT() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSGameRules", "m_iNumCT");
}
void GCCSGameRules::SetNumCT(int32_t value) {
    SetSchemaValue(m_ptr, "CCSGameRules", "m_iNumCT", false, value);
}
int32_t GCCSGameRules::GetNumSpawnableTerrorist() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSGameRules", "m_iNumSpawnableTerrorist");
}
void GCCSGameRules::SetNumSpawnableTerrorist(int32_t value) {
    SetSchemaValue(m_ptr, "CCSGameRules", "m_iNumSpawnableTerrorist", false, value);
}
int32_t GCCSGameRules::GetNumSpawnableCT() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSGameRules", "m_iNumSpawnableCT");
}
void GCCSGameRules::SetNumSpawnableCT(int32_t value) {
    SetSchemaValue(m_ptr, "CCSGameRules", "m_iNumSpawnableCT", false, value);
}
std::vector<int32> GCCSGameRules::GetSelectedHostageSpawnIndices() const {
    CUtlVector<int32>* vec = GetSchemaValue<CUtlVector<int32>*>(m_ptr, "CCSGameRules", "m_arrSelectedHostageSpawnIndices"); std::vector<int32> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCCSGameRules::SetSelectedHostageSpawnIndices(std::vector<int32> value) {
    SetSchemaValueCUtlVector<int32>(m_ptr, "CCSGameRules", "m_arrSelectedHostageSpawnIndices", false, value);
}
int32_t GCCSGameRules::GetSpawnPointsRandomSeed() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSGameRules", "m_nSpawnPointsRandomSeed");
}
void GCCSGameRules::SetSpawnPointsRandomSeed(int32_t value) {
    SetSchemaValue(m_ptr, "CCSGameRules", "m_nSpawnPointsRandomSeed", false, value);
}
bool GCCSGameRules::GetFirstConnected() const {
    return GetSchemaValue<bool>(m_ptr, "CCSGameRules", "m_bFirstConnected");
}
void GCCSGameRules::SetFirstConnected(bool value) {
    SetSchemaValue(m_ptr, "CCSGameRules", "m_bFirstConnected", false, value);
}
bool GCCSGameRules::GetCompleteReset() const {
    return GetSchemaValue<bool>(m_ptr, "CCSGameRules", "m_bCompleteReset");
}
void GCCSGameRules::SetCompleteReset(bool value) {
    SetSchemaValue(m_ptr, "CCSGameRules", "m_bCompleteReset", false, value);
}
bool GCCSGameRules::GetPickNewTeamsOnReset() const {
    return GetSchemaValue<bool>(m_ptr, "CCSGameRules", "m_bPickNewTeamsOnReset");
}
void GCCSGameRules::SetPickNewTeamsOnReset(bool value) {
    SetSchemaValue(m_ptr, "CCSGameRules", "m_bPickNewTeamsOnReset", false, value);
}
bool GCCSGameRules::GetScrambleTeamsOnRestart() const {
    return GetSchemaValue<bool>(m_ptr, "CCSGameRules", "m_bScrambleTeamsOnRestart");
}
void GCCSGameRules::SetScrambleTeamsOnRestart(bool value) {
    SetSchemaValue(m_ptr, "CCSGameRules", "m_bScrambleTeamsOnRestart", false, value);
}
bool GCCSGameRules::GetSwapTeamsOnRestart() const {
    return GetSchemaValue<bool>(m_ptr, "CCSGameRules", "m_bSwapTeamsOnRestart");
}
void GCCSGameRules::SetSwapTeamsOnRestart(bool value) {
    SetSchemaValue(m_ptr, "CCSGameRules", "m_bSwapTeamsOnRestart", false, value);
}
std::vector<int32> GCCSGameRules::GetEndMatchTiedVotes() const {
    CUtlVector<int32>* vec = GetSchemaValue<CUtlVector<int32>*>(m_ptr, "CCSGameRules", "m_nEndMatchTiedVotes"); std::vector<int32> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCCSGameRules::SetEndMatchTiedVotes(std::vector<int32> value) {
    SetSchemaValueCUtlVector<int32>(m_ptr, "CCSGameRules", "m_nEndMatchTiedVotes", false, value);
}
bool GCCSGameRules::GetNeedToAskPlayersForContinueVote() const {
    return GetSchemaValue<bool>(m_ptr, "CCSGameRules", "m_bNeedToAskPlayersForContinueVote");
}
void GCCSGameRules::SetNeedToAskPlayersForContinueVote(bool value) {
    SetSchemaValue(m_ptr, "CCSGameRules", "m_bNeedToAskPlayersForContinueVote", false, value);
}
uint32_t GCCSGameRules::GetNumQueuedMatchmakingAccounts() const {
    return GetSchemaValue<uint32_t>(m_ptr, "CCSGameRules", "m_numQueuedMatchmakingAccounts");
}
void GCCSGameRules::SetNumQueuedMatchmakingAccounts(uint32_t value) {
    SetSchemaValue(m_ptr, "CCSGameRules", "m_numQueuedMatchmakingAccounts", false, value);
}
float GCCSGameRules::GetAvgPlayerRank() const {
    return GetSchemaValue<float>(m_ptr, "CCSGameRules", "m_fAvgPlayerRank");
}
void GCCSGameRules::SetAvgPlayerRank(float value) {
    SetSchemaValue(m_ptr, "CCSGameRules", "m_fAvgPlayerRank", false, value);
}
std::string GCCSGameRules::GetQueuedMatchmakingReservationString() const {
    return GetSchemaValuePtr<char>(m_ptr, "CCSGameRules", "m_pQueuedMatchmakingReservationString");
}
void GCCSGameRules::SetQueuedMatchmakingReservationString(std::string value) {
    WriteSchemaPtrValue(m_ptr, "CCSGameRules", "m_pQueuedMatchmakingReservationString", false, reinterpret_cast<byte*>(const_cast<char*>(value.c_str())), value.size());
}
uint32_t GCCSGameRules::GetNumTotalTournamentDrops() const {
    return GetSchemaValue<uint32_t>(m_ptr, "CCSGameRules", "m_numTotalTournamentDrops");
}
void GCCSGameRules::SetNumTotalTournamentDrops(uint32_t value) {
    SetSchemaValue(m_ptr, "CCSGameRules", "m_numTotalTournamentDrops", false, value);
}
uint32_t GCCSGameRules::GetNumSpectatorsCountMax() const {
    return GetSchemaValue<uint32_t>(m_ptr, "CCSGameRules", "m_numSpectatorsCountMax");
}
void GCCSGameRules::SetNumSpectatorsCountMax(uint32_t value) {
    SetSchemaValue(m_ptr, "CCSGameRules", "m_numSpectatorsCountMax", false, value);
}
uint32_t GCCSGameRules::GetNumSpectatorsCountMaxTV() const {
    return GetSchemaValue<uint32_t>(m_ptr, "CCSGameRules", "m_numSpectatorsCountMaxTV");
}
void GCCSGameRules::SetNumSpectatorsCountMaxTV(uint32_t value) {
    SetSchemaValue(m_ptr, "CCSGameRules", "m_numSpectatorsCountMaxTV", false, value);
}
uint32_t GCCSGameRules::GetNumSpectatorsCountMaxLnk() const {
    return GetSchemaValue<uint32_t>(m_ptr, "CCSGameRules", "m_numSpectatorsCountMaxLnk");
}
void GCCSGameRules::SetNumSpectatorsCountMaxLnk(uint32_t value) {
    SetSchemaValue(m_ptr, "CCSGameRules", "m_numSpectatorsCountMaxLnk", false, value);
}
bool GCCSGameRules::GetForceTeamChangeSilent() const {
    return GetSchemaValue<bool>(m_ptr, "CCSGameRules", "m_bForceTeamChangeSilent");
}
void GCCSGameRules::SetForceTeamChangeSilent(bool value) {
    SetSchemaValue(m_ptr, "CCSGameRules", "m_bForceTeamChangeSilent", false, value);
}
bool GCCSGameRules::GetLoadingRoundBackupData() const {
    return GetSchemaValue<bool>(m_ptr, "CCSGameRules", "m_bLoadingRoundBackupData");
}
void GCCSGameRules::SetLoadingRoundBackupData(bool value) {
    SetSchemaValue(m_ptr, "CCSGameRules", "m_bLoadingRoundBackupData", false, value);
}
int32_t GCCSGameRules::GetMatchInfoShowType() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSGameRules", "m_nMatchInfoShowType");
}
void GCCSGameRules::SetMatchInfoShowType(int32_t value) {
    SetSchemaValue(m_ptr, "CCSGameRules", "m_nMatchInfoShowType", false, value);
}
float GCCSGameRules::GetMatchInfoDecidedTime() const {
    return GetSchemaValue<float>(m_ptr, "CCSGameRules", "m_flMatchInfoDecidedTime");
}
void GCCSGameRules::SetMatchInfoDecidedTime(float value) {
    SetSchemaValue(m_ptr, "CCSGameRules", "m_flMatchInfoDecidedTime", false, value);
}
int32_t GCCSGameRules::GetMTeamDMLastWinningTeamNumber() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSGameRules", "mTeamDMLastWinningTeamNumber");
}
void GCCSGameRules::SetMTeamDMLastWinningTeamNumber(int32_t value) {
    SetSchemaValue(m_ptr, "CCSGameRules", "mTeamDMLastWinningTeamNumber", false, value);
}
float GCCSGameRules::GetMTeamDMLastThinkTime() const {
    return GetSchemaValue<float>(m_ptr, "CCSGameRules", "mTeamDMLastThinkTime");
}
void GCCSGameRules::SetMTeamDMLastThinkTime(float value) {
    SetSchemaValue(m_ptr, "CCSGameRules", "mTeamDMLastThinkTime", false, value);
}
float GCCSGameRules::GetTeamDMLastAnnouncementTime() const {
    return GetSchemaValue<float>(m_ptr, "CCSGameRules", "m_flTeamDMLastAnnouncementTime");
}
void GCCSGameRules::SetTeamDMLastAnnouncementTime(float value) {
    SetSchemaValue(m_ptr, "CCSGameRules", "m_flTeamDMLastAnnouncementTime", false, value);
}
int32_t GCCSGameRules::GetAccountTerrorist() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSGameRules", "m_iAccountTerrorist");
}
void GCCSGameRules::SetAccountTerrorist(int32_t value) {
    SetSchemaValue(m_ptr, "CCSGameRules", "m_iAccountTerrorist", false, value);
}
int32_t GCCSGameRules::GetAccountCT() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSGameRules", "m_iAccountCT");
}
void GCCSGameRules::SetAccountCT(int32_t value) {
    SetSchemaValue(m_ptr, "CCSGameRules", "m_iAccountCT", false, value);
}
int32_t GCCSGameRules::GetSpawnPointCount_Terrorist() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSGameRules", "m_iSpawnPointCount_Terrorist");
}
void GCCSGameRules::SetSpawnPointCount_Terrorist(int32_t value) {
    SetSchemaValue(m_ptr, "CCSGameRules", "m_iSpawnPointCount_Terrorist", false, value);
}
int32_t GCCSGameRules::GetSpawnPointCount_CT() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSGameRules", "m_iSpawnPointCount_CT");
}
void GCCSGameRules::SetSpawnPointCount_CT(int32_t value) {
    SetSchemaValue(m_ptr, "CCSGameRules", "m_iSpawnPointCount_CT", false, value);
}
int32_t GCCSGameRules::GetMaxNumTerrorists() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSGameRules", "m_iMaxNumTerrorists");
}
void GCCSGameRules::SetMaxNumTerrorists(int32_t value) {
    SetSchemaValue(m_ptr, "CCSGameRules", "m_iMaxNumTerrorists", false, value);
}
int32_t GCCSGameRules::GetMaxNumCTs() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSGameRules", "m_iMaxNumCTs");
}
void GCCSGameRules::SetMaxNumCTs(int32_t value) {
    SetSchemaValue(m_ptr, "CCSGameRules", "m_iMaxNumCTs", false, value);
}
int32_t GCCSGameRules::GetLoserBonusMostRecentTeam() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSGameRules", "m_iLoserBonusMostRecentTeam");
}
void GCCSGameRules::SetLoserBonusMostRecentTeam(int32_t value) {
    SetSchemaValue(m_ptr, "CCSGameRules", "m_iLoserBonusMostRecentTeam", false, value);
}
float GCCSGameRules::GetTmNextPeriodicThink() const {
    return GetSchemaValue<float>(m_ptr, "CCSGameRules", "m_tmNextPeriodicThink");
}
void GCCSGameRules::SetTmNextPeriodicThink(float value) {
    SetSchemaValue(m_ptr, "CCSGameRules", "m_tmNextPeriodicThink", false, value);
}
bool GCCSGameRules::GetVoiceWonMatchBragFired() const {
    return GetSchemaValue<bool>(m_ptr, "CCSGameRules", "m_bVoiceWonMatchBragFired");
}
void GCCSGameRules::SetVoiceWonMatchBragFired(bool value) {
    SetSchemaValue(m_ptr, "CCSGameRules", "m_bVoiceWonMatchBragFired", false, value);
}
float GCCSGameRules::GetWarmupNextChatNoticeTime() const {
    return GetSchemaValue<float>(m_ptr, "CCSGameRules", "m_fWarmupNextChatNoticeTime");
}
void GCCSGameRules::SetWarmupNextChatNoticeTime(float value) {
    SetSchemaValue(m_ptr, "CCSGameRules", "m_fWarmupNextChatNoticeTime", false, value);
}
int32_t GCCSGameRules::GetHostagesRescued() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSGameRules", "m_iHostagesRescued");
}
void GCCSGameRules::SetHostagesRescued(int32_t value) {
    SetSchemaValue(m_ptr, "CCSGameRules", "m_iHostagesRescued", false, value);
}
int32_t GCCSGameRules::GetHostagesTouched() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSGameRules", "m_iHostagesTouched");
}
void GCCSGameRules::SetHostagesTouched(int32_t value) {
    SetSchemaValue(m_ptr, "CCSGameRules", "m_iHostagesTouched", false, value);
}
float GCCSGameRules::GetNextHostageAnnouncement() const {
    return GetSchemaValue<float>(m_ptr, "CCSGameRules", "m_flNextHostageAnnouncement");
}
void GCCSGameRules::SetNextHostageAnnouncement(float value) {
    SetSchemaValue(m_ptr, "CCSGameRules", "m_flNextHostageAnnouncement", false, value);
}
bool GCCSGameRules::GetNoTerroristsKilled() const {
    return GetSchemaValue<bool>(m_ptr, "CCSGameRules", "m_bNoTerroristsKilled");
}
void GCCSGameRules::SetNoTerroristsKilled(bool value) {
    SetSchemaValue(m_ptr, "CCSGameRules", "m_bNoTerroristsKilled", false, value);
}
bool GCCSGameRules::GetNoCTsKilled() const {
    return GetSchemaValue<bool>(m_ptr, "CCSGameRules", "m_bNoCTsKilled");
}
void GCCSGameRules::SetNoCTsKilled(bool value) {
    SetSchemaValue(m_ptr, "CCSGameRules", "m_bNoCTsKilled", false, value);
}
bool GCCSGameRules::GetNoEnemiesKilled() const {
    return GetSchemaValue<bool>(m_ptr, "CCSGameRules", "m_bNoEnemiesKilled");
}
void GCCSGameRules::SetNoEnemiesKilled(bool value) {
    SetSchemaValue(m_ptr, "CCSGameRules", "m_bNoEnemiesKilled", false, value);
}
bool GCCSGameRules::GetCanDonateWeapons() const {
    return GetSchemaValue<bool>(m_ptr, "CCSGameRules", "m_bCanDonateWeapons");
}
void GCCSGameRules::SetCanDonateWeapons(bool value) {
    SetSchemaValue(m_ptr, "CCSGameRules", "m_bCanDonateWeapons", false, value);
}
float GCCSGameRules::GetFirstKillTime() const {
    return GetSchemaValue<float>(m_ptr, "CCSGameRules", "m_firstKillTime");
}
void GCCSGameRules::SetFirstKillTime(float value) {
    SetSchemaValue(m_ptr, "CCSGameRules", "m_firstKillTime", false, value);
}
float GCCSGameRules::GetFirstBloodTime() const {
    return GetSchemaValue<float>(m_ptr, "CCSGameRules", "m_firstBloodTime");
}
void GCCSGameRules::SetFirstBloodTime(float value) {
    SetSchemaValue(m_ptr, "CCSGameRules", "m_firstBloodTime", false, value);
}
bool GCCSGameRules::GetHostageWasInjured() const {
    return GetSchemaValue<bool>(m_ptr, "CCSGameRules", "m_hostageWasInjured");
}
void GCCSGameRules::SetHostageWasInjured(bool value) {
    SetSchemaValue(m_ptr, "CCSGameRules", "m_hostageWasInjured", false, value);
}
bool GCCSGameRules::GetHostageWasKilled() const {
    return GetSchemaValue<bool>(m_ptr, "CCSGameRules", "m_hostageWasKilled");
}
void GCCSGameRules::SetHostageWasKilled(bool value) {
    SetSchemaValue(m_ptr, "CCSGameRules", "m_hostageWasKilled", false, value);
}
bool GCCSGameRules::GetVoteCalled() const {
    return GetSchemaValue<bool>(m_ptr, "CCSGameRules", "m_bVoteCalled");
}
void GCCSGameRules::SetVoteCalled(bool value) {
    SetSchemaValue(m_ptr, "CCSGameRules", "m_bVoteCalled", false, value);
}
bool GCCSGameRules::GetServerVoteOnReset() const {
    return GetSchemaValue<bool>(m_ptr, "CCSGameRules", "m_bServerVoteOnReset");
}
void GCCSGameRules::SetServerVoteOnReset(bool value) {
    SetSchemaValue(m_ptr, "CCSGameRules", "m_bServerVoteOnReset", false, value);
}
float GCCSGameRules::GetVoteCheckThrottle() const {
    return GetSchemaValue<float>(m_ptr, "CCSGameRules", "m_flVoteCheckThrottle");
}
void GCCSGameRules::SetVoteCheckThrottle(float value) {
    SetSchemaValue(m_ptr, "CCSGameRules", "m_flVoteCheckThrottle", false, value);
}
bool GCCSGameRules::GetBuyTimeEnded() const {
    return GetSchemaValue<bool>(m_ptr, "CCSGameRules", "m_bBuyTimeEnded");
}
void GCCSGameRules::SetBuyTimeEnded(bool value) {
    SetSchemaValue(m_ptr, "CCSGameRules", "m_bBuyTimeEnded", false, value);
}
int32_t GCCSGameRules::GetLastFreezeEndBeep() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSGameRules", "m_nLastFreezeEndBeep");
}
void GCCSGameRules::SetLastFreezeEndBeep(int32_t value) {
    SetSchemaValue(m_ptr, "CCSGameRules", "m_nLastFreezeEndBeep", false, value);
}
bool GCCSGameRules::GetTargetBombed() const {
    return GetSchemaValue<bool>(m_ptr, "CCSGameRules", "m_bTargetBombed");
}
void GCCSGameRules::SetTargetBombed(bool value) {
    SetSchemaValue(m_ptr, "CCSGameRules", "m_bTargetBombed", false, value);
}
bool GCCSGameRules::GetBombDefused() const {
    return GetSchemaValue<bool>(m_ptr, "CCSGameRules", "m_bBombDefused");
}
void GCCSGameRules::SetBombDefused(bool value) {
    SetSchemaValue(m_ptr, "CCSGameRules", "m_bBombDefused", false, value);
}
bool GCCSGameRules::GetMapHasBombZone() const {
    return GetSchemaValue<bool>(m_ptr, "CCSGameRules", "m_bMapHasBombZone");
}
void GCCSGameRules::SetMapHasBombZone(bool value) {
    SetSchemaValue(m_ptr, "CCSGameRules", "m_bMapHasBombZone", false, value);
}
Vector GCCSGameRules::GetMainCTSpawnPos() const {
    return GetSchemaValue<Vector>(m_ptr, "CCSGameRules", "m_vecMainCTSpawnPos");
}
void GCCSGameRules::SetMainCTSpawnPos(Vector value) {
    SetSchemaValue(m_ptr, "CCSGameRules", "m_vecMainCTSpawnPos", false, value);
}
std::vector<GSpawnPoint*> GCCSGameRules::GetCTSpawnPointsMasterList() const {
    CUtlVector<GSpawnPoint*>* vec = GetSchemaValue<CUtlVector<GSpawnPoint*>*>(m_ptr, "CCSGameRules", "m_CTSpawnPointsMasterList"); std::vector<GSpawnPoint*> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCCSGameRules::SetCTSpawnPointsMasterList(std::vector<GSpawnPoint*> value) {
    SetSchemaValueCUtlVector<GSpawnPoint*>(m_ptr, "CCSGameRules", "m_CTSpawnPointsMasterList", false, value);
}
std::vector<GSpawnPoint*> GCCSGameRules::GetTerroristSpawnPointsMasterList() const {
    CUtlVector<GSpawnPoint*>* vec = GetSchemaValue<CUtlVector<GSpawnPoint*>*>(m_ptr, "CCSGameRules", "m_TerroristSpawnPointsMasterList"); std::vector<GSpawnPoint*> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCCSGameRules::SetTerroristSpawnPointsMasterList(std::vector<GSpawnPoint*> value) {
    SetSchemaValueCUtlVector<GSpawnPoint*>(m_ptr, "CCSGameRules", "m_TerroristSpawnPointsMasterList", false, value);
}
bool GCCSGameRules::GetRespawningAllRespawnablePlayers() const {
    return GetSchemaValue<bool>(m_ptr, "CCSGameRules", "m_bRespawningAllRespawnablePlayers");
}
void GCCSGameRules::SetRespawningAllRespawnablePlayers(bool value) {
    SetSchemaValue(m_ptr, "CCSGameRules", "m_bRespawningAllRespawnablePlayers", false, value);
}
int32_t GCCSGameRules::GetNextCTSpawnPoint() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSGameRules", "m_iNextCTSpawnPoint");
}
void GCCSGameRules::SetNextCTSpawnPoint(int32_t value) {
    SetSchemaValue(m_ptr, "CCSGameRules", "m_iNextCTSpawnPoint", false, value);
}
float GCCSGameRules::GetCTSpawnPointUsedTime() const {
    return GetSchemaValue<float>(m_ptr, "CCSGameRules", "m_flCTSpawnPointUsedTime");
}
void GCCSGameRules::SetCTSpawnPointUsedTime(float value) {
    SetSchemaValue(m_ptr, "CCSGameRules", "m_flCTSpawnPointUsedTime", false, value);
}
int32_t GCCSGameRules::GetNextTerroristSpawnPoint() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSGameRules", "m_iNextTerroristSpawnPoint");
}
void GCCSGameRules::SetNextTerroristSpawnPoint(int32_t value) {
    SetSchemaValue(m_ptr, "CCSGameRules", "m_iNextTerroristSpawnPoint", false, value);
}
float GCCSGameRules::GetTerroristSpawnPointUsedTime() const {
    return GetSchemaValue<float>(m_ptr, "CCSGameRules", "m_flTerroristSpawnPointUsedTime");
}
void GCCSGameRules::SetTerroristSpawnPointUsedTime(float value) {
    SetSchemaValue(m_ptr, "CCSGameRules", "m_flTerroristSpawnPointUsedTime", false, value);
}
std::vector<GSpawnPoint*> GCCSGameRules::GetCTSpawnPoints() const {
    CUtlVector<GSpawnPoint*>* vec = GetSchemaValue<CUtlVector<GSpawnPoint*>*>(m_ptr, "CCSGameRules", "m_CTSpawnPoints"); std::vector<GSpawnPoint*> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCCSGameRules::SetCTSpawnPoints(std::vector<GSpawnPoint*> value) {
    SetSchemaValueCUtlVector<GSpawnPoint*>(m_ptr, "CCSGameRules", "m_CTSpawnPoints", false, value);
}
std::vector<GSpawnPoint*> GCCSGameRules::GetTerroristSpawnPoints() const {
    CUtlVector<GSpawnPoint*>* vec = GetSchemaValue<CUtlVector<GSpawnPoint*>*>(m_ptr, "CCSGameRules", "m_TerroristSpawnPoints"); std::vector<GSpawnPoint*> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCCSGameRules::SetTerroristSpawnPoints(std::vector<GSpawnPoint*> value) {
    SetSchemaValueCUtlVector<GSpawnPoint*>(m_ptr, "CCSGameRules", "m_TerroristSpawnPoints", false, value);
}
bool GCCSGameRules::GetIsUnreservedGameServer() const {
    return GetSchemaValue<bool>(m_ptr, "CCSGameRules", "m_bIsUnreservedGameServer");
}
void GCCSGameRules::SetIsUnreservedGameServer(bool value) {
    SetSchemaValue(m_ptr, "CCSGameRules", "m_bIsUnreservedGameServer", false, value);
}
float GCCSGameRules::GetAutobalanceDisplayTime() const {
    return GetSchemaValue<float>(m_ptr, "CCSGameRules", "m_fAutobalanceDisplayTime");
}
void GCCSGameRules::SetAutobalanceDisplayTime(float value) {
    SetSchemaValue(m_ptr, "CCSGameRules", "m_fAutobalanceDisplayTime", false, value);
}
bool GCCSGameRules::GetAllowWeaponSwitch() const {
    return GetSchemaValue<bool>(m_ptr, "CCSGameRules", "m_bAllowWeaponSwitch");
}
void GCCSGameRules::SetAllowWeaponSwitch(bool value) {
    SetSchemaValue(m_ptr, "CCSGameRules", "m_bAllowWeaponSwitch", false, value);
}
bool GCCSGameRules::GetRoundTimeWarningTriggered() const {
    return GetSchemaValue<bool>(m_ptr, "CCSGameRules", "m_bRoundTimeWarningTriggered");
}
void GCCSGameRules::SetRoundTimeWarningTriggered(bool value) {
    SetSchemaValue(m_ptr, "CCSGameRules", "m_bRoundTimeWarningTriggered", false, value);
}
float GCCSGameRules::GetPhaseChangeAnnouncementTime() const {
    return GetSchemaValue<float>(m_ptr, "CCSGameRules", "m_phaseChangeAnnouncementTime");
}
void GCCSGameRules::SetPhaseChangeAnnouncementTime(float value) {
    SetSchemaValue(m_ptr, "CCSGameRules", "m_phaseChangeAnnouncementTime", false, value);
}
float GCCSGameRules::GetNextUpdateTeamClanNamesTime() const {
    return GetSchemaValue<float>(m_ptr, "CCSGameRules", "m_fNextUpdateTeamClanNamesTime");
}
void GCCSGameRules::SetNextUpdateTeamClanNamesTime(float value) {
    SetSchemaValue(m_ptr, "CCSGameRules", "m_fNextUpdateTeamClanNamesTime", false, value);
}
float GCCSGameRules::GetLastThinkTime() const {
    return GetSchemaValue<float>(m_ptr, "CCSGameRules", "m_flLastThinkTime");
}
void GCCSGameRules::SetLastThinkTime(float value) {
    SetSchemaValue(m_ptr, "CCSGameRules", "m_flLastThinkTime", false, value);
}
float GCCSGameRules::GetAccumulatedRoundOffDamage() const {
    return GetSchemaValue<float>(m_ptr, "CCSGameRules", "m_fAccumulatedRoundOffDamage");
}
void GCCSGameRules::SetAccumulatedRoundOffDamage(float value) {
    SetSchemaValue(m_ptr, "CCSGameRules", "m_fAccumulatedRoundOffDamage", false, value);
}
int32_t GCCSGameRules::GetShorthandedBonusLastEvalRound() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSGameRules", "m_nShorthandedBonusLastEvalRound");
}
void GCCSGameRules::SetShorthandedBonusLastEvalRound(int32_t value) {
    SetSchemaValue(m_ptr, "CCSGameRules", "m_nShorthandedBonusLastEvalRound", false, value);
}
int32_t GCCSGameRules::GetMatchAbortedEarlyReason() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSGameRules", "m_nMatchAbortedEarlyReason");
}
void GCCSGameRules::SetMatchAbortedEarlyReason(int32_t value) {
    SetSchemaValue(m_ptr, "CCSGameRules", "m_nMatchAbortedEarlyReason", false, value);
}
bool GCCSGameRules::GetHasTriggeredRoundStartMusic() const {
    return GetSchemaValue<bool>(m_ptr, "CCSGameRules", "m_bHasTriggeredRoundStartMusic");
}
void GCCSGameRules::SetHasTriggeredRoundStartMusic(bool value) {
    SetSchemaValue(m_ptr, "CCSGameRules", "m_bHasTriggeredRoundStartMusic", false, value);
}
bool GCCSGameRules::GetSwitchingTeamsAtRoundReset() const {
    return GetSchemaValue<bool>(m_ptr, "CCSGameRules", "m_bSwitchingTeamsAtRoundReset");
}
void GCCSGameRules::SetSwitchingTeamsAtRoundReset(bool value) {
    SetSchemaValue(m_ptr, "CCSGameRules", "m_bSwitchingTeamsAtRoundReset", false, value);
}
GCCSGameModeRules GCCSGameRules::GetGameModeRules() const {
    GCCSGameModeRules value(*(void**)GetSchemaPtr(m_ptr, "CCSGameRules", "m_pGameModeRules"));
    return value;
}
void GCCSGameRules::SetGameModeRules(GCCSGameModeRules value) {
    SetSchemaValue(m_ptr, "CCSGameRules","m_pGameModeRules", false, (char*)value.GetPtr());
}
GCBaseEntity GCCSGameRules::GetPlayerResource() const {
    GCBaseEntity value((void*)(GetSchemaValue<CHandle<CEntityInstance>>(m_ptr, "CCSGameRules", "m_hPlayerResource").Get()));
    return value;
}
void GCCSGameRules::SetPlayerResource(GCBaseEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'PlayerResource' is not possible.\n");
}
GCRetakeGameRules GCCSGameRules::GetRetakeRules() const {
    GCRetakeGameRules value(GetSchemaPtr(m_ptr, "CCSGameRules", "m_RetakeRules"));
    return value;
}
void GCCSGameRules::SetRetakeRules(GCRetakeGameRules value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'RetakeRules' is not possible.\n");
}
std::vector<bool> GCCSGameRules::GetTeamLastKillUsedUniqueWeaponMatch() const {
    bool* outValue = (bool*)GetSchemaPtr(m_ptr, "CCSGameRules", "m_bTeamLastKillUsedUniqueWeaponMatch"); std::vector<bool> ret; for(int i = 0; i < 4; i++) { ret.push_back(outValue[i]); } return ret;
}
void GCCSGameRules::SetTeamLastKillUsedUniqueWeaponMatch(std::vector<bool> value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'TeamLastKillUsedUniqueWeaponMatch' is not possible.\n");
}
uint32_t GCCSGameRules::GetMatchEndCount() const {
    return GetSchemaValue<uint32_t>(m_ptr, "CCSGameRules", "m_nMatchEndCount");
}
void GCCSGameRules::SetMatchEndCount(uint32_t value) {
    SetSchemaValue(m_ptr, "CCSGameRules", "m_nMatchEndCount", false, value);
}
int32_t GCCSGameRules::GetTTeamIntroVariant() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSGameRules", "m_nTTeamIntroVariant");
}
void GCCSGameRules::SetTTeamIntroVariant(int32_t value) {
    SetSchemaValue(m_ptr, "CCSGameRules", "m_nTTeamIntroVariant", false, value);
}
int32_t GCCSGameRules::GetCTTeamIntroVariant() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSGameRules", "m_nCTTeamIntroVariant");
}
void GCCSGameRules::SetCTTeamIntroVariant(int32_t value) {
    SetSchemaValue(m_ptr, "CCSGameRules", "m_nCTTeamIntroVariant", false, value);
}
bool GCCSGameRules::GetTeamIntroPeriod() const {
    return GetSchemaValue<bool>(m_ptr, "CCSGameRules", "m_bTeamIntroPeriod");
}
void GCCSGameRules::SetTeamIntroPeriod(bool value) {
    SetSchemaValue(m_ptr, "CCSGameRules", "m_bTeamIntroPeriod", false, value);
}
float GCCSGameRules::GetTeamIntroPeriodEnd() const {
    return GetSchemaValue<float>(m_ptr, "CCSGameRules", "m_fTeamIntroPeriodEnd");
}
void GCCSGameRules::SetTeamIntroPeriodEnd(float value) {
    SetSchemaValue(m_ptr, "CCSGameRules", "m_fTeamIntroPeriodEnd", false, value);
}
bool GCCSGameRules::GetPlayedTeamIntroVO() const {
    return GetSchemaValue<bool>(m_ptr, "CCSGameRules", "m_bPlayedTeamIntroVO");
}
void GCCSGameRules::SetPlayedTeamIntroVO(bool value) {
    SetSchemaValue(m_ptr, "CCSGameRules", "m_bPlayedTeamIntroVO", false, value);
}
int32_t GCCSGameRules::GetRoundEndWinnerTeam() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSGameRules", "m_iRoundEndWinnerTeam");
}
void GCCSGameRules::SetRoundEndWinnerTeam(int32_t value) {
    SetSchemaValue(m_ptr, "CCSGameRules", "m_iRoundEndWinnerTeam", false, value);
}
int32_t GCCSGameRules::GetRoundEndReason() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSGameRules", "m_eRoundEndReason");
}
void GCCSGameRules::SetRoundEndReason(int32_t value) {
    SetSchemaValue(m_ptr, "CCSGameRules", "m_eRoundEndReason", false, value);
}
bool GCCSGameRules::GetRoundEndShowTimerDefend() const {
    return GetSchemaValue<bool>(m_ptr, "CCSGameRules", "m_bRoundEndShowTimerDefend");
}
void GCCSGameRules::SetRoundEndShowTimerDefend(bool value) {
    SetSchemaValue(m_ptr, "CCSGameRules", "m_bRoundEndShowTimerDefend", false, value);
}
int32_t GCCSGameRules::GetRoundEndTimerTime() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSGameRules", "m_iRoundEndTimerTime");
}
void GCCSGameRules::SetRoundEndTimerTime(int32_t value) {
    SetSchemaValue(m_ptr, "CCSGameRules", "m_iRoundEndTimerTime", false, value);
}
std::string GCCSGameRules::GetRoundEndFunFactToken() const {
    return GetSchemaValue<CUtlString>(m_ptr, "CCSGameRules", "m_sRoundEndFunFactToken").Get();
}
void GCCSGameRules::SetRoundEndFunFactToken(std::string value) {
    SetSchemaValue(m_ptr, "CCSGameRules", "m_sRoundEndFunFactToken", false, CUtlString(value.c_str()));
}
int32_t GCCSGameRules::GetRoundEndFunFactPlayerSlot() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSGameRules", "m_iRoundEndFunFactPlayerSlot");
}
void GCCSGameRules::SetRoundEndFunFactPlayerSlot(int32_t value) {
    SetSchemaValue(m_ptr, "CCSGameRules", "m_iRoundEndFunFactPlayerSlot", false, value);
}
int32_t GCCSGameRules::GetRoundEndFunFactData1() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSGameRules", "m_iRoundEndFunFactData1");
}
void GCCSGameRules::SetRoundEndFunFactData1(int32_t value) {
    SetSchemaValue(m_ptr, "CCSGameRules", "m_iRoundEndFunFactData1", false, value);
}
int32_t GCCSGameRules::GetRoundEndFunFactData2() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSGameRules", "m_iRoundEndFunFactData2");
}
void GCCSGameRules::SetRoundEndFunFactData2(int32_t value) {
    SetSchemaValue(m_ptr, "CCSGameRules", "m_iRoundEndFunFactData2", false, value);
}
int32_t GCCSGameRules::GetRoundEndFunFactData3() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSGameRules", "m_iRoundEndFunFactData3");
}
void GCCSGameRules::SetRoundEndFunFactData3(int32_t value) {
    SetSchemaValue(m_ptr, "CCSGameRules", "m_iRoundEndFunFactData3", false, value);
}
std::string GCCSGameRules::GetRoundEndMessage() const {
    return GetSchemaValue<CUtlString>(m_ptr, "CCSGameRules", "m_sRoundEndMessage").Get();
}
void GCCSGameRules::SetRoundEndMessage(std::string value) {
    SetSchemaValue(m_ptr, "CCSGameRules", "m_sRoundEndMessage", false, CUtlString(value.c_str()));
}
int32_t GCCSGameRules::GetRoundEndPlayerCount() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSGameRules", "m_iRoundEndPlayerCount");
}
void GCCSGameRules::SetRoundEndPlayerCount(int32_t value) {
    SetSchemaValue(m_ptr, "CCSGameRules", "m_iRoundEndPlayerCount", false, value);
}
bool GCCSGameRules::GetRoundEndNoMusic() const {
    return GetSchemaValue<bool>(m_ptr, "CCSGameRules", "m_bRoundEndNoMusic");
}
void GCCSGameRules::SetRoundEndNoMusic(bool value) {
    SetSchemaValue(m_ptr, "CCSGameRules", "m_bRoundEndNoMusic", false, value);
}
int32_t GCCSGameRules::GetRoundEndLegacy() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSGameRules", "m_iRoundEndLegacy");
}
void GCCSGameRules::SetRoundEndLegacy(int32_t value) {
    SetSchemaValue(m_ptr, "CCSGameRules", "m_iRoundEndLegacy", false, value);
}
uint32_t GCCSGameRules::GetRoundEndCount() const {
    return GetSchemaValue<uint32_t>(m_ptr, "CCSGameRules", "m_nRoundEndCount");
}
void GCCSGameRules::SetRoundEndCount(uint32_t value) {
    SetSchemaValue(m_ptr, "CCSGameRules", "m_nRoundEndCount", false, value);
}
int32_t GCCSGameRules::GetRoundStartRoundNumber() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSGameRules", "m_iRoundStartRoundNumber");
}
void GCCSGameRules::SetRoundStartRoundNumber(int32_t value) {
    SetSchemaValue(m_ptr, "CCSGameRules", "m_iRoundStartRoundNumber", false, value);
}
uint32_t GCCSGameRules::GetRoundStartCount() const {
    return GetSchemaValue<uint32_t>(m_ptr, "CCSGameRules", "m_nRoundStartCount");
}
void GCCSGameRules::SetRoundStartCount(uint32_t value) {
    SetSchemaValue(m_ptr, "CCSGameRules", "m_nRoundStartCount", false, value);
}
double GCCSGameRules::GetLastPerfSampleTime() const {
    return GetSchemaValue<double>(m_ptr, "CCSGameRules", "m_flLastPerfSampleTime");
}
void GCCSGameRules::SetLastPerfSampleTime(double value) {
    SetSchemaValue(m_ptr, "CCSGameRules", "m_flLastPerfSampleTime", false, value);
}
void* GCCSGameRules::GetPtr() {
    return m_ptr;
}
std::string GCCSGameRules::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCCSGameRules::IsValid() {
    return (m_ptr != nullptr);
}
GCTeamplayRules GCCSGameRules::GetParent() const {
    GCTeamplayRules value(m_ptr);
    return value;
}
void GCCSGameRules::SetParent(GCTeamplayRules value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCCSGameRules(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCCSGameRules>("CCSGameRules")
        .addConstructor<void (*)(std::string)>()
        .addProperty("FreezePeriod", &GCCSGameRules::GetFreezePeriod, &GCCSGameRules::SetFreezePeriod)
        .addProperty("WarmupPeriod", &GCCSGameRules::GetWarmupPeriod, &GCCSGameRules::SetWarmupPeriod)
        .addProperty("WarmupPeriodEnd", &GCCSGameRules::GetWarmupPeriodEnd, &GCCSGameRules::SetWarmupPeriodEnd)
        .addProperty("WarmupPeriodStart", &GCCSGameRules::GetWarmupPeriodStart, &GCCSGameRules::SetWarmupPeriodStart)
        .addProperty("ServerPaused", &GCCSGameRules::GetServerPaused, &GCCSGameRules::SetServerPaused)
        .addProperty("TerroristTimeOutActive", &GCCSGameRules::GetTerroristTimeOutActive, &GCCSGameRules::SetTerroristTimeOutActive)
        .addProperty("CTTimeOutActive", &GCCSGameRules::GetCTTimeOutActive, &GCCSGameRules::SetCTTimeOutActive)
        .addProperty("TerroristTimeOutRemaining", &GCCSGameRules::GetTerroristTimeOutRemaining, &GCCSGameRules::SetTerroristTimeOutRemaining)
        .addProperty("CTTimeOutRemaining", &GCCSGameRules::GetCTTimeOutRemaining, &GCCSGameRules::SetCTTimeOutRemaining)
        .addProperty("TerroristTimeOuts", &GCCSGameRules::GetTerroristTimeOuts, &GCCSGameRules::SetTerroristTimeOuts)
        .addProperty("CTTimeOuts", &GCCSGameRules::GetCTTimeOuts, &GCCSGameRules::SetCTTimeOuts)
        .addProperty("TechnicalTimeOut", &GCCSGameRules::GetTechnicalTimeOut, &GCCSGameRules::SetTechnicalTimeOut)
        .addProperty("MatchWaitingForResume", &GCCSGameRules::GetMatchWaitingForResume, &GCCSGameRules::SetMatchWaitingForResume)
        .addProperty("RoundTime", &GCCSGameRules::GetRoundTime, &GCCSGameRules::SetRoundTime)
        .addProperty("MatchStartTime", &GCCSGameRules::GetMatchStartTime, &GCCSGameRules::SetMatchStartTime)
        .addProperty("RoundStartTime", &GCCSGameRules::GetRoundStartTime, &GCCSGameRules::SetRoundStartTime)
        .addProperty("RestartRoundTime", &GCCSGameRules::GetRestartRoundTime, &GCCSGameRules::SetRestartRoundTime)
        .addProperty("GameRestart", &GCCSGameRules::GetGameRestart, &GCCSGameRules::SetGameRestart)
        .addProperty("GameStartTime", &GCCSGameRules::GetGameStartTime, &GCCSGameRules::SetGameStartTime)
        .addProperty("TimeUntilNextPhaseStarts", &GCCSGameRules::GetTimeUntilNextPhaseStarts, &GCCSGameRules::SetTimeUntilNextPhaseStarts)
        .addProperty("GamePhase", &GCCSGameRules::GetGamePhase, &GCCSGameRules::SetGamePhase)
        .addProperty("TotalRoundsPlayed", &GCCSGameRules::GetTotalRoundsPlayed, &GCCSGameRules::SetTotalRoundsPlayed)
        .addProperty("RoundsPlayedThisPhase", &GCCSGameRules::GetRoundsPlayedThisPhase, &GCCSGameRules::SetRoundsPlayedThisPhase)
        .addProperty("OvertimePlaying", &GCCSGameRules::GetOvertimePlaying, &GCCSGameRules::SetOvertimePlaying)
        .addProperty("HostagesRemaining", &GCCSGameRules::GetHostagesRemaining, &GCCSGameRules::SetHostagesRemaining)
        .addProperty("AnyHostageReached", &GCCSGameRules::GetAnyHostageReached, &GCCSGameRules::SetAnyHostageReached)
        .addProperty("MapHasBombTarget", &GCCSGameRules::GetMapHasBombTarget, &GCCSGameRules::SetMapHasBombTarget)
        .addProperty("MapHasRescueZone", &GCCSGameRules::GetMapHasRescueZone, &GCCSGameRules::SetMapHasRescueZone)
        .addProperty("MapHasBuyZone", &GCCSGameRules::GetMapHasBuyZone, &GCCSGameRules::SetMapHasBuyZone)
        .addProperty("IsQueuedMatchmaking", &GCCSGameRules::GetIsQueuedMatchmaking, &GCCSGameRules::SetIsQueuedMatchmaking)
        .addProperty("QueuedMatchmakingMode", &GCCSGameRules::GetQueuedMatchmakingMode, &GCCSGameRules::SetQueuedMatchmakingMode)
        .addProperty("IsValveDS", &GCCSGameRules::GetIsValveDS, &GCCSGameRules::SetIsValveDS)
        .addProperty("LogoMap", &GCCSGameRules::GetLogoMap, &GCCSGameRules::SetLogoMap)
        .addProperty("PlayAllStepSoundsOnServer", &GCCSGameRules::GetPlayAllStepSoundsOnServer, &GCCSGameRules::SetPlayAllStepSoundsOnServer)
        .addProperty("SpectatorSlotCount", &GCCSGameRules::GetSpectatorSlotCount, &GCCSGameRules::SetSpectatorSlotCount)
        .addProperty("MatchDevice", &GCCSGameRules::GetMatchDevice, &GCCSGameRules::SetMatchDevice)
        .addProperty("HasMatchStarted", &GCCSGameRules::GetHasMatchStarted, &GCCSGameRules::SetHasMatchStarted)
        .addProperty("NextMapInMapgroup", &GCCSGameRules::GetNextMapInMapgroup, &GCCSGameRules::SetNextMapInMapgroup)
        .addProperty("TournamentEventName", &GCCSGameRules::GetTournamentEventName, &GCCSGameRules::SetTournamentEventName)
        .addProperty("TournamentEventStage", &GCCSGameRules::GetTournamentEventStage, &GCCSGameRules::SetTournamentEventStage)
        .addProperty("MatchStatTxt", &GCCSGameRules::GetMatchStatTxt, &GCCSGameRules::SetMatchStatTxt)
        .addProperty("TournamentPredictionsTxt", &GCCSGameRules::GetTournamentPredictionsTxt, &GCCSGameRules::SetTournamentPredictionsTxt)
        .addProperty("TournamentPredictionsPct", &GCCSGameRules::GetTournamentPredictionsPct, &GCCSGameRules::SetTournamentPredictionsPct)
        .addProperty("CMMItemDropRevealStartTime", &GCCSGameRules::GetCMMItemDropRevealStartTime, &GCCSGameRules::SetCMMItemDropRevealStartTime)
        .addProperty("CMMItemDropRevealEndTime", &GCCSGameRules::GetCMMItemDropRevealEndTime, &GCCSGameRules::SetCMMItemDropRevealEndTime)
        .addProperty("IsDroppingItems", &GCCSGameRules::GetIsDroppingItems, &GCCSGameRules::SetIsDroppingItems)
        .addProperty("IsQuestEligible", &GCCSGameRules::GetIsQuestEligible, &GCCSGameRules::SetIsQuestEligible)
        .addProperty("IsHltvActive", &GCCSGameRules::GetIsHltvActive, &GCCSGameRules::SetIsHltvActive)
        .addProperty("ProhibitedItemIndices", &GCCSGameRules::GetProhibitedItemIndices, &GCCSGameRules::SetProhibitedItemIndices)
        .addProperty("TournamentActiveCasterAccounts", &GCCSGameRules::GetTournamentActiveCasterAccounts, &GCCSGameRules::SetTournamentActiveCasterAccounts)
        .addProperty("NumBestOfMaps", &GCCSGameRules::GetNumBestOfMaps, &GCCSGameRules::SetNumBestOfMaps)
        .addProperty("HalloweenMaskListSeed", &GCCSGameRules::GetHalloweenMaskListSeed, &GCCSGameRules::SetHalloweenMaskListSeed)
        .addProperty("BombDropped", &GCCSGameRules::GetBombDropped, &GCCSGameRules::SetBombDropped)
        .addProperty("BombPlanted", &GCCSGameRules::GetBombPlanted, &GCCSGameRules::SetBombPlanted)
        .addProperty("RoundWinStatus", &GCCSGameRules::GetRoundWinStatus, &GCCSGameRules::SetRoundWinStatus)
        .addProperty("RoundWinReason", &GCCSGameRules::GetRoundWinReason, &GCCSGameRules::SetRoundWinReason)
        .addProperty("TCantBuy", &GCCSGameRules::GetTCantBuy, &GCCSGameRules::SetTCantBuy)
        .addProperty("CTCantBuy", &GCCSGameRules::GetCTCantBuy, &GCCSGameRules::SetCTCantBuy)
        .addProperty("MatchStats_RoundResults", &GCCSGameRules::GetMatchStats_RoundResults, &GCCSGameRules::SetMatchStats_RoundResults)
        .addProperty("MatchStats_PlayersAlive_CT", &GCCSGameRules::GetMatchStats_PlayersAlive_CT, &GCCSGameRules::SetMatchStats_PlayersAlive_CT)
        .addProperty("MatchStats_PlayersAlive_T", &GCCSGameRules::GetMatchStats_PlayersAlive_T, &GCCSGameRules::SetMatchStats_PlayersAlive_T)
        .addProperty("TeamRespawnWaveTimes", &GCCSGameRules::GetTeamRespawnWaveTimes, &GCCSGameRules::SetTeamRespawnWaveTimes)
        .addProperty("NextRespawnWave", &GCCSGameRules::GetNextRespawnWave, &GCCSGameRules::SetNextRespawnWave)
        .addProperty("ServerQuestID", &GCCSGameRules::GetServerQuestID, &GCCSGameRules::SetServerQuestID)
        .addProperty("MinimapMins", &GCCSGameRules::GetMinimapMins, &GCCSGameRules::SetMinimapMins)
        .addProperty("MinimapMaxs", &GCCSGameRules::GetMinimapMaxs, &GCCSGameRules::SetMinimapMaxs)
        .addProperty("MinimapVerticalSectionHeights", &GCCSGameRules::GetMinimapVerticalSectionHeights, &GCCSGameRules::SetMinimapVerticalSectionHeights)
        .addProperty("SpawnedTerrorHuntHeavy", &GCCSGameRules::GetSpawnedTerrorHuntHeavy, &GCCSGameRules::SetSpawnedTerrorHuntHeavy)
        .addProperty("EndMatchMapGroupVoteTypes", &GCCSGameRules::GetEndMatchMapGroupVoteTypes, &GCCSGameRules::SetEndMatchMapGroupVoteTypes)
        .addProperty("EndMatchMapGroupVoteOptions", &GCCSGameRules::GetEndMatchMapGroupVoteOptions, &GCCSGameRules::SetEndMatchMapGroupVoteOptions)
        .addProperty("EndMatchMapVoteWinner", &GCCSGameRules::GetEndMatchMapVoteWinner, &GCCSGameRules::SetEndMatchMapVoteWinner)
        .addProperty("NumConsecutiveCTLoses", &GCCSGameRules::GetNumConsecutiveCTLoses, &GCCSGameRules::SetNumConsecutiveCTLoses)
        .addProperty("NumConsecutiveTerroristLoses", &GCCSGameRules::GetNumConsecutiveTerroristLoses, &GCCSGameRules::SetNumConsecutiveTerroristLoses)
        .addProperty("HasHostageBeenTouched", &GCCSGameRules::GetHasHostageBeenTouched, &GCCSGameRules::SetHasHostageBeenTouched)
        .addProperty("IntermissionStartTime", &GCCSGameRules::GetIntermissionStartTime, &GCCSGameRules::SetIntermissionStartTime)
        .addProperty("IntermissionEndTime", &GCCSGameRules::GetIntermissionEndTime, &GCCSGameRules::SetIntermissionEndTime)
        .addProperty("LevelInitialized", &GCCSGameRules::GetLevelInitialized, &GCCSGameRules::SetLevelInitialized)
        .addProperty("TotalRoundsPlayed1", &GCCSGameRules::GetTotalRoundsPlayed1, &GCCSGameRules::SetTotalRoundsPlayed1)
        .addProperty("UnBalancedRounds", &GCCSGameRules::GetUnBalancedRounds, &GCCSGameRules::SetUnBalancedRounds)
        .addProperty("EndMatchOnRoundReset", &GCCSGameRules::GetEndMatchOnRoundReset, &GCCSGameRules::SetEndMatchOnRoundReset)
        .addProperty("EndMatchOnThink", &GCCSGameRules::GetEndMatchOnThink, &GCCSGameRules::SetEndMatchOnThink)
        .addProperty("FreezeTime", &GCCSGameRules::GetFreezeTime, &GCCSGameRules::SetFreezeTime)
        .addProperty("NumTerrorist", &GCCSGameRules::GetNumTerrorist, &GCCSGameRules::SetNumTerrorist)
        .addProperty("NumCT", &GCCSGameRules::GetNumCT, &GCCSGameRules::SetNumCT)
        .addProperty("NumSpawnableTerrorist", &GCCSGameRules::GetNumSpawnableTerrorist, &GCCSGameRules::SetNumSpawnableTerrorist)
        .addProperty("NumSpawnableCT", &GCCSGameRules::GetNumSpawnableCT, &GCCSGameRules::SetNumSpawnableCT)
        .addProperty("SelectedHostageSpawnIndices", &GCCSGameRules::GetSelectedHostageSpawnIndices, &GCCSGameRules::SetSelectedHostageSpawnIndices)
        .addProperty("SpawnPointsRandomSeed", &GCCSGameRules::GetSpawnPointsRandomSeed, &GCCSGameRules::SetSpawnPointsRandomSeed)
        .addProperty("FirstConnected", &GCCSGameRules::GetFirstConnected, &GCCSGameRules::SetFirstConnected)
        .addProperty("CompleteReset", &GCCSGameRules::GetCompleteReset, &GCCSGameRules::SetCompleteReset)
        .addProperty("PickNewTeamsOnReset", &GCCSGameRules::GetPickNewTeamsOnReset, &GCCSGameRules::SetPickNewTeamsOnReset)
        .addProperty("ScrambleTeamsOnRestart", &GCCSGameRules::GetScrambleTeamsOnRestart, &GCCSGameRules::SetScrambleTeamsOnRestart)
        .addProperty("SwapTeamsOnRestart", &GCCSGameRules::GetSwapTeamsOnRestart, &GCCSGameRules::SetSwapTeamsOnRestart)
        .addProperty("EndMatchTiedVotes", &GCCSGameRules::GetEndMatchTiedVotes, &GCCSGameRules::SetEndMatchTiedVotes)
        .addProperty("NeedToAskPlayersForContinueVote", &GCCSGameRules::GetNeedToAskPlayersForContinueVote, &GCCSGameRules::SetNeedToAskPlayersForContinueVote)
        .addProperty("NumQueuedMatchmakingAccounts", &GCCSGameRules::GetNumQueuedMatchmakingAccounts, &GCCSGameRules::SetNumQueuedMatchmakingAccounts)
        .addProperty("AvgPlayerRank", &GCCSGameRules::GetAvgPlayerRank, &GCCSGameRules::SetAvgPlayerRank)
        .addProperty("QueuedMatchmakingReservationString", &GCCSGameRules::GetQueuedMatchmakingReservationString, &GCCSGameRules::SetQueuedMatchmakingReservationString)
        .addProperty("NumTotalTournamentDrops", &GCCSGameRules::GetNumTotalTournamentDrops, &GCCSGameRules::SetNumTotalTournamentDrops)
        .addProperty("NumSpectatorsCountMax", &GCCSGameRules::GetNumSpectatorsCountMax, &GCCSGameRules::SetNumSpectatorsCountMax)
        .addProperty("NumSpectatorsCountMaxTV", &GCCSGameRules::GetNumSpectatorsCountMaxTV, &GCCSGameRules::SetNumSpectatorsCountMaxTV)
        .addProperty("NumSpectatorsCountMaxLnk", &GCCSGameRules::GetNumSpectatorsCountMaxLnk, &GCCSGameRules::SetNumSpectatorsCountMaxLnk)
        .addProperty("ForceTeamChangeSilent", &GCCSGameRules::GetForceTeamChangeSilent, &GCCSGameRules::SetForceTeamChangeSilent)
        .addProperty("LoadingRoundBackupData", &GCCSGameRules::GetLoadingRoundBackupData, &GCCSGameRules::SetLoadingRoundBackupData)
        .addProperty("MatchInfoShowType", &GCCSGameRules::GetMatchInfoShowType, &GCCSGameRules::SetMatchInfoShowType)
        .addProperty("MatchInfoDecidedTime", &GCCSGameRules::GetMatchInfoDecidedTime, &GCCSGameRules::SetMatchInfoDecidedTime)
        .addProperty("MTeamDMLastWinningTeamNumber", &GCCSGameRules::GetMTeamDMLastWinningTeamNumber, &GCCSGameRules::SetMTeamDMLastWinningTeamNumber)
        .addProperty("MTeamDMLastThinkTime", &GCCSGameRules::GetMTeamDMLastThinkTime, &GCCSGameRules::SetMTeamDMLastThinkTime)
        .addProperty("TeamDMLastAnnouncementTime", &GCCSGameRules::GetTeamDMLastAnnouncementTime, &GCCSGameRules::SetTeamDMLastAnnouncementTime)
        .addProperty("AccountTerrorist", &GCCSGameRules::GetAccountTerrorist, &GCCSGameRules::SetAccountTerrorist)
        .addProperty("AccountCT", &GCCSGameRules::GetAccountCT, &GCCSGameRules::SetAccountCT)
        .addProperty("SpawnPointCount_Terrorist", &GCCSGameRules::GetSpawnPointCount_Terrorist, &GCCSGameRules::SetSpawnPointCount_Terrorist)
        .addProperty("SpawnPointCount_CT", &GCCSGameRules::GetSpawnPointCount_CT, &GCCSGameRules::SetSpawnPointCount_CT)
        .addProperty("MaxNumTerrorists", &GCCSGameRules::GetMaxNumTerrorists, &GCCSGameRules::SetMaxNumTerrorists)
        .addProperty("MaxNumCTs", &GCCSGameRules::GetMaxNumCTs, &GCCSGameRules::SetMaxNumCTs)
        .addProperty("LoserBonusMostRecentTeam", &GCCSGameRules::GetLoserBonusMostRecentTeam, &GCCSGameRules::SetLoserBonusMostRecentTeam)
        .addProperty("TmNextPeriodicThink", &GCCSGameRules::GetTmNextPeriodicThink, &GCCSGameRules::SetTmNextPeriodicThink)
        .addProperty("VoiceWonMatchBragFired", &GCCSGameRules::GetVoiceWonMatchBragFired, &GCCSGameRules::SetVoiceWonMatchBragFired)
        .addProperty("WarmupNextChatNoticeTime", &GCCSGameRules::GetWarmupNextChatNoticeTime, &GCCSGameRules::SetWarmupNextChatNoticeTime)
        .addProperty("HostagesRescued", &GCCSGameRules::GetHostagesRescued, &GCCSGameRules::SetHostagesRescued)
        .addProperty("HostagesTouched", &GCCSGameRules::GetHostagesTouched, &GCCSGameRules::SetHostagesTouched)
        .addProperty("NextHostageAnnouncement", &GCCSGameRules::GetNextHostageAnnouncement, &GCCSGameRules::SetNextHostageAnnouncement)
        .addProperty("NoTerroristsKilled", &GCCSGameRules::GetNoTerroristsKilled, &GCCSGameRules::SetNoTerroristsKilled)
        .addProperty("NoCTsKilled", &GCCSGameRules::GetNoCTsKilled, &GCCSGameRules::SetNoCTsKilled)
        .addProperty("NoEnemiesKilled", &GCCSGameRules::GetNoEnemiesKilled, &GCCSGameRules::SetNoEnemiesKilled)
        .addProperty("CanDonateWeapons", &GCCSGameRules::GetCanDonateWeapons, &GCCSGameRules::SetCanDonateWeapons)
        .addProperty("FirstKillTime", &GCCSGameRules::GetFirstKillTime, &GCCSGameRules::SetFirstKillTime)
        .addProperty("FirstBloodTime", &GCCSGameRules::GetFirstBloodTime, &GCCSGameRules::SetFirstBloodTime)
        .addProperty("HostageWasInjured", &GCCSGameRules::GetHostageWasInjured, &GCCSGameRules::SetHostageWasInjured)
        .addProperty("HostageWasKilled", &GCCSGameRules::GetHostageWasKilled, &GCCSGameRules::SetHostageWasKilled)
        .addProperty("VoteCalled", &GCCSGameRules::GetVoteCalled, &GCCSGameRules::SetVoteCalled)
        .addProperty("ServerVoteOnReset", &GCCSGameRules::GetServerVoteOnReset, &GCCSGameRules::SetServerVoteOnReset)
        .addProperty("VoteCheckThrottle", &GCCSGameRules::GetVoteCheckThrottle, &GCCSGameRules::SetVoteCheckThrottle)
        .addProperty("BuyTimeEnded", &GCCSGameRules::GetBuyTimeEnded, &GCCSGameRules::SetBuyTimeEnded)
        .addProperty("LastFreezeEndBeep", &GCCSGameRules::GetLastFreezeEndBeep, &GCCSGameRules::SetLastFreezeEndBeep)
        .addProperty("TargetBombed", &GCCSGameRules::GetTargetBombed, &GCCSGameRules::SetTargetBombed)
        .addProperty("BombDefused", &GCCSGameRules::GetBombDefused, &GCCSGameRules::SetBombDefused)
        .addProperty("MapHasBombZone", &GCCSGameRules::GetMapHasBombZone, &GCCSGameRules::SetMapHasBombZone)
        .addProperty("MainCTSpawnPos", &GCCSGameRules::GetMainCTSpawnPos, &GCCSGameRules::SetMainCTSpawnPos)
        .addProperty("CTSpawnPointsMasterList", &GCCSGameRules::GetCTSpawnPointsMasterList, &GCCSGameRules::SetCTSpawnPointsMasterList)
        .addProperty("TerroristSpawnPointsMasterList", &GCCSGameRules::GetTerroristSpawnPointsMasterList, &GCCSGameRules::SetTerroristSpawnPointsMasterList)
        .addProperty("RespawningAllRespawnablePlayers", &GCCSGameRules::GetRespawningAllRespawnablePlayers, &GCCSGameRules::SetRespawningAllRespawnablePlayers)
        .addProperty("NextCTSpawnPoint", &GCCSGameRules::GetNextCTSpawnPoint, &GCCSGameRules::SetNextCTSpawnPoint)
        .addProperty("CTSpawnPointUsedTime", &GCCSGameRules::GetCTSpawnPointUsedTime, &GCCSGameRules::SetCTSpawnPointUsedTime)
        .addProperty("NextTerroristSpawnPoint", &GCCSGameRules::GetNextTerroristSpawnPoint, &GCCSGameRules::SetNextTerroristSpawnPoint)
        .addProperty("TerroristSpawnPointUsedTime", &GCCSGameRules::GetTerroristSpawnPointUsedTime, &GCCSGameRules::SetTerroristSpawnPointUsedTime)
        .addProperty("CTSpawnPoints", &GCCSGameRules::GetCTSpawnPoints, &GCCSGameRules::SetCTSpawnPoints)
        .addProperty("TerroristSpawnPoints", &GCCSGameRules::GetTerroristSpawnPoints, &GCCSGameRules::SetTerroristSpawnPoints)
        .addProperty("IsUnreservedGameServer", &GCCSGameRules::GetIsUnreservedGameServer, &GCCSGameRules::SetIsUnreservedGameServer)
        .addProperty("AutobalanceDisplayTime", &GCCSGameRules::GetAutobalanceDisplayTime, &GCCSGameRules::SetAutobalanceDisplayTime)
        .addProperty("AllowWeaponSwitch", &GCCSGameRules::GetAllowWeaponSwitch, &GCCSGameRules::SetAllowWeaponSwitch)
        .addProperty("RoundTimeWarningTriggered", &GCCSGameRules::GetRoundTimeWarningTriggered, &GCCSGameRules::SetRoundTimeWarningTriggered)
        .addProperty("PhaseChangeAnnouncementTime", &GCCSGameRules::GetPhaseChangeAnnouncementTime, &GCCSGameRules::SetPhaseChangeAnnouncementTime)
        .addProperty("NextUpdateTeamClanNamesTime", &GCCSGameRules::GetNextUpdateTeamClanNamesTime, &GCCSGameRules::SetNextUpdateTeamClanNamesTime)
        .addProperty("LastThinkTime", &GCCSGameRules::GetLastThinkTime, &GCCSGameRules::SetLastThinkTime)
        .addProperty("AccumulatedRoundOffDamage", &GCCSGameRules::GetAccumulatedRoundOffDamage, &GCCSGameRules::SetAccumulatedRoundOffDamage)
        .addProperty("ShorthandedBonusLastEvalRound", &GCCSGameRules::GetShorthandedBonusLastEvalRound, &GCCSGameRules::SetShorthandedBonusLastEvalRound)
        .addProperty("MatchAbortedEarlyReason", &GCCSGameRules::GetMatchAbortedEarlyReason, &GCCSGameRules::SetMatchAbortedEarlyReason)
        .addProperty("HasTriggeredRoundStartMusic", &GCCSGameRules::GetHasTriggeredRoundStartMusic, &GCCSGameRules::SetHasTriggeredRoundStartMusic)
        .addProperty("SwitchingTeamsAtRoundReset", &GCCSGameRules::GetSwitchingTeamsAtRoundReset, &GCCSGameRules::SetSwitchingTeamsAtRoundReset)
        .addProperty("GameModeRules", &GCCSGameRules::GetGameModeRules, &GCCSGameRules::SetGameModeRules)
        .addProperty("PlayerResource", &GCCSGameRules::GetPlayerResource, &GCCSGameRules::SetPlayerResource)
        .addProperty("RetakeRules", &GCCSGameRules::GetRetakeRules, &GCCSGameRules::SetRetakeRules)
        .addProperty("TeamLastKillUsedUniqueWeaponMatch", &GCCSGameRules::GetTeamLastKillUsedUniqueWeaponMatch, &GCCSGameRules::SetTeamLastKillUsedUniqueWeaponMatch)
        .addProperty("MatchEndCount", &GCCSGameRules::GetMatchEndCount, &GCCSGameRules::SetMatchEndCount)
        .addProperty("TTeamIntroVariant", &GCCSGameRules::GetTTeamIntroVariant, &GCCSGameRules::SetTTeamIntroVariant)
        .addProperty("CTTeamIntroVariant", &GCCSGameRules::GetCTTeamIntroVariant, &GCCSGameRules::SetCTTeamIntroVariant)
        .addProperty("TeamIntroPeriod", &GCCSGameRules::GetTeamIntroPeriod, &GCCSGameRules::SetTeamIntroPeriod)
        .addProperty("TeamIntroPeriodEnd", &GCCSGameRules::GetTeamIntroPeriodEnd, &GCCSGameRules::SetTeamIntroPeriodEnd)
        .addProperty("PlayedTeamIntroVO", &GCCSGameRules::GetPlayedTeamIntroVO, &GCCSGameRules::SetPlayedTeamIntroVO)
        .addProperty("RoundEndWinnerTeam", &GCCSGameRules::GetRoundEndWinnerTeam, &GCCSGameRules::SetRoundEndWinnerTeam)
        .addProperty("RoundEndReason", &GCCSGameRules::GetRoundEndReason, &GCCSGameRules::SetRoundEndReason)
        .addProperty("RoundEndShowTimerDefend", &GCCSGameRules::GetRoundEndShowTimerDefend, &GCCSGameRules::SetRoundEndShowTimerDefend)
        .addProperty("RoundEndTimerTime", &GCCSGameRules::GetRoundEndTimerTime, &GCCSGameRules::SetRoundEndTimerTime)
        .addProperty("RoundEndFunFactToken", &GCCSGameRules::GetRoundEndFunFactToken, &GCCSGameRules::SetRoundEndFunFactToken)
        .addProperty("RoundEndFunFactPlayerSlot", &GCCSGameRules::GetRoundEndFunFactPlayerSlot, &GCCSGameRules::SetRoundEndFunFactPlayerSlot)
        .addProperty("RoundEndFunFactData1", &GCCSGameRules::GetRoundEndFunFactData1, &GCCSGameRules::SetRoundEndFunFactData1)
        .addProperty("RoundEndFunFactData2", &GCCSGameRules::GetRoundEndFunFactData2, &GCCSGameRules::SetRoundEndFunFactData2)
        .addProperty("RoundEndFunFactData3", &GCCSGameRules::GetRoundEndFunFactData3, &GCCSGameRules::SetRoundEndFunFactData3)
        .addProperty("RoundEndMessage", &GCCSGameRules::GetRoundEndMessage, &GCCSGameRules::SetRoundEndMessage)
        .addProperty("RoundEndPlayerCount", &GCCSGameRules::GetRoundEndPlayerCount, &GCCSGameRules::SetRoundEndPlayerCount)
        .addProperty("RoundEndNoMusic", &GCCSGameRules::GetRoundEndNoMusic, &GCCSGameRules::SetRoundEndNoMusic)
        .addProperty("RoundEndLegacy", &GCCSGameRules::GetRoundEndLegacy, &GCCSGameRules::SetRoundEndLegacy)
        .addProperty("RoundEndCount", &GCCSGameRules::GetRoundEndCount, &GCCSGameRules::SetRoundEndCount)
        .addProperty("RoundStartRoundNumber", &GCCSGameRules::GetRoundStartRoundNumber, &GCCSGameRules::SetRoundStartRoundNumber)
        .addProperty("RoundStartCount", &GCCSGameRules::GetRoundStartCount, &GCCSGameRules::SetRoundStartCount)
        .addProperty("LastPerfSampleTime", &GCCSGameRules::GetLastPerfSampleTime, &GCCSGameRules::SetLastPerfSampleTime)
        .addProperty("Parent", &GCCSGameRules::GetParent, &GCCSGameRules::SetParent)
        .addFunction("ToPtr", &GCCSGameRules::ToPtr)
        .addFunction("IsValid", &GCCSGameRules::IsValid)
        .endClass();
}
GCColorCorrection::GCColorCorrection(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCColorCorrection::GCColorCorrection(void *ptr) {
    m_ptr = ptr;
}
float GCColorCorrection::GetFadeInDuration() const {
    return GetSchemaValue<float>(m_ptr, "CColorCorrection", "m_flFadeInDuration");
}
void GCColorCorrection::SetFadeInDuration(float value) {
    SetSchemaValue(m_ptr, "CColorCorrection", "m_flFadeInDuration", false, value);
}
float GCColorCorrection::GetFadeOutDuration() const {
    return GetSchemaValue<float>(m_ptr, "CColorCorrection", "m_flFadeOutDuration");
}
void GCColorCorrection::SetFadeOutDuration(float value) {
    SetSchemaValue(m_ptr, "CColorCorrection", "m_flFadeOutDuration", false, value);
}
float GCColorCorrection::GetStartFadeInWeight() const {
    return GetSchemaValue<float>(m_ptr, "CColorCorrection", "m_flStartFadeInWeight");
}
void GCColorCorrection::SetStartFadeInWeight(float value) {
    SetSchemaValue(m_ptr, "CColorCorrection", "m_flStartFadeInWeight", false, value);
}
float GCColorCorrection::GetStartFadeOutWeight() const {
    return GetSchemaValue<float>(m_ptr, "CColorCorrection", "m_flStartFadeOutWeight");
}
void GCColorCorrection::SetStartFadeOutWeight(float value) {
    SetSchemaValue(m_ptr, "CColorCorrection", "m_flStartFadeOutWeight", false, value);
}
float GCColorCorrection::GetTimeStartFadeIn() const {
    return GetSchemaValue<float>(m_ptr, "CColorCorrection", "m_flTimeStartFadeIn");
}
void GCColorCorrection::SetTimeStartFadeIn(float value) {
    SetSchemaValue(m_ptr, "CColorCorrection", "m_flTimeStartFadeIn", false, value);
}
float GCColorCorrection::GetTimeStartFadeOut() const {
    return GetSchemaValue<float>(m_ptr, "CColorCorrection", "m_flTimeStartFadeOut");
}
void GCColorCorrection::SetTimeStartFadeOut(float value) {
    SetSchemaValue(m_ptr, "CColorCorrection", "m_flTimeStartFadeOut", false, value);
}
float GCColorCorrection::GetMaxWeight() const {
    return GetSchemaValue<float>(m_ptr, "CColorCorrection", "m_flMaxWeight");
}
void GCColorCorrection::SetMaxWeight(float value) {
    SetSchemaValue(m_ptr, "CColorCorrection", "m_flMaxWeight", false, value);
}
bool GCColorCorrection::GetStartDisabled() const {
    return GetSchemaValue<bool>(m_ptr, "CColorCorrection", "m_bStartDisabled");
}
void GCColorCorrection::SetStartDisabled(bool value) {
    SetSchemaValue(m_ptr, "CColorCorrection", "m_bStartDisabled", false, value);
}
bool GCColorCorrection::GetEnabled() const {
    return GetSchemaValue<bool>(m_ptr, "CColorCorrection", "m_bEnabled");
}
void GCColorCorrection::SetEnabled(bool value) {
    SetSchemaValue(m_ptr, "CColorCorrection", "m_bEnabled", false, value);
}
bool GCColorCorrection::GetMaster() const {
    return GetSchemaValue<bool>(m_ptr, "CColorCorrection", "m_bMaster");
}
void GCColorCorrection::SetMaster(bool value) {
    SetSchemaValue(m_ptr, "CColorCorrection", "m_bMaster", false, value);
}
bool GCColorCorrection::GetClientSide() const {
    return GetSchemaValue<bool>(m_ptr, "CColorCorrection", "m_bClientSide");
}
void GCColorCorrection::SetClientSide(bool value) {
    SetSchemaValue(m_ptr, "CColorCorrection", "m_bClientSide", false, value);
}
bool GCColorCorrection::GetExclusive() const {
    return GetSchemaValue<bool>(m_ptr, "CColorCorrection", "m_bExclusive");
}
void GCColorCorrection::SetExclusive(bool value) {
    SetSchemaValue(m_ptr, "CColorCorrection", "m_bExclusive", false, value);
}
float GCColorCorrection::GetMinFalloff() const {
    return GetSchemaValue<float>(m_ptr, "CColorCorrection", "m_MinFalloff");
}
void GCColorCorrection::SetMinFalloff(float value) {
    SetSchemaValue(m_ptr, "CColorCorrection", "m_MinFalloff", false, value);
}
float GCColorCorrection::GetMaxFalloff() const {
    return GetSchemaValue<float>(m_ptr, "CColorCorrection", "m_MaxFalloff");
}
void GCColorCorrection::SetMaxFalloff(float value) {
    SetSchemaValue(m_ptr, "CColorCorrection", "m_MaxFalloff", false, value);
}
float GCColorCorrection::GetCurWeight() const {
    return GetSchemaValue<float>(m_ptr, "CColorCorrection", "m_flCurWeight");
}
void GCColorCorrection::SetCurWeight(float value) {
    SetSchemaValue(m_ptr, "CColorCorrection", "m_flCurWeight", false, value);
}
std::string GCColorCorrection::GetNetlookupFilename() const {
    return GetSchemaValuePtr<char>(m_ptr, "CColorCorrection", "m_netlookupFilename");
}
void GCColorCorrection::SetNetlookupFilename(std::string value) {
    WriteSchemaPtrValue(m_ptr, "CColorCorrection", "m_netlookupFilename", false, reinterpret_cast<byte*>(const_cast<char*>(value.c_str())), 512);
}
std::string GCColorCorrection::GetLookupFilename() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CColorCorrection", "m_lookupFilename").String();
}
void GCColorCorrection::SetLookupFilename(std::string value) {
    SetSchemaValue(m_ptr, "CColorCorrection", "m_lookupFilename", false, CUtlSymbolLarge(value.c_str()));
}
void* GCColorCorrection::GetPtr() {
    return m_ptr;
}
std::string GCColorCorrection::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCColorCorrection::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseEntity GCColorCorrection::GetParent() const {
    GCBaseEntity value(m_ptr);
    return value;
}
void GCColorCorrection::SetParent(GCBaseEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCColorCorrection(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCColorCorrection>("CColorCorrection")
        .addConstructor<void (*)(std::string)>()
        .addProperty("FadeInDuration", &GCColorCorrection::GetFadeInDuration, &GCColorCorrection::SetFadeInDuration)
        .addProperty("FadeOutDuration", &GCColorCorrection::GetFadeOutDuration, &GCColorCorrection::SetFadeOutDuration)
        .addProperty("StartFadeInWeight", &GCColorCorrection::GetStartFadeInWeight, &GCColorCorrection::SetStartFadeInWeight)
        .addProperty("StartFadeOutWeight", &GCColorCorrection::GetStartFadeOutWeight, &GCColorCorrection::SetStartFadeOutWeight)
        .addProperty("TimeStartFadeIn", &GCColorCorrection::GetTimeStartFadeIn, &GCColorCorrection::SetTimeStartFadeIn)
        .addProperty("TimeStartFadeOut", &GCColorCorrection::GetTimeStartFadeOut, &GCColorCorrection::SetTimeStartFadeOut)
        .addProperty("MaxWeight", &GCColorCorrection::GetMaxWeight, &GCColorCorrection::SetMaxWeight)
        .addProperty("StartDisabled", &GCColorCorrection::GetStartDisabled, &GCColorCorrection::SetStartDisabled)
        .addProperty("Enabled", &GCColorCorrection::GetEnabled, &GCColorCorrection::SetEnabled)
        .addProperty("Master", &GCColorCorrection::GetMaster, &GCColorCorrection::SetMaster)
        .addProperty("ClientSide", &GCColorCorrection::GetClientSide, &GCColorCorrection::SetClientSide)
        .addProperty("Exclusive", &GCColorCorrection::GetExclusive, &GCColorCorrection::SetExclusive)
        .addProperty("MinFalloff", &GCColorCorrection::GetMinFalloff, &GCColorCorrection::SetMinFalloff)
        .addProperty("MaxFalloff", &GCColorCorrection::GetMaxFalloff, &GCColorCorrection::SetMaxFalloff)
        .addProperty("CurWeight", &GCColorCorrection::GetCurWeight, &GCColorCorrection::SetCurWeight)
        .addProperty("NetlookupFilename", &GCColorCorrection::GetNetlookupFilename, &GCColorCorrection::SetNetlookupFilename)
        .addProperty("LookupFilename", &GCColorCorrection::GetLookupFilename, &GCColorCorrection::SetLookupFilename)
        .addProperty("Parent", &GCColorCorrection::GetParent, &GCColorCorrection::SetParent)
        .addFunction("ToPtr", &GCColorCorrection::ToPtr)
        .addFunction("IsValid", &GCColorCorrection::IsValid)
        .endClass();
}
GCWeaponElite::GCWeaponElite(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCWeaponElite::GCWeaponElite(void *ptr) {
    m_ptr = ptr;
}
void* GCWeaponElite::GetPtr() {
    return m_ptr;
}
std::string GCWeaponElite::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCWeaponElite::IsValid() {
    return (m_ptr != nullptr);
}
GCCSWeaponBaseGun GCWeaponElite::GetParent() const {
    GCCSWeaponBaseGun value(m_ptr);
    return value;
}
void GCWeaponElite::SetParent(GCCSWeaponBaseGun value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCWeaponElite(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCWeaponElite>("CWeaponElite")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCWeaponElite::GetParent, &GCWeaponElite::SetParent)
        .addFunction("ToPtr", &GCWeaponElite::ToPtr)
        .addFunction("IsValid", &GCWeaponElite::IsValid)
        .endClass();
}
GCSoundEventEntityAlias_snd_event_point::GCSoundEventEntityAlias_snd_event_point(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCSoundEventEntityAlias_snd_event_point::GCSoundEventEntityAlias_snd_event_point(void *ptr) {
    m_ptr = ptr;
}
void* GCSoundEventEntityAlias_snd_event_point::GetPtr() {
    return m_ptr;
}
std::string GCSoundEventEntityAlias_snd_event_point::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCSoundEventEntityAlias_snd_event_point::IsValid() {
    return (m_ptr != nullptr);
}
GCSoundEventEntity GCSoundEventEntityAlias_snd_event_point::GetParent() const {
    GCSoundEventEntity value(m_ptr);
    return value;
}
void GCSoundEventEntityAlias_snd_event_point::SetParent(GCSoundEventEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCSoundEventEntityAlias_snd_event_point(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCSoundEventEntityAlias_snd_event_point>("CSoundEventEntityAlias_snd_event_point")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCSoundEventEntityAlias_snd_event_point::GetParent, &GCSoundEventEntityAlias_snd_event_point::SetParent)
        .addFunction("ToPtr", &GCSoundEventEntityAlias_snd_event_point::ToPtr)
        .addFunction("IsValid", &GCSoundEventEntityAlias_snd_event_point::IsValid)
        .endClass();
}
GCBaseEntityAPI::GCBaseEntityAPI(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCBaseEntityAPI::GCBaseEntityAPI(void *ptr) {
    m_ptr = ptr;
}
void* GCBaseEntityAPI::GetPtr() {
    return m_ptr;
}
std::string GCBaseEntityAPI::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCBaseEntityAPI::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCBaseEntityAPI(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCBaseEntityAPI>("CBaseEntityAPI")
        .addConstructor<void (*)(std::string)>()
        .addFunction("ToPtr", &GCBaseEntityAPI::ToPtr)
        .addFunction("IsValid", &GCBaseEntityAPI::IsValid)
        .endClass();
}
GCC4::GCC4(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCC4::GCC4(void *ptr) {
    m_ptr = ptr;
}
Vector GCC4::GetLastValidPlayerHeldPosition() const {
    return GetSchemaValue<Vector>(m_ptr, "CC4", "m_vecLastValidPlayerHeldPosition");
}
void GCC4::SetLastValidPlayerHeldPosition(Vector value) {
    SetSchemaValue(m_ptr, "CC4", "m_vecLastValidPlayerHeldPosition", false, value);
}
Vector GCC4::GetLastValidDroppedPosition() const {
    return GetSchemaValue<Vector>(m_ptr, "CC4", "m_vecLastValidDroppedPosition");
}
void GCC4::SetLastValidDroppedPosition(Vector value) {
    SetSchemaValue(m_ptr, "CC4", "m_vecLastValidDroppedPosition", false, value);
}
bool GCC4::GetDoValidDroppedPositionCheck() const {
    return GetSchemaValue<bool>(m_ptr, "CC4", "m_bDoValidDroppedPositionCheck");
}
void GCC4::SetDoValidDroppedPositionCheck(bool value) {
    SetSchemaValue(m_ptr, "CC4", "m_bDoValidDroppedPositionCheck", false, value);
}
bool GCC4::GetStartedArming() const {
    return GetSchemaValue<bool>(m_ptr, "CC4", "m_bStartedArming");
}
void GCC4::SetStartedArming(bool value) {
    SetSchemaValue(m_ptr, "CC4", "m_bStartedArming", false, value);
}
float GCC4::GetArmedTime() const {
    return GetSchemaValue<float>(m_ptr, "CC4", "m_fArmedTime");
}
void GCC4::SetArmedTime(float value) {
    SetSchemaValue(m_ptr, "CC4", "m_fArmedTime", false, value);
}
bool GCC4::GetBombPlacedAnimation() const {
    return GetSchemaValue<bool>(m_ptr, "CC4", "m_bBombPlacedAnimation");
}
void GCC4::SetBombPlacedAnimation(bool value) {
    SetSchemaValue(m_ptr, "CC4", "m_bBombPlacedAnimation", false, value);
}
bool GCC4::GetIsPlantingViaUse() const {
    return GetSchemaValue<bool>(m_ptr, "CC4", "m_bIsPlantingViaUse");
}
void GCC4::SetIsPlantingViaUse(bool value) {
    SetSchemaValue(m_ptr, "CC4", "m_bIsPlantingViaUse", false, value);
}
GEntitySpottedState_t GCC4::GetEntitySpottedState() const {
    GEntitySpottedState_t value(GetSchemaPtr(m_ptr, "CC4", "m_entitySpottedState"));
    return value;
}
void GCC4::SetEntitySpottedState(GEntitySpottedState_t value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'EntitySpottedState' is not possible.\n");
}
int32_t GCC4::GetSpotRules() const {
    return GetSchemaValue<int32_t>(m_ptr, "CC4", "m_nSpotRules");
}
void GCC4::SetSpotRules(int32_t value) {
    SetSchemaValue(m_ptr, "CC4", "m_nSpotRules", false, value);
}
std::vector<bool> GCC4::GetPlayedArmingBeeps() const {
    bool* outValue = (bool*)GetSchemaPtr(m_ptr, "CC4", "m_bPlayedArmingBeeps"); std::vector<bool> ret; for(int i = 0; i < 7; i++) { ret.push_back(outValue[i]); } return ret;
}
void GCC4::SetPlayedArmingBeeps(std::vector<bool> value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'PlayedArmingBeeps' is not possible.\n");
}
bool GCC4::GetBombPlanted() const {
    return GetSchemaValue<bool>(m_ptr, "CC4", "m_bBombPlanted");
}
void GCC4::SetBombPlanted(bool value) {
    SetSchemaValue(m_ptr, "CC4", "m_bBombPlanted", false, value);
}
void* GCC4::GetPtr() {
    return m_ptr;
}
std::string GCC4::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCC4::IsValid() {
    return (m_ptr != nullptr);
}
GCCSWeaponBase GCC4::GetParent() const {
    GCCSWeaponBase value(m_ptr);
    return value;
}
void GCC4::SetParent(GCCSWeaponBase value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCC4(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCC4>("CC4")
        .addConstructor<void (*)(std::string)>()
        .addProperty("LastValidPlayerHeldPosition", &GCC4::GetLastValidPlayerHeldPosition, &GCC4::SetLastValidPlayerHeldPosition)
        .addProperty("LastValidDroppedPosition", &GCC4::GetLastValidDroppedPosition, &GCC4::SetLastValidDroppedPosition)
        .addProperty("DoValidDroppedPositionCheck", &GCC4::GetDoValidDroppedPositionCheck, &GCC4::SetDoValidDroppedPositionCheck)
        .addProperty("StartedArming", &GCC4::GetStartedArming, &GCC4::SetStartedArming)
        .addProperty("ArmedTime", &GCC4::GetArmedTime, &GCC4::SetArmedTime)
        .addProperty("BombPlacedAnimation", &GCC4::GetBombPlacedAnimation, &GCC4::SetBombPlacedAnimation)
        .addProperty("IsPlantingViaUse", &GCC4::GetIsPlantingViaUse, &GCC4::SetIsPlantingViaUse)
        .addProperty("EntitySpottedState", &GCC4::GetEntitySpottedState, &GCC4::SetEntitySpottedState)
        .addProperty("SpotRules", &GCC4::GetSpotRules, &GCC4::SetSpotRules)
        .addProperty("PlayedArmingBeeps", &GCC4::GetPlayedArmingBeeps, &GCC4::SetPlayedArmingBeeps)
        .addProperty("BombPlanted", &GCC4::GetBombPlanted, &GCC4::SetBombPlanted)
        .addProperty("Parent", &GCC4::GetParent, &GCC4::SetParent)
        .addFunction("ToPtr", &GCC4::ToPtr)
        .addFunction("IsValid", &GCC4::IsValid)
        .endClass();
}
GCHostageRescueZone::GCHostageRescueZone(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCHostageRescueZone::GCHostageRescueZone(void *ptr) {
    m_ptr = ptr;
}
void* GCHostageRescueZone::GetPtr() {
    return m_ptr;
}
std::string GCHostageRescueZone::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCHostageRescueZone::IsValid() {
    return (m_ptr != nullptr);
}
GCHostageRescueZoneShim GCHostageRescueZone::GetParent() const {
    GCHostageRescueZoneShim value(m_ptr);
    return value;
}
void GCHostageRescueZone::SetParent(GCHostageRescueZoneShim value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCHostageRescueZone(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCHostageRescueZone>("CHostageRescueZone")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCHostageRescueZone::GetParent, &GCHostageRescueZone::SetParent)
        .addFunction("ToPtr", &GCHostageRescueZone::ToPtr)
        .addFunction("IsValid", &GCHostageRescueZone::IsValid)
        .endClass();
}
GCPointPrefab::GCPointPrefab(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCPointPrefab::GCPointPrefab(void *ptr) {
    m_ptr = ptr;
}
std::string GCPointPrefab::GetTargetMapName() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CPointPrefab", "m_targetMapName").String();
}
void GCPointPrefab::SetTargetMapName(std::string value) {
    SetSchemaValue(m_ptr, "CPointPrefab", "m_targetMapName", false, CUtlSymbolLarge(value.c_str()));
}
std::string GCPointPrefab::GetForceWorldGroupID() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CPointPrefab", "m_forceWorldGroupID").String();
}
void GCPointPrefab::SetForceWorldGroupID(std::string value) {
    SetSchemaValue(m_ptr, "CPointPrefab", "m_forceWorldGroupID", false, CUtlSymbolLarge(value.c_str()));
}
std::string GCPointPrefab::GetAssociatedRelayTargetName() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CPointPrefab", "m_associatedRelayTargetName").String();
}
void GCPointPrefab::SetAssociatedRelayTargetName(std::string value) {
    SetSchemaValue(m_ptr, "CPointPrefab", "m_associatedRelayTargetName", false, CUtlSymbolLarge(value.c_str()));
}
bool GCPointPrefab::GetFixupNames() const {
    return GetSchemaValue<bool>(m_ptr, "CPointPrefab", "m_fixupNames");
}
void GCPointPrefab::SetFixupNames(bool value) {
    SetSchemaValue(m_ptr, "CPointPrefab", "m_fixupNames", false, value);
}
bool GCPointPrefab::GetLoadDynamic() const {
    return GetSchemaValue<bool>(m_ptr, "CPointPrefab", "m_bLoadDynamic");
}
void GCPointPrefab::SetLoadDynamic(bool value) {
    SetSchemaValue(m_ptr, "CPointPrefab", "m_bLoadDynamic", false, value);
}
GCPointPrefab GCPointPrefab::GetAssociatedRelayEntity() const {
    GCPointPrefab value((void*)(GetSchemaValue<CHandle<CEntityInstance>>(m_ptr, "CPointPrefab", "m_associatedRelayEntity").Get()));
    return value;
}
void GCPointPrefab::SetAssociatedRelayEntity(GCPointPrefab value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'AssociatedRelayEntity' is not possible.\n");
}
void* GCPointPrefab::GetPtr() {
    return m_ptr;
}
std::string GCPointPrefab::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCPointPrefab::IsValid() {
    return (m_ptr != nullptr);
}
GCServerOnlyPointEntity GCPointPrefab::GetParent() const {
    GCServerOnlyPointEntity value(m_ptr);
    return value;
}
void GCPointPrefab::SetParent(GCServerOnlyPointEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCPointPrefab(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCPointPrefab>("CPointPrefab")
        .addConstructor<void (*)(std::string)>()
        .addProperty("TargetMapName", &GCPointPrefab::GetTargetMapName, &GCPointPrefab::SetTargetMapName)
        .addProperty("ForceWorldGroupID", &GCPointPrefab::GetForceWorldGroupID, &GCPointPrefab::SetForceWorldGroupID)
        .addProperty("AssociatedRelayTargetName", &GCPointPrefab::GetAssociatedRelayTargetName, &GCPointPrefab::SetAssociatedRelayTargetName)
        .addProperty("FixupNames", &GCPointPrefab::GetFixupNames, &GCPointPrefab::SetFixupNames)
        .addProperty("LoadDynamic", &GCPointPrefab::GetLoadDynamic, &GCPointPrefab::SetLoadDynamic)
        .addProperty("AssociatedRelayEntity", &GCPointPrefab::GetAssociatedRelayEntity, &GCPointPrefab::SetAssociatedRelayEntity)
        .addProperty("Parent", &GCPointPrefab::GetParent, &GCPointPrefab::SetParent)
        .addFunction("ToPtr", &GCPointPrefab::ToPtr)
        .addFunction("IsValid", &GCPointPrefab::IsValid)
        .endClass();
}
GCRotDoor::GCRotDoor(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCRotDoor::GCRotDoor(void *ptr) {
    m_ptr = ptr;
}
bool GCRotDoor::GetSolidBsp() const {
    return GetSchemaValue<bool>(m_ptr, "CRotDoor", "m_bSolidBsp");
}
void GCRotDoor::SetSolidBsp(bool value) {
    SetSchemaValue(m_ptr, "CRotDoor", "m_bSolidBsp", false, value);
}
void* GCRotDoor::GetPtr() {
    return m_ptr;
}
std::string GCRotDoor::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCRotDoor::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseDoor GCRotDoor::GetParent() const {
    GCBaseDoor value(m_ptr);
    return value;
}
void GCRotDoor::SetParent(GCBaseDoor value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCRotDoor(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCRotDoor>("CRotDoor")
        .addConstructor<void (*)(std::string)>()
        .addProperty("SolidBsp", &GCRotDoor::GetSolidBsp, &GCRotDoor::SetSolidBsp)
        .addProperty("Parent", &GCRotDoor::GetParent, &GCRotDoor::SetParent)
        .addFunction("ToPtr", &GCRotDoor::ToPtr)
        .addFunction("IsValid", &GCRotDoor::IsValid)
        .endClass();
}
GCSkeletonAnimationController::GCSkeletonAnimationController(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCSkeletonAnimationController::GCSkeletonAnimationController(void *ptr) {
    m_ptr = ptr;
}
GCSkeletonInstance GCSkeletonAnimationController::GetSkeletonInstance() const {
    GCSkeletonInstance value(*(void**)GetSchemaPtr(m_ptr, "CSkeletonAnimationController", "m_pSkeletonInstance"));
    return value;
}
void GCSkeletonAnimationController::SetSkeletonInstance(GCSkeletonInstance value) {
    SetSchemaValue(m_ptr, "CSkeletonAnimationController","m_pSkeletonInstance", false, (char*)value.GetPtr());
}
void* GCSkeletonAnimationController::GetPtr() {
    return m_ptr;
}
std::string GCSkeletonAnimationController::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCSkeletonAnimationController::IsValid() {
    return (m_ptr != nullptr);
}
GISkeletonAnimationController GCSkeletonAnimationController::GetParent() const {
    GISkeletonAnimationController value(m_ptr);
    return value;
}
void GCSkeletonAnimationController::SetParent(GISkeletonAnimationController value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCSkeletonAnimationController(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCSkeletonAnimationController>("CSkeletonAnimationController")
        .addConstructor<void (*)(std::string)>()
        .addProperty("SkeletonInstance", &GCSkeletonAnimationController::GetSkeletonInstance, &GCSkeletonAnimationController::SetSkeletonInstance)
        .addProperty("Parent", &GCSkeletonAnimationController::GetParent, &GCSkeletonAnimationController::SetParent)
        .addFunction("ToPtr", &GCSkeletonAnimationController::ToPtr)
        .addFunction("IsValid", &GCSkeletonAnimationController::IsValid)
        .endClass();
}
GCTablet::GCTablet(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCTablet::GCTablet(void *ptr) {
    m_ptr = ptr;
}
void* GCTablet::GetPtr() {
    return m_ptr;
}
std::string GCTablet::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCTablet::IsValid() {
    return (m_ptr != nullptr);
}
GCCSWeaponBase GCTablet::GetParent() const {
    GCCSWeaponBase value(m_ptr);
    return value;
}
void GCTablet::SetParent(GCCSWeaponBase value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCTablet(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCTablet>("CTablet")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCTablet::GetParent, &GCTablet::SetParent)
        .addFunction("ToPtr", &GCTablet::ToPtr)
        .addFunction("IsValid", &GCTablet::IsValid)
        .endClass();
}
GCTankTrainAI::GCTankTrainAI(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCTankTrainAI::GCTankTrainAI(void *ptr) {
    m_ptr = ptr;
}
GCFuncTrackTrain GCTankTrainAI::GetTrain() const {
    GCFuncTrackTrain value((void*)(GetSchemaValue<CHandle<CEntityInstance>>(m_ptr, "CTankTrainAI", "m_hTrain").Get()));
    return value;
}
void GCTankTrainAI::SetTrain(GCFuncTrackTrain value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Train' is not possible.\n");
}
GCBaseEntity GCTankTrainAI::GetTargetEntity() const {
    GCBaseEntity value((void*)(GetSchemaValue<CHandle<CEntityInstance>>(m_ptr, "CTankTrainAI", "m_hTargetEntity").Get()));
    return value;
}
void GCTankTrainAI::SetTargetEntity(GCBaseEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'TargetEntity' is not possible.\n");
}
int32_t GCTankTrainAI::GetSoundPlaying() const {
    return GetSchemaValue<int32_t>(m_ptr, "CTankTrainAI", "m_soundPlaying");
}
void GCTankTrainAI::SetSoundPlaying(int32_t value) {
    SetSchemaValue(m_ptr, "CTankTrainAI", "m_soundPlaying", false, value);
}
std::string GCTankTrainAI::GetStartSoundName() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CTankTrainAI", "m_startSoundName").String();
}
void GCTankTrainAI::SetStartSoundName(std::string value) {
    SetSchemaValue(m_ptr, "CTankTrainAI", "m_startSoundName", false, CUtlSymbolLarge(value.c_str()));
}
std::string GCTankTrainAI::GetEngineSoundName() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CTankTrainAI", "m_engineSoundName").String();
}
void GCTankTrainAI::SetEngineSoundName(std::string value) {
    SetSchemaValue(m_ptr, "CTankTrainAI", "m_engineSoundName", false, CUtlSymbolLarge(value.c_str()));
}
std::string GCTankTrainAI::GetMovementSoundName() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CTankTrainAI", "m_movementSoundName").String();
}
void GCTankTrainAI::SetMovementSoundName(std::string value) {
    SetSchemaValue(m_ptr, "CTankTrainAI", "m_movementSoundName", false, CUtlSymbolLarge(value.c_str()));
}
std::string GCTankTrainAI::GetTargetEntityName() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CTankTrainAI", "m_targetEntityName").String();
}
void GCTankTrainAI::SetTargetEntityName(std::string value) {
    SetSchemaValue(m_ptr, "CTankTrainAI", "m_targetEntityName", false, CUtlSymbolLarge(value.c_str()));
}
void* GCTankTrainAI::GetPtr() {
    return m_ptr;
}
std::string GCTankTrainAI::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCTankTrainAI::IsValid() {
    return (m_ptr != nullptr);
}
GCPointEntity GCTankTrainAI::GetParent() const {
    GCPointEntity value(m_ptr);
    return value;
}
void GCTankTrainAI::SetParent(GCPointEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCTankTrainAI(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCTankTrainAI>("CTankTrainAI")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Train", &GCTankTrainAI::GetTrain, &GCTankTrainAI::SetTrain)
        .addProperty("TargetEntity", &GCTankTrainAI::GetTargetEntity, &GCTankTrainAI::SetTargetEntity)
        .addProperty("SoundPlaying", &GCTankTrainAI::GetSoundPlaying, &GCTankTrainAI::SetSoundPlaying)
        .addProperty("StartSoundName", &GCTankTrainAI::GetStartSoundName, &GCTankTrainAI::SetStartSoundName)
        .addProperty("EngineSoundName", &GCTankTrainAI::GetEngineSoundName, &GCTankTrainAI::SetEngineSoundName)
        .addProperty("MovementSoundName", &GCTankTrainAI::GetMovementSoundName, &GCTankTrainAI::SetMovementSoundName)
        .addProperty("TargetEntityName", &GCTankTrainAI::GetTargetEntityName, &GCTankTrainAI::SetTargetEntityName)
        .addProperty("Parent", &GCTankTrainAI::GetParent, &GCTankTrainAI::SetParent)
        .addFunction("ToPtr", &GCTankTrainAI::ToPtr)
        .addFunction("IsValid", &GCTankTrainAI::IsValid)
        .endClass();
}
GCGameGibManager::GCGameGibManager(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCGameGibManager::GCGameGibManager(void *ptr) {
    m_ptr = ptr;
}
bool GCGameGibManager::GetAllowNewGibs() const {
    return GetSchemaValue<bool>(m_ptr, "CGameGibManager", "m_bAllowNewGibs");
}
void GCGameGibManager::SetAllowNewGibs(bool value) {
    SetSchemaValue(m_ptr, "CGameGibManager", "m_bAllowNewGibs", false, value);
}
int32_t GCGameGibManager::GetCurrentMaxPieces() const {
    return GetSchemaValue<int32_t>(m_ptr, "CGameGibManager", "m_iCurrentMaxPieces");
}
void GCGameGibManager::SetCurrentMaxPieces(int32_t value) {
    SetSchemaValue(m_ptr, "CGameGibManager", "m_iCurrentMaxPieces", false, value);
}
int32_t GCGameGibManager::GetMaxPieces() const {
    return GetSchemaValue<int32_t>(m_ptr, "CGameGibManager", "m_iMaxPieces");
}
void GCGameGibManager::SetMaxPieces(int32_t value) {
    SetSchemaValue(m_ptr, "CGameGibManager", "m_iMaxPieces", false, value);
}
int32_t GCGameGibManager::GetLastFrame() const {
    return GetSchemaValue<int32_t>(m_ptr, "CGameGibManager", "m_iLastFrame");
}
void GCGameGibManager::SetLastFrame(int32_t value) {
    SetSchemaValue(m_ptr, "CGameGibManager", "m_iLastFrame", false, value);
}
void* GCGameGibManager::GetPtr() {
    return m_ptr;
}
std::string GCGameGibManager::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCGameGibManager::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseEntity GCGameGibManager::GetParent() const {
    GCBaseEntity value(m_ptr);
    return value;
}
void GCGameGibManager::SetParent(GCBaseEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCGameGibManager(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCGameGibManager>("CGameGibManager")
        .addConstructor<void (*)(std::string)>()
        .addProperty("AllowNewGibs", &GCGameGibManager::GetAllowNewGibs, &GCGameGibManager::SetAllowNewGibs)
        .addProperty("CurrentMaxPieces", &GCGameGibManager::GetCurrentMaxPieces, &GCGameGibManager::SetCurrentMaxPieces)
        .addProperty("MaxPieces", &GCGameGibManager::GetMaxPieces, &GCGameGibManager::SetMaxPieces)
        .addProperty("LastFrame", &GCGameGibManager::GetLastFrame, &GCGameGibManager::SetLastFrame)
        .addProperty("Parent", &GCGameGibManager::GetParent, &GCGameGibManager::SetParent)
        .addFunction("ToPtr", &GCGameGibManager::ToPtr)
        .addFunction("IsValid", &GCGameGibManager::IsValid)
        .endClass();
}
GCCSPointScript::GCCSPointScript(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCCSPointScript::GCCSPointScript(void *ptr) {
    m_ptr = ptr;
}
GCCSPointScriptEntity GCCSPointScript::GetParent() const {
    GCCSPointScriptEntity value(*(void**)GetSchemaPtr(m_ptr, "CCSPointScript", "m_pParent"));
    return value;
}
void GCCSPointScript::SetParent(GCCSPointScriptEntity value) {
    SetSchemaValue(m_ptr, "CCSPointScript","m_pParent", false, (char*)value.GetPtr());
}
void* GCCSPointScript::GetPtr() {
    return m_ptr;
}
std::string GCCSPointScript::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCCSPointScript::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCCSPointScript(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCCSPointScript>("CCSPointScript")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCCSPointScript::GetParent, &GCCSPointScript::SetParent)
        .addFunction("ToPtr", &GCCSPointScript::ToPtr)
        .addFunction("IsValid", &GCCSPointScript::IsValid)
        .endClass();
}
GCRagdollPropAlias_physics_prop_ragdoll::GCRagdollPropAlias_physics_prop_ragdoll(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCRagdollPropAlias_physics_prop_ragdoll::GCRagdollPropAlias_physics_prop_ragdoll(void *ptr) {
    m_ptr = ptr;
}
void* GCRagdollPropAlias_physics_prop_ragdoll::GetPtr() {
    return m_ptr;
}
std::string GCRagdollPropAlias_physics_prop_ragdoll::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCRagdollPropAlias_physics_prop_ragdoll::IsValid() {
    return (m_ptr != nullptr);
}
GCRagdollProp GCRagdollPropAlias_physics_prop_ragdoll::GetParent() const {
    GCRagdollProp value(m_ptr);
    return value;
}
void GCRagdollPropAlias_physics_prop_ragdoll::SetParent(GCRagdollProp value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCRagdollPropAlias_physics_prop_ragdoll(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCRagdollPropAlias_physics_prop_ragdoll>("CRagdollPropAlias_physics_prop_ragdoll")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCRagdollPropAlias_physics_prop_ragdoll::GetParent, &GCRagdollPropAlias_physics_prop_ragdoll::SetParent)
        .addFunction("ToPtr", &GCRagdollPropAlias_physics_prop_ragdoll::ToPtr)
        .addFunction("IsValid", &GCRagdollPropAlias_physics_prop_ragdoll::IsValid)
        .endClass();
}
GCCSSprite::GCCSSprite(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCCSSprite::GCCSSprite(void *ptr) {
    m_ptr = ptr;
}
void* GCCSSprite::GetPtr() {
    return m_ptr;
}
std::string GCCSSprite::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCCSSprite::IsValid() {
    return (m_ptr != nullptr);
}
GCSprite GCCSSprite::GetParent() const {
    GCSprite value(m_ptr);
    return value;
}
void GCCSSprite::SetParent(GCSprite value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCCSSprite(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCCSSprite>("CCSSprite")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCCSSprite::GetParent, &GCCSSprite::SetParent)
        .addFunction("ToPtr", &GCCSSprite::ToPtr)
        .addFunction("IsValid", &GCCSSprite::IsValid)
        .endClass();
}
GCFuncPropRespawnZone::GCFuncPropRespawnZone(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCFuncPropRespawnZone::GCFuncPropRespawnZone(void *ptr) {
    m_ptr = ptr;
}
void* GCFuncPropRespawnZone::GetPtr() {
    return m_ptr;
}
std::string GCFuncPropRespawnZone::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCFuncPropRespawnZone::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseEntity GCFuncPropRespawnZone::GetParent() const {
    GCBaseEntity value(m_ptr);
    return value;
}
void GCFuncPropRespawnZone::SetParent(GCBaseEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCFuncPropRespawnZone(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCFuncPropRespawnZone>("CFuncPropRespawnZone")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCFuncPropRespawnZone::GetParent, &GCFuncPropRespawnZone::SetParent)
        .addFunction("ToPtr", &GCFuncPropRespawnZone::ToPtr)
        .addFunction("IsValid", &GCFuncPropRespawnZone::IsValid)
        .endClass();
}
GCInfoDeathmatchSpawn::GCInfoDeathmatchSpawn(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCInfoDeathmatchSpawn::GCInfoDeathmatchSpawn(void *ptr) {
    m_ptr = ptr;
}
void* GCInfoDeathmatchSpawn::GetPtr() {
    return m_ptr;
}
std::string GCInfoDeathmatchSpawn::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCInfoDeathmatchSpawn::IsValid() {
    return (m_ptr != nullptr);
}
GSpawnPoint GCInfoDeathmatchSpawn::GetParent() const {
    GSpawnPoint value(m_ptr);
    return value;
}
void GCInfoDeathmatchSpawn::SetParent(GSpawnPoint value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCInfoDeathmatchSpawn(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCInfoDeathmatchSpawn>("CInfoDeathmatchSpawn")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCInfoDeathmatchSpawn::GetParent, &GCInfoDeathmatchSpawn::SetParent)
        .addFunction("ToPtr", &GCInfoDeathmatchSpawn::ToPtr)
        .addFunction("IsValid", &GCInfoDeathmatchSpawn::IsValid)
        .endClass();
}
GCWeaponSCAR20::GCWeaponSCAR20(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCWeaponSCAR20::GCWeaponSCAR20(void *ptr) {
    m_ptr = ptr;
}
void* GCWeaponSCAR20::GetPtr() {
    return m_ptr;
}
std::string GCWeaponSCAR20::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCWeaponSCAR20::IsValid() {
    return (m_ptr != nullptr);
}
GCCSWeaponBaseGun GCWeaponSCAR20::GetParent() const {
    GCCSWeaponBaseGun value(m_ptr);
    return value;
}
void GCWeaponSCAR20::SetParent(GCCSWeaponBaseGun value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCWeaponSCAR20(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCWeaponSCAR20>("CWeaponSCAR20")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCWeaponSCAR20::GetParent, &GCWeaponSCAR20::SetParent)
        .addFunction("ToPtr", &GCWeaponSCAR20::ToPtr)
        .addFunction("IsValid", &GCWeaponSCAR20::IsValid)
        .endClass();
}
GCTripWireFireProjectile::GCTripWireFireProjectile(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCTripWireFireProjectile::GCTripWireFireProjectile(void *ptr) {
    m_ptr = ptr;
}
void* GCTripWireFireProjectile::GetPtr() {
    return m_ptr;
}
std::string GCTripWireFireProjectile::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCTripWireFireProjectile::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseGrenade GCTripWireFireProjectile::GetParent() const {
    GCBaseGrenade value(m_ptr);
    return value;
}
void GCTripWireFireProjectile::SetParent(GCBaseGrenade value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCTripWireFireProjectile(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCTripWireFireProjectile>("CTripWireFireProjectile")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCTripWireFireProjectile::GetParent, &GCTripWireFireProjectile::SetParent)
        .addFunction("ToPtr", &GCTripWireFireProjectile::ToPtr)
        .addFunction("IsValid", &GCTripWireFireProjectile::IsValid)
        .endClass();
}
GCFuncTrackAuto::GCFuncTrackAuto(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCFuncTrackAuto::GCFuncTrackAuto(void *ptr) {
    m_ptr = ptr;
}
void* GCFuncTrackAuto::GetPtr() {
    return m_ptr;
}
std::string GCFuncTrackAuto::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCFuncTrackAuto::IsValid() {
    return (m_ptr != nullptr);
}
GCFuncTrackChange GCFuncTrackAuto::GetParent() const {
    GCFuncTrackChange value(m_ptr);
    return value;
}
void GCFuncTrackAuto::SetParent(GCFuncTrackChange value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCFuncTrackAuto(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCFuncTrackAuto>("CFuncTrackAuto")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCFuncTrackAuto::GetParent, &GCFuncTrackAuto::SetParent)
        .addFunction("ToPtr", &GCFuncTrackAuto::ToPtr)
        .addFunction("IsValid", &GCFuncTrackAuto::IsValid)
        .endClass();
}
GCEnvSpark::GCEnvSpark(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCEnvSpark::GCEnvSpark(void *ptr) {
    m_ptr = ptr;
}
float GCEnvSpark::GetDelay() const {
    return GetSchemaValue<float>(m_ptr, "CEnvSpark", "m_flDelay");
}
void GCEnvSpark::SetDelay(float value) {
    SetSchemaValue(m_ptr, "CEnvSpark", "m_flDelay", false, value);
}
int32_t GCEnvSpark::GetMagnitude() const {
    return GetSchemaValue<int32_t>(m_ptr, "CEnvSpark", "m_nMagnitude");
}
void GCEnvSpark::SetMagnitude(int32_t value) {
    SetSchemaValue(m_ptr, "CEnvSpark", "m_nMagnitude", false, value);
}
int32_t GCEnvSpark::GetTrailLength() const {
    return GetSchemaValue<int32_t>(m_ptr, "CEnvSpark", "m_nTrailLength");
}
void GCEnvSpark::SetTrailLength(int32_t value) {
    SetSchemaValue(m_ptr, "CEnvSpark", "m_nTrailLength", false, value);
}
int32_t GCEnvSpark::GetType() const {
    return GetSchemaValue<int32_t>(m_ptr, "CEnvSpark", "m_nType");
}
void GCEnvSpark::SetType(int32_t value) {
    SetSchemaValue(m_ptr, "CEnvSpark", "m_nType", false, value);
}
GCEntityIOOutput GCEnvSpark::GetOnSpark() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CEnvSpark", "m_OnSpark"));
    return value;
}
void GCEnvSpark::SetOnSpark(GCEntityIOOutput value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'OnSpark' is not possible.\n");
}
void* GCEnvSpark::GetPtr() {
    return m_ptr;
}
std::string GCEnvSpark::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCEnvSpark::IsValid() {
    return (m_ptr != nullptr);
}
GCPointEntity GCEnvSpark::GetParent() const {
    GCPointEntity value(m_ptr);
    return value;
}
void GCEnvSpark::SetParent(GCPointEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCEnvSpark(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCEnvSpark>("CEnvSpark")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Delay", &GCEnvSpark::GetDelay, &GCEnvSpark::SetDelay)
        .addProperty("Magnitude", &GCEnvSpark::GetMagnitude, &GCEnvSpark::SetMagnitude)
        .addProperty("TrailLength", &GCEnvSpark::GetTrailLength, &GCEnvSpark::SetTrailLength)
        .addProperty("Type", &GCEnvSpark::GetType, &GCEnvSpark::SetType)
        .addProperty("OnSpark", &GCEnvSpark::GetOnSpark, &GCEnvSpark::SetOnSpark)
        .addProperty("Parent", &GCEnvSpark::GetParent, &GCEnvSpark::SetParent)
        .addFunction("ToPtr", &GCEnvSpark::ToPtr)
        .addFunction("IsValid", &GCEnvSpark::IsValid)
        .endClass();
}
GCCSObserver_ObserverServices::GCCSObserver_ObserverServices(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCCSObserver_ObserverServices::GCCSObserver_ObserverServices(void *ptr) {
    m_ptr = ptr;
}
void* GCCSObserver_ObserverServices::GetPtr() {
    return m_ptr;
}
std::string GCCSObserver_ObserverServices::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCCSObserver_ObserverServices::IsValid() {
    return (m_ptr != nullptr);
}
GCPlayer_ObserverServices GCCSObserver_ObserverServices::GetParent() const {
    GCPlayer_ObserverServices value(m_ptr);
    return value;
}
void GCCSObserver_ObserverServices::SetParent(GCPlayer_ObserverServices value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCCSObserver_ObserverServices(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCCSObserver_ObserverServices>("CCSObserver_ObserverServices")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCCSObserver_ObserverServices::GetParent, &GCCSObserver_ObserverServices::SetParent)
        .addFunction("ToPtr", &GCCSObserver_ObserverServices::ToPtr)
        .addFunction("IsValid", &GCCSObserver_ObserverServices::IsValid)
        .endClass();
}
GCPlayer_AutoaimServices::GCPlayer_AutoaimServices(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCPlayer_AutoaimServices::GCPlayer_AutoaimServices(void *ptr) {
    m_ptr = ptr;
}
void* GCPlayer_AutoaimServices::GetPtr() {
    return m_ptr;
}
std::string GCPlayer_AutoaimServices::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCPlayer_AutoaimServices::IsValid() {
    return (m_ptr != nullptr);
}
GCPlayerPawnComponent GCPlayer_AutoaimServices::GetParent() const {
    GCPlayerPawnComponent value(m_ptr);
    return value;
}
void GCPlayer_AutoaimServices::SetParent(GCPlayerPawnComponent value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCPlayer_AutoaimServices(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCPlayer_AutoaimServices>("CPlayer_AutoaimServices")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCPlayer_AutoaimServices::GetParent, &GCPlayer_AutoaimServices::SetParent)
        .addFunction("ToPtr", &GCPlayer_AutoaimServices::ToPtr)
        .addFunction("IsValid", &GCPlayer_AutoaimServices::IsValid)
        .endClass();
}
GCFuncTrain::GCFuncTrain(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCFuncTrain::GCFuncTrain(void *ptr) {
    m_ptr = ptr;
}
GCBaseEntity GCFuncTrain::GetCurrentTarget() const {
    GCBaseEntity value((void*)(GetSchemaValue<CHandle<CEntityInstance>>(m_ptr, "CFuncTrain", "m_hCurrentTarget").Get()));
    return value;
}
void GCFuncTrain::SetCurrentTarget(GCBaseEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'CurrentTarget' is not possible.\n");
}
bool GCFuncTrain::GetActivated() const {
    return GetSchemaValue<bool>(m_ptr, "CFuncTrain", "m_activated");
}
void GCFuncTrain::SetActivated(bool value) {
    SetSchemaValue(m_ptr, "CFuncTrain", "m_activated", false, value);
}
GCBaseEntity GCFuncTrain::GetEnemy() const {
    GCBaseEntity value((void*)(GetSchemaValue<CHandle<CEntityInstance>>(m_ptr, "CFuncTrain", "m_hEnemy").Get()));
    return value;
}
void GCFuncTrain::SetEnemy(GCBaseEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Enemy' is not possible.\n");
}
float GCFuncTrain::GetBlockDamage() const {
    return GetSchemaValue<float>(m_ptr, "CFuncTrain", "m_flBlockDamage");
}
void GCFuncTrain::SetBlockDamage(float value) {
    SetSchemaValue(m_ptr, "CFuncTrain", "m_flBlockDamage", false, value);
}
float GCFuncTrain::GetNextBlockTime() const {
    return GetSchemaValue<float>(m_ptr, "CFuncTrain", "m_flNextBlockTime");
}
void GCFuncTrain::SetNextBlockTime(float value) {
    SetSchemaValue(m_ptr, "CFuncTrain", "m_flNextBlockTime", false, value);
}
std::string GCFuncTrain::GetLastTarget() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CFuncTrain", "m_iszLastTarget").String();
}
void GCFuncTrain::SetLastTarget(std::string value) {
    SetSchemaValue(m_ptr, "CFuncTrain", "m_iszLastTarget", false, CUtlSymbolLarge(value.c_str()));
}
void* GCFuncTrain::GetPtr() {
    return m_ptr;
}
std::string GCFuncTrain::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCFuncTrain::IsValid() {
    return (m_ptr != nullptr);
}
GCBasePlatTrain GCFuncTrain::GetParent() const {
    GCBasePlatTrain value(m_ptr);
    return value;
}
void GCFuncTrain::SetParent(GCBasePlatTrain value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCFuncTrain(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCFuncTrain>("CFuncTrain")
        .addConstructor<void (*)(std::string)>()
        .addProperty("CurrentTarget", &GCFuncTrain::GetCurrentTarget, &GCFuncTrain::SetCurrentTarget)
        .addProperty("Activated", &GCFuncTrain::GetActivated, &GCFuncTrain::SetActivated)
        .addProperty("Enemy", &GCFuncTrain::GetEnemy, &GCFuncTrain::SetEnemy)
        .addProperty("BlockDamage", &GCFuncTrain::GetBlockDamage, &GCFuncTrain::SetBlockDamage)
        .addProperty("NextBlockTime", &GCFuncTrain::GetNextBlockTime, &GCFuncTrain::SetNextBlockTime)
        .addProperty("LastTarget", &GCFuncTrain::GetLastTarget, &GCFuncTrain::SetLastTarget)
        .addProperty("Parent", &GCFuncTrain::GetParent, &GCFuncTrain::SetParent)
        .addFunction("ToPtr", &GCFuncTrain::ToPtr)
        .addFunction("IsValid", &GCFuncTrain::IsValid)
        .endClass();
}
GCHostageAlias_info_hostage_spawn::GCHostageAlias_info_hostage_spawn(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCHostageAlias_info_hostage_spawn::GCHostageAlias_info_hostage_spawn(void *ptr) {
    m_ptr = ptr;
}
void* GCHostageAlias_info_hostage_spawn::GetPtr() {
    return m_ptr;
}
std::string GCHostageAlias_info_hostage_spawn::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCHostageAlias_info_hostage_spawn::IsValid() {
    return (m_ptr != nullptr);
}
GCHostage GCHostageAlias_info_hostage_spawn::GetParent() const {
    GCHostage value(m_ptr);
    return value;
}
void GCHostageAlias_info_hostage_spawn::SetParent(GCHostage value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCHostageAlias_info_hostage_spawn(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCHostageAlias_info_hostage_spawn>("CHostageAlias_info_hostage_spawn")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCHostageAlias_info_hostage_spawn::GetParent, &GCHostageAlias_info_hostage_spawn::SetParent)
        .addFunction("ToPtr", &GCHostageAlias_info_hostage_spawn::ToPtr)
        .addFunction("IsValid", &GCHostageAlias_info_hostage_spawn::IsValid)
        .endClass();
}
GCNavLinkAreaEntity::GCNavLinkAreaEntity(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCNavLinkAreaEntity::GCNavLinkAreaEntity(void *ptr) {
    m_ptr = ptr;
}
float GCNavLinkAreaEntity::GetWidth() const {
    return GetSchemaValue<float>(m_ptr, "CNavLinkAreaEntity", "m_flWidth");
}
void GCNavLinkAreaEntity::SetWidth(float value) {
    SetSchemaValue(m_ptr, "CNavLinkAreaEntity", "m_flWidth", false, value);
}
Vector GCNavLinkAreaEntity::GetLocatorOffset() const {
    return GetSchemaValue<Vector>(m_ptr, "CNavLinkAreaEntity", "m_vLocatorOffset");
}
void GCNavLinkAreaEntity::SetLocatorOffset(Vector value) {
    SetSchemaValue(m_ptr, "CNavLinkAreaEntity", "m_vLocatorOffset", false, value);
}
QAngle GCNavLinkAreaEntity::GetLocatorAnglesOffset() const {
    return GetSchemaValue<QAngle>(m_ptr, "CNavLinkAreaEntity", "m_qLocatorAnglesOffset");
}
void GCNavLinkAreaEntity::SetLocatorAnglesOffset(QAngle value) {
    SetSchemaValue(m_ptr, "CNavLinkAreaEntity", "m_qLocatorAnglesOffset", false, value);
}
std::string GCNavLinkAreaEntity::GetStrMovementForward() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CNavLinkAreaEntity", "m_strMovementForward").String();
}
void GCNavLinkAreaEntity::SetStrMovementForward(std::string value) {
    SetSchemaValue(m_ptr, "CNavLinkAreaEntity", "m_strMovementForward", false, CUtlSymbolLarge(value.c_str()));
}
std::string GCNavLinkAreaEntity::GetStrMovementReverse() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CNavLinkAreaEntity", "m_strMovementReverse").String();
}
void GCNavLinkAreaEntity::SetStrMovementReverse(std::string value) {
    SetSchemaValue(m_ptr, "CNavLinkAreaEntity", "m_strMovementReverse", false, CUtlSymbolLarge(value.c_str()));
}
int32_t GCNavLinkAreaEntity::GetNavLinkIdForward() const {
    return GetSchemaValue<int32_t>(m_ptr, "CNavLinkAreaEntity", "m_nNavLinkIdForward");
}
void GCNavLinkAreaEntity::SetNavLinkIdForward(int32_t value) {
    SetSchemaValue(m_ptr, "CNavLinkAreaEntity", "m_nNavLinkIdForward", false, value);
}
int32_t GCNavLinkAreaEntity::GetNavLinkIdReverse() const {
    return GetSchemaValue<int32_t>(m_ptr, "CNavLinkAreaEntity", "m_nNavLinkIdReverse");
}
void GCNavLinkAreaEntity::SetNavLinkIdReverse(int32_t value) {
    SetSchemaValue(m_ptr, "CNavLinkAreaEntity", "m_nNavLinkIdReverse", false, value);
}
bool GCNavLinkAreaEntity::GetEnabled() const {
    return GetSchemaValue<bool>(m_ptr, "CNavLinkAreaEntity", "m_bEnabled");
}
void GCNavLinkAreaEntity::SetEnabled(bool value) {
    SetSchemaValue(m_ptr, "CNavLinkAreaEntity", "m_bEnabled", false, value);
}
std::string GCNavLinkAreaEntity::GetStrFilterName() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CNavLinkAreaEntity", "m_strFilterName").String();
}
void GCNavLinkAreaEntity::SetStrFilterName(std::string value) {
    SetSchemaValue(m_ptr, "CNavLinkAreaEntity", "m_strFilterName", false, CUtlSymbolLarge(value.c_str()));
}
GCBaseFilter GCNavLinkAreaEntity::GetFilter() const {
    GCBaseFilter value((void*)(GetSchemaValue<CHandle<CEntityInstance>>(m_ptr, "CNavLinkAreaEntity", "m_hFilter").Get()));
    return value;
}
void GCNavLinkAreaEntity::SetFilter(GCBaseFilter value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Filter' is not possible.\n");
}
GCEntityIOOutput GCNavLinkAreaEntity::GetOnNavLinkStart() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CNavLinkAreaEntity", "m_OnNavLinkStart"));
    return value;
}
void GCNavLinkAreaEntity::SetOnNavLinkStart(GCEntityIOOutput value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'OnNavLinkStart' is not possible.\n");
}
GCEntityIOOutput GCNavLinkAreaEntity::GetOnNavLinkFinish() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CNavLinkAreaEntity", "m_OnNavLinkFinish"));
    return value;
}
void GCNavLinkAreaEntity::SetOnNavLinkFinish(GCEntityIOOutput value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'OnNavLinkFinish' is not possible.\n");
}
bool GCNavLinkAreaEntity::GetIsTerminus() const {
    return GetSchemaValue<bool>(m_ptr, "CNavLinkAreaEntity", "m_bIsTerminus");
}
void GCNavLinkAreaEntity::SetIsTerminus(bool value) {
    SetSchemaValue(m_ptr, "CNavLinkAreaEntity", "m_bIsTerminus", false, value);
}
void* GCNavLinkAreaEntity::GetPtr() {
    return m_ptr;
}
std::string GCNavLinkAreaEntity::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCNavLinkAreaEntity::IsValid() {
    return (m_ptr != nullptr);
}
GCPointEntity GCNavLinkAreaEntity::GetParent() const {
    GCPointEntity value(m_ptr);
    return value;
}
void GCNavLinkAreaEntity::SetParent(GCPointEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCNavLinkAreaEntity(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCNavLinkAreaEntity>("CNavLinkAreaEntity")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Width", &GCNavLinkAreaEntity::GetWidth, &GCNavLinkAreaEntity::SetWidth)
        .addProperty("LocatorOffset", &GCNavLinkAreaEntity::GetLocatorOffset, &GCNavLinkAreaEntity::SetLocatorOffset)
        .addProperty("LocatorAnglesOffset", &GCNavLinkAreaEntity::GetLocatorAnglesOffset, &GCNavLinkAreaEntity::SetLocatorAnglesOffset)
        .addProperty("StrMovementForward", &GCNavLinkAreaEntity::GetStrMovementForward, &GCNavLinkAreaEntity::SetStrMovementForward)
        .addProperty("StrMovementReverse", &GCNavLinkAreaEntity::GetStrMovementReverse, &GCNavLinkAreaEntity::SetStrMovementReverse)
        .addProperty("NavLinkIdForward", &GCNavLinkAreaEntity::GetNavLinkIdForward, &GCNavLinkAreaEntity::SetNavLinkIdForward)
        .addProperty("NavLinkIdReverse", &GCNavLinkAreaEntity::GetNavLinkIdReverse, &GCNavLinkAreaEntity::SetNavLinkIdReverse)
        .addProperty("Enabled", &GCNavLinkAreaEntity::GetEnabled, &GCNavLinkAreaEntity::SetEnabled)
        .addProperty("StrFilterName", &GCNavLinkAreaEntity::GetStrFilterName, &GCNavLinkAreaEntity::SetStrFilterName)
        .addProperty("Filter", &GCNavLinkAreaEntity::GetFilter, &GCNavLinkAreaEntity::SetFilter)
        .addProperty("OnNavLinkStart", &GCNavLinkAreaEntity::GetOnNavLinkStart, &GCNavLinkAreaEntity::SetOnNavLinkStart)
        .addProperty("OnNavLinkFinish", &GCNavLinkAreaEntity::GetOnNavLinkFinish, &GCNavLinkAreaEntity::SetOnNavLinkFinish)
        .addProperty("IsTerminus", &GCNavLinkAreaEntity::GetIsTerminus, &GCNavLinkAreaEntity::SetIsTerminus)
        .addProperty("Parent", &GCNavLinkAreaEntity::GetParent, &GCNavLinkAreaEntity::SetParent)
        .addFunction("ToPtr", &GCNavLinkAreaEntity::ToPtr)
        .addFunction("IsValid", &GCNavLinkAreaEntity::IsValid)
        .endClass();
}
GCFuncMoveLinearAlias_momentary_door::GCFuncMoveLinearAlias_momentary_door(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCFuncMoveLinearAlias_momentary_door::GCFuncMoveLinearAlias_momentary_door(void *ptr) {
    m_ptr = ptr;
}
void* GCFuncMoveLinearAlias_momentary_door::GetPtr() {
    return m_ptr;
}
std::string GCFuncMoveLinearAlias_momentary_door::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCFuncMoveLinearAlias_momentary_door::IsValid() {
    return (m_ptr != nullptr);
}
GCFuncMoveLinear GCFuncMoveLinearAlias_momentary_door::GetParent() const {
    GCFuncMoveLinear value(m_ptr);
    return value;
}
void GCFuncMoveLinearAlias_momentary_door::SetParent(GCFuncMoveLinear value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCFuncMoveLinearAlias_momentary_door(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCFuncMoveLinearAlias_momentary_door>("CFuncMoveLinearAlias_momentary_door")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCFuncMoveLinearAlias_momentary_door::GetParent, &GCFuncMoveLinearAlias_momentary_door::SetParent)
        .addFunction("ToPtr", &GCFuncMoveLinearAlias_momentary_door::ToPtr)
        .addFunction("IsValid", &GCFuncMoveLinearAlias_momentary_door::IsValid)
        .endClass();
}
GCCommentaryAuto::GCCommentaryAuto(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCCommentaryAuto::GCCommentaryAuto(void *ptr) {
    m_ptr = ptr;
}
GCEntityIOOutput GCCommentaryAuto::GetOnCommentaryNewGame() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CCommentaryAuto", "m_OnCommentaryNewGame"));
    return value;
}
void GCCommentaryAuto::SetOnCommentaryNewGame(GCEntityIOOutput value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'OnCommentaryNewGame' is not possible.\n");
}
GCEntityIOOutput GCCommentaryAuto::GetOnCommentaryMidGame() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CCommentaryAuto", "m_OnCommentaryMidGame"));
    return value;
}
void GCCommentaryAuto::SetOnCommentaryMidGame(GCEntityIOOutput value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'OnCommentaryMidGame' is not possible.\n");
}
GCEntityIOOutput GCCommentaryAuto::GetOnCommentaryMultiplayerSpawn() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CCommentaryAuto", "m_OnCommentaryMultiplayerSpawn"));
    return value;
}
void GCCommentaryAuto::SetOnCommentaryMultiplayerSpawn(GCEntityIOOutput value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'OnCommentaryMultiplayerSpawn' is not possible.\n");
}
void* GCCommentaryAuto::GetPtr() {
    return m_ptr;
}
std::string GCCommentaryAuto::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCCommentaryAuto::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseEntity GCCommentaryAuto::GetParent() const {
    GCBaseEntity value(m_ptr);
    return value;
}
void GCCommentaryAuto::SetParent(GCBaseEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCCommentaryAuto(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCCommentaryAuto>("CCommentaryAuto")
        .addConstructor<void (*)(std::string)>()
        .addProperty("OnCommentaryNewGame", &GCCommentaryAuto::GetOnCommentaryNewGame, &GCCommentaryAuto::SetOnCommentaryNewGame)
        .addProperty("OnCommentaryMidGame", &GCCommentaryAuto::GetOnCommentaryMidGame, &GCCommentaryAuto::SetOnCommentaryMidGame)
        .addProperty("OnCommentaryMultiplayerSpawn", &GCCommentaryAuto::GetOnCommentaryMultiplayerSpawn, &GCCommentaryAuto::SetOnCommentaryMultiplayerSpawn)
        .addProperty("Parent", &GCCommentaryAuto::GetParent, &GCCommentaryAuto::SetParent)
        .addFunction("ToPtr", &GCCommentaryAuto::ToPtr)
        .addFunction("IsValid", &GCCommentaryAuto::IsValid)
        .endClass();
}
GCMapInfo::GCMapInfo(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCMapInfo::GCMapInfo(void *ptr) {
    m_ptr = ptr;
}
int32_t GCMapInfo::GetBuyingStatus() const {
    return GetSchemaValue<int32_t>(m_ptr, "CMapInfo", "m_iBuyingStatus");
}
void GCMapInfo::SetBuyingStatus(int32_t value) {
    SetSchemaValue(m_ptr, "CMapInfo", "m_iBuyingStatus", false, value);
}
float GCMapInfo::GetBombRadius() const {
    return GetSchemaValue<float>(m_ptr, "CMapInfo", "m_flBombRadius");
}
void GCMapInfo::SetBombRadius(float value) {
    SetSchemaValue(m_ptr, "CMapInfo", "m_flBombRadius", false, value);
}
int32_t GCMapInfo::GetPetPopulation() const {
    return GetSchemaValue<int32_t>(m_ptr, "CMapInfo", "m_iPetPopulation");
}
void GCMapInfo::SetPetPopulation(int32_t value) {
    SetSchemaValue(m_ptr, "CMapInfo", "m_iPetPopulation", false, value);
}
bool GCMapInfo::GetUseNormalSpawnsForDM() const {
    return GetSchemaValue<bool>(m_ptr, "CMapInfo", "m_bUseNormalSpawnsForDM");
}
void GCMapInfo::SetUseNormalSpawnsForDM(bool value) {
    SetSchemaValue(m_ptr, "CMapInfo", "m_bUseNormalSpawnsForDM", false, value);
}
bool GCMapInfo::GetDisableAutoGeneratedDMSpawns() const {
    return GetSchemaValue<bool>(m_ptr, "CMapInfo", "m_bDisableAutoGeneratedDMSpawns");
}
void GCMapInfo::SetDisableAutoGeneratedDMSpawns(bool value) {
    SetSchemaValue(m_ptr, "CMapInfo", "m_bDisableAutoGeneratedDMSpawns", false, value);
}
float GCMapInfo::GetBotMaxVisionDistance() const {
    return GetSchemaValue<float>(m_ptr, "CMapInfo", "m_flBotMaxVisionDistance");
}
void GCMapInfo::SetBotMaxVisionDistance(float value) {
    SetSchemaValue(m_ptr, "CMapInfo", "m_flBotMaxVisionDistance", false, value);
}
int32_t GCMapInfo::GetHostageCount() const {
    return GetSchemaValue<int32_t>(m_ptr, "CMapInfo", "m_iHostageCount");
}
void GCMapInfo::SetHostageCount(int32_t value) {
    SetSchemaValue(m_ptr, "CMapInfo", "m_iHostageCount", false, value);
}
bool GCMapInfo::GetFadePlayerVisibilityFarZ() const {
    return GetSchemaValue<bool>(m_ptr, "CMapInfo", "m_bFadePlayerVisibilityFarZ");
}
void GCMapInfo::SetFadePlayerVisibilityFarZ(bool value) {
    SetSchemaValue(m_ptr, "CMapInfo", "m_bFadePlayerVisibilityFarZ", false, value);
}
void* GCMapInfo::GetPtr() {
    return m_ptr;
}
std::string GCMapInfo::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCMapInfo::IsValid() {
    return (m_ptr != nullptr);
}
GCPointEntity GCMapInfo::GetParent() const {
    GCPointEntity value(m_ptr);
    return value;
}
void GCMapInfo::SetParent(GCPointEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCMapInfo(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCMapInfo>("CMapInfo")
        .addConstructor<void (*)(std::string)>()
        .addProperty("BuyingStatus", &GCMapInfo::GetBuyingStatus, &GCMapInfo::SetBuyingStatus)
        .addProperty("BombRadius", &GCMapInfo::GetBombRadius, &GCMapInfo::SetBombRadius)
        .addProperty("PetPopulation", &GCMapInfo::GetPetPopulation, &GCMapInfo::SetPetPopulation)
        .addProperty("UseNormalSpawnsForDM", &GCMapInfo::GetUseNormalSpawnsForDM, &GCMapInfo::SetUseNormalSpawnsForDM)
        .addProperty("DisableAutoGeneratedDMSpawns", &GCMapInfo::GetDisableAutoGeneratedDMSpawns, &GCMapInfo::SetDisableAutoGeneratedDMSpawns)
        .addProperty("BotMaxVisionDistance", &GCMapInfo::GetBotMaxVisionDistance, &GCMapInfo::SetBotMaxVisionDistance)
        .addProperty("HostageCount", &GCMapInfo::GetHostageCount, &GCMapInfo::SetHostageCount)
        .addProperty("FadePlayerVisibilityFarZ", &GCMapInfo::GetFadePlayerVisibilityFarZ, &GCMapInfo::SetFadePlayerVisibilityFarZ)
        .addProperty("Parent", &GCMapInfo::GetParent, &GCMapInfo::SetParent)
        .addFunction("ToPtr", &GCMapInfo::ToPtr)
        .addFunction("IsValid", &GCMapInfo::IsValid)
        .endClass();
}
GCTriggerBombReset::GCTriggerBombReset(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCTriggerBombReset::GCTriggerBombReset(void *ptr) {
    m_ptr = ptr;
}
void* GCTriggerBombReset::GetPtr() {
    return m_ptr;
}
std::string GCTriggerBombReset::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCTriggerBombReset::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseTrigger GCTriggerBombReset::GetParent() const {
    GCBaseTrigger value(m_ptr);
    return value;
}
void GCTriggerBombReset::SetParent(GCBaseTrigger value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCTriggerBombReset(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCTriggerBombReset>("CTriggerBombReset")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCTriggerBombReset::GetParent, &GCTriggerBombReset::SetParent)
        .addFunction("ToPtr", &GCTriggerBombReset::ToPtr)
        .addFunction("IsValid", &GCTriggerBombReset::IsValid)
        .endClass();
}
GCBaseDMStart::GCBaseDMStart(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCBaseDMStart::GCBaseDMStart(void *ptr) {
    m_ptr = ptr;
}
std::string GCBaseDMStart::GetMaster() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CBaseDMStart", "m_Master").String();
}
void GCBaseDMStart::SetMaster(std::string value) {
    SetSchemaValue(m_ptr, "CBaseDMStart", "m_Master", false, CUtlSymbolLarge(value.c_str()));
}
void* GCBaseDMStart::GetPtr() {
    return m_ptr;
}
std::string GCBaseDMStart::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCBaseDMStart::IsValid() {
    return (m_ptr != nullptr);
}
GCPointEntity GCBaseDMStart::GetParent() const {
    GCPointEntity value(m_ptr);
    return value;
}
void GCBaseDMStart::SetParent(GCPointEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCBaseDMStart(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCBaseDMStart>("CBaseDMStart")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Master", &GCBaseDMStart::GetMaster, &GCBaseDMStart::SetMaster)
        .addProperty("Parent", &GCBaseDMStart::GetParent, &GCBaseDMStart::SetParent)
        .addFunction("ToPtr", &GCBaseDMStart::ToPtr)
        .addFunction("IsValid", &GCBaseDMStart::IsValid)
        .endClass();
}
GCLogicMeasureMovement::GCLogicMeasureMovement(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCLogicMeasureMovement::GCLogicMeasureMovement(void *ptr) {
    m_ptr = ptr;
}
std::string GCLogicMeasureMovement::GetStrMeasureTarget() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CLogicMeasureMovement", "m_strMeasureTarget").String();
}
void GCLogicMeasureMovement::SetStrMeasureTarget(std::string value) {
    SetSchemaValue(m_ptr, "CLogicMeasureMovement", "m_strMeasureTarget", false, CUtlSymbolLarge(value.c_str()));
}
std::string GCLogicMeasureMovement::GetStrMeasureReference() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CLogicMeasureMovement", "m_strMeasureReference").String();
}
void GCLogicMeasureMovement::SetStrMeasureReference(std::string value) {
    SetSchemaValue(m_ptr, "CLogicMeasureMovement", "m_strMeasureReference", false, CUtlSymbolLarge(value.c_str()));
}
std::string GCLogicMeasureMovement::GetStrTargetReference() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CLogicMeasureMovement", "m_strTargetReference").String();
}
void GCLogicMeasureMovement::SetStrTargetReference(std::string value) {
    SetSchemaValue(m_ptr, "CLogicMeasureMovement", "m_strTargetReference", false, CUtlSymbolLarge(value.c_str()));
}
GCBaseEntity GCLogicMeasureMovement::GetMeasureTarget() const {
    GCBaseEntity value((void*)(GetSchemaValue<CHandle<CEntityInstance>>(m_ptr, "CLogicMeasureMovement", "m_hMeasureTarget").Get()));
    return value;
}
void GCLogicMeasureMovement::SetMeasureTarget(GCBaseEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'MeasureTarget' is not possible.\n");
}
GCBaseEntity GCLogicMeasureMovement::GetMeasureReference() const {
    GCBaseEntity value((void*)(GetSchemaValue<CHandle<CEntityInstance>>(m_ptr, "CLogicMeasureMovement", "m_hMeasureReference").Get()));
    return value;
}
void GCLogicMeasureMovement::SetMeasureReference(GCBaseEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'MeasureReference' is not possible.\n");
}
GCBaseEntity GCLogicMeasureMovement::GetTarget() const {
    GCBaseEntity value((void*)(GetSchemaValue<CHandle<CEntityInstance>>(m_ptr, "CLogicMeasureMovement", "m_hTarget").Get()));
    return value;
}
void GCLogicMeasureMovement::SetTarget(GCBaseEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Target' is not possible.\n");
}
GCBaseEntity GCLogicMeasureMovement::GetTargetReference() const {
    GCBaseEntity value((void*)(GetSchemaValue<CHandle<CEntityInstance>>(m_ptr, "CLogicMeasureMovement", "m_hTargetReference").Get()));
    return value;
}
void GCLogicMeasureMovement::SetTargetReference(GCBaseEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'TargetReference' is not possible.\n");
}
float GCLogicMeasureMovement::GetScale() const {
    return GetSchemaValue<float>(m_ptr, "CLogicMeasureMovement", "m_flScale");
}
void GCLogicMeasureMovement::SetScale(float value) {
    SetSchemaValue(m_ptr, "CLogicMeasureMovement", "m_flScale", false, value);
}
int32_t GCLogicMeasureMovement::GetMeasureType() const {
    return GetSchemaValue<int32_t>(m_ptr, "CLogicMeasureMovement", "m_nMeasureType");
}
void GCLogicMeasureMovement::SetMeasureType(int32_t value) {
    SetSchemaValue(m_ptr, "CLogicMeasureMovement", "m_nMeasureType", false, value);
}
void* GCLogicMeasureMovement::GetPtr() {
    return m_ptr;
}
std::string GCLogicMeasureMovement::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCLogicMeasureMovement::IsValid() {
    return (m_ptr != nullptr);
}
GCLogicalEntity GCLogicMeasureMovement::GetParent() const {
    GCLogicalEntity value(m_ptr);
    return value;
}
void GCLogicMeasureMovement::SetParent(GCLogicalEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCLogicMeasureMovement(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCLogicMeasureMovement>("CLogicMeasureMovement")
        .addConstructor<void (*)(std::string)>()
        .addProperty("StrMeasureTarget", &GCLogicMeasureMovement::GetStrMeasureTarget, &GCLogicMeasureMovement::SetStrMeasureTarget)
        .addProperty("StrMeasureReference", &GCLogicMeasureMovement::GetStrMeasureReference, &GCLogicMeasureMovement::SetStrMeasureReference)
        .addProperty("StrTargetReference", &GCLogicMeasureMovement::GetStrTargetReference, &GCLogicMeasureMovement::SetStrTargetReference)
        .addProperty("MeasureTarget", &GCLogicMeasureMovement::GetMeasureTarget, &GCLogicMeasureMovement::SetMeasureTarget)
        .addProperty("MeasureReference", &GCLogicMeasureMovement::GetMeasureReference, &GCLogicMeasureMovement::SetMeasureReference)
        .addProperty("Target", &GCLogicMeasureMovement::GetTarget, &GCLogicMeasureMovement::SetTarget)
        .addProperty("TargetReference", &GCLogicMeasureMovement::GetTargetReference, &GCLogicMeasureMovement::SetTargetReference)
        .addProperty("Scale", &GCLogicMeasureMovement::GetScale, &GCLogicMeasureMovement::SetScale)
        .addProperty("MeasureType", &GCLogicMeasureMovement::GetMeasureType, &GCLogicMeasureMovement::SetMeasureType)
        .addProperty("Parent", &GCLogicMeasureMovement::GetParent, &GCLogicMeasureMovement::SetParent)
        .addFunction("ToPtr", &GCLogicMeasureMovement::ToPtr)
        .addFunction("IsValid", &GCLogicMeasureMovement::IsValid)
        .endClass();
}
GViewAngleServerChange_t::GViewAngleServerChange_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GViewAngleServerChange_t::GViewAngleServerChange_t(void *ptr) {
    m_ptr = ptr;
}
uint64_t GViewAngleServerChange_t::GetType() const {
    return GetSchemaValue<uint64_t>(m_ptr, "ViewAngleServerChange_t", "nType");
}
void GViewAngleServerChange_t::SetType(uint64_t value) {
    SetSchemaValue(m_ptr, "ViewAngleServerChange_t", "nType", true, value);
}
QAngle GViewAngleServerChange_t::GetAngle() const {
    return GetSchemaValue<QAngle>(m_ptr, "ViewAngleServerChange_t", "qAngle");
}
void GViewAngleServerChange_t::SetAngle(QAngle value) {
    SetSchemaValue(m_ptr, "ViewAngleServerChange_t", "qAngle", true, value);
}
uint32_t GViewAngleServerChange_t::GetIndex() const {
    return GetSchemaValue<uint32_t>(m_ptr, "ViewAngleServerChange_t", "nIndex");
}
void GViewAngleServerChange_t::SetIndex(uint32_t value) {
    SetSchemaValue(m_ptr, "ViewAngleServerChange_t", "nIndex", true, value);
}
void* GViewAngleServerChange_t::GetPtr() {
    return m_ptr;
}
std::string GViewAngleServerChange_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GViewAngleServerChange_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassViewAngleServerChange_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GViewAngleServerChange_t>("ViewAngleServerChange_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Type", &GViewAngleServerChange_t::GetType, &GViewAngleServerChange_t::SetType)
        .addProperty("Angle", &GViewAngleServerChange_t::GetAngle, &GViewAngleServerChange_t::SetAngle)
        .addProperty("Index", &GViewAngleServerChange_t::GetIndex, &GViewAngleServerChange_t::SetIndex)
        .addFunction("ToPtr", &GViewAngleServerChange_t::ToPtr)
        .addFunction("IsValid", &GViewAngleServerChange_t::IsValid)
        .endClass();
}
GPhysicsRagdollPose_t::GPhysicsRagdollPose_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GPhysicsRagdollPose_t::GPhysicsRagdollPose_t(void *ptr) {
    m_ptr = ptr;
}
GCNetworkVarChainer GPhysicsRagdollPose_t::Get__pChainEntity() const {
    GCNetworkVarChainer value(GetSchemaPtr(m_ptr, "PhysicsRagdollPose_t", "__m_pChainEntity"));
    return value;
}
void GPhysicsRagdollPose_t::Set__pChainEntity(GCNetworkVarChainer value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for '__pChainEntity' is not possible.\n");
}
GCBaseEntity GPhysicsRagdollPose_t::GetOwner() const {
    GCBaseEntity value((void*)(GetSchemaValue<CHandle<CEntityInstance>>(m_ptr, "PhysicsRagdollPose_t", "m_hOwner").Get()));
    return value;
}
void GPhysicsRagdollPose_t::SetOwner(GCBaseEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Owner' is not possible.\n");
}
void* GPhysicsRagdollPose_t::GetPtr() {
    return m_ptr;
}
std::string GPhysicsRagdollPose_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GPhysicsRagdollPose_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassPhysicsRagdollPose_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GPhysicsRagdollPose_t>("PhysicsRagdollPose_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("__pChainEntity", &GPhysicsRagdollPose_t::Get__pChainEntity, &GPhysicsRagdollPose_t::Set__pChainEntity)
        .addProperty("Owner", &GPhysicsRagdollPose_t::GetOwner, &GPhysicsRagdollPose_t::SetOwner)
        .addFunction("ToPtr", &GPhysicsRagdollPose_t::ToPtr)
        .addFunction("IsValid", &GPhysicsRagdollPose_t::IsValid)
        .endClass();
}
GCBreachChargeProjectile::GCBreachChargeProjectile(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCBreachChargeProjectile::GCBreachChargeProjectile(void *ptr) {
    m_ptr = ptr;
}
void* GCBreachChargeProjectile::GetPtr() {
    return m_ptr;
}
std::string GCBreachChargeProjectile::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCBreachChargeProjectile::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseGrenade GCBreachChargeProjectile::GetParent() const {
    GCBaseGrenade value(m_ptr);
    return value;
}
void GCBreachChargeProjectile::SetParent(GCBaseGrenade value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCBreachChargeProjectile(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCBreachChargeProjectile>("CBreachChargeProjectile")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCBreachChargeProjectile::GetParent, &GCBreachChargeProjectile::SetParent)
        .addFunction("ToPtr", &GCBreachChargeProjectile::ToPtr)
        .addFunction("IsValid", &GCBreachChargeProjectile::IsValid)
        .endClass();
}
GCRangeFloat::GCRangeFloat(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCRangeFloat::GCRangeFloat(void *ptr) {
    m_ptr = ptr;
}
std::vector<float> GCRangeFloat::GetValue() const {
    float* outValue = (float*)GetSchemaPtr(m_ptr, "CRangeFloat", "m_pValue"); std::vector<float> ret; for(int i = 0; i < 2; i++) { ret.push_back(outValue[i]); } return ret;
}
void GCRangeFloat::SetValue(std::vector<float> value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Value' is not possible.\n");
}
void* GCRangeFloat::GetPtr() {
    return m_ptr;
}
std::string GCRangeFloat::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCRangeFloat::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCRangeFloat(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCRangeFloat>("CRangeFloat")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Value", &GCRangeFloat::GetValue, &GCRangeFloat::SetValue)
        .addFunction("ToPtr", &GCRangeFloat::ToPtr)
        .addFunction("IsValid", &GCRangeFloat::IsValid)
        .endClass();
}
GCAnimEventListenerBase::GCAnimEventListenerBase(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCAnimEventListenerBase::GCAnimEventListenerBase(void *ptr) {
    m_ptr = ptr;
}
void* GCAnimEventListenerBase::GetPtr() {
    return m_ptr;
}
std::string GCAnimEventListenerBase::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCAnimEventListenerBase::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCAnimEventListenerBase(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCAnimEventListenerBase>("CAnimEventListenerBase")
        .addConstructor<void (*)(std::string)>()
        .addFunction("ToPtr", &GCAnimEventListenerBase::ToPtr)
        .addFunction("IsValid", &GCAnimEventListenerBase::IsValid)
        .endClass();
}
GRelationship_t::GRelationship_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GRelationship_t::GRelationship_t(void *ptr) {
    m_ptr = ptr;
}
uint64_t GRelationship_t::GetDisposition() const {
    return GetSchemaValue<uint64_t>(m_ptr, "Relationship_t", "disposition");
}
void GRelationship_t::SetDisposition(uint64_t value) {
    SetSchemaValue(m_ptr, "Relationship_t", "disposition", true, value);
}
int32_t GRelationship_t::GetPriority() const {
    return GetSchemaValue<int32_t>(m_ptr, "Relationship_t", "priority");
}
void GRelationship_t::SetPriority(int32_t value) {
    SetSchemaValue(m_ptr, "Relationship_t", "priority", true, value);
}
void* GRelationship_t::GetPtr() {
    return m_ptr;
}
std::string GRelationship_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GRelationship_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassRelationship_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GRelationship_t>("Relationship_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Disposition", &GRelationship_t::GetDisposition, &GRelationship_t::SetDisposition)
        .addProperty("Priority", &GRelationship_t::GetPriority, &GRelationship_t::SetPriority)
        .addFunction("ToPtr", &GRelationship_t::ToPtr)
        .addFunction("IsValid", &GRelationship_t::IsValid)
        .endClass();
}
GCRemapFloat::GCRemapFloat(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCRemapFloat::GCRemapFloat(void *ptr) {
    m_ptr = ptr;
}
std::vector<float> GCRemapFloat::GetValue() const {
    float* outValue = (float*)GetSchemaPtr(m_ptr, "CRemapFloat", "m_pValue"); std::vector<float> ret; for(int i = 0; i < 4; i++) { ret.push_back(outValue[i]); } return ret;
}
void GCRemapFloat::SetValue(std::vector<float> value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Value' is not possible.\n");
}
void* GCRemapFloat::GetPtr() {
    return m_ptr;
}
std::string GCRemapFloat::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCRemapFloat::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCRemapFloat(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCRemapFloat>("CRemapFloat")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Value", &GCRemapFloat::GetValue, &GCRemapFloat::SetValue)
        .addFunction("ToPtr", &GCRemapFloat::ToPtr)
        .addFunction("IsValid", &GCRemapFloat::IsValid)
        .endClass();
}
GIGapHost_GameEntity::GIGapHost_GameEntity(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GIGapHost_GameEntity::GIGapHost_GameEntity(void *ptr) {
    m_ptr = ptr;
}
void* GIGapHost_GameEntity::GetPtr() {
    return m_ptr;
}
std::string GIGapHost_GameEntity::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GIGapHost_GameEntity::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassIGapHost_GameEntity(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GIGapHost_GameEntity>("IGapHost_GameEntity")
        .addConstructor<void (*)(std::string)>()
        .addFunction("ToPtr", &GIGapHost_GameEntity::ToPtr)
        .addFunction("IsValid", &GIGapHost_GameEntity::IsValid)
        .endClass();
}
GCFootstepTableHandle::GCFootstepTableHandle(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCFootstepTableHandle::GCFootstepTableHandle(void *ptr) {
    m_ptr = ptr;
}
void* GCFootstepTableHandle::GetPtr() {
    return m_ptr;
}
std::string GCFootstepTableHandle::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCFootstepTableHandle::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCFootstepTableHandle(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCFootstepTableHandle>("CFootstepTableHandle")
        .addConstructor<void (*)(std::string)>()
        .addFunction("ToPtr", &GCFootstepTableHandle::ToPtr)
        .addFunction("IsValid", &GCFootstepTableHandle::IsValid)
        .endClass();
}
GCCSPlayerController_InventoryServices::GCCSPlayerController_InventoryServices(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCCSPlayerController_InventoryServices::GCCSPlayerController_InventoryServices(void *ptr) {
    m_ptr = ptr;
}
uint16_t GCCSPlayerController_InventoryServices::GetMusicID() const {
    return GetSchemaValue<uint16_t>(m_ptr, "CCSPlayerController_InventoryServices", "m_unMusicID");
}
void GCCSPlayerController_InventoryServices::SetMusicID(uint16_t value) {
    SetSchemaValue(m_ptr, "CCSPlayerController_InventoryServices", "m_unMusicID", false, value);
}
std::vector<uint64_t> GCCSPlayerController_InventoryServices::GetRank() const {
    uint64_t* outValue = (uint64_t*)GetSchemaPtr(m_ptr, "CCSPlayerController_InventoryServices", "m_rank"); std::vector<uint64_t> ret; for(int i = 0; i < 6; i++) { ret.push_back(outValue[i]); } return ret;
}
void GCCSPlayerController_InventoryServices::SetRank(std::vector<uint64_t> value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Rank' is not possible.\n");
}
int32_t GCCSPlayerController_InventoryServices::GetPersonaDataPublicLevel() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSPlayerController_InventoryServices", "m_nPersonaDataPublicLevel");
}
void GCCSPlayerController_InventoryServices::SetPersonaDataPublicLevel(int32_t value) {
    SetSchemaValue(m_ptr, "CCSPlayerController_InventoryServices", "m_nPersonaDataPublicLevel", false, value);
}
int32_t GCCSPlayerController_InventoryServices::GetPersonaDataPublicCommendsLeader() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSPlayerController_InventoryServices", "m_nPersonaDataPublicCommendsLeader");
}
void GCCSPlayerController_InventoryServices::SetPersonaDataPublicCommendsLeader(int32_t value) {
    SetSchemaValue(m_ptr, "CCSPlayerController_InventoryServices", "m_nPersonaDataPublicCommendsLeader", false, value);
}
int32_t GCCSPlayerController_InventoryServices::GetPersonaDataPublicCommendsTeacher() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSPlayerController_InventoryServices", "m_nPersonaDataPublicCommendsTeacher");
}
void GCCSPlayerController_InventoryServices::SetPersonaDataPublicCommendsTeacher(int32_t value) {
    SetSchemaValue(m_ptr, "CCSPlayerController_InventoryServices", "m_nPersonaDataPublicCommendsTeacher", false, value);
}
int32_t GCCSPlayerController_InventoryServices::GetPersonaDataPublicCommendsFriendly() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSPlayerController_InventoryServices", "m_nPersonaDataPublicCommendsFriendly");
}
void GCCSPlayerController_InventoryServices::SetPersonaDataPublicCommendsFriendly(int32_t value) {
    SetSchemaValue(m_ptr, "CCSPlayerController_InventoryServices", "m_nPersonaDataPublicCommendsFriendly", false, value);
}
int32_t GCCSPlayerController_InventoryServices::GetPersonaDataXpTrailLevel() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSPlayerController_InventoryServices", "m_nPersonaDataXpTrailLevel");
}
void GCCSPlayerController_InventoryServices::SetPersonaDataXpTrailLevel(int32_t value) {
    SetSchemaValue(m_ptr, "CCSPlayerController_InventoryServices", "m_nPersonaDataXpTrailLevel", false, value);
}
std::vector<uint32_t> GCCSPlayerController_InventoryServices::GetEquippedPlayerSprayIDs() const {
    uint32_t* outValue = (uint32_t*)GetSchemaPtr(m_ptr, "CCSPlayerController_InventoryServices", "m_unEquippedPlayerSprayIDs"); std::vector<uint32_t> ret; for(int i = 0; i < 1; i++) { ret.push_back(outValue[i]); } return ret;
}
void GCCSPlayerController_InventoryServices::SetEquippedPlayerSprayIDs(std::vector<uint32_t> value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'EquippedPlayerSprayIDs' is not possible.\n");
}
std::vector<GServerAuthoritativeWeaponSlot_t> GCCSPlayerController_InventoryServices::GetServerAuthoritativeWeaponSlots() const {
    CUtlVector<GServerAuthoritativeWeaponSlot_t>* vec = GetSchemaValue<CUtlVector<GServerAuthoritativeWeaponSlot_t>*>(m_ptr, "CCSPlayerController_InventoryServices", "m_vecServerAuthoritativeWeaponSlots"); std::vector<GServerAuthoritativeWeaponSlot_t> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCCSPlayerController_InventoryServices::SetServerAuthoritativeWeaponSlots(std::vector<GServerAuthoritativeWeaponSlot_t> value) {
    SetSchemaValueCUtlVector<GServerAuthoritativeWeaponSlot_t>(m_ptr, "CCSPlayerController_InventoryServices", "m_vecServerAuthoritativeWeaponSlots", false, value);
}
void* GCCSPlayerController_InventoryServices::GetPtr() {
    return m_ptr;
}
std::string GCCSPlayerController_InventoryServices::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCCSPlayerController_InventoryServices::IsValid() {
    return (m_ptr != nullptr);
}
GCPlayerControllerComponent GCCSPlayerController_InventoryServices::GetParent() const {
    GCPlayerControllerComponent value(m_ptr);
    return value;
}
void GCCSPlayerController_InventoryServices::SetParent(GCPlayerControllerComponent value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCCSPlayerController_InventoryServices(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCCSPlayerController_InventoryServices>("CCSPlayerController_InventoryServices")
        .addConstructor<void (*)(std::string)>()
        .addProperty("MusicID", &GCCSPlayerController_InventoryServices::GetMusicID, &GCCSPlayerController_InventoryServices::SetMusicID)
        .addProperty("Rank", &GCCSPlayerController_InventoryServices::GetRank, &GCCSPlayerController_InventoryServices::SetRank)
        .addProperty("PersonaDataPublicLevel", &GCCSPlayerController_InventoryServices::GetPersonaDataPublicLevel, &GCCSPlayerController_InventoryServices::SetPersonaDataPublicLevel)
        .addProperty("PersonaDataPublicCommendsLeader", &GCCSPlayerController_InventoryServices::GetPersonaDataPublicCommendsLeader, &GCCSPlayerController_InventoryServices::SetPersonaDataPublicCommendsLeader)
        .addProperty("PersonaDataPublicCommendsTeacher", &GCCSPlayerController_InventoryServices::GetPersonaDataPublicCommendsTeacher, &GCCSPlayerController_InventoryServices::SetPersonaDataPublicCommendsTeacher)
        .addProperty("PersonaDataPublicCommendsFriendly", &GCCSPlayerController_InventoryServices::GetPersonaDataPublicCommendsFriendly, &GCCSPlayerController_InventoryServices::SetPersonaDataPublicCommendsFriendly)
        .addProperty("PersonaDataXpTrailLevel", &GCCSPlayerController_InventoryServices::GetPersonaDataXpTrailLevel, &GCCSPlayerController_InventoryServices::SetPersonaDataXpTrailLevel)
        .addProperty("EquippedPlayerSprayIDs", &GCCSPlayerController_InventoryServices::GetEquippedPlayerSprayIDs, &GCCSPlayerController_InventoryServices::SetEquippedPlayerSprayIDs)
        .addProperty("ServerAuthoritativeWeaponSlots", &GCCSPlayerController_InventoryServices::GetServerAuthoritativeWeaponSlots, &GCCSPlayerController_InventoryServices::SetServerAuthoritativeWeaponSlots)
        .addProperty("Parent", &GCCSPlayerController_InventoryServices::GetParent, &GCCSPlayerController_InventoryServices::SetParent)
        .addFunction("ToPtr", &GCCSPlayerController_InventoryServices::ToPtr)
        .addFunction("IsValid", &GCCSPlayerController_InventoryServices::IsValid)
        .endClass();
}
GCResponseQueue::GCResponseQueue(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCResponseQueue::GCResponseQueue(void *ptr) {
    m_ptr = ptr;
}
std::vector<GCAI_Expresser*> GCResponseQueue::GetExpresserTargets() const {
    CUtlVector<GCAI_Expresser*>* vec = GetSchemaValue<CUtlVector<GCAI_Expresser*>*>(m_ptr, "CResponseQueue", "m_ExpresserTargets"); std::vector<GCAI_Expresser*> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCResponseQueue::SetExpresserTargets(std::vector<GCAI_Expresser*> value) {
    SetSchemaValueCUtlVector<GCAI_Expresser*>(m_ptr, "CResponseQueue", "m_ExpresserTargets", false, value);
}
void* GCResponseQueue::GetPtr() {
    return m_ptr;
}
std::string GCResponseQueue::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCResponseQueue::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCResponseQueue(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCResponseQueue>("CResponseQueue")
        .addConstructor<void (*)(std::string)>()
        .addProperty("ExpresserTargets", &GCResponseQueue::GetExpresserTargets, &GCResponseQueue::SetExpresserTargets)
        .addFunction("ToPtr", &GCResponseQueue::ToPtr)
        .addFunction("IsValid", &GCResponseQueue::IsValid)
        .endClass();
}
GCScriptUniformRandomStream::GCScriptUniformRandomStream(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCScriptUniformRandomStream::GCScriptUniformRandomStream(void *ptr) {
    m_ptr = ptr;
}
int32_t GCScriptUniformRandomStream::GetInitialSeed() const {
    return GetSchemaValue<int32_t>(m_ptr, "CScriptUniformRandomStream", "m_nInitialSeed");
}
void GCScriptUniformRandomStream::SetInitialSeed(int32_t value) {
    SetSchemaValue(m_ptr, "CScriptUniformRandomStream", "m_nInitialSeed", false, value);
}
void* GCScriptUniformRandomStream::GetPtr() {
    return m_ptr;
}
std::string GCScriptUniformRandomStream::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCScriptUniformRandomStream::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCScriptUniformRandomStream(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCScriptUniformRandomStream>("CScriptUniformRandomStream")
        .addConstructor<void (*)(std::string)>()
        .addProperty("InitialSeed", &GCScriptUniformRandomStream::GetInitialSeed, &GCScriptUniformRandomStream::SetInitialSeed)
        .addFunction("ToPtr", &GCScriptUniformRandomStream::ToPtr)
        .addFunction("IsValid", &GCScriptUniformRandomStream::IsValid)
        .endClass();
}
GParticleIndex_t::GParticleIndex_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GParticleIndex_t::GParticleIndex_t(void *ptr) {
    m_ptr = ptr;
}
int32_t GParticleIndex_t::GetValue() const {
    return GetSchemaValue<int32_t>(m_ptr, "ParticleIndex_t", "m_Value");
}
void GParticleIndex_t::SetValue(int32_t value) {
    SetSchemaValue(m_ptr, "ParticleIndex_t", "m_Value", true, value);
}
void* GParticleIndex_t::GetPtr() {
    return m_ptr;
}
std::string GParticleIndex_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GParticleIndex_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassParticleIndex_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GParticleIndex_t>("ParticleIndex_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Value", &GParticleIndex_t::GetValue, &GParticleIndex_t::SetValue)
        .addFunction("ToPtr", &GParticleIndex_t::ToPtr)
        .addFunction("IsValid", &GParticleIndex_t::IsValid)
        .endClass();
}
GCPhysHinge::GCPhysHinge(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCPhysHinge::GCPhysHinge(void *ptr) {
    m_ptr = ptr;
}
GConstraintSoundInfo GCPhysHinge::GetSoundInfo() const {
    GConstraintSoundInfo value(GetSchemaPtr(m_ptr, "CPhysHinge", "m_soundInfo"));
    return value;
}
void GCPhysHinge::SetSoundInfo(GConstraintSoundInfo value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'SoundInfo' is not possible.\n");
}
GCEntityIOOutput GCPhysHinge::GetNotifyMinLimitReached() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CPhysHinge", "m_NotifyMinLimitReached"));
    return value;
}
void GCPhysHinge::SetNotifyMinLimitReached(GCEntityIOOutput value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'NotifyMinLimitReached' is not possible.\n");
}
GCEntityIOOutput GCPhysHinge::GetNotifyMaxLimitReached() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CPhysHinge", "m_NotifyMaxLimitReached"));
    return value;
}
void GCPhysHinge::SetNotifyMaxLimitReached(GCEntityIOOutput value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'NotifyMaxLimitReached' is not possible.\n");
}
bool GCPhysHinge::GetAtMinLimit() const {
    return GetSchemaValue<bool>(m_ptr, "CPhysHinge", "m_bAtMinLimit");
}
void GCPhysHinge::SetAtMinLimit(bool value) {
    SetSchemaValue(m_ptr, "CPhysHinge", "m_bAtMinLimit", false, value);
}
bool GCPhysHinge::GetAtMaxLimit() const {
    return GetSchemaValue<bool>(m_ptr, "CPhysHinge", "m_bAtMaxLimit");
}
void GCPhysHinge::SetAtMaxLimit(bool value) {
    SetSchemaValue(m_ptr, "CPhysHinge", "m_bAtMaxLimit", false, value);
}
Gconstraint_hingeparams_t GCPhysHinge::GetHinge() const {
    Gconstraint_hingeparams_t value(GetSchemaPtr(m_ptr, "CPhysHinge", "m_hinge"));
    return value;
}
void GCPhysHinge::SetHinge(Gconstraint_hingeparams_t value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Hinge' is not possible.\n");
}
float GCPhysHinge::GetHingeFriction() const {
    return GetSchemaValue<float>(m_ptr, "CPhysHinge", "m_hingeFriction");
}
void GCPhysHinge::SetHingeFriction(float value) {
    SetSchemaValue(m_ptr, "CPhysHinge", "m_hingeFriction", false, value);
}
float GCPhysHinge::GetSystemLoadScale() const {
    return GetSchemaValue<float>(m_ptr, "CPhysHinge", "m_systemLoadScale");
}
void GCPhysHinge::SetSystemLoadScale(float value) {
    SetSchemaValue(m_ptr, "CPhysHinge", "m_systemLoadScale", false, value);
}
bool GCPhysHinge::GetIsAxisLocal() const {
    return GetSchemaValue<bool>(m_ptr, "CPhysHinge", "m_bIsAxisLocal");
}
void GCPhysHinge::SetIsAxisLocal(bool value) {
    SetSchemaValue(m_ptr, "CPhysHinge", "m_bIsAxisLocal", false, value);
}
float GCPhysHinge::GetMinRotation() const {
    return GetSchemaValue<float>(m_ptr, "CPhysHinge", "m_flMinRotation");
}
void GCPhysHinge::SetMinRotation(float value) {
    SetSchemaValue(m_ptr, "CPhysHinge", "m_flMinRotation", false, value);
}
float GCPhysHinge::GetMaxRotation() const {
    return GetSchemaValue<float>(m_ptr, "CPhysHinge", "m_flMaxRotation");
}
void GCPhysHinge::SetMaxRotation(float value) {
    SetSchemaValue(m_ptr, "CPhysHinge", "m_flMaxRotation", false, value);
}
float GCPhysHinge::GetInitialRotation() const {
    return GetSchemaValue<float>(m_ptr, "CPhysHinge", "m_flInitialRotation");
}
void GCPhysHinge::SetInitialRotation(float value) {
    SetSchemaValue(m_ptr, "CPhysHinge", "m_flInitialRotation", false, value);
}
float GCPhysHinge::GetMotorFrequency() const {
    return GetSchemaValue<float>(m_ptr, "CPhysHinge", "m_flMotorFrequency");
}
void GCPhysHinge::SetMotorFrequency(float value) {
    SetSchemaValue(m_ptr, "CPhysHinge", "m_flMotorFrequency", false, value);
}
float GCPhysHinge::GetMotorDampingRatio() const {
    return GetSchemaValue<float>(m_ptr, "CPhysHinge", "m_flMotorDampingRatio");
}
void GCPhysHinge::SetMotorDampingRatio(float value) {
    SetSchemaValue(m_ptr, "CPhysHinge", "m_flMotorDampingRatio", false, value);
}
float GCPhysHinge::GetAngleSpeed() const {
    return GetSchemaValue<float>(m_ptr, "CPhysHinge", "m_flAngleSpeed");
}
void GCPhysHinge::SetAngleSpeed(float value) {
    SetSchemaValue(m_ptr, "CPhysHinge", "m_flAngleSpeed", false, value);
}
float GCPhysHinge::GetAngleSpeedThreshold() const {
    return GetSchemaValue<float>(m_ptr, "CPhysHinge", "m_flAngleSpeedThreshold");
}
void GCPhysHinge::SetAngleSpeedThreshold(float value) {
    SetSchemaValue(m_ptr, "CPhysHinge", "m_flAngleSpeedThreshold", false, value);
}
GCEntityIOOutput GCPhysHinge::GetOnStartMoving() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CPhysHinge", "m_OnStartMoving"));
    return value;
}
void GCPhysHinge::SetOnStartMoving(GCEntityIOOutput value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'OnStartMoving' is not possible.\n");
}
GCEntityIOOutput GCPhysHinge::GetOnStopMoving() const {
    GCEntityIOOutput value(GetSchemaPtr(m_ptr, "CPhysHinge", "m_OnStopMoving"));
    return value;
}
void GCPhysHinge::SetOnStopMoving(GCEntityIOOutput value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'OnStopMoving' is not possible.\n");
}
void* GCPhysHinge::GetPtr() {
    return m_ptr;
}
std::string GCPhysHinge::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCPhysHinge::IsValid() {
    return (m_ptr != nullptr);
}
GCPhysConstraint GCPhysHinge::GetParent() const {
    GCPhysConstraint value(m_ptr);
    return value;
}
void GCPhysHinge::SetParent(GCPhysConstraint value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCPhysHinge(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCPhysHinge>("CPhysHinge")
        .addConstructor<void (*)(std::string)>()
        .addProperty("SoundInfo", &GCPhysHinge::GetSoundInfo, &GCPhysHinge::SetSoundInfo)
        .addProperty("NotifyMinLimitReached", &GCPhysHinge::GetNotifyMinLimitReached, &GCPhysHinge::SetNotifyMinLimitReached)
        .addProperty("NotifyMaxLimitReached", &GCPhysHinge::GetNotifyMaxLimitReached, &GCPhysHinge::SetNotifyMaxLimitReached)
        .addProperty("AtMinLimit", &GCPhysHinge::GetAtMinLimit, &GCPhysHinge::SetAtMinLimit)
        .addProperty("AtMaxLimit", &GCPhysHinge::GetAtMaxLimit, &GCPhysHinge::SetAtMaxLimit)
        .addProperty("Hinge", &GCPhysHinge::GetHinge, &GCPhysHinge::SetHinge)
        .addProperty("HingeFriction", &GCPhysHinge::GetHingeFriction, &GCPhysHinge::SetHingeFriction)
        .addProperty("SystemLoadScale", &GCPhysHinge::GetSystemLoadScale, &GCPhysHinge::SetSystemLoadScale)
        .addProperty("IsAxisLocal", &GCPhysHinge::GetIsAxisLocal, &GCPhysHinge::SetIsAxisLocal)
        .addProperty("MinRotation", &GCPhysHinge::GetMinRotation, &GCPhysHinge::SetMinRotation)
        .addProperty("MaxRotation", &GCPhysHinge::GetMaxRotation, &GCPhysHinge::SetMaxRotation)
        .addProperty("InitialRotation", &GCPhysHinge::GetInitialRotation, &GCPhysHinge::SetInitialRotation)
        .addProperty("MotorFrequency", &GCPhysHinge::GetMotorFrequency, &GCPhysHinge::SetMotorFrequency)
        .addProperty("MotorDampingRatio", &GCPhysHinge::GetMotorDampingRatio, &GCPhysHinge::SetMotorDampingRatio)
        .addProperty("AngleSpeed", &GCPhysHinge::GetAngleSpeed, &GCPhysHinge::SetAngleSpeed)
        .addProperty("AngleSpeedThreshold", &GCPhysHinge::GetAngleSpeedThreshold, &GCPhysHinge::SetAngleSpeedThreshold)
        .addProperty("OnStartMoving", &GCPhysHinge::GetOnStartMoving, &GCPhysHinge::SetOnStartMoving)
        .addProperty("OnStopMoving", &GCPhysHinge::GetOnStopMoving, &GCPhysHinge::SetOnStopMoving)
        .addProperty("Parent", &GCPhysHinge::GetParent, &GCPhysHinge::SetParent)
        .addFunction("ToPtr", &GCPhysHinge::ToPtr)
        .addFunction("IsValid", &GCPhysHinge::IsValid)
        .endClass();
}
GCSimpleSimTimer::GCSimpleSimTimer(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCSimpleSimTimer::GCSimpleSimTimer(void *ptr) {
    m_ptr = ptr;
}
float GCSimpleSimTimer::GetNext() const {
    return GetSchemaValue<float>(m_ptr, "CSimpleSimTimer", "m_next");
}
void GCSimpleSimTimer::SetNext(float value) {
    SetSchemaValue(m_ptr, "CSimpleSimTimer", "m_next", false, value);
}
uint32_t GCSimpleSimTimer::GetWorldGroupId() const {
    return GetSchemaValue<CUtlStringToken>(m_ptr, "CSimpleSimTimer", "m_nWorldGroupId").m_nHashCode;
}
void GCSimpleSimTimer::SetWorldGroupId(uint32_t value) {
    SetSchemaValue(m_ptr, "CSimpleSimTimer", "m_nWorldGroupId", false, CUtlStringToken(value));
}
void* GCSimpleSimTimer::GetPtr() {
    return m_ptr;
}
std::string GCSimpleSimTimer::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCSimpleSimTimer::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCSimpleSimTimer(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCSimpleSimTimer>("CSimpleSimTimer")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Next", &GCSimpleSimTimer::GetNext, &GCSimpleSimTimer::SetNext)
        .addProperty("WorldGroupId", &GCSimpleSimTimer::GetWorldGroupId, &GCSimpleSimTimer::SetWorldGroupId)
        .addFunction("ToPtr", &GCSimpleSimTimer::ToPtr)
        .addFunction("IsValid", &GCSimpleSimTimer::IsValid)
        .endClass();
}
GCSkillDamage::GCSkillDamage(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCSkillDamage::GCSkillDamage(void *ptr) {
    m_ptr = ptr;
}
GCSkillFloat GCSkillDamage::GetDamage() const {
    GCSkillFloat value(GetSchemaPtr(m_ptr, "CSkillDamage", "m_flDamage"));
    return value;
}
void GCSkillDamage::SetDamage(GCSkillFloat value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Damage' is not possible.\n");
}
float GCSkillDamage::GetNPCDamageScalarVsNPC() const {
    return GetSchemaValue<float>(m_ptr, "CSkillDamage", "m_flNPCDamageScalarVsNPC");
}
void GCSkillDamage::SetNPCDamageScalarVsNPC(float value) {
    SetSchemaValue(m_ptr, "CSkillDamage", "m_flNPCDamageScalarVsNPC", false, value);
}
float GCSkillDamage::GetPhysicsForceDamage() const {
    return GetSchemaValue<float>(m_ptr, "CSkillDamage", "m_flPhysicsForceDamage");
}
void GCSkillDamage::SetPhysicsForceDamage(float value) {
    SetSchemaValue(m_ptr, "CSkillDamage", "m_flPhysicsForceDamage", false, value);
}
void* GCSkillDamage::GetPtr() {
    return m_ptr;
}
std::string GCSkillDamage::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCSkillDamage::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCSkillDamage(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCSkillDamage>("CSkillDamage")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Damage", &GCSkillDamage::GetDamage, &GCSkillDamage::SetDamage)
        .addProperty("NPCDamageScalarVsNPC", &GCSkillDamage::GetNPCDamageScalarVsNPC, &GCSkillDamage::SetNPCDamageScalarVsNPC)
        .addProperty("PhysicsForceDamage", &GCSkillDamage::GetPhysicsForceDamage, &GCSkillDamage::SetPhysicsForceDamage)
        .addFunction("ToPtr", &GCSkillDamage::ToPtr)
        .addFunction("IsValid", &GCSkillDamage::IsValid)
        .endClass();
}
GCAnimEventQueueListener::GCAnimEventQueueListener(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCAnimEventQueueListener::GCAnimEventQueueListener(void *ptr) {
    m_ptr = ptr;
}
void* GCAnimEventQueueListener::GetPtr() {
    return m_ptr;
}
std::string GCAnimEventQueueListener::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCAnimEventQueueListener::IsValid() {
    return (m_ptr != nullptr);
}
GCAnimEventListenerBase GCAnimEventQueueListener::GetParent() const {
    GCAnimEventListenerBase value(m_ptr);
    return value;
}
void GCAnimEventQueueListener::SetParent(GCAnimEventListenerBase value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCAnimEventQueueListener(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCAnimEventQueueListener>("CAnimEventQueueListener")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCAnimEventQueueListener::GetParent, &GCAnimEventQueueListener::SetParent)
        .addFunction("ToPtr", &GCAnimEventQueueListener::ToPtr)
        .addFunction("IsValid", &GCAnimEventQueueListener::IsValid)
        .endClass();
}
GCEnvLaser::GCEnvLaser(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCEnvLaser::GCEnvLaser(void *ptr) {
    m_ptr = ptr;
}
std::string GCEnvLaser::GetLaserTarget() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CEnvLaser", "m_iszLaserTarget").String();
}
void GCEnvLaser::SetLaserTarget(std::string value) {
    SetSchemaValue(m_ptr, "CEnvLaser", "m_iszLaserTarget", false, CUtlSymbolLarge(value.c_str()));
}
GCSprite GCEnvLaser::GetSprite() const {
    GCSprite value(*(void**)GetSchemaPtr(m_ptr, "CEnvLaser", "m_pSprite"));
    return value;
}
void GCEnvLaser::SetSprite(GCSprite value) {
    SetSchemaValue(m_ptr, "CEnvLaser","m_pSprite", false, (char*)value.GetPtr());
}
std::string GCEnvLaser::GetSpriteName() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CEnvLaser", "m_iszSpriteName").String();
}
void GCEnvLaser::SetSpriteName(std::string value) {
    SetSchemaValue(m_ptr, "CEnvLaser", "m_iszSpriteName", false, CUtlSymbolLarge(value.c_str()));
}
Vector GCEnvLaser::GetFirePosition() const {
    return GetSchemaValue<Vector>(m_ptr, "CEnvLaser", "m_firePosition");
}
void GCEnvLaser::SetFirePosition(Vector value) {
    SetSchemaValue(m_ptr, "CEnvLaser", "m_firePosition", false, value);
}
float GCEnvLaser::GetStartFrame() const {
    return GetSchemaValue<float>(m_ptr, "CEnvLaser", "m_flStartFrame");
}
void GCEnvLaser::SetStartFrame(float value) {
    SetSchemaValue(m_ptr, "CEnvLaser", "m_flStartFrame", false, value);
}
void* GCEnvLaser::GetPtr() {
    return m_ptr;
}
std::string GCEnvLaser::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCEnvLaser::IsValid() {
    return (m_ptr != nullptr);
}
GCBeam GCEnvLaser::GetParent() const {
    GCBeam value(m_ptr);
    return value;
}
void GCEnvLaser::SetParent(GCBeam value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCEnvLaser(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCEnvLaser>("CEnvLaser")
        .addConstructor<void (*)(std::string)>()
        .addProperty("LaserTarget", &GCEnvLaser::GetLaserTarget, &GCEnvLaser::SetLaserTarget)
        .addProperty("Sprite", &GCEnvLaser::GetSprite, &GCEnvLaser::SetSprite)
        .addProperty("SpriteName", &GCEnvLaser::GetSpriteName, &GCEnvLaser::SetSpriteName)
        .addProperty("FirePosition", &GCEnvLaser::GetFirePosition, &GCEnvLaser::SetFirePosition)
        .addProperty("StartFrame", &GCEnvLaser::GetStartFrame, &GCEnvLaser::SetStartFrame)
        .addProperty("Parent", &GCEnvLaser::GetParent, &GCEnvLaser::SetParent)
        .addFunction("ToPtr", &GCEnvLaser::ToPtr)
        .addFunction("IsValid", &GCEnvLaser::IsValid)
        .endClass();
}
GCFiringModeFloat::GCFiringModeFloat(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCFiringModeFloat::GCFiringModeFloat(void *ptr) {
    m_ptr = ptr;
}
std::vector<float> GCFiringModeFloat::GetValues() const {
    float* outValue = (float*)GetSchemaPtr(m_ptr, "CFiringModeFloat", "m_flValues"); std::vector<float> ret; for(int i = 0; i < 2; i++) { ret.push_back(outValue[i]); } return ret;
}
void GCFiringModeFloat::SetValues(std::vector<float> value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Values' is not possible.\n");
}
void* GCFiringModeFloat::GetPtr() {
    return m_ptr;
}
std::string GCFiringModeFloat::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCFiringModeFloat::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCFiringModeFloat(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCFiringModeFloat>("CFiringModeFloat")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Values", &GCFiringModeFloat::GetValues, &GCFiringModeFloat::SetValues)
        .addFunction("ToPtr", &GCFiringModeFloat::ToPtr)
        .addFunction("IsValid", &GCFiringModeFloat::IsValid)
        .endClass();
}
GCRopeOverlapHit::GCRopeOverlapHit(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCRopeOverlapHit::GCRopeOverlapHit(void *ptr) {
    m_ptr = ptr;
}
GCBaseEntity GCRopeOverlapHit::GetEntity() const {
    GCBaseEntity value((void*)(GetSchemaValue<CHandle<CEntityInstance>>(m_ptr, "CRopeOverlapHit", "m_hEntity").Get()));
    return value;
}
void GCRopeOverlapHit::SetEntity(GCBaseEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Entity' is not possible.\n");
}
std::vector<int32> GCRopeOverlapHit::GetOverlappingLinks() const {
    CUtlVector<int32>* vec = GetSchemaValue<CUtlVector<int32>*>(m_ptr, "CRopeOverlapHit", "m_vecOverlappingLinks"); std::vector<int32> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCRopeOverlapHit::SetOverlappingLinks(std::vector<int32> value) {
    SetSchemaValueCUtlVector<int32>(m_ptr, "CRopeOverlapHit", "m_vecOverlappingLinks", false, value);
}
void* GCRopeOverlapHit::GetPtr() {
    return m_ptr;
}
std::string GCRopeOverlapHit::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCRopeOverlapHit::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCRopeOverlapHit(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCRopeOverlapHit>("CRopeOverlapHit")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Entity", &GCRopeOverlapHit::GetEntity, &GCRopeOverlapHit::SetEntity)
        .addProperty("OverlappingLinks", &GCRopeOverlapHit::GetOverlappingLinks, &GCRopeOverlapHit::SetOverlappingLinks)
        .addFunction("ToPtr", &GCRopeOverlapHit::ToPtr)
        .addFunction("IsValid", &GCRopeOverlapHit::IsValid)
        .endClass();
}
GResponseContext_t::GResponseContext_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GResponseContext_t::GResponseContext_t(void *ptr) {
    m_ptr = ptr;
}
std::string GResponseContext_t::GetName() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "ResponseContext_t", "m_iszName").String();
}
void GResponseContext_t::SetName(std::string value) {
    SetSchemaValue(m_ptr, "ResponseContext_t", "m_iszName", true, CUtlSymbolLarge(value.c_str()));
}
std::string GResponseContext_t::GetValue() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "ResponseContext_t", "m_iszValue").String();
}
void GResponseContext_t::SetValue(std::string value) {
    SetSchemaValue(m_ptr, "ResponseContext_t", "m_iszValue", true, CUtlSymbolLarge(value.c_str()));
}
float GResponseContext_t::GetExpirationTime() const {
    return GetSchemaValue<float>(m_ptr, "ResponseContext_t", "m_fExpirationTime");
}
void GResponseContext_t::SetExpirationTime(float value) {
    SetSchemaValue(m_ptr, "ResponseContext_t", "m_fExpirationTime", true, value);
}
void* GResponseContext_t::GetPtr() {
    return m_ptr;
}
std::string GResponseContext_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GResponseContext_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassResponseContext_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GResponseContext_t>("ResponseContext_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Name", &GResponseContext_t::GetName, &GResponseContext_t::SetName)
        .addProperty("Value", &GResponseContext_t::GetValue, &GResponseContext_t::SetValue)
        .addProperty("ExpirationTime", &GResponseContext_t::GetExpirationTime, &GResponseContext_t::SetExpirationTime)
        .addFunction("ToPtr", &GResponseContext_t::ToPtr)
        .addFunction("IsValid", &GResponseContext_t::IsValid)
        .endClass();
}
GCNavVolume::GCNavVolume(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCNavVolume::GCNavVolume(void *ptr) {
    m_ptr = ptr;
}
void* GCNavVolume::GetPtr() {
    return m_ptr;
}
std::string GCNavVolume::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCNavVolume::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCNavVolume(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCNavVolume>("CNavVolume")
        .addConstructor<void (*)(std::string)>()
        .addFunction("ToPtr", &GCNavVolume::ToPtr)
        .addFunction("IsValid", &GCNavVolume::IsValid)
        .endClass();
}
GCCSObserver_MovementServices::GCCSObserver_MovementServices(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCCSObserver_MovementServices::GCCSObserver_MovementServices(void *ptr) {
    m_ptr = ptr;
}
void* GCCSObserver_MovementServices::GetPtr() {
    return m_ptr;
}
std::string GCCSObserver_MovementServices::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCCSObserver_MovementServices::IsValid() {
    return (m_ptr != nullptr);
}
GCPlayer_MovementServices GCCSObserver_MovementServices::GetParent() const {
    GCPlayer_MovementServices value(m_ptr);
    return value;
}
void GCCSObserver_MovementServices::SetParent(GCPlayer_MovementServices value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCCSObserver_MovementServices(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCCSObserver_MovementServices>("CCSObserver_MovementServices")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCCSObserver_MovementServices::GetParent, &GCCSObserver_MovementServices::SetParent)
        .addFunction("ToPtr", &GCCSObserver_MovementServices::ToPtr)
        .addFunction("IsValid", &GCCSObserver_MovementServices::IsValid)
        .endClass();
}
GCCSGOPlayerAnimGraphState::GCCSGOPlayerAnimGraphState(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCCSGOPlayerAnimGraphState::GCCSGOPlayerAnimGraphState(void *ptr) {
    m_ptr = ptr;
}
void* GCCSGOPlayerAnimGraphState::GetPtr() {
    return m_ptr;
}
std::string GCCSGOPlayerAnimGraphState::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCCSGOPlayerAnimGraphState::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCCSGOPlayerAnimGraphState(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCCSGOPlayerAnimGraphState>("CCSGOPlayerAnimGraphState")
        .addConstructor<void (*)(std::string)>()
        .addFunction("ToPtr", &GCCSGOPlayerAnimGraphState::ToPtr)
        .addFunction("IsValid", &GCCSGOPlayerAnimGraphState::IsValid)
        .endClass();
}
GCGameScriptedMoveData::GCGameScriptedMoveData(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCGameScriptedMoveData::GCGameScriptedMoveData(void *ptr) {
    m_ptr = ptr;
}
Vector GCGameScriptedMoveData::GetAccumulatedRootMotion() const {
    return GetSchemaValue<Vector>(m_ptr, "CGameScriptedMoveData", "m_vAccumulatedRootMotion");
}
void GCGameScriptedMoveData::SetAccumulatedRootMotion(Vector value) {
    SetSchemaValue(m_ptr, "CGameScriptedMoveData", "m_vAccumulatedRootMotion", false, value);
}
Vector GCGameScriptedMoveData::GetDest() const {
    return GetSchemaValue<Vector>(m_ptr, "CGameScriptedMoveData", "m_vDest");
}
void GCGameScriptedMoveData::SetDest(Vector value) {
    SetSchemaValue(m_ptr, "CGameScriptedMoveData", "m_vDest", false, value);
}
Vector GCGameScriptedMoveData::GetSrc() const {
    return GetSchemaValue<Vector>(m_ptr, "CGameScriptedMoveData", "m_vSrc");
}
void GCGameScriptedMoveData::SetSrc(Vector value) {
    SetSchemaValue(m_ptr, "CGameScriptedMoveData", "m_vSrc", false, value);
}
QAngle GCGameScriptedMoveData::GetSrc1() const {
    return GetSchemaValue<QAngle>(m_ptr, "CGameScriptedMoveData", "m_angSrc");
}
void GCGameScriptedMoveData::SetSrc1(QAngle value) {
    SetSchemaValue(m_ptr, "CGameScriptedMoveData", "m_angSrc", false, value);
}
QAngle GCGameScriptedMoveData::GetDst() const {
    return GetSchemaValue<QAngle>(m_ptr, "CGameScriptedMoveData", "m_angDst");
}
void GCGameScriptedMoveData::SetDst(QAngle value) {
    SetSchemaValue(m_ptr, "CGameScriptedMoveData", "m_angDst", false, value);
}
QAngle GCGameScriptedMoveData::GetCurrent() const {
    return GetSchemaValue<QAngle>(m_ptr, "CGameScriptedMoveData", "m_angCurrent");
}
void GCGameScriptedMoveData::SetCurrent(QAngle value) {
    SetSchemaValue(m_ptr, "CGameScriptedMoveData", "m_angCurrent", false, value);
}
float GCGameScriptedMoveData::GetAngRate() const {
    return GetSchemaValue<float>(m_ptr, "CGameScriptedMoveData", "m_flAngRate");
}
void GCGameScriptedMoveData::SetAngRate(float value) {
    SetSchemaValue(m_ptr, "CGameScriptedMoveData", "m_flAngRate", false, value);
}
float GCGameScriptedMoveData::GetDuration() const {
    return GetSchemaValue<float>(m_ptr, "CGameScriptedMoveData", "m_flDuration");
}
void GCGameScriptedMoveData::SetDuration(float value) {
    SetSchemaValue(m_ptr, "CGameScriptedMoveData", "m_flDuration", false, value);
}
float GCGameScriptedMoveData::GetStartTime() const {
    return GetSchemaValue<float>(m_ptr, "CGameScriptedMoveData", "m_flStartTime");
}
void GCGameScriptedMoveData::SetStartTime(float value) {
    SetSchemaValue(m_ptr, "CGameScriptedMoveData", "m_flStartTime", false, value);
}
bool GCGameScriptedMoveData::GetActive() const {
    return GetSchemaValue<bool>(m_ptr, "CGameScriptedMoveData", "m_bActive");
}
void GCGameScriptedMoveData::SetActive(bool value) {
    SetSchemaValue(m_ptr, "CGameScriptedMoveData", "m_bActive", false, value);
}
bool GCGameScriptedMoveData::GetTeleportOnEnd() const {
    return GetSchemaValue<bool>(m_ptr, "CGameScriptedMoveData", "m_bTeleportOnEnd");
}
void GCGameScriptedMoveData::SetTeleportOnEnd(bool value) {
    SetSchemaValue(m_ptr, "CGameScriptedMoveData", "m_bTeleportOnEnd", false, value);
}
bool GCGameScriptedMoveData::GetIgnoreRotation() const {
    return GetSchemaValue<bool>(m_ptr, "CGameScriptedMoveData", "m_bIgnoreRotation");
}
void GCGameScriptedMoveData::SetIgnoreRotation(bool value) {
    SetSchemaValue(m_ptr, "CGameScriptedMoveData", "m_bIgnoreRotation", false, value);
}
uint64_t GCGameScriptedMoveData::GetType() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CGameScriptedMoveData", "m_nType");
}
void GCGameScriptedMoveData::SetType(uint64_t value) {
    SetSchemaValue(m_ptr, "CGameScriptedMoveData", "m_nType", false, value);
}
bool GCGameScriptedMoveData::GetSuccess() const {
    return GetSchemaValue<bool>(m_ptr, "CGameScriptedMoveData", "m_bSuccess");
}
void GCGameScriptedMoveData::SetSuccess(bool value) {
    SetSchemaValue(m_ptr, "CGameScriptedMoveData", "m_bSuccess", false, value);
}
uint64_t GCGameScriptedMoveData::GetForcedCrouchState() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CGameScriptedMoveData", "m_nForcedCrouchState");
}
void GCGameScriptedMoveData::SetForcedCrouchState(uint64_t value) {
    SetSchemaValue(m_ptr, "CGameScriptedMoveData", "m_nForcedCrouchState", false, value);
}
bool GCGameScriptedMoveData::GetIgnoreCollisions() const {
    return GetSchemaValue<bool>(m_ptr, "CGameScriptedMoveData", "m_bIgnoreCollisions");
}
void GCGameScriptedMoveData::SetIgnoreCollisions(bool value) {
    SetSchemaValue(m_ptr, "CGameScriptedMoveData", "m_bIgnoreCollisions", false, value);
}
void* GCGameScriptedMoveData::GetPtr() {
    return m_ptr;
}
std::string GCGameScriptedMoveData::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCGameScriptedMoveData::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCGameScriptedMoveData(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCGameScriptedMoveData>("CGameScriptedMoveData")
        .addConstructor<void (*)(std::string)>()
        .addProperty("AccumulatedRootMotion", &GCGameScriptedMoveData::GetAccumulatedRootMotion, &GCGameScriptedMoveData::SetAccumulatedRootMotion)
        .addProperty("Dest", &GCGameScriptedMoveData::GetDest, &GCGameScriptedMoveData::SetDest)
        .addProperty("Src", &GCGameScriptedMoveData::GetSrc, &GCGameScriptedMoveData::SetSrc)
        .addProperty("Src1", &GCGameScriptedMoveData::GetSrc1, &GCGameScriptedMoveData::SetSrc1)
        .addProperty("Dst", &GCGameScriptedMoveData::GetDst, &GCGameScriptedMoveData::SetDst)
        .addProperty("Current", &GCGameScriptedMoveData::GetCurrent, &GCGameScriptedMoveData::SetCurrent)
        .addProperty("AngRate", &GCGameScriptedMoveData::GetAngRate, &GCGameScriptedMoveData::SetAngRate)
        .addProperty("Duration", &GCGameScriptedMoveData::GetDuration, &GCGameScriptedMoveData::SetDuration)
        .addProperty("StartTime", &GCGameScriptedMoveData::GetStartTime, &GCGameScriptedMoveData::SetStartTime)
        .addProperty("Active", &GCGameScriptedMoveData::GetActive, &GCGameScriptedMoveData::SetActive)
        .addProperty("TeleportOnEnd", &GCGameScriptedMoveData::GetTeleportOnEnd, &GCGameScriptedMoveData::SetTeleportOnEnd)
        .addProperty("IgnoreRotation", &GCGameScriptedMoveData::GetIgnoreRotation, &GCGameScriptedMoveData::SetIgnoreRotation)
        .addProperty("Type", &GCGameScriptedMoveData::GetType, &GCGameScriptedMoveData::SetType)
        .addProperty("Success", &GCGameScriptedMoveData::GetSuccess, &GCGameScriptedMoveData::SetSuccess)
        .addProperty("ForcedCrouchState", &GCGameScriptedMoveData::GetForcedCrouchState, &GCGameScriptedMoveData::SetForcedCrouchState)
        .addProperty("IgnoreCollisions", &GCGameScriptedMoveData::GetIgnoreCollisions, &GCGameScriptedMoveData::SetIgnoreCollisions)
        .addFunction("ToPtr", &GCGameScriptedMoveData::ToPtr)
        .addFunction("IsValid", &GCGameScriptedMoveData::IsValid)
        .endClass();
}
GCBaseAnimGraphController::GCBaseAnimGraphController(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCBaseAnimGraphController::GCBaseAnimGraphController(void *ptr) {
    m_ptr = ptr;
}
GCAnimGraphNetworkedVariables GCBaseAnimGraphController::GetAnimGraphNetworkedVars() const {
    GCAnimGraphNetworkedVariables value(GetSchemaPtr(m_ptr, "CBaseAnimGraphController", "m_animGraphNetworkedVars"));
    return value;
}
void GCBaseAnimGraphController::SetAnimGraphNetworkedVars(GCAnimGraphNetworkedVariables value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'AnimGraphNetworkedVars' is not possible.\n");
}
bool GCBaseAnimGraphController::GetSequenceFinished() const {
    return GetSchemaValue<bool>(m_ptr, "CBaseAnimGraphController", "m_bSequenceFinished");
}
void GCBaseAnimGraphController::SetSequenceFinished(bool value) {
    SetSchemaValue(m_ptr, "CBaseAnimGraphController", "m_bSequenceFinished", false, value);
}
float GCBaseAnimGraphController::GetSoundSyncTime() const {
    return GetSchemaValue<float>(m_ptr, "CBaseAnimGraphController", "m_flSoundSyncTime");
}
void GCBaseAnimGraphController::SetSoundSyncTime(float value) {
    SetSchemaValue(m_ptr, "CBaseAnimGraphController", "m_flSoundSyncTime", false, value);
}
uint32_t GCBaseAnimGraphController::GetActiveIKChainMask() const {
    return GetSchemaValue<uint32_t>(m_ptr, "CBaseAnimGraphController", "m_nActiveIKChainMask");
}
void GCBaseAnimGraphController::SetActiveIKChainMask(uint32_t value) {
    SetSchemaValue(m_ptr, "CBaseAnimGraphController", "m_nActiveIKChainMask", false, value);
}
float GCBaseAnimGraphController::GetSeqStartTime() const {
    return GetSchemaValue<float>(m_ptr, "CBaseAnimGraphController", "m_flSeqStartTime");
}
void GCBaseAnimGraphController::SetSeqStartTime(float value) {
    SetSchemaValue(m_ptr, "CBaseAnimGraphController", "m_flSeqStartTime", false, value);
}
float GCBaseAnimGraphController::GetSeqFixedCycle() const {
    return GetSchemaValue<float>(m_ptr, "CBaseAnimGraphController", "m_flSeqFixedCycle");
}
void GCBaseAnimGraphController::SetSeqFixedCycle(float value) {
    SetSchemaValue(m_ptr, "CBaseAnimGraphController", "m_flSeqFixedCycle", false, value);
}
uint64_t GCBaseAnimGraphController::GetAnimLoopMode() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CBaseAnimGraphController", "m_nAnimLoopMode");
}
void GCBaseAnimGraphController::SetAnimLoopMode(uint64_t value) {
    SetSchemaValue(m_ptr, "CBaseAnimGraphController", "m_nAnimLoopMode", false, value);
}
float GCBaseAnimGraphController::GetPlaybackRate() const {
    return GetSchemaValue<float>(m_ptr, "CBaseAnimGraphController", "m_flPlaybackRate");
}
void GCBaseAnimGraphController::SetPlaybackRate(float value) {
    SetSchemaValue(m_ptr, "CBaseAnimGraphController", "m_flPlaybackRate", false, value);
}
uint64_t GCBaseAnimGraphController::GetNotifyState() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CBaseAnimGraphController", "m_nNotifyState");
}
void GCBaseAnimGraphController::SetNotifyState(uint64_t value) {
    SetSchemaValue(m_ptr, "CBaseAnimGraphController", "m_nNotifyState", false, value);
}
bool GCBaseAnimGraphController::GetNetworkedAnimationInputsChanged() const {
    return GetSchemaValue<bool>(m_ptr, "CBaseAnimGraphController", "m_bNetworkedAnimationInputsChanged");
}
void GCBaseAnimGraphController::SetNetworkedAnimationInputsChanged(bool value) {
    SetSchemaValue(m_ptr, "CBaseAnimGraphController", "m_bNetworkedAnimationInputsChanged", false, value);
}
bool GCBaseAnimGraphController::GetNetworkedSequenceChanged() const {
    return GetSchemaValue<bool>(m_ptr, "CBaseAnimGraphController", "m_bNetworkedSequenceChanged");
}
void GCBaseAnimGraphController::SetNetworkedSequenceChanged(bool value) {
    SetSchemaValue(m_ptr, "CBaseAnimGraphController", "m_bNetworkedSequenceChanged", false, value);
}
bool GCBaseAnimGraphController::GetLastUpdateSkipped() const {
    return GetSchemaValue<bool>(m_ptr, "CBaseAnimGraphController", "m_bLastUpdateSkipped");
}
void GCBaseAnimGraphController::SetLastUpdateSkipped(bool value) {
    SetSchemaValue(m_ptr, "CBaseAnimGraphController", "m_bLastUpdateSkipped", false, value);
}
float GCBaseAnimGraphController::GetPrevAnimUpdateTime() const {
    return GetSchemaValue<float>(m_ptr, "CBaseAnimGraphController", "m_flPrevAnimUpdateTime");
}
void GCBaseAnimGraphController::SetPrevAnimUpdateTime(float value) {
    SetSchemaValue(m_ptr, "CBaseAnimGraphController", "m_flPrevAnimUpdateTime", false, value);
}
void* GCBaseAnimGraphController::GetPtr() {
    return m_ptr;
}
std::string GCBaseAnimGraphController::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCBaseAnimGraphController::IsValid() {
    return (m_ptr != nullptr);
}
GCSkeletonAnimationController GCBaseAnimGraphController::GetParent() const {
    GCSkeletonAnimationController value(m_ptr);
    return value;
}
void GCBaseAnimGraphController::SetParent(GCSkeletonAnimationController value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCBaseAnimGraphController(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCBaseAnimGraphController>("CBaseAnimGraphController")
        .addConstructor<void (*)(std::string)>()
        .addProperty("AnimGraphNetworkedVars", &GCBaseAnimGraphController::GetAnimGraphNetworkedVars, &GCBaseAnimGraphController::SetAnimGraphNetworkedVars)
        .addProperty("SequenceFinished", &GCBaseAnimGraphController::GetSequenceFinished, &GCBaseAnimGraphController::SetSequenceFinished)
        .addProperty("SoundSyncTime", &GCBaseAnimGraphController::GetSoundSyncTime, &GCBaseAnimGraphController::SetSoundSyncTime)
        .addProperty("ActiveIKChainMask", &GCBaseAnimGraphController::GetActiveIKChainMask, &GCBaseAnimGraphController::SetActiveIKChainMask)
        .addProperty("SeqStartTime", &GCBaseAnimGraphController::GetSeqStartTime, &GCBaseAnimGraphController::SetSeqStartTime)
        .addProperty("SeqFixedCycle", &GCBaseAnimGraphController::GetSeqFixedCycle, &GCBaseAnimGraphController::SetSeqFixedCycle)
        .addProperty("AnimLoopMode", &GCBaseAnimGraphController::GetAnimLoopMode, &GCBaseAnimGraphController::SetAnimLoopMode)
        .addProperty("PlaybackRate", &GCBaseAnimGraphController::GetPlaybackRate, &GCBaseAnimGraphController::SetPlaybackRate)
        .addProperty("NotifyState", &GCBaseAnimGraphController::GetNotifyState, &GCBaseAnimGraphController::SetNotifyState)
        .addProperty("NetworkedAnimationInputsChanged", &GCBaseAnimGraphController::GetNetworkedAnimationInputsChanged, &GCBaseAnimGraphController::SetNetworkedAnimationInputsChanged)
        .addProperty("NetworkedSequenceChanged", &GCBaseAnimGraphController::GetNetworkedSequenceChanged, &GCBaseAnimGraphController::SetNetworkedSequenceChanged)
        .addProperty("LastUpdateSkipped", &GCBaseAnimGraphController::GetLastUpdateSkipped, &GCBaseAnimGraphController::SetLastUpdateSkipped)
        .addProperty("PrevAnimUpdateTime", &GCBaseAnimGraphController::GetPrevAnimUpdateTime, &GCBaseAnimGraphController::SetPrevAnimUpdateTime)
        .addProperty("Parent", &GCBaseAnimGraphController::GetParent, &GCBaseAnimGraphController::SetParent)
        .addFunction("ToPtr", &GCBaseAnimGraphController::ToPtr)
        .addFunction("IsValid", &GCBaseAnimGraphController::IsValid)
        .endClass();
}
GCNavVolumeSphere::GCNavVolumeSphere(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCNavVolumeSphere::GCNavVolumeSphere(void *ptr) {
    m_ptr = ptr;
}
Vector GCNavVolumeSphere::GetCenter() const {
    return GetSchemaValue<Vector>(m_ptr, "CNavVolumeSphere", "m_vCenter");
}
void GCNavVolumeSphere::SetCenter(Vector value) {
    SetSchemaValue(m_ptr, "CNavVolumeSphere", "m_vCenter", false, value);
}
float GCNavVolumeSphere::GetRadius() const {
    return GetSchemaValue<float>(m_ptr, "CNavVolumeSphere", "m_flRadius");
}
void GCNavVolumeSphere::SetRadius(float value) {
    SetSchemaValue(m_ptr, "CNavVolumeSphere", "m_flRadius", false, value);
}
void* GCNavVolumeSphere::GetPtr() {
    return m_ptr;
}
std::string GCNavVolumeSphere::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCNavVolumeSphere::IsValid() {
    return (m_ptr != nullptr);
}
GCNavVolume GCNavVolumeSphere::GetParent() const {
    GCNavVolume value(m_ptr);
    return value;
}
void GCNavVolumeSphere::SetParent(GCNavVolume value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCNavVolumeSphere(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCNavVolumeSphere>("CNavVolumeSphere")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Center", &GCNavVolumeSphere::GetCenter, &GCNavVolumeSphere::SetCenter)
        .addProperty("Radius", &GCNavVolumeSphere::GetRadius, &GCNavVolumeSphere::SetRadius)
        .addProperty("Parent", &GCNavVolumeSphere::GetParent, &GCNavVolumeSphere::SetParent)
        .addFunction("ToPtr", &GCNavVolumeSphere::ToPtr)
        .addFunction("IsValid", &GCNavVolumeSphere::IsValid)
        .endClass();
}
GCResponseCriteriaSet::GCResponseCriteriaSet(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCResponseCriteriaSet::GCResponseCriteriaSet(void *ptr) {
    m_ptr = ptr;
}
int32_t GCResponseCriteriaSet::GetNumPrefixedContexts() const {
    return GetSchemaValue<int32_t>(m_ptr, "CResponseCriteriaSet", "m_nNumPrefixedContexts");
}
void GCResponseCriteriaSet::SetNumPrefixedContexts(int32_t value) {
    SetSchemaValue(m_ptr, "CResponseCriteriaSet", "m_nNumPrefixedContexts", false, value);
}
bool GCResponseCriteriaSet::GetOverrideOnAppend() const {
    return GetSchemaValue<bool>(m_ptr, "CResponseCriteriaSet", "m_bOverrideOnAppend");
}
void GCResponseCriteriaSet::SetOverrideOnAppend(bool value) {
    SetSchemaValue(m_ptr, "CResponseCriteriaSet", "m_bOverrideOnAppend", false, value);
}
void* GCResponseCriteriaSet::GetPtr() {
    return m_ptr;
}
std::string GCResponseCriteriaSet::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCResponseCriteriaSet::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCResponseCriteriaSet(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCResponseCriteriaSet>("CResponseCriteriaSet")
        .addConstructor<void (*)(std::string)>()
        .addProperty("NumPrefixedContexts", &GCResponseCriteriaSet::GetNumPrefixedContexts, &GCResponseCriteriaSet::SetNumPrefixedContexts)
        .addProperty("OverrideOnAppend", &GCResponseCriteriaSet::GetOverrideOnAppend, &GCResponseCriteriaSet::SetOverrideOnAppend)
        .addFunction("ToPtr", &GCResponseCriteriaSet::ToPtr)
        .addFunction("IsValid", &GCResponseCriteriaSet::IsValid)
        .endClass();
}
GCAI_Expresser::GCAI_Expresser(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCAI_Expresser::GCAI_Expresser(void *ptr) {
    m_ptr = ptr;
}
float GCAI_Expresser::GetStopTalkTime() const {
    return GetSchemaValue<float>(m_ptr, "CAI_Expresser", "m_flStopTalkTime");
}
void GCAI_Expresser::SetStopTalkTime(float value) {
    SetSchemaValue(m_ptr, "CAI_Expresser", "m_flStopTalkTime", false, value);
}
float GCAI_Expresser::GetStopTalkTimeWithoutDelay() const {
    return GetSchemaValue<float>(m_ptr, "CAI_Expresser", "m_flStopTalkTimeWithoutDelay");
}
void GCAI_Expresser::SetStopTalkTimeWithoutDelay(float value) {
    SetSchemaValue(m_ptr, "CAI_Expresser", "m_flStopTalkTimeWithoutDelay", false, value);
}
float GCAI_Expresser::GetBlockedTalkTime() const {
    return GetSchemaValue<float>(m_ptr, "CAI_Expresser", "m_flBlockedTalkTime");
}
void GCAI_Expresser::SetBlockedTalkTime(float value) {
    SetSchemaValue(m_ptr, "CAI_Expresser", "m_flBlockedTalkTime", false, value);
}
int32_t GCAI_Expresser::GetVoicePitch() const {
    return GetSchemaValue<int32_t>(m_ptr, "CAI_Expresser", "m_voicePitch");
}
void GCAI_Expresser::SetVoicePitch(int32_t value) {
    SetSchemaValue(m_ptr, "CAI_Expresser", "m_voicePitch", false, value);
}
float GCAI_Expresser::GetLastTimeAcceptedSpeak() const {
    return GetSchemaValue<float>(m_ptr, "CAI_Expresser", "m_flLastTimeAcceptedSpeak");
}
void GCAI_Expresser::SetLastTimeAcceptedSpeak(float value) {
    SetSchemaValue(m_ptr, "CAI_Expresser", "m_flLastTimeAcceptedSpeak", false, value);
}
bool GCAI_Expresser::GetAllowSpeakingInterrupts() const {
    return GetSchemaValue<bool>(m_ptr, "CAI_Expresser", "m_bAllowSpeakingInterrupts");
}
void GCAI_Expresser::SetAllowSpeakingInterrupts(bool value) {
    SetSchemaValue(m_ptr, "CAI_Expresser", "m_bAllowSpeakingInterrupts", false, value);
}
bool GCAI_Expresser::GetConsiderSceneInvolvementAsSpeech() const {
    return GetSchemaValue<bool>(m_ptr, "CAI_Expresser", "m_bConsiderSceneInvolvementAsSpeech");
}
void GCAI_Expresser::SetConsiderSceneInvolvementAsSpeech(bool value) {
    SetSchemaValue(m_ptr, "CAI_Expresser", "m_bConsiderSceneInvolvementAsSpeech", false, value);
}
bool GCAI_Expresser::GetSceneEntityDisabled() const {
    return GetSchemaValue<bool>(m_ptr, "CAI_Expresser", "m_bSceneEntityDisabled");
}
void GCAI_Expresser::SetSceneEntityDisabled(bool value) {
    SetSchemaValue(m_ptr, "CAI_Expresser", "m_bSceneEntityDisabled", false, value);
}
int32_t GCAI_Expresser::GetLastSpokenPriority() const {
    return GetSchemaValue<int32_t>(m_ptr, "CAI_Expresser", "m_nLastSpokenPriority");
}
void GCAI_Expresser::SetLastSpokenPriority(int32_t value) {
    SetSchemaValue(m_ptr, "CAI_Expresser", "m_nLastSpokenPriority", false, value);
}
GCBaseFlex GCAI_Expresser::GetOuter() const {
    GCBaseFlex value(*(void**)GetSchemaPtr(m_ptr, "CAI_Expresser", "m_pOuter"));
    return value;
}
void GCAI_Expresser::SetOuter(GCBaseFlex value) {
    SetSchemaValue(m_ptr, "CAI_Expresser","m_pOuter", false, (char*)value.GetPtr());
}
void* GCAI_Expresser::GetPtr() {
    return m_ptr;
}
std::string GCAI_Expresser::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCAI_Expresser::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCAI_Expresser(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCAI_Expresser>("CAI_Expresser")
        .addConstructor<void (*)(std::string)>()
        .addProperty("StopTalkTime", &GCAI_Expresser::GetStopTalkTime, &GCAI_Expresser::SetStopTalkTime)
        .addProperty("StopTalkTimeWithoutDelay", &GCAI_Expresser::GetStopTalkTimeWithoutDelay, &GCAI_Expresser::SetStopTalkTimeWithoutDelay)
        .addProperty("BlockedTalkTime", &GCAI_Expresser::GetBlockedTalkTime, &GCAI_Expresser::SetBlockedTalkTime)
        .addProperty("VoicePitch", &GCAI_Expresser::GetVoicePitch, &GCAI_Expresser::SetVoicePitch)
        .addProperty("LastTimeAcceptedSpeak", &GCAI_Expresser::GetLastTimeAcceptedSpeak, &GCAI_Expresser::SetLastTimeAcceptedSpeak)
        .addProperty("AllowSpeakingInterrupts", &GCAI_Expresser::GetAllowSpeakingInterrupts, &GCAI_Expresser::SetAllowSpeakingInterrupts)
        .addProperty("ConsiderSceneInvolvementAsSpeech", &GCAI_Expresser::GetConsiderSceneInvolvementAsSpeech, &GCAI_Expresser::SetConsiderSceneInvolvementAsSpeech)
        .addProperty("SceneEntityDisabled", &GCAI_Expresser::GetSceneEntityDisabled, &GCAI_Expresser::SetSceneEntityDisabled)
        .addProperty("LastSpokenPriority", &GCAI_Expresser::GetLastSpokenPriority, &GCAI_Expresser::SetLastSpokenPriority)
        .addProperty("Outer", &GCAI_Expresser::GetOuter, &GCAI_Expresser::SetOuter)
        .addFunction("ToPtr", &GCAI_Expresser::ToPtr)
        .addFunction("IsValid", &GCAI_Expresser::IsValid)
        .endClass();
}
GIChoreoServices::GIChoreoServices(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GIChoreoServices::GIChoreoServices(void *ptr) {
    m_ptr = ptr;
}
void* GIChoreoServices::GetPtr() {
    return m_ptr;
}
std::string GIChoreoServices::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GIChoreoServices::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassIChoreoServices(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GIChoreoServices>("IChoreoServices")
        .addConstructor<void (*)(std::string)>()
        .addFunction("ToPtr", &GIChoreoServices::ToPtr)
        .addFunction("IsValid", &GIChoreoServices::IsValid)
        .endClass();
}
GCStopwatchBase::GCStopwatchBase(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCStopwatchBase::GCStopwatchBase(void *ptr) {
    m_ptr = ptr;
}
bool GCStopwatchBase::GetIsRunning() const {
    return GetSchemaValue<bool>(m_ptr, "CStopwatchBase", "m_fIsRunning");
}
void GCStopwatchBase::SetIsRunning(bool value) {
    SetSchemaValue(m_ptr, "CStopwatchBase", "m_fIsRunning", false, value);
}
void* GCStopwatchBase::GetPtr() {
    return m_ptr;
}
std::string GCStopwatchBase::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCStopwatchBase::IsValid() {
    return (m_ptr != nullptr);
}
GCSimpleSimTimer GCStopwatchBase::GetParent() const {
    GCSimpleSimTimer value(m_ptr);
    return value;
}
void GCStopwatchBase::SetParent(GCSimpleSimTimer value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCStopwatchBase(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCStopwatchBase>("CStopwatchBase")
        .addConstructor<void (*)(std::string)>()
        .addProperty("IsRunning", &GCStopwatchBase::GetIsRunning, &GCStopwatchBase::SetIsRunning)
        .addProperty("Parent", &GCStopwatchBase::GetParent, &GCStopwatchBase::SetParent)
        .addFunction("ToPtr", &GCStopwatchBase::ToPtr)
        .addFunction("IsValid", &GCStopwatchBase::IsValid)
        .endClass();
}
GResponseParams::GResponseParams(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GResponseParams::GResponseParams(void *ptr) {
    m_ptr = ptr;
}
int16_t GResponseParams::GetOdds() const {
    return GetSchemaValue<int16_t>(m_ptr, "ResponseParams", "odds");
}
void GResponseParams::SetOdds(int16_t value) {
    SetSchemaValue(m_ptr, "ResponseParams", "odds", false, value);
}
int16_t GResponseParams::GetFlags() const {
    return GetSchemaValue<int16_t>(m_ptr, "ResponseParams", "flags");
}
void GResponseParams::SetFlags(int16_t value) {
    SetSchemaValue(m_ptr, "ResponseParams", "flags", false, value);
}
GResponseFollowup GResponseParams::GetFollowup() const {
    GResponseFollowup value(*(void**)GetSchemaPtr(m_ptr, "ResponseParams", "m_pFollowup"));
    return value;
}
void GResponseParams::SetFollowup(GResponseFollowup value) {
    SetSchemaValue(m_ptr, "ResponseParams","m_pFollowup", false, (char*)value.GetPtr());
}
void* GResponseParams::GetPtr() {
    return m_ptr;
}
std::string GResponseParams::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GResponseParams::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassResponseParams(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GResponseParams>("ResponseParams")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Odds", &GResponseParams::GetOdds, &GResponseParams::SetOdds)
        .addProperty("Flags", &GResponseParams::GetFlags, &GResponseParams::SetFlags)
        .addProperty("Followup", &GResponseParams::GetFollowup, &GResponseParams::SetFollowup)
        .addFunction("ToPtr", &GResponseParams::ToPtr)
        .addFunction("IsValid", &GResponseParams::IsValid)
        .endClass();
}
GCItem_Healthshot::GCItem_Healthshot(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCItem_Healthshot::GCItem_Healthshot(void *ptr) {
    m_ptr = ptr;
}
void* GCItem_Healthshot::GetPtr() {
    return m_ptr;
}
std::string GCItem_Healthshot::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCItem_Healthshot::IsValid() {
    return (m_ptr != nullptr);
}
GCWeaponBaseItem GCItem_Healthshot::GetParent() const {
    GCWeaponBaseItem value(m_ptr);
    return value;
}
void GCItem_Healthshot::SetParent(GCWeaponBaseItem value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCItem_Healthshot(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCItem_Healthshot>("CItem_Healthshot")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCItem_Healthshot::GetParent, &GCItem_Healthshot::SetParent)
        .addFunction("ToPtr", &GCItem_Healthshot::ToPtr)
        .addFunction("IsValid", &GCItem_Healthshot::IsValid)
        .endClass();
}
GCPhysHingeAlias_phys_hinge_local::GCPhysHingeAlias_phys_hinge_local(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCPhysHingeAlias_phys_hinge_local::GCPhysHingeAlias_phys_hinge_local(void *ptr) {
    m_ptr = ptr;
}
void* GCPhysHingeAlias_phys_hinge_local::GetPtr() {
    return m_ptr;
}
std::string GCPhysHingeAlias_phys_hinge_local::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCPhysHingeAlias_phys_hinge_local::IsValid() {
    return (m_ptr != nullptr);
}
GCPhysHinge GCPhysHingeAlias_phys_hinge_local::GetParent() const {
    GCPhysHinge value(m_ptr);
    return value;
}
void GCPhysHingeAlias_phys_hinge_local::SetParent(GCPhysHinge value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCPhysHingeAlias_phys_hinge_local(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCPhysHingeAlias_phys_hinge_local>("CPhysHingeAlias_phys_hinge_local")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCPhysHingeAlias_phys_hinge_local::GetParent, &GCPhysHingeAlias_phys_hinge_local::SetParent)
        .addFunction("ToPtr", &GCPhysHingeAlias_phys_hinge_local::ToPtr)
        .addFunction("IsValid", &GCPhysHingeAlias_phys_hinge_local::IsValid)
        .endClass();
}
GPointCameraSettings_t::GPointCameraSettings_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GPointCameraSettings_t::GPointCameraSettings_t(void *ptr) {
    m_ptr = ptr;
}
float GPointCameraSettings_t::GetNearBlurryDistance() const {
    return GetSchemaValue<float>(m_ptr, "PointCameraSettings_t", "m_flNearBlurryDistance");
}
void GPointCameraSettings_t::SetNearBlurryDistance(float value) {
    SetSchemaValue(m_ptr, "PointCameraSettings_t", "m_flNearBlurryDistance", true, value);
}
float GPointCameraSettings_t::GetNearCrispDistance() const {
    return GetSchemaValue<float>(m_ptr, "PointCameraSettings_t", "m_flNearCrispDistance");
}
void GPointCameraSettings_t::SetNearCrispDistance(float value) {
    SetSchemaValue(m_ptr, "PointCameraSettings_t", "m_flNearCrispDistance", true, value);
}
float GPointCameraSettings_t::GetFarCrispDistance() const {
    return GetSchemaValue<float>(m_ptr, "PointCameraSettings_t", "m_flFarCrispDistance");
}
void GPointCameraSettings_t::SetFarCrispDistance(float value) {
    SetSchemaValue(m_ptr, "PointCameraSettings_t", "m_flFarCrispDistance", true, value);
}
float GPointCameraSettings_t::GetFarBlurryDistance() const {
    return GetSchemaValue<float>(m_ptr, "PointCameraSettings_t", "m_flFarBlurryDistance");
}
void GPointCameraSettings_t::SetFarBlurryDistance(float value) {
    SetSchemaValue(m_ptr, "PointCameraSettings_t", "m_flFarBlurryDistance", true, value);
}
void* GPointCameraSettings_t::GetPtr() {
    return m_ptr;
}
std::string GPointCameraSettings_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GPointCameraSettings_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassPointCameraSettings_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GPointCameraSettings_t>("PointCameraSettings_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("NearBlurryDistance", &GPointCameraSettings_t::GetNearBlurryDistance, &GPointCameraSettings_t::SetNearBlurryDistance)
        .addProperty("NearCrispDistance", &GPointCameraSettings_t::GetNearCrispDistance, &GPointCameraSettings_t::SetNearCrispDistance)
        .addProperty("FarCrispDistance", &GPointCameraSettings_t::GetFarCrispDistance, &GPointCameraSettings_t::SetFarCrispDistance)
        .addProperty("FarBlurryDistance", &GPointCameraSettings_t::GetFarBlurryDistance, &GPointCameraSettings_t::SetFarBlurryDistance)
        .addFunction("ToPtr", &GPointCameraSettings_t::ToPtr)
        .addFunction("IsValid", &GPointCameraSettings_t::IsValid)
        .endClass();
}
GCSoundEnvelope::GCSoundEnvelope(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCSoundEnvelope::GCSoundEnvelope(void *ptr) {
    m_ptr = ptr;
}
float GCSoundEnvelope::GetCurrent() const {
    return GetSchemaValue<float>(m_ptr, "CSoundEnvelope", "m_current");
}
void GCSoundEnvelope::SetCurrent(float value) {
    SetSchemaValue(m_ptr, "CSoundEnvelope", "m_current", false, value);
}
float GCSoundEnvelope::GetTarget() const {
    return GetSchemaValue<float>(m_ptr, "CSoundEnvelope", "m_target");
}
void GCSoundEnvelope::SetTarget(float value) {
    SetSchemaValue(m_ptr, "CSoundEnvelope", "m_target", false, value);
}
float GCSoundEnvelope::GetRate() const {
    return GetSchemaValue<float>(m_ptr, "CSoundEnvelope", "m_rate");
}
void GCSoundEnvelope::SetRate(float value) {
    SetSchemaValue(m_ptr, "CSoundEnvelope", "m_rate", false, value);
}
bool GCSoundEnvelope::GetForceupdate() const {
    return GetSchemaValue<bool>(m_ptr, "CSoundEnvelope", "m_forceupdate");
}
void GCSoundEnvelope::SetForceupdate(bool value) {
    SetSchemaValue(m_ptr, "CSoundEnvelope", "m_forceupdate", false, value);
}
void* GCSoundEnvelope::GetPtr() {
    return m_ptr;
}
std::string GCSoundEnvelope::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCSoundEnvelope::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCSoundEnvelope(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCSoundEnvelope>("CSoundEnvelope")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Current", &GCSoundEnvelope::GetCurrent, &GCSoundEnvelope::SetCurrent)
        .addProperty("Target", &GCSoundEnvelope::GetTarget, &GCSoundEnvelope::SetTarget)
        .addProperty("Rate", &GCSoundEnvelope::GetRate, &GCSoundEnvelope::SetRate)
        .addProperty("Forceupdate", &GCSoundEnvelope::GetForceupdate, &GCSoundEnvelope::SetForceupdate)
        .addFunction("ToPtr", &GCSoundEnvelope::ToPtr)
        .addFunction("IsValid", &GCSoundEnvelope::IsValid)
        .endClass();
}
Gdynpitchvol_t::Gdynpitchvol_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
Gdynpitchvol_t::Gdynpitchvol_t(void *ptr) {
    m_ptr = ptr;
}
void* Gdynpitchvol_t::GetPtr() {
    return m_ptr;
}
std::string Gdynpitchvol_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool Gdynpitchvol_t::IsValid() {
    return (m_ptr != nullptr);
}
Gdynpitchvol_base_t Gdynpitchvol_t::GetParent() const {
    Gdynpitchvol_base_t value(m_ptr);
    return value;
}
void Gdynpitchvol_t::SetParent(Gdynpitchvol_base_t value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassdynpitchvol_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<Gdynpitchvol_t>("dynpitchvol_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &Gdynpitchvol_t::GetParent, &Gdynpitchvol_t::SetParent)
        .addFunction("ToPtr", &Gdynpitchvol_t::ToPtr)
        .addFunction("IsValid", &Gdynpitchvol_t::IsValid)
        .endClass();
}
GCStopwatch::GCStopwatch(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCStopwatch::GCStopwatch(void *ptr) {
    m_ptr = ptr;
}
float GCStopwatch::GetInterval() const {
    return GetSchemaValue<float>(m_ptr, "CStopwatch", "m_interval");
}
void GCStopwatch::SetInterval(float value) {
    SetSchemaValue(m_ptr, "CStopwatch", "m_interval", false, value);
}
void* GCStopwatch::GetPtr() {
    return m_ptr;
}
std::string GCStopwatch::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCStopwatch::IsValid() {
    return (m_ptr != nullptr);
}
GCStopwatchBase GCStopwatch::GetParent() const {
    GCStopwatchBase value(m_ptr);
    return value;
}
void GCStopwatch::SetParent(GCStopwatchBase value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCStopwatch(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCStopwatch>("CStopwatch")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Interval", &GCStopwatch::GetInterval, &GCStopwatch::SetInterval)
        .addProperty("Parent", &GCStopwatch::GetParent, &GCStopwatch::SetParent)
        .addFunction("ToPtr", &GCStopwatch::ToPtr)
        .addFunction("IsValid", &GCStopwatch::IsValid)
        .endClass();
}
GCNavVolumeVector::GCNavVolumeVector(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCNavVolumeVector::GCNavVolumeVector(void *ptr) {
    m_ptr = ptr;
}
bool GCNavVolumeVector::GetHasBeenPreFiltered() const {
    return GetSchemaValue<bool>(m_ptr, "CNavVolumeVector", "m_bHasBeenPreFiltered");
}
void GCNavVolumeVector::SetHasBeenPreFiltered(bool value) {
    SetSchemaValue(m_ptr, "CNavVolumeVector", "m_bHasBeenPreFiltered", false, value);
}
void* GCNavVolumeVector::GetPtr() {
    return m_ptr;
}
std::string GCNavVolumeVector::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCNavVolumeVector::IsValid() {
    return (m_ptr != nullptr);
}
GCNavVolume GCNavVolumeVector::GetParent() const {
    GCNavVolume value(m_ptr);
    return value;
}
void GCNavVolumeVector::SetParent(GCNavVolume value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCNavVolumeVector(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCNavVolumeVector>("CNavVolumeVector")
        .addConstructor<void (*)(std::string)>()
        .addProperty("HasBeenPreFiltered", &GCNavVolumeVector::GetHasBeenPreFiltered, &GCNavVolumeVector::SetHasBeenPreFiltered)
        .addProperty("Parent", &GCNavVolumeVector::GetParent, &GCNavVolumeVector::SetParent)
        .addFunction("ToPtr", &GCNavVolumeVector::ToPtr)
        .addFunction("IsValid", &GCNavVolumeVector::IsValid)
        .endClass();
}
GNavGravity_t::GNavGravity_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GNavGravity_t::GNavGravity_t(void *ptr) {
    m_ptr = ptr;
}
Vector GNavGravity_t::GetGravity() const {
    return GetSchemaValue<Vector>(m_ptr, "NavGravity_t", "m_vGravity");
}
void GNavGravity_t::SetGravity(Vector value) {
    SetSchemaValue(m_ptr, "NavGravity_t", "m_vGravity", true, value);
}
bool GNavGravity_t::GetDefault() const {
    return GetSchemaValue<bool>(m_ptr, "NavGravity_t", "m_bDefault");
}
void GNavGravity_t::SetDefault(bool value) {
    SetSchemaValue(m_ptr, "NavGravity_t", "m_bDefault", true, value);
}
void* GNavGravity_t::GetPtr() {
    return m_ptr;
}
std::string GNavGravity_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GNavGravity_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassNavGravity_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GNavGravity_t>("NavGravity_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Gravity", &GNavGravity_t::GetGravity, &GNavGravity_t::SetGravity)
        .addProperty("Default", &GNavGravity_t::GetDefault, &GNavGravity_t::SetDefault)
        .addFunction("ToPtr", &GNavGravity_t::ToPtr)
        .addFunction("IsValid", &GNavGravity_t::IsValid)
        .endClass();
}
GCEnvShake::GCEnvShake(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCEnvShake::GCEnvShake(void *ptr) {
    m_ptr = ptr;
}
std::string GCEnvShake::GetLimitToEntity() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CEnvShake", "m_limitToEntity").String();
}
void GCEnvShake::SetLimitToEntity(std::string value) {
    SetSchemaValue(m_ptr, "CEnvShake", "m_limitToEntity", false, CUtlSymbolLarge(value.c_str()));
}
float GCEnvShake::GetAmplitude() const {
    return GetSchemaValue<float>(m_ptr, "CEnvShake", "m_Amplitude");
}
void GCEnvShake::SetAmplitude(float value) {
    SetSchemaValue(m_ptr, "CEnvShake", "m_Amplitude", false, value);
}
float GCEnvShake::GetFrequency() const {
    return GetSchemaValue<float>(m_ptr, "CEnvShake", "m_Frequency");
}
void GCEnvShake::SetFrequency(float value) {
    SetSchemaValue(m_ptr, "CEnvShake", "m_Frequency", false, value);
}
float GCEnvShake::GetDuration() const {
    return GetSchemaValue<float>(m_ptr, "CEnvShake", "m_Duration");
}
void GCEnvShake::SetDuration(float value) {
    SetSchemaValue(m_ptr, "CEnvShake", "m_Duration", false, value);
}
float GCEnvShake::GetRadius() const {
    return GetSchemaValue<float>(m_ptr, "CEnvShake", "m_Radius");
}
void GCEnvShake::SetRadius(float value) {
    SetSchemaValue(m_ptr, "CEnvShake", "m_Radius", false, value);
}
float GCEnvShake::GetStopTime() const {
    return GetSchemaValue<float>(m_ptr, "CEnvShake", "m_stopTime");
}
void GCEnvShake::SetStopTime(float value) {
    SetSchemaValue(m_ptr, "CEnvShake", "m_stopTime", false, value);
}
float GCEnvShake::GetNextShake() const {
    return GetSchemaValue<float>(m_ptr, "CEnvShake", "m_nextShake");
}
void GCEnvShake::SetNextShake(float value) {
    SetSchemaValue(m_ptr, "CEnvShake", "m_nextShake", false, value);
}
float GCEnvShake::GetCurrentAmp() const {
    return GetSchemaValue<float>(m_ptr, "CEnvShake", "m_currentAmp");
}
void GCEnvShake::SetCurrentAmp(float value) {
    SetSchemaValue(m_ptr, "CEnvShake", "m_currentAmp", false, value);
}
Vector GCEnvShake::GetMaxForce() const {
    return GetSchemaValue<Vector>(m_ptr, "CEnvShake", "m_maxForce");
}
void GCEnvShake::SetMaxForce(Vector value) {
    SetSchemaValue(m_ptr, "CEnvShake", "m_maxForce", false, value);
}
GCPhysicsShake GCEnvShake::GetShakeCallback() const {
    GCPhysicsShake value(GetSchemaPtr(m_ptr, "CEnvShake", "m_shakeCallback"));
    return value;
}
void GCEnvShake::SetShakeCallback(GCPhysicsShake value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'ShakeCallback' is not possible.\n");
}
void* GCEnvShake::GetPtr() {
    return m_ptr;
}
std::string GCEnvShake::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCEnvShake::IsValid() {
    return (m_ptr != nullptr);
}
GCPointEntity GCEnvShake::GetParent() const {
    GCPointEntity value(m_ptr);
    return value;
}
void GCEnvShake::SetParent(GCPointEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCEnvShake(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCEnvShake>("CEnvShake")
        .addConstructor<void (*)(std::string)>()
        .addProperty("LimitToEntity", &GCEnvShake::GetLimitToEntity, &GCEnvShake::SetLimitToEntity)
        .addProperty("Amplitude", &GCEnvShake::GetAmplitude, &GCEnvShake::SetAmplitude)
        .addProperty("Frequency", &GCEnvShake::GetFrequency, &GCEnvShake::SetFrequency)
        .addProperty("Duration", &GCEnvShake::GetDuration, &GCEnvShake::SetDuration)
        .addProperty("Radius", &GCEnvShake::GetRadius, &GCEnvShake::SetRadius)
        .addProperty("StopTime", &GCEnvShake::GetStopTime, &GCEnvShake::SetStopTime)
        .addProperty("NextShake", &GCEnvShake::GetNextShake, &GCEnvShake::SetNextShake)
        .addProperty("CurrentAmp", &GCEnvShake::GetCurrentAmp, &GCEnvShake::SetCurrentAmp)
        .addProperty("MaxForce", &GCEnvShake::GetMaxForce, &GCEnvShake::SetMaxForce)
        .addProperty("ShakeCallback", &GCEnvShake::GetShakeCallback, &GCEnvShake::SetShakeCallback)
        .addProperty("Parent", &GCEnvShake::GetParent, &GCEnvShake::SetParent)
        .addFunction("ToPtr", &GCEnvShake::ToPtr)
        .addFunction("IsValid", &GCEnvShake::IsValid)
        .endClass();
}
GCPhysSlideConstraint::GCPhysSlideConstraint(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCPhysSlideConstraint::GCPhysSlideConstraint(void *ptr) {
    m_ptr = ptr;
}
Vector GCPhysSlideConstraint::GetAxisEnd() const {
    return GetSchemaValue<Vector>(m_ptr, "CPhysSlideConstraint", "m_axisEnd");
}
void GCPhysSlideConstraint::SetAxisEnd(Vector value) {
    SetSchemaValue(m_ptr, "CPhysSlideConstraint", "m_axisEnd", false, value);
}
float GCPhysSlideConstraint::GetSlideFriction() const {
    return GetSchemaValue<float>(m_ptr, "CPhysSlideConstraint", "m_slideFriction");
}
void GCPhysSlideConstraint::SetSlideFriction(float value) {
    SetSchemaValue(m_ptr, "CPhysSlideConstraint", "m_slideFriction", false, value);
}
float GCPhysSlideConstraint::GetSystemLoadScale() const {
    return GetSchemaValue<float>(m_ptr, "CPhysSlideConstraint", "m_systemLoadScale");
}
void GCPhysSlideConstraint::SetSystemLoadScale(float value) {
    SetSchemaValue(m_ptr, "CPhysSlideConstraint", "m_systemLoadScale", false, value);
}
float GCPhysSlideConstraint::GetInitialOffset() const {
    return GetSchemaValue<float>(m_ptr, "CPhysSlideConstraint", "m_initialOffset");
}
void GCPhysSlideConstraint::SetInitialOffset(float value) {
    SetSchemaValue(m_ptr, "CPhysSlideConstraint", "m_initialOffset", false, value);
}
bool GCPhysSlideConstraint::GetEnableLinearConstraint() const {
    return GetSchemaValue<bool>(m_ptr, "CPhysSlideConstraint", "m_bEnableLinearConstraint");
}
void GCPhysSlideConstraint::SetEnableLinearConstraint(bool value) {
    SetSchemaValue(m_ptr, "CPhysSlideConstraint", "m_bEnableLinearConstraint", false, value);
}
bool GCPhysSlideConstraint::GetEnableAngularConstraint() const {
    return GetSchemaValue<bool>(m_ptr, "CPhysSlideConstraint", "m_bEnableAngularConstraint");
}
void GCPhysSlideConstraint::SetEnableAngularConstraint(bool value) {
    SetSchemaValue(m_ptr, "CPhysSlideConstraint", "m_bEnableAngularConstraint", false, value);
}
float GCPhysSlideConstraint::GetMotorFrequency() const {
    return GetSchemaValue<float>(m_ptr, "CPhysSlideConstraint", "m_flMotorFrequency");
}
void GCPhysSlideConstraint::SetMotorFrequency(float value) {
    SetSchemaValue(m_ptr, "CPhysSlideConstraint", "m_flMotorFrequency", false, value);
}
float GCPhysSlideConstraint::GetMotorDampingRatio() const {
    return GetSchemaValue<float>(m_ptr, "CPhysSlideConstraint", "m_flMotorDampingRatio");
}
void GCPhysSlideConstraint::SetMotorDampingRatio(float value) {
    SetSchemaValue(m_ptr, "CPhysSlideConstraint", "m_flMotorDampingRatio", false, value);
}
bool GCPhysSlideConstraint::GetUseEntityPivot() const {
    return GetSchemaValue<bool>(m_ptr, "CPhysSlideConstraint", "m_bUseEntityPivot");
}
void GCPhysSlideConstraint::SetUseEntityPivot(bool value) {
    SetSchemaValue(m_ptr, "CPhysSlideConstraint", "m_bUseEntityPivot", false, value);
}
GConstraintSoundInfo GCPhysSlideConstraint::GetSoundInfo() const {
    GConstraintSoundInfo value(GetSchemaPtr(m_ptr, "CPhysSlideConstraint", "m_soundInfo"));
    return value;
}
void GCPhysSlideConstraint::SetSoundInfo(GConstraintSoundInfo value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'SoundInfo' is not possible.\n");
}
void* GCPhysSlideConstraint::GetPtr() {
    return m_ptr;
}
std::string GCPhysSlideConstraint::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCPhysSlideConstraint::IsValid() {
    return (m_ptr != nullptr);
}
GCPhysConstraint GCPhysSlideConstraint::GetParent() const {
    GCPhysConstraint value(m_ptr);
    return value;
}
void GCPhysSlideConstraint::SetParent(GCPhysConstraint value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCPhysSlideConstraint(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCPhysSlideConstraint>("CPhysSlideConstraint")
        .addConstructor<void (*)(std::string)>()
        .addProperty("AxisEnd", &GCPhysSlideConstraint::GetAxisEnd, &GCPhysSlideConstraint::SetAxisEnd)
        .addProperty("SlideFriction", &GCPhysSlideConstraint::GetSlideFriction, &GCPhysSlideConstraint::SetSlideFriction)
        .addProperty("SystemLoadScale", &GCPhysSlideConstraint::GetSystemLoadScale, &GCPhysSlideConstraint::SetSystemLoadScale)
        .addProperty("InitialOffset", &GCPhysSlideConstraint::GetInitialOffset, &GCPhysSlideConstraint::SetInitialOffset)
        .addProperty("EnableLinearConstraint", &GCPhysSlideConstraint::GetEnableLinearConstraint, &GCPhysSlideConstraint::SetEnableLinearConstraint)
        .addProperty("EnableAngularConstraint", &GCPhysSlideConstraint::GetEnableAngularConstraint, &GCPhysSlideConstraint::SetEnableAngularConstraint)
        .addProperty("MotorFrequency", &GCPhysSlideConstraint::GetMotorFrequency, &GCPhysSlideConstraint::SetMotorFrequency)
        .addProperty("MotorDampingRatio", &GCPhysSlideConstraint::GetMotorDampingRatio, &GCPhysSlideConstraint::SetMotorDampingRatio)
        .addProperty("UseEntityPivot", &GCPhysSlideConstraint::GetUseEntityPivot, &GCPhysSlideConstraint::SetUseEntityPivot)
        .addProperty("SoundInfo", &GCPhysSlideConstraint::GetSoundInfo, &GCPhysSlideConstraint::SetSoundInfo)
        .addProperty("Parent", &GCPhysSlideConstraint::GetParent, &GCPhysSlideConstraint::SetParent)
        .addFunction("ToPtr", &GCPhysSlideConstraint::ToPtr)
        .addFunction("IsValid", &GCPhysSlideConstraint::IsValid)
        .endClass();
}
GCSound::GCSound(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCSound::GCSound(void *ptr) {
    m_ptr = ptr;
}
GCBaseEntity GCSound::GetOwner() const {
    GCBaseEntity value((void*)(GetSchemaValue<CHandle<CEntityInstance>>(m_ptr, "CSound", "m_hOwner").Get()));
    return value;
}
void GCSound::SetOwner(GCBaseEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Owner' is not possible.\n");
}
GCBaseEntity GCSound::GetTarget() const {
    GCBaseEntity value((void*)(GetSchemaValue<CHandle<CEntityInstance>>(m_ptr, "CSound", "m_hTarget").Get()));
    return value;
}
void GCSound::SetTarget(GCBaseEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Target' is not possible.\n");
}
int32_t GCSound::GetVolume() const {
    return GetSchemaValue<int32_t>(m_ptr, "CSound", "m_iVolume");
}
void GCSound::SetVolume(int32_t value) {
    SetSchemaValue(m_ptr, "CSound", "m_iVolume", false, value);
}
float GCSound::GetOcclusionScale() const {
    return GetSchemaValue<float>(m_ptr, "CSound", "m_flOcclusionScale");
}
void GCSound::SetOcclusionScale(float value) {
    SetSchemaValue(m_ptr, "CSound", "m_flOcclusionScale", false, value);
}
int32_t GCSound::GetNextAudible() const {
    return GetSchemaValue<int32_t>(m_ptr, "CSound", "m_iNextAudible");
}
void GCSound::SetNextAudible(int32_t value) {
    SetSchemaValue(m_ptr, "CSound", "m_iNextAudible", false, value);
}
float GCSound::GetExpireTime() const {
    return GetSchemaValue<float>(m_ptr, "CSound", "m_flExpireTime");
}
void GCSound::SetExpireTime(float value) {
    SetSchemaValue(m_ptr, "CSound", "m_flExpireTime", false, value);
}
int16_t GCSound::GetNext() const {
    return GetSchemaValue<int16_t>(m_ptr, "CSound", "m_iNext");
}
void GCSound::SetNext(int16_t value) {
    SetSchemaValue(m_ptr, "CSound", "m_iNext", false, value);
}
bool GCSound::GetNoExpirationTime() const {
    return GetSchemaValue<bool>(m_ptr, "CSound", "m_bNoExpirationTime");
}
void GCSound::SetNoExpirationTime(bool value) {
    SetSchemaValue(m_ptr, "CSound", "m_bNoExpirationTime", false, value);
}
int32_t GCSound::GetOwnerChannelIndex() const {
    return GetSchemaValue<int32_t>(m_ptr, "CSound", "m_ownerChannelIndex");
}
void GCSound::SetOwnerChannelIndex(int32_t value) {
    SetSchemaValue(m_ptr, "CSound", "m_ownerChannelIndex", false, value);
}
Vector GCSound::GetOrigin() const {
    return GetSchemaValue<Vector>(m_ptr, "CSound", "m_vecOrigin");
}
void GCSound::SetOrigin(Vector value) {
    SetSchemaValue(m_ptr, "CSound", "m_vecOrigin", false, value);
}
bool GCSound::GetHasOwner() const {
    return GetSchemaValue<bool>(m_ptr, "CSound", "m_bHasOwner");
}
void GCSound::SetHasOwner(bool value) {
    SetSchemaValue(m_ptr, "CSound", "m_bHasOwner", false, value);
}
void* GCSound::GetPtr() {
    return m_ptr;
}
std::string GCSound::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCSound::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCSound(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCSound>("CSound")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Owner", &GCSound::GetOwner, &GCSound::SetOwner)
        .addProperty("Target", &GCSound::GetTarget, &GCSound::SetTarget)
        .addProperty("Volume", &GCSound::GetVolume, &GCSound::SetVolume)
        .addProperty("OcclusionScale", &GCSound::GetOcclusionScale, &GCSound::SetOcclusionScale)
        .addProperty("NextAudible", &GCSound::GetNextAudible, &GCSound::SetNextAudible)
        .addProperty("ExpireTime", &GCSound::GetExpireTime, &GCSound::SetExpireTime)
        .addProperty("Next", &GCSound::GetNext, &GCSound::SetNext)
        .addProperty("NoExpirationTime", &GCSound::GetNoExpirationTime, &GCSound::SetNoExpirationTime)
        .addProperty("OwnerChannelIndex", &GCSound::GetOwnerChannelIndex, &GCSound::SetOwnerChannelIndex)
        .addProperty("Origin", &GCSound::GetOrigin, &GCSound::SetOrigin)
        .addProperty("HasOwner", &GCSound::GetHasOwner, &GCSound::SetHasOwner)
        .addFunction("ToPtr", &GCSound::ToPtr)
        .addFunction("IsValid", &GCSound::IsValid)
        .endClass();
}
GCTakeDamageResult::GCTakeDamageResult(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCTakeDamageResult::GCTakeDamageResult(void *ptr) {
    m_ptr = ptr;
}
GCTakeDamageInfo GCTakeDamageResult::GetOriginatingInfo() const {
    GCTakeDamageInfo value(*(void**)GetSchemaPtr(m_ptr, "CTakeDamageResult", "m_pOriginatingInfo"));
    return value;
}
void GCTakeDamageResult::SetOriginatingInfo(GCTakeDamageInfo value) {
    SetSchemaValue(m_ptr, "CTakeDamageResult","m_pOriginatingInfo", false, (char*)value.GetPtr());
}
int32_t GCTakeDamageResult::GetHealthLost() const {
    return GetSchemaValue<int32_t>(m_ptr, "CTakeDamageResult", "m_nHealthLost");
}
void GCTakeDamageResult::SetHealthLost(int32_t value) {
    SetSchemaValue(m_ptr, "CTakeDamageResult", "m_nHealthLost", false, value);
}
int32_t GCTakeDamageResult::GetDamageTaken() const {
    return GetSchemaValue<int32_t>(m_ptr, "CTakeDamageResult", "m_nDamageTaken");
}
void GCTakeDamageResult::SetDamageTaken(int32_t value) {
    SetSchemaValue(m_ptr, "CTakeDamageResult", "m_nDamageTaken", false, value);
}
int32_t GCTakeDamageResult::GetTotalledHealthLost() const {
    return GetSchemaValue<int32_t>(m_ptr, "CTakeDamageResult", "m_nTotalledHealthLost");
}
void GCTakeDamageResult::SetTotalledHealthLost(int32_t value) {
    SetSchemaValue(m_ptr, "CTakeDamageResult", "m_nTotalledHealthLost", false, value);
}
int32_t GCTakeDamageResult::GetTotalledDamageTaken() const {
    return GetSchemaValue<int32_t>(m_ptr, "CTakeDamageResult", "m_nTotalledDamageTaken");
}
void GCTakeDamageResult::SetTotalledDamageTaken(int32_t value) {
    SetSchemaValue(m_ptr, "CTakeDamageResult", "m_nTotalledDamageTaken", false, value);
}
void* GCTakeDamageResult::GetPtr() {
    return m_ptr;
}
std::string GCTakeDamageResult::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCTakeDamageResult::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCTakeDamageResult(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCTakeDamageResult>("CTakeDamageResult")
        .addConstructor<void (*)(std::string)>()
        .addProperty("OriginatingInfo", &GCTakeDamageResult::GetOriginatingInfo, &GCTakeDamageResult::SetOriginatingInfo)
        .addProperty("HealthLost", &GCTakeDamageResult::GetHealthLost, &GCTakeDamageResult::SetHealthLost)
        .addProperty("DamageTaken", &GCTakeDamageResult::GetDamageTaken, &GCTakeDamageResult::SetDamageTaken)
        .addProperty("TotalledHealthLost", &GCTakeDamageResult::GetTotalledHealthLost, &GCTakeDamageResult::SetTotalledHealthLost)
        .addProperty("TotalledDamageTaken", &GCTakeDamageResult::GetTotalledDamageTaken, &GCTakeDamageResult::SetTotalledDamageTaken)
        .addFunction("ToPtr", &GCTakeDamageResult::ToPtr)
        .addFunction("IsValid", &GCTakeDamageResult::IsValid)
        .endClass();
}
GCMolotovProjectile::GCMolotovProjectile(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCMolotovProjectile::GCMolotovProjectile(void *ptr) {
    m_ptr = ptr;
}
bool GCMolotovProjectile::GetIsIncGrenade() const {
    return GetSchemaValue<bool>(m_ptr, "CMolotovProjectile", "m_bIsIncGrenade");
}
void GCMolotovProjectile::SetIsIncGrenade(bool value) {
    SetSchemaValue(m_ptr, "CMolotovProjectile", "m_bIsIncGrenade", false, value);
}
bool GCMolotovProjectile::GetDetonated() const {
    return GetSchemaValue<bool>(m_ptr, "CMolotovProjectile", "m_bDetonated");
}
void GCMolotovProjectile::SetDetonated(bool value) {
    SetSchemaValue(m_ptr, "CMolotovProjectile", "m_bDetonated", false, value);
}
GIntervalTimer GCMolotovProjectile::GetStillTimer() const {
    GIntervalTimer value(GetSchemaPtr(m_ptr, "CMolotovProjectile", "m_stillTimer"));
    return value;
}
void GCMolotovProjectile::SetStillTimer(GIntervalTimer value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'StillTimer' is not possible.\n");
}
bool GCMolotovProjectile::GetHasBouncedOffPlayer() const {
    return GetSchemaValue<bool>(m_ptr, "CMolotovProjectile", "m_bHasBouncedOffPlayer");
}
void GCMolotovProjectile::SetHasBouncedOffPlayer(bool value) {
    SetSchemaValue(m_ptr, "CMolotovProjectile", "m_bHasBouncedOffPlayer", false, value);
}
void* GCMolotovProjectile::GetPtr() {
    return m_ptr;
}
std::string GCMolotovProjectile::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCMolotovProjectile::IsValid() {
    return (m_ptr != nullptr);
}
GCBaseCSGrenadeProjectile GCMolotovProjectile::GetParent() const {
    GCBaseCSGrenadeProjectile value(m_ptr);
    return value;
}
void GCMolotovProjectile::SetParent(GCBaseCSGrenadeProjectile value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCMolotovProjectile(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCMolotovProjectile>("CMolotovProjectile")
        .addConstructor<void (*)(std::string)>()
        .addProperty("IsIncGrenade", &GCMolotovProjectile::GetIsIncGrenade, &GCMolotovProjectile::SetIsIncGrenade)
        .addProperty("Detonated", &GCMolotovProjectile::GetDetonated, &GCMolotovProjectile::SetDetonated)
        .addProperty("StillTimer", &GCMolotovProjectile::GetStillTimer, &GCMolotovProjectile::SetStillTimer)
        .addProperty("HasBouncedOffPlayer", &GCMolotovProjectile::GetHasBouncedOffPlayer, &GCMolotovProjectile::SetHasBouncedOffPlayer)
        .addProperty("Parent", &GCMolotovProjectile::GetParent, &GCMolotovProjectile::SetParent)
        .addFunction("ToPtr", &GCMolotovProjectile::ToPtr)
        .addFunction("IsValid", &GCMolotovProjectile::IsValid)
        .endClass();
}
GCCommentarySystem::GCCommentarySystem(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCCommentarySystem::GCCommentarySystem(void *ptr) {
    m_ptr = ptr;
}
bool GCCommentarySystem::GetCommentaryConvarsChanging() const {
    return GetSchemaValue<bool>(m_ptr, "CCommentarySystem", "m_bCommentaryConvarsChanging");
}
void GCCommentarySystem::SetCommentaryConvarsChanging(bool value) {
    SetSchemaValue(m_ptr, "CCommentarySystem", "m_bCommentaryConvarsChanging", false, value);
}
bool GCCommentarySystem::GetCommentaryEnabledMidGame() const {
    return GetSchemaValue<bool>(m_ptr, "CCommentarySystem", "m_bCommentaryEnabledMidGame");
}
void GCCommentarySystem::SetCommentaryEnabledMidGame(bool value) {
    SetSchemaValue(m_ptr, "CCommentarySystem", "m_bCommentaryEnabledMidGame", false, value);
}
float GCCommentarySystem::GetNextTeleportTime() const {
    return GetSchemaValue<float>(m_ptr, "CCommentarySystem", "m_flNextTeleportTime");
}
void GCCommentarySystem::SetNextTeleportTime(float value) {
    SetSchemaValue(m_ptr, "CCommentarySystem", "m_flNextTeleportTime", false, value);
}
int32_t GCCommentarySystem::GetTeleportStage() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCommentarySystem", "m_iTeleportStage");
}
void GCCommentarySystem::SetTeleportStage(int32_t value) {
    SetSchemaValue(m_ptr, "CCommentarySystem", "m_iTeleportStage", false, value);
}
bool GCCommentarySystem::GetCheatState() const {
    return GetSchemaValue<bool>(m_ptr, "CCommentarySystem", "m_bCheatState");
}
void GCCommentarySystem::SetCheatState(bool value) {
    SetSchemaValue(m_ptr, "CCommentarySystem", "m_bCheatState", false, value);
}
bool GCCommentarySystem::GetIsFirstSpawnGroupToLoad() const {
    return GetSchemaValue<bool>(m_ptr, "CCommentarySystem", "m_bIsFirstSpawnGroupToLoad");
}
void GCCommentarySystem::SetIsFirstSpawnGroupToLoad(bool value) {
    SetSchemaValue(m_ptr, "CCommentarySystem", "m_bIsFirstSpawnGroupToLoad", false, value);
}
void* GCCommentarySystem::GetPtr() {
    return m_ptr;
}
std::string GCCommentarySystem::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCCommentarySystem::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCCommentarySystem(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCCommentarySystem>("CCommentarySystem")
        .addConstructor<void (*)(std::string)>()
        .addProperty("CommentaryConvarsChanging", &GCCommentarySystem::GetCommentaryConvarsChanging, &GCCommentarySystem::SetCommentaryConvarsChanging)
        .addProperty("CommentaryEnabledMidGame", &GCCommentarySystem::GetCommentaryEnabledMidGame, &GCCommentarySystem::SetCommentaryEnabledMidGame)
        .addProperty("NextTeleportTime", &GCCommentarySystem::GetNextTeleportTime, &GCCommentarySystem::SetNextTeleportTime)
        .addProperty("TeleportStage", &GCCommentarySystem::GetTeleportStage, &GCCommentarySystem::SetTeleportStage)
        .addProperty("CheatState", &GCCommentarySystem::GetCheatState, &GCCommentarySystem::SetCheatState)
        .addProperty("IsFirstSpawnGroupToLoad", &GCCommentarySystem::GetIsFirstSpawnGroupToLoad, &GCCommentarySystem::SetIsFirstSpawnGroupToLoad)
        .addFunction("ToPtr", &GCCommentarySystem::ToPtr)
        .addFunction("IsValid", &GCCommentarySystem::IsValid)
        .endClass();
}
GResponseFollowup::GResponseFollowup(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GResponseFollowup::GResponseFollowup(void *ptr) {
    m_ptr = ptr;
}
std::string GResponseFollowup::GetFollowup_concept() const {
    return GetSchemaValuePtr<char>(m_ptr, "ResponseFollowup", "followup_concept");
}
void GResponseFollowup::SetFollowup_concept(std::string value) {
    WriteSchemaPtrValue(m_ptr, "ResponseFollowup", "followup_concept", false, reinterpret_cast<byte*>(const_cast<char*>(value.c_str())), value.size());
}
std::string GResponseFollowup::GetFollowup_contexts() const {
    return GetSchemaValuePtr<char>(m_ptr, "ResponseFollowup", "followup_contexts");
}
void GResponseFollowup::SetFollowup_contexts(std::string value) {
    WriteSchemaPtrValue(m_ptr, "ResponseFollowup", "followup_contexts", false, reinterpret_cast<byte*>(const_cast<char*>(value.c_str())), value.size());
}
float GResponseFollowup::GetFollowup_delay() const {
    return GetSchemaValue<float>(m_ptr, "ResponseFollowup", "followup_delay");
}
void GResponseFollowup::SetFollowup_delay(float value) {
    SetSchemaValue(m_ptr, "ResponseFollowup", "followup_delay", false, value);
}
std::string GResponseFollowup::GetFollowup_target() const {
    return GetSchemaValuePtr<char>(m_ptr, "ResponseFollowup", "followup_target");
}
void GResponseFollowup::SetFollowup_target(std::string value) {
    WriteSchemaPtrValue(m_ptr, "ResponseFollowup", "followup_target", false, reinterpret_cast<byte*>(const_cast<char*>(value.c_str())), value.size());
}
std::string GResponseFollowup::GetFollowup_entityiotarget() const {
    return GetSchemaValuePtr<char>(m_ptr, "ResponseFollowup", "followup_entityiotarget");
}
void GResponseFollowup::SetFollowup_entityiotarget(std::string value) {
    WriteSchemaPtrValue(m_ptr, "ResponseFollowup", "followup_entityiotarget", false, reinterpret_cast<byte*>(const_cast<char*>(value.c_str())), value.size());
}
std::string GResponseFollowup::GetFollowup_entityioinput() const {
    return GetSchemaValuePtr<char>(m_ptr, "ResponseFollowup", "followup_entityioinput");
}
void GResponseFollowup::SetFollowup_entityioinput(std::string value) {
    WriteSchemaPtrValue(m_ptr, "ResponseFollowup", "followup_entityioinput", false, reinterpret_cast<byte*>(const_cast<char*>(value.c_str())), value.size());
}
float GResponseFollowup::GetFollowup_entityiodelay() const {
    return GetSchemaValue<float>(m_ptr, "ResponseFollowup", "followup_entityiodelay");
}
void GResponseFollowup::SetFollowup_entityiodelay(float value) {
    SetSchemaValue(m_ptr, "ResponseFollowup", "followup_entityiodelay", false, value);
}
bool GResponseFollowup::GetFired() const {
    return GetSchemaValue<bool>(m_ptr, "ResponseFollowup", "bFired");
}
void GResponseFollowup::SetFired(bool value) {
    SetSchemaValue(m_ptr, "ResponseFollowup", "bFired", false, value);
}
void* GResponseFollowup::GetPtr() {
    return m_ptr;
}
std::string GResponseFollowup::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GResponseFollowup::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassResponseFollowup(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GResponseFollowup>("ResponseFollowup")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Followup_concept", &GResponseFollowup::GetFollowup_concept, &GResponseFollowup::SetFollowup_concept)
        .addProperty("Followup_contexts", &GResponseFollowup::GetFollowup_contexts, &GResponseFollowup::SetFollowup_contexts)
        .addProperty("Followup_delay", &GResponseFollowup::GetFollowup_delay, &GResponseFollowup::SetFollowup_delay)
        .addProperty("Followup_target", &GResponseFollowup::GetFollowup_target, &GResponseFollowup::SetFollowup_target)
        .addProperty("Followup_entityiotarget", &GResponseFollowup::GetFollowup_entityiotarget, &GResponseFollowup::SetFollowup_entityiotarget)
        .addProperty("Followup_entityioinput", &GResponseFollowup::GetFollowup_entityioinput, &GResponseFollowup::SetFollowup_entityioinput)
        .addProperty("Followup_entityiodelay", &GResponseFollowup::GetFollowup_entityiodelay, &GResponseFollowup::SetFollowup_entityiodelay)
        .addProperty("Fired", &GResponseFollowup::GetFired, &GResponseFollowup::SetFired)
        .addFunction("ToPtr", &GResponseFollowup::ToPtr)
        .addFunction("IsValid", &GResponseFollowup::IsValid)
        .endClass();
}
GCRangeInt::GCRangeInt(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCRangeInt::GCRangeInt(void *ptr) {
    m_ptr = ptr;
}
std::vector<int32_t> GCRangeInt::GetValue() const {
    int32_t* outValue = (int32_t*)GetSchemaPtr(m_ptr, "CRangeInt", "m_pValue"); std::vector<int32_t> ret; for(int i = 0; i < 2; i++) { ret.push_back(outValue[i]); } return ret;
}
void GCRangeInt::SetValue(std::vector<int32_t> value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Value' is not possible.\n");
}
void* GCRangeInt::GetPtr() {
    return m_ptr;
}
std::string GCRangeInt::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCRangeInt::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCRangeInt(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCRangeInt>("CRangeInt")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Value", &GCRangeInt::GetValue, &GCRangeInt::SetValue)
        .addFunction("ToPtr", &GCRangeInt::ToPtr)
        .addFunction("IsValid", &GCRangeInt::IsValid)
        .endClass();
}
GCNavLinkAnimgraphVar::GCNavLinkAnimgraphVar(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCNavLinkAnimgraphVar::GCNavLinkAnimgraphVar(void *ptr) {
    m_ptr = ptr;
}
uint32_t GCNavLinkAnimgraphVar::GetAlignmentDegrees() const {
    return GetSchemaValue<uint32_t>(m_ptr, "CNavLinkAnimgraphVar", "m_unAlignmentDegrees");
}
void GCNavLinkAnimgraphVar::SetAlignmentDegrees(uint32_t value) {
    SetSchemaValue(m_ptr, "CNavLinkAnimgraphVar", "m_unAlignmentDegrees", false, value);
}
void* GCNavLinkAnimgraphVar::GetPtr() {
    return m_ptr;
}
std::string GCNavLinkAnimgraphVar::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCNavLinkAnimgraphVar::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCNavLinkAnimgraphVar(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCNavLinkAnimgraphVar>("CNavLinkAnimgraphVar")
        .addConstructor<void (*)(std::string)>()
        .addProperty("AlignmentDegrees", &GCNavLinkAnimgraphVar::GetAlignmentDegrees, &GCNavLinkAnimgraphVar::SetAlignmentDegrees)
        .addFunction("ToPtr", &GCNavLinkAnimgraphVar::ToPtr)
        .addFunction("IsValid", &GCNavLinkAnimgraphVar::IsValid)
        .endClass();
}
GCCSGO_TeamSelectCounterTerroristPosition::GCCSGO_TeamSelectCounterTerroristPosition(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCCSGO_TeamSelectCounterTerroristPosition::GCCSGO_TeamSelectCounterTerroristPosition(void *ptr) {
    m_ptr = ptr;
}
void* GCCSGO_TeamSelectCounterTerroristPosition::GetPtr() {
    return m_ptr;
}
std::string GCCSGO_TeamSelectCounterTerroristPosition::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCCSGO_TeamSelectCounterTerroristPosition::IsValid() {
    return (m_ptr != nullptr);
}
GCCSGO_TeamSelectCharacterPosition GCCSGO_TeamSelectCounterTerroristPosition::GetParent() const {
    GCCSGO_TeamSelectCharacterPosition value(m_ptr);
    return value;
}
void GCCSGO_TeamSelectCounterTerroristPosition::SetParent(GCCSGO_TeamSelectCharacterPosition value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCCSGO_TeamSelectCounterTerroristPosition(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCCSGO_TeamSelectCounterTerroristPosition>("CCSGO_TeamSelectCounterTerroristPosition")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCCSGO_TeamSelectCounterTerroristPosition::GetParent, &GCCSGO_TeamSelectCounterTerroristPosition::SetParent)
        .addFunction("ToPtr", &GCCSGO_TeamSelectCounterTerroristPosition::ToPtr)
        .addFunction("IsValid", &GCCSGO_TeamSelectCounterTerroristPosition::IsValid)
        .endClass();
}
GCNavLinkMovementVData::GCNavLinkMovementVData(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCNavLinkMovementVData::GCNavLinkMovementVData(void *ptr) {
    m_ptr = ptr;
}
bool GCNavLinkMovementVData::GetIsInterpolated() const {
    return GetSchemaValue<bool>(m_ptr, "CNavLinkMovementVData", "m_bIsInterpolated");
}
void GCNavLinkMovementVData::SetIsInterpolated(bool value) {
    SetSchemaValue(m_ptr, "CNavLinkMovementVData", "m_bIsInterpolated", false, value);
}
uint32_t GCNavLinkMovementVData::GetRecommendedDistance() const {
    return GetSchemaValue<uint32_t>(m_ptr, "CNavLinkMovementVData", "m_unRecommendedDistance");
}
void GCNavLinkMovementVData::SetRecommendedDistance(uint32_t value) {
    SetSchemaValue(m_ptr, "CNavLinkMovementVData", "m_unRecommendedDistance", false, value);
}
std::vector<GCNavLinkAnimgraphVar> GCNavLinkMovementVData::GetAnimgraphVars() const {
    CUtlVector<GCNavLinkAnimgraphVar>* vec = GetSchemaValue<CUtlVector<GCNavLinkAnimgraphVar>*>(m_ptr, "CNavLinkMovementVData", "m_vecAnimgraphVars"); std::vector<GCNavLinkAnimgraphVar> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCNavLinkMovementVData::SetAnimgraphVars(std::vector<GCNavLinkAnimgraphVar> value) {
    SetSchemaValueCUtlVector<GCNavLinkAnimgraphVar>(m_ptr, "CNavLinkMovementVData", "m_vecAnimgraphVars", false, value);
}
void* GCNavLinkMovementVData::GetPtr() {
    return m_ptr;
}
std::string GCNavLinkMovementVData::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCNavLinkMovementVData::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCNavLinkMovementVData(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCNavLinkMovementVData>("CNavLinkMovementVData")
        .addConstructor<void (*)(std::string)>()
        .addProperty("IsInterpolated", &GCNavLinkMovementVData::GetIsInterpolated, &GCNavLinkMovementVData::SetIsInterpolated)
        .addProperty("RecommendedDistance", &GCNavLinkMovementVData::GetRecommendedDistance, &GCNavLinkMovementVData::SetRecommendedDistance)
        .addProperty("AnimgraphVars", &GCNavLinkMovementVData::GetAnimgraphVars, &GCNavLinkMovementVData::SetAnimgraphVars)
        .addFunction("ToPtr", &GCNavLinkMovementVData::ToPtr)
        .addFunction("IsValid", &GCNavLinkMovementVData::IsValid)
        .endClass();
}
GCAnimGraphControllerBase::GCAnimGraphControllerBase(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCAnimGraphControllerBase::GCAnimGraphControllerBase(void *ptr) {
    m_ptr = ptr;
}
void* GCAnimGraphControllerBase::GetPtr() {
    return m_ptr;
}
std::string GCAnimGraphControllerBase::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCAnimGraphControllerBase::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCAnimGraphControllerBase(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCAnimGraphControllerBase>("CAnimGraphControllerBase")
        .addConstructor<void (*)(std::string)>()
        .addFunction("ToPtr", &GCAnimGraphControllerBase::ToPtr)
        .addFunction("IsValid", &GCAnimGraphControllerBase::IsValid)
        .endClass();
}
GRagdollCreationParams_t::GRagdollCreationParams_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GRagdollCreationParams_t::GRagdollCreationParams_t(void *ptr) {
    m_ptr = ptr;
}
Vector GRagdollCreationParams_t::GetForce() const {
    return GetSchemaValue<Vector>(m_ptr, "RagdollCreationParams_t", "m_vForce");
}
void GRagdollCreationParams_t::SetForce(Vector value) {
    SetSchemaValue(m_ptr, "RagdollCreationParams_t", "m_vForce", true, value);
}
int32_t GRagdollCreationParams_t::GetForceBone() const {
    return GetSchemaValue<int32_t>(m_ptr, "RagdollCreationParams_t", "m_nForceBone");
}
void GRagdollCreationParams_t::SetForceBone(int32_t value) {
    SetSchemaValue(m_ptr, "RagdollCreationParams_t", "m_nForceBone", true, value);
}
bool GRagdollCreationParams_t::GetForceCurrentWorldTransform() const {
    return GetSchemaValue<bool>(m_ptr, "RagdollCreationParams_t", "m_bForceCurrentWorldTransform");
}
void GRagdollCreationParams_t::SetForceCurrentWorldTransform(bool value) {
    SetSchemaValue(m_ptr, "RagdollCreationParams_t", "m_bForceCurrentWorldTransform", true, value);
}
void* GRagdollCreationParams_t::GetPtr() {
    return m_ptr;
}
std::string GRagdollCreationParams_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GRagdollCreationParams_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassRagdollCreationParams_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GRagdollCreationParams_t>("RagdollCreationParams_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Force", &GRagdollCreationParams_t::GetForce, &GRagdollCreationParams_t::SetForce)
        .addProperty("ForceBone", &GRagdollCreationParams_t::GetForceBone, &GRagdollCreationParams_t::SetForceBone)
        .addProperty("ForceCurrentWorldTransform", &GRagdollCreationParams_t::GetForceCurrentWorldTransform, &GRagdollCreationParams_t::SetForceCurrentWorldTransform)
        .addFunction("ToPtr", &GRagdollCreationParams_t::ToPtr)
        .addFunction("IsValid", &GRagdollCreationParams_t::IsValid)
        .endClass();
}
GAmmoTypeInfo_t::GAmmoTypeInfo_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GAmmoTypeInfo_t::GAmmoTypeInfo_t(void *ptr) {
    m_ptr = ptr;
}
int32_t GAmmoTypeInfo_t::GetMaxCarry() const {
    return GetSchemaValue<int32_t>(m_ptr, "AmmoTypeInfo_t", "m_nMaxCarry");
}
void GAmmoTypeInfo_t::SetMaxCarry(int32_t value) {
    SetSchemaValue(m_ptr, "AmmoTypeInfo_t", "m_nMaxCarry", true, value);
}
GCRangeInt GAmmoTypeInfo_t::GetSplashSize() const {
    GCRangeInt value(GetSchemaPtr(m_ptr, "AmmoTypeInfo_t", "m_nSplashSize"));
    return value;
}
void GAmmoTypeInfo_t::SetSplashSize(GCRangeInt value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'SplashSize' is not possible.\n");
}
uint64_t GAmmoTypeInfo_t::GetFlags() const {
    return GetSchemaValue<uint64_t>(m_ptr, "AmmoTypeInfo_t", "m_nFlags");
}
void GAmmoTypeInfo_t::SetFlags(uint64_t value) {
    SetSchemaValue(m_ptr, "AmmoTypeInfo_t", "m_nFlags", true, value);
}
float GAmmoTypeInfo_t::GetMass() const {
    return GetSchemaValue<float>(m_ptr, "AmmoTypeInfo_t", "m_flMass");
}
void GAmmoTypeInfo_t::SetMass(float value) {
    SetSchemaValue(m_ptr, "AmmoTypeInfo_t", "m_flMass", true, value);
}
GCRangeFloat GAmmoTypeInfo_t::GetSpeed() const {
    GCRangeFloat value(GetSchemaPtr(m_ptr, "AmmoTypeInfo_t", "m_flSpeed"));
    return value;
}
void GAmmoTypeInfo_t::SetSpeed(GCRangeFloat value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Speed' is not possible.\n");
}
void* GAmmoTypeInfo_t::GetPtr() {
    return m_ptr;
}
std::string GAmmoTypeInfo_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GAmmoTypeInfo_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassAmmoTypeInfo_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GAmmoTypeInfo_t>("AmmoTypeInfo_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("MaxCarry", &GAmmoTypeInfo_t::GetMaxCarry, &GAmmoTypeInfo_t::SetMaxCarry)
        .addProperty("SplashSize", &GAmmoTypeInfo_t::GetSplashSize, &GAmmoTypeInfo_t::SetSplashSize)
        .addProperty("Flags", &GAmmoTypeInfo_t::GetFlags, &GAmmoTypeInfo_t::SetFlags)
        .addProperty("Mass", &GAmmoTypeInfo_t::GetMass, &GAmmoTypeInfo_t::SetMass)
        .addProperty("Speed", &GAmmoTypeInfo_t::GetSpeed, &GAmmoTypeInfo_t::SetSpeed)
        .addFunction("ToPtr", &GAmmoTypeInfo_t::ToPtr)
        .addFunction("IsValid", &GAmmoTypeInfo_t::IsValid)
        .endClass();
}
GCRandStopwatch::GCRandStopwatch(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCRandStopwatch::GCRandStopwatch(void *ptr) {
    m_ptr = ptr;
}
float GCRandStopwatch::GetMinInterval() const {
    return GetSchemaValue<float>(m_ptr, "CRandStopwatch", "m_minInterval");
}
void GCRandStopwatch::SetMinInterval(float value) {
    SetSchemaValue(m_ptr, "CRandStopwatch", "m_minInterval", false, value);
}
float GCRandStopwatch::GetMaxInterval() const {
    return GetSchemaValue<float>(m_ptr, "CRandStopwatch", "m_maxInterval");
}
void GCRandStopwatch::SetMaxInterval(float value) {
    SetSchemaValue(m_ptr, "CRandStopwatch", "m_maxInterval", false, value);
}
void* GCRandStopwatch::GetPtr() {
    return m_ptr;
}
std::string GCRandStopwatch::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCRandStopwatch::IsValid() {
    return (m_ptr != nullptr);
}
GCStopwatchBase GCRandStopwatch::GetParent() const {
    GCStopwatchBase value(m_ptr);
    return value;
}
void GCRandStopwatch::SetParent(GCStopwatchBase value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCRandStopwatch(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCRandStopwatch>("CRandStopwatch")
        .addConstructor<void (*)(std::string)>()
        .addProperty("MinInterval", &GCRandStopwatch::GetMinInterval, &GCRandStopwatch::SetMinInterval)
        .addProperty("MaxInterval", &GCRandStopwatch::GetMaxInterval, &GCRandStopwatch::SetMaxInterval)
        .addProperty("Parent", &GCRandStopwatch::GetParent, &GCRandStopwatch::SetParent)
        .addFunction("ToPtr", &GCRandStopwatch::ToPtr)
        .addFunction("IsValid", &GCRandStopwatch::IsValid)
        .endClass();
}
GCGameChoreoServices::GCGameChoreoServices(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCGameChoreoServices::GCGameChoreoServices(void *ptr) {
    m_ptr = ptr;
}
GCBaseAnimGraph GCGameChoreoServices::GetOwner() const {
    GCBaseAnimGraph value((void*)(GetSchemaValue<CHandle<CEntityInstance>>(m_ptr, "CGameChoreoServices", "m_hOwner").Get()));
    return value;
}
void GCGameChoreoServices::SetOwner(GCBaseAnimGraph value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Owner' is not possible.\n");
}
GCScriptedSequence GCGameChoreoServices::GetScriptedSequence() const {
    GCScriptedSequence value((void*)(GetSchemaValue<CHandle<CEntityInstance>>(m_ptr, "CGameChoreoServices", "m_hScriptedSequence").Get()));
    return value;
}
void GCGameChoreoServices::SetScriptedSequence(GCScriptedSequence value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'ScriptedSequence' is not possible.\n");
}
GIChoreoServices GCGameChoreoServices::GetScriptState() const {
    GIChoreoServices value(GetSchemaPtr(m_ptr, "CGameChoreoServices", "m_scriptState"));
    return value;
}
void GCGameChoreoServices::SetScriptState(GIChoreoServices value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'ScriptState' is not possible.\n");
}
GIChoreoServices GCGameChoreoServices::GetChoreoState() const {
    GIChoreoServices value(GetSchemaPtr(m_ptr, "CGameChoreoServices", "m_choreoState"));
    return value;
}
void GCGameChoreoServices::SetChoreoState(GIChoreoServices value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'ChoreoState' is not possible.\n");
}
float GCGameChoreoServices::GetTimeStartedState() const {
    return GetSchemaValue<float>(m_ptr, "CGameChoreoServices", "m_flTimeStartedState");
}
void GCGameChoreoServices::SetTimeStartedState(float value) {
    SetSchemaValue(m_ptr, "CGameChoreoServices", "m_flTimeStartedState", false, value);
}
void* GCGameChoreoServices::GetPtr() {
    return m_ptr;
}
std::string GCGameChoreoServices::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCGameChoreoServices::IsValid() {
    return (m_ptr != nullptr);
}
GIChoreoServices GCGameChoreoServices::GetParent() const {
    GIChoreoServices value(m_ptr);
    return value;
}
void GCGameChoreoServices::SetParent(GIChoreoServices value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCGameChoreoServices(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCGameChoreoServices>("CGameChoreoServices")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Owner", &GCGameChoreoServices::GetOwner, &GCGameChoreoServices::SetOwner)
        .addProperty("ScriptedSequence", &GCGameChoreoServices::GetScriptedSequence, &GCGameChoreoServices::SetScriptedSequence)
        .addProperty("ScriptState", &GCGameChoreoServices::GetScriptState, &GCGameChoreoServices::SetScriptState)
        .addProperty("ChoreoState", &GCGameChoreoServices::GetChoreoState, &GCGameChoreoServices::SetChoreoState)
        .addProperty("TimeStartedState", &GCGameChoreoServices::GetTimeStartedState, &GCGameChoreoServices::SetTimeStartedState)
        .addProperty("Parent", &GCGameChoreoServices::GetParent, &GCGameChoreoServices::SetParent)
        .addFunction("ToPtr", &GCGameChoreoServices::ToPtr)
        .addFunction("IsValid", &GCGameChoreoServices::IsValid)
        .endClass();
}
GCSimpleStopwatch::GCSimpleStopwatch(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCSimpleStopwatch::GCSimpleStopwatch(void *ptr) {
    m_ptr = ptr;
}
void* GCSimpleStopwatch::GetPtr() {
    return m_ptr;
}
std::string GCSimpleStopwatch::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCSimpleStopwatch::IsValid() {
    return (m_ptr != nullptr);
}
GCStopwatchBase GCSimpleStopwatch::GetParent() const {
    GCStopwatchBase value(m_ptr);
    return value;
}
void GCSimpleStopwatch::SetParent(GCStopwatchBase value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCSimpleStopwatch(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCSimpleStopwatch>("CSimpleStopwatch")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCSimpleStopwatch::GetParent, &GCSimpleStopwatch::SetParent)
        .addFunction("ToPtr", &GCSimpleStopwatch::ToPtr)
        .addFunction("IsValid", &GCSimpleStopwatch::IsValid)
        .endClass();
}
GCShatterGlassShard::GCShatterGlassShard(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCShatterGlassShard::GCShatterGlassShard(void *ptr) {
    m_ptr = ptr;
}
uint32_t GCShatterGlassShard::GetShardHandle() const {
    return GetSchemaValue<uint32_t>(m_ptr, "CShatterGlassShard", "m_hShardHandle");
}
void GCShatterGlassShard::SetShardHandle(uint32_t value) {
    SetSchemaValue(m_ptr, "CShatterGlassShard", "m_hShardHandle", false, value);
}
std::vector<Vector2D> GCShatterGlassShard::GetPanelVertices() const {
    CUtlVector<Vector2D>* vec = GetSchemaValue<CUtlVector<Vector2D>*>(m_ptr, "CShatterGlassShard", "m_vecPanelVertices"); std::vector<Vector2D> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCShatterGlassShard::SetPanelVertices(std::vector<Vector2D> value) {
    SetSchemaValueCUtlVector<Vector2D>(m_ptr, "CShatterGlassShard", "m_vecPanelVertices", false, value);
}
Vector2D GCShatterGlassShard::GetLocalPanelSpaceOrigin() const {
    return GetSchemaValue<Vector2D>(m_ptr, "CShatterGlassShard", "m_vLocalPanelSpaceOrigin");
}
void GCShatterGlassShard::SetLocalPanelSpaceOrigin(Vector2D value) {
    SetSchemaValue(m_ptr, "CShatterGlassShard", "m_vLocalPanelSpaceOrigin", false, value);
}
GCShatterGlassShardPhysics GCShatterGlassShard::GetPhysicsEntity() const {
    GCShatterGlassShardPhysics value((void*)(GetSchemaValue<CHandle<CEntityInstance>>(m_ptr, "CShatterGlassShard", "m_hPhysicsEntity").Get()));
    return value;
}
void GCShatterGlassShard::SetPhysicsEntity(GCShatterGlassShardPhysics value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'PhysicsEntity' is not possible.\n");
}
GCFuncShatterglass GCShatterGlassShard::GetParentPanel() const {
    GCFuncShatterglass value((void*)(GetSchemaValue<CHandle<CEntityInstance>>(m_ptr, "CShatterGlassShard", "m_hParentPanel").Get()));
    return value;
}
void GCShatterGlassShard::SetParentPanel(GCFuncShatterglass value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'ParentPanel' is not possible.\n");
}
uint32_t GCShatterGlassShard::GetParentShard() const {
    return GetSchemaValue<uint32_t>(m_ptr, "CShatterGlassShard", "m_hParentShard");
}
void GCShatterGlassShard::SetParentShard(uint32_t value) {
    SetSchemaValue(m_ptr, "CShatterGlassShard", "m_hParentShard", false, value);
}
uint64_t GCShatterGlassShard::GetShatterStressType() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CShatterGlassShard", "m_ShatterStressType");
}
void GCShatterGlassShard::SetShatterStressType(uint64_t value) {
    SetSchemaValue(m_ptr, "CShatterGlassShard", "m_ShatterStressType", false, value);
}
Vector GCShatterGlassShard::GetStressVelocity() const {
    return GetSchemaValue<Vector>(m_ptr, "CShatterGlassShard", "m_vecStressVelocity");
}
void GCShatterGlassShard::SetStressVelocity(Vector value) {
    SetSchemaValue(m_ptr, "CShatterGlassShard", "m_vecStressVelocity", false, value);
}
bool GCShatterGlassShard::GetCreatedModel() const {
    return GetSchemaValue<bool>(m_ptr, "CShatterGlassShard", "m_bCreatedModel");
}
void GCShatterGlassShard::SetCreatedModel(bool value) {
    SetSchemaValue(m_ptr, "CShatterGlassShard", "m_bCreatedModel", false, value);
}
float GCShatterGlassShard::GetLongestEdge() const {
    return GetSchemaValue<float>(m_ptr, "CShatterGlassShard", "m_flLongestEdge");
}
void GCShatterGlassShard::SetLongestEdge(float value) {
    SetSchemaValue(m_ptr, "CShatterGlassShard", "m_flLongestEdge", false, value);
}
float GCShatterGlassShard::GetShortestEdge() const {
    return GetSchemaValue<float>(m_ptr, "CShatterGlassShard", "m_flShortestEdge");
}
void GCShatterGlassShard::SetShortestEdge(float value) {
    SetSchemaValue(m_ptr, "CShatterGlassShard", "m_flShortestEdge", false, value);
}
float GCShatterGlassShard::GetLongestAcross() const {
    return GetSchemaValue<float>(m_ptr, "CShatterGlassShard", "m_flLongestAcross");
}
void GCShatterGlassShard::SetLongestAcross(float value) {
    SetSchemaValue(m_ptr, "CShatterGlassShard", "m_flLongestAcross", false, value);
}
float GCShatterGlassShard::GetShortestAcross() const {
    return GetSchemaValue<float>(m_ptr, "CShatterGlassShard", "m_flShortestAcross");
}
void GCShatterGlassShard::SetShortestAcross(float value) {
    SetSchemaValue(m_ptr, "CShatterGlassShard", "m_flShortestAcross", false, value);
}
float GCShatterGlassShard::GetSumOfAllEdges() const {
    return GetSchemaValue<float>(m_ptr, "CShatterGlassShard", "m_flSumOfAllEdges");
}
void GCShatterGlassShard::SetSumOfAllEdges(float value) {
    SetSchemaValue(m_ptr, "CShatterGlassShard", "m_flSumOfAllEdges", false, value);
}
float GCShatterGlassShard::GetArea() const {
    return GetSchemaValue<float>(m_ptr, "CShatterGlassShard", "m_flArea");
}
void GCShatterGlassShard::SetArea(float value) {
    SetSchemaValue(m_ptr, "CShatterGlassShard", "m_flArea", false, value);
}
uint64_t GCShatterGlassShard::GetOnFrameEdge() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CShatterGlassShard", "m_nOnFrameEdge");
}
void GCShatterGlassShard::SetOnFrameEdge(uint64_t value) {
    SetSchemaValue(m_ptr, "CShatterGlassShard", "m_nOnFrameEdge", false, value);
}
int32_t GCShatterGlassShard::GetParentPanelsNthShard() const {
    return GetSchemaValue<int32_t>(m_ptr, "CShatterGlassShard", "m_nParentPanelsNthShard");
}
void GCShatterGlassShard::SetParentPanelsNthShard(int32_t value) {
    SetSchemaValue(m_ptr, "CShatterGlassShard", "m_nParentPanelsNthShard", false, value);
}
int32_t GCShatterGlassShard::GetSubShardGeneration() const {
    return GetSchemaValue<int32_t>(m_ptr, "CShatterGlassShard", "m_nSubShardGeneration");
}
void GCShatterGlassShard::SetSubShardGeneration(int32_t value) {
    SetSchemaValue(m_ptr, "CShatterGlassShard", "m_nSubShardGeneration", false, value);
}
Vector2D GCShatterGlassShard::GetAverageVertPosition() const {
    return GetSchemaValue<Vector2D>(m_ptr, "CShatterGlassShard", "m_vecAverageVertPosition");
}
void GCShatterGlassShard::SetAverageVertPosition(Vector2D value) {
    SetSchemaValue(m_ptr, "CShatterGlassShard", "m_vecAverageVertPosition", false, value);
}
bool GCShatterGlassShard::GetAverageVertPositionIsValid() const {
    return GetSchemaValue<bool>(m_ptr, "CShatterGlassShard", "m_bAverageVertPositionIsValid");
}
void GCShatterGlassShard::SetAverageVertPositionIsValid(bool value) {
    SetSchemaValue(m_ptr, "CShatterGlassShard", "m_bAverageVertPositionIsValid", false, value);
}
Vector2D GCShatterGlassShard::GetPanelSpaceStressPositionA() const {
    return GetSchemaValue<Vector2D>(m_ptr, "CShatterGlassShard", "m_vecPanelSpaceStressPositionA");
}
void GCShatterGlassShard::SetPanelSpaceStressPositionA(Vector2D value) {
    SetSchemaValue(m_ptr, "CShatterGlassShard", "m_vecPanelSpaceStressPositionA", false, value);
}
Vector2D GCShatterGlassShard::GetPanelSpaceStressPositionB() const {
    return GetSchemaValue<Vector2D>(m_ptr, "CShatterGlassShard", "m_vecPanelSpaceStressPositionB");
}
void GCShatterGlassShard::SetPanelSpaceStressPositionB(Vector2D value) {
    SetSchemaValue(m_ptr, "CShatterGlassShard", "m_vecPanelSpaceStressPositionB", false, value);
}
bool GCShatterGlassShard::GetStressPositionAIsValid() const {
    return GetSchemaValue<bool>(m_ptr, "CShatterGlassShard", "m_bStressPositionAIsValid");
}
void GCShatterGlassShard::SetStressPositionAIsValid(bool value) {
    SetSchemaValue(m_ptr, "CShatterGlassShard", "m_bStressPositionAIsValid", false, value);
}
bool GCShatterGlassShard::GetStressPositionBIsValid() const {
    return GetSchemaValue<bool>(m_ptr, "CShatterGlassShard", "m_bStressPositionBIsValid");
}
void GCShatterGlassShard::SetStressPositionBIsValid(bool value) {
    SetSchemaValue(m_ptr, "CShatterGlassShard", "m_bStressPositionBIsValid", false, value);
}
bool GCShatterGlassShard::GetFlaggedForRemoval() const {
    return GetSchemaValue<bool>(m_ptr, "CShatterGlassShard", "m_bFlaggedForRemoval");
}
void GCShatterGlassShard::SetFlaggedForRemoval(bool value) {
    SetSchemaValue(m_ptr, "CShatterGlassShard", "m_bFlaggedForRemoval", false, value);
}
float GCShatterGlassShard::GetPhysicsEntitySpawnedAtTime() const {
    return GetSchemaValue<float>(m_ptr, "CShatterGlassShard", "m_flPhysicsEntitySpawnedAtTime");
}
void GCShatterGlassShard::SetPhysicsEntitySpawnedAtTime(float value) {
    SetSchemaValue(m_ptr, "CShatterGlassShard", "m_flPhysicsEntitySpawnedAtTime", false, value);
}
bool GCShatterGlassShard::GetShatterRateLimited() const {
    return GetSchemaValue<bool>(m_ptr, "CShatterGlassShard", "m_bShatterRateLimited");
}
void GCShatterGlassShard::SetShatterRateLimited(bool value) {
    SetSchemaValue(m_ptr, "CShatterGlassShard", "m_bShatterRateLimited", false, value);
}
GCBaseEntity GCShatterGlassShard::GetEntityHittingMe() const {
    GCBaseEntity value((void*)(GetSchemaValue<CHandle<CEntityInstance>>(m_ptr, "CShatterGlassShard", "m_hEntityHittingMe").Get()));
    return value;
}
void GCShatterGlassShard::SetEntityHittingMe(GCBaseEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'EntityHittingMe' is not possible.\n");
}
std::vector<uint32> GCShatterGlassShard::GetNeighbors() const {
    CUtlVector<uint32>* vec = GetSchemaValue<CUtlVector<uint32>*>(m_ptr, "CShatterGlassShard", "m_vecNeighbors"); std::vector<uint32> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCShatterGlassShard::SetNeighbors(std::vector<uint32> value) {
    SetSchemaValueCUtlVector<uint32>(m_ptr, "CShatterGlassShard", "m_vecNeighbors", false, value);
}
void* GCShatterGlassShard::GetPtr() {
    return m_ptr;
}
std::string GCShatterGlassShard::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCShatterGlassShard::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCShatterGlassShard(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCShatterGlassShard>("CShatterGlassShard")
        .addConstructor<void (*)(std::string)>()
        .addProperty("ShardHandle", &GCShatterGlassShard::GetShardHandle, &GCShatterGlassShard::SetShardHandle)
        .addProperty("PanelVertices", &GCShatterGlassShard::GetPanelVertices, &GCShatterGlassShard::SetPanelVertices)
        .addProperty("LocalPanelSpaceOrigin", &GCShatterGlassShard::GetLocalPanelSpaceOrigin, &GCShatterGlassShard::SetLocalPanelSpaceOrigin)
        .addProperty("PhysicsEntity", &GCShatterGlassShard::GetPhysicsEntity, &GCShatterGlassShard::SetPhysicsEntity)
        .addProperty("ParentPanel", &GCShatterGlassShard::GetParentPanel, &GCShatterGlassShard::SetParentPanel)
        .addProperty("ParentShard", &GCShatterGlassShard::GetParentShard, &GCShatterGlassShard::SetParentShard)
        .addProperty("ShatterStressType", &GCShatterGlassShard::GetShatterStressType, &GCShatterGlassShard::SetShatterStressType)
        .addProperty("StressVelocity", &GCShatterGlassShard::GetStressVelocity, &GCShatterGlassShard::SetStressVelocity)
        .addProperty("CreatedModel", &GCShatterGlassShard::GetCreatedModel, &GCShatterGlassShard::SetCreatedModel)
        .addProperty("LongestEdge", &GCShatterGlassShard::GetLongestEdge, &GCShatterGlassShard::SetLongestEdge)
        .addProperty("ShortestEdge", &GCShatterGlassShard::GetShortestEdge, &GCShatterGlassShard::SetShortestEdge)
        .addProperty("LongestAcross", &GCShatterGlassShard::GetLongestAcross, &GCShatterGlassShard::SetLongestAcross)
        .addProperty("ShortestAcross", &GCShatterGlassShard::GetShortestAcross, &GCShatterGlassShard::SetShortestAcross)
        .addProperty("SumOfAllEdges", &GCShatterGlassShard::GetSumOfAllEdges, &GCShatterGlassShard::SetSumOfAllEdges)
        .addProperty("Area", &GCShatterGlassShard::GetArea, &GCShatterGlassShard::SetArea)
        .addProperty("OnFrameEdge", &GCShatterGlassShard::GetOnFrameEdge, &GCShatterGlassShard::SetOnFrameEdge)
        .addProperty("ParentPanelsNthShard", &GCShatterGlassShard::GetParentPanelsNthShard, &GCShatterGlassShard::SetParentPanelsNthShard)
        .addProperty("SubShardGeneration", &GCShatterGlassShard::GetSubShardGeneration, &GCShatterGlassShard::SetSubShardGeneration)
        .addProperty("AverageVertPosition", &GCShatterGlassShard::GetAverageVertPosition, &GCShatterGlassShard::SetAverageVertPosition)
        .addProperty("AverageVertPositionIsValid", &GCShatterGlassShard::GetAverageVertPositionIsValid, &GCShatterGlassShard::SetAverageVertPositionIsValid)
        .addProperty("PanelSpaceStressPositionA", &GCShatterGlassShard::GetPanelSpaceStressPositionA, &GCShatterGlassShard::SetPanelSpaceStressPositionA)
        .addProperty("PanelSpaceStressPositionB", &GCShatterGlassShard::GetPanelSpaceStressPositionB, &GCShatterGlassShard::SetPanelSpaceStressPositionB)
        .addProperty("StressPositionAIsValid", &GCShatterGlassShard::GetStressPositionAIsValid, &GCShatterGlassShard::SetStressPositionAIsValid)
        .addProperty("StressPositionBIsValid", &GCShatterGlassShard::GetStressPositionBIsValid, &GCShatterGlassShard::SetStressPositionBIsValid)
        .addProperty("FlaggedForRemoval", &GCShatterGlassShard::GetFlaggedForRemoval, &GCShatterGlassShard::SetFlaggedForRemoval)
        .addProperty("PhysicsEntitySpawnedAtTime", &GCShatterGlassShard::GetPhysicsEntitySpawnedAtTime, &GCShatterGlassShard::SetPhysicsEntitySpawnedAtTime)
        .addProperty("ShatterRateLimited", &GCShatterGlassShard::GetShatterRateLimited, &GCShatterGlassShard::SetShatterRateLimited)
        .addProperty("EntityHittingMe", &GCShatterGlassShard::GetEntityHittingMe, &GCShatterGlassShard::SetEntityHittingMe)
        .addProperty("Neighbors", &GCShatterGlassShard::GetNeighbors, &GCShatterGlassShard::SetNeighbors)
        .addFunction("ToPtr", &GCShatterGlassShard::ToPtr)
        .addFunction("IsValid", &GCShatterGlassShard::IsValid)
        .endClass();
}
GCommandToolCommand_t::GCommandToolCommand_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCommandToolCommand_t::GCommandToolCommand_t(void *ptr) {
    m_ptr = ptr;
}
bool GCommandToolCommand_t::GetEnabled() const {
    return GetSchemaValue<bool>(m_ptr, "CommandToolCommand_t", "m_bEnabled");
}
void GCommandToolCommand_t::SetEnabled(bool value) {
    SetSchemaValue(m_ptr, "CommandToolCommand_t", "m_bEnabled", true, value);
}
bool GCommandToolCommand_t::GetOpened() const {
    return GetSchemaValue<bool>(m_ptr, "CommandToolCommand_t", "m_bOpened");
}
void GCommandToolCommand_t::SetOpened(bool value) {
    SetSchemaValue(m_ptr, "CommandToolCommand_t", "m_bOpened", true, value);
}
uint32_t GCommandToolCommand_t::GetInternalId() const {
    return GetSchemaValue<uint32_t>(m_ptr, "CommandToolCommand_t", "m_InternalId");
}
void GCommandToolCommand_t::SetInternalId(uint32_t value) {
    SetSchemaValue(m_ptr, "CommandToolCommand_t", "m_InternalId", true, value);
}
std::string GCommandToolCommand_t::GetShortName() const {
    return GetSchemaValue<CUtlString>(m_ptr, "CommandToolCommand_t", "m_ShortName").Get();
}
void GCommandToolCommand_t::SetShortName(std::string value) {
    SetSchemaValue(m_ptr, "CommandToolCommand_t", "m_ShortName", true, CUtlString(value.c_str()));
}
uint64_t GCommandToolCommand_t::GetExecMode() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CommandToolCommand_t", "m_ExecMode");
}
void GCommandToolCommand_t::SetExecMode(uint64_t value) {
    SetSchemaValue(m_ptr, "CommandToolCommand_t", "m_ExecMode", true, value);
}
std::string GCommandToolCommand_t::GetSpawnGroup() const {
    return GetSchemaValue<CUtlString>(m_ptr, "CommandToolCommand_t", "m_SpawnGroup").Get();
}
void GCommandToolCommand_t::SetSpawnGroup(std::string value) {
    SetSchemaValue(m_ptr, "CommandToolCommand_t", "m_SpawnGroup", true, CUtlString(value.c_str()));
}
float GCommandToolCommand_t::GetPeriodicExecDelay() const {
    return GetSchemaValue<float>(m_ptr, "CommandToolCommand_t", "m_PeriodicExecDelay");
}
void GCommandToolCommand_t::SetPeriodicExecDelay(float value) {
    SetSchemaValue(m_ptr, "CommandToolCommand_t", "m_PeriodicExecDelay", true, value);
}
uint64_t GCommandToolCommand_t::GetSpecType() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CommandToolCommand_t", "m_SpecType");
}
void GCommandToolCommand_t::SetSpecType(uint64_t value) {
    SetSchemaValue(m_ptr, "CommandToolCommand_t", "m_SpecType", true, value);
}
std::string GCommandToolCommand_t::GetEntitySpec() const {
    return GetSchemaValue<CUtlString>(m_ptr, "CommandToolCommand_t", "m_EntitySpec").Get();
}
void GCommandToolCommand_t::SetEntitySpec(std::string value) {
    SetSchemaValue(m_ptr, "CommandToolCommand_t", "m_EntitySpec", true, CUtlString(value.c_str()));
}
std::string GCommandToolCommand_t::GetCommands() const {
    return GetSchemaValue<CUtlString>(m_ptr, "CommandToolCommand_t", "m_Commands").Get();
}
void GCommandToolCommand_t::SetCommands(std::string value) {
    SetSchemaValue(m_ptr, "CommandToolCommand_t", "m_Commands", true, CUtlString(value.c_str()));
}
uint64_t GCommandToolCommand_t::GetSetDebugBits() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CommandToolCommand_t", "m_SetDebugBits");
}
void GCommandToolCommand_t::SetSetDebugBits(uint64_t value) {
    SetSchemaValue(m_ptr, "CommandToolCommand_t", "m_SetDebugBits", true, value);
}
uint64_t GCommandToolCommand_t::GetClearDebugBits() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CommandToolCommand_t", "m_ClearDebugBits");
}
void GCommandToolCommand_t::SetClearDebugBits(uint64_t value) {
    SetSchemaValue(m_ptr, "CommandToolCommand_t", "m_ClearDebugBits", true, value);
}
void* GCommandToolCommand_t::GetPtr() {
    return m_ptr;
}
std::string GCommandToolCommand_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCommandToolCommand_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCommandToolCommand_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCommandToolCommand_t>("CommandToolCommand_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Enabled", &GCommandToolCommand_t::GetEnabled, &GCommandToolCommand_t::SetEnabled)
        .addProperty("Opened", &GCommandToolCommand_t::GetOpened, &GCommandToolCommand_t::SetOpened)
        .addProperty("InternalId", &GCommandToolCommand_t::GetInternalId, &GCommandToolCommand_t::SetInternalId)
        .addProperty("ShortName", &GCommandToolCommand_t::GetShortName, &GCommandToolCommand_t::SetShortName)
        .addProperty("ExecMode", &GCommandToolCommand_t::GetExecMode, &GCommandToolCommand_t::SetExecMode)
        .addProperty("SpawnGroup", &GCommandToolCommand_t::GetSpawnGroup, &GCommandToolCommand_t::SetSpawnGroup)
        .addProperty("PeriodicExecDelay", &GCommandToolCommand_t::GetPeriodicExecDelay, &GCommandToolCommand_t::SetPeriodicExecDelay)
        .addProperty("SpecType", &GCommandToolCommand_t::GetSpecType, &GCommandToolCommand_t::SetSpecType)
        .addProperty("EntitySpec", &GCommandToolCommand_t::GetEntitySpec, &GCommandToolCommand_t::SetEntitySpec)
        .addProperty("Commands", &GCommandToolCommand_t::GetCommands, &GCommandToolCommand_t::SetCommands)
        .addProperty("SetDebugBits", &GCommandToolCommand_t::GetSetDebugBits, &GCommandToolCommand_t::SetSetDebugBits)
        .addProperty("ClearDebugBits", &GCommandToolCommand_t::GetClearDebugBits, &GCommandToolCommand_t::SetClearDebugBits)
        .addFunction("ToPtr", &GCommandToolCommand_t::ToPtr)
        .addFunction("IsValid", &GCommandToolCommand_t::IsValid)
        .endClass();
}
Gragdollelement_t::Gragdollelement_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
Gragdollelement_t::Gragdollelement_t(void *ptr) {
    m_ptr = ptr;
}
Vector Gragdollelement_t::GetOriginParentSpace() const {
    return GetSchemaValue<Vector>(m_ptr, "ragdollelement_t", "originParentSpace");
}
void Gragdollelement_t::SetOriginParentSpace(Vector value) {
    SetSchemaValue(m_ptr, "ragdollelement_t", "originParentSpace", true, value);
}
int32_t Gragdollelement_t::GetParentIndex() const {
    return GetSchemaValue<int32_t>(m_ptr, "ragdollelement_t", "parentIndex");
}
void Gragdollelement_t::SetParentIndex(int32_t value) {
    SetSchemaValue(m_ptr, "ragdollelement_t", "parentIndex", true, value);
}
float Gragdollelement_t::GetRadius() const {
    return GetSchemaValue<float>(m_ptr, "ragdollelement_t", "m_flRadius");
}
void Gragdollelement_t::SetRadius(float value) {
    SetSchemaValue(m_ptr, "ragdollelement_t", "m_flRadius", true, value);
}
void* Gragdollelement_t::GetPtr() {
    return m_ptr;
}
std::string Gragdollelement_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool Gragdollelement_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassragdollelement_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<Gragdollelement_t>("ragdollelement_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("OriginParentSpace", &Gragdollelement_t::GetOriginParentSpace, &Gragdollelement_t::SetOriginParentSpace)
        .addProperty("ParentIndex", &Gragdollelement_t::GetParentIndex, &Gragdollelement_t::SetParentIndex)
        .addProperty("Radius", &Gragdollelement_t::GetRadius, &Gragdollelement_t::SetRadius)
        .addFunction("ToPtr", &Gragdollelement_t::ToPtr)
        .addFunction("IsValid", &Gragdollelement_t::IsValid)
        .endClass();
}
GCBodyComponentBaseModelEntity::GCBodyComponentBaseModelEntity(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCBodyComponentBaseModelEntity::GCBodyComponentBaseModelEntity(void *ptr) {
    m_ptr = ptr;
}
void* GCBodyComponentBaseModelEntity::GetPtr() {
    return m_ptr;
}
std::string GCBodyComponentBaseModelEntity::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCBodyComponentBaseModelEntity::IsValid() {
    return (m_ptr != nullptr);
}
GCBodyComponentSkeletonInstance GCBodyComponentBaseModelEntity::GetParent() const {
    GCBodyComponentSkeletonInstance value(m_ptr);
    return value;
}
void GCBodyComponentBaseModelEntity::SetParent(GCBodyComponentSkeletonInstance value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCBodyComponentBaseModelEntity(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCBodyComponentBaseModelEntity>("CBodyComponentBaseModelEntity")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCBodyComponentBaseModelEntity::GetParent, &GCBodyComponentBaseModelEntity::SetParent)
        .addFunction("ToPtr", &GCBodyComponentBaseModelEntity::ToPtr)
        .addFunction("IsValid", &GCBodyComponentBaseModelEntity::IsValid)
        .endClass();
}
GCNetworkOriginQuantizedVector::GCNetworkOriginQuantizedVector(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCNetworkOriginQuantizedVector::GCNetworkOriginQuantizedVector(void *ptr) {
    m_ptr = ptr;
}
float GCNetworkOriginQuantizedVector::GetX() const {
    return GetSchemaValue<float>(m_ptr, "CNetworkOriginQuantizedVector", "m_vecX");
}
void GCNetworkOriginQuantizedVector::SetX(float value) {
    SetSchemaValue(m_ptr, "CNetworkOriginQuantizedVector", "m_vecX", false, value);
}
float GCNetworkOriginQuantizedVector::GetY() const {
    return GetSchemaValue<float>(m_ptr, "CNetworkOriginQuantizedVector", "m_vecY");
}
void GCNetworkOriginQuantizedVector::SetY(float value) {
    SetSchemaValue(m_ptr, "CNetworkOriginQuantizedVector", "m_vecY", false, value);
}
float GCNetworkOriginQuantizedVector::GetZ() const {
    return GetSchemaValue<float>(m_ptr, "CNetworkOriginQuantizedVector", "m_vecZ");
}
void GCNetworkOriginQuantizedVector::SetZ(float value) {
    SetSchemaValue(m_ptr, "CNetworkOriginQuantizedVector", "m_vecZ", false, value);
}
void* GCNetworkOriginQuantizedVector::GetPtr() {
    return m_ptr;
}
std::string GCNetworkOriginQuantizedVector::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCNetworkOriginQuantizedVector::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCNetworkOriginQuantizedVector(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCNetworkOriginQuantizedVector>("CNetworkOriginQuantizedVector")
        .addConstructor<void (*)(std::string)>()
        .addProperty("X", &GCNetworkOriginQuantizedVector::GetX, &GCNetworkOriginQuantizedVector::SetX)
        .addProperty("Y", &GCNetworkOriginQuantizedVector::GetY, &GCNetworkOriginQuantizedVector::SetY)
        .addProperty("Z", &GCNetworkOriginQuantizedVector::GetZ, &GCNetworkOriginQuantizedVector::SetZ)
        .addFunction("ToPtr", &GCNetworkOriginQuantizedVector::ToPtr)
        .addFunction("IsValid", &GCNetworkOriginQuantizedVector::IsValid)
        .endClass();
}
Gmagnetted_objects_t::Gmagnetted_objects_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
Gmagnetted_objects_t::Gmagnetted_objects_t(void *ptr) {
    m_ptr = ptr;
}
GCBaseEntity Gmagnetted_objects_t::GetEntity() const {
    GCBaseEntity value((void*)(GetSchemaValue<CHandle<CEntityInstance>>(m_ptr, "magnetted_objects_t", "hEntity").Get()));
    return value;
}
void Gmagnetted_objects_t::SetEntity(GCBaseEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Entity' is not possible.\n");
}
void* Gmagnetted_objects_t::GetPtr() {
    return m_ptr;
}
std::string Gmagnetted_objects_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool Gmagnetted_objects_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassmagnetted_objects_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<Gmagnetted_objects_t>("magnetted_objects_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Entity", &Gmagnetted_objects_t::GetEntity, &Gmagnetted_objects_t::SetEntity)
        .addFunction("ToPtr", &Gmagnetted_objects_t::ToPtr)
        .addFunction("IsValid", &Gmagnetted_objects_t::IsValid)
        .endClass();
}
GCHintMessageQueue::GCHintMessageQueue(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCHintMessageQueue::GCHintMessageQueue(void *ptr) {
    m_ptr = ptr;
}
float GCHintMessageQueue::GetTmMessageEnd() const {
    return GetSchemaValue<float>(m_ptr, "CHintMessageQueue", "m_tmMessageEnd");
}
void GCHintMessageQueue::SetTmMessageEnd(float value) {
    SetSchemaValue(m_ptr, "CHintMessageQueue", "m_tmMessageEnd", false, value);
}
GCBasePlayerController GCHintMessageQueue::GetPlayerController() const {
    GCBasePlayerController value(*(void**)GetSchemaPtr(m_ptr, "CHintMessageQueue", "m_pPlayerController"));
    return value;
}
void GCHintMessageQueue::SetPlayerController(GCBasePlayerController value) {
    SetSchemaValue(m_ptr, "CHintMessageQueue","m_pPlayerController", false, (char*)value.GetPtr());
}
void* GCHintMessageQueue::GetPtr() {
    return m_ptr;
}
std::string GCHintMessageQueue::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCHintMessageQueue::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCHintMessageQueue(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCHintMessageQueue>("CHintMessageQueue")
        .addConstructor<void (*)(std::string)>()
        .addProperty("TmMessageEnd", &GCHintMessageQueue::GetTmMessageEnd, &GCHintMessageQueue::SetTmMessageEnd)
        .addProperty("PlayerController", &GCHintMessageQueue::GetPlayerController, &GCHintMessageQueue::SetPlayerController)
        .addFunction("ToPtr", &GCHintMessageQueue::ToPtr)
        .addFunction("IsValid", &GCHintMessageQueue::IsValid)
        .endClass();
}
GCSkillInt::GCSkillInt(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCSkillInt::GCSkillInt(void *ptr) {
    m_ptr = ptr;
}
std::vector<int32_t> GCSkillInt::GetValue() const {
    int32_t* outValue = (int32_t*)GetSchemaPtr(m_ptr, "CSkillInt", "m_pValue"); std::vector<int32_t> ret; for(int i = 0; i < 4; i++) { ret.push_back(outValue[i]); } return ret;
}
void GCSkillInt::SetValue(std::vector<int32_t> value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Value' is not possible.\n");
}
void* GCSkillInt::GetPtr() {
    return m_ptr;
}
std::string GCSkillInt::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCSkillInt::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCSkillInt(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCSkillInt>("CSkillInt")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Value", &GCSkillInt::GetValue, &GCSkillInt::SetValue)
        .addFunction("ToPtr", &GCSkillInt::ToPtr)
        .addFunction("IsValid", &GCSkillInt::IsValid)
        .endClass();
}
Gthinkfunc_t::Gthinkfunc_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
Gthinkfunc_t::Gthinkfunc_t(void *ptr) {
    m_ptr = ptr;
}
uint32_t Gthinkfunc_t::GetContext() const {
    return GetSchemaValue<CUtlStringToken>(m_ptr, "thinkfunc_t", "m_nContext").m_nHashCode;
}
void Gthinkfunc_t::SetContext(uint32_t value) {
    SetSchemaValue(m_ptr, "thinkfunc_t", "m_nContext", true, CUtlStringToken(value));
}
int32 Gthinkfunc_t::GetNextThinkTick() const {
    return GetSchemaValue<int32>(m_ptr, "thinkfunc_t", "m_nNextThinkTick");
}
void Gthinkfunc_t::SetNextThinkTick(int32 value) {
    SetSchemaValue(m_ptr, "thinkfunc_t", "m_nNextThinkTick", true, value);
}
int32 Gthinkfunc_t::GetLastThinkTick() const {
    return GetSchemaValue<int32>(m_ptr, "thinkfunc_t", "m_nLastThinkTick");
}
void Gthinkfunc_t::SetLastThinkTick(int32 value) {
    SetSchemaValue(m_ptr, "thinkfunc_t", "m_nLastThinkTick", true, value);
}
void* Gthinkfunc_t::GetPtr() {
    return m_ptr;
}
std::string Gthinkfunc_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool Gthinkfunc_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassthinkfunc_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<Gthinkfunc_t>("thinkfunc_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Context", &Gthinkfunc_t::GetContext, &Gthinkfunc_t::SetContext)
        .addProperty("NextThinkTick", &Gthinkfunc_t::GetNextThinkTick, &Gthinkfunc_t::SetNextThinkTick)
        .addProperty("LastThinkTick", &Gthinkfunc_t::GetLastThinkTick, &Gthinkfunc_t::SetLastThinkTick)
        .addFunction("ToPtr", &Gthinkfunc_t::ToPtr)
        .addFunction("IsValid", &Gthinkfunc_t::IsValid)
        .endClass();
}
GCNavHullPresetVData::GCNavHullPresetVData(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCNavHullPresetVData::GCNavHullPresetVData(void *ptr) {
    m_ptr = ptr;
}
std::vector<CUtlString> GCNavHullPresetVData::GetNavHulls() const {
    CUtlVector<CUtlString>* vec = GetSchemaValue<CUtlVector<CUtlString>*>(m_ptr, "CNavHullPresetVData", "m_vecNavHulls"); std::vector<CUtlString> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCNavHullPresetVData::SetNavHulls(std::vector<CUtlString> value) {
    SetSchemaValueCUtlVector<CUtlString>(m_ptr, "CNavHullPresetVData", "m_vecNavHulls", false, value);
}
void* GCNavHullPresetVData::GetPtr() {
    return m_ptr;
}
std::string GCNavHullPresetVData::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCNavHullPresetVData::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCNavHullPresetVData(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCNavHullPresetVData>("CNavHullPresetVData")
        .addConstructor<void (*)(std::string)>()
        .addProperty("NavHulls", &GCNavHullPresetVData::GetNavHulls, &GCNavHullPresetVData::SetNavHulls)
        .addFunction("ToPtr", &GCNavHullPresetVData::ToPtr)
        .addFunction("IsValid", &GCNavHullPresetVData::IsValid)
        .endClass();
}
GCBasePlayerVData::GCBasePlayerVData(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCBasePlayerVData::GCBasePlayerVData(void *ptr) {
    m_ptr = ptr;
}
GCSkillFloat GCBasePlayerVData::GetHeadDamageMultiplier() const {
    GCSkillFloat value(GetSchemaPtr(m_ptr, "CBasePlayerVData", "m_flHeadDamageMultiplier"));
    return value;
}
void GCBasePlayerVData::SetHeadDamageMultiplier(GCSkillFloat value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'HeadDamageMultiplier' is not possible.\n");
}
GCSkillFloat GCBasePlayerVData::GetChestDamageMultiplier() const {
    GCSkillFloat value(GetSchemaPtr(m_ptr, "CBasePlayerVData", "m_flChestDamageMultiplier"));
    return value;
}
void GCBasePlayerVData::SetChestDamageMultiplier(GCSkillFloat value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'ChestDamageMultiplier' is not possible.\n");
}
GCSkillFloat GCBasePlayerVData::GetStomachDamageMultiplier() const {
    GCSkillFloat value(GetSchemaPtr(m_ptr, "CBasePlayerVData", "m_flStomachDamageMultiplier"));
    return value;
}
void GCBasePlayerVData::SetStomachDamageMultiplier(GCSkillFloat value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'StomachDamageMultiplier' is not possible.\n");
}
GCSkillFloat GCBasePlayerVData::GetArmDamageMultiplier() const {
    GCSkillFloat value(GetSchemaPtr(m_ptr, "CBasePlayerVData", "m_flArmDamageMultiplier"));
    return value;
}
void GCBasePlayerVData::SetArmDamageMultiplier(GCSkillFloat value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'ArmDamageMultiplier' is not possible.\n");
}
GCSkillFloat GCBasePlayerVData::GetLegDamageMultiplier() const {
    GCSkillFloat value(GetSchemaPtr(m_ptr, "CBasePlayerVData", "m_flLegDamageMultiplier"));
    return value;
}
void GCBasePlayerVData::SetLegDamageMultiplier(GCSkillFloat value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'LegDamageMultiplier' is not possible.\n");
}
float GCBasePlayerVData::GetHoldBreathTime() const {
    return GetSchemaValue<float>(m_ptr, "CBasePlayerVData", "m_flHoldBreathTime");
}
void GCBasePlayerVData::SetHoldBreathTime(float value) {
    SetSchemaValue(m_ptr, "CBasePlayerVData", "m_flHoldBreathTime", false, value);
}
float GCBasePlayerVData::GetDrowningDamageInterval() const {
    return GetSchemaValue<float>(m_ptr, "CBasePlayerVData", "m_flDrowningDamageInterval");
}
void GCBasePlayerVData::SetDrowningDamageInterval(float value) {
    SetSchemaValue(m_ptr, "CBasePlayerVData", "m_flDrowningDamageInterval", false, value);
}
int32_t GCBasePlayerVData::GetDrowningDamageInitial() const {
    return GetSchemaValue<int32_t>(m_ptr, "CBasePlayerVData", "m_nDrowningDamageInitial");
}
void GCBasePlayerVData::SetDrowningDamageInitial(int32_t value) {
    SetSchemaValue(m_ptr, "CBasePlayerVData", "m_nDrowningDamageInitial", false, value);
}
int32_t GCBasePlayerVData::GetDrowningDamageMax() const {
    return GetSchemaValue<int32_t>(m_ptr, "CBasePlayerVData", "m_nDrowningDamageMax");
}
void GCBasePlayerVData::SetDrowningDamageMax(int32_t value) {
    SetSchemaValue(m_ptr, "CBasePlayerVData", "m_nDrowningDamageMax", false, value);
}
int32_t GCBasePlayerVData::GetWaterSpeed() const {
    return GetSchemaValue<int32_t>(m_ptr, "CBasePlayerVData", "m_nWaterSpeed");
}
void GCBasePlayerVData::SetWaterSpeed(int32_t value) {
    SetSchemaValue(m_ptr, "CBasePlayerVData", "m_nWaterSpeed", false, value);
}
float GCBasePlayerVData::GetUseRange() const {
    return GetSchemaValue<float>(m_ptr, "CBasePlayerVData", "m_flUseRange");
}
void GCBasePlayerVData::SetUseRange(float value) {
    SetSchemaValue(m_ptr, "CBasePlayerVData", "m_flUseRange", false, value);
}
float GCBasePlayerVData::GetUseAngleTolerance() const {
    return GetSchemaValue<float>(m_ptr, "CBasePlayerVData", "m_flUseAngleTolerance");
}
void GCBasePlayerVData::SetUseAngleTolerance(float value) {
    SetSchemaValue(m_ptr, "CBasePlayerVData", "m_flUseAngleTolerance", false, value);
}
float GCBasePlayerVData::GetCrouchTime() const {
    return GetSchemaValue<float>(m_ptr, "CBasePlayerVData", "m_flCrouchTime");
}
void GCBasePlayerVData::SetCrouchTime(float value) {
    SetSchemaValue(m_ptr, "CBasePlayerVData", "m_flCrouchTime", false, value);
}
void* GCBasePlayerVData::GetPtr() {
    return m_ptr;
}
std::string GCBasePlayerVData::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCBasePlayerVData::IsValid() {
    return (m_ptr != nullptr);
}
GCEntitySubclassVDataBase GCBasePlayerVData::GetParent() const {
    GCEntitySubclassVDataBase value(m_ptr);
    return value;
}
void GCBasePlayerVData::SetParent(GCEntitySubclassVDataBase value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCBasePlayerVData(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCBasePlayerVData>("CBasePlayerVData")
        .addConstructor<void (*)(std::string)>()
        .addProperty("HeadDamageMultiplier", &GCBasePlayerVData::GetHeadDamageMultiplier, &GCBasePlayerVData::SetHeadDamageMultiplier)
        .addProperty("ChestDamageMultiplier", &GCBasePlayerVData::GetChestDamageMultiplier, &GCBasePlayerVData::SetChestDamageMultiplier)
        .addProperty("StomachDamageMultiplier", &GCBasePlayerVData::GetStomachDamageMultiplier, &GCBasePlayerVData::SetStomachDamageMultiplier)
        .addProperty("ArmDamageMultiplier", &GCBasePlayerVData::GetArmDamageMultiplier, &GCBasePlayerVData::SetArmDamageMultiplier)
        .addProperty("LegDamageMultiplier", &GCBasePlayerVData::GetLegDamageMultiplier, &GCBasePlayerVData::SetLegDamageMultiplier)
        .addProperty("HoldBreathTime", &GCBasePlayerVData::GetHoldBreathTime, &GCBasePlayerVData::SetHoldBreathTime)
        .addProperty("DrowningDamageInterval", &GCBasePlayerVData::GetDrowningDamageInterval, &GCBasePlayerVData::SetDrowningDamageInterval)
        .addProperty("DrowningDamageInitial", &GCBasePlayerVData::GetDrowningDamageInitial, &GCBasePlayerVData::SetDrowningDamageInitial)
        .addProperty("DrowningDamageMax", &GCBasePlayerVData::GetDrowningDamageMax, &GCBasePlayerVData::SetDrowningDamageMax)
        .addProperty("WaterSpeed", &GCBasePlayerVData::GetWaterSpeed, &GCBasePlayerVData::SetWaterSpeed)
        .addProperty("UseRange", &GCBasePlayerVData::GetUseRange, &GCBasePlayerVData::SetUseRange)
        .addProperty("UseAngleTolerance", &GCBasePlayerVData::GetUseAngleTolerance, &GCBasePlayerVData::SetUseAngleTolerance)
        .addProperty("CrouchTime", &GCBasePlayerVData::GetCrouchTime, &GCBasePlayerVData::SetCrouchTime)
        .addProperty("Parent", &GCBasePlayerVData::GetParent, &GCBasePlayerVData::SetParent)
        .addFunction("ToPtr", &GCBasePlayerVData::ToPtr)
        .addFunction("IsValid", &GCBasePlayerVData::IsValid)
        .endClass();
}
GCSceneEventInfo::GCSceneEventInfo(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCSceneEventInfo::GCSceneEventInfo(void *ptr) {
    m_ptr = ptr;
}
int32_t GCSceneEventInfo::GetLayer() const {
    return GetSchemaValue<int32_t>(m_ptr, "CSceneEventInfo", "m_iLayer");
}
void GCSceneEventInfo::SetLayer(int32_t value) {
    SetSchemaValue(m_ptr, "CSceneEventInfo", "m_iLayer", false, value);
}
int32_t GCSceneEventInfo::GetPriority() const {
    return GetSchemaValue<int32_t>(m_ptr, "CSceneEventInfo", "m_iPriority");
}
void GCSceneEventInfo::SetPriority(int32_t value) {
    SetSchemaValue(m_ptr, "CSceneEventInfo", "m_iPriority", false, value);
}
float GCSceneEventInfo::GetWeight() const {
    return GetSchemaValue<float>(m_ptr, "CSceneEventInfo", "m_flWeight");
}
void GCSceneEventInfo::SetWeight(float value) {
    SetSchemaValue(m_ptr, "CSceneEventInfo", "m_flWeight", false, value);
}
bool GCSceneEventInfo::GetHasArrived() const {
    return GetSchemaValue<bool>(m_ptr, "CSceneEventInfo", "m_bHasArrived");
}
void GCSceneEventInfo::SetHasArrived(bool value) {
    SetSchemaValue(m_ptr, "CSceneEventInfo", "m_bHasArrived", false, value);
}
int32_t GCSceneEventInfo::GetType() const {
    return GetSchemaValue<int32_t>(m_ptr, "CSceneEventInfo", "m_nType");
}
void GCSceneEventInfo::SetType(int32_t value) {
    SetSchemaValue(m_ptr, "CSceneEventInfo", "m_nType", false, value);
}
float GCSceneEventInfo::GetNext() const {
    return GetSchemaValue<float>(m_ptr, "CSceneEventInfo", "m_flNext");
}
void GCSceneEventInfo::SetNext(float value) {
    SetSchemaValue(m_ptr, "CSceneEventInfo", "m_flNext", false, value);
}
bool GCSceneEventInfo::GetIsGesture() const {
    return GetSchemaValue<bool>(m_ptr, "CSceneEventInfo", "m_bIsGesture");
}
void GCSceneEventInfo::SetIsGesture(bool value) {
    SetSchemaValue(m_ptr, "CSceneEventInfo", "m_bIsGesture", false, value);
}
bool GCSceneEventInfo::GetShouldRemove() const {
    return GetSchemaValue<bool>(m_ptr, "CSceneEventInfo", "m_bShouldRemove");
}
void GCSceneEventInfo::SetShouldRemove(bool value) {
    SetSchemaValue(m_ptr, "CSceneEventInfo", "m_bShouldRemove", false, value);
}
GCBaseEntity GCSceneEventInfo::GetTarget() const {
    GCBaseEntity value((void*)(GetSchemaValue<CHandle<CEntityInstance>>(m_ptr, "CSceneEventInfo", "m_hTarget").Get()));
    return value;
}
void GCSceneEventInfo::SetTarget(GCBaseEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Target' is not possible.\n");
}
GSceneEventId_t GCSceneEventInfo::GetSceneEventId() const {
    GSceneEventId_t value(GetSchemaPtr(m_ptr, "CSceneEventInfo", "m_nSceneEventId"));
    return value;
}
void GCSceneEventInfo::SetSceneEventId(GSceneEventId_t value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'SceneEventId' is not possible.\n");
}
bool GCSceneEventInfo::GetClientSide() const {
    return GetSchemaValue<bool>(m_ptr, "CSceneEventInfo", "m_bClientSide");
}
void GCSceneEventInfo::SetClientSide(bool value) {
    SetSchemaValue(m_ptr, "CSceneEventInfo", "m_bClientSide", false, value);
}
bool GCSceneEventInfo::GetStarted() const {
    return GetSchemaValue<bool>(m_ptr, "CSceneEventInfo", "m_bStarted");
}
void GCSceneEventInfo::SetStarted(bool value) {
    SetSchemaValue(m_ptr, "CSceneEventInfo", "m_bStarted", false, value);
}
void* GCSceneEventInfo::GetPtr() {
    return m_ptr;
}
std::string GCSceneEventInfo::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCSceneEventInfo::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCSceneEventInfo(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCSceneEventInfo>("CSceneEventInfo")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Layer", &GCSceneEventInfo::GetLayer, &GCSceneEventInfo::SetLayer)
        .addProperty("Priority", &GCSceneEventInfo::GetPriority, &GCSceneEventInfo::SetPriority)
        .addProperty("Weight", &GCSceneEventInfo::GetWeight, &GCSceneEventInfo::SetWeight)
        .addProperty("HasArrived", &GCSceneEventInfo::GetHasArrived, &GCSceneEventInfo::SetHasArrived)
        .addProperty("Type", &GCSceneEventInfo::GetType, &GCSceneEventInfo::SetType)
        .addProperty("Next", &GCSceneEventInfo::GetNext, &GCSceneEventInfo::SetNext)
        .addProperty("IsGesture", &GCSceneEventInfo::GetIsGesture, &GCSceneEventInfo::SetIsGesture)
        .addProperty("ShouldRemove", &GCSceneEventInfo::GetShouldRemove, &GCSceneEventInfo::SetShouldRemove)
        .addProperty("Target", &GCSceneEventInfo::GetTarget, &GCSceneEventInfo::SetTarget)
        .addProperty("SceneEventId", &GCSceneEventInfo::GetSceneEventId, &GCSceneEventInfo::SetSceneEventId)
        .addProperty("ClientSide", &GCSceneEventInfo::GetClientSide, &GCSceneEventInfo::SetClientSide)
        .addProperty("Started", &GCSceneEventInfo::GetStarted, &GCSceneEventInfo::SetStarted)
        .addFunction("ToPtr", &GCSceneEventInfo::ToPtr)
        .addFunction("IsValid", &GCSceneEventInfo::IsValid)
        .endClass();
}
GCCopyRecipientFilter::GCCopyRecipientFilter(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCCopyRecipientFilter::GCCopyRecipientFilter(void *ptr) {
    m_ptr = ptr;
}
int32_t GCCopyRecipientFilter::GetFlags() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCopyRecipientFilter", "m_Flags");
}
void GCCopyRecipientFilter::SetFlags(int32_t value) {
    SetSchemaValue(m_ptr, "CCopyRecipientFilter", "m_Flags", false, value);
}
std::vector<int32_t> GCCopyRecipientFilter::GetRecipients() const {
    CUtlVector<int32_t>* vec = GetSchemaValue<CUtlVector<int32_t>*>(m_ptr, "CCopyRecipientFilter", "m_Recipients"); std::vector<int32_t> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCCopyRecipientFilter::SetRecipients(std::vector<int32_t> value) {
    SetSchemaValueCUtlVector<int32_t>(m_ptr, "CCopyRecipientFilter", "m_Recipients", false, value);
}
void* GCCopyRecipientFilter::GetPtr() {
    return m_ptr;
}
std::string GCCopyRecipientFilter::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCCopyRecipientFilter::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCCopyRecipientFilter(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCCopyRecipientFilter>("CCopyRecipientFilter")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Flags", &GCCopyRecipientFilter::GetFlags, &GCCopyRecipientFilter::SetFlags)
        .addProperty("Recipients", &GCCopyRecipientFilter::GetRecipients, &GCCopyRecipientFilter::SetRecipients)
        .addFunction("ToPtr", &GCCopyRecipientFilter::ToPtr)
        .addFunction("IsValid", &GCCopyRecipientFilter::IsValid)
        .endClass();
}
GCPropDoorRotatingBreakable::GCPropDoorRotatingBreakable(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCPropDoorRotatingBreakable::GCPropDoorRotatingBreakable(void *ptr) {
    m_ptr = ptr;
}
bool GCPropDoorRotatingBreakable::GetBreakable() const {
    return GetSchemaValue<bool>(m_ptr, "CPropDoorRotatingBreakable", "m_bBreakable");
}
void GCPropDoorRotatingBreakable::SetBreakable(bool value) {
    SetSchemaValue(m_ptr, "CPropDoorRotatingBreakable", "m_bBreakable", false, value);
}
bool GCPropDoorRotatingBreakable::GetIsAbleToCloseAreaPortals() const {
    return GetSchemaValue<bool>(m_ptr, "CPropDoorRotatingBreakable", "m_isAbleToCloseAreaPortals");
}
void GCPropDoorRotatingBreakable::SetIsAbleToCloseAreaPortals(bool value) {
    SetSchemaValue(m_ptr, "CPropDoorRotatingBreakable", "m_isAbleToCloseAreaPortals", false, value);
}
int32_t GCPropDoorRotatingBreakable::GetCurrentDamageState() const {
    return GetSchemaValue<int32_t>(m_ptr, "CPropDoorRotatingBreakable", "m_currentDamageState");
}
void GCPropDoorRotatingBreakable::SetCurrentDamageState(int32_t value) {
    SetSchemaValue(m_ptr, "CPropDoorRotatingBreakable", "m_currentDamageState", false, value);
}
std::vector<CUtlSymbolLarge> GCPropDoorRotatingBreakable::GetDamageStates() const {
    CUtlVector<CUtlSymbolLarge>* vec = GetSchemaValue<CUtlVector<CUtlSymbolLarge>*>(m_ptr, "CPropDoorRotatingBreakable", "m_damageStates"); std::vector<CUtlSymbolLarge> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCPropDoorRotatingBreakable::SetDamageStates(std::vector<CUtlSymbolLarge> value) {
    SetSchemaValueCUtlVector<CUtlSymbolLarge>(m_ptr, "CPropDoorRotatingBreakable", "m_damageStates", false, value);
}
void* GCPropDoorRotatingBreakable::GetPtr() {
    return m_ptr;
}
std::string GCPropDoorRotatingBreakable::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCPropDoorRotatingBreakable::IsValid() {
    return (m_ptr != nullptr);
}
GCPropDoorRotating GCPropDoorRotatingBreakable::GetParent() const {
    GCPropDoorRotating value(m_ptr);
    return value;
}
void GCPropDoorRotatingBreakable::SetParent(GCPropDoorRotating value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCPropDoorRotatingBreakable(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCPropDoorRotatingBreakable>("CPropDoorRotatingBreakable")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Breakable", &GCPropDoorRotatingBreakable::GetBreakable, &GCPropDoorRotatingBreakable::SetBreakable)
        .addProperty("IsAbleToCloseAreaPortals", &GCPropDoorRotatingBreakable::GetIsAbleToCloseAreaPortals, &GCPropDoorRotatingBreakable::SetIsAbleToCloseAreaPortals)
        .addProperty("CurrentDamageState", &GCPropDoorRotatingBreakable::GetCurrentDamageState, &GCPropDoorRotatingBreakable::SetCurrentDamageState)
        .addProperty("DamageStates", &GCPropDoorRotatingBreakable::GetDamageStates, &GCPropDoorRotatingBreakable::SetDamageStates)
        .addProperty("Parent", &GCPropDoorRotatingBreakable::GetParent, &GCPropDoorRotatingBreakable::SetParent)
        .addFunction("ToPtr", &GCPropDoorRotatingBreakable::ToPtr)
        .addFunction("IsValid", &GCPropDoorRotatingBreakable::IsValid)
        .endClass();
}
GCBtActionAim::GCBtActionAim(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCBtActionAim::GCBtActionAim(void *ptr) {
    m_ptr = ptr;
}
std::string GCBtActionAim::GetSensorInputKey() const {
    return GetSchemaValue<CUtlString>(m_ptr, "CBtActionAim", "m_szSensorInputKey").Get();
}
void GCBtActionAim::SetSensorInputKey(std::string value) {
    SetSchemaValue(m_ptr, "CBtActionAim", "m_szSensorInputKey", false, CUtlString(value.c_str()));
}
std::string GCBtActionAim::GetAimReadyKey() const {
    return GetSchemaValue<CUtlString>(m_ptr, "CBtActionAim", "m_szAimReadyKey").Get();
}
void GCBtActionAim::SetAimReadyKey(std::string value) {
    SetSchemaValue(m_ptr, "CBtActionAim", "m_szAimReadyKey", false, CUtlString(value.c_str()));
}
float GCBtActionAim::GetZoomCooldownTimestamp() const {
    return GetSchemaValue<float>(m_ptr, "CBtActionAim", "m_flZoomCooldownTimestamp");
}
void GCBtActionAim::SetZoomCooldownTimestamp(float value) {
    SetSchemaValue(m_ptr, "CBtActionAim", "m_flZoomCooldownTimestamp", false, value);
}
bool GCBtActionAim::GetDoneAiming() const {
    return GetSchemaValue<bool>(m_ptr, "CBtActionAim", "m_bDoneAiming");
}
void GCBtActionAim::SetDoneAiming(bool value) {
    SetSchemaValue(m_ptr, "CBtActionAim", "m_bDoneAiming", false, value);
}
float GCBtActionAim::GetLerpStartTime() const {
    return GetSchemaValue<float>(m_ptr, "CBtActionAim", "m_flLerpStartTime");
}
void GCBtActionAim::SetLerpStartTime(float value) {
    SetSchemaValue(m_ptr, "CBtActionAim", "m_flLerpStartTime", false, value);
}
float GCBtActionAim::GetNextLookTargetLerpTime() const {
    return GetSchemaValue<float>(m_ptr, "CBtActionAim", "m_flNextLookTargetLerpTime");
}
void GCBtActionAim::SetNextLookTargetLerpTime(float value) {
    SetSchemaValue(m_ptr, "CBtActionAim", "m_flNextLookTargetLerpTime", false, value);
}
float GCBtActionAim::GetPenaltyReductionRatio() const {
    return GetSchemaValue<float>(m_ptr, "CBtActionAim", "m_flPenaltyReductionRatio");
}
void GCBtActionAim::SetPenaltyReductionRatio(float value) {
    SetSchemaValue(m_ptr, "CBtActionAim", "m_flPenaltyReductionRatio", false, value);
}
QAngle GCBtActionAim::GetNextLookTarget() const {
    return GetSchemaValue<QAngle>(m_ptr, "CBtActionAim", "m_NextLookTarget");
}
void GCBtActionAim::SetNextLookTarget(QAngle value) {
    SetSchemaValue(m_ptr, "CBtActionAim", "m_NextLookTarget", false, value);
}
GCountdownTimer GCBtActionAim::GetAimTimer() const {
    GCountdownTimer value(GetSchemaPtr(m_ptr, "CBtActionAim", "m_AimTimer"));
    return value;
}
void GCBtActionAim::SetAimTimer(GCountdownTimer value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'AimTimer' is not possible.\n");
}
GCountdownTimer GCBtActionAim::GetSniperHoldTimer() const {
    GCountdownTimer value(GetSchemaPtr(m_ptr, "CBtActionAim", "m_SniperHoldTimer"));
    return value;
}
void GCBtActionAim::SetSniperHoldTimer(GCountdownTimer value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'SniperHoldTimer' is not possible.\n");
}
GCountdownTimer GCBtActionAim::GetFocusIntervalTimer() const {
    GCountdownTimer value(GetSchemaPtr(m_ptr, "CBtActionAim", "m_FocusIntervalTimer"));
    return value;
}
void GCBtActionAim::SetFocusIntervalTimer(GCountdownTimer value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'FocusIntervalTimer' is not possible.\n");
}
bool GCBtActionAim::GetAcquired() const {
    return GetSchemaValue<bool>(m_ptr, "CBtActionAim", "m_bAcquired");
}
void GCBtActionAim::SetAcquired(bool value) {
    SetSchemaValue(m_ptr, "CBtActionAim", "m_bAcquired", false, value);
}
void* GCBtActionAim::GetPtr() {
    return m_ptr;
}
std::string GCBtActionAim::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCBtActionAim::IsValid() {
    return (m_ptr != nullptr);
}
GCBtNode GCBtActionAim::GetParent() const {
    GCBtNode value(m_ptr);
    return value;
}
void GCBtActionAim::SetParent(GCBtNode value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCBtActionAim(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCBtActionAim>("CBtActionAim")
        .addConstructor<void (*)(std::string)>()
        .addProperty("SensorInputKey", &GCBtActionAim::GetSensorInputKey, &GCBtActionAim::SetSensorInputKey)
        .addProperty("AimReadyKey", &GCBtActionAim::GetAimReadyKey, &GCBtActionAim::SetAimReadyKey)
        .addProperty("ZoomCooldownTimestamp", &GCBtActionAim::GetZoomCooldownTimestamp, &GCBtActionAim::SetZoomCooldownTimestamp)
        .addProperty("DoneAiming", &GCBtActionAim::GetDoneAiming, &GCBtActionAim::SetDoneAiming)
        .addProperty("LerpStartTime", &GCBtActionAim::GetLerpStartTime, &GCBtActionAim::SetLerpStartTime)
        .addProperty("NextLookTargetLerpTime", &GCBtActionAim::GetNextLookTargetLerpTime, &GCBtActionAim::SetNextLookTargetLerpTime)
        .addProperty("PenaltyReductionRatio", &GCBtActionAim::GetPenaltyReductionRatio, &GCBtActionAim::SetPenaltyReductionRatio)
        .addProperty("NextLookTarget", &GCBtActionAim::GetNextLookTarget, &GCBtActionAim::SetNextLookTarget)
        .addProperty("AimTimer", &GCBtActionAim::GetAimTimer, &GCBtActionAim::SetAimTimer)
        .addProperty("SniperHoldTimer", &GCBtActionAim::GetSniperHoldTimer, &GCBtActionAim::SetSniperHoldTimer)
        .addProperty("FocusIntervalTimer", &GCBtActionAim::GetFocusIntervalTimer, &GCBtActionAim::SetFocusIntervalTimer)
        .addProperty("Acquired", &GCBtActionAim::GetAcquired, &GCBtActionAim::SetAcquired)
        .addProperty("Parent", &GCBtActionAim::GetParent, &GCBtActionAim::SetParent)
        .addFunction("ToPtr", &GCBtActionAim::ToPtr)
        .addFunction("IsValid", &GCBtActionAim::IsValid)
        .endClass();
}
GCFiringModeInt::GCFiringModeInt(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCFiringModeInt::GCFiringModeInt(void *ptr) {
    m_ptr = ptr;
}
std::vector<int32_t> GCFiringModeInt::GetValues() const {
    int32_t* outValue = (int32_t*)GetSchemaPtr(m_ptr, "CFiringModeInt", "m_nValues"); std::vector<int32_t> ret; for(int i = 0; i < 2; i++) { ret.push_back(outValue[i]); } return ret;
}
void GCFiringModeInt::SetValues(std::vector<int32_t> value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Values' is not possible.\n");
}
void* GCFiringModeInt::GetPtr() {
    return m_ptr;
}
std::string GCFiringModeInt::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCFiringModeInt::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCFiringModeInt(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCFiringModeInt>("CFiringModeInt")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Values", &GCFiringModeInt::GetValues, &GCFiringModeInt::SetValues)
        .addFunction("ToPtr", &GCFiringModeInt::ToPtr)
        .addFunction("IsValid", &GCFiringModeInt::IsValid)
        .endClass();
}
GCSoundPatch::GCSoundPatch(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCSoundPatch::GCSoundPatch(void *ptr) {
    m_ptr = ptr;
}
GCSoundEnvelope GCSoundPatch::GetPitch() const {
    GCSoundEnvelope value(GetSchemaPtr(m_ptr, "CSoundPatch", "m_pitch"));
    return value;
}
void GCSoundPatch::SetPitch(GCSoundEnvelope value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Pitch' is not possible.\n");
}
GCSoundEnvelope GCSoundPatch::GetVolume() const {
    GCSoundEnvelope value(GetSchemaPtr(m_ptr, "CSoundPatch", "m_volume"));
    return value;
}
void GCSoundPatch::SetVolume(GCSoundEnvelope value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Volume' is not possible.\n");
}
float GCSoundPatch::GetShutdownTime() const {
    return GetSchemaValue<float>(m_ptr, "CSoundPatch", "m_shutdownTime");
}
void GCSoundPatch::SetShutdownTime(float value) {
    SetSchemaValue(m_ptr, "CSoundPatch", "m_shutdownTime", false, value);
}
float GCSoundPatch::GetLastTime() const {
    return GetSchemaValue<float>(m_ptr, "CSoundPatch", "m_flLastTime");
}
void GCSoundPatch::SetLastTime(float value) {
    SetSchemaValue(m_ptr, "CSoundPatch", "m_flLastTime", false, value);
}
std::string GCSoundPatch::GetSoundScriptName() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CSoundPatch", "m_iszSoundScriptName").String();
}
void GCSoundPatch::SetSoundScriptName(std::string value) {
    SetSchemaValue(m_ptr, "CSoundPatch", "m_iszSoundScriptName", false, CUtlSymbolLarge(value.c_str()));
}
GCBaseEntity GCSoundPatch::GetEnt() const {
    GCBaseEntity value((void*)(GetSchemaValue<CHandle<CEntityInstance>>(m_ptr, "CSoundPatch", "m_hEnt").Get()));
    return value;
}
void GCSoundPatch::SetEnt(GCBaseEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Ent' is not possible.\n");
}
int GCSoundPatch::GetSoundEntityIndex() const {
    return GetSchemaValue<CEntityIndex>(m_ptr, "CSoundPatch", "m_soundEntityIndex").Get();
}
void GCSoundPatch::SetSoundEntityIndex(int value) {
    SetSchemaValue(m_ptr, "CSoundPatch", "m_soundEntityIndex", false, CEntityIndex(value));
}
Vector GCSoundPatch::GetSoundOrigin() const {
    return GetSchemaValue<Vector>(m_ptr, "CSoundPatch", "m_soundOrigin");
}
void GCSoundPatch::SetSoundOrigin(Vector value) {
    SetSchemaValue(m_ptr, "CSoundPatch", "m_soundOrigin", false, value);
}
int32_t GCSoundPatch::GetIsPlaying() const {
    return GetSchemaValue<int32_t>(m_ptr, "CSoundPatch", "m_isPlaying");
}
void GCSoundPatch::SetIsPlaying(int32_t value) {
    SetSchemaValue(m_ptr, "CSoundPatch", "m_isPlaying", false, value);
}
GCCopyRecipientFilter GCSoundPatch::GetFilter() const {
    GCCopyRecipientFilter value(GetSchemaPtr(m_ptr, "CSoundPatch", "m_Filter"));
    return value;
}
void GCSoundPatch::SetFilter(GCCopyRecipientFilter value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Filter' is not possible.\n");
}
float GCSoundPatch::GetCloseCaptionDuration() const {
    return GetSchemaValue<float>(m_ptr, "CSoundPatch", "m_flCloseCaptionDuration");
}
void GCSoundPatch::SetCloseCaptionDuration(float value) {
    SetSchemaValue(m_ptr, "CSoundPatch", "m_flCloseCaptionDuration", false, value);
}
bool GCSoundPatch::GetUpdatedSoundOrigin() const {
    return GetSchemaValue<bool>(m_ptr, "CSoundPatch", "m_bUpdatedSoundOrigin");
}
void GCSoundPatch::SetUpdatedSoundOrigin(bool value) {
    SetSchemaValue(m_ptr, "CSoundPatch", "m_bUpdatedSoundOrigin", false, value);
}
std::string GCSoundPatch::GetClassName() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CSoundPatch", "m_iszClassName").String();
}
void GCSoundPatch::SetClassName(std::string value) {
    SetSchemaValue(m_ptr, "CSoundPatch", "m_iszClassName", false, CUtlSymbolLarge(value.c_str()));
}
void* GCSoundPatch::GetPtr() {
    return m_ptr;
}
std::string GCSoundPatch::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCSoundPatch::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCSoundPatch(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCSoundPatch>("CSoundPatch")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Pitch", &GCSoundPatch::GetPitch, &GCSoundPatch::SetPitch)
        .addProperty("Volume", &GCSoundPatch::GetVolume, &GCSoundPatch::SetVolume)
        .addProperty("ShutdownTime", &GCSoundPatch::GetShutdownTime, &GCSoundPatch::SetShutdownTime)
        .addProperty("LastTime", &GCSoundPatch::GetLastTime, &GCSoundPatch::SetLastTime)
        .addProperty("SoundScriptName", &GCSoundPatch::GetSoundScriptName, &GCSoundPatch::SetSoundScriptName)
        .addProperty("Ent", &GCSoundPatch::GetEnt, &GCSoundPatch::SetEnt)
        .addProperty("SoundEntityIndex", &GCSoundPatch::GetSoundEntityIndex, &GCSoundPatch::SetSoundEntityIndex)
        .addProperty("SoundOrigin", &GCSoundPatch::GetSoundOrigin, &GCSoundPatch::SetSoundOrigin)
        .addProperty("IsPlaying", &GCSoundPatch::GetIsPlaying, &GCSoundPatch::SetIsPlaying)
        .addProperty("Filter", &GCSoundPatch::GetFilter, &GCSoundPatch::SetFilter)
        .addProperty("CloseCaptionDuration", &GCSoundPatch::GetCloseCaptionDuration, &GCSoundPatch::SetCloseCaptionDuration)
        .addProperty("UpdatedSoundOrigin", &GCSoundPatch::GetUpdatedSoundOrigin, &GCSoundPatch::SetUpdatedSoundOrigin)
        .addProperty("ClassName", &GCSoundPatch::GetClassName, &GCSoundPatch::SetClassName)
        .addFunction("ToPtr", &GCSoundPatch::ToPtr)
        .addFunction("IsValid", &GCSoundPatch::IsValid)
        .endClass();
}
GCSmoothFunc::GCSmoothFunc(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCSmoothFunc::GCSmoothFunc(void *ptr) {
    m_ptr = ptr;
}
float GCSmoothFunc::GetSmoothAmplitude() const {
    return GetSchemaValue<float>(m_ptr, "CSmoothFunc", "m_flSmoothAmplitude");
}
void GCSmoothFunc::SetSmoothAmplitude(float value) {
    SetSchemaValue(m_ptr, "CSmoothFunc", "m_flSmoothAmplitude", false, value);
}
float GCSmoothFunc::GetSmoothBias() const {
    return GetSchemaValue<float>(m_ptr, "CSmoothFunc", "m_flSmoothBias");
}
void GCSmoothFunc::SetSmoothBias(float value) {
    SetSchemaValue(m_ptr, "CSmoothFunc", "m_flSmoothBias", false, value);
}
float GCSmoothFunc::GetSmoothDuration() const {
    return GetSchemaValue<float>(m_ptr, "CSmoothFunc", "m_flSmoothDuration");
}
void GCSmoothFunc::SetSmoothDuration(float value) {
    SetSchemaValue(m_ptr, "CSmoothFunc", "m_flSmoothDuration", false, value);
}
float GCSmoothFunc::GetSmoothRemainingTime() const {
    return GetSchemaValue<float>(m_ptr, "CSmoothFunc", "m_flSmoothRemainingTime");
}
void GCSmoothFunc::SetSmoothRemainingTime(float value) {
    SetSchemaValue(m_ptr, "CSmoothFunc", "m_flSmoothRemainingTime", false, value);
}
int32_t GCSmoothFunc::GetSmoothDir() const {
    return GetSchemaValue<int32_t>(m_ptr, "CSmoothFunc", "m_nSmoothDir");
}
void GCSmoothFunc::SetSmoothDir(int32_t value) {
    SetSchemaValue(m_ptr, "CSmoothFunc", "m_nSmoothDir", false, value);
}
void* GCSmoothFunc::GetPtr() {
    return m_ptr;
}
std::string GCSmoothFunc::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCSmoothFunc::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCSmoothFunc(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCSmoothFunc>("CSmoothFunc")
        .addConstructor<void (*)(std::string)>()
        .addProperty("SmoothAmplitude", &GCSmoothFunc::GetSmoothAmplitude, &GCSmoothFunc::SetSmoothAmplitude)
        .addProperty("SmoothBias", &GCSmoothFunc::GetSmoothBias, &GCSmoothFunc::SetSmoothBias)
        .addProperty("SmoothDuration", &GCSmoothFunc::GetSmoothDuration, &GCSmoothFunc::SetSmoothDuration)
        .addProperty("SmoothRemainingTime", &GCSmoothFunc::GetSmoothRemainingTime, &GCSmoothFunc::SetSmoothRemainingTime)
        .addProperty("SmoothDir", &GCSmoothFunc::GetSmoothDir, &GCSmoothFunc::SetSmoothDir)
        .addFunction("ToPtr", &GCSmoothFunc::ToPtr)
        .addFunction("IsValid", &GCSmoothFunc::IsValid)
        .endClass();
}
GIHasAttributes::GIHasAttributes(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GIHasAttributes::GIHasAttributes(void *ptr) {
    m_ptr = ptr;
}
void* GIHasAttributes::GetPtr() {
    return m_ptr;
}
std::string GIHasAttributes::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GIHasAttributes::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassIHasAttributes(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GIHasAttributes>("IHasAttributes")
        .addConstructor<void (*)(std::string)>()
        .addFunction("ToPtr", &GIHasAttributes::ToPtr)
        .addFunction("IsValid", &GIHasAttributes::IsValid)
        .endClass();
}
GCRagdollPropAttached::GCRagdollPropAttached(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCRagdollPropAttached::GCRagdollPropAttached(void *ptr) {
    m_ptr = ptr;
}
uint32_t GCRagdollPropAttached::GetBoneIndexAttached() const {
    return GetSchemaValue<uint32_t>(m_ptr, "CRagdollPropAttached", "m_boneIndexAttached");
}
void GCRagdollPropAttached::SetBoneIndexAttached(uint32_t value) {
    SetSchemaValue(m_ptr, "CRagdollPropAttached", "m_boneIndexAttached", false, value);
}
uint32_t GCRagdollPropAttached::GetRagdollAttachedObjectIndex() const {
    return GetSchemaValue<uint32_t>(m_ptr, "CRagdollPropAttached", "m_ragdollAttachedObjectIndex");
}
void GCRagdollPropAttached::SetRagdollAttachedObjectIndex(uint32_t value) {
    SetSchemaValue(m_ptr, "CRagdollPropAttached", "m_ragdollAttachedObjectIndex", false, value);
}
Vector GCRagdollPropAttached::GetAttachmentPointBoneSpace() const {
    return GetSchemaValue<Vector>(m_ptr, "CRagdollPropAttached", "m_attachmentPointBoneSpace");
}
void GCRagdollPropAttached::SetAttachmentPointBoneSpace(Vector value) {
    SetSchemaValue(m_ptr, "CRagdollPropAttached", "m_attachmentPointBoneSpace", false, value);
}
Vector GCRagdollPropAttached::GetAttachmentPointRagdollSpace() const {
    return GetSchemaValue<Vector>(m_ptr, "CRagdollPropAttached", "m_attachmentPointRagdollSpace");
}
void GCRagdollPropAttached::SetAttachmentPointRagdollSpace(Vector value) {
    SetSchemaValue(m_ptr, "CRagdollPropAttached", "m_attachmentPointRagdollSpace", false, value);
}
bool GCRagdollPropAttached::GetShouldDetach() const {
    return GetSchemaValue<bool>(m_ptr, "CRagdollPropAttached", "m_bShouldDetach");
}
void GCRagdollPropAttached::SetShouldDetach(bool value) {
    SetSchemaValue(m_ptr, "CRagdollPropAttached", "m_bShouldDetach", false, value);
}
bool GCRagdollPropAttached::GetShouldDeleteAttachedActivationRecord() const {
    return GetSchemaValue<bool>(m_ptr, "CRagdollPropAttached", "m_bShouldDeleteAttachedActivationRecord");
}
void GCRagdollPropAttached::SetShouldDeleteAttachedActivationRecord(bool value) {
    SetSchemaValue(m_ptr, "CRagdollPropAttached", "m_bShouldDeleteAttachedActivationRecord", false, value);
}
void* GCRagdollPropAttached::GetPtr() {
    return m_ptr;
}
std::string GCRagdollPropAttached::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCRagdollPropAttached::IsValid() {
    return (m_ptr != nullptr);
}
GCRagdollProp GCRagdollPropAttached::GetParent() const {
    GCRagdollProp value(m_ptr);
    return value;
}
void GCRagdollPropAttached::SetParent(GCRagdollProp value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCRagdollPropAttached(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCRagdollPropAttached>("CRagdollPropAttached")
        .addConstructor<void (*)(std::string)>()
        .addProperty("BoneIndexAttached", &GCRagdollPropAttached::GetBoneIndexAttached, &GCRagdollPropAttached::SetBoneIndexAttached)
        .addProperty("RagdollAttachedObjectIndex", &GCRagdollPropAttached::GetRagdollAttachedObjectIndex, &GCRagdollPropAttached::SetRagdollAttachedObjectIndex)
        .addProperty("AttachmentPointBoneSpace", &GCRagdollPropAttached::GetAttachmentPointBoneSpace, &GCRagdollPropAttached::SetAttachmentPointBoneSpace)
        .addProperty("AttachmentPointRagdollSpace", &GCRagdollPropAttached::GetAttachmentPointRagdollSpace, &GCRagdollPropAttached::SetAttachmentPointRagdollSpace)
        .addProperty("ShouldDetach", &GCRagdollPropAttached::GetShouldDetach, &GCRagdollPropAttached::SetShouldDetach)
        .addProperty("ShouldDeleteAttachedActivationRecord", &GCRagdollPropAttached::GetShouldDeleteAttachedActivationRecord, &GCRagdollPropAttached::SetShouldDeleteAttachedActivationRecord)
        .addProperty("Parent", &GCRagdollPropAttached::GetParent, &GCRagdollPropAttached::SetParent)
        .addFunction("ToPtr", &GCRagdollPropAttached::ToPtr)
        .addFunction("IsValid", &GCRagdollPropAttached::IsValid)
        .endClass();
}
GHullFlags_t::GHullFlags_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GHullFlags_t::GHullFlags_t(void *ptr) {
    m_ptr = ptr;
}
bool GHullFlags_t::GetHull_Human() const {
    return GetSchemaValue<bool>(m_ptr, "HullFlags_t", "m_bHull_Human");
}
void GHullFlags_t::SetHull_Human(bool value) {
    SetSchemaValue(m_ptr, "HullFlags_t", "m_bHull_Human", true, value);
}
bool GHullFlags_t::GetHull_SmallCentered() const {
    return GetSchemaValue<bool>(m_ptr, "HullFlags_t", "m_bHull_SmallCentered");
}
void GHullFlags_t::SetHull_SmallCentered(bool value) {
    SetSchemaValue(m_ptr, "HullFlags_t", "m_bHull_SmallCentered", true, value);
}
bool GHullFlags_t::GetHull_WideHuman() const {
    return GetSchemaValue<bool>(m_ptr, "HullFlags_t", "m_bHull_WideHuman");
}
void GHullFlags_t::SetHull_WideHuman(bool value) {
    SetSchemaValue(m_ptr, "HullFlags_t", "m_bHull_WideHuman", true, value);
}
bool GHullFlags_t::GetHull_Tiny() const {
    return GetSchemaValue<bool>(m_ptr, "HullFlags_t", "m_bHull_Tiny");
}
void GHullFlags_t::SetHull_Tiny(bool value) {
    SetSchemaValue(m_ptr, "HullFlags_t", "m_bHull_Tiny", true, value);
}
bool GHullFlags_t::GetHull_Medium() const {
    return GetSchemaValue<bool>(m_ptr, "HullFlags_t", "m_bHull_Medium");
}
void GHullFlags_t::SetHull_Medium(bool value) {
    SetSchemaValue(m_ptr, "HullFlags_t", "m_bHull_Medium", true, value);
}
bool GHullFlags_t::GetHull_TinyCentered() const {
    return GetSchemaValue<bool>(m_ptr, "HullFlags_t", "m_bHull_TinyCentered");
}
void GHullFlags_t::SetHull_TinyCentered(bool value) {
    SetSchemaValue(m_ptr, "HullFlags_t", "m_bHull_TinyCentered", true, value);
}
bool GHullFlags_t::GetHull_Large() const {
    return GetSchemaValue<bool>(m_ptr, "HullFlags_t", "m_bHull_Large");
}
void GHullFlags_t::SetHull_Large(bool value) {
    SetSchemaValue(m_ptr, "HullFlags_t", "m_bHull_Large", true, value);
}
bool GHullFlags_t::GetHull_LargeCentered() const {
    return GetSchemaValue<bool>(m_ptr, "HullFlags_t", "m_bHull_LargeCentered");
}
void GHullFlags_t::SetHull_LargeCentered(bool value) {
    SetSchemaValue(m_ptr, "HullFlags_t", "m_bHull_LargeCentered", true, value);
}
bool GHullFlags_t::GetHull_MediumTall() const {
    return GetSchemaValue<bool>(m_ptr, "HullFlags_t", "m_bHull_MediumTall");
}
void GHullFlags_t::SetHull_MediumTall(bool value) {
    SetSchemaValue(m_ptr, "HullFlags_t", "m_bHull_MediumTall", true, value);
}
bool GHullFlags_t::GetHull_Small() const {
    return GetSchemaValue<bool>(m_ptr, "HullFlags_t", "m_bHull_Small");
}
void GHullFlags_t::SetHull_Small(bool value) {
    SetSchemaValue(m_ptr, "HullFlags_t", "m_bHull_Small", true, value);
}
void* GHullFlags_t::GetPtr() {
    return m_ptr;
}
std::string GHullFlags_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GHullFlags_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassHullFlags_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GHullFlags_t>("HullFlags_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Hull_Human", &GHullFlags_t::GetHull_Human, &GHullFlags_t::SetHull_Human)
        .addProperty("Hull_SmallCentered", &GHullFlags_t::GetHull_SmallCentered, &GHullFlags_t::SetHull_SmallCentered)
        .addProperty("Hull_WideHuman", &GHullFlags_t::GetHull_WideHuman, &GHullFlags_t::SetHull_WideHuman)
        .addProperty("Hull_Tiny", &GHullFlags_t::GetHull_Tiny, &GHullFlags_t::SetHull_Tiny)
        .addProperty("Hull_Medium", &GHullFlags_t::GetHull_Medium, &GHullFlags_t::SetHull_Medium)
        .addProperty("Hull_TinyCentered", &GHullFlags_t::GetHull_TinyCentered, &GHullFlags_t::SetHull_TinyCentered)
        .addProperty("Hull_Large", &GHullFlags_t::GetHull_Large, &GHullFlags_t::SetHull_Large)
        .addProperty("Hull_LargeCentered", &GHullFlags_t::GetHull_LargeCentered, &GHullFlags_t::SetHull_LargeCentered)
        .addProperty("Hull_MediumTall", &GHullFlags_t::GetHull_MediumTall, &GHullFlags_t::SetHull_MediumTall)
        .addProperty("Hull_Small", &GHullFlags_t::GetHull_Small, &GHullFlags_t::SetHull_Small)
        .addFunction("ToPtr", &GHullFlags_t::ToPtr)
        .addFunction("IsValid", &GHullFlags_t::IsValid)
        .endClass();
}
GCBodyComponentBaseAnimGraph::GCBodyComponentBaseAnimGraph(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCBodyComponentBaseAnimGraph::GCBodyComponentBaseAnimGraph(void *ptr) {
    m_ptr = ptr;
}
GCBaseAnimGraphController GCBodyComponentBaseAnimGraph::GetAnimationController() const {
    GCBaseAnimGraphController value(GetSchemaPtr(m_ptr, "CBodyComponentBaseAnimGraph", "m_animationController"));
    return value;
}
void GCBodyComponentBaseAnimGraph::SetAnimationController(GCBaseAnimGraphController value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'AnimationController' is not possible.\n");
}
void* GCBodyComponentBaseAnimGraph::GetPtr() {
    return m_ptr;
}
std::string GCBodyComponentBaseAnimGraph::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCBodyComponentBaseAnimGraph::IsValid() {
    return (m_ptr != nullptr);
}
GCBodyComponentSkeletonInstance GCBodyComponentBaseAnimGraph::GetParent() const {
    GCBodyComponentSkeletonInstance value(m_ptr);
    return value;
}
void GCBodyComponentBaseAnimGraph::SetParent(GCBodyComponentSkeletonInstance value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCBodyComponentBaseAnimGraph(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCBodyComponentBaseAnimGraph>("CBodyComponentBaseAnimGraph")
        .addConstructor<void (*)(std::string)>()
        .addProperty("AnimationController", &GCBodyComponentBaseAnimGraph::GetAnimationController, &GCBodyComponentBaseAnimGraph::SetAnimationController)
        .addProperty("Parent", &GCBodyComponentBaseAnimGraph::GetParent, &GCBodyComponentBaseAnimGraph::SetParent)
        .addFunction("ToPtr", &GCBodyComponentBaseAnimGraph::ToPtr)
        .addFunction("IsValid", &GCBodyComponentBaseAnimGraph::IsValid)
        .endClass();
}
GGameAmmoTypeInfo_t::GGameAmmoTypeInfo_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GGameAmmoTypeInfo_t::GGameAmmoTypeInfo_t(void *ptr) {
    m_ptr = ptr;
}
int32_t GGameAmmoTypeInfo_t::GetBuySize() const {
    return GetSchemaValue<int32_t>(m_ptr, "GameAmmoTypeInfo_t", "m_nBuySize");
}
void GGameAmmoTypeInfo_t::SetBuySize(int32_t value) {
    SetSchemaValue(m_ptr, "GameAmmoTypeInfo_t", "m_nBuySize", true, value);
}
int32_t GGameAmmoTypeInfo_t::GetCost() const {
    return GetSchemaValue<int32_t>(m_ptr, "GameAmmoTypeInfo_t", "m_nCost");
}
void GGameAmmoTypeInfo_t::SetCost(int32_t value) {
    SetSchemaValue(m_ptr, "GameAmmoTypeInfo_t", "m_nCost", true, value);
}
void* GGameAmmoTypeInfo_t::GetPtr() {
    return m_ptr;
}
std::string GGameAmmoTypeInfo_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GGameAmmoTypeInfo_t::IsValid() {
    return (m_ptr != nullptr);
}
GAmmoTypeInfo_t GGameAmmoTypeInfo_t::GetParent() const {
    GAmmoTypeInfo_t value(m_ptr);
    return value;
}
void GGameAmmoTypeInfo_t::SetParent(GAmmoTypeInfo_t value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassGameAmmoTypeInfo_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GGameAmmoTypeInfo_t>("GameAmmoTypeInfo_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("BuySize", &GGameAmmoTypeInfo_t::GetBuySize, &GGameAmmoTypeInfo_t::SetBuySize)
        .addProperty("Cost", &GGameAmmoTypeInfo_t::GetCost, &GGameAmmoTypeInfo_t::SetCost)
        .addProperty("Parent", &GGameAmmoTypeInfo_t::GetParent, &GGameAmmoTypeInfo_t::SetParent)
        .addFunction("ToPtr", &GGameAmmoTypeInfo_t::ToPtr)
        .addFunction("IsValid", &GGameAmmoTypeInfo_t::IsValid)
        .endClass();
}
GCPhysMotor::GCPhysMotor(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCPhysMotor::GCPhysMotor(void *ptr) {
    m_ptr = ptr;
}
std::string GCPhysMotor::GetNameAttach() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CPhysMotor", "m_nameAttach").String();
}
void GCPhysMotor::SetNameAttach(std::string value) {
    SetSchemaValue(m_ptr, "CPhysMotor", "m_nameAttach", false, CUtlSymbolLarge(value.c_str()));
}
GCBaseEntity GCPhysMotor::GetAttachedObject() const {
    GCBaseEntity value((void*)(GetSchemaValue<CHandle<CEntityInstance>>(m_ptr, "CPhysMotor", "m_hAttachedObject").Get()));
    return value;
}
void GCPhysMotor::SetAttachedObject(GCBaseEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'AttachedObject' is not possible.\n");
}
float GCPhysMotor::GetSpinUp() const {
    return GetSchemaValue<float>(m_ptr, "CPhysMotor", "m_spinUp");
}
void GCPhysMotor::SetSpinUp(float value) {
    SetSchemaValue(m_ptr, "CPhysMotor", "m_spinUp", false, value);
}
float GCPhysMotor::GetAdditionalAcceleration() const {
    return GetSchemaValue<float>(m_ptr, "CPhysMotor", "m_additionalAcceleration");
}
void GCPhysMotor::SetAdditionalAcceleration(float value) {
    SetSchemaValue(m_ptr, "CPhysMotor", "m_additionalAcceleration", false, value);
}
float GCPhysMotor::GetAngularAcceleration() const {
    return GetSchemaValue<float>(m_ptr, "CPhysMotor", "m_angularAcceleration");
}
void GCPhysMotor::SetAngularAcceleration(float value) {
    SetSchemaValue(m_ptr, "CPhysMotor", "m_angularAcceleration", false, value);
}
float GCPhysMotor::GetLastTime() const {
    return GetSchemaValue<float>(m_ptr, "CPhysMotor", "m_lastTime");
}
void GCPhysMotor::SetLastTime(float value) {
    SetSchemaValue(m_ptr, "CPhysMotor", "m_lastTime", false, value);
}
GCMotorController GCPhysMotor::GetMotor() const {
    GCMotorController value(GetSchemaPtr(m_ptr, "CPhysMotor", "m_motor"));
    return value;
}
void GCPhysMotor::SetMotor(GCMotorController value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Motor' is not possible.\n");
}
void* GCPhysMotor::GetPtr() {
    return m_ptr;
}
std::string GCPhysMotor::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCPhysMotor::IsValid() {
    return (m_ptr != nullptr);
}
GCLogicalEntity GCPhysMotor::GetParent() const {
    GCLogicalEntity value(m_ptr);
    return value;
}
void GCPhysMotor::SetParent(GCLogicalEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCPhysMotor(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCPhysMotor>("CPhysMotor")
        .addConstructor<void (*)(std::string)>()
        .addProperty("NameAttach", &GCPhysMotor::GetNameAttach, &GCPhysMotor::SetNameAttach)
        .addProperty("AttachedObject", &GCPhysMotor::GetAttachedObject, &GCPhysMotor::SetAttachedObject)
        .addProperty("SpinUp", &GCPhysMotor::GetSpinUp, &GCPhysMotor::SetSpinUp)
        .addProperty("AdditionalAcceleration", &GCPhysMotor::GetAdditionalAcceleration, &GCPhysMotor::SetAdditionalAcceleration)
        .addProperty("AngularAcceleration", &GCPhysMotor::GetAngularAcceleration, &GCPhysMotor::SetAngularAcceleration)
        .addProperty("LastTime", &GCPhysMotor::GetLastTime, &GCPhysMotor::SetLastTime)
        .addProperty("Motor", &GCPhysMotor::GetMotor, &GCPhysMotor::SetMotor)
        .addProperty("Parent", &GCPhysMotor::GetParent, &GCPhysMotor::SetParent)
        .addFunction("ToPtr", &GCPhysMotor::ToPtr)
        .addFunction("IsValid", &GCPhysMotor::IsValid)
        .endClass();
}
GCSimTimer::GCSimTimer(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCSimTimer::GCSimTimer(void *ptr) {
    m_ptr = ptr;
}
float GCSimTimer::GetInterval() const {
    return GetSchemaValue<float>(m_ptr, "CSimTimer", "m_interval");
}
void GCSimTimer::SetInterval(float value) {
    SetSchemaValue(m_ptr, "CSimTimer", "m_interval", false, value);
}
void* GCSimTimer::GetPtr() {
    return m_ptr;
}
std::string GCSimTimer::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCSimTimer::IsValid() {
    return (m_ptr != nullptr);
}
GCSimpleSimTimer GCSimTimer::GetParent() const {
    GCSimpleSimTimer value(m_ptr);
    return value;
}
void GCSimTimer::SetParent(GCSimpleSimTimer value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCSimTimer(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCSimTimer>("CSimTimer")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Interval", &GCSimTimer::GetInterval, &GCSimTimer::SetInterval)
        .addProperty("Parent", &GCSimTimer::GetParent, &GCSimTimer::SetParent)
        .addFunction("ToPtr", &GCSimTimer::ToPtr)
        .addFunction("IsValid", &GCSimTimer::IsValid)
        .endClass();
}
GCBaseIssue::GCBaseIssue(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCBaseIssue::GCBaseIssue(void *ptr) {
    m_ptr = ptr;
}
std::string GCBaseIssue::GetTypeString() const {
    return GetSchemaValuePtr<char>(m_ptr, "CBaseIssue", "m_szTypeString");
}
void GCBaseIssue::SetTypeString(std::string value) {
    WriteSchemaPtrValue(m_ptr, "CBaseIssue", "m_szTypeString", false, reinterpret_cast<byte*>(const_cast<char*>(value.c_str())), 64);
}
std::string GCBaseIssue::GetDetailsString() const {
    return GetSchemaValuePtr<char>(m_ptr, "CBaseIssue", "m_szDetailsString");
}
void GCBaseIssue::SetDetailsString(std::string value) {
    WriteSchemaPtrValue(m_ptr, "CBaseIssue", "m_szDetailsString", false, reinterpret_cast<byte*>(const_cast<char*>(value.c_str())), 260);
}
int32_t GCBaseIssue::GetNumYesVotes() const {
    return GetSchemaValue<int32_t>(m_ptr, "CBaseIssue", "m_iNumYesVotes");
}
void GCBaseIssue::SetNumYesVotes(int32_t value) {
    SetSchemaValue(m_ptr, "CBaseIssue", "m_iNumYesVotes", false, value);
}
int32_t GCBaseIssue::GetNumNoVotes() const {
    return GetSchemaValue<int32_t>(m_ptr, "CBaseIssue", "m_iNumNoVotes");
}
void GCBaseIssue::SetNumNoVotes(int32_t value) {
    SetSchemaValue(m_ptr, "CBaseIssue", "m_iNumNoVotes", false, value);
}
int32_t GCBaseIssue::GetNumPotentialVotes() const {
    return GetSchemaValue<int32_t>(m_ptr, "CBaseIssue", "m_iNumPotentialVotes");
}
void GCBaseIssue::SetNumPotentialVotes(int32_t value) {
    SetSchemaValue(m_ptr, "CBaseIssue", "m_iNumPotentialVotes", false, value);
}
void* GCBaseIssue::GetPtr() {
    return m_ptr;
}
std::string GCBaseIssue::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCBaseIssue::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCBaseIssue(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCBaseIssue>("CBaseIssue")
        .addConstructor<void (*)(std::string)>()
        .addProperty("TypeString", &GCBaseIssue::GetTypeString, &GCBaseIssue::SetTypeString)
        .addProperty("DetailsString", &GCBaseIssue::GetDetailsString, &GCBaseIssue::SetDetailsString)
        .addProperty("NumYesVotes", &GCBaseIssue::GetNumYesVotes, &GCBaseIssue::SetNumYesVotes)
        .addProperty("NumNoVotes", &GCBaseIssue::GetNumNoVotes, &GCBaseIssue::SetNumNoVotes)
        .addProperty("NumPotentialVotes", &GCBaseIssue::GetNumPotentialVotes, &GCBaseIssue::SetNumPotentialVotes)
        .addFunction("ToPtr", &GCBaseIssue::ToPtr)
        .addFunction("IsValid", &GCBaseIssue::IsValid)
        .endClass();
}
GCTakeDamageInfo::GCTakeDamageInfo(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCTakeDamageInfo::GCTakeDamageInfo(void *ptr) {
    m_ptr = ptr;
}
Vector GCTakeDamageInfo::GetDamageForce() const {
    return GetSchemaValue<Vector>(m_ptr, "CTakeDamageInfo", "m_vecDamageForce");
}
void GCTakeDamageInfo::SetDamageForce(Vector value) {
    SetSchemaValue(m_ptr, "CTakeDamageInfo", "m_vecDamageForce", false, value);
}
Vector GCTakeDamageInfo::GetDamagePosition() const {
    return GetSchemaValue<Vector>(m_ptr, "CTakeDamageInfo", "m_vecDamagePosition");
}
void GCTakeDamageInfo::SetDamagePosition(Vector value) {
    SetSchemaValue(m_ptr, "CTakeDamageInfo", "m_vecDamagePosition", false, value);
}
Vector GCTakeDamageInfo::GetReportedPosition() const {
    return GetSchemaValue<Vector>(m_ptr, "CTakeDamageInfo", "m_vecReportedPosition");
}
void GCTakeDamageInfo::SetReportedPosition(Vector value) {
    SetSchemaValue(m_ptr, "CTakeDamageInfo", "m_vecReportedPosition", false, value);
}
Vector GCTakeDamageInfo::GetDamageDirection() const {
    return GetSchemaValue<Vector>(m_ptr, "CTakeDamageInfo", "m_vecDamageDirection");
}
void GCTakeDamageInfo::SetDamageDirection(Vector value) {
    SetSchemaValue(m_ptr, "CTakeDamageInfo", "m_vecDamageDirection", false, value);
}
GCBaseEntity GCTakeDamageInfo::GetInflictor() const {
    GCBaseEntity value((void*)(GetSchemaValue<CHandle<CEntityInstance>>(m_ptr, "CTakeDamageInfo", "m_hInflictor").Get()));
    return value;
}
void GCTakeDamageInfo::SetInflictor(GCBaseEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Inflictor' is not possible.\n");
}
GCBaseEntity GCTakeDamageInfo::GetAttacker() const {
    GCBaseEntity value((void*)(GetSchemaValue<CHandle<CEntityInstance>>(m_ptr, "CTakeDamageInfo", "m_hAttacker").Get()));
    return value;
}
void GCTakeDamageInfo::SetAttacker(GCBaseEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Attacker' is not possible.\n");
}
GCBaseEntity GCTakeDamageInfo::GetAbility() const {
    GCBaseEntity value((void*)(GetSchemaValue<CHandle<CEntityInstance>>(m_ptr, "CTakeDamageInfo", "m_hAbility").Get()));
    return value;
}
void GCTakeDamageInfo::SetAbility(GCBaseEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Ability' is not possible.\n");
}
float GCTakeDamageInfo::GetDamage() const {
    return GetSchemaValue<float>(m_ptr, "CTakeDamageInfo", "m_flDamage");
}
void GCTakeDamageInfo::SetDamage(float value) {
    SetSchemaValue(m_ptr, "CTakeDamageInfo", "m_flDamage", false, value);
}
float GCTakeDamageInfo::GetTotalledDamage() const {
    return GetSchemaValue<float>(m_ptr, "CTakeDamageInfo", "m_flTotalledDamage");
}
void GCTakeDamageInfo::SetTotalledDamage(float value) {
    SetSchemaValue(m_ptr, "CTakeDamageInfo", "m_flTotalledDamage", false, value);
}
int32_t GCTakeDamageInfo::GetBitsDamageType() const {
    return GetSchemaValue<int32_t>(m_ptr, "CTakeDamageInfo", "m_bitsDamageType");
}
void GCTakeDamageInfo::SetBitsDamageType(int32_t value) {
    SetSchemaValue(m_ptr, "CTakeDamageInfo", "m_bitsDamageType", false, value);
}
int32_t GCTakeDamageInfo::GetDamageCustom() const {
    return GetSchemaValue<int32_t>(m_ptr, "CTakeDamageInfo", "m_iDamageCustom");
}
void GCTakeDamageInfo::SetDamageCustom(int32_t value) {
    SetSchemaValue(m_ptr, "CTakeDamageInfo", "m_iDamageCustom", false, value);
}
uint32_t GCTakeDamageInfo::GetAmmoType() const {
    return GetSchemaValue<uint32_t>(m_ptr, "CTakeDamageInfo", "m_iAmmoType");
}
void GCTakeDamageInfo::SetAmmoType(uint32_t value) {
    SetSchemaValue(m_ptr, "CTakeDamageInfo", "m_iAmmoType", false, value);
}
float GCTakeDamageInfo::GetOriginalDamage() const {
    return GetSchemaValue<float>(m_ptr, "CTakeDamageInfo", "m_flOriginalDamage");
}
void GCTakeDamageInfo::SetOriginalDamage(float value) {
    SetSchemaValue(m_ptr, "CTakeDamageInfo", "m_flOriginalDamage", false, value);
}
bool GCTakeDamageInfo::GetShouldBleed() const {
    return GetSchemaValue<bool>(m_ptr, "CTakeDamageInfo", "m_bShouldBleed");
}
void GCTakeDamageInfo::SetShouldBleed(bool value) {
    SetSchemaValue(m_ptr, "CTakeDamageInfo", "m_bShouldBleed", false, value);
}
bool GCTakeDamageInfo::GetShouldSpark() const {
    return GetSchemaValue<bool>(m_ptr, "CTakeDamageInfo", "m_bShouldSpark");
}
void GCTakeDamageInfo::SetShouldSpark(bool value) {
    SetSchemaValue(m_ptr, "CTakeDamageInfo", "m_bShouldSpark", false, value);
}
uint64_t GCTakeDamageInfo::GetDamageFlags() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CTakeDamageInfo", "m_nDamageFlags");
}
void GCTakeDamageInfo::SetDamageFlags(uint64_t value) {
    SetSchemaValue(m_ptr, "CTakeDamageInfo", "m_nDamageFlags", false, value);
}
int32_t GCTakeDamageInfo::GetNumObjectsPenetrated() const {
    return GetSchemaValue<int32_t>(m_ptr, "CTakeDamageInfo", "m_nNumObjectsPenetrated");
}
void GCTakeDamageInfo::SetNumObjectsPenetrated(int32_t value) {
    SetSchemaValue(m_ptr, "CTakeDamageInfo", "m_nNumObjectsPenetrated", false, value);
}
bool GCTakeDamageInfo::GetInTakeDamageFlow() const {
    return GetSchemaValue<bool>(m_ptr, "CTakeDamageInfo", "m_bInTakeDamageFlow");
}
void GCTakeDamageInfo::SetInTakeDamageFlow(bool value) {
    SetSchemaValue(m_ptr, "CTakeDamageInfo", "m_bInTakeDamageFlow", false, value);
}
void* GCTakeDamageInfo::GetPtr() {
    return m_ptr;
}
std::string GCTakeDamageInfo::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCTakeDamageInfo::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCTakeDamageInfo(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCTakeDamageInfo>("CTakeDamageInfo")
        .addConstructor<void (*)(std::string)>()
        .addProperty("DamageForce", &GCTakeDamageInfo::GetDamageForce, &GCTakeDamageInfo::SetDamageForce)
        .addProperty("DamagePosition", &GCTakeDamageInfo::GetDamagePosition, &GCTakeDamageInfo::SetDamagePosition)
        .addProperty("ReportedPosition", &GCTakeDamageInfo::GetReportedPosition, &GCTakeDamageInfo::SetReportedPosition)
        .addProperty("DamageDirection", &GCTakeDamageInfo::GetDamageDirection, &GCTakeDamageInfo::SetDamageDirection)
        .addProperty("Inflictor", &GCTakeDamageInfo::GetInflictor, &GCTakeDamageInfo::SetInflictor)
        .addProperty("Attacker", &GCTakeDamageInfo::GetAttacker, &GCTakeDamageInfo::SetAttacker)
        .addProperty("Ability", &GCTakeDamageInfo::GetAbility, &GCTakeDamageInfo::SetAbility)
        .addProperty("Damage", &GCTakeDamageInfo::GetDamage, &GCTakeDamageInfo::SetDamage)
        .addProperty("TotalledDamage", &GCTakeDamageInfo::GetTotalledDamage, &GCTakeDamageInfo::SetTotalledDamage)
        .addProperty("BitsDamageType", &GCTakeDamageInfo::GetBitsDamageType, &GCTakeDamageInfo::SetBitsDamageType)
        .addProperty("DamageCustom", &GCTakeDamageInfo::GetDamageCustom, &GCTakeDamageInfo::SetDamageCustom)
        .addProperty("AmmoType", &GCTakeDamageInfo::GetAmmoType, &GCTakeDamageInfo::SetAmmoType)
        .addProperty("OriginalDamage", &GCTakeDamageInfo::GetOriginalDamage, &GCTakeDamageInfo::SetOriginalDamage)
        .addProperty("ShouldBleed", &GCTakeDamageInfo::GetShouldBleed, &GCTakeDamageInfo::SetShouldBleed)
        .addProperty("ShouldSpark", &GCTakeDamageInfo::GetShouldSpark, &GCTakeDamageInfo::SetShouldSpark)
        .addProperty("DamageFlags", &GCTakeDamageInfo::GetDamageFlags, &GCTakeDamageInfo::SetDamageFlags)
        .addProperty("NumObjectsPenetrated", &GCTakeDamageInfo::GetNumObjectsPenetrated, &GCTakeDamageInfo::SetNumObjectsPenetrated)
        .addProperty("InTakeDamageFlow", &GCTakeDamageInfo::GetInTakeDamageFlow, &GCTakeDamageInfo::SetInTakeDamageFlow)
        .addFunction("ToPtr", &GCTakeDamageInfo::ToPtr)
        .addFunction("IsValid", &GCTakeDamageInfo::IsValid)
        .endClass();
}
GConceptHistory_t::GConceptHistory_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GConceptHistory_t::GConceptHistory_t(void *ptr) {
    m_ptr = ptr;
}
float GConceptHistory_t::GetTimeSpoken() const {
    return GetSchemaValue<float>(m_ptr, "ConceptHistory_t", "timeSpoken");
}
void GConceptHistory_t::SetTimeSpoken(float value) {
    SetSchemaValue(m_ptr, "ConceptHistory_t", "timeSpoken", true, value);
}
void* GConceptHistory_t::GetPtr() {
    return m_ptr;
}
std::string GConceptHistory_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GConceptHistory_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassConceptHistory_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GConceptHistory_t>("ConceptHistory_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("TimeSpoken", &GConceptHistory_t::GetTimeSpoken, &GConceptHistory_t::SetTimeSpoken)
        .addFunction("ToPtr", &GConceptHistory_t::ToPtr)
        .addFunction("IsValid", &GConceptHistory_t::IsValid)
        .endClass();
}
GCPhysTorque::GCPhysTorque(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCPhysTorque::GCPhysTorque(void *ptr) {
    m_ptr = ptr;
}
Vector GCPhysTorque::GetAxis() const {
    return GetSchemaValue<Vector>(m_ptr, "CPhysTorque", "m_axis");
}
void GCPhysTorque::SetAxis(Vector value) {
    SetSchemaValue(m_ptr, "CPhysTorque", "m_axis", false, value);
}
void* GCPhysTorque::GetPtr() {
    return m_ptr;
}
std::string GCPhysTorque::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCPhysTorque::IsValid() {
    return (m_ptr != nullptr);
}
GCPhysForce GCPhysTorque::GetParent() const {
    GCPhysForce value(m_ptr);
    return value;
}
void GCPhysTorque::SetParent(GCPhysForce value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCPhysTorque(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCPhysTorque>("CPhysTorque")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Axis", &GCPhysTorque::GetAxis, &GCPhysTorque::SetAxis)
        .addProperty("Parent", &GCPhysTorque::GetParent, &GCPhysTorque::SetParent)
        .addFunction("ToPtr", &GCPhysTorque::ToPtr)
        .addFunction("IsValid", &GCPhysTorque::IsValid)
        .endClass();
}
GSummaryTakeDamageInfo_t::GSummaryTakeDamageInfo_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GSummaryTakeDamageInfo_t::GSummaryTakeDamageInfo_t(void *ptr) {
    m_ptr = ptr;
}
int32_t GSummaryTakeDamageInfo_t::GetSummarisedCount() const {
    return GetSchemaValue<int32_t>(m_ptr, "SummaryTakeDamageInfo_t", "nSummarisedCount");
}
void GSummaryTakeDamageInfo_t::SetSummarisedCount(int32_t value) {
    SetSchemaValue(m_ptr, "SummaryTakeDamageInfo_t", "nSummarisedCount", true, value);
}
GCTakeDamageInfo GSummaryTakeDamageInfo_t::GetInfo() const {
    GCTakeDamageInfo value(GetSchemaPtr(m_ptr, "SummaryTakeDamageInfo_t", "info"));
    return value;
}
void GSummaryTakeDamageInfo_t::SetInfo(GCTakeDamageInfo value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Info' is not possible.\n");
}
GCTakeDamageResult GSummaryTakeDamageInfo_t::GetResult() const {
    GCTakeDamageResult value(GetSchemaPtr(m_ptr, "SummaryTakeDamageInfo_t", "result"));
    return value;
}
void GSummaryTakeDamageInfo_t::SetResult(GCTakeDamageResult value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Result' is not possible.\n");
}
GCBaseEntity GSummaryTakeDamageInfo_t::GetTarget() const {
    GCBaseEntity value((void*)(GetSchemaValue<CHandle<CEntityInstance>>(m_ptr, "SummaryTakeDamageInfo_t", "hTarget").Get()));
    return value;
}
void GSummaryTakeDamageInfo_t::SetTarget(GCBaseEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Target' is not possible.\n");
}
void* GSummaryTakeDamageInfo_t::GetPtr() {
    return m_ptr;
}
std::string GSummaryTakeDamageInfo_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GSummaryTakeDamageInfo_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassSummaryTakeDamageInfo_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GSummaryTakeDamageInfo_t>("SummaryTakeDamageInfo_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("SummarisedCount", &GSummaryTakeDamageInfo_t::GetSummarisedCount, &GSummaryTakeDamageInfo_t::SetSummarisedCount)
        .addProperty("Info", &GSummaryTakeDamageInfo_t::GetInfo, &GSummaryTakeDamageInfo_t::SetInfo)
        .addProperty("Result", &GSummaryTakeDamageInfo_t::GetResult, &GSummaryTakeDamageInfo_t::SetResult)
        .addProperty("Target", &GSummaryTakeDamageInfo_t::GetTarget, &GSummaryTakeDamageInfo_t::SetTarget)
        .addFunction("ToPtr", &GSummaryTakeDamageInfo_t::ToPtr)
        .addFunction("IsValid", &GSummaryTakeDamageInfo_t::IsValid)
        .endClass();
}
GCRandSimTimer::GCRandSimTimer(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCRandSimTimer::GCRandSimTimer(void *ptr) {
    m_ptr = ptr;
}
float GCRandSimTimer::GetMinInterval() const {
    return GetSchemaValue<float>(m_ptr, "CRandSimTimer", "m_minInterval");
}
void GCRandSimTimer::SetMinInterval(float value) {
    SetSchemaValue(m_ptr, "CRandSimTimer", "m_minInterval", false, value);
}
float GCRandSimTimer::GetMaxInterval() const {
    return GetSchemaValue<float>(m_ptr, "CRandSimTimer", "m_maxInterval");
}
void GCRandSimTimer::SetMaxInterval(float value) {
    SetSchemaValue(m_ptr, "CRandSimTimer", "m_maxInterval", false, value);
}
void* GCRandSimTimer::GetPtr() {
    return m_ptr;
}
std::string GCRandSimTimer::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCRandSimTimer::IsValid() {
    return (m_ptr != nullptr);
}
GCSimpleSimTimer GCRandSimTimer::GetParent() const {
    GCSimpleSimTimer value(m_ptr);
    return value;
}
void GCRandSimTimer::SetParent(GCSimpleSimTimer value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCRandSimTimer(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCRandSimTimer>("CRandSimTimer")
        .addConstructor<void (*)(std::string)>()
        .addProperty("MinInterval", &GCRandSimTimer::GetMinInterval, &GCRandSimTimer::SetMinInterval)
        .addProperty("MaxInterval", &GCRandSimTimer::GetMaxInterval, &GCRandSimTimer::SetMaxInterval)
        .addProperty("Parent", &GCRandSimTimer::GetParent, &GCRandSimTimer::SetParent)
        .addFunction("ToPtr", &GCRandSimTimer::ToPtr)
        .addFunction("IsValid", &GCRandSimTimer::IsValid)
        .endClass();
}
GCBtNodeComposite::GCBtNodeComposite(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCBtNodeComposite::GCBtNodeComposite(void *ptr) {
    m_ptr = ptr;
}
void* GCBtNodeComposite::GetPtr() {
    return m_ptr;
}
std::string GCBtNodeComposite::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCBtNodeComposite::IsValid() {
    return (m_ptr != nullptr);
}
GCBtNode GCBtNodeComposite::GetParent() const {
    GCBtNode value(m_ptr);
    return value;
}
void GCBtNodeComposite::SetParent(GCBtNode value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCBtNodeComposite(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCBtNodeComposite>("CBtNodeComposite")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCBtNodeComposite::GetParent, &GCBtNodeComposite::SetParent)
        .addFunction("ToPtr", &GCBtNodeComposite::ToPtr)
        .addFunction("IsValid", &GCBtNodeComposite::IsValid)
        .endClass();
}
GCFireCrackerBlast::GCFireCrackerBlast(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCFireCrackerBlast::GCFireCrackerBlast(void *ptr) {
    m_ptr = ptr;
}
void* GCFireCrackerBlast::GetPtr() {
    return m_ptr;
}
std::string GCFireCrackerBlast::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCFireCrackerBlast::IsValid() {
    return (m_ptr != nullptr);
}
GCInferno GCFireCrackerBlast::GetParent() const {
    GCInferno value(m_ptr);
    return value;
}
void GCFireCrackerBlast::SetParent(GCInferno value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCFireCrackerBlast(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCFireCrackerBlast>("CFireCrackerBlast")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCFireCrackerBlast::GetParent, &GCFireCrackerBlast::SetParent)
        .addFunction("ToPtr", &GCFireCrackerBlast::ToPtr)
        .addFunction("IsValid", &GCFireCrackerBlast::IsValid)
        .endClass();
}
Gsndopvarlatchdata_t::Gsndopvarlatchdata_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
Gsndopvarlatchdata_t::Gsndopvarlatchdata_t(void *ptr) {
    m_ptr = ptr;
}
std::string Gsndopvarlatchdata_t::GetStack() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "sndopvarlatchdata_t", "m_iszStack").String();
}
void Gsndopvarlatchdata_t::SetStack(std::string value) {
    SetSchemaValue(m_ptr, "sndopvarlatchdata_t", "m_iszStack", true, CUtlSymbolLarge(value.c_str()));
}
std::string Gsndopvarlatchdata_t::GetOperator() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "sndopvarlatchdata_t", "m_iszOperator").String();
}
void Gsndopvarlatchdata_t::SetOperator(std::string value) {
    SetSchemaValue(m_ptr, "sndopvarlatchdata_t", "m_iszOperator", true, CUtlSymbolLarge(value.c_str()));
}
std::string Gsndopvarlatchdata_t::GetOpvar() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "sndopvarlatchdata_t", "m_iszOpvar").String();
}
void Gsndopvarlatchdata_t::SetOpvar(std::string value) {
    SetSchemaValue(m_ptr, "sndopvarlatchdata_t", "m_iszOpvar", true, CUtlSymbolLarge(value.c_str()));
}
float Gsndopvarlatchdata_t::GetVal() const {
    return GetSchemaValue<float>(m_ptr, "sndopvarlatchdata_t", "m_flVal");
}
void Gsndopvarlatchdata_t::SetVal(float value) {
    SetSchemaValue(m_ptr, "sndopvarlatchdata_t", "m_flVal", true, value);
}
Vector Gsndopvarlatchdata_t::GetPos() const {
    return GetSchemaValue<Vector>(m_ptr, "sndopvarlatchdata_t", "m_vPos");
}
void Gsndopvarlatchdata_t::SetPos(Vector value) {
    SetSchemaValue(m_ptr, "sndopvarlatchdata_t", "m_vPos", true, value);
}
void* Gsndopvarlatchdata_t::GetPtr() {
    return m_ptr;
}
std::string Gsndopvarlatchdata_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool Gsndopvarlatchdata_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClasssndopvarlatchdata_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<Gsndopvarlatchdata_t>("sndopvarlatchdata_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Stack", &Gsndopvarlatchdata_t::GetStack, &Gsndopvarlatchdata_t::SetStack)
        .addProperty("Operator", &Gsndopvarlatchdata_t::GetOperator, &Gsndopvarlatchdata_t::SetOperator)
        .addProperty("Opvar", &Gsndopvarlatchdata_t::GetOpvar, &Gsndopvarlatchdata_t::SetOpvar)
        .addProperty("Val", &Gsndopvarlatchdata_t::GetVal, &Gsndopvarlatchdata_t::SetVal)
        .addProperty("Pos", &Gsndopvarlatchdata_t::GetPos, &Gsndopvarlatchdata_t::SetPos)
        .addFunction("ToPtr", &Gsndopvarlatchdata_t::ToPtr)
        .addFunction("IsValid", &Gsndopvarlatchdata_t::IsValid)
        .endClass();
}
GCCSGO_TeamSelectTerroristPosition::GCCSGO_TeamSelectTerroristPosition(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCCSGO_TeamSelectTerroristPosition::GCCSGO_TeamSelectTerroristPosition(void *ptr) {
    m_ptr = ptr;
}
void* GCCSGO_TeamSelectTerroristPosition::GetPtr() {
    return m_ptr;
}
std::string GCCSGO_TeamSelectTerroristPosition::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCCSGO_TeamSelectTerroristPosition::IsValid() {
    return (m_ptr != nullptr);
}
GCCSGO_TeamSelectCharacterPosition GCCSGO_TeamSelectTerroristPosition::GetParent() const {
    GCCSGO_TeamSelectCharacterPosition value(m_ptr);
    return value;
}
void GCCSGO_TeamSelectTerroristPosition::SetParent(GCCSGO_TeamSelectCharacterPosition value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCCSGO_TeamSelectTerroristPosition(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCCSGO_TeamSelectTerroristPosition>("CCSGO_TeamSelectTerroristPosition")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCCSGO_TeamSelectTerroristPosition::GetParent, &GCCSGO_TeamSelectTerroristPosition::SetParent)
        .addFunction("ToPtr", &GCCSGO_TeamSelectTerroristPosition::ToPtr)
        .addFunction("IsValid", &GCCSGO_TeamSelectTerroristPosition::IsValid)
        .endClass();
}
GCAI_ExpresserWithFollowup::GCAI_ExpresserWithFollowup(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCAI_ExpresserWithFollowup::GCAI_ExpresserWithFollowup(void *ptr) {
    m_ptr = ptr;
}
GResponseFollowup GCAI_ExpresserWithFollowup::GetPostponedFollowup() const {
    GResponseFollowup value(*(void**)GetSchemaPtr(m_ptr, "CAI_ExpresserWithFollowup", "m_pPostponedFollowup"));
    return value;
}
void GCAI_ExpresserWithFollowup::SetPostponedFollowup(GResponseFollowup value) {
    SetSchemaValue(m_ptr, "CAI_ExpresserWithFollowup","m_pPostponedFollowup", false, (char*)value.GetPtr());
}
void* GCAI_ExpresserWithFollowup::GetPtr() {
    return m_ptr;
}
std::string GCAI_ExpresserWithFollowup::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCAI_ExpresserWithFollowup::IsValid() {
    return (m_ptr != nullptr);
}
GCAI_Expresser GCAI_ExpresserWithFollowup::GetParent() const {
    GCAI_Expresser value(m_ptr);
    return value;
}
void GCAI_ExpresserWithFollowup::SetParent(GCAI_Expresser value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCAI_ExpresserWithFollowup(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCAI_ExpresserWithFollowup>("CAI_ExpresserWithFollowup")
        .addConstructor<void (*)(std::string)>()
        .addProperty("PostponedFollowup", &GCAI_ExpresserWithFollowup::GetPostponedFollowup, &GCAI_ExpresserWithFollowup::SetPostponedFollowup)
        .addProperty("Parent", &GCAI_ExpresserWithFollowup::GetParent, &GCAI_ExpresserWithFollowup::SetParent)
        .addFunction("ToPtr", &GCAI_ExpresserWithFollowup::ToPtr)
        .addFunction("IsValid", &GCAI_ExpresserWithFollowup::IsValid)
        .endClass();
}
GCNavVolumeMarkupVolume::GCNavVolumeMarkupVolume(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCNavVolumeMarkupVolume::GCNavVolumeMarkupVolume(void *ptr) {
    m_ptr = ptr;
}
void* GCNavVolumeMarkupVolume::GetPtr() {
    return m_ptr;
}
std::string GCNavVolumeMarkupVolume::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCNavVolumeMarkupVolume::IsValid() {
    return (m_ptr != nullptr);
}
GCNavVolume GCNavVolumeMarkupVolume::GetParent() const {
    GCNavVolume value(m_ptr);
    return value;
}
void GCNavVolumeMarkupVolume::SetParent(GCNavVolume value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCNavVolumeMarkupVolume(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCNavVolumeMarkupVolume>("CNavVolumeMarkupVolume")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCNavVolumeMarkupVolume::GetParent, &GCNavVolumeMarkupVolume::SetParent)
        .addFunction("ToPtr", &GCNavVolumeMarkupVolume::ToPtr)
        .addFunction("IsValid", &GCNavVolumeMarkupVolume::IsValid)
        .endClass();
}
GQuestProgress::GQuestProgress(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GQuestProgress::GQuestProgress(void *ptr) {
    m_ptr = ptr;
}
void* GQuestProgress::GetPtr() {
    return m_ptr;
}
std::string GQuestProgress::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GQuestProgress::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassQuestProgress(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GQuestProgress>("QuestProgress")
        .addConstructor<void (*)(std::string)>()
        .addFunction("ToPtr", &GQuestProgress::ToPtr)
        .addFunction("IsValid", &GQuestProgress::IsValid)
        .endClass();
}
Glerpdata_t::Glerpdata_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
Glerpdata_t::Glerpdata_t(void *ptr) {
    m_ptr = ptr;
}
GCBaseEntity Glerpdata_t::GetEnt() const {
    GCBaseEntity value((void*)(GetSchemaValue<CHandle<CEntityInstance>>(m_ptr, "lerpdata_t", "m_hEnt").Get()));
    return value;
}
void Glerpdata_t::SetEnt(GCBaseEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Ent' is not possible.\n");
}
uint64_t Glerpdata_t::GetMoveType() const {
    return GetSchemaValue<uint64_t>(m_ptr, "lerpdata_t", "m_MoveType");
}
void Glerpdata_t::SetMoveType(uint64_t value) {
    SetSchemaValue(m_ptr, "lerpdata_t", "m_MoveType", true, value);
}
float Glerpdata_t::GetStartTime() const {
    return GetSchemaValue<float>(m_ptr, "lerpdata_t", "m_flStartTime");
}
void Glerpdata_t::SetStartTime(float value) {
    SetSchemaValue(m_ptr, "lerpdata_t", "m_flStartTime", true, value);
}
Vector Glerpdata_t::GetStartOrigin() const {
    return GetSchemaValue<Vector>(m_ptr, "lerpdata_t", "m_vecStartOrigin");
}
void Glerpdata_t::SetStartOrigin(Vector value) {
    SetSchemaValue(m_ptr, "lerpdata_t", "m_vecStartOrigin", true, value);
}
GParticleIndex_t Glerpdata_t::GetFXIndex() const {
    GParticleIndex_t value(GetSchemaPtr(m_ptr, "lerpdata_t", "m_nFXIndex"));
    return value;
}
void Glerpdata_t::SetFXIndex(GParticleIndex_t value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'FXIndex' is not possible.\n");
}
void* Glerpdata_t::GetPtr() {
    return m_ptr;
}
std::string Glerpdata_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool Glerpdata_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClasslerpdata_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<Glerpdata_t>("lerpdata_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Ent", &Glerpdata_t::GetEnt, &Glerpdata_t::SetEnt)
        .addProperty("MoveType", &Glerpdata_t::GetMoveType, &Glerpdata_t::SetMoveType)
        .addProperty("StartTime", &Glerpdata_t::GetStartTime, &Glerpdata_t::SetStartTime)
        .addProperty("StartOrigin", &Glerpdata_t::GetStartOrigin, &Glerpdata_t::SetStartOrigin)
        .addProperty("FXIndex", &Glerpdata_t::GetFXIndex, &Glerpdata_t::SetFXIndex)
        .addFunction("ToPtr", &Glerpdata_t::ToPtr)
        .addFunction("IsValid", &Glerpdata_t::IsValid)
        .endClass();
}
GCMultiplayer_Expresser::GCMultiplayer_Expresser(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCMultiplayer_Expresser::GCMultiplayer_Expresser(void *ptr) {
    m_ptr = ptr;
}
bool GCMultiplayer_Expresser::GetAllowMultipleScenes() const {
    return GetSchemaValue<bool>(m_ptr, "CMultiplayer_Expresser", "m_bAllowMultipleScenes");
}
void GCMultiplayer_Expresser::SetAllowMultipleScenes(bool value) {
    SetSchemaValue(m_ptr, "CMultiplayer_Expresser", "m_bAllowMultipleScenes", false, value);
}
void* GCMultiplayer_Expresser::GetPtr() {
    return m_ptr;
}
std::string GCMultiplayer_Expresser::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCMultiplayer_Expresser::IsValid() {
    return (m_ptr != nullptr);
}
GCAI_ExpresserWithFollowup GCMultiplayer_Expresser::GetParent() const {
    GCAI_ExpresserWithFollowup value(m_ptr);
    return value;
}
void GCMultiplayer_Expresser::SetParent(GCAI_ExpresserWithFollowup value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCMultiplayer_Expresser(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCMultiplayer_Expresser>("CMultiplayer_Expresser")
        .addConstructor<void (*)(std::string)>()
        .addProperty("AllowMultipleScenes", &GCMultiplayer_Expresser::GetAllowMultipleScenes, &GCMultiplayer_Expresser::SetAllowMultipleScenes)
        .addProperty("Parent", &GCMultiplayer_Expresser::GetParent, &GCMultiplayer_Expresser::SetParent)
        .addFunction("ToPtr", &GCMultiplayer_Expresser::ToPtr)
        .addFunction("IsValid", &GCMultiplayer_Expresser::IsValid)
        .endClass();
}
GCTakeDamageSummaryScopeGuard::GCTakeDamageSummaryScopeGuard(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCTakeDamageSummaryScopeGuard::GCTakeDamageSummaryScopeGuard(void *ptr) {
    m_ptr = ptr;
}
std::vector<GSummaryTakeDamageInfo_t*> GCTakeDamageSummaryScopeGuard::GetSummaries() const {
    CUtlVector<GSummaryTakeDamageInfo_t*>* vec = GetSchemaValue<CUtlVector<GSummaryTakeDamageInfo_t*>*>(m_ptr, "CTakeDamageSummaryScopeGuard", "m_vecSummaries"); std::vector<GSummaryTakeDamageInfo_t*> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCTakeDamageSummaryScopeGuard::SetSummaries(std::vector<GSummaryTakeDamageInfo_t*> value) {
    SetSchemaValueCUtlVector<GSummaryTakeDamageInfo_t*>(m_ptr, "CTakeDamageSummaryScopeGuard", "m_vecSummaries", false, value);
}
void* GCTakeDamageSummaryScopeGuard::GetPtr() {
    return m_ptr;
}
std::string GCTakeDamageSummaryScopeGuard::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCTakeDamageSummaryScopeGuard::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCTakeDamageSummaryScopeGuard(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCTakeDamageSummaryScopeGuard>("CTakeDamageSummaryScopeGuard")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Summaries", &GCTakeDamageSummaryScopeGuard::GetSummaries, &GCTakeDamageSummaryScopeGuard::SetSummaries)
        .addFunction("ToPtr", &GCTakeDamageSummaryScopeGuard::ToPtr)
        .addFunction("IsValid", &GCTakeDamageSummaryScopeGuard::IsValid)
        .endClass();
}
GCWeaponSawedoff::GCWeaponSawedoff(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCWeaponSawedoff::GCWeaponSawedoff(void *ptr) {
    m_ptr = ptr;
}
void* GCWeaponSawedoff::GetPtr() {
    return m_ptr;
}
std::string GCWeaponSawedoff::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCWeaponSawedoff::IsValid() {
    return (m_ptr != nullptr);
}
GCCSWeaponBase GCWeaponSawedoff::GetParent() const {
    GCCSWeaponBase value(m_ptr);
    return value;
}
void GCWeaponSawedoff::SetParent(GCCSWeaponBase value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCWeaponSawedoff(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCWeaponSawedoff>("CWeaponSawedoff")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCWeaponSawedoff::GetParent, &GCWeaponSawedoff::SetParent)
        .addFunction("ToPtr", &GCWeaponSawedoff::ToPtr)
        .addFunction("IsValid", &GCWeaponSawedoff::IsValid)
        .endClass();
}
GCCSPlayer_MovementServices::GCCSPlayer_MovementServices(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCCSPlayer_MovementServices::GCCSPlayer_MovementServices(void *ptr) {
    m_ptr = ptr;
}
float GCCSPlayer_MovementServices::GetMaxFallVelocity() const {
    return GetSchemaValue<float>(m_ptr, "CCSPlayer_MovementServices", "m_flMaxFallVelocity");
}
void GCCSPlayer_MovementServices::SetMaxFallVelocity(float value) {
    SetSchemaValue(m_ptr, "CCSPlayer_MovementServices", "m_flMaxFallVelocity", false, value);
}
Vector GCCSPlayer_MovementServices::GetLadderNormal() const {
    return GetSchemaValue<Vector>(m_ptr, "CCSPlayer_MovementServices", "m_vecLadderNormal");
}
void GCCSPlayer_MovementServices::SetLadderNormal(Vector value) {
    SetSchemaValue(m_ptr, "CCSPlayer_MovementServices", "m_vecLadderNormal", false, value);
}
int32_t GCCSPlayer_MovementServices::GetLadderSurfacePropIndex() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSPlayer_MovementServices", "m_nLadderSurfacePropIndex");
}
void GCCSPlayer_MovementServices::SetLadderSurfacePropIndex(int32_t value) {
    SetSchemaValue(m_ptr, "CCSPlayer_MovementServices", "m_nLadderSurfacePropIndex", false, value);
}
float GCCSPlayer_MovementServices::GetDuckAmount() const {
    return GetSchemaValue<float>(m_ptr, "CCSPlayer_MovementServices", "m_flDuckAmount");
}
void GCCSPlayer_MovementServices::SetDuckAmount(float value) {
    SetSchemaValue(m_ptr, "CCSPlayer_MovementServices", "m_flDuckAmount", false, value);
}
float GCCSPlayer_MovementServices::GetDuckSpeed() const {
    return GetSchemaValue<float>(m_ptr, "CCSPlayer_MovementServices", "m_flDuckSpeed");
}
void GCCSPlayer_MovementServices::SetDuckSpeed(float value) {
    SetSchemaValue(m_ptr, "CCSPlayer_MovementServices", "m_flDuckSpeed", false, value);
}
bool GCCSPlayer_MovementServices::GetDuckOverride() const {
    return GetSchemaValue<bool>(m_ptr, "CCSPlayer_MovementServices", "m_bDuckOverride");
}
void GCCSPlayer_MovementServices::SetDuckOverride(bool value) {
    SetSchemaValue(m_ptr, "CCSPlayer_MovementServices", "m_bDuckOverride", false, value);
}
bool GCCSPlayer_MovementServices::GetDesiresDuck() const {
    return GetSchemaValue<bool>(m_ptr, "CCSPlayer_MovementServices", "m_bDesiresDuck");
}
void GCCSPlayer_MovementServices::SetDesiresDuck(bool value) {
    SetSchemaValue(m_ptr, "CCSPlayer_MovementServices", "m_bDesiresDuck", false, value);
}
float GCCSPlayer_MovementServices::GetDuckOffset() const {
    return GetSchemaValue<float>(m_ptr, "CCSPlayer_MovementServices", "m_flDuckOffset");
}
void GCCSPlayer_MovementServices::SetDuckOffset(float value) {
    SetSchemaValue(m_ptr, "CCSPlayer_MovementServices", "m_flDuckOffset", false, value);
}
uint32_t GCCSPlayer_MovementServices::GetDuckTimeMsecs() const {
    return GetSchemaValue<uint32_t>(m_ptr, "CCSPlayer_MovementServices", "m_nDuckTimeMsecs");
}
void GCCSPlayer_MovementServices::SetDuckTimeMsecs(uint32_t value) {
    SetSchemaValue(m_ptr, "CCSPlayer_MovementServices", "m_nDuckTimeMsecs", false, value);
}
uint32_t GCCSPlayer_MovementServices::GetDuckJumpTimeMsecs() const {
    return GetSchemaValue<uint32_t>(m_ptr, "CCSPlayer_MovementServices", "m_nDuckJumpTimeMsecs");
}
void GCCSPlayer_MovementServices::SetDuckJumpTimeMsecs(uint32_t value) {
    SetSchemaValue(m_ptr, "CCSPlayer_MovementServices", "m_nDuckJumpTimeMsecs", false, value);
}
uint32_t GCCSPlayer_MovementServices::GetJumpTimeMsecs() const {
    return GetSchemaValue<uint32_t>(m_ptr, "CCSPlayer_MovementServices", "m_nJumpTimeMsecs");
}
void GCCSPlayer_MovementServices::SetJumpTimeMsecs(uint32_t value) {
    SetSchemaValue(m_ptr, "CCSPlayer_MovementServices", "m_nJumpTimeMsecs", false, value);
}
float GCCSPlayer_MovementServices::GetLastDuckTime() const {
    return GetSchemaValue<float>(m_ptr, "CCSPlayer_MovementServices", "m_flLastDuckTime");
}
void GCCSPlayer_MovementServices::SetLastDuckTime(float value) {
    SetSchemaValue(m_ptr, "CCSPlayer_MovementServices", "m_flLastDuckTime", false, value);
}
Vector2D GCCSPlayer_MovementServices::GetLastPositionAtFullCrouchSpeed() const {
    return GetSchemaValue<Vector2D>(m_ptr, "CCSPlayer_MovementServices", "m_vecLastPositionAtFullCrouchSpeed");
}
void GCCSPlayer_MovementServices::SetLastPositionAtFullCrouchSpeed(Vector2D value) {
    SetSchemaValue(m_ptr, "CCSPlayer_MovementServices", "m_vecLastPositionAtFullCrouchSpeed", false, value);
}
bool GCCSPlayer_MovementServices::GetDuckUntilOnGround() const {
    return GetSchemaValue<bool>(m_ptr, "CCSPlayer_MovementServices", "m_duckUntilOnGround");
}
void GCCSPlayer_MovementServices::SetDuckUntilOnGround(bool value) {
    SetSchemaValue(m_ptr, "CCSPlayer_MovementServices", "m_duckUntilOnGround", false, value);
}
bool GCCSPlayer_MovementServices::GetHasWalkMovedSinceLastJump() const {
    return GetSchemaValue<bool>(m_ptr, "CCSPlayer_MovementServices", "m_bHasWalkMovedSinceLastJump");
}
void GCCSPlayer_MovementServices::SetHasWalkMovedSinceLastJump(bool value) {
    SetSchemaValue(m_ptr, "CCSPlayer_MovementServices", "m_bHasWalkMovedSinceLastJump", false, value);
}
bool GCCSPlayer_MovementServices::GetInStuckTest() const {
    return GetSchemaValue<bool>(m_ptr, "CCSPlayer_MovementServices", "m_bInStuckTest");
}
void GCCSPlayer_MovementServices::SetInStuckTest(bool value) {
    SetSchemaValue(m_ptr, "CCSPlayer_MovementServices", "m_bInStuckTest", false, value);
}
int32_t GCCSPlayer_MovementServices::GetTraceCount() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSPlayer_MovementServices", "m_nTraceCount");
}
void GCCSPlayer_MovementServices::SetTraceCount(int32_t value) {
    SetSchemaValue(m_ptr, "CCSPlayer_MovementServices", "m_nTraceCount", false, value);
}
int32_t GCCSPlayer_MovementServices::GetStuckLast() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSPlayer_MovementServices", "m_StuckLast");
}
void GCCSPlayer_MovementServices::SetStuckLast(int32_t value) {
    SetSchemaValue(m_ptr, "CCSPlayer_MovementServices", "m_StuckLast", false, value);
}
bool GCCSPlayer_MovementServices::GetSpeedCropped() const {
    return GetSchemaValue<bool>(m_ptr, "CCSPlayer_MovementServices", "m_bSpeedCropped");
}
void GCCSPlayer_MovementServices::SetSpeedCropped(bool value) {
    SetSchemaValue(m_ptr, "CCSPlayer_MovementServices", "m_bSpeedCropped", false, value);
}
int32_t GCCSPlayer_MovementServices::GetOldWaterLevel() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSPlayer_MovementServices", "m_nOldWaterLevel");
}
void GCCSPlayer_MovementServices::SetOldWaterLevel(int32_t value) {
    SetSchemaValue(m_ptr, "CCSPlayer_MovementServices", "m_nOldWaterLevel", false, value);
}
float GCCSPlayer_MovementServices::GetWaterEntryTime() const {
    return GetSchemaValue<float>(m_ptr, "CCSPlayer_MovementServices", "m_flWaterEntryTime");
}
void GCCSPlayer_MovementServices::SetWaterEntryTime(float value) {
    SetSchemaValue(m_ptr, "CCSPlayer_MovementServices", "m_flWaterEntryTime", false, value);
}
Vector GCCSPlayer_MovementServices::GetForward() const {
    return GetSchemaValue<Vector>(m_ptr, "CCSPlayer_MovementServices", "m_vecForward");
}
void GCCSPlayer_MovementServices::SetForward(Vector value) {
    SetSchemaValue(m_ptr, "CCSPlayer_MovementServices", "m_vecForward", false, value);
}
Vector GCCSPlayer_MovementServices::GetLeft() const {
    return GetSchemaValue<Vector>(m_ptr, "CCSPlayer_MovementServices", "m_vecLeft");
}
void GCCSPlayer_MovementServices::SetLeft(Vector value) {
    SetSchemaValue(m_ptr, "CCSPlayer_MovementServices", "m_vecLeft", false, value);
}
Vector GCCSPlayer_MovementServices::GetUp() const {
    return GetSchemaValue<Vector>(m_ptr, "CCSPlayer_MovementServices", "m_vecUp");
}
void GCCSPlayer_MovementServices::SetUp(Vector value) {
    SetSchemaValue(m_ptr, "CCSPlayer_MovementServices", "m_vecUp", false, value);
}
int32_t GCCSPlayer_MovementServices::GetGameCodeHasMovedPlayerAfterCommand() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSPlayer_MovementServices", "m_nGameCodeHasMovedPlayerAfterCommand");
}
void GCCSPlayer_MovementServices::SetGameCodeHasMovedPlayerAfterCommand(int32_t value) {
    SetSchemaValue(m_ptr, "CCSPlayer_MovementServices", "m_nGameCodeHasMovedPlayerAfterCommand", false, value);
}
bool GCCSPlayer_MovementServices::GetMadeFootstepNoise() const {
    return GetSchemaValue<bool>(m_ptr, "CCSPlayer_MovementServices", "m_bMadeFootstepNoise");
}
void GCCSPlayer_MovementServices::SetMadeFootstepNoise(bool value) {
    SetSchemaValue(m_ptr, "CCSPlayer_MovementServices", "m_bMadeFootstepNoise", false, value);
}
int32_t GCCSPlayer_MovementServices::GetFootsteps() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSPlayer_MovementServices", "m_iFootsteps");
}
void GCCSPlayer_MovementServices::SetFootsteps(int32_t value) {
    SetSchemaValue(m_ptr, "CCSPlayer_MovementServices", "m_iFootsteps", false, value);
}
bool GCCSPlayer_MovementServices::GetOldJumpPressed() const {
    return GetSchemaValue<bool>(m_ptr, "CCSPlayer_MovementServices", "m_bOldJumpPressed");
}
void GCCSPlayer_MovementServices::SetOldJumpPressed(bool value) {
    SetSchemaValue(m_ptr, "CCSPlayer_MovementServices", "m_bOldJumpPressed", false, value);
}
float GCCSPlayer_MovementServices::GetJumpPressedTime() const {
    return GetSchemaValue<float>(m_ptr, "CCSPlayer_MovementServices", "m_flJumpPressedTime");
}
void GCCSPlayer_MovementServices::SetJumpPressedTime(float value) {
    SetSchemaValue(m_ptr, "CCSPlayer_MovementServices", "m_flJumpPressedTime", false, value);
}
float GCCSPlayer_MovementServices::GetJumpUntil() const {
    return GetSchemaValue<float>(m_ptr, "CCSPlayer_MovementServices", "m_flJumpUntil");
}
void GCCSPlayer_MovementServices::SetJumpUntil(float value) {
    SetSchemaValue(m_ptr, "CCSPlayer_MovementServices", "m_flJumpUntil", false, value);
}
float GCCSPlayer_MovementServices::GetJumpVel() const {
    return GetSchemaValue<float>(m_ptr, "CCSPlayer_MovementServices", "m_flJumpVel");
}
void GCCSPlayer_MovementServices::SetJumpVel(float value) {
    SetSchemaValue(m_ptr, "CCSPlayer_MovementServices", "m_flJumpVel", false, value);
}
float GCCSPlayer_MovementServices::GetStashGrenadeParameterWhen() const {
    return GetSchemaValue<float>(m_ptr, "CCSPlayer_MovementServices", "m_fStashGrenadeParameterWhen");
}
void GCCSPlayer_MovementServices::SetStashGrenadeParameterWhen(float value) {
    SetSchemaValue(m_ptr, "CCSPlayer_MovementServices", "m_fStashGrenadeParameterWhen", false, value);
}
uint64_t GCCSPlayer_MovementServices::GetButtonDownMaskPrev() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CCSPlayer_MovementServices", "m_nButtonDownMaskPrev");
}
void GCCSPlayer_MovementServices::SetButtonDownMaskPrev(uint64_t value) {
    SetSchemaValue(m_ptr, "CCSPlayer_MovementServices", "m_nButtonDownMaskPrev", false, value);
}
float GCCSPlayer_MovementServices::GetOffsetTickCompleteTime() const {
    return GetSchemaValue<float>(m_ptr, "CCSPlayer_MovementServices", "m_flOffsetTickCompleteTime");
}
void GCCSPlayer_MovementServices::SetOffsetTickCompleteTime(float value) {
    SetSchemaValue(m_ptr, "CCSPlayer_MovementServices", "m_flOffsetTickCompleteTime", false, value);
}
float GCCSPlayer_MovementServices::GetOffsetTickStashedSpeed() const {
    return GetSchemaValue<float>(m_ptr, "CCSPlayer_MovementServices", "m_flOffsetTickStashedSpeed");
}
void GCCSPlayer_MovementServices::SetOffsetTickStashedSpeed(float value) {
    SetSchemaValue(m_ptr, "CCSPlayer_MovementServices", "m_flOffsetTickStashedSpeed", false, value);
}
float GCCSPlayer_MovementServices::GetStamina() const {
    return GetSchemaValue<float>(m_ptr, "CCSPlayer_MovementServices", "m_flStamina");
}
void GCCSPlayer_MovementServices::SetStamina(float value) {
    SetSchemaValue(m_ptr, "CCSPlayer_MovementServices", "m_flStamina", false, value);
}
float GCCSPlayer_MovementServices::GetHeightAtJumpStart() const {
    return GetSchemaValue<float>(m_ptr, "CCSPlayer_MovementServices", "m_flHeightAtJumpStart");
}
void GCCSPlayer_MovementServices::SetHeightAtJumpStart(float value) {
    SetSchemaValue(m_ptr, "CCSPlayer_MovementServices", "m_flHeightAtJumpStart", false, value);
}
float GCCSPlayer_MovementServices::GetMaxJumpHeightThisJump() const {
    return GetSchemaValue<float>(m_ptr, "CCSPlayer_MovementServices", "m_flMaxJumpHeightThisJump");
}
void GCCSPlayer_MovementServices::SetMaxJumpHeightThisJump(float value) {
    SetSchemaValue(m_ptr, "CCSPlayer_MovementServices", "m_flMaxJumpHeightThisJump", false, value);
}
void* GCCSPlayer_MovementServices::GetPtr() {
    return m_ptr;
}
std::string GCCSPlayer_MovementServices::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCCSPlayer_MovementServices::IsValid() {
    return (m_ptr != nullptr);
}
GCPlayer_MovementServices_Humanoid GCCSPlayer_MovementServices::GetParent() const {
    GCPlayer_MovementServices_Humanoid value(m_ptr);
    return value;
}
void GCCSPlayer_MovementServices::SetParent(GCPlayer_MovementServices_Humanoid value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCCSPlayer_MovementServices(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCCSPlayer_MovementServices>("CCSPlayer_MovementServices")
        .addConstructor<void (*)(std::string)>()
        .addProperty("MaxFallVelocity", &GCCSPlayer_MovementServices::GetMaxFallVelocity, &GCCSPlayer_MovementServices::SetMaxFallVelocity)
        .addProperty("LadderNormal", &GCCSPlayer_MovementServices::GetLadderNormal, &GCCSPlayer_MovementServices::SetLadderNormal)
        .addProperty("LadderSurfacePropIndex", &GCCSPlayer_MovementServices::GetLadderSurfacePropIndex, &GCCSPlayer_MovementServices::SetLadderSurfacePropIndex)
        .addProperty("DuckAmount", &GCCSPlayer_MovementServices::GetDuckAmount, &GCCSPlayer_MovementServices::SetDuckAmount)
        .addProperty("DuckSpeed", &GCCSPlayer_MovementServices::GetDuckSpeed, &GCCSPlayer_MovementServices::SetDuckSpeed)
        .addProperty("DuckOverride", &GCCSPlayer_MovementServices::GetDuckOverride, &GCCSPlayer_MovementServices::SetDuckOverride)
        .addProperty("DesiresDuck", &GCCSPlayer_MovementServices::GetDesiresDuck, &GCCSPlayer_MovementServices::SetDesiresDuck)
        .addProperty("DuckOffset", &GCCSPlayer_MovementServices::GetDuckOffset, &GCCSPlayer_MovementServices::SetDuckOffset)
        .addProperty("DuckTimeMsecs", &GCCSPlayer_MovementServices::GetDuckTimeMsecs, &GCCSPlayer_MovementServices::SetDuckTimeMsecs)
        .addProperty("DuckJumpTimeMsecs", &GCCSPlayer_MovementServices::GetDuckJumpTimeMsecs, &GCCSPlayer_MovementServices::SetDuckJumpTimeMsecs)
        .addProperty("JumpTimeMsecs", &GCCSPlayer_MovementServices::GetJumpTimeMsecs, &GCCSPlayer_MovementServices::SetJumpTimeMsecs)
        .addProperty("LastDuckTime", &GCCSPlayer_MovementServices::GetLastDuckTime, &GCCSPlayer_MovementServices::SetLastDuckTime)
        .addProperty("LastPositionAtFullCrouchSpeed", &GCCSPlayer_MovementServices::GetLastPositionAtFullCrouchSpeed, &GCCSPlayer_MovementServices::SetLastPositionAtFullCrouchSpeed)
        .addProperty("DuckUntilOnGround", &GCCSPlayer_MovementServices::GetDuckUntilOnGround, &GCCSPlayer_MovementServices::SetDuckUntilOnGround)
        .addProperty("HasWalkMovedSinceLastJump", &GCCSPlayer_MovementServices::GetHasWalkMovedSinceLastJump, &GCCSPlayer_MovementServices::SetHasWalkMovedSinceLastJump)
        .addProperty("InStuckTest", &GCCSPlayer_MovementServices::GetInStuckTest, &GCCSPlayer_MovementServices::SetInStuckTest)
        .addProperty("TraceCount", &GCCSPlayer_MovementServices::GetTraceCount, &GCCSPlayer_MovementServices::SetTraceCount)
        .addProperty("StuckLast", &GCCSPlayer_MovementServices::GetStuckLast, &GCCSPlayer_MovementServices::SetStuckLast)
        .addProperty("SpeedCropped", &GCCSPlayer_MovementServices::GetSpeedCropped, &GCCSPlayer_MovementServices::SetSpeedCropped)
        .addProperty("OldWaterLevel", &GCCSPlayer_MovementServices::GetOldWaterLevel, &GCCSPlayer_MovementServices::SetOldWaterLevel)
        .addProperty("WaterEntryTime", &GCCSPlayer_MovementServices::GetWaterEntryTime, &GCCSPlayer_MovementServices::SetWaterEntryTime)
        .addProperty("Forward", &GCCSPlayer_MovementServices::GetForward, &GCCSPlayer_MovementServices::SetForward)
        .addProperty("Left", &GCCSPlayer_MovementServices::GetLeft, &GCCSPlayer_MovementServices::SetLeft)
        .addProperty("Up", &GCCSPlayer_MovementServices::GetUp, &GCCSPlayer_MovementServices::SetUp)
        .addProperty("GameCodeHasMovedPlayerAfterCommand", &GCCSPlayer_MovementServices::GetGameCodeHasMovedPlayerAfterCommand, &GCCSPlayer_MovementServices::SetGameCodeHasMovedPlayerAfterCommand)
        .addProperty("MadeFootstepNoise", &GCCSPlayer_MovementServices::GetMadeFootstepNoise, &GCCSPlayer_MovementServices::SetMadeFootstepNoise)
        .addProperty("Footsteps", &GCCSPlayer_MovementServices::GetFootsteps, &GCCSPlayer_MovementServices::SetFootsteps)
        .addProperty("OldJumpPressed", &GCCSPlayer_MovementServices::GetOldJumpPressed, &GCCSPlayer_MovementServices::SetOldJumpPressed)
        .addProperty("JumpPressedTime", &GCCSPlayer_MovementServices::GetJumpPressedTime, &GCCSPlayer_MovementServices::SetJumpPressedTime)
        .addProperty("JumpUntil", &GCCSPlayer_MovementServices::GetJumpUntil, &GCCSPlayer_MovementServices::SetJumpUntil)
        .addProperty("JumpVel", &GCCSPlayer_MovementServices::GetJumpVel, &GCCSPlayer_MovementServices::SetJumpVel)
        .addProperty("StashGrenadeParameterWhen", &GCCSPlayer_MovementServices::GetStashGrenadeParameterWhen, &GCCSPlayer_MovementServices::SetStashGrenadeParameterWhen)
        .addProperty("ButtonDownMaskPrev", &GCCSPlayer_MovementServices::GetButtonDownMaskPrev, &GCCSPlayer_MovementServices::SetButtonDownMaskPrev)
        .addProperty("OffsetTickCompleteTime", &GCCSPlayer_MovementServices::GetOffsetTickCompleteTime, &GCCSPlayer_MovementServices::SetOffsetTickCompleteTime)
        .addProperty("OffsetTickStashedSpeed", &GCCSPlayer_MovementServices::GetOffsetTickStashedSpeed, &GCCSPlayer_MovementServices::SetOffsetTickStashedSpeed)
        .addProperty("Stamina", &GCCSPlayer_MovementServices::GetStamina, &GCCSPlayer_MovementServices::SetStamina)
        .addProperty("HeightAtJumpStart", &GCCSPlayer_MovementServices::GetHeightAtJumpStart, &GCCSPlayer_MovementServices::SetHeightAtJumpStart)
        .addProperty("MaxJumpHeightThisJump", &GCCSPlayer_MovementServices::GetMaxJumpHeightThisJump, &GCCSPlayer_MovementServices::SetMaxJumpHeightThisJump)
        .addProperty("Parent", &GCCSPlayer_MovementServices::GetParent, &GCCSPlayer_MovementServices::SetParent)
        .addFunction("ToPtr", &GCCSPlayer_MovementServices::ToPtr)
        .addFunction("IsValid", &GCCSPlayer_MovementServices::IsValid)
        .endClass();
}
GCNavHullVData::GCNavHullVData(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCNavHullVData::GCNavHullVData(void *ptr) {
    m_ptr = ptr;
}
bool GCNavHullVData::GetAgentEnabled() const {
    return GetSchemaValue<bool>(m_ptr, "CNavHullVData", "m_bAgentEnabled");
}
void GCNavHullVData::SetAgentEnabled(bool value) {
    SetSchemaValue(m_ptr, "CNavHullVData", "m_bAgentEnabled", false, value);
}
float GCNavHullVData::GetAgentRadius() const {
    return GetSchemaValue<float>(m_ptr, "CNavHullVData", "m_agentRadius");
}
void GCNavHullVData::SetAgentRadius(float value) {
    SetSchemaValue(m_ptr, "CNavHullVData", "m_agentRadius", false, value);
}
float GCNavHullVData::GetAgentHeight() const {
    return GetSchemaValue<float>(m_ptr, "CNavHullVData", "m_agentHeight");
}
void GCNavHullVData::SetAgentHeight(float value) {
    SetSchemaValue(m_ptr, "CNavHullVData", "m_agentHeight", false, value);
}
bool GCNavHullVData::GetAgentShortHeightEnabled() const {
    return GetSchemaValue<bool>(m_ptr, "CNavHullVData", "m_agentShortHeightEnabled");
}
void GCNavHullVData::SetAgentShortHeightEnabled(bool value) {
    SetSchemaValue(m_ptr, "CNavHullVData", "m_agentShortHeightEnabled", false, value);
}
float GCNavHullVData::GetAgentShortHeight() const {
    return GetSchemaValue<float>(m_ptr, "CNavHullVData", "m_agentShortHeight");
}
void GCNavHullVData::SetAgentShortHeight(float value) {
    SetSchemaValue(m_ptr, "CNavHullVData", "m_agentShortHeight", false, value);
}
float GCNavHullVData::GetAgentMaxClimb() const {
    return GetSchemaValue<float>(m_ptr, "CNavHullVData", "m_agentMaxClimb");
}
void GCNavHullVData::SetAgentMaxClimb(float value) {
    SetSchemaValue(m_ptr, "CNavHullVData", "m_agentMaxClimb", false, value);
}
int32_t GCNavHullVData::GetAgentMaxSlope() const {
    return GetSchemaValue<int32_t>(m_ptr, "CNavHullVData", "m_agentMaxSlope");
}
void GCNavHullVData::SetAgentMaxSlope(int32_t value) {
    SetSchemaValue(m_ptr, "CNavHullVData", "m_agentMaxSlope", false, value);
}
float GCNavHullVData::GetAgentMaxJumpDownDist() const {
    return GetSchemaValue<float>(m_ptr, "CNavHullVData", "m_agentMaxJumpDownDist");
}
void GCNavHullVData::SetAgentMaxJumpDownDist(float value) {
    SetSchemaValue(m_ptr, "CNavHullVData", "m_agentMaxJumpDownDist", false, value);
}
float GCNavHullVData::GetAgentMaxJumpHorizDistBase() const {
    return GetSchemaValue<float>(m_ptr, "CNavHullVData", "m_agentMaxJumpHorizDistBase");
}
void GCNavHullVData::SetAgentMaxJumpHorizDistBase(float value) {
    SetSchemaValue(m_ptr, "CNavHullVData", "m_agentMaxJumpHorizDistBase", false, value);
}
float GCNavHullVData::GetAgentMaxJumpUpDist() const {
    return GetSchemaValue<float>(m_ptr, "CNavHullVData", "m_agentMaxJumpUpDist");
}
void GCNavHullVData::SetAgentMaxJumpUpDist(float value) {
    SetSchemaValue(m_ptr, "CNavHullVData", "m_agentMaxJumpUpDist", false, value);
}
int32_t GCNavHullVData::GetAgentBorderErosion() const {
    return GetSchemaValue<int32_t>(m_ptr, "CNavHullVData", "m_agentBorderErosion");
}
void GCNavHullVData::SetAgentBorderErosion(int32_t value) {
    SetSchemaValue(m_ptr, "CNavHullVData", "m_agentBorderErosion", false, value);
}
void* GCNavHullVData::GetPtr() {
    return m_ptr;
}
std::string GCNavHullVData::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCNavHullVData::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCNavHullVData(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCNavHullVData>("CNavHullVData")
        .addConstructor<void (*)(std::string)>()
        .addProperty("AgentEnabled", &GCNavHullVData::GetAgentEnabled, &GCNavHullVData::SetAgentEnabled)
        .addProperty("AgentRadius", &GCNavHullVData::GetAgentRadius, &GCNavHullVData::SetAgentRadius)
        .addProperty("AgentHeight", &GCNavHullVData::GetAgentHeight, &GCNavHullVData::SetAgentHeight)
        .addProperty("AgentShortHeightEnabled", &GCNavHullVData::GetAgentShortHeightEnabled, &GCNavHullVData::SetAgentShortHeightEnabled)
        .addProperty("AgentShortHeight", &GCNavHullVData::GetAgentShortHeight, &GCNavHullVData::SetAgentShortHeight)
        .addProperty("AgentMaxClimb", &GCNavHullVData::GetAgentMaxClimb, &GCNavHullVData::SetAgentMaxClimb)
        .addProperty("AgentMaxSlope", &GCNavHullVData::GetAgentMaxSlope, &GCNavHullVData::SetAgentMaxSlope)
        .addProperty("AgentMaxJumpDownDist", &GCNavHullVData::GetAgentMaxJumpDownDist, &GCNavHullVData::SetAgentMaxJumpDownDist)
        .addProperty("AgentMaxJumpHorizDistBase", &GCNavHullVData::GetAgentMaxJumpHorizDistBase, &GCNavHullVData::SetAgentMaxJumpHorizDistBase)
        .addProperty("AgentMaxJumpUpDist", &GCNavHullVData::GetAgentMaxJumpUpDist, &GCNavHullVData::SetAgentMaxJumpUpDist)
        .addProperty("AgentBorderErosion", &GCNavHullVData::GetAgentBorderErosion, &GCNavHullVData::SetAgentBorderErosion)
        .addFunction("ToPtr", &GCNavHullVData::ToPtr)
        .addFunction("IsValid", &GCNavHullVData::IsValid)
        .endClass();
}
GSoundOpvarTraceResult_t::GSoundOpvarTraceResult_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GSoundOpvarTraceResult_t::GSoundOpvarTraceResult_t(void *ptr) {
    m_ptr = ptr;
}
Vector GSoundOpvarTraceResult_t::GetPos() const {
    return GetSchemaValue<Vector>(m_ptr, "SoundOpvarTraceResult_t", "vPos");
}
void GSoundOpvarTraceResult_t::SetPos(Vector value) {
    SetSchemaValue(m_ptr, "SoundOpvarTraceResult_t", "vPos", true, value);
}
bool GSoundOpvarTraceResult_t::GetDidHit() const {
    return GetSchemaValue<bool>(m_ptr, "SoundOpvarTraceResult_t", "bDidHit");
}
void GSoundOpvarTraceResult_t::SetDidHit(bool value) {
    SetSchemaValue(m_ptr, "SoundOpvarTraceResult_t", "bDidHit", true, value);
}
float GSoundOpvarTraceResult_t::GetDistSqrToCenter() const {
    return GetSchemaValue<float>(m_ptr, "SoundOpvarTraceResult_t", "flDistSqrToCenter");
}
void GSoundOpvarTraceResult_t::SetDistSqrToCenter(float value) {
    SetSchemaValue(m_ptr, "SoundOpvarTraceResult_t", "flDistSqrToCenter", true, value);
}
void* GSoundOpvarTraceResult_t::GetPtr() {
    return m_ptr;
}
std::string GSoundOpvarTraceResult_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GSoundOpvarTraceResult_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassSoundOpvarTraceResult_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GSoundOpvarTraceResult_t>("SoundOpvarTraceResult_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Pos", &GSoundOpvarTraceResult_t::GetPos, &GSoundOpvarTraceResult_t::SetPos)
        .addProperty("DidHit", &GSoundOpvarTraceResult_t::GetDidHit, &GSoundOpvarTraceResult_t::SetDidHit)
        .addProperty("DistSqrToCenter", &GSoundOpvarTraceResult_t::GetDistSqrToCenter, &GSoundOpvarTraceResult_t::SetDistSqrToCenter)
        .addFunction("ToPtr", &GSoundOpvarTraceResult_t::ToPtr)
        .addFunction("IsValid", &GSoundOpvarTraceResult_t::IsValid)
        .endClass();
}
GCAnimEventListener::GCAnimEventListener(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCAnimEventListener::GCAnimEventListener(void *ptr) {
    m_ptr = ptr;
}
void* GCAnimEventListener::GetPtr() {
    return m_ptr;
}
std::string GCAnimEventListener::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCAnimEventListener::IsValid() {
    return (m_ptr != nullptr);
}
GCAnimEventListenerBase GCAnimEventListener::GetParent() const {
    GCAnimEventListenerBase value(m_ptr);
    return value;
}
void GCAnimEventListener::SetParent(GCAnimEventListenerBase value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCAnimEventListener(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCAnimEventListener>("CAnimEventListener")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCAnimEventListener::GetParent, &GCAnimEventListener::SetParent)
        .addFunction("ToPtr", &GCAnimEventListener::ToPtr)
        .addFunction("IsValid", &GCAnimEventListener::IsValid)
        .endClass();
}
GCNavVolumeCalculatedVector::GCNavVolumeCalculatedVector(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCNavVolumeCalculatedVector::GCNavVolumeCalculatedVector(void *ptr) {
    m_ptr = ptr;
}
void* GCNavVolumeCalculatedVector::GetPtr() {
    return m_ptr;
}
std::string GCNavVolumeCalculatedVector::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCNavVolumeCalculatedVector::IsValid() {
    return (m_ptr != nullptr);
}
GCNavVolume GCNavVolumeCalculatedVector::GetParent() const {
    GCNavVolume value(m_ptr);
    return value;
}
void GCNavVolumeCalculatedVector::SetParent(GCNavVolume value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCNavVolumeCalculatedVector(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCNavVolumeCalculatedVector>("CNavVolumeCalculatedVector")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCNavVolumeCalculatedVector::GetParent, &GCNavVolumeCalculatedVector::SetParent)
        .addFunction("ToPtr", &GCNavVolumeCalculatedVector::ToPtr)
        .addFunction("IsValid", &GCNavVolumeCalculatedVector::IsValid)
        .endClass();
}
GCCSWeaponBaseVData::GCCSWeaponBaseVData(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCCSWeaponBaseVData::GCCSWeaponBaseVData(void *ptr) {
    m_ptr = ptr;
}
uint64_t GCCSWeaponBaseVData::GetWeaponType() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CCSWeaponBaseVData", "m_WeaponType");
}
void GCCSWeaponBaseVData::SetWeaponType(uint64_t value) {
    SetSchemaValue(m_ptr, "CCSWeaponBaseVData", "m_WeaponType", false, value);
}
uint64_t GCCSWeaponBaseVData::GetWeaponCategory() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CCSWeaponBaseVData", "m_WeaponCategory");
}
void GCCSWeaponBaseVData::SetWeaponCategory(uint64_t value) {
    SetSchemaValue(m_ptr, "CCSWeaponBaseVData", "m_WeaponCategory", false, value);
}
uint64_t GCCSWeaponBaseVData::GetGearSlot() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CCSWeaponBaseVData", "m_GearSlot");
}
void GCCSWeaponBaseVData::SetGearSlot(uint64_t value) {
    SetSchemaValue(m_ptr, "CCSWeaponBaseVData", "m_GearSlot", false, value);
}
int32_t GCCSWeaponBaseVData::GetGearSlotPosition() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSWeaponBaseVData", "m_GearSlotPosition");
}
void GCCSWeaponBaseVData::SetGearSlotPosition(int32_t value) {
    SetSchemaValue(m_ptr, "CCSWeaponBaseVData", "m_GearSlotPosition", false, value);
}
uint64_t GCCSWeaponBaseVData::GetDefaultLoadoutSlot() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CCSWeaponBaseVData", "m_DefaultLoadoutSlot");
}
void GCCSWeaponBaseVData::SetDefaultLoadoutSlot(uint64_t value) {
    SetSchemaValue(m_ptr, "CCSWeaponBaseVData", "m_DefaultLoadoutSlot", false, value);
}
std::string GCCSWeaponBaseVData::GetWrongTeamMsg() const {
    return GetSchemaValue<CUtlString>(m_ptr, "CCSWeaponBaseVData", "m_sWrongTeamMsg").Get();
}
void GCCSWeaponBaseVData::SetWrongTeamMsg(std::string value) {
    SetSchemaValue(m_ptr, "CCSWeaponBaseVData", "m_sWrongTeamMsg", false, CUtlString(value.c_str()));
}
int32_t GCCSWeaponBaseVData::GetPrice() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSWeaponBaseVData", "m_nPrice");
}
void GCCSWeaponBaseVData::SetPrice(int32_t value) {
    SetSchemaValue(m_ptr, "CCSWeaponBaseVData", "m_nPrice", false, value);
}
int32_t GCCSWeaponBaseVData::GetKillAward() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSWeaponBaseVData", "m_nKillAward");
}
void GCCSWeaponBaseVData::SetKillAward(int32_t value) {
    SetSchemaValue(m_ptr, "CCSWeaponBaseVData", "m_nKillAward", false, value);
}
int32_t GCCSWeaponBaseVData::GetPrimaryReserveAmmoMax() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSWeaponBaseVData", "m_nPrimaryReserveAmmoMax");
}
void GCCSWeaponBaseVData::SetPrimaryReserveAmmoMax(int32_t value) {
    SetSchemaValue(m_ptr, "CCSWeaponBaseVData", "m_nPrimaryReserveAmmoMax", false, value);
}
int32_t GCCSWeaponBaseVData::GetSecondaryReserveAmmoMax() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSWeaponBaseVData", "m_nSecondaryReserveAmmoMax");
}
void GCCSWeaponBaseVData::SetSecondaryReserveAmmoMax(int32_t value) {
    SetSchemaValue(m_ptr, "CCSWeaponBaseVData", "m_nSecondaryReserveAmmoMax", false, value);
}
bool GCCSWeaponBaseVData::GetMeleeWeapon() const {
    return GetSchemaValue<bool>(m_ptr, "CCSWeaponBaseVData", "m_bMeleeWeapon");
}
void GCCSWeaponBaseVData::SetMeleeWeapon(bool value) {
    SetSchemaValue(m_ptr, "CCSWeaponBaseVData", "m_bMeleeWeapon", false, value);
}
bool GCCSWeaponBaseVData::GetHasBurstMode() const {
    return GetSchemaValue<bool>(m_ptr, "CCSWeaponBaseVData", "m_bHasBurstMode");
}
void GCCSWeaponBaseVData::SetHasBurstMode(bool value) {
    SetSchemaValue(m_ptr, "CCSWeaponBaseVData", "m_bHasBurstMode", false, value);
}
bool GCCSWeaponBaseVData::GetIsRevolver() const {
    return GetSchemaValue<bool>(m_ptr, "CCSWeaponBaseVData", "m_bIsRevolver");
}
void GCCSWeaponBaseVData::SetIsRevolver(bool value) {
    SetSchemaValue(m_ptr, "CCSWeaponBaseVData", "m_bIsRevolver", false, value);
}
bool GCCSWeaponBaseVData::GetCannotShootUnderwater() const {
    return GetSchemaValue<bool>(m_ptr, "CCSWeaponBaseVData", "m_bCannotShootUnderwater");
}
void GCCSWeaponBaseVData::SetCannotShootUnderwater(bool value) {
    SetSchemaValue(m_ptr, "CCSWeaponBaseVData", "m_bCannotShootUnderwater", false, value);
}
std::string GCCSWeaponBaseVData::GetAnimExtension() const {
    return GetSchemaValue<CUtlString>(m_ptr, "CCSWeaponBaseVData", "m_szAnimExtension").Get();
}
void GCCSWeaponBaseVData::SetAnimExtension(std::string value) {
    SetSchemaValue(m_ptr, "CCSWeaponBaseVData", "m_szAnimExtension", false, CUtlString(value.c_str()));
}
uint64_t GCCSWeaponBaseVData::GetSilencerType() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CCSWeaponBaseVData", "m_eSilencerType");
}
void GCCSWeaponBaseVData::SetSilencerType(uint64_t value) {
    SetSchemaValue(m_ptr, "CCSWeaponBaseVData", "m_eSilencerType", false, value);
}
int32_t GCCSWeaponBaseVData::GetCrosshairMinDistance() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSWeaponBaseVData", "m_nCrosshairMinDistance");
}
void GCCSWeaponBaseVData::SetCrosshairMinDistance(int32_t value) {
    SetSchemaValue(m_ptr, "CCSWeaponBaseVData", "m_nCrosshairMinDistance", false, value);
}
int32_t GCCSWeaponBaseVData::GetCrosshairDeltaDistance() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSWeaponBaseVData", "m_nCrosshairDeltaDistance");
}
void GCCSWeaponBaseVData::SetCrosshairDeltaDistance(int32_t value) {
    SetSchemaValue(m_ptr, "CCSWeaponBaseVData", "m_nCrosshairDeltaDistance", false, value);
}
bool GCCSWeaponBaseVData::GetIsFullAuto() const {
    return GetSchemaValue<bool>(m_ptr, "CCSWeaponBaseVData", "m_bIsFullAuto");
}
void GCCSWeaponBaseVData::SetIsFullAuto(bool value) {
    SetSchemaValue(m_ptr, "CCSWeaponBaseVData", "m_bIsFullAuto", false, value);
}
int32_t GCCSWeaponBaseVData::GetNumBullets() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSWeaponBaseVData", "m_nNumBullets");
}
void GCCSWeaponBaseVData::SetNumBullets(int32_t value) {
    SetSchemaValue(m_ptr, "CCSWeaponBaseVData", "m_nNumBullets", false, value);
}
GCFiringModeFloat GCCSWeaponBaseVData::GetCycleTime() const {
    GCFiringModeFloat value(GetSchemaPtr(m_ptr, "CCSWeaponBaseVData", "m_flCycleTime"));
    return value;
}
void GCCSWeaponBaseVData::SetCycleTime(GCFiringModeFloat value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'CycleTime' is not possible.\n");
}
GCFiringModeFloat GCCSWeaponBaseVData::GetMaxSpeed() const {
    GCFiringModeFloat value(GetSchemaPtr(m_ptr, "CCSWeaponBaseVData", "m_flMaxSpeed"));
    return value;
}
void GCCSWeaponBaseVData::SetMaxSpeed(GCFiringModeFloat value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'MaxSpeed' is not possible.\n");
}
GCFiringModeFloat GCCSWeaponBaseVData::GetSpread() const {
    GCFiringModeFloat value(GetSchemaPtr(m_ptr, "CCSWeaponBaseVData", "m_flSpread"));
    return value;
}
void GCCSWeaponBaseVData::SetSpread(GCFiringModeFloat value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Spread' is not possible.\n");
}
GCFiringModeFloat GCCSWeaponBaseVData::GetInaccuracyCrouch() const {
    GCFiringModeFloat value(GetSchemaPtr(m_ptr, "CCSWeaponBaseVData", "m_flInaccuracyCrouch"));
    return value;
}
void GCCSWeaponBaseVData::SetInaccuracyCrouch(GCFiringModeFloat value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'InaccuracyCrouch' is not possible.\n");
}
GCFiringModeFloat GCCSWeaponBaseVData::GetInaccuracyStand() const {
    GCFiringModeFloat value(GetSchemaPtr(m_ptr, "CCSWeaponBaseVData", "m_flInaccuracyStand"));
    return value;
}
void GCCSWeaponBaseVData::SetInaccuracyStand(GCFiringModeFloat value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'InaccuracyStand' is not possible.\n");
}
GCFiringModeFloat GCCSWeaponBaseVData::GetInaccuracyJump() const {
    GCFiringModeFloat value(GetSchemaPtr(m_ptr, "CCSWeaponBaseVData", "m_flInaccuracyJump"));
    return value;
}
void GCCSWeaponBaseVData::SetInaccuracyJump(GCFiringModeFloat value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'InaccuracyJump' is not possible.\n");
}
GCFiringModeFloat GCCSWeaponBaseVData::GetInaccuracyLand() const {
    GCFiringModeFloat value(GetSchemaPtr(m_ptr, "CCSWeaponBaseVData", "m_flInaccuracyLand"));
    return value;
}
void GCCSWeaponBaseVData::SetInaccuracyLand(GCFiringModeFloat value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'InaccuracyLand' is not possible.\n");
}
GCFiringModeFloat GCCSWeaponBaseVData::GetInaccuracyLadder() const {
    GCFiringModeFloat value(GetSchemaPtr(m_ptr, "CCSWeaponBaseVData", "m_flInaccuracyLadder"));
    return value;
}
void GCCSWeaponBaseVData::SetInaccuracyLadder(GCFiringModeFloat value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'InaccuracyLadder' is not possible.\n");
}
GCFiringModeFloat GCCSWeaponBaseVData::GetInaccuracyFire() const {
    GCFiringModeFloat value(GetSchemaPtr(m_ptr, "CCSWeaponBaseVData", "m_flInaccuracyFire"));
    return value;
}
void GCCSWeaponBaseVData::SetInaccuracyFire(GCFiringModeFloat value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'InaccuracyFire' is not possible.\n");
}
GCFiringModeFloat GCCSWeaponBaseVData::GetInaccuracyMove() const {
    GCFiringModeFloat value(GetSchemaPtr(m_ptr, "CCSWeaponBaseVData", "m_flInaccuracyMove"));
    return value;
}
void GCCSWeaponBaseVData::SetInaccuracyMove(GCFiringModeFloat value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'InaccuracyMove' is not possible.\n");
}
GCFiringModeFloat GCCSWeaponBaseVData::GetRecoilAngle() const {
    GCFiringModeFloat value(GetSchemaPtr(m_ptr, "CCSWeaponBaseVData", "m_flRecoilAngle"));
    return value;
}
void GCCSWeaponBaseVData::SetRecoilAngle(GCFiringModeFloat value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'RecoilAngle' is not possible.\n");
}
GCFiringModeFloat GCCSWeaponBaseVData::GetRecoilAngleVariance() const {
    GCFiringModeFloat value(GetSchemaPtr(m_ptr, "CCSWeaponBaseVData", "m_flRecoilAngleVariance"));
    return value;
}
void GCCSWeaponBaseVData::SetRecoilAngleVariance(GCFiringModeFloat value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'RecoilAngleVariance' is not possible.\n");
}
GCFiringModeFloat GCCSWeaponBaseVData::GetRecoilMagnitude() const {
    GCFiringModeFloat value(GetSchemaPtr(m_ptr, "CCSWeaponBaseVData", "m_flRecoilMagnitude"));
    return value;
}
void GCCSWeaponBaseVData::SetRecoilMagnitude(GCFiringModeFloat value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'RecoilMagnitude' is not possible.\n");
}
GCFiringModeFloat GCCSWeaponBaseVData::GetRecoilMagnitudeVariance() const {
    GCFiringModeFloat value(GetSchemaPtr(m_ptr, "CCSWeaponBaseVData", "m_flRecoilMagnitudeVariance"));
    return value;
}
void GCCSWeaponBaseVData::SetRecoilMagnitudeVariance(GCFiringModeFloat value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'RecoilMagnitudeVariance' is not possible.\n");
}
GCFiringModeInt GCCSWeaponBaseVData::GetTracerFrequency() const {
    GCFiringModeInt value(GetSchemaPtr(m_ptr, "CCSWeaponBaseVData", "m_nTracerFrequency"));
    return value;
}
void GCCSWeaponBaseVData::SetTracerFrequency(GCFiringModeInt value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'TracerFrequency' is not possible.\n");
}
float GCCSWeaponBaseVData::GetInaccuracyJumpInitial() const {
    return GetSchemaValue<float>(m_ptr, "CCSWeaponBaseVData", "m_flInaccuracyJumpInitial");
}
void GCCSWeaponBaseVData::SetInaccuracyJumpInitial(float value) {
    SetSchemaValue(m_ptr, "CCSWeaponBaseVData", "m_flInaccuracyJumpInitial", false, value);
}
float GCCSWeaponBaseVData::GetInaccuracyJumpApex() const {
    return GetSchemaValue<float>(m_ptr, "CCSWeaponBaseVData", "m_flInaccuracyJumpApex");
}
void GCCSWeaponBaseVData::SetInaccuracyJumpApex(float value) {
    SetSchemaValue(m_ptr, "CCSWeaponBaseVData", "m_flInaccuracyJumpApex", false, value);
}
float GCCSWeaponBaseVData::GetInaccuracyReload() const {
    return GetSchemaValue<float>(m_ptr, "CCSWeaponBaseVData", "m_flInaccuracyReload");
}
void GCCSWeaponBaseVData::SetInaccuracyReload(float value) {
    SetSchemaValue(m_ptr, "CCSWeaponBaseVData", "m_flInaccuracyReload", false, value);
}
int32_t GCCSWeaponBaseVData::GetRecoilSeed() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSWeaponBaseVData", "m_nRecoilSeed");
}
void GCCSWeaponBaseVData::SetRecoilSeed(int32_t value) {
    SetSchemaValue(m_ptr, "CCSWeaponBaseVData", "m_nRecoilSeed", false, value);
}
int32_t GCCSWeaponBaseVData::GetSpreadSeed() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSWeaponBaseVData", "m_nSpreadSeed");
}
void GCCSWeaponBaseVData::SetSpreadSeed(int32_t value) {
    SetSchemaValue(m_ptr, "CCSWeaponBaseVData", "m_nSpreadSeed", false, value);
}
float GCCSWeaponBaseVData::GetTimeToIdleAfterFire() const {
    return GetSchemaValue<float>(m_ptr, "CCSWeaponBaseVData", "m_flTimeToIdleAfterFire");
}
void GCCSWeaponBaseVData::SetTimeToIdleAfterFire(float value) {
    SetSchemaValue(m_ptr, "CCSWeaponBaseVData", "m_flTimeToIdleAfterFire", false, value);
}
float GCCSWeaponBaseVData::GetIdleInterval() const {
    return GetSchemaValue<float>(m_ptr, "CCSWeaponBaseVData", "m_flIdleInterval");
}
void GCCSWeaponBaseVData::SetIdleInterval(float value) {
    SetSchemaValue(m_ptr, "CCSWeaponBaseVData", "m_flIdleInterval", false, value);
}
float GCCSWeaponBaseVData::GetAttackMovespeedFactor() const {
    return GetSchemaValue<float>(m_ptr, "CCSWeaponBaseVData", "m_flAttackMovespeedFactor");
}
void GCCSWeaponBaseVData::SetAttackMovespeedFactor(float value) {
    SetSchemaValue(m_ptr, "CCSWeaponBaseVData", "m_flAttackMovespeedFactor", false, value);
}
float GCCSWeaponBaseVData::GetHeatPerShot() const {
    return GetSchemaValue<float>(m_ptr, "CCSWeaponBaseVData", "m_flHeatPerShot");
}
void GCCSWeaponBaseVData::SetHeatPerShot(float value) {
    SetSchemaValue(m_ptr, "CCSWeaponBaseVData", "m_flHeatPerShot", false, value);
}
float GCCSWeaponBaseVData::GetInaccuracyPitchShift() const {
    return GetSchemaValue<float>(m_ptr, "CCSWeaponBaseVData", "m_flInaccuracyPitchShift");
}
void GCCSWeaponBaseVData::SetInaccuracyPitchShift(float value) {
    SetSchemaValue(m_ptr, "CCSWeaponBaseVData", "m_flInaccuracyPitchShift", false, value);
}
float GCCSWeaponBaseVData::GetInaccuracyAltSoundThreshold() const {
    return GetSchemaValue<float>(m_ptr, "CCSWeaponBaseVData", "m_flInaccuracyAltSoundThreshold");
}
void GCCSWeaponBaseVData::SetInaccuracyAltSoundThreshold(float value) {
    SetSchemaValue(m_ptr, "CCSWeaponBaseVData", "m_flInaccuracyAltSoundThreshold", false, value);
}
float GCCSWeaponBaseVData::GetBotAudibleRange() const {
    return GetSchemaValue<float>(m_ptr, "CCSWeaponBaseVData", "m_flBotAudibleRange");
}
void GCCSWeaponBaseVData::SetBotAudibleRange(float value) {
    SetSchemaValue(m_ptr, "CCSWeaponBaseVData", "m_flBotAudibleRange", false, value);
}
std::string GCCSWeaponBaseVData::GetUseRadioSubtitle() const {
    return GetSchemaValue<CUtlString>(m_ptr, "CCSWeaponBaseVData", "m_szUseRadioSubtitle").Get();
}
void GCCSWeaponBaseVData::SetUseRadioSubtitle(std::string value) {
    SetSchemaValue(m_ptr, "CCSWeaponBaseVData", "m_szUseRadioSubtitle", false, CUtlString(value.c_str()));
}
bool GCCSWeaponBaseVData::GetUnzoomsAfterShot() const {
    return GetSchemaValue<bool>(m_ptr, "CCSWeaponBaseVData", "m_bUnzoomsAfterShot");
}
void GCCSWeaponBaseVData::SetUnzoomsAfterShot(bool value) {
    SetSchemaValue(m_ptr, "CCSWeaponBaseVData", "m_bUnzoomsAfterShot", false, value);
}
bool GCCSWeaponBaseVData::GetHideViewModelWhenZoomed() const {
    return GetSchemaValue<bool>(m_ptr, "CCSWeaponBaseVData", "m_bHideViewModelWhenZoomed");
}
void GCCSWeaponBaseVData::SetHideViewModelWhenZoomed(bool value) {
    SetSchemaValue(m_ptr, "CCSWeaponBaseVData", "m_bHideViewModelWhenZoomed", false, value);
}
int32_t GCCSWeaponBaseVData::GetZoomLevels() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSWeaponBaseVData", "m_nZoomLevels");
}
void GCCSWeaponBaseVData::SetZoomLevels(int32_t value) {
    SetSchemaValue(m_ptr, "CCSWeaponBaseVData", "m_nZoomLevels", false, value);
}
int32_t GCCSWeaponBaseVData::GetZoomFOV1() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSWeaponBaseVData", "m_nZoomFOV1");
}
void GCCSWeaponBaseVData::SetZoomFOV1(int32_t value) {
    SetSchemaValue(m_ptr, "CCSWeaponBaseVData", "m_nZoomFOV1", false, value);
}
int32_t GCCSWeaponBaseVData::GetZoomFOV2() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSWeaponBaseVData", "m_nZoomFOV2");
}
void GCCSWeaponBaseVData::SetZoomFOV2(int32_t value) {
    SetSchemaValue(m_ptr, "CCSWeaponBaseVData", "m_nZoomFOV2", false, value);
}
float GCCSWeaponBaseVData::GetZoomTime0() const {
    return GetSchemaValue<float>(m_ptr, "CCSWeaponBaseVData", "m_flZoomTime0");
}
void GCCSWeaponBaseVData::SetZoomTime0(float value) {
    SetSchemaValue(m_ptr, "CCSWeaponBaseVData", "m_flZoomTime0", false, value);
}
float GCCSWeaponBaseVData::GetZoomTime1() const {
    return GetSchemaValue<float>(m_ptr, "CCSWeaponBaseVData", "m_flZoomTime1");
}
void GCCSWeaponBaseVData::SetZoomTime1(float value) {
    SetSchemaValue(m_ptr, "CCSWeaponBaseVData", "m_flZoomTime1", false, value);
}
float GCCSWeaponBaseVData::GetZoomTime2() const {
    return GetSchemaValue<float>(m_ptr, "CCSWeaponBaseVData", "m_flZoomTime2");
}
void GCCSWeaponBaseVData::SetZoomTime2(float value) {
    SetSchemaValue(m_ptr, "CCSWeaponBaseVData", "m_flZoomTime2", false, value);
}
float GCCSWeaponBaseVData::GetIronSightPullUpSpeed() const {
    return GetSchemaValue<float>(m_ptr, "CCSWeaponBaseVData", "m_flIronSightPullUpSpeed");
}
void GCCSWeaponBaseVData::SetIronSightPullUpSpeed(float value) {
    SetSchemaValue(m_ptr, "CCSWeaponBaseVData", "m_flIronSightPullUpSpeed", false, value);
}
float GCCSWeaponBaseVData::GetIronSightPutDownSpeed() const {
    return GetSchemaValue<float>(m_ptr, "CCSWeaponBaseVData", "m_flIronSightPutDownSpeed");
}
void GCCSWeaponBaseVData::SetIronSightPutDownSpeed(float value) {
    SetSchemaValue(m_ptr, "CCSWeaponBaseVData", "m_flIronSightPutDownSpeed", false, value);
}
float GCCSWeaponBaseVData::GetIronSightFOV() const {
    return GetSchemaValue<float>(m_ptr, "CCSWeaponBaseVData", "m_flIronSightFOV");
}
void GCCSWeaponBaseVData::SetIronSightFOV(float value) {
    SetSchemaValue(m_ptr, "CCSWeaponBaseVData", "m_flIronSightFOV", false, value);
}
float GCCSWeaponBaseVData::GetIronSightPivotForward() const {
    return GetSchemaValue<float>(m_ptr, "CCSWeaponBaseVData", "m_flIronSightPivotForward");
}
void GCCSWeaponBaseVData::SetIronSightPivotForward(float value) {
    SetSchemaValue(m_ptr, "CCSWeaponBaseVData", "m_flIronSightPivotForward", false, value);
}
float GCCSWeaponBaseVData::GetIronSightLooseness() const {
    return GetSchemaValue<float>(m_ptr, "CCSWeaponBaseVData", "m_flIronSightLooseness");
}
void GCCSWeaponBaseVData::SetIronSightLooseness(float value) {
    SetSchemaValue(m_ptr, "CCSWeaponBaseVData", "m_flIronSightLooseness", false, value);
}
QAngle GCCSWeaponBaseVData::GetPivotAngle() const {
    return GetSchemaValue<QAngle>(m_ptr, "CCSWeaponBaseVData", "m_angPivotAngle");
}
void GCCSWeaponBaseVData::SetPivotAngle(QAngle value) {
    SetSchemaValue(m_ptr, "CCSWeaponBaseVData", "m_angPivotAngle", false, value);
}
Vector GCCSWeaponBaseVData::GetIronSightEyePos() const {
    return GetSchemaValue<Vector>(m_ptr, "CCSWeaponBaseVData", "m_vecIronSightEyePos");
}
void GCCSWeaponBaseVData::SetIronSightEyePos(Vector value) {
    SetSchemaValue(m_ptr, "CCSWeaponBaseVData", "m_vecIronSightEyePos", false, value);
}
int32_t GCCSWeaponBaseVData::GetDamage() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSWeaponBaseVData", "m_nDamage");
}
void GCCSWeaponBaseVData::SetDamage(int32_t value) {
    SetSchemaValue(m_ptr, "CCSWeaponBaseVData", "m_nDamage", false, value);
}
float GCCSWeaponBaseVData::GetHeadshotMultiplier() const {
    return GetSchemaValue<float>(m_ptr, "CCSWeaponBaseVData", "m_flHeadshotMultiplier");
}
void GCCSWeaponBaseVData::SetHeadshotMultiplier(float value) {
    SetSchemaValue(m_ptr, "CCSWeaponBaseVData", "m_flHeadshotMultiplier", false, value);
}
float GCCSWeaponBaseVData::GetArmorRatio() const {
    return GetSchemaValue<float>(m_ptr, "CCSWeaponBaseVData", "m_flArmorRatio");
}
void GCCSWeaponBaseVData::SetArmorRatio(float value) {
    SetSchemaValue(m_ptr, "CCSWeaponBaseVData", "m_flArmorRatio", false, value);
}
float GCCSWeaponBaseVData::GetPenetration() const {
    return GetSchemaValue<float>(m_ptr, "CCSWeaponBaseVData", "m_flPenetration");
}
void GCCSWeaponBaseVData::SetPenetration(float value) {
    SetSchemaValue(m_ptr, "CCSWeaponBaseVData", "m_flPenetration", false, value);
}
float GCCSWeaponBaseVData::GetRange() const {
    return GetSchemaValue<float>(m_ptr, "CCSWeaponBaseVData", "m_flRange");
}
void GCCSWeaponBaseVData::SetRange(float value) {
    SetSchemaValue(m_ptr, "CCSWeaponBaseVData", "m_flRange", false, value);
}
float GCCSWeaponBaseVData::GetRangeModifier() const {
    return GetSchemaValue<float>(m_ptr, "CCSWeaponBaseVData", "m_flRangeModifier");
}
void GCCSWeaponBaseVData::SetRangeModifier(float value) {
    SetSchemaValue(m_ptr, "CCSWeaponBaseVData", "m_flRangeModifier", false, value);
}
float GCCSWeaponBaseVData::GetFlinchVelocityModifierLarge() const {
    return GetSchemaValue<float>(m_ptr, "CCSWeaponBaseVData", "m_flFlinchVelocityModifierLarge");
}
void GCCSWeaponBaseVData::SetFlinchVelocityModifierLarge(float value) {
    SetSchemaValue(m_ptr, "CCSWeaponBaseVData", "m_flFlinchVelocityModifierLarge", false, value);
}
float GCCSWeaponBaseVData::GetFlinchVelocityModifierSmall() const {
    return GetSchemaValue<float>(m_ptr, "CCSWeaponBaseVData", "m_flFlinchVelocityModifierSmall");
}
void GCCSWeaponBaseVData::SetFlinchVelocityModifierSmall(float value) {
    SetSchemaValue(m_ptr, "CCSWeaponBaseVData", "m_flFlinchVelocityModifierSmall", false, value);
}
float GCCSWeaponBaseVData::GetRecoveryTimeCrouch() const {
    return GetSchemaValue<float>(m_ptr, "CCSWeaponBaseVData", "m_flRecoveryTimeCrouch");
}
void GCCSWeaponBaseVData::SetRecoveryTimeCrouch(float value) {
    SetSchemaValue(m_ptr, "CCSWeaponBaseVData", "m_flRecoveryTimeCrouch", false, value);
}
float GCCSWeaponBaseVData::GetRecoveryTimeStand() const {
    return GetSchemaValue<float>(m_ptr, "CCSWeaponBaseVData", "m_flRecoveryTimeStand");
}
void GCCSWeaponBaseVData::SetRecoveryTimeStand(float value) {
    SetSchemaValue(m_ptr, "CCSWeaponBaseVData", "m_flRecoveryTimeStand", false, value);
}
float GCCSWeaponBaseVData::GetRecoveryTimeCrouchFinal() const {
    return GetSchemaValue<float>(m_ptr, "CCSWeaponBaseVData", "m_flRecoveryTimeCrouchFinal");
}
void GCCSWeaponBaseVData::SetRecoveryTimeCrouchFinal(float value) {
    SetSchemaValue(m_ptr, "CCSWeaponBaseVData", "m_flRecoveryTimeCrouchFinal", false, value);
}
float GCCSWeaponBaseVData::GetRecoveryTimeStandFinal() const {
    return GetSchemaValue<float>(m_ptr, "CCSWeaponBaseVData", "m_flRecoveryTimeStandFinal");
}
void GCCSWeaponBaseVData::SetRecoveryTimeStandFinal(float value) {
    SetSchemaValue(m_ptr, "CCSWeaponBaseVData", "m_flRecoveryTimeStandFinal", false, value);
}
int32_t GCCSWeaponBaseVData::GetRecoveryTransitionStartBullet() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSWeaponBaseVData", "m_nRecoveryTransitionStartBullet");
}
void GCCSWeaponBaseVData::SetRecoveryTransitionStartBullet(int32_t value) {
    SetSchemaValue(m_ptr, "CCSWeaponBaseVData", "m_nRecoveryTransitionStartBullet", false, value);
}
int32_t GCCSWeaponBaseVData::GetRecoveryTransitionEndBullet() const {
    return GetSchemaValue<int32_t>(m_ptr, "CCSWeaponBaseVData", "m_nRecoveryTransitionEndBullet");
}
void GCCSWeaponBaseVData::SetRecoveryTransitionEndBullet(int32_t value) {
    SetSchemaValue(m_ptr, "CCSWeaponBaseVData", "m_nRecoveryTransitionEndBullet", false, value);
}
float GCCSWeaponBaseVData::GetThrowVelocity() const {
    return GetSchemaValue<float>(m_ptr, "CCSWeaponBaseVData", "m_flThrowVelocity");
}
void GCCSWeaponBaseVData::SetThrowVelocity(float value) {
    SetSchemaValue(m_ptr, "CCSWeaponBaseVData", "m_flThrowVelocity", false, value);
}
Vector GCCSWeaponBaseVData::GetSmokeColor() const {
    return GetSchemaValue<Vector>(m_ptr, "CCSWeaponBaseVData", "m_vSmokeColor");
}
void GCCSWeaponBaseVData::SetSmokeColor(Vector value) {
    SetSchemaValue(m_ptr, "CCSWeaponBaseVData", "m_vSmokeColor", false, value);
}
void* GCCSWeaponBaseVData::GetPtr() {
    return m_ptr;
}
std::string GCCSWeaponBaseVData::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCCSWeaponBaseVData::IsValid() {
    return (m_ptr != nullptr);
}
GCBasePlayerWeaponVData GCCSWeaponBaseVData::GetParent() const {
    GCBasePlayerWeaponVData value(m_ptr);
    return value;
}
void GCCSWeaponBaseVData::SetParent(GCBasePlayerWeaponVData value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCCSWeaponBaseVData(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCCSWeaponBaseVData>("CCSWeaponBaseVData")
        .addConstructor<void (*)(std::string)>()
        .addProperty("WeaponType", &GCCSWeaponBaseVData::GetWeaponType, &GCCSWeaponBaseVData::SetWeaponType)
        .addProperty("WeaponCategory", &GCCSWeaponBaseVData::GetWeaponCategory, &GCCSWeaponBaseVData::SetWeaponCategory)
        .addProperty("GearSlot", &GCCSWeaponBaseVData::GetGearSlot, &GCCSWeaponBaseVData::SetGearSlot)
        .addProperty("GearSlotPosition", &GCCSWeaponBaseVData::GetGearSlotPosition, &GCCSWeaponBaseVData::SetGearSlotPosition)
        .addProperty("DefaultLoadoutSlot", &GCCSWeaponBaseVData::GetDefaultLoadoutSlot, &GCCSWeaponBaseVData::SetDefaultLoadoutSlot)
        .addProperty("WrongTeamMsg", &GCCSWeaponBaseVData::GetWrongTeamMsg, &GCCSWeaponBaseVData::SetWrongTeamMsg)
        .addProperty("Price", &GCCSWeaponBaseVData::GetPrice, &GCCSWeaponBaseVData::SetPrice)
        .addProperty("KillAward", &GCCSWeaponBaseVData::GetKillAward, &GCCSWeaponBaseVData::SetKillAward)
        .addProperty("PrimaryReserveAmmoMax", &GCCSWeaponBaseVData::GetPrimaryReserveAmmoMax, &GCCSWeaponBaseVData::SetPrimaryReserveAmmoMax)
        .addProperty("SecondaryReserveAmmoMax", &GCCSWeaponBaseVData::GetSecondaryReserveAmmoMax, &GCCSWeaponBaseVData::SetSecondaryReserveAmmoMax)
        .addProperty("MeleeWeapon", &GCCSWeaponBaseVData::GetMeleeWeapon, &GCCSWeaponBaseVData::SetMeleeWeapon)
        .addProperty("HasBurstMode", &GCCSWeaponBaseVData::GetHasBurstMode, &GCCSWeaponBaseVData::SetHasBurstMode)
        .addProperty("IsRevolver", &GCCSWeaponBaseVData::GetIsRevolver, &GCCSWeaponBaseVData::SetIsRevolver)
        .addProperty("CannotShootUnderwater", &GCCSWeaponBaseVData::GetCannotShootUnderwater, &GCCSWeaponBaseVData::SetCannotShootUnderwater)
        .addProperty("AnimExtension", &GCCSWeaponBaseVData::GetAnimExtension, &GCCSWeaponBaseVData::SetAnimExtension)
        .addProperty("SilencerType", &GCCSWeaponBaseVData::GetSilencerType, &GCCSWeaponBaseVData::SetSilencerType)
        .addProperty("CrosshairMinDistance", &GCCSWeaponBaseVData::GetCrosshairMinDistance, &GCCSWeaponBaseVData::SetCrosshairMinDistance)
        .addProperty("CrosshairDeltaDistance", &GCCSWeaponBaseVData::GetCrosshairDeltaDistance, &GCCSWeaponBaseVData::SetCrosshairDeltaDistance)
        .addProperty("IsFullAuto", &GCCSWeaponBaseVData::GetIsFullAuto, &GCCSWeaponBaseVData::SetIsFullAuto)
        .addProperty("NumBullets", &GCCSWeaponBaseVData::GetNumBullets, &GCCSWeaponBaseVData::SetNumBullets)
        .addProperty("CycleTime", &GCCSWeaponBaseVData::GetCycleTime, &GCCSWeaponBaseVData::SetCycleTime)
        .addProperty("MaxSpeed", &GCCSWeaponBaseVData::GetMaxSpeed, &GCCSWeaponBaseVData::SetMaxSpeed)
        .addProperty("Spread", &GCCSWeaponBaseVData::GetSpread, &GCCSWeaponBaseVData::SetSpread)
        .addProperty("InaccuracyCrouch", &GCCSWeaponBaseVData::GetInaccuracyCrouch, &GCCSWeaponBaseVData::SetInaccuracyCrouch)
        .addProperty("InaccuracyStand", &GCCSWeaponBaseVData::GetInaccuracyStand, &GCCSWeaponBaseVData::SetInaccuracyStand)
        .addProperty("InaccuracyJump", &GCCSWeaponBaseVData::GetInaccuracyJump, &GCCSWeaponBaseVData::SetInaccuracyJump)
        .addProperty("InaccuracyLand", &GCCSWeaponBaseVData::GetInaccuracyLand, &GCCSWeaponBaseVData::SetInaccuracyLand)
        .addProperty("InaccuracyLadder", &GCCSWeaponBaseVData::GetInaccuracyLadder, &GCCSWeaponBaseVData::SetInaccuracyLadder)
        .addProperty("InaccuracyFire", &GCCSWeaponBaseVData::GetInaccuracyFire, &GCCSWeaponBaseVData::SetInaccuracyFire)
        .addProperty("InaccuracyMove", &GCCSWeaponBaseVData::GetInaccuracyMove, &GCCSWeaponBaseVData::SetInaccuracyMove)
        .addProperty("RecoilAngle", &GCCSWeaponBaseVData::GetRecoilAngle, &GCCSWeaponBaseVData::SetRecoilAngle)
        .addProperty("RecoilAngleVariance", &GCCSWeaponBaseVData::GetRecoilAngleVariance, &GCCSWeaponBaseVData::SetRecoilAngleVariance)
        .addProperty("RecoilMagnitude", &GCCSWeaponBaseVData::GetRecoilMagnitude, &GCCSWeaponBaseVData::SetRecoilMagnitude)
        .addProperty("RecoilMagnitudeVariance", &GCCSWeaponBaseVData::GetRecoilMagnitudeVariance, &GCCSWeaponBaseVData::SetRecoilMagnitudeVariance)
        .addProperty("TracerFrequency", &GCCSWeaponBaseVData::GetTracerFrequency, &GCCSWeaponBaseVData::SetTracerFrequency)
        .addProperty("InaccuracyJumpInitial", &GCCSWeaponBaseVData::GetInaccuracyJumpInitial, &GCCSWeaponBaseVData::SetInaccuracyJumpInitial)
        .addProperty("InaccuracyJumpApex", &GCCSWeaponBaseVData::GetInaccuracyJumpApex, &GCCSWeaponBaseVData::SetInaccuracyJumpApex)
        .addProperty("InaccuracyReload", &GCCSWeaponBaseVData::GetInaccuracyReload, &GCCSWeaponBaseVData::SetInaccuracyReload)
        .addProperty("RecoilSeed", &GCCSWeaponBaseVData::GetRecoilSeed, &GCCSWeaponBaseVData::SetRecoilSeed)
        .addProperty("SpreadSeed", &GCCSWeaponBaseVData::GetSpreadSeed, &GCCSWeaponBaseVData::SetSpreadSeed)
        .addProperty("TimeToIdleAfterFire", &GCCSWeaponBaseVData::GetTimeToIdleAfterFire, &GCCSWeaponBaseVData::SetTimeToIdleAfterFire)
        .addProperty("IdleInterval", &GCCSWeaponBaseVData::GetIdleInterval, &GCCSWeaponBaseVData::SetIdleInterval)
        .addProperty("AttackMovespeedFactor", &GCCSWeaponBaseVData::GetAttackMovespeedFactor, &GCCSWeaponBaseVData::SetAttackMovespeedFactor)
        .addProperty("HeatPerShot", &GCCSWeaponBaseVData::GetHeatPerShot, &GCCSWeaponBaseVData::SetHeatPerShot)
        .addProperty("InaccuracyPitchShift", &GCCSWeaponBaseVData::GetInaccuracyPitchShift, &GCCSWeaponBaseVData::SetInaccuracyPitchShift)
        .addProperty("InaccuracyAltSoundThreshold", &GCCSWeaponBaseVData::GetInaccuracyAltSoundThreshold, &GCCSWeaponBaseVData::SetInaccuracyAltSoundThreshold)
        .addProperty("BotAudibleRange", &GCCSWeaponBaseVData::GetBotAudibleRange, &GCCSWeaponBaseVData::SetBotAudibleRange)
        .addProperty("UseRadioSubtitle", &GCCSWeaponBaseVData::GetUseRadioSubtitle, &GCCSWeaponBaseVData::SetUseRadioSubtitle)
        .addProperty("UnzoomsAfterShot", &GCCSWeaponBaseVData::GetUnzoomsAfterShot, &GCCSWeaponBaseVData::SetUnzoomsAfterShot)
        .addProperty("HideViewModelWhenZoomed", &GCCSWeaponBaseVData::GetHideViewModelWhenZoomed, &GCCSWeaponBaseVData::SetHideViewModelWhenZoomed)
        .addProperty("ZoomLevels", &GCCSWeaponBaseVData::GetZoomLevels, &GCCSWeaponBaseVData::SetZoomLevels)
        .addProperty("ZoomFOV1", &GCCSWeaponBaseVData::GetZoomFOV1, &GCCSWeaponBaseVData::SetZoomFOV1)
        .addProperty("ZoomFOV2", &GCCSWeaponBaseVData::GetZoomFOV2, &GCCSWeaponBaseVData::SetZoomFOV2)
        .addProperty("ZoomTime0", &GCCSWeaponBaseVData::GetZoomTime0, &GCCSWeaponBaseVData::SetZoomTime0)
        .addProperty("ZoomTime1", &GCCSWeaponBaseVData::GetZoomTime1, &GCCSWeaponBaseVData::SetZoomTime1)
        .addProperty("ZoomTime2", &GCCSWeaponBaseVData::GetZoomTime2, &GCCSWeaponBaseVData::SetZoomTime2)
        .addProperty("IronSightPullUpSpeed", &GCCSWeaponBaseVData::GetIronSightPullUpSpeed, &GCCSWeaponBaseVData::SetIronSightPullUpSpeed)
        .addProperty("IronSightPutDownSpeed", &GCCSWeaponBaseVData::GetIronSightPutDownSpeed, &GCCSWeaponBaseVData::SetIronSightPutDownSpeed)
        .addProperty("IronSightFOV", &GCCSWeaponBaseVData::GetIronSightFOV, &GCCSWeaponBaseVData::SetIronSightFOV)
        .addProperty("IronSightPivotForward", &GCCSWeaponBaseVData::GetIronSightPivotForward, &GCCSWeaponBaseVData::SetIronSightPivotForward)
        .addProperty("IronSightLooseness", &GCCSWeaponBaseVData::GetIronSightLooseness, &GCCSWeaponBaseVData::SetIronSightLooseness)
        .addProperty("PivotAngle", &GCCSWeaponBaseVData::GetPivotAngle, &GCCSWeaponBaseVData::SetPivotAngle)
        .addProperty("IronSightEyePos", &GCCSWeaponBaseVData::GetIronSightEyePos, &GCCSWeaponBaseVData::SetIronSightEyePos)
        .addProperty("Damage", &GCCSWeaponBaseVData::GetDamage, &GCCSWeaponBaseVData::SetDamage)
        .addProperty("HeadshotMultiplier", &GCCSWeaponBaseVData::GetHeadshotMultiplier, &GCCSWeaponBaseVData::SetHeadshotMultiplier)
        .addProperty("ArmorRatio", &GCCSWeaponBaseVData::GetArmorRatio, &GCCSWeaponBaseVData::SetArmorRatio)
        .addProperty("Penetration", &GCCSWeaponBaseVData::GetPenetration, &GCCSWeaponBaseVData::SetPenetration)
        .addProperty("Range", &GCCSWeaponBaseVData::GetRange, &GCCSWeaponBaseVData::SetRange)
        .addProperty("RangeModifier", &GCCSWeaponBaseVData::GetRangeModifier, &GCCSWeaponBaseVData::SetRangeModifier)
        .addProperty("FlinchVelocityModifierLarge", &GCCSWeaponBaseVData::GetFlinchVelocityModifierLarge, &GCCSWeaponBaseVData::SetFlinchVelocityModifierLarge)
        .addProperty("FlinchVelocityModifierSmall", &GCCSWeaponBaseVData::GetFlinchVelocityModifierSmall, &GCCSWeaponBaseVData::SetFlinchVelocityModifierSmall)
        .addProperty("RecoveryTimeCrouch", &GCCSWeaponBaseVData::GetRecoveryTimeCrouch, &GCCSWeaponBaseVData::SetRecoveryTimeCrouch)
        .addProperty("RecoveryTimeStand", &GCCSWeaponBaseVData::GetRecoveryTimeStand, &GCCSWeaponBaseVData::SetRecoveryTimeStand)
        .addProperty("RecoveryTimeCrouchFinal", &GCCSWeaponBaseVData::GetRecoveryTimeCrouchFinal, &GCCSWeaponBaseVData::SetRecoveryTimeCrouchFinal)
        .addProperty("RecoveryTimeStandFinal", &GCCSWeaponBaseVData::GetRecoveryTimeStandFinal, &GCCSWeaponBaseVData::SetRecoveryTimeStandFinal)
        .addProperty("RecoveryTransitionStartBullet", &GCCSWeaponBaseVData::GetRecoveryTransitionStartBullet, &GCCSWeaponBaseVData::SetRecoveryTransitionStartBullet)
        .addProperty("RecoveryTransitionEndBullet", &GCCSWeaponBaseVData::GetRecoveryTransitionEndBullet, &GCCSWeaponBaseVData::SetRecoveryTransitionEndBullet)
        .addProperty("ThrowVelocity", &GCCSWeaponBaseVData::GetThrowVelocity, &GCCSWeaponBaseVData::SetThrowVelocity)
        .addProperty("SmokeColor", &GCCSWeaponBaseVData::GetSmokeColor, &GCCSWeaponBaseVData::SetSmokeColor)
        .addProperty("Parent", &GCCSWeaponBaseVData::GetParent, &GCCSWeaponBaseVData::SetParent)
        .addFunction("ToPtr", &GCCSWeaponBaseVData::ToPtr)
        .addFunction("IsValid", &GCCSWeaponBaseVData::IsValid)
        .endClass();
}
GCBtNodeConditionInactive::GCBtNodeConditionInactive(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCBtNodeConditionInactive::GCBtNodeConditionInactive(void *ptr) {
    m_ptr = ptr;
}
float GCBtNodeConditionInactive::GetRoundStartThresholdSeconds() const {
    return GetSchemaValue<float>(m_ptr, "CBtNodeConditionInactive", "m_flRoundStartThresholdSeconds");
}
void GCBtNodeConditionInactive::SetRoundStartThresholdSeconds(float value) {
    SetSchemaValue(m_ptr, "CBtNodeConditionInactive", "m_flRoundStartThresholdSeconds", false, value);
}
float GCBtNodeConditionInactive::GetSensorInactivityThresholdSeconds() const {
    return GetSchemaValue<float>(m_ptr, "CBtNodeConditionInactive", "m_flSensorInactivityThresholdSeconds");
}
void GCBtNodeConditionInactive::SetSensorInactivityThresholdSeconds(float value) {
    SetSchemaValue(m_ptr, "CBtNodeConditionInactive", "m_flSensorInactivityThresholdSeconds", false, value);
}
GCountdownTimer GCBtNodeConditionInactive::GetSensorInactivityTimer() const {
    GCountdownTimer value(GetSchemaPtr(m_ptr, "CBtNodeConditionInactive", "m_SensorInactivityTimer"));
    return value;
}
void GCBtNodeConditionInactive::SetSensorInactivityTimer(GCountdownTimer value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'SensorInactivityTimer' is not possible.\n");
}
void* GCBtNodeConditionInactive::GetPtr() {
    return m_ptr;
}
std::string GCBtNodeConditionInactive::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCBtNodeConditionInactive::IsValid() {
    return (m_ptr != nullptr);
}
GCBtNodeCondition GCBtNodeConditionInactive::GetParent() const {
    GCBtNodeCondition value(m_ptr);
    return value;
}
void GCBtNodeConditionInactive::SetParent(GCBtNodeCondition value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCBtNodeConditionInactive(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCBtNodeConditionInactive>("CBtNodeConditionInactive")
        .addConstructor<void (*)(std::string)>()
        .addProperty("RoundStartThresholdSeconds", &GCBtNodeConditionInactive::GetRoundStartThresholdSeconds, &GCBtNodeConditionInactive::SetRoundStartThresholdSeconds)
        .addProperty("SensorInactivityThresholdSeconds", &GCBtNodeConditionInactive::GetSensorInactivityThresholdSeconds, &GCBtNodeConditionInactive::SetSensorInactivityThresholdSeconds)
        .addProperty("SensorInactivityTimer", &GCBtNodeConditionInactive::GetSensorInactivityTimer, &GCBtNodeConditionInactive::SetSensorInactivityTimer)
        .addProperty("Parent", &GCBtNodeConditionInactive::GetParent, &GCBtNodeConditionInactive::SetParent)
        .addFunction("ToPtr", &GCBtNodeConditionInactive::ToPtr)
        .addFunction("IsValid", &GCBtNodeConditionInactive::IsValid)
        .endClass();
}
GCSAdditionalPerRoundStats_t::GCSAdditionalPerRoundStats_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCSAdditionalPerRoundStats_t::GCSAdditionalPerRoundStats_t(void *ptr) {
    m_ptr = ptr;
}
int32_t GCSAdditionalPerRoundStats_t::GetNumChickensKilled() const {
    return GetSchemaValue<int32_t>(m_ptr, "CSAdditionalPerRoundStats_t", "m_numChickensKilled");
}
void GCSAdditionalPerRoundStats_t::SetNumChickensKilled(int32_t value) {
    SetSchemaValue(m_ptr, "CSAdditionalPerRoundStats_t", "m_numChickensKilled", true, value);
}
int32_t GCSAdditionalPerRoundStats_t::GetKillsWhileBlind() const {
    return GetSchemaValue<int32_t>(m_ptr, "CSAdditionalPerRoundStats_t", "m_killsWhileBlind");
}
void GCSAdditionalPerRoundStats_t::SetKillsWhileBlind(int32_t value) {
    SetSchemaValue(m_ptr, "CSAdditionalPerRoundStats_t", "m_killsWhileBlind", true, value);
}
int32_t GCSAdditionalPerRoundStats_t::GetBombCarrierkills() const {
    return GetSchemaValue<int32_t>(m_ptr, "CSAdditionalPerRoundStats_t", "m_bombCarrierkills");
}
void GCSAdditionalPerRoundStats_t::SetBombCarrierkills(int32_t value) {
    SetSchemaValue(m_ptr, "CSAdditionalPerRoundStats_t", "m_bombCarrierkills", true, value);
}
int32_t GCSAdditionalPerRoundStats_t::GetBurnDamageInflicted() const {
    return GetSchemaValue<int32_t>(m_ptr, "CSAdditionalPerRoundStats_t", "m_iBurnDamageInflicted");
}
void GCSAdditionalPerRoundStats_t::SetBurnDamageInflicted(int32_t value) {
    SetSchemaValue(m_ptr, "CSAdditionalPerRoundStats_t", "m_iBurnDamageInflicted", true, value);
}
int32_t GCSAdditionalPerRoundStats_t::GetBlastDamageInflicted() const {
    return GetSchemaValue<int32_t>(m_ptr, "CSAdditionalPerRoundStats_t", "m_iBlastDamageInflicted");
}
void GCSAdditionalPerRoundStats_t::SetBlastDamageInflicted(int32_t value) {
    SetSchemaValue(m_ptr, "CSAdditionalPerRoundStats_t", "m_iBlastDamageInflicted", true, value);
}
int32_t GCSAdditionalPerRoundStats_t::GetDinks() const {
    return GetSchemaValue<int32_t>(m_ptr, "CSAdditionalPerRoundStats_t", "m_iDinks");
}
void GCSAdditionalPerRoundStats_t::SetDinks(int32_t value) {
    SetSchemaValue(m_ptr, "CSAdditionalPerRoundStats_t", "m_iDinks", true, value);
}
void* GCSAdditionalPerRoundStats_t::GetPtr() {
    return m_ptr;
}
std::string GCSAdditionalPerRoundStats_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCSAdditionalPerRoundStats_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCSAdditionalPerRoundStats_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCSAdditionalPerRoundStats_t>("CSAdditionalPerRoundStats_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("NumChickensKilled", &GCSAdditionalPerRoundStats_t::GetNumChickensKilled, &GCSAdditionalPerRoundStats_t::SetNumChickensKilled)
        .addProperty("KillsWhileBlind", &GCSAdditionalPerRoundStats_t::GetKillsWhileBlind, &GCSAdditionalPerRoundStats_t::SetKillsWhileBlind)
        .addProperty("BombCarrierkills", &GCSAdditionalPerRoundStats_t::GetBombCarrierkills, &GCSAdditionalPerRoundStats_t::SetBombCarrierkills)
        .addProperty("BurnDamageInflicted", &GCSAdditionalPerRoundStats_t::GetBurnDamageInflicted, &GCSAdditionalPerRoundStats_t::SetBurnDamageInflicted)
        .addProperty("BlastDamageInflicted", &GCSAdditionalPerRoundStats_t::GetBlastDamageInflicted, &GCSAdditionalPerRoundStats_t::SetBlastDamageInflicted)
        .addProperty("Dinks", &GCSAdditionalPerRoundStats_t::GetDinks, &GCSAdditionalPerRoundStats_t::SetDinks)
        .addFunction("ToPtr", &GCSAdditionalPerRoundStats_t::ToPtr)
        .addFunction("IsValid", &GCSAdditionalPerRoundStats_t::IsValid)
        .endClass();
}
GActiveModelConfig_t::GActiveModelConfig_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GActiveModelConfig_t::GActiveModelConfig_t(void *ptr) {
    m_ptr = ptr;
}
GModelConfigHandle_t GActiveModelConfig_t::GetHandle() const {
    GModelConfigHandle_t value(GetSchemaPtr(m_ptr, "ActiveModelConfig_t", "m_Handle"));
    return value;
}
void GActiveModelConfig_t::SetHandle(GModelConfigHandle_t value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Handle' is not possible.\n");
}
std::string GActiveModelConfig_t::GetName() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "ActiveModelConfig_t", "m_Name").String();
}
void GActiveModelConfig_t::SetName(std::string value) {
    SetSchemaValue(m_ptr, "ActiveModelConfig_t", "m_Name", true, CUtlSymbolLarge(value.c_str()));
}
std::vector<GCBaseModelEntity> GActiveModelConfig_t::GetAssociatedEntities() const {
    CUtlVector<CHandle<CEntityInstance>>* vec = GetSchemaValue<CUtlVector<CHandle<CEntityInstance>>*>(m_ptr, "ActiveModelConfig_t", "m_AssociatedEntities"); 
    std::vector<GCBaseModelEntity> outVec; 
    for(int i = 0; i < vec->Count(); i++) { 
        outVec.push_back(GCBaseModelEntity((void*)(vec->Element(i).Get()))); 
    } 
    return outVec;
}
void GActiveModelConfig_t::SetAssociatedEntities(std::vector<GCBaseModelEntity> value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'AssociatedEntities' is not possible.\n");
}
std::vector<CUtlSymbolLarge> GActiveModelConfig_t::GetAssociatedEntityNames() const {
    CUtlVector<CUtlSymbolLarge>* vec = GetSchemaValue<CUtlVector<CUtlSymbolLarge>*>(m_ptr, "ActiveModelConfig_t", "m_AssociatedEntityNames"); std::vector<CUtlSymbolLarge> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GActiveModelConfig_t::SetAssociatedEntityNames(std::vector<CUtlSymbolLarge> value) {
    SetSchemaValueCUtlVector<CUtlSymbolLarge>(m_ptr, "ActiveModelConfig_t", "m_AssociatedEntityNames", true, value);
}
void* GActiveModelConfig_t::GetPtr() {
    return m_ptr;
}
std::string GActiveModelConfig_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GActiveModelConfig_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassActiveModelConfig_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GActiveModelConfig_t>("ActiveModelConfig_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Handle", &GActiveModelConfig_t::GetHandle, &GActiveModelConfig_t::SetHandle)
        .addProperty("Name", &GActiveModelConfig_t::GetName, &GActiveModelConfig_t::SetName)
        .addProperty("AssociatedEntities", &GActiveModelConfig_t::GetAssociatedEntities, &GActiveModelConfig_t::SetAssociatedEntities)
        .addProperty("AssociatedEntityNames", &GActiveModelConfig_t::GetAssociatedEntityNames, &GActiveModelConfig_t::SetAssociatedEntityNames)
        .addFunction("ToPtr", &GActiveModelConfig_t::ToPtr)
        .addFunction("IsValid", &GActiveModelConfig_t::IsValid)
        .endClass();
}
GCPrecipitationVData::GCPrecipitationVData(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCPrecipitationVData::GCPrecipitationVData(void *ptr) {
    m_ptr = ptr;
}
float GCPrecipitationVData::GetInnerDistance() const {
    return GetSchemaValue<float>(m_ptr, "CPrecipitationVData", "m_flInnerDistance");
}
void GCPrecipitationVData::SetInnerDistance(float value) {
    SetSchemaValue(m_ptr, "CPrecipitationVData", "m_flInnerDistance", false, value);
}
uint64_t GCPrecipitationVData::GetAttachType() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CPrecipitationVData", "m_nAttachType");
}
void GCPrecipitationVData::SetAttachType(uint64_t value) {
    SetSchemaValue(m_ptr, "CPrecipitationVData", "m_nAttachType", false, value);
}
bool GCPrecipitationVData::GetBatchSameVolumeType() const {
    return GetSchemaValue<bool>(m_ptr, "CPrecipitationVData", "m_bBatchSameVolumeType");
}
void GCPrecipitationVData::SetBatchSameVolumeType(bool value) {
    SetSchemaValue(m_ptr, "CPrecipitationVData", "m_bBatchSameVolumeType", false, value);
}
int32_t GCPrecipitationVData::GetRTEnvCP() const {
    return GetSchemaValue<int32_t>(m_ptr, "CPrecipitationVData", "m_nRTEnvCP");
}
void GCPrecipitationVData::SetRTEnvCP(int32_t value) {
    SetSchemaValue(m_ptr, "CPrecipitationVData", "m_nRTEnvCP", false, value);
}
int32_t GCPrecipitationVData::GetRTEnvCPComponent() const {
    return GetSchemaValue<int32_t>(m_ptr, "CPrecipitationVData", "m_nRTEnvCPComponent");
}
void GCPrecipitationVData::SetRTEnvCPComponent(int32_t value) {
    SetSchemaValue(m_ptr, "CPrecipitationVData", "m_nRTEnvCPComponent", false, value);
}
std::string GCPrecipitationVData::GetModifier() const {
    return GetSchemaValue<CUtlString>(m_ptr, "CPrecipitationVData", "m_szModifier").Get();
}
void GCPrecipitationVData::SetModifier(std::string value) {
    SetSchemaValue(m_ptr, "CPrecipitationVData", "m_szModifier", false, CUtlString(value.c_str()));
}
void* GCPrecipitationVData::GetPtr() {
    return m_ptr;
}
std::string GCPrecipitationVData::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCPrecipitationVData::IsValid() {
    return (m_ptr != nullptr);
}
GCEntitySubclassVDataBase GCPrecipitationVData::GetParent() const {
    GCEntitySubclassVDataBase value(m_ptr);
    return value;
}
void GCPrecipitationVData::SetParent(GCEntitySubclassVDataBase value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCPrecipitationVData(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCPrecipitationVData>("CPrecipitationVData")
        .addConstructor<void (*)(std::string)>()
        .addProperty("InnerDistance", &GCPrecipitationVData::GetInnerDistance, &GCPrecipitationVData::SetInnerDistance)
        .addProperty("AttachType", &GCPrecipitationVData::GetAttachType, &GCPrecipitationVData::SetAttachType)
        .addProperty("BatchSameVolumeType", &GCPrecipitationVData::GetBatchSameVolumeType, &GCPrecipitationVData::SetBatchSameVolumeType)
        .addProperty("RTEnvCP", &GCPrecipitationVData::GetRTEnvCP, &GCPrecipitationVData::SetRTEnvCP)
        .addProperty("RTEnvCPComponent", &GCPrecipitationVData::GetRTEnvCPComponent, &GCPrecipitationVData::SetRTEnvCPComponent)
        .addProperty("Modifier", &GCPrecipitationVData::GetModifier, &GCPrecipitationVData::SetModifier)
        .addProperty("Parent", &GCPrecipitationVData::GetParent, &GCPrecipitationVData::SetParent)
        .addFunction("ToPtr", &GCPrecipitationVData::ToPtr)
        .addFunction("IsValid", &GCPrecipitationVData::IsValid)
        .endClass();
}
GCBreakableStageHelper::GCBreakableStageHelper(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCBreakableStageHelper::GCBreakableStageHelper(void *ptr) {
    m_ptr = ptr;
}
int32_t GCBreakableStageHelper::GetCurrentStage() const {
    return GetSchemaValue<int32_t>(m_ptr, "CBreakableStageHelper", "m_nCurrentStage");
}
void GCBreakableStageHelper::SetCurrentStage(int32_t value) {
    SetSchemaValue(m_ptr, "CBreakableStageHelper", "m_nCurrentStage", false, value);
}
int32_t GCBreakableStageHelper::GetStageCount() const {
    return GetSchemaValue<int32_t>(m_ptr, "CBreakableStageHelper", "m_nStageCount");
}
void GCBreakableStageHelper::SetStageCount(int32_t value) {
    SetSchemaValue(m_ptr, "CBreakableStageHelper", "m_nStageCount", false, value);
}
void* GCBreakableStageHelper::GetPtr() {
    return m_ptr;
}
std::string GCBreakableStageHelper::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCBreakableStageHelper::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCBreakableStageHelper(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCBreakableStageHelper>("CBreakableStageHelper")
        .addConstructor<void (*)(std::string)>()
        .addProperty("CurrentStage", &GCBreakableStageHelper::GetCurrentStage, &GCBreakableStageHelper::SetCurrentStage)
        .addProperty("StageCount", &GCBreakableStageHelper::GetStageCount, &GCBreakableStageHelper::SetStageCount)
        .addFunction("ToPtr", &GCBreakableStageHelper::ToPtr)
        .addFunction("IsValid", &GCBreakableStageHelper::IsValid)
        .endClass();
}
GCNavVolumeBreadthFirstSearch::GCNavVolumeBreadthFirstSearch(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCNavVolumeBreadthFirstSearch::GCNavVolumeBreadthFirstSearch(void *ptr) {
    m_ptr = ptr;
}
Vector GCNavVolumeBreadthFirstSearch::GetStartPos() const {
    return GetSchemaValue<Vector>(m_ptr, "CNavVolumeBreadthFirstSearch", "m_vStartPos");
}
void GCNavVolumeBreadthFirstSearch::SetStartPos(Vector value) {
    SetSchemaValue(m_ptr, "CNavVolumeBreadthFirstSearch", "m_vStartPos", false, value);
}
float GCNavVolumeBreadthFirstSearch::GetSearchDist() const {
    return GetSchemaValue<float>(m_ptr, "CNavVolumeBreadthFirstSearch", "m_flSearchDist");
}
void GCNavVolumeBreadthFirstSearch::SetSearchDist(float value) {
    SetSchemaValue(m_ptr, "CNavVolumeBreadthFirstSearch", "m_flSearchDist", false, value);
}
void* GCNavVolumeBreadthFirstSearch::GetPtr() {
    return m_ptr;
}
std::string GCNavVolumeBreadthFirstSearch::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCNavVolumeBreadthFirstSearch::IsValid() {
    return (m_ptr != nullptr);
}
GCNavVolumeCalculatedVector GCNavVolumeBreadthFirstSearch::GetParent() const {
    GCNavVolumeCalculatedVector value(m_ptr);
    return value;
}
void GCNavVolumeBreadthFirstSearch::SetParent(GCNavVolumeCalculatedVector value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCNavVolumeBreadthFirstSearch(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCNavVolumeBreadthFirstSearch>("CNavVolumeBreadthFirstSearch")
        .addConstructor<void (*)(std::string)>()
        .addProperty("StartPos", &GCNavVolumeBreadthFirstSearch::GetStartPos, &GCNavVolumeBreadthFirstSearch::SetStartPos)
        .addProperty("SearchDist", &GCNavVolumeBreadthFirstSearch::GetSearchDist, &GCNavVolumeBreadthFirstSearch::SetSearchDist)
        .addProperty("Parent", &GCNavVolumeBreadthFirstSearch::GetParent, &GCNavVolumeBreadthFirstSearch::SetParent)
        .addFunction("ToPtr", &GCNavVolumeBreadthFirstSearch::ToPtr)
        .addFunction("IsValid", &GCNavVolumeBreadthFirstSearch::IsValid)
        .endClass();
}
GCAmbientGeneric::GCAmbientGeneric(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCAmbientGeneric::GCAmbientGeneric(void *ptr) {
    m_ptr = ptr;
}
float GCAmbientGeneric::GetRadius() const {
    return GetSchemaValue<float>(m_ptr, "CAmbientGeneric", "m_radius");
}
void GCAmbientGeneric::SetRadius(float value) {
    SetSchemaValue(m_ptr, "CAmbientGeneric", "m_radius", false, value);
}
float GCAmbientGeneric::GetMaxRadius() const {
    return GetSchemaValue<float>(m_ptr, "CAmbientGeneric", "m_flMaxRadius");
}
void GCAmbientGeneric::SetMaxRadius(float value) {
    SetSchemaValue(m_ptr, "CAmbientGeneric", "m_flMaxRadius", false, value);
}
uint64_t GCAmbientGeneric::GetSoundLevel() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CAmbientGeneric", "m_iSoundLevel");
}
void GCAmbientGeneric::SetSoundLevel(uint64_t value) {
    SetSchemaValue(m_ptr, "CAmbientGeneric", "m_iSoundLevel", false, value);
}
Gdynpitchvol_t GCAmbientGeneric::GetDpv() const {
    Gdynpitchvol_t value(GetSchemaPtr(m_ptr, "CAmbientGeneric", "m_dpv"));
    return value;
}
void GCAmbientGeneric::SetDpv(Gdynpitchvol_t value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Dpv' is not possible.\n");
}
bool GCAmbientGeneric::GetActive() const {
    return GetSchemaValue<bool>(m_ptr, "CAmbientGeneric", "m_fActive");
}
void GCAmbientGeneric::SetActive(bool value) {
    SetSchemaValue(m_ptr, "CAmbientGeneric", "m_fActive", false, value);
}
bool GCAmbientGeneric::GetLooping() const {
    return GetSchemaValue<bool>(m_ptr, "CAmbientGeneric", "m_fLooping");
}
void GCAmbientGeneric::SetLooping(bool value) {
    SetSchemaValue(m_ptr, "CAmbientGeneric", "m_fLooping", false, value);
}
std::string GCAmbientGeneric::GetSound() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CAmbientGeneric", "m_iszSound").String();
}
void GCAmbientGeneric::SetSound(std::string value) {
    SetSchemaValue(m_ptr, "CAmbientGeneric", "m_iszSound", false, CUtlSymbolLarge(value.c_str()));
}
std::string GCAmbientGeneric::GetSourceEntName() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CAmbientGeneric", "m_sSourceEntName").String();
}
void GCAmbientGeneric::SetSourceEntName(std::string value) {
    SetSchemaValue(m_ptr, "CAmbientGeneric", "m_sSourceEntName", false, CUtlSymbolLarge(value.c_str()));
}
GCBaseEntity GCAmbientGeneric::GetSoundSource() const {
    GCBaseEntity value((void*)(GetSchemaValue<CHandle<CEntityInstance>>(m_ptr, "CAmbientGeneric", "m_hSoundSource").Get()));
    return value;
}
void GCAmbientGeneric::SetSoundSource(GCBaseEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'SoundSource' is not possible.\n");
}
int GCAmbientGeneric::GetSoundSourceEntIndex() const {
    return GetSchemaValue<CEntityIndex>(m_ptr, "CAmbientGeneric", "m_nSoundSourceEntIndex").Get();
}
void GCAmbientGeneric::SetSoundSourceEntIndex(int value) {
    SetSchemaValue(m_ptr, "CAmbientGeneric", "m_nSoundSourceEntIndex", false, CEntityIndex(value));
}
void* GCAmbientGeneric::GetPtr() {
    return m_ptr;
}
std::string GCAmbientGeneric::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCAmbientGeneric::IsValid() {
    return (m_ptr != nullptr);
}
GCPointEntity GCAmbientGeneric::GetParent() const {
    GCPointEntity value(m_ptr);
    return value;
}
void GCAmbientGeneric::SetParent(GCPointEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCAmbientGeneric(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCAmbientGeneric>("CAmbientGeneric")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Radius", &GCAmbientGeneric::GetRadius, &GCAmbientGeneric::SetRadius)
        .addProperty("MaxRadius", &GCAmbientGeneric::GetMaxRadius, &GCAmbientGeneric::SetMaxRadius)
        .addProperty("SoundLevel", &GCAmbientGeneric::GetSoundLevel, &GCAmbientGeneric::SetSoundLevel)
        .addProperty("Dpv", &GCAmbientGeneric::GetDpv, &GCAmbientGeneric::SetDpv)
        .addProperty("Active", &GCAmbientGeneric::GetActive, &GCAmbientGeneric::SetActive)
        .addProperty("Looping", &GCAmbientGeneric::GetLooping, &GCAmbientGeneric::SetLooping)
        .addProperty("Sound", &GCAmbientGeneric::GetSound, &GCAmbientGeneric::SetSound)
        .addProperty("SourceEntName", &GCAmbientGeneric::GetSourceEntName, &GCAmbientGeneric::SetSourceEntName)
        .addProperty("SoundSource", &GCAmbientGeneric::GetSoundSource, &GCAmbientGeneric::SetSoundSource)
        .addProperty("SoundSourceEntIndex", &GCAmbientGeneric::GetSoundSourceEntIndex, &GCAmbientGeneric::SetSoundSourceEntIndex)
        .addProperty("Parent", &GCAmbientGeneric::GetParent, &GCAmbientGeneric::SetParent)
        .addFunction("ToPtr", &GCAmbientGeneric::ToPtr)
        .addFunction("IsValid", &GCAmbientGeneric::IsValid)
        .endClass();
}
GCSAdditionalMatchStats_t::GCSAdditionalMatchStats_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCSAdditionalMatchStats_t::GCSAdditionalMatchStats_t(void *ptr) {
    m_ptr = ptr;
}
int32_t GCSAdditionalMatchStats_t::GetNumRoundsSurvived() const {
    return GetSchemaValue<int32_t>(m_ptr, "CSAdditionalMatchStats_t", "m_numRoundsSurvived");
}
void GCSAdditionalMatchStats_t::SetNumRoundsSurvived(int32_t value) {
    SetSchemaValue(m_ptr, "CSAdditionalMatchStats_t", "m_numRoundsSurvived", true, value);
}
int32_t GCSAdditionalMatchStats_t::GetMaxNumRoundsSurvived() const {
    return GetSchemaValue<int32_t>(m_ptr, "CSAdditionalMatchStats_t", "m_maxNumRoundsSurvived");
}
void GCSAdditionalMatchStats_t::SetMaxNumRoundsSurvived(int32_t value) {
    SetSchemaValue(m_ptr, "CSAdditionalMatchStats_t", "m_maxNumRoundsSurvived", true, value);
}
int32_t GCSAdditionalMatchStats_t::GetNumRoundsSurvivedTotal() const {
    return GetSchemaValue<int32_t>(m_ptr, "CSAdditionalMatchStats_t", "m_numRoundsSurvivedTotal");
}
void GCSAdditionalMatchStats_t::SetNumRoundsSurvivedTotal(int32_t value) {
    SetSchemaValue(m_ptr, "CSAdditionalMatchStats_t", "m_numRoundsSurvivedTotal", true, value);
}
int32_t GCSAdditionalMatchStats_t::GetRoundsWonWithoutPurchase() const {
    return GetSchemaValue<int32_t>(m_ptr, "CSAdditionalMatchStats_t", "m_iRoundsWonWithoutPurchase");
}
void GCSAdditionalMatchStats_t::SetRoundsWonWithoutPurchase(int32_t value) {
    SetSchemaValue(m_ptr, "CSAdditionalMatchStats_t", "m_iRoundsWonWithoutPurchase", true, value);
}
int32_t GCSAdditionalMatchStats_t::GetRoundsWonWithoutPurchaseTotal() const {
    return GetSchemaValue<int32_t>(m_ptr, "CSAdditionalMatchStats_t", "m_iRoundsWonWithoutPurchaseTotal");
}
void GCSAdditionalMatchStats_t::SetRoundsWonWithoutPurchaseTotal(int32_t value) {
    SetSchemaValue(m_ptr, "CSAdditionalMatchStats_t", "m_iRoundsWonWithoutPurchaseTotal", true, value);
}
int32_t GCSAdditionalMatchStats_t::GetNumFirstKills() const {
    return GetSchemaValue<int32_t>(m_ptr, "CSAdditionalMatchStats_t", "m_numFirstKills");
}
void GCSAdditionalMatchStats_t::SetNumFirstKills(int32_t value) {
    SetSchemaValue(m_ptr, "CSAdditionalMatchStats_t", "m_numFirstKills", true, value);
}
int32_t GCSAdditionalMatchStats_t::GetNumClutchKills() const {
    return GetSchemaValue<int32_t>(m_ptr, "CSAdditionalMatchStats_t", "m_numClutchKills");
}
void GCSAdditionalMatchStats_t::SetNumClutchKills(int32_t value) {
    SetSchemaValue(m_ptr, "CSAdditionalMatchStats_t", "m_numClutchKills", true, value);
}
int32_t GCSAdditionalMatchStats_t::GetNumPistolKills() const {
    return GetSchemaValue<int32_t>(m_ptr, "CSAdditionalMatchStats_t", "m_numPistolKills");
}
void GCSAdditionalMatchStats_t::SetNumPistolKills(int32_t value) {
    SetSchemaValue(m_ptr, "CSAdditionalMatchStats_t", "m_numPistolKills", true, value);
}
int32_t GCSAdditionalMatchStats_t::GetNumSniperKills() const {
    return GetSchemaValue<int32_t>(m_ptr, "CSAdditionalMatchStats_t", "m_numSniperKills");
}
void GCSAdditionalMatchStats_t::SetNumSniperKills(int32_t value) {
    SetSchemaValue(m_ptr, "CSAdditionalMatchStats_t", "m_numSniperKills", true, value);
}
int32_t GCSAdditionalMatchStats_t::GetNumSuicides() const {
    return GetSchemaValue<int32_t>(m_ptr, "CSAdditionalMatchStats_t", "m_iNumSuicides");
}
void GCSAdditionalMatchStats_t::SetNumSuicides(int32_t value) {
    SetSchemaValue(m_ptr, "CSAdditionalMatchStats_t", "m_iNumSuicides", true, value);
}
int32_t GCSAdditionalMatchStats_t::GetNumTeamKills() const {
    return GetSchemaValue<int32_t>(m_ptr, "CSAdditionalMatchStats_t", "m_iNumTeamKills");
}
void GCSAdditionalMatchStats_t::SetNumTeamKills(int32_t value) {
    SetSchemaValue(m_ptr, "CSAdditionalMatchStats_t", "m_iNumTeamKills", true, value);
}
int32_t GCSAdditionalMatchStats_t::GetTeamDamage() const {
    return GetSchemaValue<int32_t>(m_ptr, "CSAdditionalMatchStats_t", "m_iTeamDamage");
}
void GCSAdditionalMatchStats_t::SetTeamDamage(int32_t value) {
    SetSchemaValue(m_ptr, "CSAdditionalMatchStats_t", "m_iTeamDamage", true, value);
}
void* GCSAdditionalMatchStats_t::GetPtr() {
    return m_ptr;
}
std::string GCSAdditionalMatchStats_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCSAdditionalMatchStats_t::IsValid() {
    return (m_ptr != nullptr);
}
GCSAdditionalPerRoundStats_t GCSAdditionalMatchStats_t::GetParent() const {
    GCSAdditionalPerRoundStats_t value(m_ptr);
    return value;
}
void GCSAdditionalMatchStats_t::SetParent(GCSAdditionalPerRoundStats_t value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCSAdditionalMatchStats_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCSAdditionalMatchStats_t>("CSAdditionalMatchStats_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("NumRoundsSurvived", &GCSAdditionalMatchStats_t::GetNumRoundsSurvived, &GCSAdditionalMatchStats_t::SetNumRoundsSurvived)
        .addProperty("MaxNumRoundsSurvived", &GCSAdditionalMatchStats_t::GetMaxNumRoundsSurvived, &GCSAdditionalMatchStats_t::SetMaxNumRoundsSurvived)
        .addProperty("NumRoundsSurvivedTotal", &GCSAdditionalMatchStats_t::GetNumRoundsSurvivedTotal, &GCSAdditionalMatchStats_t::SetNumRoundsSurvivedTotal)
        .addProperty("RoundsWonWithoutPurchase", &GCSAdditionalMatchStats_t::GetRoundsWonWithoutPurchase, &GCSAdditionalMatchStats_t::SetRoundsWonWithoutPurchase)
        .addProperty("RoundsWonWithoutPurchaseTotal", &GCSAdditionalMatchStats_t::GetRoundsWonWithoutPurchaseTotal, &GCSAdditionalMatchStats_t::SetRoundsWonWithoutPurchaseTotal)
        .addProperty("NumFirstKills", &GCSAdditionalMatchStats_t::GetNumFirstKills, &GCSAdditionalMatchStats_t::SetNumFirstKills)
        .addProperty("NumClutchKills", &GCSAdditionalMatchStats_t::GetNumClutchKills, &GCSAdditionalMatchStats_t::SetNumClutchKills)
        .addProperty("NumPistolKills", &GCSAdditionalMatchStats_t::GetNumPistolKills, &GCSAdditionalMatchStats_t::SetNumPistolKills)
        .addProperty("NumSniperKills", &GCSAdditionalMatchStats_t::GetNumSniperKills, &GCSAdditionalMatchStats_t::SetNumSniperKills)
        .addProperty("NumSuicides", &GCSAdditionalMatchStats_t::GetNumSuicides, &GCSAdditionalMatchStats_t::SetNumSuicides)
        .addProperty("NumTeamKills", &GCSAdditionalMatchStats_t::GetNumTeamKills, &GCSAdditionalMatchStats_t::SetNumTeamKills)
        .addProperty("TeamDamage", &GCSAdditionalMatchStats_t::GetTeamDamage, &GCSAdditionalMatchStats_t::SetTeamDamage)
        .addProperty("Parent", &GCSAdditionalMatchStats_t::GetParent, &GCSAdditionalMatchStats_t::SetParent)
        .addFunction("ToPtr", &GCSAdditionalMatchStats_t::ToPtr)
        .addFunction("IsValid", &GCSAdditionalMatchStats_t::IsValid)
        .endClass();
}
GIRagdoll::GIRagdoll(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GIRagdoll::GIRagdoll(void *ptr) {
    m_ptr = ptr;
}
void* GIRagdoll::GetPtr() {
    return m_ptr;
}
std::string GIRagdoll::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GIRagdoll::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassIRagdoll(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GIRagdoll>("IRagdoll")
        .addConstructor<void (*)(std::string)>()
        .addFunction("ToPtr", &GIRagdoll::ToPtr)
        .addFunction("IsValid", &GIRagdoll::IsValid)
        .endClass();
}
GCGameText::GCGameText(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCGameText::GCGameText(void *ptr) {
    m_ptr = ptr;
}
std::string GCGameText::GetMessage() const {
    return GetSchemaValue<CUtlSymbolLarge>(m_ptr, "CGameText", "m_iszMessage").String();
}
void GCGameText::SetMessage(std::string value) {
    SetSchemaValue(m_ptr, "CGameText", "m_iszMessage", false, CUtlSymbolLarge(value.c_str()));
}
Ghudtextparms_t GCGameText::GetTextParms() const {
    Ghudtextparms_t value(GetSchemaPtr(m_ptr, "CGameText", "m_textParms"));
    return value;
}
void GCGameText::SetTextParms(Ghudtextparms_t value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'TextParms' is not possible.\n");
}
void* GCGameText::GetPtr() {
    return m_ptr;
}
std::string GCGameText::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCGameText::IsValid() {
    return (m_ptr != nullptr);
}
GCRulePointEntity GCGameText::GetParent() const {
    GCRulePointEntity value(m_ptr);
    return value;
}
void GCGameText::SetParent(GCRulePointEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCGameText(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCGameText>("CGameText")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Message", &GCGameText::GetMessage, &GCGameText::SetMessage)
        .addProperty("TextParms", &GCGameText::GetTextParms, &GCGameText::SetTextParms)
        .addProperty("Parent", &GCGameText::GetParent, &GCGameText::SetParent)
        .addFunction("ToPtr", &GCGameText::ToPtr)
        .addFunction("IsValid", &GCGameText::IsValid)
        .endClass();
}
GCInfoInstructorHintBombTargetB::GCInfoInstructorHintBombTargetB(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCInfoInstructorHintBombTargetB::GCInfoInstructorHintBombTargetB(void *ptr) {
    m_ptr = ptr;
}
void* GCInfoInstructorHintBombTargetB::GetPtr() {
    return m_ptr;
}
std::string GCInfoInstructorHintBombTargetB::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCInfoInstructorHintBombTargetB::IsValid() {
    return (m_ptr != nullptr);
}
GCPointEntity GCInfoInstructorHintBombTargetB::GetParent() const {
    GCPointEntity value(m_ptr);
    return value;
}
void GCInfoInstructorHintBombTargetB::SetParent(GCPointEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCInfoInstructorHintBombTargetB(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCInfoInstructorHintBombTargetB>("CInfoInstructorHintBombTargetB")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCInfoInstructorHintBombTargetB::GetParent, &GCInfoInstructorHintBombTargetB::SetParent)
        .addFunction("ToPtr", &GCInfoInstructorHintBombTargetB::ToPtr)
        .addFunction("IsValid", &GCInfoInstructorHintBombTargetB::IsValid)
        .endClass();
}
GCNavVolumeAll::GCNavVolumeAll(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCNavVolumeAll::GCNavVolumeAll(void *ptr) {
    m_ptr = ptr;
}
void* GCNavVolumeAll::GetPtr() {
    return m_ptr;
}
std::string GCNavVolumeAll::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCNavVolumeAll::IsValid() {
    return (m_ptr != nullptr);
}
GCNavVolumeVector GCNavVolumeAll::GetParent() const {
    GCNavVolumeVector value(m_ptr);
    return value;
}
void GCNavVolumeAll::SetParent(GCNavVolumeVector value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCNavVolumeAll(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCNavVolumeAll>("CNavVolumeAll")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCNavVolumeAll::GetParent, &GCNavVolumeAll::SetParent)
        .addFunction("ToPtr", &GCNavVolumeAll::ToPtr)
        .addFunction("IsValid", &GCNavVolumeAll::IsValid)
        .endClass();
}
GCNavVolumeSphericalShell::GCNavVolumeSphericalShell(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCNavVolumeSphericalShell::GCNavVolumeSphericalShell(void *ptr) {
    m_ptr = ptr;
}
float GCNavVolumeSphericalShell::GetRadiusInner() const {
    return GetSchemaValue<float>(m_ptr, "CNavVolumeSphericalShell", "m_flRadiusInner");
}
void GCNavVolumeSphericalShell::SetRadiusInner(float value) {
    SetSchemaValue(m_ptr, "CNavVolumeSphericalShell", "m_flRadiusInner", false, value);
}
void* GCNavVolumeSphericalShell::GetPtr() {
    return m_ptr;
}
std::string GCNavVolumeSphericalShell::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCNavVolumeSphericalShell::IsValid() {
    return (m_ptr != nullptr);
}
GCNavVolumeSphere GCNavVolumeSphericalShell::GetParent() const {
    GCNavVolumeSphere value(m_ptr);
    return value;
}
void GCNavVolumeSphericalShell::SetParent(GCNavVolumeSphere value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCNavVolumeSphericalShell(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCNavVolumeSphericalShell>("CNavVolumeSphericalShell")
        .addConstructor<void (*)(std::string)>()
        .addProperty("RadiusInner", &GCNavVolumeSphericalShell::GetRadiusInner, &GCNavVolumeSphericalShell::SetRadiusInner)
        .addProperty("Parent", &GCNavVolumeSphericalShell::GetParent, &GCNavVolumeSphericalShell::SetParent)
        .addFunction("ToPtr", &GCNavVolumeSphericalShell::ToPtr)
        .addFunction("IsValid", &GCNavVolumeSphericalShell::IsValid)
        .endClass();
}
GRelationshipOverride_t::GRelationshipOverride_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GRelationshipOverride_t::GRelationshipOverride_t(void *ptr) {
    m_ptr = ptr;
}
GCBaseEntity GRelationshipOverride_t::GetEntity() const {
    GCBaseEntity value((void*)(GetSchemaValue<CHandle<CEntityInstance>>(m_ptr, "RelationshipOverride_t", "entity").Get()));
    return value;
}
void GRelationshipOverride_t::SetEntity(GCBaseEntity value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Entity' is not possible.\n");
}
uint64_t GRelationshipOverride_t::GetClassType() const {
    return GetSchemaValue<uint64_t>(m_ptr, "RelationshipOverride_t", "classType");
}
void GRelationshipOverride_t::SetClassType(uint64_t value) {
    SetSchemaValue(m_ptr, "RelationshipOverride_t", "classType", true, value);
}
void* GRelationshipOverride_t::GetPtr() {
    return m_ptr;
}
std::string GRelationshipOverride_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GRelationshipOverride_t::IsValid() {
    return (m_ptr != nullptr);
}
GRelationship_t GRelationshipOverride_t::GetParent() const {
    GRelationship_t value(m_ptr);
    return value;
}
void GRelationshipOverride_t::SetParent(GRelationship_t value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassRelationshipOverride_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GRelationshipOverride_t>("RelationshipOverride_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Entity", &GRelationshipOverride_t::GetEntity, &GRelationshipOverride_t::SetEntity)
        .addProperty("ClassType", &GRelationshipOverride_t::GetClassType, &GRelationshipOverride_t::SetClassType)
        .addProperty("Parent", &GRelationshipOverride_t::GetParent, &GRelationshipOverride_t::SetParent)
        .addFunction("ToPtr", &GRelationshipOverride_t::ToPtr)
        .addFunction("IsValid", &GRelationshipOverride_t::IsValid)
        .endClass();
}
GParticleAttributeIndex_t::GParticleAttributeIndex_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GParticleAttributeIndex_t::GParticleAttributeIndex_t(void *ptr) {
    m_ptr = ptr;
}
int32_t GParticleAttributeIndex_t::GetValue() const {
    return GetSchemaValue<int32_t>(m_ptr, "ParticleAttributeIndex_t", "m_Value");
}
void GParticleAttributeIndex_t::SetValue(int32_t value) {
    SetSchemaValue(m_ptr, "ParticleAttributeIndex_t", "m_Value", true, value);
}
void* GParticleAttributeIndex_t::GetPtr() {
    return m_ptr;
}
std::string GParticleAttributeIndex_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GParticleAttributeIndex_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassParticleAttributeIndex_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GParticleAttributeIndex_t>("ParticleAttributeIndex_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Value", &GParticleAttributeIndex_t::GetValue, &GParticleAttributeIndex_t::SetValue)
        .addFunction("ToPtr", &GParticleAttributeIndex_t::ToPtr)
        .addFunction("IsValid", &GParticleAttributeIndex_t::IsValid)
        .endClass();
}
GCParticleInput::GCParticleInput(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCParticleInput::GCParticleInput(void *ptr) {
    m_ptr = ptr;
}
void* GCParticleInput::GetPtr() {
    return m_ptr;
}
std::string GCParticleInput::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCParticleInput::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCParticleInput(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCParticleInput>("CParticleInput")
        .addConstructor<void (*)(std::string)>()
        .addFunction("ToPtr", &GCParticleInput::ToPtr)
        .addFunction("IsValid", &GCParticleInput::IsValid)
        .endClass();
}
GCParticleFloatInput::GCParticleFloatInput(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCParticleFloatInput::GCParticleFloatInput(void *ptr) {
    m_ptr = ptr;
}
uint64_t GCParticleFloatInput::GetType() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CParticleFloatInput", "m_nType");
}
void GCParticleFloatInput::SetType(uint64_t value) {
    SetSchemaValue(m_ptr, "CParticleFloatInput", "m_nType", false, value);
}
uint64_t GCParticleFloatInput::GetMapType() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CParticleFloatInput", "m_nMapType");
}
void GCParticleFloatInput::SetMapType(uint64_t value) {
    SetSchemaValue(m_ptr, "CParticleFloatInput", "m_nMapType", false, value);
}
float GCParticleFloatInput::GetLiteralValue() const {
    return GetSchemaValue<float>(m_ptr, "CParticleFloatInput", "m_flLiteralValue");
}
void GCParticleFloatInput::SetLiteralValue(float value) {
    SetSchemaValue(m_ptr, "CParticleFloatInput", "m_flLiteralValue", false, value);
}
int32_t GCParticleFloatInput::GetControlPoint() const {
    return GetSchemaValue<int32_t>(m_ptr, "CParticleFloatInput", "m_nControlPoint");
}
void GCParticleFloatInput::SetControlPoint(int32_t value) {
    SetSchemaValue(m_ptr, "CParticleFloatInput", "m_nControlPoint", false, value);
}
GParticleAttributeIndex_t GCParticleFloatInput::GetScalarAttribute() const {
    GParticleAttributeIndex_t value(GetSchemaPtr(m_ptr, "CParticleFloatInput", "m_nScalarAttribute"));
    return value;
}
void GCParticleFloatInput::SetScalarAttribute(GParticleAttributeIndex_t value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'ScalarAttribute' is not possible.\n");
}
GParticleAttributeIndex_t GCParticleFloatInput::GetVectorAttribute() const {
    GParticleAttributeIndex_t value(GetSchemaPtr(m_ptr, "CParticleFloatInput", "m_nVectorAttribute"));
    return value;
}
void GCParticleFloatInput::SetVectorAttribute(GParticleAttributeIndex_t value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'VectorAttribute' is not possible.\n");
}
int32_t GCParticleFloatInput::GetVectorComponent() const {
    return GetSchemaValue<int32_t>(m_ptr, "CParticleFloatInput", "m_nVectorComponent");
}
void GCParticleFloatInput::SetVectorComponent(int32_t value) {
    SetSchemaValue(m_ptr, "CParticleFloatInput", "m_nVectorComponent", false, value);
}
float GCParticleFloatInput::GetRandomMin() const {
    return GetSchemaValue<float>(m_ptr, "CParticleFloatInput", "m_flRandomMin");
}
void GCParticleFloatInput::SetRandomMin(float value) {
    SetSchemaValue(m_ptr, "CParticleFloatInput", "m_flRandomMin", false, value);
}
float GCParticleFloatInput::GetRandomMax() const {
    return GetSchemaValue<float>(m_ptr, "CParticleFloatInput", "m_flRandomMax");
}
void GCParticleFloatInput::SetRandomMax(float value) {
    SetSchemaValue(m_ptr, "CParticleFloatInput", "m_flRandomMax", false, value);
}
bool GCParticleFloatInput::GetHasRandomSignFlip() const {
    return GetSchemaValue<bool>(m_ptr, "CParticleFloatInput", "m_bHasRandomSignFlip");
}
void GCParticleFloatInput::SetHasRandomSignFlip(bool value) {
    SetSchemaValue(m_ptr, "CParticleFloatInput", "m_bHasRandomSignFlip", false, value);
}
int32_t GCParticleFloatInput::GetRandomSeed() const {
    return GetSchemaValue<int32_t>(m_ptr, "CParticleFloatInput", "m_nRandomSeed");
}
void GCParticleFloatInput::SetRandomSeed(int32_t value) {
    SetSchemaValue(m_ptr, "CParticleFloatInput", "m_nRandomSeed", false, value);
}
uint64_t GCParticleFloatInput::GetRandomMode() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CParticleFloatInput", "m_nRandomMode");
}
void GCParticleFloatInput::SetRandomMode(uint64_t value) {
    SetSchemaValue(m_ptr, "CParticleFloatInput", "m_nRandomMode", false, value);
}
float GCParticleFloatInput::GetLOD0() const {
    return GetSchemaValue<float>(m_ptr, "CParticleFloatInput", "m_flLOD0");
}
void GCParticleFloatInput::SetLOD0(float value) {
    SetSchemaValue(m_ptr, "CParticleFloatInput", "m_flLOD0", false, value);
}
float GCParticleFloatInput::GetLOD1() const {
    return GetSchemaValue<float>(m_ptr, "CParticleFloatInput", "m_flLOD1");
}
void GCParticleFloatInput::SetLOD1(float value) {
    SetSchemaValue(m_ptr, "CParticleFloatInput", "m_flLOD1", false, value);
}
float GCParticleFloatInput::GetLOD2() const {
    return GetSchemaValue<float>(m_ptr, "CParticleFloatInput", "m_flLOD2");
}
void GCParticleFloatInput::SetLOD2(float value) {
    SetSchemaValue(m_ptr, "CParticleFloatInput", "m_flLOD2", false, value);
}
float GCParticleFloatInput::GetLOD3() const {
    return GetSchemaValue<float>(m_ptr, "CParticleFloatInput", "m_flLOD3");
}
void GCParticleFloatInput::SetLOD3(float value) {
    SetSchemaValue(m_ptr, "CParticleFloatInput", "m_flLOD3", false, value);
}
GParticleAttributeIndex_t GCParticleFloatInput::GetNoiseInputVectorAttribute() const {
    GParticleAttributeIndex_t value(GetSchemaPtr(m_ptr, "CParticleFloatInput", "m_nNoiseInputVectorAttribute"));
    return value;
}
void GCParticleFloatInput::SetNoiseInputVectorAttribute(GParticleAttributeIndex_t value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'NoiseInputVectorAttribute' is not possible.\n");
}
float GCParticleFloatInput::GetNoiseOutputMin() const {
    return GetSchemaValue<float>(m_ptr, "CParticleFloatInput", "m_flNoiseOutputMin");
}
void GCParticleFloatInput::SetNoiseOutputMin(float value) {
    SetSchemaValue(m_ptr, "CParticleFloatInput", "m_flNoiseOutputMin", false, value);
}
float GCParticleFloatInput::GetNoiseOutputMax() const {
    return GetSchemaValue<float>(m_ptr, "CParticleFloatInput", "m_flNoiseOutputMax");
}
void GCParticleFloatInput::SetNoiseOutputMax(float value) {
    SetSchemaValue(m_ptr, "CParticleFloatInput", "m_flNoiseOutputMax", false, value);
}
float GCParticleFloatInput::GetNoiseScale() const {
    return GetSchemaValue<float>(m_ptr, "CParticleFloatInput", "m_flNoiseScale");
}
void GCParticleFloatInput::SetNoiseScale(float value) {
    SetSchemaValue(m_ptr, "CParticleFloatInput", "m_flNoiseScale", false, value);
}
Vector GCParticleFloatInput::GetNoiseOffsetRate() const {
    return GetSchemaValue<Vector>(m_ptr, "CParticleFloatInput", "m_vecNoiseOffsetRate");
}
void GCParticleFloatInput::SetNoiseOffsetRate(Vector value) {
    SetSchemaValue(m_ptr, "CParticleFloatInput", "m_vecNoiseOffsetRate", false, value);
}
float GCParticleFloatInput::GetNoiseOffset() const {
    return GetSchemaValue<float>(m_ptr, "CParticleFloatInput", "m_flNoiseOffset");
}
void GCParticleFloatInput::SetNoiseOffset(float value) {
    SetSchemaValue(m_ptr, "CParticleFloatInput", "m_flNoiseOffset", false, value);
}
int32_t GCParticleFloatInput::GetNoiseOctaves() const {
    return GetSchemaValue<int32_t>(m_ptr, "CParticleFloatInput", "m_nNoiseOctaves");
}
void GCParticleFloatInput::SetNoiseOctaves(int32_t value) {
    SetSchemaValue(m_ptr, "CParticleFloatInput", "m_nNoiseOctaves", false, value);
}
uint64_t GCParticleFloatInput::GetNoiseTurbulence() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CParticleFloatInput", "m_nNoiseTurbulence");
}
void GCParticleFloatInput::SetNoiseTurbulence(uint64_t value) {
    SetSchemaValue(m_ptr, "CParticleFloatInput", "m_nNoiseTurbulence", false, value);
}
uint64_t GCParticleFloatInput::GetNoiseType() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CParticleFloatInput", "m_nNoiseType");
}
void GCParticleFloatInput::SetNoiseType(uint64_t value) {
    SetSchemaValue(m_ptr, "CParticleFloatInput", "m_nNoiseType", false, value);
}
uint64_t GCParticleFloatInput::GetNoiseModifier() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CParticleFloatInput", "m_nNoiseModifier");
}
void GCParticleFloatInput::SetNoiseModifier(uint64_t value) {
    SetSchemaValue(m_ptr, "CParticleFloatInput", "m_nNoiseModifier", false, value);
}
float GCParticleFloatInput::GetNoiseTurbulenceScale() const {
    return GetSchemaValue<float>(m_ptr, "CParticleFloatInput", "m_flNoiseTurbulenceScale");
}
void GCParticleFloatInput::SetNoiseTurbulenceScale(float value) {
    SetSchemaValue(m_ptr, "CParticleFloatInput", "m_flNoiseTurbulenceScale", false, value);
}
float GCParticleFloatInput::GetNoiseTurbulenceMix() const {
    return GetSchemaValue<float>(m_ptr, "CParticleFloatInput", "m_flNoiseTurbulenceMix");
}
void GCParticleFloatInput::SetNoiseTurbulenceMix(float value) {
    SetSchemaValue(m_ptr, "CParticleFloatInput", "m_flNoiseTurbulenceMix", false, value);
}
float GCParticleFloatInput::GetNoiseImgPreviewScale() const {
    return GetSchemaValue<float>(m_ptr, "CParticleFloatInput", "m_flNoiseImgPreviewScale");
}
void GCParticleFloatInput::SetNoiseImgPreviewScale(float value) {
    SetSchemaValue(m_ptr, "CParticleFloatInput", "m_flNoiseImgPreviewScale", false, value);
}
bool GCParticleFloatInput::GetNoiseImgPreviewLive() const {
    return GetSchemaValue<bool>(m_ptr, "CParticleFloatInput", "m_bNoiseImgPreviewLive");
}
void GCParticleFloatInput::SetNoiseImgPreviewLive(bool value) {
    SetSchemaValue(m_ptr, "CParticleFloatInput", "m_bNoiseImgPreviewLive", false, value);
}
float GCParticleFloatInput::GetNoCameraFallback() const {
    return GetSchemaValue<float>(m_ptr, "CParticleFloatInput", "m_flNoCameraFallback");
}
void GCParticleFloatInput::SetNoCameraFallback(float value) {
    SetSchemaValue(m_ptr, "CParticleFloatInput", "m_flNoCameraFallback", false, value);
}
bool GCParticleFloatInput::GetUseBoundsCenter() const {
    return GetSchemaValue<bool>(m_ptr, "CParticleFloatInput", "m_bUseBoundsCenter");
}
void GCParticleFloatInput::SetUseBoundsCenter(bool value) {
    SetSchemaValue(m_ptr, "CParticleFloatInput", "m_bUseBoundsCenter", false, value);
}
uint64_t GCParticleFloatInput::GetInputMode() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CParticleFloatInput", "m_nInputMode");
}
void GCParticleFloatInput::SetInputMode(uint64_t value) {
    SetSchemaValue(m_ptr, "CParticleFloatInput", "m_nInputMode", false, value);
}
float GCParticleFloatInput::GetMultFactor() const {
    return GetSchemaValue<float>(m_ptr, "CParticleFloatInput", "m_flMultFactor");
}
void GCParticleFloatInput::SetMultFactor(float value) {
    SetSchemaValue(m_ptr, "CParticleFloatInput", "m_flMultFactor", false, value);
}
float GCParticleFloatInput::GetInput0() const {
    return GetSchemaValue<float>(m_ptr, "CParticleFloatInput", "m_flInput0");
}
void GCParticleFloatInput::SetInput0(float value) {
    SetSchemaValue(m_ptr, "CParticleFloatInput", "m_flInput0", false, value);
}
float GCParticleFloatInput::GetInput1() const {
    return GetSchemaValue<float>(m_ptr, "CParticleFloatInput", "m_flInput1");
}
void GCParticleFloatInput::SetInput1(float value) {
    SetSchemaValue(m_ptr, "CParticleFloatInput", "m_flInput1", false, value);
}
float GCParticleFloatInput::GetOutput0() const {
    return GetSchemaValue<float>(m_ptr, "CParticleFloatInput", "m_flOutput0");
}
void GCParticleFloatInput::SetOutput0(float value) {
    SetSchemaValue(m_ptr, "CParticleFloatInput", "m_flOutput0", false, value);
}
float GCParticleFloatInput::GetOutput1() const {
    return GetSchemaValue<float>(m_ptr, "CParticleFloatInput", "m_flOutput1");
}
void GCParticleFloatInput::SetOutput1(float value) {
    SetSchemaValue(m_ptr, "CParticleFloatInput", "m_flOutput1", false, value);
}
float GCParticleFloatInput::GetNotchedRangeMin() const {
    return GetSchemaValue<float>(m_ptr, "CParticleFloatInput", "m_flNotchedRangeMin");
}
void GCParticleFloatInput::SetNotchedRangeMin(float value) {
    SetSchemaValue(m_ptr, "CParticleFloatInput", "m_flNotchedRangeMin", false, value);
}
float GCParticleFloatInput::GetNotchedRangeMax() const {
    return GetSchemaValue<float>(m_ptr, "CParticleFloatInput", "m_flNotchedRangeMax");
}
void GCParticleFloatInput::SetNotchedRangeMax(float value) {
    SetSchemaValue(m_ptr, "CParticleFloatInput", "m_flNotchedRangeMax", false, value);
}
float GCParticleFloatInput::GetNotchedOutputOutside() const {
    return GetSchemaValue<float>(m_ptr, "CParticleFloatInput", "m_flNotchedOutputOutside");
}
void GCParticleFloatInput::SetNotchedOutputOutside(float value) {
    SetSchemaValue(m_ptr, "CParticleFloatInput", "m_flNotchedOutputOutside", false, value);
}
float GCParticleFloatInput::GetNotchedOutputInside() const {
    return GetSchemaValue<float>(m_ptr, "CParticleFloatInput", "m_flNotchedOutputInside");
}
void GCParticleFloatInput::SetNotchedOutputInside(float value) {
    SetSchemaValue(m_ptr, "CParticleFloatInput", "m_flNotchedOutputInside", false, value);
}
uint64_t GCParticleFloatInput::GetBiasType() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CParticleFloatInput", "m_nBiasType");
}
void GCParticleFloatInput::SetBiasType(uint64_t value) {
    SetSchemaValue(m_ptr, "CParticleFloatInput", "m_nBiasType", false, value);
}
float GCParticleFloatInput::GetBiasParameter() const {
    return GetSchemaValue<float>(m_ptr, "CParticleFloatInput", "m_flBiasParameter");
}
void GCParticleFloatInput::SetBiasParameter(float value) {
    SetSchemaValue(m_ptr, "CParticleFloatInput", "m_flBiasParameter", false, value);
}
void* GCParticleFloatInput::GetPtr() {
    return m_ptr;
}
std::string GCParticleFloatInput::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCParticleFloatInput::IsValid() {
    return (m_ptr != nullptr);
}
GCParticleInput GCParticleFloatInput::GetParent() const {
    GCParticleInput value(m_ptr);
    return value;
}
void GCParticleFloatInput::SetParent(GCParticleInput value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCParticleFloatInput(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCParticleFloatInput>("CParticleFloatInput")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Type", &GCParticleFloatInput::GetType, &GCParticleFloatInput::SetType)
        .addProperty("MapType", &GCParticleFloatInput::GetMapType, &GCParticleFloatInput::SetMapType)
        .addProperty("LiteralValue", &GCParticleFloatInput::GetLiteralValue, &GCParticleFloatInput::SetLiteralValue)
        .addProperty("ControlPoint", &GCParticleFloatInput::GetControlPoint, &GCParticleFloatInput::SetControlPoint)
        .addProperty("ScalarAttribute", &GCParticleFloatInput::GetScalarAttribute, &GCParticleFloatInput::SetScalarAttribute)
        .addProperty("VectorAttribute", &GCParticleFloatInput::GetVectorAttribute, &GCParticleFloatInput::SetVectorAttribute)
        .addProperty("VectorComponent", &GCParticleFloatInput::GetVectorComponent, &GCParticleFloatInput::SetVectorComponent)
        .addProperty("RandomMin", &GCParticleFloatInput::GetRandomMin, &GCParticleFloatInput::SetRandomMin)
        .addProperty("RandomMax", &GCParticleFloatInput::GetRandomMax, &GCParticleFloatInput::SetRandomMax)
        .addProperty("HasRandomSignFlip", &GCParticleFloatInput::GetHasRandomSignFlip, &GCParticleFloatInput::SetHasRandomSignFlip)
        .addProperty("RandomSeed", &GCParticleFloatInput::GetRandomSeed, &GCParticleFloatInput::SetRandomSeed)
        .addProperty("RandomMode", &GCParticleFloatInput::GetRandomMode, &GCParticleFloatInput::SetRandomMode)
        .addProperty("LOD0", &GCParticleFloatInput::GetLOD0, &GCParticleFloatInput::SetLOD0)
        .addProperty("LOD1", &GCParticleFloatInput::GetLOD1, &GCParticleFloatInput::SetLOD1)
        .addProperty("LOD2", &GCParticleFloatInput::GetLOD2, &GCParticleFloatInput::SetLOD2)
        .addProperty("LOD3", &GCParticleFloatInput::GetLOD3, &GCParticleFloatInput::SetLOD3)
        .addProperty("NoiseInputVectorAttribute", &GCParticleFloatInput::GetNoiseInputVectorAttribute, &GCParticleFloatInput::SetNoiseInputVectorAttribute)
        .addProperty("NoiseOutputMin", &GCParticleFloatInput::GetNoiseOutputMin, &GCParticleFloatInput::SetNoiseOutputMin)
        .addProperty("NoiseOutputMax", &GCParticleFloatInput::GetNoiseOutputMax, &GCParticleFloatInput::SetNoiseOutputMax)
        .addProperty("NoiseScale", &GCParticleFloatInput::GetNoiseScale, &GCParticleFloatInput::SetNoiseScale)
        .addProperty("NoiseOffsetRate", &GCParticleFloatInput::GetNoiseOffsetRate, &GCParticleFloatInput::SetNoiseOffsetRate)
        .addProperty("NoiseOffset", &GCParticleFloatInput::GetNoiseOffset, &GCParticleFloatInput::SetNoiseOffset)
        .addProperty("NoiseOctaves", &GCParticleFloatInput::GetNoiseOctaves, &GCParticleFloatInput::SetNoiseOctaves)
        .addProperty("NoiseTurbulence", &GCParticleFloatInput::GetNoiseTurbulence, &GCParticleFloatInput::SetNoiseTurbulence)
        .addProperty("NoiseType", &GCParticleFloatInput::GetNoiseType, &GCParticleFloatInput::SetNoiseType)
        .addProperty("NoiseModifier", &GCParticleFloatInput::GetNoiseModifier, &GCParticleFloatInput::SetNoiseModifier)
        .addProperty("NoiseTurbulenceScale", &GCParticleFloatInput::GetNoiseTurbulenceScale, &GCParticleFloatInput::SetNoiseTurbulenceScale)
        .addProperty("NoiseTurbulenceMix", &GCParticleFloatInput::GetNoiseTurbulenceMix, &GCParticleFloatInput::SetNoiseTurbulenceMix)
        .addProperty("NoiseImgPreviewScale", &GCParticleFloatInput::GetNoiseImgPreviewScale, &GCParticleFloatInput::SetNoiseImgPreviewScale)
        .addProperty("NoiseImgPreviewLive", &GCParticleFloatInput::GetNoiseImgPreviewLive, &GCParticleFloatInput::SetNoiseImgPreviewLive)
        .addProperty("NoCameraFallback", &GCParticleFloatInput::GetNoCameraFallback, &GCParticleFloatInput::SetNoCameraFallback)
        .addProperty("UseBoundsCenter", &GCParticleFloatInput::GetUseBoundsCenter, &GCParticleFloatInput::SetUseBoundsCenter)
        .addProperty("InputMode", &GCParticleFloatInput::GetInputMode, &GCParticleFloatInput::SetInputMode)
        .addProperty("MultFactor", &GCParticleFloatInput::GetMultFactor, &GCParticleFloatInput::SetMultFactor)
        .addProperty("Input0", &GCParticleFloatInput::GetInput0, &GCParticleFloatInput::SetInput0)
        .addProperty("Input1", &GCParticleFloatInput::GetInput1, &GCParticleFloatInput::SetInput1)
        .addProperty("Output0", &GCParticleFloatInput::GetOutput0, &GCParticleFloatInput::SetOutput0)
        .addProperty("Output1", &GCParticleFloatInput::GetOutput1, &GCParticleFloatInput::SetOutput1)
        .addProperty("NotchedRangeMin", &GCParticleFloatInput::GetNotchedRangeMin, &GCParticleFloatInput::SetNotchedRangeMin)
        .addProperty("NotchedRangeMax", &GCParticleFloatInput::GetNotchedRangeMax, &GCParticleFloatInput::SetNotchedRangeMax)
        .addProperty("NotchedOutputOutside", &GCParticleFloatInput::GetNotchedOutputOutside, &GCParticleFloatInput::SetNotchedOutputOutside)
        .addProperty("NotchedOutputInside", &GCParticleFloatInput::GetNotchedOutputInside, &GCParticleFloatInput::SetNotchedOutputInside)
        .addProperty("BiasType", &GCParticleFloatInput::GetBiasType, &GCParticleFloatInput::SetBiasType)
        .addProperty("BiasParameter", &GCParticleFloatInput::GetBiasParameter, &GCParticleFloatInput::SetBiasParameter)
        .addProperty("Parent", &GCParticleFloatInput::GetParent, &GCParticleFloatInput::SetParent)
        .addFunction("ToPtr", &GCParticleFloatInput::ToPtr)
        .addFunction("IsValid", &GCParticleFloatInput::IsValid)
        .endClass();
}
GVoxelVisBlockOffset_t::GVoxelVisBlockOffset_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GVoxelVisBlockOffset_t::GVoxelVisBlockOffset_t(void *ptr) {
    m_ptr = ptr;
}
uint32_t GVoxelVisBlockOffset_t::GetOffset() const {
    return GetSchemaValue<uint32_t>(m_ptr, "VoxelVisBlockOffset_t", "m_nOffset");
}
void GVoxelVisBlockOffset_t::SetOffset(uint32_t value) {
    SetSchemaValue(m_ptr, "VoxelVisBlockOffset_t", "m_nOffset", true, value);
}
uint32_t GVoxelVisBlockOffset_t::GetElementCount() const {
    return GetSchemaValue<uint32_t>(m_ptr, "VoxelVisBlockOffset_t", "m_nElementCount");
}
void GVoxelVisBlockOffset_t::SetElementCount(uint32_t value) {
    SetSchemaValue(m_ptr, "VoxelVisBlockOffset_t", "m_nElementCount", true, value);
}
void* GVoxelVisBlockOffset_t::GetPtr() {
    return m_ptr;
}
std::string GVoxelVisBlockOffset_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GVoxelVisBlockOffset_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassVoxelVisBlockOffset_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GVoxelVisBlockOffset_t>("VoxelVisBlockOffset_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Offset", &GVoxelVisBlockOffset_t::GetOffset, &GVoxelVisBlockOffset_t::SetOffset)
        .addProperty("ElementCount", &GVoxelVisBlockOffset_t::GetElementCount, &GVoxelVisBlockOffset_t::SetElementCount)
        .addFunction("ToPtr", &GVoxelVisBlockOffset_t::ToPtr)
        .addFunction("IsValid", &GVoxelVisBlockOffset_t::IsValid)
        .endClass();
}
GAggregateLODSetup_t::GAggregateLODSetup_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GAggregateLODSetup_t::GAggregateLODSetup_t(void *ptr) {
    m_ptr = ptr;
}
Vector GAggregateLODSetup_t::GetLODOrigin() const {
    return GetSchemaValue<Vector>(m_ptr, "AggregateLODSetup_t", "m_vLODOrigin");
}
void GAggregateLODSetup_t::SetLODOrigin(Vector value) {
    SetSchemaValue(m_ptr, "AggregateLODSetup_t", "m_vLODOrigin", true, value);
}
float GAggregateLODSetup_t::GetMaxObjectScale() const {
    return GetSchemaValue<float>(m_ptr, "AggregateLODSetup_t", "m_fMaxObjectScale");
}
void GAggregateLODSetup_t::SetMaxObjectScale(float value) {
    SetSchemaValue(m_ptr, "AggregateLODSetup_t", "m_fMaxObjectScale", true, value);
}
std::vector<float32> GAggregateLODSetup_t::GetSwitchDistances() const {
    CUtlVector<float32>* vec = GetSchemaValue<CUtlVector<float32>*>(m_ptr, "AggregateLODSetup_t", "m_fSwitchDistances"); std::vector<float32> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GAggregateLODSetup_t::SetSwitchDistances(std::vector<float32> value) {
    SetSchemaValueCUtlVector<float32>(m_ptr, "AggregateLODSetup_t", "m_fSwitchDistances", true, value);
}
void* GAggregateLODSetup_t::GetPtr() {
    return m_ptr;
}
std::string GAggregateLODSetup_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GAggregateLODSetup_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassAggregateLODSetup_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GAggregateLODSetup_t>("AggregateLODSetup_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("LODOrigin", &GAggregateLODSetup_t::GetLODOrigin, &GAggregateLODSetup_t::SetLODOrigin)
        .addProperty("MaxObjectScale", &GAggregateLODSetup_t::GetMaxObjectScale, &GAggregateLODSetup_t::SetMaxObjectScale)
        .addProperty("SwitchDistances", &GAggregateLODSetup_t::GetSwitchDistances, &GAggregateLODSetup_t::SetSwitchDistances)
        .addFunction("ToPtr", &GAggregateLODSetup_t::ToPtr)
        .addFunction("IsValid", &GAggregateLODSetup_t::IsValid)
        .endClass();
}
GCProductQuantizer::GCProductQuantizer(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCProductQuantizer::GCProductQuantizer(void *ptr) {
    m_ptr = ptr;
}
std::vector<GCVectorQuantizer> GCProductQuantizer::GetSubQuantizers() const {
    CUtlVector<GCVectorQuantizer>* vec = GetSchemaValue<CUtlVector<GCVectorQuantizer>*>(m_ptr, "CProductQuantizer", "m_subQuantizers"); std::vector<GCVectorQuantizer> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCProductQuantizer::SetSubQuantizers(std::vector<GCVectorQuantizer> value) {
    SetSchemaValueCUtlVector<GCVectorQuantizer>(m_ptr, "CProductQuantizer", "m_subQuantizers", false, value);
}
int32_t GCProductQuantizer::GetDimensions() const {
    return GetSchemaValue<int32_t>(m_ptr, "CProductQuantizer", "m_nDimensions");
}
void GCProductQuantizer::SetDimensions(int32_t value) {
    SetSchemaValue(m_ptr, "CProductQuantizer", "m_nDimensions", false, value);
}
void* GCProductQuantizer::GetPtr() {
    return m_ptr;
}
std::string GCProductQuantizer::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCProductQuantizer::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCProductQuantizer(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCProductQuantizer>("CProductQuantizer")
        .addConstructor<void (*)(std::string)>()
        .addProperty("SubQuantizers", &GCProductQuantizer::GetSubQuantizers, &GCProductQuantizer::SetSubQuantizers)
        .addProperty("Dimensions", &GCProductQuantizer::GetDimensions, &GCProductQuantizer::SetDimensions)
        .addFunction("ToPtr", &GCProductQuantizer::ToPtr)
        .addFunction("IsValid", &GCProductQuantizer::IsValid)
        .endClass();
}
GCAnimUpdateNodeRef::GCAnimUpdateNodeRef(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCAnimUpdateNodeRef::GCAnimUpdateNodeRef(void *ptr) {
    m_ptr = ptr;
}
int32_t GCAnimUpdateNodeRef::GetNodeIndex() const {
    return GetSchemaValue<int32_t>(m_ptr, "CAnimUpdateNodeRef", "m_nodeIndex");
}
void GCAnimUpdateNodeRef::SetNodeIndex(int32_t value) {
    SetSchemaValue(m_ptr, "CAnimUpdateNodeRef", "m_nodeIndex", false, value);
}
void* GCAnimUpdateNodeRef::GetPtr() {
    return m_ptr;
}
std::string GCAnimUpdateNodeRef::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCAnimUpdateNodeRef::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCAnimUpdateNodeRef(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCAnimUpdateNodeRef>("CAnimUpdateNodeRef")
        .addConstructor<void (*)(std::string)>()
        .addProperty("NodeIndex", &GCAnimUpdateNodeRef::GetNodeIndex, &GCAnimUpdateNodeRef::SetNodeIndex)
        .addFunction("ToPtr", &GCAnimUpdateNodeRef::ToPtr)
        .addFunction("IsValid", &GCAnimUpdateNodeRef::IsValid)
        .endClass();
}
GCNmGraphNode::GCNmGraphNode(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCNmGraphNode::GCNmGraphNode(void *ptr) {
    m_ptr = ptr;
}
int16_t GCNmGraphNode::GetNodeIdx() const {
    return GetSchemaValue<int16_t>(m_ptr, "CNmGraphNode", "m_nNodeIdx");
}
void GCNmGraphNode::SetNodeIdx(int16_t value) {
    SetSchemaValue(m_ptr, "CNmGraphNode", "m_nNodeIdx", false, value);
}
void* GCNmGraphNode::GetPtr() {
    return m_ptr;
}
std::string GCNmGraphNode::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCNmGraphNode::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCNmGraphNode(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCNmGraphNode>("CNmGraphNode")
        .addConstructor<void (*)(std::string)>()
        .addProperty("NodeIdx", &GCNmGraphNode::GetNodeIdx, &GCNmGraphNode::SetNodeIdx)
        .addFunction("ToPtr", &GCNmGraphNode::ToPtr)
        .addFunction("IsValid", &GCNmGraphNode::IsValid)
        .endClass();
}
GCParticleCollectionFloatInput::GCParticleCollectionFloatInput(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCParticleCollectionFloatInput::GCParticleCollectionFloatInput(void *ptr) {
    m_ptr = ptr;
}
void* GCParticleCollectionFloatInput::GetPtr() {
    return m_ptr;
}
std::string GCParticleCollectionFloatInput::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCParticleCollectionFloatInput::IsValid() {
    return (m_ptr != nullptr);
}
GCParticleFloatInput GCParticleCollectionFloatInput::GetParent() const {
    GCParticleFloatInput value(m_ptr);
    return value;
}
void GCParticleCollectionFloatInput::SetParent(GCParticleFloatInput value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCParticleCollectionFloatInput(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCParticleCollectionFloatInput>("CParticleCollectionFloatInput")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCParticleCollectionFloatInput::GetParent, &GCParticleCollectionFloatInput::SetParent)
        .addFunction("ToPtr", &GCParticleCollectionFloatInput::ToPtr)
        .addFunction("IsValid", &GCParticleCollectionFloatInput::IsValid)
        .endClass();
}
GCParticleFunction::GCParticleFunction(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCParticleFunction::GCParticleFunction(void *ptr) {
    m_ptr = ptr;
}
GCParticleCollectionFloatInput GCParticleFunction::GetOpStrength() const {
    GCParticleCollectionFloatInput value(GetSchemaPtr(m_ptr, "CParticleFunction", "m_flOpStrength"));
    return value;
}
void GCParticleFunction::SetOpStrength(GCParticleCollectionFloatInput value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'OpStrength' is not possible.\n");
}
uint64_t GCParticleFunction::GetOpEndCapState() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CParticleFunction", "m_nOpEndCapState");
}
void GCParticleFunction::SetOpEndCapState(uint64_t value) {
    SetSchemaValue(m_ptr, "CParticleFunction", "m_nOpEndCapState", false, value);
}
float GCParticleFunction::GetOpStartFadeInTime() const {
    return GetSchemaValue<float>(m_ptr, "CParticleFunction", "m_flOpStartFadeInTime");
}
void GCParticleFunction::SetOpStartFadeInTime(float value) {
    SetSchemaValue(m_ptr, "CParticleFunction", "m_flOpStartFadeInTime", false, value);
}
float GCParticleFunction::GetOpEndFadeInTime() const {
    return GetSchemaValue<float>(m_ptr, "CParticleFunction", "m_flOpEndFadeInTime");
}
void GCParticleFunction::SetOpEndFadeInTime(float value) {
    SetSchemaValue(m_ptr, "CParticleFunction", "m_flOpEndFadeInTime", false, value);
}
float GCParticleFunction::GetOpStartFadeOutTime() const {
    return GetSchemaValue<float>(m_ptr, "CParticleFunction", "m_flOpStartFadeOutTime");
}
void GCParticleFunction::SetOpStartFadeOutTime(float value) {
    SetSchemaValue(m_ptr, "CParticleFunction", "m_flOpStartFadeOutTime", false, value);
}
float GCParticleFunction::GetOpEndFadeOutTime() const {
    return GetSchemaValue<float>(m_ptr, "CParticleFunction", "m_flOpEndFadeOutTime");
}
void GCParticleFunction::SetOpEndFadeOutTime(float value) {
    SetSchemaValue(m_ptr, "CParticleFunction", "m_flOpEndFadeOutTime", false, value);
}
float GCParticleFunction::GetOpFadeOscillatePeriod() const {
    return GetSchemaValue<float>(m_ptr, "CParticleFunction", "m_flOpFadeOscillatePeriod");
}
void GCParticleFunction::SetOpFadeOscillatePeriod(float value) {
    SetSchemaValue(m_ptr, "CParticleFunction", "m_flOpFadeOscillatePeriod", false, value);
}
bool GCParticleFunction::GetNormalizeToStopTime() const {
    return GetSchemaValue<bool>(m_ptr, "CParticleFunction", "m_bNormalizeToStopTime");
}
void GCParticleFunction::SetNormalizeToStopTime(bool value) {
    SetSchemaValue(m_ptr, "CParticleFunction", "m_bNormalizeToStopTime", false, value);
}
float GCParticleFunction::GetOpTimeOffsetMin() const {
    return GetSchemaValue<float>(m_ptr, "CParticleFunction", "m_flOpTimeOffsetMin");
}
void GCParticleFunction::SetOpTimeOffsetMin(float value) {
    SetSchemaValue(m_ptr, "CParticleFunction", "m_flOpTimeOffsetMin", false, value);
}
float GCParticleFunction::GetOpTimeOffsetMax() const {
    return GetSchemaValue<float>(m_ptr, "CParticleFunction", "m_flOpTimeOffsetMax");
}
void GCParticleFunction::SetOpTimeOffsetMax(float value) {
    SetSchemaValue(m_ptr, "CParticleFunction", "m_flOpTimeOffsetMax", false, value);
}
int32_t GCParticleFunction::GetOpTimeOffsetSeed() const {
    return GetSchemaValue<int32_t>(m_ptr, "CParticleFunction", "m_nOpTimeOffsetSeed");
}
void GCParticleFunction::SetOpTimeOffsetSeed(int32_t value) {
    SetSchemaValue(m_ptr, "CParticleFunction", "m_nOpTimeOffsetSeed", false, value);
}
int32_t GCParticleFunction::GetOpTimeScaleSeed() const {
    return GetSchemaValue<int32_t>(m_ptr, "CParticleFunction", "m_nOpTimeScaleSeed");
}
void GCParticleFunction::SetOpTimeScaleSeed(int32_t value) {
    SetSchemaValue(m_ptr, "CParticleFunction", "m_nOpTimeScaleSeed", false, value);
}
float GCParticleFunction::GetOpTimeScaleMin() const {
    return GetSchemaValue<float>(m_ptr, "CParticleFunction", "m_flOpTimeScaleMin");
}
void GCParticleFunction::SetOpTimeScaleMin(float value) {
    SetSchemaValue(m_ptr, "CParticleFunction", "m_flOpTimeScaleMin", false, value);
}
float GCParticleFunction::GetOpTimeScaleMax() const {
    return GetSchemaValue<float>(m_ptr, "CParticleFunction", "m_flOpTimeScaleMax");
}
void GCParticleFunction::SetOpTimeScaleMax(float value) {
    SetSchemaValue(m_ptr, "CParticleFunction", "m_flOpTimeScaleMax", false, value);
}
bool GCParticleFunction::GetDisableOperator() const {
    return GetSchemaValue<bool>(m_ptr, "CParticleFunction", "m_bDisableOperator");
}
void GCParticleFunction::SetDisableOperator(bool value) {
    SetSchemaValue(m_ptr, "CParticleFunction", "m_bDisableOperator", false, value);
}
std::string GCParticleFunction::GetNotes() const {
    return GetSchemaValue<CUtlString>(m_ptr, "CParticleFunction", "m_Notes").Get();
}
void GCParticleFunction::SetNotes(std::string value) {
    SetSchemaValue(m_ptr, "CParticleFunction", "m_Notes", false, CUtlString(value.c_str()));
}
void* GCParticleFunction::GetPtr() {
    return m_ptr;
}
std::string GCParticleFunction::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCParticleFunction::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCParticleFunction(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCParticleFunction>("CParticleFunction")
        .addConstructor<void (*)(std::string)>()
        .addProperty("OpStrength", &GCParticleFunction::GetOpStrength, &GCParticleFunction::SetOpStrength)
        .addProperty("OpEndCapState", &GCParticleFunction::GetOpEndCapState, &GCParticleFunction::SetOpEndCapState)
        .addProperty("OpStartFadeInTime", &GCParticleFunction::GetOpStartFadeInTime, &GCParticleFunction::SetOpStartFadeInTime)
        .addProperty("OpEndFadeInTime", &GCParticleFunction::GetOpEndFadeInTime, &GCParticleFunction::SetOpEndFadeInTime)
        .addProperty("OpStartFadeOutTime", &GCParticleFunction::GetOpStartFadeOutTime, &GCParticleFunction::SetOpStartFadeOutTime)
        .addProperty("OpEndFadeOutTime", &GCParticleFunction::GetOpEndFadeOutTime, &GCParticleFunction::SetOpEndFadeOutTime)
        .addProperty("OpFadeOscillatePeriod", &GCParticleFunction::GetOpFadeOscillatePeriod, &GCParticleFunction::SetOpFadeOscillatePeriod)
        .addProperty("NormalizeToStopTime", &GCParticleFunction::GetNormalizeToStopTime, &GCParticleFunction::SetNormalizeToStopTime)
        .addProperty("OpTimeOffsetMin", &GCParticleFunction::GetOpTimeOffsetMin, &GCParticleFunction::SetOpTimeOffsetMin)
        .addProperty("OpTimeOffsetMax", &GCParticleFunction::GetOpTimeOffsetMax, &GCParticleFunction::SetOpTimeOffsetMax)
        .addProperty("OpTimeOffsetSeed", &GCParticleFunction::GetOpTimeOffsetSeed, &GCParticleFunction::SetOpTimeOffsetSeed)
        .addProperty("OpTimeScaleSeed", &GCParticleFunction::GetOpTimeScaleSeed, &GCParticleFunction::SetOpTimeScaleSeed)
        .addProperty("OpTimeScaleMin", &GCParticleFunction::GetOpTimeScaleMin, &GCParticleFunction::SetOpTimeScaleMin)
        .addProperty("OpTimeScaleMax", &GCParticleFunction::GetOpTimeScaleMax, &GCParticleFunction::SetOpTimeScaleMax)
        .addProperty("DisableOperator", &GCParticleFunction::GetDisableOperator, &GCParticleFunction::SetDisableOperator)
        .addProperty("Notes", &GCParticleFunction::GetNotes, &GCParticleFunction::SetNotes)
        .addFunction("ToPtr", &GCParticleFunction::ToPtr)
        .addFunction("IsValid", &GCParticleFunction::IsValid)
        .endClass();
}
GCParticleFunctionOperator::GCParticleFunctionOperator(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCParticleFunctionOperator::GCParticleFunctionOperator(void *ptr) {
    m_ptr = ptr;
}
void* GCParticleFunctionOperator::GetPtr() {
    return m_ptr;
}
std::string GCParticleFunctionOperator::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCParticleFunctionOperator::IsValid() {
    return (m_ptr != nullptr);
}
GCParticleFunction GCParticleFunctionOperator::GetParent() const {
    GCParticleFunction value(m_ptr);
    return value;
}
void GCParticleFunctionOperator::SetParent(GCParticleFunction value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCParticleFunctionOperator(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCParticleFunctionOperator>("CParticleFunctionOperator")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCParticleFunctionOperator::GetParent, &GCParticleFunctionOperator::SetParent)
        .addFunction("ToPtr", &GCParticleFunctionOperator::ToPtr)
        .addFunction("IsValid", &GCParticleFunctionOperator::IsValid)
        .endClass();
}
GPARTICLE_WORLD_HANDLE__::GPARTICLE_WORLD_HANDLE__(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GPARTICLE_WORLD_HANDLE__::GPARTICLE_WORLD_HANDLE__(void *ptr) {
    m_ptr = ptr;
}
int32_t GPARTICLE_WORLD_HANDLE__::GetUnused() const {
    return GetSchemaValue<int32_t>(m_ptr, "PARTICLE_WORLD_HANDLE__", "unused");
}
void GPARTICLE_WORLD_HANDLE__::SetUnused(int32_t value) {
    SetSchemaValue(m_ptr, "PARTICLE_WORLD_HANDLE__", "unused", false, value);
}
void* GPARTICLE_WORLD_HANDLE__::GetPtr() {
    return m_ptr;
}
std::string GPARTICLE_WORLD_HANDLE__::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GPARTICLE_WORLD_HANDLE__::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassPARTICLE_WORLD_HANDLE__(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GPARTICLE_WORLD_HANDLE__>("PARTICLE_WORLD_HANDLE__")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Unused", &GPARTICLE_WORLD_HANDLE__::GetUnused, &GPARTICLE_WORLD_HANDLE__::SetUnused)
        .addFunction("ToPtr", &GPARTICLE_WORLD_HANDLE__::ToPtr)
        .addFunction("IsValid", &GPARTICLE_WORLD_HANDLE__::IsValid)
        .endClass();
}
GVMixDynamicsCompressorDesc_t::GVMixDynamicsCompressorDesc_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GVMixDynamicsCompressorDesc_t::GVMixDynamicsCompressorDesc_t(void *ptr) {
    m_ptr = ptr;
}
float GVMixDynamicsCompressorDesc_t::GetFldbOutputGain() const {
    return GetSchemaValue<float>(m_ptr, "VMixDynamicsCompressorDesc_t", "m_fldbOutputGain");
}
void GVMixDynamicsCompressorDesc_t::SetFldbOutputGain(float value) {
    SetSchemaValue(m_ptr, "VMixDynamicsCompressorDesc_t", "m_fldbOutputGain", true, value);
}
float GVMixDynamicsCompressorDesc_t::GetFldbCompressionThreshold() const {
    return GetSchemaValue<float>(m_ptr, "VMixDynamicsCompressorDesc_t", "m_fldbCompressionThreshold");
}
void GVMixDynamicsCompressorDesc_t::SetFldbCompressionThreshold(float value) {
    SetSchemaValue(m_ptr, "VMixDynamicsCompressorDesc_t", "m_fldbCompressionThreshold", true, value);
}
float GVMixDynamicsCompressorDesc_t::GetFldbKneeWidth() const {
    return GetSchemaValue<float>(m_ptr, "VMixDynamicsCompressorDesc_t", "m_fldbKneeWidth");
}
void GVMixDynamicsCompressorDesc_t::SetFldbKneeWidth(float value) {
    SetSchemaValue(m_ptr, "VMixDynamicsCompressorDesc_t", "m_fldbKneeWidth", true, value);
}
float GVMixDynamicsCompressorDesc_t::GetCompressionRatio() const {
    return GetSchemaValue<float>(m_ptr, "VMixDynamicsCompressorDesc_t", "m_flCompressionRatio");
}
void GVMixDynamicsCompressorDesc_t::SetCompressionRatio(float value) {
    SetSchemaValue(m_ptr, "VMixDynamicsCompressorDesc_t", "m_flCompressionRatio", true, value);
}
float GVMixDynamicsCompressorDesc_t::GetAttackTimeMS() const {
    return GetSchemaValue<float>(m_ptr, "VMixDynamicsCompressorDesc_t", "m_flAttackTimeMS");
}
void GVMixDynamicsCompressorDesc_t::SetAttackTimeMS(float value) {
    SetSchemaValue(m_ptr, "VMixDynamicsCompressorDesc_t", "m_flAttackTimeMS", true, value);
}
float GVMixDynamicsCompressorDesc_t::GetReleaseTimeMS() const {
    return GetSchemaValue<float>(m_ptr, "VMixDynamicsCompressorDesc_t", "m_flReleaseTimeMS");
}
void GVMixDynamicsCompressorDesc_t::SetReleaseTimeMS(float value) {
    SetSchemaValue(m_ptr, "VMixDynamicsCompressorDesc_t", "m_flReleaseTimeMS", true, value);
}
float GVMixDynamicsCompressorDesc_t::GetRMSTimeMS() const {
    return GetSchemaValue<float>(m_ptr, "VMixDynamicsCompressorDesc_t", "m_flRMSTimeMS");
}
void GVMixDynamicsCompressorDesc_t::SetRMSTimeMS(float value) {
    SetSchemaValue(m_ptr, "VMixDynamicsCompressorDesc_t", "m_flRMSTimeMS", true, value);
}
float GVMixDynamicsCompressorDesc_t::GetWetMix() const {
    return GetSchemaValue<float>(m_ptr, "VMixDynamicsCompressorDesc_t", "m_flWetMix");
}
void GVMixDynamicsCompressorDesc_t::SetWetMix(float value) {
    SetSchemaValue(m_ptr, "VMixDynamicsCompressorDesc_t", "m_flWetMix", true, value);
}
bool GVMixDynamicsCompressorDesc_t::GetPeakMode() const {
    return GetSchemaValue<bool>(m_ptr, "VMixDynamicsCompressorDesc_t", "m_bPeakMode");
}
void GVMixDynamicsCompressorDesc_t::SetPeakMode(bool value) {
    SetSchemaValue(m_ptr, "VMixDynamicsCompressorDesc_t", "m_bPeakMode", true, value);
}
void* GVMixDynamicsCompressorDesc_t::GetPtr() {
    return m_ptr;
}
std::string GVMixDynamicsCompressorDesc_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GVMixDynamicsCompressorDesc_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassVMixDynamicsCompressorDesc_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GVMixDynamicsCompressorDesc_t>("VMixDynamicsCompressorDesc_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("FldbOutputGain", &GVMixDynamicsCompressorDesc_t::GetFldbOutputGain, &GVMixDynamicsCompressorDesc_t::SetFldbOutputGain)
        .addProperty("FldbCompressionThreshold", &GVMixDynamicsCompressorDesc_t::GetFldbCompressionThreshold, &GVMixDynamicsCompressorDesc_t::SetFldbCompressionThreshold)
        .addProperty("FldbKneeWidth", &GVMixDynamicsCompressorDesc_t::GetFldbKneeWidth, &GVMixDynamicsCompressorDesc_t::SetFldbKneeWidth)
        .addProperty("CompressionRatio", &GVMixDynamicsCompressorDesc_t::GetCompressionRatio, &GVMixDynamicsCompressorDesc_t::SetCompressionRatio)
        .addProperty("AttackTimeMS", &GVMixDynamicsCompressorDesc_t::GetAttackTimeMS, &GVMixDynamicsCompressorDesc_t::SetAttackTimeMS)
        .addProperty("ReleaseTimeMS", &GVMixDynamicsCompressorDesc_t::GetReleaseTimeMS, &GVMixDynamicsCompressorDesc_t::SetReleaseTimeMS)
        .addProperty("RMSTimeMS", &GVMixDynamicsCompressorDesc_t::GetRMSTimeMS, &GVMixDynamicsCompressorDesc_t::SetRMSTimeMS)
        .addProperty("WetMix", &GVMixDynamicsCompressorDesc_t::GetWetMix, &GVMixDynamicsCompressorDesc_t::SetWetMix)
        .addProperty("PeakMode", &GVMixDynamicsCompressorDesc_t::GetPeakMode, &GVMixDynamicsCompressorDesc_t::SetPeakMode)
        .addFunction("ToPtr", &GVMixDynamicsCompressorDesc_t::ToPtr)
        .addFunction("IsValid", &GVMixDynamicsCompressorDesc_t::IsValid)
        .endClass();
}
GFootStepTrigger::GFootStepTrigger(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GFootStepTrigger::GFootStepTrigger(void *ptr) {
    m_ptr = ptr;
}
std::vector<int32> GFootStepTrigger::GetTags() const {
    CUtlVector<int32>* vec = GetSchemaValue<CUtlVector<int32>*>(m_ptr, "FootStepTrigger", "m_tags"); std::vector<int32> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GFootStepTrigger::SetTags(std::vector<int32> value) {
    SetSchemaValueCUtlVector<int32>(m_ptr, "FootStepTrigger", "m_tags", false, value);
}
int32_t GFootStepTrigger::GetFootIndex() const {
    return GetSchemaValue<int32_t>(m_ptr, "FootStepTrigger", "m_nFootIndex");
}
void GFootStepTrigger::SetFootIndex(int32_t value) {
    SetSchemaValue(m_ptr, "FootStepTrigger", "m_nFootIndex", false, value);
}
uint64_t GFootStepTrigger::GetTriggerPhase() const {
    return GetSchemaValue<uint64_t>(m_ptr, "FootStepTrigger", "m_triggerPhase");
}
void GFootStepTrigger::SetTriggerPhase(uint64_t value) {
    SetSchemaValue(m_ptr, "FootStepTrigger", "m_triggerPhase", false, value);
}
void* GFootStepTrigger::GetPtr() {
    return m_ptr;
}
std::string GFootStepTrigger::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GFootStepTrigger::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassFootStepTrigger(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GFootStepTrigger>("FootStepTrigger")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Tags", &GFootStepTrigger::GetTags, &GFootStepTrigger::SetTags)
        .addProperty("FootIndex", &GFootStepTrigger::GetFootIndex, &GFootStepTrigger::SetFootIndex)
        .addProperty("TriggerPhase", &GFootStepTrigger::GetTriggerPhase, &GFootStepTrigger::SetTriggerPhase)
        .addFunction("ToPtr", &GFootStepTrigger::ToPtr)
        .addFunction("IsValid", &GFootStepTrigger::IsValid)
        .endClass();
}
GParticleControlPointDriver_t::GParticleControlPointDriver_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GParticleControlPointDriver_t::GParticleControlPointDriver_t(void *ptr) {
    m_ptr = ptr;
}
int32_t GParticleControlPointDriver_t::GetControlPoint() const {
    return GetSchemaValue<int32_t>(m_ptr, "ParticleControlPointDriver_t", "m_iControlPoint");
}
void GParticleControlPointDriver_t::SetControlPoint(int32_t value) {
    SetSchemaValue(m_ptr, "ParticleControlPointDriver_t", "m_iControlPoint", true, value);
}
uint64_t GParticleControlPointDriver_t::GetAttachType() const {
    return GetSchemaValue<uint64_t>(m_ptr, "ParticleControlPointDriver_t", "m_iAttachType");
}
void GParticleControlPointDriver_t::SetAttachType(uint64_t value) {
    SetSchemaValue(m_ptr, "ParticleControlPointDriver_t", "m_iAttachType", true, value);
}
std::string GParticleControlPointDriver_t::GetAttachmentName() const {
    return GetSchemaValue<CUtlString>(m_ptr, "ParticleControlPointDriver_t", "m_attachmentName").Get();
}
void GParticleControlPointDriver_t::SetAttachmentName(std::string value) {
    SetSchemaValue(m_ptr, "ParticleControlPointDriver_t", "m_attachmentName", true, CUtlString(value.c_str()));
}
Vector GParticleControlPointDriver_t::GetOffset() const {
    return GetSchemaValue<Vector>(m_ptr, "ParticleControlPointDriver_t", "m_vecOffset");
}
void GParticleControlPointDriver_t::SetOffset(Vector value) {
    SetSchemaValue(m_ptr, "ParticleControlPointDriver_t", "m_vecOffset", true, value);
}
QAngle GParticleControlPointDriver_t::GetOffset1() const {
    return GetSchemaValue<QAngle>(m_ptr, "ParticleControlPointDriver_t", "m_angOffset");
}
void GParticleControlPointDriver_t::SetOffset1(QAngle value) {
    SetSchemaValue(m_ptr, "ParticleControlPointDriver_t", "m_angOffset", true, value);
}
std::string GParticleControlPointDriver_t::GetEntityName() const {
    return GetSchemaValue<CUtlString>(m_ptr, "ParticleControlPointDriver_t", "m_entityName").Get();
}
void GParticleControlPointDriver_t::SetEntityName(std::string value) {
    SetSchemaValue(m_ptr, "ParticleControlPointDriver_t", "m_entityName", true, CUtlString(value.c_str()));
}
void* GParticleControlPointDriver_t::GetPtr() {
    return m_ptr;
}
std::string GParticleControlPointDriver_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GParticleControlPointDriver_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassParticleControlPointDriver_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GParticleControlPointDriver_t>("ParticleControlPointDriver_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("ControlPoint", &GParticleControlPointDriver_t::GetControlPoint, &GParticleControlPointDriver_t::SetControlPoint)
        .addProperty("AttachType", &GParticleControlPointDriver_t::GetAttachType, &GParticleControlPointDriver_t::SetAttachType)
        .addProperty("AttachmentName", &GParticleControlPointDriver_t::GetAttachmentName, &GParticleControlPointDriver_t::SetAttachmentName)
        .addProperty("Offset", &GParticleControlPointDriver_t::GetOffset, &GParticleControlPointDriver_t::SetOffset)
        .addProperty("Offset1", &GParticleControlPointDriver_t::GetOffset1, &GParticleControlPointDriver_t::SetOffset1)
        .addProperty("EntityName", &GParticleControlPointDriver_t::GetEntityName, &GParticleControlPointDriver_t::SetEntityName)
        .addFunction("ToPtr", &GParticleControlPointDriver_t::ToPtr)
        .addFunction("IsValid", &GParticleControlPointDriver_t::IsValid)
        .endClass();
}
GFeSphereRigid_t::GFeSphereRigid_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GFeSphereRigid_t::GFeSphereRigid_t(void *ptr) {
    m_ptr = ptr;
}
float GFeSphereRigid_t::GetSphere() const {
    return GetSchemaValue<float>(m_ptr, "FeSphereRigid_t", "vSphere");
}
void GFeSphereRigid_t::SetSphere(float value) {
    SetSchemaValue(m_ptr, "FeSphereRigid_t", "vSphere", true, value);
}
uint16_t GFeSphereRigid_t::GetNode() const {
    return GetSchemaValue<uint16_t>(m_ptr, "FeSphereRigid_t", "nNode");
}
void GFeSphereRigid_t::SetNode(uint16_t value) {
    SetSchemaValue(m_ptr, "FeSphereRigid_t", "nNode", true, value);
}
uint16_t GFeSphereRigid_t::GetCollisionMask() const {
    return GetSchemaValue<uint16_t>(m_ptr, "FeSphereRigid_t", "nCollisionMask");
}
void GFeSphereRigid_t::SetCollisionMask(uint16_t value) {
    SetSchemaValue(m_ptr, "FeSphereRigid_t", "nCollisionMask", true, value);
}
uint16_t GFeSphereRigid_t::GetVertexMapIndex() const {
    return GetSchemaValue<uint16_t>(m_ptr, "FeSphereRigid_t", "nVertexMapIndex");
}
void GFeSphereRigid_t::SetVertexMapIndex(uint16_t value) {
    SetSchemaValue(m_ptr, "FeSphereRigid_t", "nVertexMapIndex", true, value);
}
uint16_t GFeSphereRigid_t::GetFlags() const {
    return GetSchemaValue<uint16_t>(m_ptr, "FeSphereRigid_t", "nFlags");
}
void GFeSphereRigid_t::SetFlags(uint16_t value) {
    SetSchemaValue(m_ptr, "FeSphereRigid_t", "nFlags", true, value);
}
void* GFeSphereRigid_t::GetPtr() {
    return m_ptr;
}
std::string GFeSphereRigid_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GFeSphereRigid_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassFeSphereRigid_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GFeSphereRigid_t>("FeSphereRigid_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Sphere", &GFeSphereRigid_t::GetSphere, &GFeSphereRigid_t::SetSphere)
        .addProperty("Node", &GFeSphereRigid_t::GetNode, &GFeSphereRigid_t::SetNode)
        .addProperty("CollisionMask", &GFeSphereRigid_t::GetCollisionMask, &GFeSphereRigid_t::SetCollisionMask)
        .addProperty("VertexMapIndex", &GFeSphereRigid_t::GetVertexMapIndex, &GFeSphereRigid_t::SetVertexMapIndex)
        .addProperty("Flags", &GFeSphereRigid_t::GetFlags, &GFeSphereRigid_t::SetFlags)
        .addFunction("ToPtr", &GFeSphereRigid_t::ToPtr)
        .addFunction("IsValid", &GFeSphereRigid_t::IsValid)
        .endClass();
}
GCMotionMetricEvaluator::GCMotionMetricEvaluator(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCMotionMetricEvaluator::GCMotionMetricEvaluator(void *ptr) {
    m_ptr = ptr;
}
std::vector<float32> GCMotionMetricEvaluator::GetMeans() const {
    CUtlVector<float32>* vec = GetSchemaValue<CUtlVector<float32>*>(m_ptr, "CMotionMetricEvaluator", "m_means"); std::vector<float32> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCMotionMetricEvaluator::SetMeans(std::vector<float32> value) {
    SetSchemaValueCUtlVector<float32>(m_ptr, "CMotionMetricEvaluator", "m_means", false, value);
}
std::vector<float32> GCMotionMetricEvaluator::GetStandardDeviations() const {
    CUtlVector<float32>* vec = GetSchemaValue<CUtlVector<float32>*>(m_ptr, "CMotionMetricEvaluator", "m_standardDeviations"); std::vector<float32> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCMotionMetricEvaluator::SetStandardDeviations(std::vector<float32> value) {
    SetSchemaValueCUtlVector<float32>(m_ptr, "CMotionMetricEvaluator", "m_standardDeviations", false, value);
}
float GCMotionMetricEvaluator::GetWeight() const {
    return GetSchemaValue<float>(m_ptr, "CMotionMetricEvaluator", "m_flWeight");
}
void GCMotionMetricEvaluator::SetWeight(float value) {
    SetSchemaValue(m_ptr, "CMotionMetricEvaluator", "m_flWeight", false, value);
}
int32_t GCMotionMetricEvaluator::GetDimensionStartIndex() const {
    return GetSchemaValue<int32_t>(m_ptr, "CMotionMetricEvaluator", "m_nDimensionStartIndex");
}
void GCMotionMetricEvaluator::SetDimensionStartIndex(int32_t value) {
    SetSchemaValue(m_ptr, "CMotionMetricEvaluator", "m_nDimensionStartIndex", false, value);
}
void* GCMotionMetricEvaluator::GetPtr() {
    return m_ptr;
}
std::string GCMotionMetricEvaluator::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCMotionMetricEvaluator::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCMotionMetricEvaluator(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCMotionMetricEvaluator>("CMotionMetricEvaluator")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Means", &GCMotionMetricEvaluator::GetMeans, &GCMotionMetricEvaluator::SetMeans)
        .addProperty("StandardDeviations", &GCMotionMetricEvaluator::GetStandardDeviations, &GCMotionMetricEvaluator::SetStandardDeviations)
        .addProperty("Weight", &GCMotionMetricEvaluator::GetWeight, &GCMotionMetricEvaluator::SetWeight)
        .addProperty("DimensionStartIndex", &GCMotionMetricEvaluator::GetDimensionStartIndex, &GCMotionMetricEvaluator::SetDimensionStartIndex)
        .addFunction("ToPtr", &GCMotionMetricEvaluator::ToPtr)
        .addFunction("IsValid", &GCMotionMetricEvaluator::IsValid)
        .endClass();
}
GCDrawCullingData::GCDrawCullingData(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCDrawCullingData::GCDrawCullingData(void *ptr) {
    m_ptr = ptr;
}
Vector GCDrawCullingData::GetConeApex() const {
    return GetSchemaValue<Vector>(m_ptr, "CDrawCullingData", "m_vConeApex");
}
void GCDrawCullingData::SetConeApex(Vector value) {
    SetSchemaValue(m_ptr, "CDrawCullingData", "m_vConeApex", false, value);
}
std::vector<int32_t> GCDrawCullingData::GetConeAxis() const {
    int32_t* outValue = (int32_t*)GetSchemaPtr(m_ptr, "CDrawCullingData", "m_ConeAxis"); std::vector<int32_t> ret; for(int i = 0; i < 3; i++) { ret.push_back(outValue[i]); } return ret;
}
void GCDrawCullingData::SetConeAxis(std::vector<int32_t> value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'ConeAxis' is not possible.\n");
}
int32_t GCDrawCullingData::GetConeCutoff() const {
    return GetSchemaValue<int32_t>(m_ptr, "CDrawCullingData", "m_ConeCutoff");
}
void GCDrawCullingData::SetConeCutoff(int32_t value) {
    SetSchemaValue(m_ptr, "CDrawCullingData", "m_ConeCutoff", false, value);
}
void* GCDrawCullingData::GetPtr() {
    return m_ptr;
}
std::string GCDrawCullingData::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCDrawCullingData::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCDrawCullingData(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCDrawCullingData>("CDrawCullingData")
        .addConstructor<void (*)(std::string)>()
        .addProperty("ConeApex", &GCDrawCullingData::GetConeApex, &GCDrawCullingData::SetConeApex)
        .addProperty("ConeAxis", &GCDrawCullingData::GetConeAxis, &GCDrawCullingData::SetConeAxis)
        .addProperty("ConeCutoff", &GCDrawCullingData::GetConeCutoff, &GCDrawCullingData::SetConeCutoff)
        .addFunction("ToPtr", &GCDrawCullingData::ToPtr)
        .addFunction("IsValid", &GCDrawCullingData::IsValid)
        .endClass();
}
GCAnimUserDifference::GCAnimUserDifference(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCAnimUserDifference::GCAnimUserDifference(void *ptr) {
    m_ptr = ptr;
}
int32_t GCAnimUserDifference::GetType() const {
    return GetSchemaValue<int32_t>(m_ptr, "CAnimUserDifference", "m_nType");
}
void GCAnimUserDifference::SetType(int32_t value) {
    SetSchemaValue(m_ptr, "CAnimUserDifference", "m_nType", false, value);
}
void* GCAnimUserDifference::GetPtr() {
    return m_ptr;
}
std::string GCAnimUserDifference::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCAnimUserDifference::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCAnimUserDifference(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCAnimUserDifference>("CAnimUserDifference")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Type", &GCAnimUserDifference::GetType, &GCAnimUserDifference::SetType)
        .addFunction("ToPtr", &GCAnimUserDifference::ToPtr)
        .addFunction("IsValid", &GCAnimUserDifference::IsValid)
        .endClass();
}
GCSeqMultiFetchFlag::GCSeqMultiFetchFlag(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCSeqMultiFetchFlag::GCSeqMultiFetchFlag(void *ptr) {
    m_ptr = ptr;
}
bool GCSeqMultiFetchFlag::GetRealtime() const {
    return GetSchemaValue<bool>(m_ptr, "CSeqMultiFetchFlag", "m_bRealtime");
}
void GCSeqMultiFetchFlag::SetRealtime(bool value) {
    SetSchemaValue(m_ptr, "CSeqMultiFetchFlag", "m_bRealtime", false, value);
}
bool GCSeqMultiFetchFlag::GetCylepose() const {
    return GetSchemaValue<bool>(m_ptr, "CSeqMultiFetchFlag", "m_bCylepose");
}
void GCSeqMultiFetchFlag::SetCylepose(bool value) {
    SetSchemaValue(m_ptr, "CSeqMultiFetchFlag", "m_bCylepose", false, value);
}
bool GCSeqMultiFetchFlag::Get0D() const {
    return GetSchemaValue<bool>(m_ptr, "CSeqMultiFetchFlag", "m_b0D");
}
void GCSeqMultiFetchFlag::Set0D(bool value) {
    SetSchemaValue(m_ptr, "CSeqMultiFetchFlag", "m_b0D", false, value);
}
bool GCSeqMultiFetchFlag::Get1D() const {
    return GetSchemaValue<bool>(m_ptr, "CSeqMultiFetchFlag", "m_b1D");
}
void GCSeqMultiFetchFlag::Set1D(bool value) {
    SetSchemaValue(m_ptr, "CSeqMultiFetchFlag", "m_b1D", false, value);
}
bool GCSeqMultiFetchFlag::Get2D() const {
    return GetSchemaValue<bool>(m_ptr, "CSeqMultiFetchFlag", "m_b2D");
}
void GCSeqMultiFetchFlag::Set2D(bool value) {
    SetSchemaValue(m_ptr, "CSeqMultiFetchFlag", "m_b2D", false, value);
}
bool GCSeqMultiFetchFlag::Get2D_TRI() const {
    return GetSchemaValue<bool>(m_ptr, "CSeqMultiFetchFlag", "m_b2D_TRI");
}
void GCSeqMultiFetchFlag::Set2D_TRI(bool value) {
    SetSchemaValue(m_ptr, "CSeqMultiFetchFlag", "m_b2D_TRI", false, value);
}
void* GCSeqMultiFetchFlag::GetPtr() {
    return m_ptr;
}
std::string GCSeqMultiFetchFlag::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCSeqMultiFetchFlag::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCSeqMultiFetchFlag(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCSeqMultiFetchFlag>("CSeqMultiFetchFlag")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Realtime", &GCSeqMultiFetchFlag::GetRealtime, &GCSeqMultiFetchFlag::SetRealtime)
        .addProperty("Cylepose", &GCSeqMultiFetchFlag::GetCylepose, &GCSeqMultiFetchFlag::SetCylepose)
        .addProperty("0D", &GCSeqMultiFetchFlag::Get0D, &GCSeqMultiFetchFlag::Set0D)
        .addProperty("1D", &GCSeqMultiFetchFlag::Get1D, &GCSeqMultiFetchFlag::Set1D)
        .addProperty("2D", &GCSeqMultiFetchFlag::Get2D, &GCSeqMultiFetchFlag::Set2D)
        .addProperty("2D_TRI", &GCSeqMultiFetchFlag::Get2D_TRI, &GCSeqMultiFetchFlag::Set2D_TRI)
        .addFunction("ToPtr", &GCSeqMultiFetchFlag::ToPtr)
        .addFunction("IsValid", &GCSeqMultiFetchFlag::IsValid)
        .endClass();
}
GCNmEvent::GCNmEvent(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCNmEvent::GCNmEvent(void *ptr) {
    m_ptr = ptr;
}
float GCNmEvent::GetStartTime() const {
    return GetSchemaValue<float>(m_ptr, "CNmEvent", "m_flStartTime");
}
void GCNmEvent::SetStartTime(float value) {
    SetSchemaValue(m_ptr, "CNmEvent", "m_flStartTime", false, value);
}
float GCNmEvent::GetDuration() const {
    return GetSchemaValue<float>(m_ptr, "CNmEvent", "m_flDuration");
}
void GCNmEvent::SetDuration(float value) {
    SetSchemaValue(m_ptr, "CNmEvent", "m_flDuration", false, value);
}
void* GCNmEvent::GetPtr() {
    return m_ptr;
}
std::string GCNmEvent::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCNmEvent::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCNmEvent(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCNmEvent>("CNmEvent")
        .addConstructor<void (*)(std::string)>()
        .addProperty("StartTime", &GCNmEvent::GetStartTime, &GCNmEvent::SetStartTime)
        .addProperty("Duration", &GCNmEvent::GetDuration, &GCNmEvent::SetDuration)
        .addFunction("ToPtr", &GCNmEvent::ToPtr)
        .addFunction("IsValid", &GCNmEvent::IsValid)
        .endClass();
}
GCAnimParamHandle::GCAnimParamHandle(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCAnimParamHandle::GCAnimParamHandle(void *ptr) {
    m_ptr = ptr;
}
uint64_t GCAnimParamHandle::GetType() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CAnimParamHandle", "m_type");
}
void GCAnimParamHandle::SetType(uint64_t value) {
    SetSchemaValue(m_ptr, "CAnimParamHandle", "m_type", false, value);
}
uint32_t GCAnimParamHandle::GetIndex() const {
    return GetSchemaValue<uint32_t>(m_ptr, "CAnimParamHandle", "m_index");
}
void GCAnimParamHandle::SetIndex(uint32_t value) {
    SetSchemaValue(m_ptr, "CAnimParamHandle", "m_index", false, value);
}
void* GCAnimParamHandle::GetPtr() {
    return m_ptr;
}
std::string GCAnimParamHandle::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCAnimParamHandle::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCAnimParamHandle(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCAnimParamHandle>("CAnimParamHandle")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Type", &GCAnimParamHandle::GetType, &GCAnimParamHandle::SetType)
        .addProperty("Index", &GCAnimParamHandle::GetIndex, &GCAnimParamHandle::SetIndex)
        .addFunction("ToPtr", &GCAnimParamHandle::ToPtr)
        .addFunction("IsValid", &GCAnimParamHandle::IsValid)
        .endClass();
}
GCFuseSymbolTable::GCFuseSymbolTable(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCFuseSymbolTable::GCFuseSymbolTable(void *ptr) {
    m_ptr = ptr;
}
std::vector<GConstantInfo_t> GCFuseSymbolTable::GetConstants() const {
    CUtlVector<GConstantInfo_t>* vec = GetSchemaValue<CUtlVector<GConstantInfo_t>*>(m_ptr, "CFuseSymbolTable", "m_constants"); std::vector<GConstantInfo_t> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCFuseSymbolTable::SetConstants(std::vector<GConstantInfo_t> value) {
    SetSchemaValueCUtlVector<GConstantInfo_t>(m_ptr, "CFuseSymbolTable", "m_constants", false, value);
}
std::vector<GVariableInfo_t> GCFuseSymbolTable::GetVariables() const {
    CUtlVector<GVariableInfo_t>* vec = GetSchemaValue<CUtlVector<GVariableInfo_t>*>(m_ptr, "CFuseSymbolTable", "m_variables"); std::vector<GVariableInfo_t> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCFuseSymbolTable::SetVariables(std::vector<GVariableInfo_t> value) {
    SetSchemaValueCUtlVector<GVariableInfo_t>(m_ptr, "CFuseSymbolTable", "m_variables", false, value);
}
std::vector<GFunctionInfo_t> GCFuseSymbolTable::GetFunctions() const {
    CUtlVector<GFunctionInfo_t>* vec = GetSchemaValue<CUtlVector<GFunctionInfo_t>*>(m_ptr, "CFuseSymbolTable", "m_functions"); std::vector<GFunctionInfo_t> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCFuseSymbolTable::SetFunctions(std::vector<GFunctionInfo_t> value) {
    SetSchemaValueCUtlVector<GFunctionInfo_t>(m_ptr, "CFuseSymbolTable", "m_functions", false, value);
}
void* GCFuseSymbolTable::GetPtr() {
    return m_ptr;
}
std::string GCFuseSymbolTable::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCFuseSymbolTable::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCFuseSymbolTable(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCFuseSymbolTable>("CFuseSymbolTable")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Constants", &GCFuseSymbolTable::GetConstants, &GCFuseSymbolTable::SetConstants)
        .addProperty("Variables", &GCFuseSymbolTable::GetVariables, &GCFuseSymbolTable::SetVariables)
        .addProperty("Functions", &GCFuseSymbolTable::GetFunctions, &GCFuseSymbolTable::SetFunctions)
        .addFunction("ToPtr", &GCFuseSymbolTable::ToPtr)
        .addFunction("IsValid", &GCFuseSymbolTable::IsValid)
        .endClass();
}
GGeneratedTextureHandle_t::GGeneratedTextureHandle_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GGeneratedTextureHandle_t::GGeneratedTextureHandle_t(void *ptr) {
    m_ptr = ptr;
}
std::string GGeneratedTextureHandle_t::GetStrBitmapName() const {
    return GetSchemaValue<CUtlString>(m_ptr, "GeneratedTextureHandle_t", "m_strBitmapName").Get();
}
void GGeneratedTextureHandle_t::SetStrBitmapName(std::string value) {
    SetSchemaValue(m_ptr, "GeneratedTextureHandle_t", "m_strBitmapName", true, CUtlString(value.c_str()));
}
void* GGeneratedTextureHandle_t::GetPtr() {
    return m_ptr;
}
std::string GGeneratedTextureHandle_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GGeneratedTextureHandle_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassGeneratedTextureHandle_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GGeneratedTextureHandle_t>("GeneratedTextureHandle_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("StrBitmapName", &GGeneratedTextureHandle_t::GetStrBitmapName, &GGeneratedTextureHandle_t::SetStrBitmapName)
        .addFunction("ToPtr", &GGeneratedTextureHandle_t::ToPtr)
        .addFunction("IsValid", &GGeneratedTextureHandle_t::IsValid)
        .endClass();
}
GSceneViewId_t::GSceneViewId_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GSceneViewId_t::GSceneViewId_t(void *ptr) {
    m_ptr = ptr;
}
uint64_t GSceneViewId_t::GetViewId() const {
    return GetSchemaValue<uint64_t>(m_ptr, "SceneViewId_t", "m_nViewId");
}
void GSceneViewId_t::SetViewId(uint64_t value) {
    SetSchemaValue(m_ptr, "SceneViewId_t", "m_nViewId", true, value);
}
uint64_t GSceneViewId_t::GetFrameCount() const {
    return GetSchemaValue<uint64_t>(m_ptr, "SceneViewId_t", "m_nFrameCount");
}
void GSceneViewId_t::SetFrameCount(uint64_t value) {
    SetSchemaValue(m_ptr, "SceneViewId_t", "m_nFrameCount", true, value);
}
void* GSceneViewId_t::GetPtr() {
    return m_ptr;
}
std::string GSceneViewId_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GSceneViewId_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassSceneViewId_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GSceneViewId_t>("SceneViewId_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("ViewId", &GSceneViewId_t::GetViewId, &GSceneViewId_t::SetViewId)
        .addProperty("FrameCount", &GSceneViewId_t::GetFrameCount, &GSceneViewId_t::SetFrameCount)
        .addFunction("ToPtr", &GSceneViewId_t::ToPtr)
        .addFunction("IsValid", &GSceneViewId_t::IsValid)
        .endClass();
}
GPhysFeModelDesc_t::GPhysFeModelDesc_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GPhysFeModelDesc_t::GPhysFeModelDesc_t(void *ptr) {
    m_ptr = ptr;
}
std::vector<uint32> GPhysFeModelDesc_t::GetCtrlHash() const {
    CUtlVector<uint32>* vec = GetSchemaValue<CUtlVector<uint32>*>(m_ptr, "PhysFeModelDesc_t", "m_CtrlHash"); std::vector<uint32> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GPhysFeModelDesc_t::SetCtrlHash(std::vector<uint32> value) {
    SetSchemaValueCUtlVector<uint32>(m_ptr, "PhysFeModelDesc_t", "m_CtrlHash", true, value);
}
std::vector<CUtlString> GPhysFeModelDesc_t::GetCtrlName() const {
    CUtlVector<CUtlString>* vec = GetSchemaValue<CUtlVector<CUtlString>*>(m_ptr, "PhysFeModelDesc_t", "m_CtrlName"); std::vector<CUtlString> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GPhysFeModelDesc_t::SetCtrlName(std::vector<CUtlString> value) {
    SetSchemaValueCUtlVector<CUtlString>(m_ptr, "PhysFeModelDesc_t", "m_CtrlName", true, value);
}
uint32_t GPhysFeModelDesc_t::GetStaticNodeFlags() const {
    return GetSchemaValue<uint32_t>(m_ptr, "PhysFeModelDesc_t", "m_nStaticNodeFlags");
}
void GPhysFeModelDesc_t::SetStaticNodeFlags(uint32_t value) {
    SetSchemaValue(m_ptr, "PhysFeModelDesc_t", "m_nStaticNodeFlags", true, value);
}
uint32_t GPhysFeModelDesc_t::GetDynamicNodeFlags() const {
    return GetSchemaValue<uint32_t>(m_ptr, "PhysFeModelDesc_t", "m_nDynamicNodeFlags");
}
void GPhysFeModelDesc_t::SetDynamicNodeFlags(uint32_t value) {
    SetSchemaValue(m_ptr, "PhysFeModelDesc_t", "m_nDynamicNodeFlags", true, value);
}
float GPhysFeModelDesc_t::GetLocalForce() const {
    return GetSchemaValue<float>(m_ptr, "PhysFeModelDesc_t", "m_flLocalForce");
}
void GPhysFeModelDesc_t::SetLocalForce(float value) {
    SetSchemaValue(m_ptr, "PhysFeModelDesc_t", "m_flLocalForce", true, value);
}
float GPhysFeModelDesc_t::GetLocalRotation() const {
    return GetSchemaValue<float>(m_ptr, "PhysFeModelDesc_t", "m_flLocalRotation");
}
void GPhysFeModelDesc_t::SetLocalRotation(float value) {
    SetSchemaValue(m_ptr, "PhysFeModelDesc_t", "m_flLocalRotation", true, value);
}
uint16_t GPhysFeModelDesc_t::GetNodeCount() const {
    return GetSchemaValue<uint16_t>(m_ptr, "PhysFeModelDesc_t", "m_nNodeCount");
}
void GPhysFeModelDesc_t::SetNodeCount(uint16_t value) {
    SetSchemaValue(m_ptr, "PhysFeModelDesc_t", "m_nNodeCount", true, value);
}
uint16_t GPhysFeModelDesc_t::GetStaticNodes() const {
    return GetSchemaValue<uint16_t>(m_ptr, "PhysFeModelDesc_t", "m_nStaticNodes");
}
void GPhysFeModelDesc_t::SetStaticNodes(uint16_t value) {
    SetSchemaValue(m_ptr, "PhysFeModelDesc_t", "m_nStaticNodes", true, value);
}
uint16_t GPhysFeModelDesc_t::GetRotLockStaticNodes() const {
    return GetSchemaValue<uint16_t>(m_ptr, "PhysFeModelDesc_t", "m_nRotLockStaticNodes");
}
void GPhysFeModelDesc_t::SetRotLockStaticNodes(uint16_t value) {
    SetSchemaValue(m_ptr, "PhysFeModelDesc_t", "m_nRotLockStaticNodes", true, value);
}
uint16_t GPhysFeModelDesc_t::GetFirstPositionDrivenNode() const {
    return GetSchemaValue<uint16_t>(m_ptr, "PhysFeModelDesc_t", "m_nFirstPositionDrivenNode");
}
void GPhysFeModelDesc_t::SetFirstPositionDrivenNode(uint16_t value) {
    SetSchemaValue(m_ptr, "PhysFeModelDesc_t", "m_nFirstPositionDrivenNode", true, value);
}
uint16_t GPhysFeModelDesc_t::GetSimdTriCount1() const {
    return GetSchemaValue<uint16_t>(m_ptr, "PhysFeModelDesc_t", "m_nSimdTriCount1");
}
void GPhysFeModelDesc_t::SetSimdTriCount1(uint16_t value) {
    SetSchemaValue(m_ptr, "PhysFeModelDesc_t", "m_nSimdTriCount1", true, value);
}
uint16_t GPhysFeModelDesc_t::GetSimdTriCount2() const {
    return GetSchemaValue<uint16_t>(m_ptr, "PhysFeModelDesc_t", "m_nSimdTriCount2");
}
void GPhysFeModelDesc_t::SetSimdTriCount2(uint16_t value) {
    SetSchemaValue(m_ptr, "PhysFeModelDesc_t", "m_nSimdTriCount2", true, value);
}
uint16_t GPhysFeModelDesc_t::GetSimdQuadCount1() const {
    return GetSchemaValue<uint16_t>(m_ptr, "PhysFeModelDesc_t", "m_nSimdQuadCount1");
}
void GPhysFeModelDesc_t::SetSimdQuadCount1(uint16_t value) {
    SetSchemaValue(m_ptr, "PhysFeModelDesc_t", "m_nSimdQuadCount1", true, value);
}
uint16_t GPhysFeModelDesc_t::GetSimdQuadCount2() const {
    return GetSchemaValue<uint16_t>(m_ptr, "PhysFeModelDesc_t", "m_nSimdQuadCount2");
}
void GPhysFeModelDesc_t::SetSimdQuadCount2(uint16_t value) {
    SetSchemaValue(m_ptr, "PhysFeModelDesc_t", "m_nSimdQuadCount2", true, value);
}
uint16_t GPhysFeModelDesc_t::GetQuadCount1() const {
    return GetSchemaValue<uint16_t>(m_ptr, "PhysFeModelDesc_t", "m_nQuadCount1");
}
void GPhysFeModelDesc_t::SetQuadCount1(uint16_t value) {
    SetSchemaValue(m_ptr, "PhysFeModelDesc_t", "m_nQuadCount1", true, value);
}
uint16_t GPhysFeModelDesc_t::GetQuadCount2() const {
    return GetSchemaValue<uint16_t>(m_ptr, "PhysFeModelDesc_t", "m_nQuadCount2");
}
void GPhysFeModelDesc_t::SetQuadCount2(uint16_t value) {
    SetSchemaValue(m_ptr, "PhysFeModelDesc_t", "m_nQuadCount2", true, value);
}
uint16_t GPhysFeModelDesc_t::GetTreeDepth() const {
    return GetSchemaValue<uint16_t>(m_ptr, "PhysFeModelDesc_t", "m_nTreeDepth");
}
void GPhysFeModelDesc_t::SetTreeDepth(uint16_t value) {
    SetSchemaValue(m_ptr, "PhysFeModelDesc_t", "m_nTreeDepth", true, value);
}
uint16_t GPhysFeModelDesc_t::GetNodeBaseJiggleboneDependsCount() const {
    return GetSchemaValue<uint16_t>(m_ptr, "PhysFeModelDesc_t", "m_nNodeBaseJiggleboneDependsCount");
}
void GPhysFeModelDesc_t::SetNodeBaseJiggleboneDependsCount(uint16_t value) {
    SetSchemaValue(m_ptr, "PhysFeModelDesc_t", "m_nNodeBaseJiggleboneDependsCount", true, value);
}
uint16_t GPhysFeModelDesc_t::GetRopeCount() const {
    return GetSchemaValue<uint16_t>(m_ptr, "PhysFeModelDesc_t", "m_nRopeCount");
}
void GPhysFeModelDesc_t::SetRopeCount(uint16_t value) {
    SetSchemaValue(m_ptr, "PhysFeModelDesc_t", "m_nRopeCount", true, value);
}
std::vector<uint16> GPhysFeModelDesc_t::GetRopes() const {
    CUtlVector<uint16>* vec = GetSchemaValue<CUtlVector<uint16>*>(m_ptr, "PhysFeModelDesc_t", "m_Ropes"); std::vector<uint16> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GPhysFeModelDesc_t::SetRopes(std::vector<uint16> value) {
    SetSchemaValueCUtlVector<uint16>(m_ptr, "PhysFeModelDesc_t", "m_Ropes", true, value);
}
std::vector<GFeNodeBase_t> GPhysFeModelDesc_t::GetNodeBases() const {
    CUtlVector<GFeNodeBase_t>* vec = GetSchemaValue<CUtlVector<GFeNodeBase_t>*>(m_ptr, "PhysFeModelDesc_t", "m_NodeBases"); std::vector<GFeNodeBase_t> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GPhysFeModelDesc_t::SetNodeBases(std::vector<GFeNodeBase_t> value) {
    SetSchemaValueCUtlVector<GFeNodeBase_t>(m_ptr, "PhysFeModelDesc_t", "m_NodeBases", true, value);
}
std::vector<GFeSimdNodeBase_t> GPhysFeModelDesc_t::GetSimdNodeBases() const {
    CUtlVector<GFeSimdNodeBase_t>* vec = GetSchemaValue<CUtlVector<GFeSimdNodeBase_t>*>(m_ptr, "PhysFeModelDesc_t", "m_SimdNodeBases"); std::vector<GFeSimdNodeBase_t> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GPhysFeModelDesc_t::SetSimdNodeBases(std::vector<GFeSimdNodeBase_t> value) {
    SetSchemaValueCUtlVector<GFeSimdNodeBase_t>(m_ptr, "PhysFeModelDesc_t", "m_SimdNodeBases", true, value);
}
std::vector<GFeQuad_t> GPhysFeModelDesc_t::GetQuads() const {
    CUtlVector<GFeQuad_t>* vec = GetSchemaValue<CUtlVector<GFeQuad_t>*>(m_ptr, "PhysFeModelDesc_t", "m_Quads"); std::vector<GFeQuad_t> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GPhysFeModelDesc_t::SetQuads(std::vector<GFeQuad_t> value) {
    SetSchemaValueCUtlVector<GFeQuad_t>(m_ptr, "PhysFeModelDesc_t", "m_Quads", true, value);
}
std::vector<GFeSimdQuad_t> GPhysFeModelDesc_t::GetSimdQuads() const {
    CUtlVector<GFeSimdQuad_t>* vec = GetSchemaValue<CUtlVector<GFeSimdQuad_t>*>(m_ptr, "PhysFeModelDesc_t", "m_SimdQuads"); std::vector<GFeSimdQuad_t> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GPhysFeModelDesc_t::SetSimdQuads(std::vector<GFeSimdQuad_t> value) {
    SetSchemaValueCUtlVector<GFeSimdQuad_t>(m_ptr, "PhysFeModelDesc_t", "m_SimdQuads", true, value);
}
std::vector<GFeSimdTri_t> GPhysFeModelDesc_t::GetSimdTris() const {
    CUtlVector<GFeSimdTri_t>* vec = GetSchemaValue<CUtlVector<GFeSimdTri_t>*>(m_ptr, "PhysFeModelDesc_t", "m_SimdTris"); std::vector<GFeSimdTri_t> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GPhysFeModelDesc_t::SetSimdTris(std::vector<GFeSimdTri_t> value) {
    SetSchemaValueCUtlVector<GFeSimdTri_t>(m_ptr, "PhysFeModelDesc_t", "m_SimdTris", true, value);
}
std::vector<GFeSimdRodConstraint_t> GPhysFeModelDesc_t::GetSimdRods() const {
    CUtlVector<GFeSimdRodConstraint_t>* vec = GetSchemaValue<CUtlVector<GFeSimdRodConstraint_t>*>(m_ptr, "PhysFeModelDesc_t", "m_SimdRods"); std::vector<GFeSimdRodConstraint_t> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GPhysFeModelDesc_t::SetSimdRods(std::vector<GFeSimdRodConstraint_t> value) {
    SetSchemaValueCUtlVector<GFeSimdRodConstraint_t>(m_ptr, "PhysFeModelDesc_t", "m_SimdRods", true, value);
}
std::vector<GFeSimdRodConstraintAnim_t> GPhysFeModelDesc_t::GetSimdRodsAnim() const {
    CUtlVector<GFeSimdRodConstraintAnim_t>* vec = GetSchemaValue<CUtlVector<GFeSimdRodConstraintAnim_t>*>(m_ptr, "PhysFeModelDesc_t", "m_SimdRodsAnim"); std::vector<GFeSimdRodConstraintAnim_t> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GPhysFeModelDesc_t::SetSimdRodsAnim(std::vector<GFeSimdRodConstraintAnim_t> value) {
    SetSchemaValueCUtlVector<GFeSimdRodConstraintAnim_t>(m_ptr, "PhysFeModelDesc_t", "m_SimdRodsAnim", true, value);
}
std::vector<GFeRodConstraint_t> GPhysFeModelDesc_t::GetRods() const {
    CUtlVector<GFeRodConstraint_t>* vec = GetSchemaValue<CUtlVector<GFeRodConstraint_t>*>(m_ptr, "PhysFeModelDesc_t", "m_Rods"); std::vector<GFeRodConstraint_t> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GPhysFeModelDesc_t::SetRods(std::vector<GFeRodConstraint_t> value) {
    SetSchemaValueCUtlVector<GFeRodConstraint_t>(m_ptr, "PhysFeModelDesc_t", "m_Rods", true, value);
}
std::vector<GFeTwistConstraint_t> GPhysFeModelDesc_t::GetTwists() const {
    CUtlVector<GFeTwistConstraint_t>* vec = GetSchemaValue<CUtlVector<GFeTwistConstraint_t>*>(m_ptr, "PhysFeModelDesc_t", "m_Twists"); std::vector<GFeTwistConstraint_t> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GPhysFeModelDesc_t::SetTwists(std::vector<GFeTwistConstraint_t> value) {
    SetSchemaValueCUtlVector<GFeTwistConstraint_t>(m_ptr, "PhysFeModelDesc_t", "m_Twists", true, value);
}
std::vector<GFeAxialEdgeBend_t> GPhysFeModelDesc_t::GetAxialEdges() const {
    CUtlVector<GFeAxialEdgeBend_t>* vec = GetSchemaValue<CUtlVector<GFeAxialEdgeBend_t>*>(m_ptr, "PhysFeModelDesc_t", "m_AxialEdges"); std::vector<GFeAxialEdgeBend_t> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GPhysFeModelDesc_t::SetAxialEdges(std::vector<GFeAxialEdgeBend_t> value) {
    SetSchemaValueCUtlVector<GFeAxialEdgeBend_t>(m_ptr, "PhysFeModelDesc_t", "m_AxialEdges", true, value);
}
std::vector<float32> GPhysFeModelDesc_t::GetNodeInvMasses() const {
    CUtlVector<float32>* vec = GetSchemaValue<CUtlVector<float32>*>(m_ptr, "PhysFeModelDesc_t", "m_NodeInvMasses"); std::vector<float32> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GPhysFeModelDesc_t::SetNodeInvMasses(std::vector<float32> value) {
    SetSchemaValueCUtlVector<float32>(m_ptr, "PhysFeModelDesc_t", "m_NodeInvMasses", true, value);
}
std::vector<GFeCtrlOffset_t> GPhysFeModelDesc_t::GetCtrlOffsets() const {
    CUtlVector<GFeCtrlOffset_t>* vec = GetSchemaValue<CUtlVector<GFeCtrlOffset_t>*>(m_ptr, "PhysFeModelDesc_t", "m_CtrlOffsets"); std::vector<GFeCtrlOffset_t> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GPhysFeModelDesc_t::SetCtrlOffsets(std::vector<GFeCtrlOffset_t> value) {
    SetSchemaValueCUtlVector<GFeCtrlOffset_t>(m_ptr, "PhysFeModelDesc_t", "m_CtrlOffsets", true, value);
}
std::vector<GFeCtrlOsOffset_t> GPhysFeModelDesc_t::GetCtrlOsOffsets() const {
    CUtlVector<GFeCtrlOsOffset_t>* vec = GetSchemaValue<CUtlVector<GFeCtrlOsOffset_t>*>(m_ptr, "PhysFeModelDesc_t", "m_CtrlOsOffsets"); std::vector<GFeCtrlOsOffset_t> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GPhysFeModelDesc_t::SetCtrlOsOffsets(std::vector<GFeCtrlOsOffset_t> value) {
    SetSchemaValueCUtlVector<GFeCtrlOsOffset_t>(m_ptr, "PhysFeModelDesc_t", "m_CtrlOsOffsets", true, value);
}
std::vector<GFeFollowNode_t> GPhysFeModelDesc_t::GetFollowNodes() const {
    CUtlVector<GFeFollowNode_t>* vec = GetSchemaValue<CUtlVector<GFeFollowNode_t>*>(m_ptr, "PhysFeModelDesc_t", "m_FollowNodes"); std::vector<GFeFollowNode_t> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GPhysFeModelDesc_t::SetFollowNodes(std::vector<GFeFollowNode_t> value) {
    SetSchemaValueCUtlVector<GFeFollowNode_t>(m_ptr, "PhysFeModelDesc_t", "m_FollowNodes", true, value);
}
std::vector<GFeCollisionPlane_t> GPhysFeModelDesc_t::GetCollisionPlanes() const {
    CUtlVector<GFeCollisionPlane_t>* vec = GetSchemaValue<CUtlVector<GFeCollisionPlane_t>*>(m_ptr, "PhysFeModelDesc_t", "m_CollisionPlanes"); std::vector<GFeCollisionPlane_t> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GPhysFeModelDesc_t::SetCollisionPlanes(std::vector<GFeCollisionPlane_t> value) {
    SetSchemaValueCUtlVector<GFeCollisionPlane_t>(m_ptr, "PhysFeModelDesc_t", "m_CollisionPlanes", true, value);
}
std::vector<GFeNodeIntegrator_t> GPhysFeModelDesc_t::GetNodeIntegrator() const {
    CUtlVector<GFeNodeIntegrator_t>* vec = GetSchemaValue<CUtlVector<GFeNodeIntegrator_t>*>(m_ptr, "PhysFeModelDesc_t", "m_NodeIntegrator"); std::vector<GFeNodeIntegrator_t> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GPhysFeModelDesc_t::SetNodeIntegrator(std::vector<GFeNodeIntegrator_t> value) {
    SetSchemaValueCUtlVector<GFeNodeIntegrator_t>(m_ptr, "PhysFeModelDesc_t", "m_NodeIntegrator", true, value);
}
std::vector<GFeSpringIntegrator_t> GPhysFeModelDesc_t::GetSpringIntegrator() const {
    CUtlVector<GFeSpringIntegrator_t>* vec = GetSchemaValue<CUtlVector<GFeSpringIntegrator_t>*>(m_ptr, "PhysFeModelDesc_t", "m_SpringIntegrator"); std::vector<GFeSpringIntegrator_t> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GPhysFeModelDesc_t::SetSpringIntegrator(std::vector<GFeSpringIntegrator_t> value) {
    SetSchemaValueCUtlVector<GFeSpringIntegrator_t>(m_ptr, "PhysFeModelDesc_t", "m_SpringIntegrator", true, value);
}
std::vector<GFeSimdSpringIntegrator_t> GPhysFeModelDesc_t::GetSimdSpringIntegrator() const {
    CUtlVector<GFeSimdSpringIntegrator_t>* vec = GetSchemaValue<CUtlVector<GFeSimdSpringIntegrator_t>*>(m_ptr, "PhysFeModelDesc_t", "m_SimdSpringIntegrator"); std::vector<GFeSimdSpringIntegrator_t> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GPhysFeModelDesc_t::SetSimdSpringIntegrator(std::vector<GFeSimdSpringIntegrator_t> value) {
    SetSchemaValueCUtlVector<GFeSimdSpringIntegrator_t>(m_ptr, "PhysFeModelDesc_t", "m_SimdSpringIntegrator", true, value);
}
std::vector<GFeWorldCollisionParams_t> GPhysFeModelDesc_t::GetWorldCollisionParams() const {
    CUtlVector<GFeWorldCollisionParams_t>* vec = GetSchemaValue<CUtlVector<GFeWorldCollisionParams_t>*>(m_ptr, "PhysFeModelDesc_t", "m_WorldCollisionParams"); std::vector<GFeWorldCollisionParams_t> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GPhysFeModelDesc_t::SetWorldCollisionParams(std::vector<GFeWorldCollisionParams_t> value) {
    SetSchemaValueCUtlVector<GFeWorldCollisionParams_t>(m_ptr, "PhysFeModelDesc_t", "m_WorldCollisionParams", true, value);
}
std::vector<float32> GPhysFeModelDesc_t::GetLegacyStretchForce() const {
    CUtlVector<float32>* vec = GetSchemaValue<CUtlVector<float32>*>(m_ptr, "PhysFeModelDesc_t", "m_LegacyStretchForce"); std::vector<float32> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GPhysFeModelDesc_t::SetLegacyStretchForce(std::vector<float32> value) {
    SetSchemaValueCUtlVector<float32>(m_ptr, "PhysFeModelDesc_t", "m_LegacyStretchForce", true, value);
}
std::vector<float32> GPhysFeModelDesc_t::GetNodeCollisionRadii() const {
    CUtlVector<float32>* vec = GetSchemaValue<CUtlVector<float32>*>(m_ptr, "PhysFeModelDesc_t", "m_NodeCollisionRadii"); std::vector<float32> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GPhysFeModelDesc_t::SetNodeCollisionRadii(std::vector<float32> value) {
    SetSchemaValueCUtlVector<float32>(m_ptr, "PhysFeModelDesc_t", "m_NodeCollisionRadii", true, value);
}
std::vector<float32> GPhysFeModelDesc_t::GetDynNodeFriction() const {
    CUtlVector<float32>* vec = GetSchemaValue<CUtlVector<float32>*>(m_ptr, "PhysFeModelDesc_t", "m_DynNodeFriction"); std::vector<float32> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GPhysFeModelDesc_t::SetDynNodeFriction(std::vector<float32> value) {
    SetSchemaValueCUtlVector<float32>(m_ptr, "PhysFeModelDesc_t", "m_DynNodeFriction", true, value);
}
std::vector<float32> GPhysFeModelDesc_t::GetLocalRotation1() const {
    CUtlVector<float32>* vec = GetSchemaValue<CUtlVector<float32>*>(m_ptr, "PhysFeModelDesc_t", "m_LocalRotation"); std::vector<float32> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GPhysFeModelDesc_t::SetLocalRotation1(std::vector<float32> value) {
    SetSchemaValueCUtlVector<float32>(m_ptr, "PhysFeModelDesc_t", "m_LocalRotation", true, value);
}
std::vector<float32> GPhysFeModelDesc_t::GetLocalForce1() const {
    CUtlVector<float32>* vec = GetSchemaValue<CUtlVector<float32>*>(m_ptr, "PhysFeModelDesc_t", "m_LocalForce"); std::vector<float32> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GPhysFeModelDesc_t::SetLocalForce1(std::vector<float32> value) {
    SetSchemaValueCUtlVector<float32>(m_ptr, "PhysFeModelDesc_t", "m_LocalForce", true, value);
}
std::vector<GFeTaperedCapsuleStretch_t> GPhysFeModelDesc_t::GetTaperedCapsuleStretches() const {
    CUtlVector<GFeTaperedCapsuleStretch_t>* vec = GetSchemaValue<CUtlVector<GFeTaperedCapsuleStretch_t>*>(m_ptr, "PhysFeModelDesc_t", "m_TaperedCapsuleStretches"); std::vector<GFeTaperedCapsuleStretch_t> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GPhysFeModelDesc_t::SetTaperedCapsuleStretches(std::vector<GFeTaperedCapsuleStretch_t> value) {
    SetSchemaValueCUtlVector<GFeTaperedCapsuleStretch_t>(m_ptr, "PhysFeModelDesc_t", "m_TaperedCapsuleStretches", true, value);
}
std::vector<GFeTaperedCapsuleRigid_t> GPhysFeModelDesc_t::GetTaperedCapsuleRigids() const {
    CUtlVector<GFeTaperedCapsuleRigid_t>* vec = GetSchemaValue<CUtlVector<GFeTaperedCapsuleRigid_t>*>(m_ptr, "PhysFeModelDesc_t", "m_TaperedCapsuleRigids"); std::vector<GFeTaperedCapsuleRigid_t> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GPhysFeModelDesc_t::SetTaperedCapsuleRigids(std::vector<GFeTaperedCapsuleRigid_t> value) {
    SetSchemaValueCUtlVector<GFeTaperedCapsuleRigid_t>(m_ptr, "PhysFeModelDesc_t", "m_TaperedCapsuleRigids", true, value);
}
std::vector<GFeSphereRigid_t> GPhysFeModelDesc_t::GetSphereRigids() const {
    CUtlVector<GFeSphereRigid_t>* vec = GetSchemaValue<CUtlVector<GFeSphereRigid_t>*>(m_ptr, "PhysFeModelDesc_t", "m_SphereRigids"); std::vector<GFeSphereRigid_t> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GPhysFeModelDesc_t::SetSphereRigids(std::vector<GFeSphereRigid_t> value) {
    SetSchemaValueCUtlVector<GFeSphereRigid_t>(m_ptr, "PhysFeModelDesc_t", "m_SphereRigids", true, value);
}
std::vector<uint16> GPhysFeModelDesc_t::GetWorldCollisionNodes() const {
    CUtlVector<uint16>* vec = GetSchemaValue<CUtlVector<uint16>*>(m_ptr, "PhysFeModelDesc_t", "m_WorldCollisionNodes"); std::vector<uint16> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GPhysFeModelDesc_t::SetWorldCollisionNodes(std::vector<uint16> value) {
    SetSchemaValueCUtlVector<uint16>(m_ptr, "PhysFeModelDesc_t", "m_WorldCollisionNodes", true, value);
}
std::vector<uint16> GPhysFeModelDesc_t::GetTreeParents() const {
    CUtlVector<uint16>* vec = GetSchemaValue<CUtlVector<uint16>*>(m_ptr, "PhysFeModelDesc_t", "m_TreeParents"); std::vector<uint16> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GPhysFeModelDesc_t::SetTreeParents(std::vector<uint16> value) {
    SetSchemaValueCUtlVector<uint16>(m_ptr, "PhysFeModelDesc_t", "m_TreeParents", true, value);
}
std::vector<uint16> GPhysFeModelDesc_t::GetTreeCollisionMasks() const {
    CUtlVector<uint16>* vec = GetSchemaValue<CUtlVector<uint16>*>(m_ptr, "PhysFeModelDesc_t", "m_TreeCollisionMasks"); std::vector<uint16> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GPhysFeModelDesc_t::SetTreeCollisionMasks(std::vector<uint16> value) {
    SetSchemaValueCUtlVector<uint16>(m_ptr, "PhysFeModelDesc_t", "m_TreeCollisionMasks", true, value);
}
std::vector<GFeTreeChildren_t> GPhysFeModelDesc_t::GetTreeChildren() const {
    CUtlVector<GFeTreeChildren_t>* vec = GetSchemaValue<CUtlVector<GFeTreeChildren_t>*>(m_ptr, "PhysFeModelDesc_t", "m_TreeChildren"); std::vector<GFeTreeChildren_t> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GPhysFeModelDesc_t::SetTreeChildren(std::vector<GFeTreeChildren_t> value) {
    SetSchemaValueCUtlVector<GFeTreeChildren_t>(m_ptr, "PhysFeModelDesc_t", "m_TreeChildren", true, value);
}
std::vector<uint16> GPhysFeModelDesc_t::GetFreeNodes() const {
    CUtlVector<uint16>* vec = GetSchemaValue<CUtlVector<uint16>*>(m_ptr, "PhysFeModelDesc_t", "m_FreeNodes"); std::vector<uint16> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GPhysFeModelDesc_t::SetFreeNodes(std::vector<uint16> value) {
    SetSchemaValueCUtlVector<uint16>(m_ptr, "PhysFeModelDesc_t", "m_FreeNodes", true, value);
}
std::vector<GFeFitMatrix_t> GPhysFeModelDesc_t::GetFitMatrices() const {
    CUtlVector<GFeFitMatrix_t>* vec = GetSchemaValue<CUtlVector<GFeFitMatrix_t>*>(m_ptr, "PhysFeModelDesc_t", "m_FitMatrices"); std::vector<GFeFitMatrix_t> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GPhysFeModelDesc_t::SetFitMatrices(std::vector<GFeFitMatrix_t> value) {
    SetSchemaValueCUtlVector<GFeFitMatrix_t>(m_ptr, "PhysFeModelDesc_t", "m_FitMatrices", true, value);
}
std::vector<GFeFitWeight_t> GPhysFeModelDesc_t::GetFitWeights() const {
    CUtlVector<GFeFitWeight_t>* vec = GetSchemaValue<CUtlVector<GFeFitWeight_t>*>(m_ptr, "PhysFeModelDesc_t", "m_FitWeights"); std::vector<GFeFitWeight_t> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GPhysFeModelDesc_t::SetFitWeights(std::vector<GFeFitWeight_t> value) {
    SetSchemaValueCUtlVector<GFeFitWeight_t>(m_ptr, "PhysFeModelDesc_t", "m_FitWeights", true, value);
}
std::vector<GFeNodeReverseOffset_t> GPhysFeModelDesc_t::GetReverseOffsets() const {
    CUtlVector<GFeNodeReverseOffset_t>* vec = GetSchemaValue<CUtlVector<GFeNodeReverseOffset_t>*>(m_ptr, "PhysFeModelDesc_t", "m_ReverseOffsets"); std::vector<GFeNodeReverseOffset_t> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GPhysFeModelDesc_t::SetReverseOffsets(std::vector<GFeNodeReverseOffset_t> value) {
    SetSchemaValueCUtlVector<GFeNodeReverseOffset_t>(m_ptr, "PhysFeModelDesc_t", "m_ReverseOffsets", true, value);
}
std::vector<GFeAnimStrayRadius_t> GPhysFeModelDesc_t::GetAnimStrayRadii() const {
    CUtlVector<GFeAnimStrayRadius_t>* vec = GetSchemaValue<CUtlVector<GFeAnimStrayRadius_t>*>(m_ptr, "PhysFeModelDesc_t", "m_AnimStrayRadii"); std::vector<GFeAnimStrayRadius_t> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GPhysFeModelDesc_t::SetAnimStrayRadii(std::vector<GFeAnimStrayRadius_t> value) {
    SetSchemaValueCUtlVector<GFeAnimStrayRadius_t>(m_ptr, "PhysFeModelDesc_t", "m_AnimStrayRadii", true, value);
}
std::vector<GFeSimdAnimStrayRadius_t> GPhysFeModelDesc_t::GetSimdAnimStrayRadii() const {
    CUtlVector<GFeSimdAnimStrayRadius_t>* vec = GetSchemaValue<CUtlVector<GFeSimdAnimStrayRadius_t>*>(m_ptr, "PhysFeModelDesc_t", "m_SimdAnimStrayRadii"); std::vector<GFeSimdAnimStrayRadius_t> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GPhysFeModelDesc_t::SetSimdAnimStrayRadii(std::vector<GFeSimdAnimStrayRadius_t> value) {
    SetSchemaValueCUtlVector<GFeSimdAnimStrayRadius_t>(m_ptr, "PhysFeModelDesc_t", "m_SimdAnimStrayRadii", true, value);
}
std::vector<GFeKelagerBend2_t> GPhysFeModelDesc_t::GetKelagerBends() const {
    CUtlVector<GFeKelagerBend2_t>* vec = GetSchemaValue<CUtlVector<GFeKelagerBend2_t>*>(m_ptr, "PhysFeModelDesc_t", "m_KelagerBends"); std::vector<GFeKelagerBend2_t> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GPhysFeModelDesc_t::SetKelagerBends(std::vector<GFeKelagerBend2_t> value) {
    SetSchemaValueCUtlVector<GFeKelagerBend2_t>(m_ptr, "PhysFeModelDesc_t", "m_KelagerBends", true, value);
}
std::vector<GFeCtrlSoftOffset_t> GPhysFeModelDesc_t::GetCtrlSoftOffsets() const {
    CUtlVector<GFeCtrlSoftOffset_t>* vec = GetSchemaValue<CUtlVector<GFeCtrlSoftOffset_t>*>(m_ptr, "PhysFeModelDesc_t", "m_CtrlSoftOffsets"); std::vector<GFeCtrlSoftOffset_t> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GPhysFeModelDesc_t::SetCtrlSoftOffsets(std::vector<GFeCtrlSoftOffset_t> value) {
    SetSchemaValueCUtlVector<GFeCtrlSoftOffset_t>(m_ptr, "PhysFeModelDesc_t", "m_CtrlSoftOffsets", true, value);
}
std::vector<GCFeIndexedJiggleBone> GPhysFeModelDesc_t::GetJiggleBones() const {
    CUtlVector<GCFeIndexedJiggleBone>* vec = GetSchemaValue<CUtlVector<GCFeIndexedJiggleBone>*>(m_ptr, "PhysFeModelDesc_t", "m_JiggleBones"); std::vector<GCFeIndexedJiggleBone> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GPhysFeModelDesc_t::SetJiggleBones(std::vector<GCFeIndexedJiggleBone> value) {
    SetSchemaValueCUtlVector<GCFeIndexedJiggleBone>(m_ptr, "PhysFeModelDesc_t", "m_JiggleBones", true, value);
}
std::vector<uint16> GPhysFeModelDesc_t::GetSourceElems() const {
    CUtlVector<uint16>* vec = GetSchemaValue<CUtlVector<uint16>*>(m_ptr, "PhysFeModelDesc_t", "m_SourceElems"); std::vector<uint16> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GPhysFeModelDesc_t::SetSourceElems(std::vector<uint16> value) {
    SetSchemaValueCUtlVector<uint16>(m_ptr, "PhysFeModelDesc_t", "m_SourceElems", true, value);
}
std::vector<uint32> GPhysFeModelDesc_t::GetGoalDampedSpringIntegrators() const {
    CUtlVector<uint32>* vec = GetSchemaValue<CUtlVector<uint32>*>(m_ptr, "PhysFeModelDesc_t", "m_GoalDampedSpringIntegrators"); std::vector<uint32> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GPhysFeModelDesc_t::SetGoalDampedSpringIntegrators(std::vector<uint32> value) {
    SetSchemaValueCUtlVector<uint32>(m_ptr, "PhysFeModelDesc_t", "m_GoalDampedSpringIntegrators", true, value);
}
std::vector<GFeTri_t> GPhysFeModelDesc_t::GetTris() const {
    CUtlVector<GFeTri_t>* vec = GetSchemaValue<CUtlVector<GFeTri_t>*>(m_ptr, "PhysFeModelDesc_t", "m_Tris"); std::vector<GFeTri_t> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GPhysFeModelDesc_t::SetTris(std::vector<GFeTri_t> value) {
    SetSchemaValueCUtlVector<GFeTri_t>(m_ptr, "PhysFeModelDesc_t", "m_Tris", true, value);
}
uint16_t GPhysFeModelDesc_t::GetTriCount1() const {
    return GetSchemaValue<uint16_t>(m_ptr, "PhysFeModelDesc_t", "m_nTriCount1");
}
void GPhysFeModelDesc_t::SetTriCount1(uint16_t value) {
    SetSchemaValue(m_ptr, "PhysFeModelDesc_t", "m_nTriCount1", true, value);
}
uint16_t GPhysFeModelDesc_t::GetTriCount2() const {
    return GetSchemaValue<uint16_t>(m_ptr, "PhysFeModelDesc_t", "m_nTriCount2");
}
void GPhysFeModelDesc_t::SetTriCount2(uint16_t value) {
    SetSchemaValue(m_ptr, "PhysFeModelDesc_t", "m_nTriCount2", true, value);
}
uint32_t GPhysFeModelDesc_t::GetReservedUint8() const {
    return GetSchemaValue<uint32_t>(m_ptr, "PhysFeModelDesc_t", "m_nReservedUint8");
}
void GPhysFeModelDesc_t::SetReservedUint8(uint32_t value) {
    SetSchemaValue(m_ptr, "PhysFeModelDesc_t", "m_nReservedUint8", true, value);
}
uint32_t GPhysFeModelDesc_t::GetExtraPressureIterations() const {
    return GetSchemaValue<uint32_t>(m_ptr, "PhysFeModelDesc_t", "m_nExtraPressureIterations");
}
void GPhysFeModelDesc_t::SetExtraPressureIterations(uint32_t value) {
    SetSchemaValue(m_ptr, "PhysFeModelDesc_t", "m_nExtraPressureIterations", true, value);
}
uint32_t GPhysFeModelDesc_t::GetExtraGoalIterations() const {
    return GetSchemaValue<uint32_t>(m_ptr, "PhysFeModelDesc_t", "m_nExtraGoalIterations");
}
void GPhysFeModelDesc_t::SetExtraGoalIterations(uint32_t value) {
    SetSchemaValue(m_ptr, "PhysFeModelDesc_t", "m_nExtraGoalIterations", true, value);
}
uint32_t GPhysFeModelDesc_t::GetExtraIterations() const {
    return GetSchemaValue<uint32_t>(m_ptr, "PhysFeModelDesc_t", "m_nExtraIterations");
}
void GPhysFeModelDesc_t::SetExtraIterations(uint32_t value) {
    SetSchemaValue(m_ptr, "PhysFeModelDesc_t", "m_nExtraIterations", true, value);
}
std::vector<GFeBoxRigid_t> GPhysFeModelDesc_t::GetBoxRigids() const {
    CUtlVector<GFeBoxRigid_t>* vec = GetSchemaValue<CUtlVector<GFeBoxRigid_t>*>(m_ptr, "PhysFeModelDesc_t", "m_BoxRigids"); std::vector<GFeBoxRigid_t> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GPhysFeModelDesc_t::SetBoxRigids(std::vector<GFeBoxRigid_t> value) {
    SetSchemaValueCUtlVector<GFeBoxRigid_t>(m_ptr, "PhysFeModelDesc_t", "m_BoxRigids", true, value);
}
std::vector<uint8> GPhysFeModelDesc_t::GetDynNodeVertexSet() const {
    CUtlVector<uint8>* vec = GetSchemaValue<CUtlVector<uint8>*>(m_ptr, "PhysFeModelDesc_t", "m_DynNodeVertexSet"); std::vector<uint8> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GPhysFeModelDesc_t::SetDynNodeVertexSet(std::vector<uint8> value) {
    SetSchemaValueCUtlVector<uint8>(m_ptr, "PhysFeModelDesc_t", "m_DynNodeVertexSet", true, value);
}
std::vector<uint32> GPhysFeModelDesc_t::GetVertexSetNames() const {
    CUtlVector<uint32>* vec = GetSchemaValue<CUtlVector<uint32>*>(m_ptr, "PhysFeModelDesc_t", "m_VertexSetNames"); std::vector<uint32> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GPhysFeModelDesc_t::SetVertexSetNames(std::vector<uint32> value) {
    SetSchemaValueCUtlVector<uint32>(m_ptr, "PhysFeModelDesc_t", "m_VertexSetNames", true, value);
}
std::vector<GFeRigidColliderIndices_t> GPhysFeModelDesc_t::GetRigidColliderPriorities() const {
    CUtlVector<GFeRigidColliderIndices_t>* vec = GetSchemaValue<CUtlVector<GFeRigidColliderIndices_t>*>(m_ptr, "PhysFeModelDesc_t", "m_RigidColliderPriorities"); std::vector<GFeRigidColliderIndices_t> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GPhysFeModelDesc_t::SetRigidColliderPriorities(std::vector<GFeRigidColliderIndices_t> value) {
    SetSchemaValueCUtlVector<GFeRigidColliderIndices_t>(m_ptr, "PhysFeModelDesc_t", "m_RigidColliderPriorities", true, value);
}
std::vector<GFeMorphLayerDepr_t> GPhysFeModelDesc_t::GetMorphLayers() const {
    CUtlVector<GFeMorphLayerDepr_t>* vec = GetSchemaValue<CUtlVector<GFeMorphLayerDepr_t>*>(m_ptr, "PhysFeModelDesc_t", "m_MorphLayers"); std::vector<GFeMorphLayerDepr_t> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GPhysFeModelDesc_t::SetMorphLayers(std::vector<GFeMorphLayerDepr_t> value) {
    SetSchemaValueCUtlVector<GFeMorphLayerDepr_t>(m_ptr, "PhysFeModelDesc_t", "m_MorphLayers", true, value);
}
std::vector<uint8> GPhysFeModelDesc_t::GetMorphSetData() const {
    CUtlVector<uint8>* vec = GetSchemaValue<CUtlVector<uint8>*>(m_ptr, "PhysFeModelDesc_t", "m_MorphSetData"); std::vector<uint8> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GPhysFeModelDesc_t::SetMorphSetData(std::vector<uint8> value) {
    SetSchemaValueCUtlVector<uint8>(m_ptr, "PhysFeModelDesc_t", "m_MorphSetData", true, value);
}
std::vector<GFeVertexMapDesc_t> GPhysFeModelDesc_t::GetVertexMaps() const {
    CUtlVector<GFeVertexMapDesc_t>* vec = GetSchemaValue<CUtlVector<GFeVertexMapDesc_t>*>(m_ptr, "PhysFeModelDesc_t", "m_VertexMaps"); std::vector<GFeVertexMapDesc_t> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GPhysFeModelDesc_t::SetVertexMaps(std::vector<GFeVertexMapDesc_t> value) {
    SetSchemaValueCUtlVector<GFeVertexMapDesc_t>(m_ptr, "PhysFeModelDesc_t", "m_VertexMaps", true, value);
}
std::vector<uint8> GPhysFeModelDesc_t::GetVertexMapValues() const {
    CUtlVector<uint8>* vec = GetSchemaValue<CUtlVector<uint8>*>(m_ptr, "PhysFeModelDesc_t", "m_VertexMapValues"); std::vector<uint8> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GPhysFeModelDesc_t::SetVertexMapValues(std::vector<uint8> value) {
    SetSchemaValueCUtlVector<uint8>(m_ptr, "PhysFeModelDesc_t", "m_VertexMapValues", true, value);
}
std::vector<GFeEffectDesc_t> GPhysFeModelDesc_t::GetEffects() const {
    CUtlVector<GFeEffectDesc_t>* vec = GetSchemaValue<CUtlVector<GFeEffectDesc_t>*>(m_ptr, "PhysFeModelDesc_t", "m_Effects"); std::vector<GFeEffectDesc_t> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GPhysFeModelDesc_t::SetEffects(std::vector<GFeEffectDesc_t> value) {
    SetSchemaValueCUtlVector<GFeEffectDesc_t>(m_ptr, "PhysFeModelDesc_t", "m_Effects", true, value);
}
std::vector<GFeCtrlOffset_t> GPhysFeModelDesc_t::GetLockToParent() const {
    CUtlVector<GFeCtrlOffset_t>* vec = GetSchemaValue<CUtlVector<GFeCtrlOffset_t>*>(m_ptr, "PhysFeModelDesc_t", "m_LockToParent"); std::vector<GFeCtrlOffset_t> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GPhysFeModelDesc_t::SetLockToParent(std::vector<GFeCtrlOffset_t> value) {
    SetSchemaValueCUtlVector<GFeCtrlOffset_t>(m_ptr, "PhysFeModelDesc_t", "m_LockToParent", true, value);
}
std::vector<uint16> GPhysFeModelDesc_t::GetLockToGoal() const {
    CUtlVector<uint16>* vec = GetSchemaValue<CUtlVector<uint16>*>(m_ptr, "PhysFeModelDesc_t", "m_LockToGoal"); std::vector<uint16> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GPhysFeModelDesc_t::SetLockToGoal(std::vector<uint16> value) {
    SetSchemaValueCUtlVector<uint16>(m_ptr, "PhysFeModelDesc_t", "m_LockToGoal", true, value);
}
std::vector<int16> GPhysFeModelDesc_t::GetSkelParents() const {
    CUtlVector<int16>* vec = GetSchemaValue<CUtlVector<int16>*>(m_ptr, "PhysFeModelDesc_t", "m_SkelParents"); std::vector<int16> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GPhysFeModelDesc_t::SetSkelParents(std::vector<int16> value) {
    SetSchemaValueCUtlVector<int16>(m_ptr, "PhysFeModelDesc_t", "m_SkelParents", true, value);
}
std::vector<GFeNodeWindBase_t> GPhysFeModelDesc_t::GetDynNodeWindBases() const {
    CUtlVector<GFeNodeWindBase_t>* vec = GetSchemaValue<CUtlVector<GFeNodeWindBase_t>*>(m_ptr, "PhysFeModelDesc_t", "m_DynNodeWindBases"); std::vector<GFeNodeWindBase_t> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GPhysFeModelDesc_t::SetDynNodeWindBases(std::vector<GFeNodeWindBase_t> value) {
    SetSchemaValueCUtlVector<GFeNodeWindBase_t>(m_ptr, "PhysFeModelDesc_t", "m_DynNodeWindBases", true, value);
}
float GPhysFeModelDesc_t::GetInternalPressure() const {
    return GetSchemaValue<float>(m_ptr, "PhysFeModelDesc_t", "m_flInternalPressure");
}
void GPhysFeModelDesc_t::SetInternalPressure(float value) {
    SetSchemaValue(m_ptr, "PhysFeModelDesc_t", "m_flInternalPressure", true, value);
}
float GPhysFeModelDesc_t::GetDefaultTimeDilation() const {
    return GetSchemaValue<float>(m_ptr, "PhysFeModelDesc_t", "m_flDefaultTimeDilation");
}
void GPhysFeModelDesc_t::SetDefaultTimeDilation(float value) {
    SetSchemaValue(m_ptr, "PhysFeModelDesc_t", "m_flDefaultTimeDilation", true, value);
}
float GPhysFeModelDesc_t::GetWindage() const {
    return GetSchemaValue<float>(m_ptr, "PhysFeModelDesc_t", "m_flWindage");
}
void GPhysFeModelDesc_t::SetWindage(float value) {
    SetSchemaValue(m_ptr, "PhysFeModelDesc_t", "m_flWindage", true, value);
}
float GPhysFeModelDesc_t::GetWindDrag() const {
    return GetSchemaValue<float>(m_ptr, "PhysFeModelDesc_t", "m_flWindDrag");
}
void GPhysFeModelDesc_t::SetWindDrag(float value) {
    SetSchemaValue(m_ptr, "PhysFeModelDesc_t", "m_flWindDrag", true, value);
}
float GPhysFeModelDesc_t::GetDefaultSurfaceStretch() const {
    return GetSchemaValue<float>(m_ptr, "PhysFeModelDesc_t", "m_flDefaultSurfaceStretch");
}
void GPhysFeModelDesc_t::SetDefaultSurfaceStretch(float value) {
    SetSchemaValue(m_ptr, "PhysFeModelDesc_t", "m_flDefaultSurfaceStretch", true, value);
}
float GPhysFeModelDesc_t::GetDefaultThreadStretch() const {
    return GetSchemaValue<float>(m_ptr, "PhysFeModelDesc_t", "m_flDefaultThreadStretch");
}
void GPhysFeModelDesc_t::SetDefaultThreadStretch(float value) {
    SetSchemaValue(m_ptr, "PhysFeModelDesc_t", "m_flDefaultThreadStretch", true, value);
}
float GPhysFeModelDesc_t::GetDefaultGravityScale() const {
    return GetSchemaValue<float>(m_ptr, "PhysFeModelDesc_t", "m_flDefaultGravityScale");
}
void GPhysFeModelDesc_t::SetDefaultGravityScale(float value) {
    SetSchemaValue(m_ptr, "PhysFeModelDesc_t", "m_flDefaultGravityScale", true, value);
}
float GPhysFeModelDesc_t::GetDefaultVelAirDrag() const {
    return GetSchemaValue<float>(m_ptr, "PhysFeModelDesc_t", "m_flDefaultVelAirDrag");
}
void GPhysFeModelDesc_t::SetDefaultVelAirDrag(float value) {
    SetSchemaValue(m_ptr, "PhysFeModelDesc_t", "m_flDefaultVelAirDrag", true, value);
}
float GPhysFeModelDesc_t::GetDefaultExpAirDrag() const {
    return GetSchemaValue<float>(m_ptr, "PhysFeModelDesc_t", "m_flDefaultExpAirDrag");
}
void GPhysFeModelDesc_t::SetDefaultExpAirDrag(float value) {
    SetSchemaValue(m_ptr, "PhysFeModelDesc_t", "m_flDefaultExpAirDrag", true, value);
}
float GPhysFeModelDesc_t::GetDefaultVelQuadAirDrag() const {
    return GetSchemaValue<float>(m_ptr, "PhysFeModelDesc_t", "m_flDefaultVelQuadAirDrag");
}
void GPhysFeModelDesc_t::SetDefaultVelQuadAirDrag(float value) {
    SetSchemaValue(m_ptr, "PhysFeModelDesc_t", "m_flDefaultVelQuadAirDrag", true, value);
}
float GPhysFeModelDesc_t::GetDefaultExpQuadAirDrag() const {
    return GetSchemaValue<float>(m_ptr, "PhysFeModelDesc_t", "m_flDefaultExpQuadAirDrag");
}
void GPhysFeModelDesc_t::SetDefaultExpQuadAirDrag(float value) {
    SetSchemaValue(m_ptr, "PhysFeModelDesc_t", "m_flDefaultExpQuadAirDrag", true, value);
}
float GPhysFeModelDesc_t::GetRodVelocitySmoothRate() const {
    return GetSchemaValue<float>(m_ptr, "PhysFeModelDesc_t", "m_flRodVelocitySmoothRate");
}
void GPhysFeModelDesc_t::SetRodVelocitySmoothRate(float value) {
    SetSchemaValue(m_ptr, "PhysFeModelDesc_t", "m_flRodVelocitySmoothRate", true, value);
}
float GPhysFeModelDesc_t::GetQuadVelocitySmoothRate() const {
    return GetSchemaValue<float>(m_ptr, "PhysFeModelDesc_t", "m_flQuadVelocitySmoothRate");
}
void GPhysFeModelDesc_t::SetQuadVelocitySmoothRate(float value) {
    SetSchemaValue(m_ptr, "PhysFeModelDesc_t", "m_flQuadVelocitySmoothRate", true, value);
}
float GPhysFeModelDesc_t::GetAddWorldCollisionRadius() const {
    return GetSchemaValue<float>(m_ptr, "PhysFeModelDesc_t", "m_flAddWorldCollisionRadius");
}
void GPhysFeModelDesc_t::SetAddWorldCollisionRadius(float value) {
    SetSchemaValue(m_ptr, "PhysFeModelDesc_t", "m_flAddWorldCollisionRadius", true, value);
}
float GPhysFeModelDesc_t::GetDefaultVolumetricSolveAmount() const {
    return GetSchemaValue<float>(m_ptr, "PhysFeModelDesc_t", "m_flDefaultVolumetricSolveAmount");
}
void GPhysFeModelDesc_t::SetDefaultVolumetricSolveAmount(float value) {
    SetSchemaValue(m_ptr, "PhysFeModelDesc_t", "m_flDefaultVolumetricSolveAmount", true, value);
}
float GPhysFeModelDesc_t::GetMotionSmoothCDT() const {
    return GetSchemaValue<float>(m_ptr, "PhysFeModelDesc_t", "m_flMotionSmoothCDT");
}
void GPhysFeModelDesc_t::SetMotionSmoothCDT(float value) {
    SetSchemaValue(m_ptr, "PhysFeModelDesc_t", "m_flMotionSmoothCDT", true, value);
}
uint16_t GPhysFeModelDesc_t::GetRodVelocitySmoothIterations() const {
    return GetSchemaValue<uint16_t>(m_ptr, "PhysFeModelDesc_t", "m_nRodVelocitySmoothIterations");
}
void GPhysFeModelDesc_t::SetRodVelocitySmoothIterations(uint16_t value) {
    SetSchemaValue(m_ptr, "PhysFeModelDesc_t", "m_nRodVelocitySmoothIterations", true, value);
}
uint16_t GPhysFeModelDesc_t::GetQuadVelocitySmoothIterations() const {
    return GetSchemaValue<uint16_t>(m_ptr, "PhysFeModelDesc_t", "m_nQuadVelocitySmoothIterations");
}
void GPhysFeModelDesc_t::SetQuadVelocitySmoothIterations(uint16_t value) {
    SetSchemaValue(m_ptr, "PhysFeModelDesc_t", "m_nQuadVelocitySmoothIterations", true, value);
}
void* GPhysFeModelDesc_t::GetPtr() {
    return m_ptr;
}
std::string GPhysFeModelDesc_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GPhysFeModelDesc_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassPhysFeModelDesc_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GPhysFeModelDesc_t>("PhysFeModelDesc_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("CtrlHash", &GPhysFeModelDesc_t::GetCtrlHash, &GPhysFeModelDesc_t::SetCtrlHash)
        .addProperty("CtrlName", &GPhysFeModelDesc_t::GetCtrlName, &GPhysFeModelDesc_t::SetCtrlName)
        .addProperty("StaticNodeFlags", &GPhysFeModelDesc_t::GetStaticNodeFlags, &GPhysFeModelDesc_t::SetStaticNodeFlags)
        .addProperty("DynamicNodeFlags", &GPhysFeModelDesc_t::GetDynamicNodeFlags, &GPhysFeModelDesc_t::SetDynamicNodeFlags)
        .addProperty("LocalForce", &GPhysFeModelDesc_t::GetLocalForce, &GPhysFeModelDesc_t::SetLocalForce)
        .addProperty("LocalRotation", &GPhysFeModelDesc_t::GetLocalRotation, &GPhysFeModelDesc_t::SetLocalRotation)
        .addProperty("NodeCount", &GPhysFeModelDesc_t::GetNodeCount, &GPhysFeModelDesc_t::SetNodeCount)
        .addProperty("StaticNodes", &GPhysFeModelDesc_t::GetStaticNodes, &GPhysFeModelDesc_t::SetStaticNodes)
        .addProperty("RotLockStaticNodes", &GPhysFeModelDesc_t::GetRotLockStaticNodes, &GPhysFeModelDesc_t::SetRotLockStaticNodes)
        .addProperty("FirstPositionDrivenNode", &GPhysFeModelDesc_t::GetFirstPositionDrivenNode, &GPhysFeModelDesc_t::SetFirstPositionDrivenNode)
        .addProperty("SimdTriCount1", &GPhysFeModelDesc_t::GetSimdTriCount1, &GPhysFeModelDesc_t::SetSimdTriCount1)
        .addProperty("SimdTriCount2", &GPhysFeModelDesc_t::GetSimdTriCount2, &GPhysFeModelDesc_t::SetSimdTriCount2)
        .addProperty("SimdQuadCount1", &GPhysFeModelDesc_t::GetSimdQuadCount1, &GPhysFeModelDesc_t::SetSimdQuadCount1)
        .addProperty("SimdQuadCount2", &GPhysFeModelDesc_t::GetSimdQuadCount2, &GPhysFeModelDesc_t::SetSimdQuadCount2)
        .addProperty("QuadCount1", &GPhysFeModelDesc_t::GetQuadCount1, &GPhysFeModelDesc_t::SetQuadCount1)
        .addProperty("QuadCount2", &GPhysFeModelDesc_t::GetQuadCount2, &GPhysFeModelDesc_t::SetQuadCount2)
        .addProperty("TreeDepth", &GPhysFeModelDesc_t::GetTreeDepth, &GPhysFeModelDesc_t::SetTreeDepth)
        .addProperty("NodeBaseJiggleboneDependsCount", &GPhysFeModelDesc_t::GetNodeBaseJiggleboneDependsCount, &GPhysFeModelDesc_t::SetNodeBaseJiggleboneDependsCount)
        .addProperty("RopeCount", &GPhysFeModelDesc_t::GetRopeCount, &GPhysFeModelDesc_t::SetRopeCount)
        .addProperty("Ropes", &GPhysFeModelDesc_t::GetRopes, &GPhysFeModelDesc_t::SetRopes)
        .addProperty("NodeBases", &GPhysFeModelDesc_t::GetNodeBases, &GPhysFeModelDesc_t::SetNodeBases)
        .addProperty("SimdNodeBases", &GPhysFeModelDesc_t::GetSimdNodeBases, &GPhysFeModelDesc_t::SetSimdNodeBases)
        .addProperty("Quads", &GPhysFeModelDesc_t::GetQuads, &GPhysFeModelDesc_t::SetQuads)
        .addProperty("SimdQuads", &GPhysFeModelDesc_t::GetSimdQuads, &GPhysFeModelDesc_t::SetSimdQuads)
        .addProperty("SimdTris", &GPhysFeModelDesc_t::GetSimdTris, &GPhysFeModelDesc_t::SetSimdTris)
        .addProperty("SimdRods", &GPhysFeModelDesc_t::GetSimdRods, &GPhysFeModelDesc_t::SetSimdRods)
        .addProperty("SimdRodsAnim", &GPhysFeModelDesc_t::GetSimdRodsAnim, &GPhysFeModelDesc_t::SetSimdRodsAnim)
        .addProperty("Rods", &GPhysFeModelDesc_t::GetRods, &GPhysFeModelDesc_t::SetRods)
        .addProperty("Twists", &GPhysFeModelDesc_t::GetTwists, &GPhysFeModelDesc_t::SetTwists)
        .addProperty("AxialEdges", &GPhysFeModelDesc_t::GetAxialEdges, &GPhysFeModelDesc_t::SetAxialEdges)
        .addProperty("NodeInvMasses", &GPhysFeModelDesc_t::GetNodeInvMasses, &GPhysFeModelDesc_t::SetNodeInvMasses)
        .addProperty("CtrlOffsets", &GPhysFeModelDesc_t::GetCtrlOffsets, &GPhysFeModelDesc_t::SetCtrlOffsets)
        .addProperty("CtrlOsOffsets", &GPhysFeModelDesc_t::GetCtrlOsOffsets, &GPhysFeModelDesc_t::SetCtrlOsOffsets)
        .addProperty("FollowNodes", &GPhysFeModelDesc_t::GetFollowNodes, &GPhysFeModelDesc_t::SetFollowNodes)
        .addProperty("CollisionPlanes", &GPhysFeModelDesc_t::GetCollisionPlanes, &GPhysFeModelDesc_t::SetCollisionPlanes)
        .addProperty("NodeIntegrator", &GPhysFeModelDesc_t::GetNodeIntegrator, &GPhysFeModelDesc_t::SetNodeIntegrator)
        .addProperty("SpringIntegrator", &GPhysFeModelDesc_t::GetSpringIntegrator, &GPhysFeModelDesc_t::SetSpringIntegrator)
        .addProperty("SimdSpringIntegrator", &GPhysFeModelDesc_t::GetSimdSpringIntegrator, &GPhysFeModelDesc_t::SetSimdSpringIntegrator)
        .addProperty("WorldCollisionParams", &GPhysFeModelDesc_t::GetWorldCollisionParams, &GPhysFeModelDesc_t::SetWorldCollisionParams)
        .addProperty("LegacyStretchForce", &GPhysFeModelDesc_t::GetLegacyStretchForce, &GPhysFeModelDesc_t::SetLegacyStretchForce)
        .addProperty("NodeCollisionRadii", &GPhysFeModelDesc_t::GetNodeCollisionRadii, &GPhysFeModelDesc_t::SetNodeCollisionRadii)
        .addProperty("DynNodeFriction", &GPhysFeModelDesc_t::GetDynNodeFriction, &GPhysFeModelDesc_t::SetDynNodeFriction)
        .addProperty("LocalRotation1", &GPhysFeModelDesc_t::GetLocalRotation1, &GPhysFeModelDesc_t::SetLocalRotation1)
        .addProperty("LocalForce1", &GPhysFeModelDesc_t::GetLocalForce1, &GPhysFeModelDesc_t::SetLocalForce1)
        .addProperty("TaperedCapsuleStretches", &GPhysFeModelDesc_t::GetTaperedCapsuleStretches, &GPhysFeModelDesc_t::SetTaperedCapsuleStretches)
        .addProperty("TaperedCapsuleRigids", &GPhysFeModelDesc_t::GetTaperedCapsuleRigids, &GPhysFeModelDesc_t::SetTaperedCapsuleRigids)
        .addProperty("SphereRigids", &GPhysFeModelDesc_t::GetSphereRigids, &GPhysFeModelDesc_t::SetSphereRigids)
        .addProperty("WorldCollisionNodes", &GPhysFeModelDesc_t::GetWorldCollisionNodes, &GPhysFeModelDesc_t::SetWorldCollisionNodes)
        .addProperty("TreeParents", &GPhysFeModelDesc_t::GetTreeParents, &GPhysFeModelDesc_t::SetTreeParents)
        .addProperty("TreeCollisionMasks", &GPhysFeModelDesc_t::GetTreeCollisionMasks, &GPhysFeModelDesc_t::SetTreeCollisionMasks)
        .addProperty("TreeChildren", &GPhysFeModelDesc_t::GetTreeChildren, &GPhysFeModelDesc_t::SetTreeChildren)
        .addProperty("FreeNodes", &GPhysFeModelDesc_t::GetFreeNodes, &GPhysFeModelDesc_t::SetFreeNodes)
        .addProperty("FitMatrices", &GPhysFeModelDesc_t::GetFitMatrices, &GPhysFeModelDesc_t::SetFitMatrices)
        .addProperty("FitWeights", &GPhysFeModelDesc_t::GetFitWeights, &GPhysFeModelDesc_t::SetFitWeights)
        .addProperty("ReverseOffsets", &GPhysFeModelDesc_t::GetReverseOffsets, &GPhysFeModelDesc_t::SetReverseOffsets)
        .addProperty("AnimStrayRadii", &GPhysFeModelDesc_t::GetAnimStrayRadii, &GPhysFeModelDesc_t::SetAnimStrayRadii)
        .addProperty("SimdAnimStrayRadii", &GPhysFeModelDesc_t::GetSimdAnimStrayRadii, &GPhysFeModelDesc_t::SetSimdAnimStrayRadii)
        .addProperty("KelagerBends", &GPhysFeModelDesc_t::GetKelagerBends, &GPhysFeModelDesc_t::SetKelagerBends)
        .addProperty("CtrlSoftOffsets", &GPhysFeModelDesc_t::GetCtrlSoftOffsets, &GPhysFeModelDesc_t::SetCtrlSoftOffsets)
        .addProperty("JiggleBones", &GPhysFeModelDesc_t::GetJiggleBones, &GPhysFeModelDesc_t::SetJiggleBones)
        .addProperty("SourceElems", &GPhysFeModelDesc_t::GetSourceElems, &GPhysFeModelDesc_t::SetSourceElems)
        .addProperty("GoalDampedSpringIntegrators", &GPhysFeModelDesc_t::GetGoalDampedSpringIntegrators, &GPhysFeModelDesc_t::SetGoalDampedSpringIntegrators)
        .addProperty("Tris", &GPhysFeModelDesc_t::GetTris, &GPhysFeModelDesc_t::SetTris)
        .addProperty("TriCount1", &GPhysFeModelDesc_t::GetTriCount1, &GPhysFeModelDesc_t::SetTriCount1)
        .addProperty("TriCount2", &GPhysFeModelDesc_t::GetTriCount2, &GPhysFeModelDesc_t::SetTriCount2)
        .addProperty("ReservedUint8", &GPhysFeModelDesc_t::GetReservedUint8, &GPhysFeModelDesc_t::SetReservedUint8)
        .addProperty("ExtraPressureIterations", &GPhysFeModelDesc_t::GetExtraPressureIterations, &GPhysFeModelDesc_t::SetExtraPressureIterations)
        .addProperty("ExtraGoalIterations", &GPhysFeModelDesc_t::GetExtraGoalIterations, &GPhysFeModelDesc_t::SetExtraGoalIterations)
        .addProperty("ExtraIterations", &GPhysFeModelDesc_t::GetExtraIterations, &GPhysFeModelDesc_t::SetExtraIterations)
        .addProperty("BoxRigids", &GPhysFeModelDesc_t::GetBoxRigids, &GPhysFeModelDesc_t::SetBoxRigids)
        .addProperty("DynNodeVertexSet", &GPhysFeModelDesc_t::GetDynNodeVertexSet, &GPhysFeModelDesc_t::SetDynNodeVertexSet)
        .addProperty("VertexSetNames", &GPhysFeModelDesc_t::GetVertexSetNames, &GPhysFeModelDesc_t::SetVertexSetNames)
        .addProperty("RigidColliderPriorities", &GPhysFeModelDesc_t::GetRigidColliderPriorities, &GPhysFeModelDesc_t::SetRigidColliderPriorities)
        .addProperty("MorphLayers", &GPhysFeModelDesc_t::GetMorphLayers, &GPhysFeModelDesc_t::SetMorphLayers)
        .addProperty("MorphSetData", &GPhysFeModelDesc_t::GetMorphSetData, &GPhysFeModelDesc_t::SetMorphSetData)
        .addProperty("VertexMaps", &GPhysFeModelDesc_t::GetVertexMaps, &GPhysFeModelDesc_t::SetVertexMaps)
        .addProperty("VertexMapValues", &GPhysFeModelDesc_t::GetVertexMapValues, &GPhysFeModelDesc_t::SetVertexMapValues)
        .addProperty("Effects", &GPhysFeModelDesc_t::GetEffects, &GPhysFeModelDesc_t::SetEffects)
        .addProperty("LockToParent", &GPhysFeModelDesc_t::GetLockToParent, &GPhysFeModelDesc_t::SetLockToParent)
        .addProperty("LockToGoal", &GPhysFeModelDesc_t::GetLockToGoal, &GPhysFeModelDesc_t::SetLockToGoal)
        .addProperty("SkelParents", &GPhysFeModelDesc_t::GetSkelParents, &GPhysFeModelDesc_t::SetSkelParents)
        .addProperty("DynNodeWindBases", &GPhysFeModelDesc_t::GetDynNodeWindBases, &GPhysFeModelDesc_t::SetDynNodeWindBases)
        .addProperty("InternalPressure", &GPhysFeModelDesc_t::GetInternalPressure, &GPhysFeModelDesc_t::SetInternalPressure)
        .addProperty("DefaultTimeDilation", &GPhysFeModelDesc_t::GetDefaultTimeDilation, &GPhysFeModelDesc_t::SetDefaultTimeDilation)
        .addProperty("Windage", &GPhysFeModelDesc_t::GetWindage, &GPhysFeModelDesc_t::SetWindage)
        .addProperty("WindDrag", &GPhysFeModelDesc_t::GetWindDrag, &GPhysFeModelDesc_t::SetWindDrag)
        .addProperty("DefaultSurfaceStretch", &GPhysFeModelDesc_t::GetDefaultSurfaceStretch, &GPhysFeModelDesc_t::SetDefaultSurfaceStretch)
        .addProperty("DefaultThreadStretch", &GPhysFeModelDesc_t::GetDefaultThreadStretch, &GPhysFeModelDesc_t::SetDefaultThreadStretch)
        .addProperty("DefaultGravityScale", &GPhysFeModelDesc_t::GetDefaultGravityScale, &GPhysFeModelDesc_t::SetDefaultGravityScale)
        .addProperty("DefaultVelAirDrag", &GPhysFeModelDesc_t::GetDefaultVelAirDrag, &GPhysFeModelDesc_t::SetDefaultVelAirDrag)
        .addProperty("DefaultExpAirDrag", &GPhysFeModelDesc_t::GetDefaultExpAirDrag, &GPhysFeModelDesc_t::SetDefaultExpAirDrag)
        .addProperty("DefaultVelQuadAirDrag", &GPhysFeModelDesc_t::GetDefaultVelQuadAirDrag, &GPhysFeModelDesc_t::SetDefaultVelQuadAirDrag)
        .addProperty("DefaultExpQuadAirDrag", &GPhysFeModelDesc_t::GetDefaultExpQuadAirDrag, &GPhysFeModelDesc_t::SetDefaultExpQuadAirDrag)
        .addProperty("RodVelocitySmoothRate", &GPhysFeModelDesc_t::GetRodVelocitySmoothRate, &GPhysFeModelDesc_t::SetRodVelocitySmoothRate)
        .addProperty("QuadVelocitySmoothRate", &GPhysFeModelDesc_t::GetQuadVelocitySmoothRate, &GPhysFeModelDesc_t::SetQuadVelocitySmoothRate)
        .addProperty("AddWorldCollisionRadius", &GPhysFeModelDesc_t::GetAddWorldCollisionRadius, &GPhysFeModelDesc_t::SetAddWorldCollisionRadius)
        .addProperty("DefaultVolumetricSolveAmount", &GPhysFeModelDesc_t::GetDefaultVolumetricSolveAmount, &GPhysFeModelDesc_t::SetDefaultVolumetricSolveAmount)
        .addProperty("MotionSmoothCDT", &GPhysFeModelDesc_t::GetMotionSmoothCDT, &GPhysFeModelDesc_t::SetMotionSmoothCDT)
        .addProperty("RodVelocitySmoothIterations", &GPhysFeModelDesc_t::GetRodVelocitySmoothIterations, &GPhysFeModelDesc_t::SetRodVelocitySmoothIterations)
        .addProperty("QuadVelocitySmoothIterations", &GPhysFeModelDesc_t::GetQuadVelocitySmoothIterations, &GPhysFeModelDesc_t::SetQuadVelocitySmoothIterations)
        .addFunction("ToPtr", &GPhysFeModelDesc_t::ToPtr)
        .addFunction("IsValid", &GPhysFeModelDesc_t::IsValid)
        .endClass();
}
GCCycleBase::GCCycleBase(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCCycleBase::GCCycleBase(void *ptr) {
    m_ptr = ptr;
}
float GCCycleBase::GetCycle() const {
    return GetSchemaValue<float>(m_ptr, "CCycleBase", "m_flCycle");
}
void GCCycleBase::SetCycle(float value) {
    SetSchemaValue(m_ptr, "CCycleBase", "m_flCycle", false, value);
}
void* GCCycleBase::GetPtr() {
    return m_ptr;
}
std::string GCCycleBase::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCCycleBase::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCCycleBase(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCCycleBase>("CCycleBase")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Cycle", &GCCycleBase::GetCycle, &GCCycleBase::SetCycle)
        .addFunction("ToPtr", &GCCycleBase::ToPtr)
        .addFunction("IsValid", &GCCycleBase::IsValid)
        .endClass();
}
GCPhysSurfacePropertiesSoundNames::GCPhysSurfacePropertiesSoundNames(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCPhysSurfacePropertiesSoundNames::GCPhysSurfacePropertiesSoundNames(void *ptr) {
    m_ptr = ptr;
}
std::string GCPhysSurfacePropertiesSoundNames::GetImpactSoft() const {
    return GetSchemaValue<CUtlString>(m_ptr, "CPhysSurfacePropertiesSoundNames", "m_impactSoft").Get();
}
void GCPhysSurfacePropertiesSoundNames::SetImpactSoft(std::string value) {
    SetSchemaValue(m_ptr, "CPhysSurfacePropertiesSoundNames", "m_impactSoft", false, CUtlString(value.c_str()));
}
std::string GCPhysSurfacePropertiesSoundNames::GetImpactHard() const {
    return GetSchemaValue<CUtlString>(m_ptr, "CPhysSurfacePropertiesSoundNames", "m_impactHard").Get();
}
void GCPhysSurfacePropertiesSoundNames::SetImpactHard(std::string value) {
    SetSchemaValue(m_ptr, "CPhysSurfacePropertiesSoundNames", "m_impactHard", false, CUtlString(value.c_str()));
}
std::string GCPhysSurfacePropertiesSoundNames::GetScrapeSmooth() const {
    return GetSchemaValue<CUtlString>(m_ptr, "CPhysSurfacePropertiesSoundNames", "m_scrapeSmooth").Get();
}
void GCPhysSurfacePropertiesSoundNames::SetScrapeSmooth(std::string value) {
    SetSchemaValue(m_ptr, "CPhysSurfacePropertiesSoundNames", "m_scrapeSmooth", false, CUtlString(value.c_str()));
}
std::string GCPhysSurfacePropertiesSoundNames::GetScrapeRough() const {
    return GetSchemaValue<CUtlString>(m_ptr, "CPhysSurfacePropertiesSoundNames", "m_scrapeRough").Get();
}
void GCPhysSurfacePropertiesSoundNames::SetScrapeRough(std::string value) {
    SetSchemaValue(m_ptr, "CPhysSurfacePropertiesSoundNames", "m_scrapeRough", false, CUtlString(value.c_str()));
}
std::string GCPhysSurfacePropertiesSoundNames::GetBulletImpact() const {
    return GetSchemaValue<CUtlString>(m_ptr, "CPhysSurfacePropertiesSoundNames", "m_bulletImpact").Get();
}
void GCPhysSurfacePropertiesSoundNames::SetBulletImpact(std::string value) {
    SetSchemaValue(m_ptr, "CPhysSurfacePropertiesSoundNames", "m_bulletImpact", false, CUtlString(value.c_str()));
}
std::string GCPhysSurfacePropertiesSoundNames::GetRolling() const {
    return GetSchemaValue<CUtlString>(m_ptr, "CPhysSurfacePropertiesSoundNames", "m_rolling").Get();
}
void GCPhysSurfacePropertiesSoundNames::SetRolling(std::string value) {
    SetSchemaValue(m_ptr, "CPhysSurfacePropertiesSoundNames", "m_rolling", false, CUtlString(value.c_str()));
}
std::string GCPhysSurfacePropertiesSoundNames::GetBreak() const {
    return GetSchemaValue<CUtlString>(m_ptr, "CPhysSurfacePropertiesSoundNames", "m_break").Get();
}
void GCPhysSurfacePropertiesSoundNames::SetBreak(std::string value) {
    SetSchemaValue(m_ptr, "CPhysSurfacePropertiesSoundNames", "m_break", false, CUtlString(value.c_str()));
}
std::string GCPhysSurfacePropertiesSoundNames::GetStrain() const {
    return GetSchemaValue<CUtlString>(m_ptr, "CPhysSurfacePropertiesSoundNames", "m_strain").Get();
}
void GCPhysSurfacePropertiesSoundNames::SetStrain(std::string value) {
    SetSchemaValue(m_ptr, "CPhysSurfacePropertiesSoundNames", "m_strain", false, CUtlString(value.c_str()));
}
std::string GCPhysSurfacePropertiesSoundNames::GetMeleeImpact() const {
    return GetSchemaValue<CUtlString>(m_ptr, "CPhysSurfacePropertiesSoundNames", "m_meleeImpact").Get();
}
void GCPhysSurfacePropertiesSoundNames::SetMeleeImpact(std::string value) {
    SetSchemaValue(m_ptr, "CPhysSurfacePropertiesSoundNames", "m_meleeImpact", false, CUtlString(value.c_str()));
}
std::string GCPhysSurfacePropertiesSoundNames::GetPushOff() const {
    return GetSchemaValue<CUtlString>(m_ptr, "CPhysSurfacePropertiesSoundNames", "m_pushOff").Get();
}
void GCPhysSurfacePropertiesSoundNames::SetPushOff(std::string value) {
    SetSchemaValue(m_ptr, "CPhysSurfacePropertiesSoundNames", "m_pushOff", false, CUtlString(value.c_str()));
}
std::string GCPhysSurfacePropertiesSoundNames::GetSkidStop() const {
    return GetSchemaValue<CUtlString>(m_ptr, "CPhysSurfacePropertiesSoundNames", "m_skidStop").Get();
}
void GCPhysSurfacePropertiesSoundNames::SetSkidStop(std::string value) {
    SetSchemaValue(m_ptr, "CPhysSurfacePropertiesSoundNames", "m_skidStop", false, CUtlString(value.c_str()));
}
void* GCPhysSurfacePropertiesSoundNames::GetPtr() {
    return m_ptr;
}
std::string GCPhysSurfacePropertiesSoundNames::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCPhysSurfacePropertiesSoundNames::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCPhysSurfacePropertiesSoundNames(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCPhysSurfacePropertiesSoundNames>("CPhysSurfacePropertiesSoundNames")
        .addConstructor<void (*)(std::string)>()
        .addProperty("ImpactSoft", &GCPhysSurfacePropertiesSoundNames::GetImpactSoft, &GCPhysSurfacePropertiesSoundNames::SetImpactSoft)
        .addProperty("ImpactHard", &GCPhysSurfacePropertiesSoundNames::GetImpactHard, &GCPhysSurfacePropertiesSoundNames::SetImpactHard)
        .addProperty("ScrapeSmooth", &GCPhysSurfacePropertiesSoundNames::GetScrapeSmooth, &GCPhysSurfacePropertiesSoundNames::SetScrapeSmooth)
        .addProperty("ScrapeRough", &GCPhysSurfacePropertiesSoundNames::GetScrapeRough, &GCPhysSurfacePropertiesSoundNames::SetScrapeRough)
        .addProperty("BulletImpact", &GCPhysSurfacePropertiesSoundNames::GetBulletImpact, &GCPhysSurfacePropertiesSoundNames::SetBulletImpact)
        .addProperty("Rolling", &GCPhysSurfacePropertiesSoundNames::GetRolling, &GCPhysSurfacePropertiesSoundNames::SetRolling)
        .addProperty("Break", &GCPhysSurfacePropertiesSoundNames::GetBreak, &GCPhysSurfacePropertiesSoundNames::SetBreak)
        .addProperty("Strain", &GCPhysSurfacePropertiesSoundNames::GetStrain, &GCPhysSurfacePropertiesSoundNames::SetStrain)
        .addProperty("MeleeImpact", &GCPhysSurfacePropertiesSoundNames::GetMeleeImpact, &GCPhysSurfacePropertiesSoundNames::SetMeleeImpact)
        .addProperty("PushOff", &GCPhysSurfacePropertiesSoundNames::GetPushOff, &GCPhysSurfacePropertiesSoundNames::SetPushOff)
        .addProperty("SkidStop", &GCPhysSurfacePropertiesSoundNames::GetSkidStop, &GCPhysSurfacePropertiesSoundNames::SetSkidStop)
        .addFunction("ToPtr", &GCPhysSurfacePropertiesSoundNames::ToPtr)
        .addFunction("IsValid", &GCPhysSurfacePropertiesSoundNames::IsValid)
        .endClass();
}
GDynamicMeshDeformParams_t::GDynamicMeshDeformParams_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GDynamicMeshDeformParams_t::GDynamicMeshDeformParams_t(void *ptr) {
    m_ptr = ptr;
}
float GDynamicMeshDeformParams_t::GetTensionCompressScale() const {
    return GetSchemaValue<float>(m_ptr, "DynamicMeshDeformParams_t", "m_flTensionCompressScale");
}
void GDynamicMeshDeformParams_t::SetTensionCompressScale(float value) {
    SetSchemaValue(m_ptr, "DynamicMeshDeformParams_t", "m_flTensionCompressScale", true, value);
}
float GDynamicMeshDeformParams_t::GetTensionStretchScale() const {
    return GetSchemaValue<float>(m_ptr, "DynamicMeshDeformParams_t", "m_flTensionStretchScale");
}
void GDynamicMeshDeformParams_t::SetTensionStretchScale(float value) {
    SetSchemaValue(m_ptr, "DynamicMeshDeformParams_t", "m_flTensionStretchScale", true, value);
}
bool GDynamicMeshDeformParams_t::GetRecomputeSmoothNormalsAfterAnimation() const {
    return GetSchemaValue<bool>(m_ptr, "DynamicMeshDeformParams_t", "m_bRecomputeSmoothNormalsAfterAnimation");
}
void GDynamicMeshDeformParams_t::SetRecomputeSmoothNormalsAfterAnimation(bool value) {
    SetSchemaValue(m_ptr, "DynamicMeshDeformParams_t", "m_bRecomputeSmoothNormalsAfterAnimation", true, value);
}
bool GDynamicMeshDeformParams_t::GetComputeDynamicMeshTensionAfterAnimation() const {
    return GetSchemaValue<bool>(m_ptr, "DynamicMeshDeformParams_t", "m_bComputeDynamicMeshTensionAfterAnimation");
}
void GDynamicMeshDeformParams_t::SetComputeDynamicMeshTensionAfterAnimation(bool value) {
    SetSchemaValue(m_ptr, "DynamicMeshDeformParams_t", "m_bComputeDynamicMeshTensionAfterAnimation", true, value);
}
void* GDynamicMeshDeformParams_t::GetPtr() {
    return m_ptr;
}
std::string GDynamicMeshDeformParams_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GDynamicMeshDeformParams_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassDynamicMeshDeformParams_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GDynamicMeshDeformParams_t>("DynamicMeshDeformParams_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("TensionCompressScale", &GDynamicMeshDeformParams_t::GetTensionCompressScale, &GDynamicMeshDeformParams_t::SetTensionCompressScale)
        .addProperty("TensionStretchScale", &GDynamicMeshDeformParams_t::GetTensionStretchScale, &GDynamicMeshDeformParams_t::SetTensionStretchScale)
        .addProperty("RecomputeSmoothNormalsAfterAnimation", &GDynamicMeshDeformParams_t::GetRecomputeSmoothNormalsAfterAnimation, &GDynamicMeshDeformParams_t::SetRecomputeSmoothNormalsAfterAnimation)
        .addProperty("ComputeDynamicMeshTensionAfterAnimation", &GDynamicMeshDeformParams_t::GetComputeDynamicMeshTensionAfterAnimation, &GDynamicMeshDeformParams_t::SetComputeDynamicMeshTensionAfterAnimation)
        .addFunction("ToPtr", &GDynamicMeshDeformParams_t::ToPtr)
        .addFunction("IsValid", &GDynamicMeshDeformParams_t::IsValid)
        .endClass();
}
GCDistanceRemainingMetricEvaluator::GCDistanceRemainingMetricEvaluator(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCDistanceRemainingMetricEvaluator::GCDistanceRemainingMetricEvaluator(void *ptr) {
    m_ptr = ptr;
}
float GCDistanceRemainingMetricEvaluator::GetMaxDistance() const {
    return GetSchemaValue<float>(m_ptr, "CDistanceRemainingMetricEvaluator", "m_flMaxDistance");
}
void GCDistanceRemainingMetricEvaluator::SetMaxDistance(float value) {
    SetSchemaValue(m_ptr, "CDistanceRemainingMetricEvaluator", "m_flMaxDistance", false, value);
}
float GCDistanceRemainingMetricEvaluator::GetMinDistance() const {
    return GetSchemaValue<float>(m_ptr, "CDistanceRemainingMetricEvaluator", "m_flMinDistance");
}
void GCDistanceRemainingMetricEvaluator::SetMinDistance(float value) {
    SetSchemaValue(m_ptr, "CDistanceRemainingMetricEvaluator", "m_flMinDistance", false, value);
}
float GCDistanceRemainingMetricEvaluator::GetStartGoalFilterDistance() const {
    return GetSchemaValue<float>(m_ptr, "CDistanceRemainingMetricEvaluator", "m_flStartGoalFilterDistance");
}
void GCDistanceRemainingMetricEvaluator::SetStartGoalFilterDistance(float value) {
    SetSchemaValue(m_ptr, "CDistanceRemainingMetricEvaluator", "m_flStartGoalFilterDistance", false, value);
}
float GCDistanceRemainingMetricEvaluator::GetMaxGoalOvershootScale() const {
    return GetSchemaValue<float>(m_ptr, "CDistanceRemainingMetricEvaluator", "m_flMaxGoalOvershootScale");
}
void GCDistanceRemainingMetricEvaluator::SetMaxGoalOvershootScale(float value) {
    SetSchemaValue(m_ptr, "CDistanceRemainingMetricEvaluator", "m_flMaxGoalOvershootScale", false, value);
}
bool GCDistanceRemainingMetricEvaluator::GetFilterFixedMinDistance() const {
    return GetSchemaValue<bool>(m_ptr, "CDistanceRemainingMetricEvaluator", "m_bFilterFixedMinDistance");
}
void GCDistanceRemainingMetricEvaluator::SetFilterFixedMinDistance(bool value) {
    SetSchemaValue(m_ptr, "CDistanceRemainingMetricEvaluator", "m_bFilterFixedMinDistance", false, value);
}
bool GCDistanceRemainingMetricEvaluator::GetFilterGoalDistance() const {
    return GetSchemaValue<bool>(m_ptr, "CDistanceRemainingMetricEvaluator", "m_bFilterGoalDistance");
}
void GCDistanceRemainingMetricEvaluator::SetFilterGoalDistance(bool value) {
    SetSchemaValue(m_ptr, "CDistanceRemainingMetricEvaluator", "m_bFilterGoalDistance", false, value);
}
bool GCDistanceRemainingMetricEvaluator::GetFilterGoalOvershoot() const {
    return GetSchemaValue<bool>(m_ptr, "CDistanceRemainingMetricEvaluator", "m_bFilterGoalOvershoot");
}
void GCDistanceRemainingMetricEvaluator::SetFilterGoalOvershoot(bool value) {
    SetSchemaValue(m_ptr, "CDistanceRemainingMetricEvaluator", "m_bFilterGoalOvershoot", false, value);
}
void* GCDistanceRemainingMetricEvaluator::GetPtr() {
    return m_ptr;
}
std::string GCDistanceRemainingMetricEvaluator::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCDistanceRemainingMetricEvaluator::IsValid() {
    return (m_ptr != nullptr);
}
GCMotionMetricEvaluator GCDistanceRemainingMetricEvaluator::GetParent() const {
    GCMotionMetricEvaluator value(m_ptr);
    return value;
}
void GCDistanceRemainingMetricEvaluator::SetParent(GCMotionMetricEvaluator value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCDistanceRemainingMetricEvaluator(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCDistanceRemainingMetricEvaluator>("CDistanceRemainingMetricEvaluator")
        .addConstructor<void (*)(std::string)>()
        .addProperty("MaxDistance", &GCDistanceRemainingMetricEvaluator::GetMaxDistance, &GCDistanceRemainingMetricEvaluator::SetMaxDistance)
        .addProperty("MinDistance", &GCDistanceRemainingMetricEvaluator::GetMinDistance, &GCDistanceRemainingMetricEvaluator::SetMinDistance)
        .addProperty("StartGoalFilterDistance", &GCDistanceRemainingMetricEvaluator::GetStartGoalFilterDistance, &GCDistanceRemainingMetricEvaluator::SetStartGoalFilterDistance)
        .addProperty("MaxGoalOvershootScale", &GCDistanceRemainingMetricEvaluator::GetMaxGoalOvershootScale, &GCDistanceRemainingMetricEvaluator::SetMaxGoalOvershootScale)
        .addProperty("FilterFixedMinDistance", &GCDistanceRemainingMetricEvaluator::GetFilterFixedMinDistance, &GCDistanceRemainingMetricEvaluator::SetFilterFixedMinDistance)
        .addProperty("FilterGoalDistance", &GCDistanceRemainingMetricEvaluator::GetFilterGoalDistance, &GCDistanceRemainingMetricEvaluator::SetFilterGoalDistance)
        .addProperty("FilterGoalOvershoot", &GCDistanceRemainingMetricEvaluator::GetFilterGoalOvershoot, &GCDistanceRemainingMetricEvaluator::SetFilterGoalOvershoot)
        .addProperty("Parent", &GCDistanceRemainingMetricEvaluator::GetParent, &GCDistanceRemainingMetricEvaluator::SetParent)
        .addFunction("ToPtr", &GCDistanceRemainingMetricEvaluator::ToPtr)
        .addFunction("IsValid", &GCDistanceRemainingMetricEvaluator::IsValid)
        .endClass();
}
GVMixDynamicsBand_t::GVMixDynamicsBand_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GVMixDynamicsBand_t::GVMixDynamicsBand_t(void *ptr) {
    m_ptr = ptr;
}
float GVMixDynamicsBand_t::GetFldbGainInput() const {
    return GetSchemaValue<float>(m_ptr, "VMixDynamicsBand_t", "m_fldbGainInput");
}
void GVMixDynamicsBand_t::SetFldbGainInput(float value) {
    SetSchemaValue(m_ptr, "VMixDynamicsBand_t", "m_fldbGainInput", true, value);
}
float GVMixDynamicsBand_t::GetFldbGainOutput() const {
    return GetSchemaValue<float>(m_ptr, "VMixDynamicsBand_t", "m_fldbGainOutput");
}
void GVMixDynamicsBand_t::SetFldbGainOutput(float value) {
    SetSchemaValue(m_ptr, "VMixDynamicsBand_t", "m_fldbGainOutput", true, value);
}
float GVMixDynamicsBand_t::GetFldbThresholdBelow() const {
    return GetSchemaValue<float>(m_ptr, "VMixDynamicsBand_t", "m_fldbThresholdBelow");
}
void GVMixDynamicsBand_t::SetFldbThresholdBelow(float value) {
    SetSchemaValue(m_ptr, "VMixDynamicsBand_t", "m_fldbThresholdBelow", true, value);
}
float GVMixDynamicsBand_t::GetFldbThresholdAbove() const {
    return GetSchemaValue<float>(m_ptr, "VMixDynamicsBand_t", "m_fldbThresholdAbove");
}
void GVMixDynamicsBand_t::SetFldbThresholdAbove(float value) {
    SetSchemaValue(m_ptr, "VMixDynamicsBand_t", "m_fldbThresholdAbove", true, value);
}
float GVMixDynamicsBand_t::GetRatioBelow() const {
    return GetSchemaValue<float>(m_ptr, "VMixDynamicsBand_t", "m_flRatioBelow");
}
void GVMixDynamicsBand_t::SetRatioBelow(float value) {
    SetSchemaValue(m_ptr, "VMixDynamicsBand_t", "m_flRatioBelow", true, value);
}
float GVMixDynamicsBand_t::GetRatioAbove() const {
    return GetSchemaValue<float>(m_ptr, "VMixDynamicsBand_t", "m_flRatioAbove");
}
void GVMixDynamicsBand_t::SetRatioAbove(float value) {
    SetSchemaValue(m_ptr, "VMixDynamicsBand_t", "m_flRatioAbove", true, value);
}
float GVMixDynamicsBand_t::GetAttackTimeMS() const {
    return GetSchemaValue<float>(m_ptr, "VMixDynamicsBand_t", "m_flAttackTimeMS");
}
void GVMixDynamicsBand_t::SetAttackTimeMS(float value) {
    SetSchemaValue(m_ptr, "VMixDynamicsBand_t", "m_flAttackTimeMS", true, value);
}
float GVMixDynamicsBand_t::GetReleaseTimeMS() const {
    return GetSchemaValue<float>(m_ptr, "VMixDynamicsBand_t", "m_flReleaseTimeMS");
}
void GVMixDynamicsBand_t::SetReleaseTimeMS(float value) {
    SetSchemaValue(m_ptr, "VMixDynamicsBand_t", "m_flReleaseTimeMS", true, value);
}
bool GVMixDynamicsBand_t::GetEnable() const {
    return GetSchemaValue<bool>(m_ptr, "VMixDynamicsBand_t", "m_bEnable");
}
void GVMixDynamicsBand_t::SetEnable(bool value) {
    SetSchemaValue(m_ptr, "VMixDynamicsBand_t", "m_bEnable", true, value);
}
bool GVMixDynamicsBand_t::GetSolo() const {
    return GetSchemaValue<bool>(m_ptr, "VMixDynamicsBand_t", "m_bSolo");
}
void GVMixDynamicsBand_t::SetSolo(bool value) {
    SetSchemaValue(m_ptr, "VMixDynamicsBand_t", "m_bSolo", true, value);
}
void* GVMixDynamicsBand_t::GetPtr() {
    return m_ptr;
}
std::string GVMixDynamicsBand_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GVMixDynamicsBand_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassVMixDynamicsBand_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GVMixDynamicsBand_t>("VMixDynamicsBand_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("FldbGainInput", &GVMixDynamicsBand_t::GetFldbGainInput, &GVMixDynamicsBand_t::SetFldbGainInput)
        .addProperty("FldbGainOutput", &GVMixDynamicsBand_t::GetFldbGainOutput, &GVMixDynamicsBand_t::SetFldbGainOutput)
        .addProperty("FldbThresholdBelow", &GVMixDynamicsBand_t::GetFldbThresholdBelow, &GVMixDynamicsBand_t::SetFldbThresholdBelow)
        .addProperty("FldbThresholdAbove", &GVMixDynamicsBand_t::GetFldbThresholdAbove, &GVMixDynamicsBand_t::SetFldbThresholdAbove)
        .addProperty("RatioBelow", &GVMixDynamicsBand_t::GetRatioBelow, &GVMixDynamicsBand_t::SetRatioBelow)
        .addProperty("RatioAbove", &GVMixDynamicsBand_t::GetRatioAbove, &GVMixDynamicsBand_t::SetRatioAbove)
        .addProperty("AttackTimeMS", &GVMixDynamicsBand_t::GetAttackTimeMS, &GVMixDynamicsBand_t::SetAttackTimeMS)
        .addProperty("ReleaseTimeMS", &GVMixDynamicsBand_t::GetReleaseTimeMS, &GVMixDynamicsBand_t::SetReleaseTimeMS)
        .addProperty("Enable", &GVMixDynamicsBand_t::GetEnable, &GVMixDynamicsBand_t::SetEnable)
        .addProperty("Solo", &GVMixDynamicsBand_t::GetSolo, &GVMixDynamicsBand_t::SetSolo)
        .addFunction("ToPtr", &GVMixDynamicsBand_t::ToPtr)
        .addFunction("IsValid", &GVMixDynamicsBand_t::IsValid)
        .endClass();
}
GRnCapsule_t::GRnCapsule_t(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GRnCapsule_t::GRnCapsule_t(void *ptr) {
    m_ptr = ptr;
}
std::vector<Vector> GRnCapsule_t::GetCenter() const {
    Vector* outValue = (Vector*)GetSchemaPtr(m_ptr, "RnCapsule_t", "m_vCenter"); std::vector<Vector> ret; for(int i = 0; i < 2; i++) { ret.push_back(outValue[i]); } return ret;
}
void GRnCapsule_t::SetCenter(std::vector<Vector> value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Center' is not possible.\n");
}
float GRnCapsule_t::GetRadius() const {
    return GetSchemaValue<float>(m_ptr, "RnCapsule_t", "m_flRadius");
}
void GRnCapsule_t::SetRadius(float value) {
    SetSchemaValue(m_ptr, "RnCapsule_t", "m_flRadius", true, value);
}
void* GRnCapsule_t::GetPtr() {
    return m_ptr;
}
std::string GRnCapsule_t::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GRnCapsule_t::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassRnCapsule_t(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GRnCapsule_t>("RnCapsule_t")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Center", &GRnCapsule_t::GetCenter, &GRnCapsule_t::SetCenter)
        .addProperty("Radius", &GRnCapsule_t::GetRadius, &GRnCapsule_t::SetRadius)
        .addFunction("ToPtr", &GRnCapsule_t::ToPtr)
        .addFunction("IsValid", &GRnCapsule_t::IsValid)
        .endClass();
}
GCAnimInputDamping::GCAnimInputDamping(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCAnimInputDamping::GCAnimInputDamping(void *ptr) {
    m_ptr = ptr;
}
uint64_t GCAnimInputDamping::GetSpeedFunction() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CAnimInputDamping", "m_speedFunction");
}
void GCAnimInputDamping::SetSpeedFunction(uint64_t value) {
    SetSchemaValue(m_ptr, "CAnimInputDamping", "m_speedFunction", false, value);
}
float GCAnimInputDamping::GetSpeedScale() const {
    return GetSchemaValue<float>(m_ptr, "CAnimInputDamping", "m_fSpeedScale");
}
void GCAnimInputDamping::SetSpeedScale(float value) {
    SetSchemaValue(m_ptr, "CAnimInputDamping", "m_fSpeedScale", false, value);
}
void* GCAnimInputDamping::GetPtr() {
    return m_ptr;
}
std::string GCAnimInputDamping::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCAnimInputDamping::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCAnimInputDamping(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCAnimInputDamping>("CAnimInputDamping")
        .addConstructor<void (*)(std::string)>()
        .addProperty("SpeedFunction", &GCAnimInputDamping::GetSpeedFunction, &GCAnimInputDamping::SetSpeedFunction)
        .addProperty("SpeedScale", &GCAnimInputDamping::GetSpeedScale, &GCAnimInputDamping::SetSpeedScale)
        .addFunction("ToPtr", &GCAnimInputDamping::ToPtr)
        .addFunction("IsValid", &GCAnimInputDamping::IsValid)
        .endClass();
}
GAnimTagID::GAnimTagID(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GAnimTagID::GAnimTagID(void *ptr) {
    m_ptr = ptr;
}
uint32_t GAnimTagID::GetId() const {
    return GetSchemaValue<uint32_t>(m_ptr, "AnimTagID", "m_id");
}
void GAnimTagID::SetId(uint32_t value) {
    SetSchemaValue(m_ptr, "AnimTagID", "m_id", false, value);
}
void* GAnimTagID::GetPtr() {
    return m_ptr;
}
std::string GAnimTagID::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GAnimTagID::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassAnimTagID(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GAnimTagID>("AnimTagID")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Id", &GAnimTagID::GetId, &GAnimTagID::SetId)
        .addFunction("ToPtr", &GAnimTagID::ToPtr)
        .addFunction("IsValid", &GAnimTagID::IsValid)
        .endClass();
}
GCParticleFunctionPreEmission::GCParticleFunctionPreEmission(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCParticleFunctionPreEmission::GCParticleFunctionPreEmission(void *ptr) {
    m_ptr = ptr;
}
bool GCParticleFunctionPreEmission::GetRunOnce() const {
    return GetSchemaValue<bool>(m_ptr, "CParticleFunctionPreEmission", "m_bRunOnce");
}
void GCParticleFunctionPreEmission::SetRunOnce(bool value) {
    SetSchemaValue(m_ptr, "CParticleFunctionPreEmission", "m_bRunOnce", false, value);
}
void* GCParticleFunctionPreEmission::GetPtr() {
    return m_ptr;
}
std::string GCParticleFunctionPreEmission::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCParticleFunctionPreEmission::IsValid() {
    return (m_ptr != nullptr);
}
GCParticleFunctionOperator GCParticleFunctionPreEmission::GetParent() const {
    GCParticleFunctionOperator value(m_ptr);
    return value;
}
void GCParticleFunctionPreEmission::SetParent(GCParticleFunctionOperator value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCParticleFunctionPreEmission(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCParticleFunctionPreEmission>("CParticleFunctionPreEmission")
        .addConstructor<void (*)(std::string)>()
        .addProperty("RunOnce", &GCParticleFunctionPreEmission::GetRunOnce, &GCParticleFunctionPreEmission::SetRunOnce)
        .addProperty("Parent", &GCParticleFunctionPreEmission::GetParent, &GCParticleFunctionPreEmission::SetParent)
        .addFunction("ToPtr", &GCParticleFunctionPreEmission::ToPtr)
        .addFunction("IsValid", &GCParticleFunctionPreEmission::IsValid)
        .endClass();
}
GCPerParticleFloatInput::GCPerParticleFloatInput(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCPerParticleFloatInput::GCPerParticleFloatInput(void *ptr) {
    m_ptr = ptr;
}
void* GCPerParticleFloatInput::GetPtr() {
    return m_ptr;
}
std::string GCPerParticleFloatInput::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCPerParticleFloatInput::IsValid() {
    return (m_ptr != nullptr);
}
GCParticleFloatInput GCPerParticleFloatInput::GetParent() const {
    GCParticleFloatInput value(m_ptr);
    return value;
}
void GCPerParticleFloatInput::SetParent(GCParticleFloatInput value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCPerParticleFloatInput(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCPerParticleFloatInput>("CPerParticleFloatInput")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Parent", &GCPerParticleFloatInput::GetParent, &GCPerParticleFloatInput::SetParent)
        .addFunction("ToPtr", &GCPerParticleFloatInput::ToPtr)
        .addFunction("IsValid", &GCPerParticleFloatInput::IsValid)
        .endClass();
}
GCSosGroupActionSchema::GCSosGroupActionSchema(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCSosGroupActionSchema::GCSosGroupActionSchema(void *ptr) {
    m_ptr = ptr;
}
std::string GCSosGroupActionSchema::GetName() const {
    return GetSchemaValue<CUtlString>(m_ptr, "CSosGroupActionSchema", "m_name").Get();
}
void GCSosGroupActionSchema::SetName(std::string value) {
    SetSchemaValue(m_ptr, "CSosGroupActionSchema", "m_name", false, CUtlString(value.c_str()));
}
uint64_t GCSosGroupActionSchema::GetActionType() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CSosGroupActionSchema", "m_actionType");
}
void GCSosGroupActionSchema::SetActionType(uint64_t value) {
    SetSchemaValue(m_ptr, "CSosGroupActionSchema", "m_actionType", false, value);
}
uint64_t GCSosGroupActionSchema::GetActionInstanceType() const {
    return GetSchemaValue<uint64_t>(m_ptr, "CSosGroupActionSchema", "m_actionInstanceType");
}
void GCSosGroupActionSchema::SetActionInstanceType(uint64_t value) {
    SetSchemaValue(m_ptr, "CSosGroupActionSchema", "m_actionInstanceType", false, value);
}
void* GCSosGroupActionSchema::GetPtr() {
    return m_ptr;
}
std::string GCSosGroupActionSchema::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCSosGroupActionSchema::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCSosGroupActionSchema(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCSosGroupActionSchema>("CSosGroupActionSchema")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Name", &GCSosGroupActionSchema::GetName, &GCSosGroupActionSchema::SetName)
        .addProperty("ActionType", &GCSosGroupActionSchema::GetActionType, &GCSosGroupActionSchema::SetActionType)
        .addProperty("ActionInstanceType", &GCSosGroupActionSchema::GetActionInstanceType, &GCSosGroupActionSchema::SetActionInstanceType)
        .addFunction("ToPtr", &GCSosGroupActionSchema::ToPtr)
        .addFunction("IsValid", &GCSosGroupActionSchema::IsValid)
        .endClass();
}
GCFutureFacingMetricEvaluator::GCFutureFacingMetricEvaluator(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCFutureFacingMetricEvaluator::GCFutureFacingMetricEvaluator(void *ptr) {
    m_ptr = ptr;
}
float GCFutureFacingMetricEvaluator::GetDistance() const {
    return GetSchemaValue<float>(m_ptr, "CFutureFacingMetricEvaluator", "m_flDistance");
}
void GCFutureFacingMetricEvaluator::SetDistance(float value) {
    SetSchemaValue(m_ptr, "CFutureFacingMetricEvaluator", "m_flDistance", false, value);
}
float GCFutureFacingMetricEvaluator::GetTime() const {
    return GetSchemaValue<float>(m_ptr, "CFutureFacingMetricEvaluator", "m_flTime");
}
void GCFutureFacingMetricEvaluator::SetTime(float value) {
    SetSchemaValue(m_ptr, "CFutureFacingMetricEvaluator", "m_flTime", false, value);
}
void* GCFutureFacingMetricEvaluator::GetPtr() {
    return m_ptr;
}
std::string GCFutureFacingMetricEvaluator::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCFutureFacingMetricEvaluator::IsValid() {
    return (m_ptr != nullptr);
}
GCMotionMetricEvaluator GCFutureFacingMetricEvaluator::GetParent() const {
    GCMotionMetricEvaluator value(m_ptr);
    return value;
}
void GCFutureFacingMetricEvaluator::SetParent(GCMotionMetricEvaluator value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCFutureFacingMetricEvaluator(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCFutureFacingMetricEvaluator>("CFutureFacingMetricEvaluator")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Distance", &GCFutureFacingMetricEvaluator::GetDistance, &GCFutureFacingMetricEvaluator::SetDistance)
        .addProperty("Time", &GCFutureFacingMetricEvaluator::GetTime, &GCFutureFacingMetricEvaluator::SetTime)
        .addProperty("Parent", &GCFutureFacingMetricEvaluator::GetParent, &GCFutureFacingMetricEvaluator::SetParent)
        .addFunction("ToPtr", &GCFutureFacingMetricEvaluator::ToPtr)
        .addFunction("IsValid", &GCFutureFacingMetricEvaluator::IsValid)
        .endClass();
}
GCSeqTransition::GCSeqTransition(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCSeqTransition::GCSeqTransition(void *ptr) {
    m_ptr = ptr;
}
float GCSeqTransition::GetFadeInTime() const {
    return GetSchemaValue<float>(m_ptr, "CSeqTransition", "m_flFadeInTime");
}
void GCSeqTransition::SetFadeInTime(float value) {
    SetSchemaValue(m_ptr, "CSeqTransition", "m_flFadeInTime", false, value);
}
float GCSeqTransition::GetFadeOutTime() const {
    return GetSchemaValue<float>(m_ptr, "CSeqTransition", "m_flFadeOutTime");
}
void GCSeqTransition::SetFadeOutTime(float value) {
    SetSchemaValue(m_ptr, "CSeqTransition", "m_flFadeOutTime", false, value);
}
void* GCSeqTransition::GetPtr() {
    return m_ptr;
}
std::string GCSeqTransition::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCSeqTransition::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCSeqTransition(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCSeqTransition>("CSeqTransition")
        .addConstructor<void (*)(std::string)>()
        .addProperty("FadeInTime", &GCSeqTransition::GetFadeInTime, &GCSeqTransition::SetFadeInTime)
        .addProperty("FadeOutTime", &GCSeqTransition::GetFadeOutTime, &GCSeqTransition::SetFadeOutTime)
        .addFunction("ToPtr", &GCSeqTransition::ToPtr)
        .addFunction("IsValid", &GCSeqTransition::IsValid)
        .endClass();
}
GCAnimNodePath::GCAnimNodePath(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCAnimNodePath::GCAnimNodePath(void *ptr) {
    m_ptr = ptr;
}
std::vector<GAnimNodeID> GCAnimNodePath::GetPath() const {
    GAnimNodeID* outValue = (GAnimNodeID*)GetSchemaPtr(m_ptr, "CAnimNodePath", "m_path"); std::vector<GAnimNodeID> ret; for(int i = 0; i < 11; i++) { ret.push_back(outValue[i]); } return ret;
}
void GCAnimNodePath::SetPath(std::vector<GAnimNodeID> value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Path' is not possible.\n");
}
int32_t GCAnimNodePath::GetCount() const {
    return GetSchemaValue<int32_t>(m_ptr, "CAnimNodePath", "m_nCount");
}
void GCAnimNodePath::SetCount(int32_t value) {
    SetSchemaValue(m_ptr, "CAnimNodePath", "m_nCount", false, value);
}
void* GCAnimNodePath::GetPtr() {
    return m_ptr;
}
std::string GCAnimNodePath::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCAnimNodePath::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCAnimNodePath(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCAnimNodePath>("CAnimNodePath")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Path", &GCAnimNodePath::GetPath, &GCAnimNodePath::SetPath)
        .addProperty("Count", &GCAnimNodePath::GetCount, &GCAnimNodePath::SetCount)
        .addFunction("ToPtr", &GCAnimNodePath::ToPtr)
        .addFunction("IsValid", &GCAnimNodePath::IsValid)
        .endClass();
}
GCParamSpanUpdater::GCParamSpanUpdater(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCParamSpanUpdater::GCParamSpanUpdater(void *ptr) {
    m_ptr = ptr;
}
std::vector<GParamSpan_t> GCParamSpanUpdater::GetSpans() const {
    CUtlVector<GParamSpan_t>* vec = GetSchemaValue<CUtlVector<GParamSpan_t>*>(m_ptr, "CParamSpanUpdater", "m_spans"); std::vector<GParamSpan_t> outVec; for(int i = 0; i < vec->Count(); i++) { outVec.push_back(vec->Element(i)); } return outVec;
}
void GCParamSpanUpdater::SetSpans(std::vector<GParamSpan_t> value) {
    SetSchemaValueCUtlVector<GParamSpan_t>(m_ptr, "CParamSpanUpdater", "m_spans", false, value);
}
void* GCParamSpanUpdater::GetPtr() {
    return m_ptr;
}
std::string GCParamSpanUpdater::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCParamSpanUpdater::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassCParamSpanUpdater(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCParamSpanUpdater>("CParamSpanUpdater")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Spans", &GCParamSpanUpdater::GetSpans, &GCParamSpanUpdater::SetSpans)
        .addFunction("ToPtr", &GCParamSpanUpdater::ToPtr)
        .addFunction("IsValid", &GCParamSpanUpdater::IsValid)
        .endClass();
}
GAnimNodeID::GAnimNodeID(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GAnimNodeID::GAnimNodeID(void *ptr) {
    m_ptr = ptr;
}
uint32_t GAnimNodeID::GetId() const {
    return GetSchemaValue<uint32_t>(m_ptr, "AnimNodeID", "m_id");
}
void GAnimNodeID::SetId(uint32_t value) {
    SetSchemaValue(m_ptr, "AnimNodeID", "m_id", false, value);
}
void* GAnimNodeID::GetPtr() {
    return m_ptr;
}
std::string GAnimNodeID::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GAnimNodeID::IsValid() {
    return (m_ptr != nullptr);
}
void SetupLuaClassAnimNodeID(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GAnimNodeID>("AnimNodeID")
        .addConstructor<void (*)(std::string)>()
        .addProperty("Id", &GAnimNodeID::GetId, &GAnimNodeID::SetId)
        .addFunction("ToPtr", &GAnimNodeID::ToPtr)
        .addFunction("IsValid", &GAnimNodeID::IsValid)
        .endClass();
}
GCParticleFunctionInitializer::GCParticleFunctionInitializer(std::string ptr) {
    m_ptr = (void*)(strtol(ptr.c_str(), nullptr, 16));
}
GCParticleFunctionInitializer::GCParticleFunctionInitializer(void *ptr) {
    m_ptr = ptr;
}
int32_t GCParticleFunctionInitializer::GetAssociatedEmitterIndex() const {
    return GetSchemaValue<int32_t>(m_ptr, "CParticleFunctionInitializer", "m_nAssociatedEmitterIndex");
}
void GCParticleFunctionInitializer::SetAssociatedEmitterIndex(int32_t value) {
    SetSchemaValue(m_ptr, "CParticleFunctionInitializer", "m_nAssociatedEmitterIndex", false, value);
}
void* GCParticleFunctionInitializer::GetPtr() {
    return m_ptr;
}
std::string GCParticleFunctionInitializer::ToPtr() {
    return string_format("%p", m_ptr);
}
bool GCParticleFunctionInitializer::IsValid() {
    return (m_ptr != nullptr);
}
GCParticleFunction GCParticleFunctionInitializer::GetParent() const {
    GCParticleFunction value(m_ptr);
    return value;
}
void GCParticleFunctionInitializer::SetParent(GCParticleFunction value) {
    PLUGIN_PRINT("Schema SDK", "Setting a value for 'Parent' is not possible.\n");
}
void SetupLuaClassCParticleFunctionInitializer(LuaPlugin *plugin, lua_State *state)
{
    luabridge::getGlobalNamespace(state)
        .beginClass<GCParticleFunctionInitializer>("CParticleFunctionInitializer")
        .addConstructor<void (*)(std::string)>()
        .addProperty("AssociatedEmitterIndex", &GCParticleFunctionInitializer::GetAssociatedEmitterIndex, &GCParticleFunctionInitializer::SetAssociatedEmitterIndex)
        .addProperty("Parent", &GCParticleFunctionInitializer::GetParent, &GCParticleFunctionInitializer::SetParent)
        .addFunction("ToPtr", &GCParticleFunctionInitializer::ToPtr)
        .addFunction("IsValid", &GCParticleFunctionInitializer::IsValid)
        .endClass();
}